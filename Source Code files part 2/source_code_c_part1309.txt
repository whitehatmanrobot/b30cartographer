define IDS_SUCCEEDED				6014
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\cert2spc\cert2spc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       Cert2Spc.cpp
//
//  Contents:   Copy certs and/or CRLs to a SPC file.
//
//              A SPC file is an ASN.1 encoded PKCS #7 SignedData message
//              containing certificates and/or CRLs.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    05-May-96     philh   created
//  History:    08-August-97  xiaohs  input can be a spc, serialized store
//              
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "resource.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include <dbgdef.h>	
#include <unicode.h>	 
#include <wchar.h>

#include "toolutl.h"


//--------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

HMODULE		hModule=NULL;

#define		ITEM_CERT				0x00000001
#define		ITEM_CTL				0x00000002
#define		ITEM_CRL				0x00000004


//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}



//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init 
//---------------------------------------------------------------------------
static void Usage(void)
{
	IDSwprintf(hModule, IDS_SYNTAX);
}


BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem);


//---------------------------------------------------------------------------
//	 wmain
//---------------------------------------------------------------------------
extern "C" int __cdecl
wmain(int argc, WCHAR *wargv[])
{
    int			ReturnStatus=-1;
    HCERTSTORE  hStore = NULL;
	HCERTSTORE	hFileStore=NULL;
    HANDLE		hFile = INVALID_HANDLE_VALUE;
    LPWSTR		pwszFilename=NULL;

    BYTE		*pbEncoded = NULL;
    DWORD		cbEncoded =0;


    if (argc < 3)
	{
		Usage();
		return -1;
    }


	if(!InitModule())
		return -1;


	// Open temp store to contain the certs and/or CRLs to be written
    // to the spc file
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwCertEncodingType
            0,                      // hCryptProv,
            0,                      // dwFlags
            NULL                    // pvPara
            ))) 
	{
        IDSwprintf(hModule,IDS_CAN_NOT_OPEN_STORE);
        goto ErrorReturn;
    }

	//If there is any .crt or .crl file left
    while (--argc > 1)
    {	
       
		pwszFilename = *(++wargv);

		if (S_OK != RetrieveBLOBFromFile(pwszFilename, &cbEncoded, &pbEncoded))
		{
			IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
			goto ErrorReturn;
		}

		//deal with .crl file
        if (!CertAddEncodedCRLToStore(
                        hStore,
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL                // ppCrlContext
                        )) 
		{

			//open a certificate store
			hFileStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
								X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
								NULL,
								0,
								pwszFilename);

			if(!hFileStore)
			{
				IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
				goto ErrorReturn;
            }

			//copy all the certs and CRLs from hFileStore to hStore
			if(!MoveItem(hFileStore, hStore, ITEM_CERT|ITEM_CRL))
			{
				IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
				goto ErrorReturn;
			} 

			//close store
			CertCloseStore(hFileStore, 0);
			hFileStore=NULL;
        }
    
		UnmapViewOfFile(pbEncoded);
        pbEncoded = NULL;
		cbEncoded=0;
	
    }

	pwszFilename = *(++wargv);

    hFile = CreateFileU(
            pwszFilename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) 
	{
        IDSwprintf(hModule, IDS_CAN_NOT_OPEN_FILE, pwszFilename);
        goto ErrorReturn;
    }

    if (!CertSaveStore(hStore,
		X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		CERT_STORE_SAVE_AS_PKCS7,
		CERT_STORE_SAVE_TO_FILE,
		(void *)hFile,
		0					//dwFlags
		)) 
	{
        DWORD dwErr = GetLastError();
        IDSwprintf(hModule, IDS_ERROR_OUTPUT, dwErr, dwErr);
        goto ErrorReturn;
    }

    ReturnStatus = 0;
	IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;
            


ErrorReturn:
    ReturnStatus = -1;
	//print out an error msg
	IDSwprintf(hModule, IDS_FAILED);
CommonReturn:
    if (pbEncoded)
        UnmapViewOfFile(pbEncoded);

	if (hFileStore)
		CertCloseStore(hFileStore, 0);

    if (hStore)
        CertCloseStore(hStore, 0);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return ReturnStatus;
}

//-------------------------------------------------------------------------
//
//	Move Certs/CRls/CTLs from the source store to the destination
//
//-------------------------------------------------------------------------
BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {

			if(!CertAddCertificateContextToStore(hDesStore,
												pCertContext,
												CERT_STORE_ADD_REPLACE_EXISTING,
												NULL))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			if(!CertAddCTLContextToStore(hDesStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			if(!CertAddCRLContextToStore(hDesStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certhlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlp.h
//
//  Contents:   the header for certhlp.cpp, the helper functions for 
//				CertMgr tool 
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef CERTHLP_H
#define CERTHLP_H



#ifdef __cplusplus
extern "C" {
#endif	 


BOOL	CheckParameter();

BOOL	ParseSwitch (int	*pArgc, WCHAR	**pArgv[]);

void Usage(void);

void UndocumentedUsage();

BOOL	InitModule();

wchar_t *IDSwcscat(HMODULE hModule, WCHAR *pwsz, int idsString);


BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue);

BOOL	OpenGenericStore(LPWSTR			wszStoreName,
						 BOOL			fSystemStore,
						 DWORD			dwStoreFlag,
						 LPSTR			szStoreProvider,
						 DWORD			dwStoreOpenFlag,
						 BOOL			fCheckExist,
						 HCERTSTORE		*phCertStore);

BOOL	AddCertStore(HCERTSTORE	hCertStore);

BOOL	DeleteCertStore(HCERTSTORE	hCertStore);

BOOL	PutCertStore(HCERTSTORE	hCertStore);

BOOL	SaveStore(HCERTSTORE hSrcStore);

BOOL	SetEKUProperty( HCERTSTORE		hSrcStore);

BOOL	SetNameProperty( HCERTSTORE		hSrcStore);


PCCRL_CONTEXT	FindCRLInStore(HCERTSTORE hCertStore,
							   CRYPT_HASH_BLOB	*pBlob);


BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem);


BOOL	DeleteItem(HCERTSTORE	hSrcStore, 
				 DWORD		dwItem);


BOOL	DisplayCertAndPrompt(PCCERT_CONTEXT	*rgpCertContext, 
							 DWORD			dwCertCount, 
							 DWORD			*pdwIndex);

BOOL	DisplayCRLAndPrompt(PCCRL_CONTEXT	*rgpCRLContext, 
							 DWORD			dwCRLCount, 
							 DWORD			*pdwIndex);


BOOL	DisplayCTLAndPrompt(PCCTL_CONTEXT	*rgpCTLContext, 
							 DWORD			dwCTLCount, 
							 DWORD			*pdwIndex);


BOOL	BuildCertList(HCERTSTORE		hCertStore, 
					  LPWSTR			wszCertCN, 
					  PCCERT_CONTEXT	**prgpCertContext,
					  DWORD				*pdwCertCount);


BOOL	BuildCRLList(	HCERTSTORE		hCertStore, 
						PCCRL_CONTEXT	**prgpCRLContext,
						DWORD			*pdwCRLCount);


BOOL	BuildCTLList(	HCERTSTORE		hCertStore, 
						PCCTL_CONTEXT	**prgpCTLContext,
						DWORD			*pdwCTLCount);


BOOL	DisplayCertStore(HCERTSTORE	hCertStore);

BOOL	DisplayCert(PCCERT_CONTEXT	pCertContext, DWORD	dwItem);


BOOL	DisplayCTL(PCCTL_CONTEXT	pCTLContext, DWORD	dwItem);

BOOL	DisplayCRL(PCCRL_CONTEXT	pCRLContext, DWORD	dwItem);


BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem);


HCERTSTORE OpenSipStore(LPWSTR pwszStoreFilename);

HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);

HRESULT Base64ToBytesW(WCHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);

BOOL	GetBase64Decoded(LPWSTR		wszStoreName, 
						 BYTE		**ppbByte,
						 DWORD		*pcbByte);

HCERTSTORE OpenEncodedCRL(LPWSTR pwszStoreFilename);

HCERTSTORE OpenEncodedCTL (LPWSTR pwszStoreFilename);

HCERTSTORE OpenEncodedCert (LPWSTR pwszStoreFilename);

BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue);

HRESULT	WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD	*pcbByte);

 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );

BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER);

 BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


 void PrintCtlEntries(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlag);

 void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry,
        DWORD dwDisplayFlags);

BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem);

void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize);


 void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwItem);


 void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags);


 void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags);


 void DisplayThumbprint(
    LPWSTR pwszHash,
    BYTE *pbHash,
    DWORD cbHash
    );

LPWSTR FileTimeText(FILETIME *pft);

 void PrintAuxCertProperties(PCCERT_CONTEXT pCert,DWORD dwDisplayFlags);


 void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    );


 BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags);

 void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags);

 void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

  void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

void DisplaySpcLink(PSPC_LINK pSpcLink);


 void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayPoliciesExtension(
    int		idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayKeyUsage(BYTE	bFlag);

 void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayAltNameExtension(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayAnyString(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBits(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayOctetString(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0);

BOOL	InstalledFormat(LPSTR	szStructType, BYTE	*pbEncoded, DWORD cbEncoded);

 WCHAR *GuidText(GUID *pguid);


 void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    );

HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz);

 void *TestNoCopyDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbInfo = NULL
    );


BOOL IsTimeValidCtl(IN PCCTL_CONTEXT pCtl);

 void DisplaySerialNumber(PCRYPT_INTEGER_BLOB pSerialNumber);

void ReverseBytes(IN OUT PBYTE pbIn, IN DWORD cbIn);

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId);

 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    );

 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    );

void DisplayTimeStamp(BYTE *pbEncoded,DWORD cbEncoded,DWORD	dwDisplayFlags);

#ifdef __cplusplus
}
#endif

#endif  // CERTHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certhlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       Certhlp.cpp
//
//  Contents:   Certificate store management tools helper functions
//
//
//  History:    July 21st   xiaohs   created
//              
//--------------------------------------------------------------------------

#include "certmgr.h"

//+-------------------------------------------------------------------------
//  GetSignAlgids
//--------------------------------------------------------------------------
 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    )
{
    PCCRYPT_OID_INFO pInfo;

    *paiHash = 0;
    *paiPubKey = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra)
            *paiPubKey = pdwExtra[0];
    }
}

//+-------------------------------------------------------------------------
//  GetAlgid
//--------------------------------------------------------------------------
ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}
//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
 void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto ErrorReturn;
    if (NULL == (pvData = ToolUtlAlloc(cbData)))
        goto ErrorReturn;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        ToolUtlFree(pvData);
        goto ErrorReturn;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
}


////////////////////////////////////////////////////////
//
// Convert STR to WSTR
//
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;
	DWORD	dwError=0;

	assert(pwsz);

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return S_OK;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
	{
		dwError=GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	}

	//allocate memory
	*pwsz=(LPWSTR)ToolUtlAlloc(dwSize * sizeof(WCHAR));

	if(*pwsz==NULL)
		return E_OUTOFMEMORY;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return S_OK;
	}
	else
	{
		 ToolUtlFree(*pwsz);
		 dwError=GetLastError();
		 return HRESULT_FROM_WIN32(dwError);
	}
}

//+-------------------------------------------------------------------------
//  Decode the object and allocate memory
//--------------------------------------------------------------------------
 void *TestNoCopyDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbInfo
    )
{
    BOOL fResult;
    DWORD cbInfo;
    void *pvInfo;

    if (pcbInfo)
        *pcbInfo = 0;
    
    // Set to bogus value. pvInfo == NULL, should cause it to be ignored.
    cbInfo = 0x12345678;
    fResult = CryptDecodeObject(
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) 
        return NULL;

    if (NULL == (pvInfo = ToolUtlAlloc(cbInfo)))
        return NULL;

    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvInfo,
            &cbInfo
            )) 
	{
        ToolUtlFree(pvInfo);
        return NULL;
    }

    if (pcbInfo)
        *pcbInfo = cbInfo;
    return pvInfo;
}


//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;

    // Get current time to be used to determine if CTLs are time valid
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &CurrentTime);

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, &CurrentTime) >= 0)
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Display serial number
//
//--------------------------------------------------------------------------
 void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        printf(" %02X", *pb);
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       CertMgr
//
//  Contents:   Certificate store management tools
//
//              See Usage() for list of options.
//
//
//  Functions:  wmain
//
//  History:    July 21st   xiaohs   created
//              
//--------------------------------------------------------------------------

#include "certmgr.h"

//--------------------------------------------------------------------------
//
// Global Flags
//
//----------------------------------------------------------------------------
#define		ITEM_VERBOSE			0x00010000
#define		ITEM_CERT				0x00000001
#define		ITEM_CTL				0x00000002
#define		ITEM_CRL				0x00000004

#define		ACTION_DISPLAY			0x01
#define		ACTION_ADD				0x02
#define		ACTION_DELETE			0x04
#define     ACTION_PUT              0x08

#define		OPTION_SWITCH_SIZE		10

#define		SHA1_LENGTH				20
#define		MAX_HASH_LEN			20

#define		MAX_STRING_RSC_SIZE		512

//--------------------------------------------------------------------------
//
// Global Variable
//
//----------------------------------------------------------------------------
 
HMODULE	hModule=NULL;

//varibles for installable formatting routines
 HCRYPTOIDFUNCSET hFormatFuncSet;

 const CRYPT_OID_FUNC_ENTRY g_FormatTable[] = {
    szOID_BASIC_CONSTRAINTS2, FormatBasicConstraints2};

 DWORD	g_dwFormatCount=sizeof(g_FormatTable)/sizeof(g_FormatTable[0]);

typedef BOOL (WINAPI *PFN_FORMAT_FUNC)(
	IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    );


//variables for installing OID information
typedef struct _CERTMGR_OID_INFO
{
    LPCSTR              pszOID;
    int					idsOIDName;
}CERTMGR_OID_INFO;

CERTMGR_OID_INFO	g_rgOIDInfo[]={
		SPC_SP_AGENCY_INFO_OBJID,			IDS_SPC_SP_NAME,
		SPC_FINANCIAL_CRITERIA_OBJID,		IDS_SPC_FIN_NAME,
		SPC_MINIMAL_CRITERIA_OBJID,			IDS_SPC_MIN_NAME,
		szOID_NETSCAPE_CERT_TYPE,			IDS_NTSP_CERT_NAME,
		szOID_NETSCAPE_BASE_URL,			IDS_NTSP_BASE_NAME,
		szOID_NETSCAPE_REVOCATION_URL,		IDS_NTSP_REV_NAME,
		szOID_NETSCAPE_CA_REVOCATION_URL,	IDS_NTSP_CA_REV_NAME,
		szOID_NETSCAPE_CERT_RENEWAL_URL,	IDS_NTSP_RENEW_NAME,
		szOID_NETSCAPE_CA_POLICY_URL,		IDS_NTSP_POL_NAME,
		szOID_NETSCAPE_SSL_SERVER_NAME,		IDS_NTSP_SSL_SERVER_NAME,
		szOID_NETSCAPE_COMMENT,				IDS_NTSP_COMMENT};


DWORD	g_dwOIDInfo=sizeof(g_rgOIDInfo)/sizeof(g_rgOIDInfo[0]);

//varibles for string manipulations
WCHAR	g_wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	g_dwBufferSize=sizeof(g_wszBuffer)/sizeof(g_wszBuffer[0]); 


//varibles for options
DWORD		g_dwAction=0;
DWORD		g_dwItem=0;
LPWSTR		g_wszCertEncodingType=NULL;
DWORD		g_dwCertEncodingType = X509_ASN_ENCODING;
DWORD		g_dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD		g_dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
BOOL		g_fSaveAs7 = FALSE;
LPWSTR		g_wszCertCN = NULL;
LPWSTR		g_wszSha1Hash = NULL;
BYTE		*g_pbHash=NULL;
DWORD		g_cbHash=0;
BOOL		g_fAll=FALSE;
HCRYPTMSG	g_hMsg=NULL;
LPWSTR		g_wszEKU=NULL;
LPWSTR      g_wszName=NULL;
BOOL        g_fMulti=FALSE;
BOOL		g_fUndocumented=FALSE;

BOOL		g_fSrcSystemStore = FALSE;
LPWSTR		g_wszSrcStoreLocation=NULL;
DWORD		g_dwSrcStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
LPWSTR		g_wszSrcStoreName=NULL;

BOOL		g_fSameSrcDes=FALSE;
BOOL		g_fDesSystemStore = FALSE;
LPWSTR		g_wszDesStoreLocation=NULL;
DWORD		g_dwDesStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
LPWSTR		g_wszDesStoreName=NULL;

LPWSTR		g_wszSrcStoreProvider = NULL;
LPSTR		g_szSrcStoreProvider = NULL;
LPWSTR		g_wszSrcStoreOpenFlag = NULL;
DWORD		g_dwSrcStoreOpenFlag = 0;	

LPWSTR		g_wszDesStoreProvider = NULL;
LPSTR		g_szDesStoreProvider = NULL;
LPWSTR		g_wszDesStoreOpenFlag = NULL;
DWORD		g_dwDesStoreOpenFlag = 0;	


CHAR		g_szNULL[OPTION_SWITCH_SIZE];
WCHAR		g_wszSHA1[OPTION_SWITCH_SIZE];
WCHAR		g_wszMD5[OPTION_SWITCH_SIZE];
WCHAR		g_wszUnKnown[OPTION_SWITCH_SIZE*2];



//---------------------------------------------------------------------------
//	wmain
//	 
//---------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR *wargv[])
{
    int				ReturnStatus=-1;  

	//variables for parse the options
	WCHAR			*pwChar;
	WCHAR			wszSwitch1[OPTION_SWITCH_SIZE];
	WCHAR			wszSwitch2[OPTION_SWITCH_SIZE];

	HCERTSTORE		hCertStore=NULL;
    CRYPTUI_CERT_MGR_STRUCT          CertMgrStruct;


	//get the module handler
	if(!InitModule())
		goto ErrorReturn;

	//load the strings necessary for parsing the parameters
	if( !LoadStringU(hModule, IDS_SWITCH1,	wszSwitch1, OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2,	OPTION_SWITCH_SIZE)
											//<NULL>
	  ||!LoadStringA(hModule, IDS_NULL,     g_szNULL,  OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SHA1,		g_wszSHA1, 	OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_MD5,      g_wszMD5,  OPTION_SWITCH_SIZE)
											//<UNKNOWN OID>
	  ||!LoadStringU(hModule, IDS_UNKNOWN,	g_wszUnKnown, OPTION_SWITCH_SIZE*2))
		goto ErrorReturn;

    //call the UI versino of certmgr if no parameter is passed
    //memset
    if(1== argc)
    {
        memset(&CertMgrStruct, 0, sizeof(CRYPTUI_CERT_MGR_STRUCT));
        CertMgrStruct.dwSize=sizeof(CRYPTUI_CERT_MGR_STRUCT);

        CryptUIDlgCertMgr(&CertMgrStruct);

        ReturnStatus = 0;
	    IDSwprintf(hModule, IDS_SUCCEEDED);
        goto CommonReturn;
    }


	//parse the parameters
    while (--argc) 
	{
        pwChar = *++wargv;
        if (*pwChar == *wszSwitch1 || *pwChar == *wszSwitch2) 
		{
			//parse the options
            if(!ParseSwitch (&argc, &wargv))
			{
				if(TRUE==g_fUndocumented)
					goto UndocReturn;
				else
					goto UsageReturn;
			}
        } 
		else
		{
			//set the source file name
			if(NULL==g_wszSrcStoreName)
				g_wszSrcStoreName=pwChar;
			else
			{
				//set the destination file name
				if(!SetParam(&g_wszDesStoreName, pwChar))
					goto UsageReturn;
			}
		}
    }

	//check the parameters.  Make sure that they are valid and make sense
	if(!CheckParameter())
		goto UsageReturn;

	//open the destination store, which includes all the CERTS, CRTs, and CTLs
	if(!OpenGenericStore(g_wszSrcStoreName,
						 g_fSrcSystemStore,
						 g_dwSrcStoreFlag,
						 g_szSrcStoreProvider,
						 g_dwSrcStoreOpenFlag,
						 TRUE,
						 &hCertStore))
	{
		IDSwprintf(hModule,IDS_ERR_OPEN_SOURCE_STORE);
		goto ErrorReturn;
	}

	//error if we opened a signed file and there is a delete option with on destination
	if(g_hMsg)
	{
		if(g_dwAction & ACTION_DELETE)
		{
			if(g_fSameSrcDes)
			{
				IDSwprintf(hModule, IDS_ERR_DELETE_SIGNED_FILE);
				goto ErrorReturn;
			}
		}

	}

	//Display
	if(g_dwAction & ACTION_DISPLAY)
	{
		//if the msg is signed, disply the signer info
		if(g_hMsg)
		{
			if(!DisplaySignerInfo(g_hMsg, g_dwItem))
				goto ErrorReturn;
		}

		if(!DisplayCertStore(hCertStore))
			goto ErrorReturn;
	  	
		IDSwprintf(hModule, IDS_SEPERATOR);
	}


	//Delete
	if(g_dwAction & ACTION_DELETE)
	{
		if(!DeleteCertStore(hCertStore))
			goto ErrorReturn;

	}


	//Add
	if(g_dwAction & ACTION_ADD)
	{
		if(!AddCertStore(hCertStore))
			goto ErrorReturn;
	}

    if(g_dwAction & ACTION_PUT)
    {
        if(!PutCertStore(hCertStore))
            goto ErrorReturn;

    }

	//mark succeed
    ReturnStatus = 0;
	IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;
          

UndocReturn:
	//print out the undocuemted Usage
	UndocumentedUsage();
	goto CommonReturn;

//print out the Usage.  
UsageReturn:
	Usage();
	goto CommonReturn;


ErrorReturn:
	//print out an error msg
	IDSwprintf(hModule, IDS_FAILED);
	goto CommonReturn;   


CommonReturn:
	//clean up memory.  Return the status
	if(g_szSrcStoreProvider)
		ToolUtlFree(g_szSrcStoreProvider);

	if(g_szDesStoreProvider)
		ToolUtlFree(g_szDesStoreProvider);

	if(g_pbHash)
		ToolUtlFree(g_pbHash);

	if(g_hMsg)
		CryptMsgClose(g_hMsg);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);
	
	return ReturnStatus;

}

//---------------------------------------------------------------------------
// The private version of wcscat
//----------------------------------------------------------------------------

wchar_t *IDSwcscat(HMODULE hModule, WCHAR *pwsz, int idsString)
{
	//load the string
	if(!LoadStringU(hModule, idsString, g_wszBuffer, g_dwBufferSize))
		return pwsz;

	return wcscat(pwsz, g_wszBuffer);
}

//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	WCHAR			wszOIDName[MAX_STRING_RSC_SIZE];
	DWORD			dwIndex=0;
	CRYPT_OID_INFO	OIDInfo;
	
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;

    //We do not need to do the following any more.

    //the oid information are now in the OID database
	//now, we are installing the format the extensions :
	//BASICCONTRAINTS2
    if (NULL == (hFormatFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                0)))	// dwFlags
	 {
		 IDSwprintf(hModule, IDS_ERR_INIT_OID_SET);
         return FALSE;
	 }

	//install the default formatting routine
	if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                g_dwCertEncodingType,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                g_dwFormatCount,
                g_FormatTable,
                0))                         // dwFlags
    {
		IDSwprintf(hModule, IDS_ERR_INSTALL_OID);
		return FALSE;
	}

	//secondly, we install the OID information

	//init OIDInfo
/*	memset(&OIDInfo, 0, sizeof(CRYPT_OID_INFO));
	OIDInfo.cbSize=sizeof(CRYPT_OID_INFO);
	OIDInfo.dwGroupId=CRYPT_EXT_OR_ATTR_OID_GROUP_ID;

	for(dwIndex=0; dwIndex < g_dwOIDInfo; dwIndex++)
	{
		if(!LoadStringU(hModule, g_rgOIDInfo[dwIndex].idsOIDName,	
			wszOIDName, MAX_STRING_RSC_SIZE))
			return FALSE;
		
		OIDInfo.pszOID=g_rgOIDInfo[dwIndex].pszOID;
		OIDInfo.pwszName=wszOIDName;

		CryptRegisterOIDInfo(&OIDInfo,0);


	}   */

	return TRUE;
}

//---------------------------------------------------------------------------
//	Usage
//	 
//---------------------------------------------------------------------------
 void Usage(void)
{
	IDSwprintf(hModule,IDS_SYNTAX);
	IDSwprintf(hModule,IDS_SYNTAX1);
	IDSwprintf(hModule,IDS_OPTIONS);
	IDSwprintf(hModule,IDS_OPTION_ADD_DESC);			
	IDSwprintf(hModule,IDS_OPTION_DEL_DESC);
	IDSwprintf(hModule,IDS_OPTION_DEL_DESC1);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC1);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC2);
	IDSwprintf(hModule,IDS_OPTION_S_DESC);			
	IDSwprintf(hModule,IDS_OPTION_R_DESC);			
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE,IDS_R_CU,IDS_R_LM,IDS_R_CU);	
	IDSwprintf(hModule,IDS_OPTION_C_DESC);			
	IDSwprintf(hModule,IDS_OPTION_CRL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_CTL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_V_DESC);			
	IDSwprintf(hModule,IDS_OPTION_ALL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_N_DESC);			
	IDSwprintf(hModule,IDS_OPTION_SHA1_DESC);			
	IDSwprintf(hModule,IDS_OPTION_7_DESC);			
	IDSwprintf(hModule,IDS_OPTION_E_DESC);
	IDSwprintf(hModule,IDS_OPTION_E_DESC1);
	IDSwprintf(hModule,IDS_OPTION_F_DESC);
	IDSwprintf(hModule,IDS_OPTION_Y_DESC);
}

//---------------------------------------------------------------------------
//
//	Usage
//	 
//---------------------------------------------------------------------------
void UndocumentedUsage()
{
	IDSwprintf(hModule, IDS_SYNTAX);
	IDSwprintf(hModule, IDS_OPTIONS);
	IDSwprintf(hModule, IDS_OPTION_EKU_DESC);
    IDSwprintf(hModule, IDS_OPTION_NAME_DESC);
    IDSwprintf(hModule, IDS_OPTION_MULTI_DESC);
}

//--------------------------------------------------------------------------------
// Parse arguements
//--------------------------------------------------------------------------------
BOOL 
ParseSwitch (int	*pArgc,
             WCHAR	**pArgv[])
{
    WCHAR* param = **pArgv;

	//move pass '/' or '-'
    param++;

    if (IDSwcsicmp(hModule, param, IDS_OPTION_ADD)==0) {

		g_dwAction |= ACTION_ADD;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_DEL)==0) {

		g_dwAction |= ACTION_DELETE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_PUT)==0) {

		g_dwAction |= ACTION_PUT;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_S)==0) {

		if(NULL==g_wszSrcStoreName)
			g_fSrcSystemStore=TRUE;
		else
			g_fDesSystemStore=TRUE;

		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_R)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;

	   if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreLocation, **pArgv);
	   else
		    return SetParam(&g_wszDesStoreLocation, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_C)==0) {

		g_dwItem |= ITEM_CERT;
		return TRUE;
	}
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_CRL)==0) {

		g_dwItem |= ITEM_CRL;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_CTL)==0) {

		g_dwItem |= ITEM_CTL;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_V)==0) {

		g_dwItem |= ITEM_VERBOSE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_ALL)==0) {

		g_fAll=TRUE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_N)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&g_wszCertCN, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_SHA1)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&g_wszSha1Hash, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_7)==0) {

		g_fSaveAs7=TRUE;
		return TRUE;
	}
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_E)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszCertEncodingType, **pArgv);
    }

    else if(IDSwcsicmp(hModule,param, IDS_OPTION_Y)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreProvider, **pArgv);
		else
			return SetParam(&g_wszDesStoreProvider, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_F)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreOpenFlag, **pArgv);
		else
			return SetParam(&g_wszDesStoreOpenFlag, **pArgv);

    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_EKU)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszEKU, **pArgv);
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_NAME)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszName, **pArgv);
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_MULTI)==0) {

        g_fMulti=TRUE;

        return TRUE;
    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_TEST)==0) {

        g_fUndocumented=TRUE;

		return FALSE;
    }


	return FALSE;
}

//-----------------------------------------------------------------------------
//	Check the parameters
//
//-----------------------------------------------------------------------------
BOOL	CheckParameter()
{
    DWORD   dwItemCount=0;  

	//check actions
	if((g_dwAction & ACTION_ADD) && (g_dwAction & ACTION_DELETE))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

    if((g_dwAction & ACTION_ADD) && (g_dwAction & ACTION_PUT))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

    if((g_dwAction & ACTION_PUT) && (g_dwAction & ACTION_DELETE))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

	if(0==g_dwAction)
		g_dwAction |= ACTION_DISPLAY;

    //-7 and -CTL can not be set at the same time for add or put
    if(TRUE==g_fSaveAs7)
    {
        if(g_dwItem & ITEM_CTL)
        {
            if((g_dwAction & ACTION_ADD) || (g_dwAction & ACTION_PUT))
            {
               IDSwprintf(hModule, IDS_ERR_7_CTL);
               IDSwprintf(hModule, IDS_ERR_7_CTL1);
               return FALSE;
            }
        }
    }

	//-n and -sha1 can not be set at the same time
	if(g_wszCertCN && g_wszSha1Hash)
	{
		IDSwprintf(hModule, IDS_ERR_N_SHA1);
		return FALSE;
	}

	//-all can not be set with -n and -sha1 option
	if(TRUE==g_fAll)
	{
		if(g_wszCertCN || g_wszSha1Hash)
		{
			IDSwprintf(hModule, IDS_ERR_ALL_N_SHA1);
			return FALSE;
		}

	}

	//-y, -f can not be set with -s and -r for source
	if(g_wszSrcStoreProvider || g_wszSrcStoreOpenFlag)
	{
		if((TRUE==g_fSrcSystemStore)||(g_wszSrcStoreLocation))
		{
			IDSwprintf(hModule, IDS_ERR_PROVIDER_SYSTEM);
			return FALSE;
		}
	}

	//-y, -f can not be set with -s and -r	for desitnation
	if(g_wszDesStoreProvider || g_wszDesStoreOpenFlag)
	{
		if((TRUE==g_fDesSystemStore)||(g_wszDesStoreLocation))
		{
			IDSwprintf(hModule, IDS_ERR_PROVIDER_SYSTEM);
			return FALSE;
		}
	}


	//source store has to be set
	if(NULL==g_wszSrcStoreName)
	{
		IDSwprintf(hModule, IDS_ERR_SOURCE_STORE);
		return FALSE;
	}

	//get the source store Provider
	if(g_wszSrcStoreProvider)
	{
		if(S_OK != WSZtoSZ(g_wszSrcStoreProvider, &g_szSrcStoreProvider))
		{
			IDSwprintf(hModule, IDS_ERR_STORE_PROVIDER);
			return FALSE;
		}
	}

	//get the source store open flag
	if(g_wszSrcStoreOpenFlag)
	{
		g_dwSrcStoreOpenFlag = _wtol(g_wszSrcStoreOpenFlag);
	}

	//get the destination store Provider
	if(g_wszDesStoreProvider)
	{
		if(S_OK != WSZtoSZ(g_wszDesStoreProvider, &g_szDesStoreProvider))
		{
			IDSwprintf(hModule, IDS_ERR_STORE_PROVIDER);
			return FALSE;
		}
	}

	//get the destination store open flag
	if(g_wszDesStoreOpenFlag)
	{
		g_dwDesStoreOpenFlag = _wtol(g_wszDesStoreOpenFlag);
	}

	//get the encoding type
	if(g_wszCertEncodingType)
	{
		g_dwCertEncodingType = _wtol(g_wszCertEncodingType);
	}

	g_dwMsgAndCertEncodingType |= g_dwCertEncodingType;

	//get the source store location
	if(g_wszSrcStoreLocation)
	{
		if(IDSwcsicmp(hModule,g_wszSrcStoreLocation, IDS_R_CU) == 0) 
			g_dwSrcStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
		else 
		{
			if(IDSwcsicmp(hModule,g_wszSrcStoreLocation, IDS_R_LM) == 0) 
				g_dwSrcStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_REG);
				return FALSE;
			}
		}
	}

	
	//get the destincation store location
	if(g_wszDesStoreLocation)
	{
		if(IDSwcsicmp(hModule,g_wszDesStoreLocation, IDS_R_CU) == 0) 
			g_dwDesStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
		else 
		{
			if(IDSwcsicmp(hModule,g_wszDesStoreLocation, IDS_R_LM) == 0) 
				g_dwDesStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_REG);
				return FALSE;
			}
		}
	}

	//get the hash 
	if(g_wszSha1Hash)
	{
		if(S_OK != WSZtoBLOB(g_wszSha1Hash, &g_pbHash, &g_cbHash))
		{
			//sha1 hash is invalid
			IDSwprintf(hModule, IDS_ERR_SHA1_HASH);
			return FALSE;
		}
	}

	//check the item
	if(g_dwAction & ACTION_DISPLAY)
	{
		if(0==g_dwItem || ITEM_VERBOSE==g_dwItem)
			g_dwItem = g_dwItem | ITEM_CERT | ITEM_CTL | ITEM_CRL;

		//can not set destination source
		if((g_wszDesStoreLocation) || (g_fDesSystemStore==TRUE) ||
			(g_wszCertCN) || (g_wszSha1Hash) || (g_fSaveAs7==TRUE) ||
			(g_wszDesStoreName) ||(g_wszDesStoreProvider) ||(g_wszDesStoreOpenFlag))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY_TOO_MANY);
			return FALSE;
		}

	}

    //-eku can not be set for DISPLAY or PUT
    if((g_dwAction & ACTION_DISPLAY) || (g_dwAction & ACTION_PUT))
    {
        //can not set -eku option
		if(g_wszEKU || g_wszName)
		{
			IDSwprintf(hModule, IDS_ERR_DISPLAY_EKU);
			return FALSE;
		}
    }

    if(g_dwAction & ACTION_PUT)
    {
		//g_fAll can not be set, 
		if(TRUE==g_fAll)
		{
            IDSwprintf(hModule, IDS_ERR_ALL_PUT);
            return FALSE;
        }

        //only one item can not set
        dwItemCount=0;

        if(g_dwItem & ITEM_CERT)
            dwItemCount++;
        if(g_dwItem & ITEM_CTL)
            dwItemCount++;
        if(g_dwItem & ITEM_CRL)
            dwItemCount++;

        if(1!=dwItemCount)
        {
            IDSwprintf(hModule, IDS_ERR_PUT_ITEM);
            return FALSE;
        }

		//check the destination store
		if(NULL == g_wszDesStoreName)
		{	
			IDSwprintf(hModule,IDS_ERR_DES_STORE);
			return FALSE;

        }

        //can not set -s, -y, -f, or -r for the destination store
		if((g_fDesSystemStore==TRUE) || (g_wszDesStoreLocation) ||
				(g_wszDesStoreProvider) || (g_wszDesStoreOpenFlag))
		{
			IDSwprintf(hModule,IDS_TOO_MANY_DES_STORE);
			return FALSE;
		}
		
    }

	if((g_dwAction & ACTION_ADD) ||
		(g_dwAction & ACTION_DELETE))
	{

		//if g_fAll is set, OK 
		if(TRUE==g_fAll)
		{
			if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem )
				g_dwItem = g_dwItem | ITEM_CERT | ITEM_CTL | ITEM_CRL;
		}

		//check the destination store
		if(NULL == g_wszDesStoreName)
		{	
			if(g_dwAction & ACTION_ADD)
			{
				IDSwprintf(hModule,IDS_ERR_DES_STORE);
				return FALSE;
			}

			g_fSameSrcDes=TRUE;

			//can not have set -s, -y, -f or -r if the store name is not set
			if((g_fDesSystemStore==TRUE) || (g_wszDesStoreLocation) ||
				(g_wszDesStoreProvider) || (g_wszDesStoreOpenFlag))
			{
				IDSwprintf(hModule,IDS_ERR_DES_STORE);
				return FALSE;
			}
			g_wszDesStoreName=g_wszSrcStoreName;
			g_dwDesStoreFlag=g_dwSrcStoreFlag;
			g_fDesSystemStore=g_fSrcSystemStore;
			g_szDesStoreProvider=g_szSrcStoreProvider;
			g_dwDesStoreOpenFlag=g_dwSrcStoreOpenFlag;

		}
		
		//if -7 is set, can not save to a system store
		if(TRUE==g_fSaveAs7)
		{
			if(TRUE==g_fDesSystemStore)
			{
				IDSwprintf(hModule,IDS_ERR_SOURCE_SYSTEM_7);
				return FALSE;
			}
		}

	}

	return 	TRUE;

}

//------------------------------------------------------------------------------------
//
//	Open a store.  The order of trying is following:
//
//		Using predefined store provider
//		SystemStore
//		CTL
//		CRL
//		Serialized Store, PKCS#7, Encoded Cert
//		PKCS7 via sip
//		Base64 encoded, then go throught the whole thing again
//
//		
//------------------------------------------------------------------------------------
BOOL	OpenGenericStore(LPWSTR			wszStoreName,
						 BOOL			fSystemStore,
						 DWORD			dwStoreFlag,
						 LPSTR			szStoreProvider,
						 DWORD			dwStoreOpenFlag,
						 BOOL			fCheckExist,
						 HCERTSTORE		*phCertStore)
{
	HCERTSTORE		hStore=NULL;
	BYTE			*pbByte=NULL;
	DWORD			cbByte=0;
	CRYPT_DATA_BLOB	Blob;

	if(!wszStoreName || !phCertStore)
		return FALSE;

	//open the store using supplied store provider
	if(szStoreProvider)
	{
		hStore=CertOpenStore(szStoreProvider,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwStoreOpenFlag,
							wszStoreName);

		//one shot and we are done
		goto CLEANUP;

	}

	//open the system store
	if(fSystemStore)
	{	
		if(TRUE==fCheckExist)
		{
			//open Read Only stores
			hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						g_dwMsgAndCertEncodingType,
						NULL,
						dwStoreFlag |CERT_STORE_READONLY_FLAG,
						wszStoreName);

			//we need to open the store as non-readonly if the store exists
			//and we the source store is the same as destination store
			if(NULL!=hStore)
			{
				if(TRUE==g_fSameSrcDes)
				{
					CertCloseStore(hStore, 0);

					hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwStoreFlag,
							wszStoreName);
				}

			}

		}
		else
		{
			hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						g_dwMsgAndCertEncodingType,
						NULL,
						dwStoreFlag,
						wszStoreName);
		}
		

		//one shot and we are done
		goto CLEANUP;
	}

	//open an encoded CTL
	hStore=OpenEncodedCTL(wszStoreName);
	
	if(hStore)
	{
		//mark this is a CTL
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CTL;

		goto CLEANUP;
	}

	//open an encoded CRL
	hStore=OpenEncodedCRL(wszStoreName);
	if(hStore)
	{
		//mark this is a CRL
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CRL;

		goto CLEANUP;
	}

	//open an encoded Cert
	hStore=OpenEncodedCert(wszStoreName);
	if(hStore)
	{
		//mark this is a CERT		
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CERT;
		
		goto CLEANUP;
	}


	//Serialized Store, PKCS#7, Encoded Cert 
	hStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 wszStoreName);
	if(hStore)
		goto CLEANUP;

	//PKCS7 via SIP
	hStore=OpenSipStore(wszStoreName);
	if(hStore)
		goto CLEANUP;

	//base64 encoded
	if(!GetBase64Decoded(wszStoreName, &pbByte,&cbByte))
		goto CLEANUP;

	Blob.cbData=cbByte;
	Blob.pbData=pbByte;

	//open a temporary memory store
	hStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hStore)
		goto CLEANUP;


	//try as encodedCTL
	if(CertAddEncodedCTLToStore(hStore,
								 g_dwMsgAndCertEncodingType,
								 pbByte,
								 cbByte,
								 CERT_STORE_ADD_ALWAYS,
								 NULL))
		goto CLEANUP;

	//try as encodedCRL
	if(CertAddEncodedCRLToStore(hStore,
								g_dwMsgAndCertEncodingType,
								pbByte,
								cbByte,
								CERT_STORE_ADD_ALWAYS,
								NULL))
		goto CLEANUP;

	//try as encodedCert
	if(CertAddEncodedCertificateToStore(hStore,
								g_dwMsgAndCertEncodingType,
								pbByte,
								cbByte,
								CERT_STORE_ADD_ALWAYS,
								NULL))
		goto CLEANUP;

	//close the temporary store
	CertCloseStore(hStore, 0);
	hStore=NULL;

   //try as an 7
	hStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
							g_dwMsgAndCertEncodingType,
							NULL,
							0,
							&Blob);


	if(hStore)
		goto CLEANUP;

	//try as a serialized store
	hStore=CertOpenStore(CERT_STORE_PROV_SERIALIZED,
							g_dwMsgAndCertEncodingType,
							NULL,
							0,
							&Blob);

	
	//now we give up

CLEANUP:

	//free memory
	if(pbByte)
		ToolUtlFree(pbByte);

	if(hStore)
	{
		*phCertStore=hStore;
		return TRUE;
	}

	return FALSE;
}

//-------------------------------------------------------------------------
//
//	Add certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	AddCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hAddStore=NULL;
	int				idsErr=0;
	CRYPT_HASH_BLOB Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;

	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_C_CTL_CTL_ALL);
		return FALSE;
	}


	//create a temporaray memory store
	hAddStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hAddStore)
	{
		idsErr=IDS_ERR_TMP_STORE;
		goto CLEANUP;
	}

	
	//add certs
	if(g_dwItem & ITEM_CERT)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CERT))
			{
				idsErr=IDS_ERR_ADD_CERT_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hCertStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//add certificate to the hash
			   if(!CertAddCertificateContextToStore(hAddStore,
													pCertContext,
													CERT_STORE_ADD_REPLACE_EXISTING,
													NULL))
			   {
					idsErr=IDS_ERR_ADD_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount && g_wszCertCN)
				{
					idsErr=IDS_ERR_ADD_NO_CERT;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//add certificate 
				   if(!CertAddCertificateContextToStore(hAddStore,
														rgpCertContext[0],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
				   {
						idsErr=IDS_ERR_ADD_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CERT;
							goto CLEANUP;
						}
				
						//add certificate 
						if(!CertAddCertificateContextToStore(hAddStore,
														rgpCertContext[dwIndex],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
						{
							idsErr=IDS_ERR_ADD_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
		}		
	}

	//add CRLs
	if(g_dwItem & ITEM_CRL)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CRL))
			{
				idsErr=IDS_ERR_ADD_CRL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hCertStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//add CRL to the hash
				if(!CertAddCRLContextToStore(hAddStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_ADD_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hCertStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_CRL_FIND;
					goto CLEANUP;
				}

				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//add CRL 
					if(!CertAddCRLContextToStore(hAddStore,
										rgpCRLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_ADD_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CRL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCRLContextToStore(hAddStore,
										rgpCRLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_ADD_CRL;
							goto CLEANUP;
						}
					}

				}
			}
		}
	}

	//add CTLs
	if(g_dwItem & ITEM_CTL)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CTL))
			{
				idsErr=IDS_ERR_ADD_CTL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hCertStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//add CTL to the hash
				if(!CertAddCTLContextToStore(hAddStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_ADD_CTL;
						goto CLEANUP;  
				}

				//free the pCRLContext
				CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the certificate
				if(!BuildCTLList(hCertStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_CTL_FIND;
					goto CLEANUP;
				}

				//check if there is only one item
				if(1==dwCTLCount)
				{
					//add CRL 
					if(!CertAddCTLContextToStore(hAddStore,
										rgpCTLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_ADD_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CTL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCTLContextToStore(hAddStore,
										rgpCTLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_ADD_CTL;
							goto CLEANUP;
						}
					}

				}
			}
		}



	}

	//save the properties to the certificates in the store
	if(g_wszEKU)
	{
		if(!SetEKUProperty(hAddStore))
		{
			idsErr=IDS_ERR_SET_EKU;
			goto CLEANUP;
		}
	}

    //save the properties to the certificates in the store
	if(g_wszName)
	{
		if(!SetNameProperty(hAddStore))
		{
			idsErr=IDS_ERR_SET_NAME;
			goto CLEANUP;
		}
	}


	//save the hAddStore to the destination store
	if(!SaveStore(hAddStore))
		goto CLEANUP;


	fResult=TRUE;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if(hAddStore)
		CertCloseStore(hAddStore, 0);

	if(FALSE==fResult)
	{
		//output the error message
		IDSwprintf(hModule,idsErr);			
	}

	return fResult;

}
//-------------------------------------------------------------------------
//
//	Put certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	PutCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hPutStore=NULL;
	int				idsErr=0;
	CRYPT_HASH_BLOB Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
    PCCERT_CONTEXT  pCertPut=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
    PCCRL_CONTEXT	pCRLPut=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
    PCCTL_CONTEXT	pCTLPut=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;   

    BYTE            *pByte=NULL;
    DWORD           cbByte=0;
    DWORD           dwCRLFlag=0;

	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_PUT_ITEM);
		return FALSE;
	}


	//create a temporaray memory store
	hPutStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hPutStore)
	{
		idsErr=IDS_ERR_TMP_STORE;
		goto CLEANUP;
	}

	
	//put certs
	if(g_dwItem & ITEM_CERT)
	{
			//add based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hCertStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//add certificate to the hash
			   if(!CertAddCertificateContextToStore(hPutStore,
													pCertContext,
													CERT_STORE_ADD_REPLACE_EXISTING,
													NULL))
			   {
					idsErr=IDS_ERR_PUT_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_PUT_NO_CERT;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount)
				{
					idsErr=IDS_ERR_CERT_FIND;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//add certificate 
				   if(!CertAddCertificateContextToStore(hPutStore,
														rgpCertContext[0],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
				   {
						idsErr=IDS_ERR_PUT_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CERT;
							goto CLEANUP;
						}
				
						//add certificate 
						if(!CertAddCertificateContextToStore(hPutStore,
														rgpCertContext[dwIndex],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
						{
							idsErr=IDS_ERR_PUT_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
	}

	//add CRLs
	if(g_dwItem & ITEM_CRL)
	{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hCertStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//add CRL to the hash
				if(!CertAddCRLContextToStore(hPutStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_PUT_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hCertStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_PUT_CRL_FIND;
					goto CLEANUP;
				}

                //check if there is no certs
				if(0==dwCRLCount)
				{
					idsErr=IDS_ERR_PUT_CRL_FIND;
					goto CLEANUP;
				}


				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//add CRL 
					if(!CertAddCRLContextToStore(hPutStore,
										rgpCRLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_PUT_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CRL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCRLContextToStore(hPutStore,
										rgpCRLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_PUT_CRL;
							goto CLEANUP;
						}
					}

				}
			}
	}

	//add CTLs
	if(g_dwItem & ITEM_CTL)
	{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hCertStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//add CTL to the hash
				if(!CertAddCTLContextToStore(hPutStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_PUT_CTL;
						goto CLEANUP;  
				}

				//free the pCRLContext
				CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the certificate
				if(!BuildCTLList(hCertStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_PUT_CTL_FIND;
					goto CLEANUP;
				}

               //check if there is no certs
				if(0==dwCTLCount)
				{
					idsErr=IDS_ERR_PUT_CTL_FIND;
					goto CLEANUP;
				}


				//check if there is only one item
				if(1==dwCTLCount)
				{
					//add CRL 
					if(!CertAddCTLContextToStore(hPutStore,
										rgpCTLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_PUT_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CTL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCTLContextToStore(hPutStore,
										rgpCTLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_PUT_CTL;
							goto CLEANUP;
						}
					}

				}
			}



	}


	//save the hPutStore to the destination store
    //save as 7 is required
    if(g_fSaveAs7==TRUE)
    {
		if(!CertSaveStore(hPutStore,
						g_dwMsgAndCertEncodingType,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_FILENAME_W,
						g_wszDesStoreName,
						0))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}
    }
    else
    {
        //get the BLOB to save to a file in X509 format
        if(g_dwItem & ITEM_CERT)
        {
            if(NULL==(pCertPut=CertEnumCertificatesInStore(hPutStore, NULL)))
		    {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
		    }

            pByte=pCertPut->pbCertEncoded;
            cbByte=pCertPut->cbCertEncoded;
        }

        if(g_dwItem & ITEM_CRL)
        {
            if(NULL==(pCRLPut=CertGetCRLFromStore(hPutStore,
												NULL,
												NULL,
												&dwCRLFlag)))
            {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
            }

            pByte=pCRLPut->pbCrlEncoded;
            cbByte=pCRLPut->cbCrlEncoded;

        }

        if(g_dwItem & ITEM_CTL)
        {
            if(NULL==(pCTLPut=CertEnumCTLsInStore(hPutStore, NULL)))
            {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
            }
            pByte=pCTLPut->pbCtlEncoded;
            cbByte=pCTLPut->cbCtlEncoded;
        }

       if(S_OK !=OpenAndWriteToFile(g_wszDesStoreName,pByte, cbByte))
       {
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;

       }
    }


	fResult=TRUE;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

    if(pCertPut)
		CertFreeCertificateContext(pCertPut);

	if(pCRLPut)
		CertFreeCRLContext(pCRLPut);

	if(pCTLPut)
		CertFreeCTLContext(pCTLPut);


	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if(hPutStore)
		CertCloseStore(hPutStore, 0);

	if(FALSE==fResult)
	{
		//output the error message
		IDSwprintf(hModule,idsErr);			
	}

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Delete certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	DeleteCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hDeleteStore=NULL;
	BOOL			fDuplicated=FALSE;
	int				idsErr=0;
	CRYPT_HASH_BLOB	Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;


	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_C_CTL_CTL_ALL);
		return FALSE;
	}


	//first of all, create a certificate from which the certs will be deleted
	//if the source store is a fileStore, or a system store saved to its self,
	//we do not need to duplicate the source store since the deletion is not persistent;
	//otherwise, we need to duplicate the source store so that the deletion
	//will not show up at the source store
	if( ((NULL != g_szSrcStoreProvider) &&(FALSE==g_fSameSrcDes) ) ||
		((FALSE==g_fSameSrcDes) &&(TRUE==g_fSrcSystemStore)))
	{
		//open a temporary store
		hDeleteStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);


		if(!hDeleteStore)
		{
			idsErr=IDS_ERR_TMP_STORE;
			goto CLEANUP;
		}

		fDuplicated=TRUE;

		//need to copy from the source to the delete store
		if(!MoveItem(hCertStore, hDeleteStore, ITEM_CERT | ITEM_CTL | ITEM_CRL))
		{
			idsErr=IDS_ERR_COPY_FROM_SRC;
			goto CLEANUP;
		}


	}
	else
		hDeleteStore=hCertStore;


	//now, we delete CERTs, CTLs, and CRLs
	
	//delete certs
	if(g_dwItem & ITEM_CERT)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore,ITEM_CERT))
			{
				idsErr=IDS_ERR_DELETE_CERT_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hDeleteStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//delete certificate to the hash
			   if(!CertDeleteCertificateFromStore(pCertContext))
			   {
					idsErr=IDS_ERR_DELETE_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   //CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hDeleteStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hDeleteStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount && g_wszCertCN)
				{
					idsErr=IDS_ERR_DELETE_NO_CERT;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//delete certificate 
                    CertDuplicateCertificateContext(rgpCertContext[0]);

				   if(!CertDeleteCertificateFromStore(rgpCertContext[0]))
				   {
						idsErr=IDS_ERR_DELETE_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CERT;
							goto CLEANUP;
						}
				
						//delete certificate 

                        CertDuplicateCertificateContext(rgpCertContext[dwIndex]);

						if(!CertDeleteCertificateFromStore(rgpCertContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
		}		
	}


 	//delete CRLs
	if(g_dwItem & ITEM_CRL)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore, ITEM_CRL))
			{
				idsErr=IDS_ERR_DELETE_CRL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hDeleteStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//delete CRL to the hash
				if(!CertDeleteCRLFromStore(pCRLContext))
				{
						idsErr=IDS_ERR_DELETE_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				//CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hDeleteStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_CRL_FIND;
					goto CLEANUP;
				}

				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//delete CRL 
                    CertDuplicateCRLContext(rgpCRLContext[0]);

					if(!CertDeleteCRLFromStore(rgpCRLContext[0]))
					{
						idsErr=IDS_ERR_DELETE_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CRL;
							goto CLEANUP;
						}

						//delete certificate
                        CertDuplicateCRLContext(rgpCRLContext[dwIndex]);

						if(!CertDeleteCRLFromStore(rgpCRLContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CRL;
							goto CLEANUP;
						}
					}

				}
			}
		}
	}

	//delete CTLs
	if(g_dwItem & ITEM_CTL)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore, ITEM_CTL))
			{
				idsErr=IDS_ERR_DELETE_CTL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hDeleteStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//delete CTL to the hash
				if(!CertDeleteCTLFromStore(pCTLContext))
				{
						idsErr=IDS_ERR_DELETE_CTL;
						goto CLEANUP;
				}

				//free the pCRLContext
				//CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the CTLs
				if(!BuildCTLList(hDeleteStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_CTL_FIND;
					goto CLEANUP;
				}

				//check if there is only one item
				if(1==dwCTLCount)
				{
					//delete CRL 

                    CertDuplicateCTLContext(rgpCTLContext[0]);

					if(!CertDeleteCTLFromStore(rgpCTLContext[0]))
					{
						idsErr=IDS_ERR_DELETE_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CTL;
							goto CLEANUP;
						}

						//delete CTL 
                        CertDuplicateCTLContext(rgpCTLContext[dwIndex]);

						if(!CertDeleteCTLFromStore(rgpCTLContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CTL;
							goto CLEANUP;
						}
					}

				}
			}
		}



	}

	//save the properties to the certificates in the store
	if(g_wszEKU)
	{
		if(!SetEKUProperty(hDeleteStore))
		{
			idsErr=IDS_ERR_SET_EKU;
			goto CLEANUP;
		}
	}

    //save the properties to the certificates in the store
	if(g_wszName)
	{
		if(!SetNameProperty(hDeleteStore))
		{
			idsErr=IDS_ERR_SET_NAME;
			goto CLEANUP;
		}
	}


	//at last, we save the content for hDeleteStore to the desination store

	//we do not need to do any thing if the source is a system store and 
	//it is saved to its self
	if(((TRUE==g_fSameSrcDes) && (TRUE==g_fDesSystemStore))||
		((TRUE==g_fSameSrcDes)&& (NULL!=g_szDesStoreProvider)))
	{
		fResult=TRUE;
		goto CLEANUP;
	}

	if(!SaveStore(hDeleteStore))
		goto CLEANUP;

	fResult=TRUE;

CLEANUP:


	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if((hDeleteStore) &&(TRUE==fDuplicated) )
		CertCloseStore(hDeleteStore, 0);


	if(FALSE==fResult)
		//output the error message
		IDSwprintf(hModule,idsErr);			

	return fResult;

}

//---------------------------------------------------------------------------
//
//	Save the store to the destination
//--------------------------------------------------------------------------
BOOL	SaveStore(HCERTSTORE hSrcStore)
{
	BOOL		fResult=FALSE;
	HCERTSTORE	hDesStore=NULL;	
   

	DWORD		dwSaveAs=0;


	if(!hSrcStore)
	{
		IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
		return FALSE;
	}	


	//now, we need to distinguish between save to a file, or to a system store
	if(g_fDesSystemStore || g_szDesStoreProvider)
	{
		if(NULL==g_szDesStoreProvider)
		{
			hDesStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
					g_dwMsgAndCertEncodingType,
					NULL,
					g_dwDesStoreFlag,
					g_wszDesStoreName);
		}
		else
		{
			hDesStore=CertOpenStore(g_szDesStoreProvider,
							g_dwMsgAndCertEncodingType,
							NULL,
							g_dwDesStoreOpenFlag,
							g_wszDesStoreName);
		}



		if(!hDesStore)
		{
		 	IDSwprintf(hModule,IDS_ERR_OPEN_DES_STORE);
			goto CLEANUP;
		}

		if(!MoveItem(hSrcStore, hDesStore,ITEM_CERT | ITEM_CRL |ITEM_CTL))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}

	}
	else
	{
		//now, try to open the desitnation store so that the content of the destination
		//store will not be overwritten
		//we should try to do so, except when we are doing deleting,
		//and the file is saved to its self
		if(!((g_dwAction & ACTION_DELETE) && (g_fSameSrcDes==TRUE) && 
			  (FALSE==g_fDesSystemStore)))
		{
			if(OpenGenericStore(g_wszDesStoreName,
							 g_fDesSystemStore,
							 g_dwDesStoreFlag,
							 g_szDesStoreProvider,
							 g_dwDesStoreOpenFlag,
							 FALSE,
							 &hDesStore))

			{
				//if open succeeded, just move the items
				if(!MoveItem(hSrcStore, hDesStore,ITEM_CERT | ITEM_CRL |ITEM_CTL))
				{
					IDSwprintf(hModule,IDS_ERR_OPEN_DES_STORE);
					goto CLEANUP;
				}

				//now the items are moved, we need to persist them to a file.  Go on.
			
			}
			//if we can not open the generic store, then the desination store
			//does not exist.  Go on
		}

	
		//now, we have the right store to save from
		if(g_fSaveAs7==TRUE)
			dwSaveAs=CERT_STORE_SAVE_AS_PKCS7;
		else
			dwSaveAs=CERT_STORE_SAVE_AS_STORE;

		if(!CertSaveStore(hDesStore ? hDesStore : hSrcStore,
						g_dwMsgAndCertEncodingType,
						dwSaveAs,
						CERT_STORE_SAVE_TO_FILENAME_W,
						g_wszDesStoreName,
						0))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}
	}

	fResult=TRUE;

CLEANUP:

	if(hDesStore)
		CertCloseStore(hDesStore, 0);

	return fResult;

}


//-------------------------------------------------------------------------
//
//	Set EKU property to all the certificate in the store
//
//-------------------------------------------------------------------------
BOOL	SetEKUProperty( HCERTSTORE		hSrcStore)
{

	BOOL				fResult=FALSE;
	BYTE				*pbEncoded =NULL;
    DWORD				cbEncoded =0;
    DWORD				cCount;
    LPSTR				psz=NULL;
    LPSTR				pszTok=NULL;
    DWORD				cTok = 0;
    PCERT_ENHKEY_USAGE	pUsage =NULL;
	CRYPT_DATA_BLOB		Blob;

    PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pCertPre=NULL;


	if(S_OK != WSZtoSZ(g_wszEKU, &psz))
		return FALSE;

    // Count the number of OIDs as well as converting from comma delimited
    // to NULL character delimited
    pszTok = strtok(psz, ",");
    while ( pszTok != NULL )
    {
        cTok++;
        pszTok = strtok(NULL, ",");
    }

	//if cTok is 0, make sure user has passed in the correct format
	if(0==cTok)
	{
		if(0!=strcmp(psz, ","))
			goto CLEANUP;
	}

    // Allocate a cert enhanced key usage structure and fill it in with
    // the string tokens
	if(0!=cTok)
	{
		pUsage = (PCERT_ENHKEY_USAGE)ToolUtlAlloc(sizeof(CERT_ENHKEY_USAGE));

		if(NULL==pUsage)
			goto CLEANUP;

		pUsage->cUsageIdentifier = cTok;
		pUsage->rgpszUsageIdentifier = (LPSTR *)ToolUtlAlloc(sizeof(LPSTR)*cTok);
        
        if(NULL==pUsage->rgpszUsageIdentifier)
            goto CLEANUP;

		//set up the OID array
		pszTok = psz;

		for ( cCount = 0; cCount < cTok; cCount++ )
		{
			pUsage->rgpszUsageIdentifier[cCount] = pszTok;
			pszTok = pszTok+strlen(pszTok)+1;
		}

		// Encode the usage
		if(!CryptEncodeObject(
                       X509_ASN_ENCODING,
                       szOID_ENHANCED_KEY_USAGE,
                       pUsage,
                       NULL,
                       &cbEncoded
                       ))
			goto CLEANUP;

		pbEncoded = (BYTE *)ToolUtlAlloc(cbEncoded);
		if ( NULL == pbEncoded)
			goto CLEANUP;

 
		if(!CryptEncodeObject(X509_ASN_ENCODING,
                               szOID_ENHANCED_KEY_USAGE,
                               pUsage,
                               pbEncoded,
                               &cbEncoded
                               ))
			goto CLEANUP;
	}

	//now, set the EKU for each certificate in the store
	while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	{
		//1st, delete the original property
		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_ENHKEY_USAGE_PROP_ID,
										0,
										NULL))
			goto CLEANUP;

		//2nd, set the new property	if required
		if(0!=cTok)
		{	
			Blob.cbData=cbEncoded;
			Blob.pbData=pbEncoded;

			if(!CertSetCertificateContextProperty(pCertContext,
										CERT_ENHKEY_USAGE_PROP_ID,
										0,
										&Blob))
			goto CLEANUP;
		}

		pCertPre=pCertContext;
	}


	fResult=TRUE;

CLEANUP:

	if(psz)
		ToolUtlFree(psz);

	if(pUsage)
	{
	   if(pUsage->rgpszUsageIdentifier)
		   ToolUtlFree(pUsage->rgpszUsageIdentifier);
	   ToolUtlFree(pUsage);

	}

	if(pbEncoded)
		ToolUtlFree(pbEncoded);

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);


	return fResult;

}

//-------------------------------------------------------------------------
//
//	Set name property to all the certificate in the store
//
//-------------------------------------------------------------------------
BOOL	SetNameProperty( HCERTSTORE		hSrcStore)
{

	BOOL				fResult=FALSE;
	CRYPT_DATA_BLOB		Blob;

    PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pCertPre=NULL;


    //init the name property
    Blob.cbData=(wcslen(g_wszName)+1)*sizeof(WCHAR);
    Blob.pbData=(BYTE*)g_wszName;

	//now, set the NAME for each certificate in the store
	while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	{
		//1st, delete the original property
		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_FRIENDLY_NAME_PROP_ID,
										0,
										NULL))
			goto CLEANUP;

		//2nd, set the new property	if required

		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_FRIENDLY_NAME_PROP_ID,
										0,
										&Blob))
			goto CLEANUP;

		pCertPre=pCertContext;
	}


	fResult=TRUE;

CLEANUP:


	if(pCertContext)
		CertFreeCertificateContext(pCertContext);


	return fResult;

}


//-------------------------------------------------------------------------
//
//	Find a CRL based on SHA1 hash
//
//-------------------------------------------------------------------------
PCCRL_CONTEXT	FindCRLInStore(HCERTSTORE hCertStore,
							   CRYPT_HASH_BLOB	*pBlob)
{

	BYTE			*pbData=NULL;
	DWORD			cbData=0;

	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;
	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	if(!pBlob)
		return NULL;

	if(!(pBlob->pbData))
		return NULL;

	//enum the CRLS
	while(pCRLContext=CertGetCRLFromStore(hCertStore,
											NULL,
											pCRLPre,
											&dwCRLFlag))
	{
		//get the hash
		if(!CertGetCRLContextProperty(pCRLContext,
						CERT_SHA1_HASH_PROP_ID,
						NULL,
						&cbData))
			goto CLEANUP;

		pbData=(BYTE *)ToolUtlAlloc(cbData);
		if(!pbData)
			goto CLEANUP;

		if(!CertGetCRLContextProperty(pCRLContext,
						CERT_SHA1_HASH_PROP_ID,
						pbData,
						&cbData))
			goto CLEANUP;

		//Compare
		if(cbData==pBlob->cbData)
		{
			if(memcmp(pbData, pBlob->pbData, cbData)==0)
			{
				fResult=TRUE;
				break;
			}
		}

		pCRLPre=pCRLContext;

	}


CLEANUP:

	if(pbData)
		ToolUtlFree(pbData);

	if(FALSE==fResult)
	{
		if(pCRLContext)
		{
			CertFreeCRLContext(pCRLContext);
			pCRLContext=NULL;
		}
	}

	return pCRLContext;


}

//-------------------------------------------------------------------------
//
//	Move Certs/CRls/CTLs from the source store to the destination
//
//-------------------------------------------------------------------------
BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {

			if(!CertAddCertificateContextToStore(hDesStore,
												pCertContext,
												CERT_STORE_ADD_REPLACE_EXISTING,
												NULL))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			if(!CertAddCTLContextToStore(hDesStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			if(!CertAddCRLContextToStore(hDesStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Delete Certs/CRls/CTLs from the source store
//
//-------------------------------------------------------------------------
BOOL	DeleteItem(HCERTSTORE	hSrcStore, 
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {
			pCertPre=pCertContext;

			if(!CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pCertContext)))
				goto CLEANUP;

		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			 pCTLPre=pCTLContext;

			 if(!CertDeleteCTLFromStore(CertDuplicateCTLContext(pCTLContext)))
				goto CLEANUP;


		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			pCRLPre=pCRLContext;

			if(!CertDeleteCRLFromStore(CertDuplicateCRLContext(pCRLContext)))
				goto CLEANUP;
			
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Display all the certificates and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCertAndPrompt(PCCERT_CONTEXT	*rgpCertContext, 
							 DWORD			dwCertCount,
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	

	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCertCount<2)
		return FALSE;

	//Display all the certs
	for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CERT_INDEX, dwIndex+1);

		if(!DisplayCert(rgpCertContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
		//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CERT);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CERT);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CERT);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCertCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule, IDS_ERR_INVALID_INDEX);
	
	return FALSE;
}
//-------------------------------------------------------------------------
//
//	Display all the CRLs and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCRLAndPrompt(PCCRL_CONTEXT	*rgpCRLContext, 
							 DWORD			dwCRLCount, 
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	

	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCRLCount<2)
		return FALSE;

	//Display all the CRLs
	for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CRL_INDEX, dwIndex+1);

		if(!DisplayCRL(rgpCRLContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
		//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CRL);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CRL);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CRL);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCRLCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule,IDS_ERR_INVALID_INDEX);

	return FALSE;


}

//-------------------------------------------------------------------------
//
//	Display all the CTLs and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCTLAndPrompt(PCCTL_CONTEXT	*rgpCTLContext, 
							 DWORD			dwCTLCount, 
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	
	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCTLCount<2)
		return FALSE;

	//Display all the CTLs
	for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CTL_INDEX, dwIndex+1);

		if(!DisplayCTL(rgpCTLContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
	//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CTL);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CTL);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CTL);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCTLCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule,IDS_ERR_INVALID_INDEX);

	return FALSE;

}


//-------------------------------------------------------------------------
//
//	Build a list of certificates for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCertList(HCERTSTORE		hCertStore, 
					  LPWSTR			wszCertCN, 
					  PCCERT_CONTEXT	**prgpCertContext,
					  DWORD				*pdwCertCount)
{
	BOOL			fResult=FALSE;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;
	DWORD			dwIndex=0;
	DWORD			dwCount=0;



	if(!prgpCertContext || !pdwCertCount)
		return FALSE;

	//init
	*prgpCertContext=NULL;
	*pdwCertCount=0;


	//if wszCertCN is NULL, include every certs in the list
	if(NULL==wszCertCN)
	{
		while(pCertContext=CertEnumCertificatesInStore(hCertStore, pCertPre))
		{
			dwCount++;

			//allocation enough memory
			*prgpCertContext=(PCCERT_CONTEXT *)realloc((*prgpCertContext),
				dwCount * sizeof(PCCERT_CONTEXT));

			if(!(*prgpCertContext))
				goto CLEANUP;

			//duplicate the certificate context
			(*prgpCertContext)[dwCount-1]=CertDuplicateCertificateContext(pCertContext);

			if(!((*prgpCertContext)[dwCount-1]))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}
	else
	{
		//we search for the certificate based on the common name
		while(pCertContext=CertFindCertificateInStore(hCertStore,  
						 		g_dwCertEncodingType,              
						 		0,                               
						 		CERT_FIND_SUBJECT_STR_W,             
						 		wszCertCN,                       
						 		pCertPre))
		{
			dwCount++;

			//allocation enough memory
			*prgpCertContext=(PCCERT_CONTEXT *)realloc((*prgpCertContext),
				dwCount * sizeof(PCCERT_CONTEXT));

			if(!(*prgpCertContext))
				goto CLEANUP;

			//duplicate the certificate context
			(*prgpCertContext)[dwCount-1]=CertDuplicateCertificateContext(pCertContext);

			if(!((*prgpCertContext)[dwCount-1]))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }
	}

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCertContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCertContext)[dwIndex]))
					CertFreeCertificateContext(((*prgpCertContext)[dwIndex]));
			}

			free(*prgpCertContext);
		}

		*prgpCertContext=NULL;
		*pdwCertCount=0;
	}
	else
	{
		*pdwCertCount=dwCount;
	}

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Build a list of CRLs for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCRLList(	HCERTSTORE		hCertStore, 
						PCCRL_CONTEXT	**prgpCRLContext,
						DWORD			*pdwCRLCount)
{
	BOOL			fResult=FALSE;
	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;
	DWORD			dwCRLFlag=0;
	DWORD			dwIndex=0;
	DWORD			dwCount=0;



	if(!prgpCRLContext || !pdwCRLCount)
		return FALSE;

	//init
	*prgpCRLContext=NULL;
	*pdwCRLCount=0;


	while(pCRLContext=CertGetCRLFromStore(hCertStore, 
											NULL,
											pCRLPre,
											&dwCRLFlag))
	{
			dwCount++;

			//allocation enough memory
			*prgpCRLContext=(PCCRL_CONTEXT *)realloc((*prgpCRLContext),
				dwCount * sizeof(PCCRL_CONTEXT));

			if(!(*prgpCRLContext))
				goto CLEANUP;

			//duplicate the CRL context
			(*prgpCRLContext)[dwCount-1]=CertDuplicateCRLContext(pCRLContext);

			if(!((*prgpCRLContext)[dwCount-1]))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCRLContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCRLContext)[dwIndex]))
					CertFreeCRLContext(((*prgpCRLContext)[dwIndex]));
			}

			free(*prgpCRLContext);
		}

		*prgpCRLContext=NULL;
		*pdwCRLCount=0;
	}
	else
	{
		*pdwCRLCount=dwCount;
	}

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);


	return fResult;

}

//-------------------------------------------------------------------------
//
//	Build a list of CTLs for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCTLList(	HCERTSTORE		hCertStore, 
						PCCTL_CONTEXT	**prgpCTLContext,
						DWORD			*pdwCTLCount)
{
	BOOL			fResult=FALSE;
	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;
	DWORD			dwIndex=0;
	DWORD			dwCount=0;



	if(!prgpCTLContext || !pdwCTLCount)
		return FALSE;

	//init
	*prgpCTLContext=NULL;
	*pdwCTLCount=0;


	while(pCTLContext=CertEnumCTLsInStore(hCertStore,pCTLPre))
	{
			dwCount++;

			//allocation enough memory
			*prgpCTLContext=(PCCTL_CONTEXT *)realloc((*prgpCTLContext),
				dwCount * sizeof(PCCTL_CONTEXT));

			if(!(*prgpCTLContext))
				goto CLEANUP;

			//duplicate the CTL context
			(*prgpCTLContext)[dwCount-1]=CertDuplicateCTLContext(pCTLContext);

			if(!((*prgpCTLContext)[dwCount-1]))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCTLContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCTLContext)[dwIndex]))
					CertFreeCTLContext(((*prgpCTLContext)[dwIndex]));
			}

			free(*prgpCTLContext);
		}

		*prgpCTLContext=NULL;
		*pdwCTLCount=0;
	}
	else
	{
		*pdwCTLCount=dwCount;
	}

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);


	return fResult;

}
//-------------------------------------------------------------------------
//
//	Display everthing in a store
//
//-------------------------------------------------------------------------
BOOL	DisplayCertStore(HCERTSTORE	hCertStore)
{
	BOOL			fResult=FALSE;
	DWORD			dwCount=0;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//Display the certs
	if(g_dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hCertStore, pCertPre))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CERT_INDEX, dwCount);

			if(!DisplayCert(pCertContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCertPre=pCertContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CERT);
	}

	dwCount=0;
	//Display the CTLs
	if(g_dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hCertStore, pCTLPre))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CTL_INDEX, dwCount);

			if(!DisplayCTL(pCTLContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCTLPre=pCTLContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CTL);
	}

	dwCount=0;
	//Display the CRLs
	if(g_dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hCertStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CRL_INDEX, dwCount);

			if(!DisplayCRL(pCRLContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCRLPre=pCRLContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CRL);
	}



	fResult=TRUE;



	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//+-------------------------------------------------------------------------
//  DisplaySMIMECapabilitiesExtension
//--------------------------------------------------------------------------
void DisplayTimeStamp(BYTE *pbEncoded,DWORD cbEncoded,DWORD	dwDisplayFlags)
{
	CMSG_SIGNER_INFO	*pSignerInfo=NULL;

	if (NULL == (pSignerInfo = (CMSG_SIGNER_INFO *) TestNoCopyDecodeObject(
            PKCS7_SIGNER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//display the timestamper's information
	//"   Timestamp Version:: %d\n"
	IDSwprintf(hModule, IDS_TS_VERSION, pSignerInfo->dwVersion);

	//"Timestamp server's certificate issuer::\n");
	IDSwprintf(hModule, IDS_TS_ISSUER);
	
    DecodeName(pSignerInfo->Issuer.pbData,
        pSignerInfo->Issuer.cbData, dwDisplayFlags);

   	//"Timestamp server's certificate SerialNumber::\n"
    IDSwprintf(hModule, IDS_TS_SERIAL_NUMBER);       
    DisplaySerialNumber(&pSignerInfo->SerialNumber);
    printf("\n");

	//"Timestamp's authenticated attributes::\n"
	IDSwprintf(hModule, IDS_TS_AUTHATTR);       
	PrintAttributes(pSignerInfo->AuthAttrs.cAttr, pSignerInfo->AuthAttrs.rgAttr, 
		dwDisplayFlags);

	//"Timestamp's unauthenticated attributes::\n"
	if(pSignerInfo->UnauthAttrs.cAttr)
	{
		IDSwprintf(hModule, IDS_TS_UNAUTHATTR);       
		PrintAttributes(pSignerInfo->UnauthAttrs.cAttr, 
			pSignerInfo->UnauthAttrs.rgAttr, 
			dwDisplayFlags);
	}

CommonReturn:

	if(pSignerInfo)
		ToolUtlFree(pSignerInfo);

	return;
}


//-------------------------------------------------------------------------
//
//	Display a certificate
//
//-------------------------------------------------------------------------
BOOL	DisplayCert(PCCERT_CONTEXT	pCert, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;
	HCRYPTPROV	hProv = 0;


						 
	//"Subject::\n");
	IDSwprintf(hModule, IDS_SUBJECT);
	
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, dwDisplayFlags);

	//"Issuer::\n"
    IDSwprintf(hModule, IDS_ISSUER);

    DecodeName(pCert->pCertInfo->Issuer.pbData,
            pCert->pCertInfo->Issuer.cbData, dwDisplayFlags);

	//"SerialNumber::"
    IDSwprintf(hModule, IDS_SERIAL_NUMBER);       
    DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
    printf("\n");

    CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
	);
    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

    cbHash = MAX_HASH_LEN;
    CertGetCertificateContextProperty(
            pCert,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
     );
     DisplayThumbprint(g_wszMD5, rgbHash, cbHash);


           
    CryptAcquireContext(
                &hProv,
                NULL,
                NULL,           // pszProvider
                PROV_RSA_FULL,
                0               // dwFlags
	);
	if (hProv) 
	{
        cbHash = MAX_HASH_LEN;
        CryptHashPublicKeyInfo(
             hProv,
             CALG_MD5,
             0,                  // dwFlags
             g_dwCertEncodingType,
             &pCert->pCertInfo->SubjectPublicKeyInfo,
             rgbHash,
             &cbHash
        );


		//"Key "
		IDSwprintf(hModule, IDS_KEY);

        DisplayThumbprint(g_wszMD5, rgbHash, cbHash);
        CryptReleaseContext(hProv, 0);
	}

	//print the Key_Prov_Info_Prop_ID
    {
        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo;

        cbInfo = 0;

        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                           // pvData
            &cbInfo
            );
        if (cbInfo) 
		{
            pInfo = (PCRYPT_KEY_PROV_INFO) ToolUtlAlloc(cbInfo);
            if (pInfo) 
			{
                if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo
                        )) 
				{
					//"Provider Type:: %d"
					IDSwprintf(hModule, IDS_KEY_PROVIDER, pInfo->dwProvType);

					//" Provider Name:: %s"
                    if (pInfo->pwszProvName)
						IDSwprintf(hModule, IDS_PROV_NAME, pInfo->pwszProvName);
					
					//" Flags: 0x%x"
                    if (pInfo->dwFlags)
                        IDSwprintf(hModule, IDS_FLAGS, pInfo->dwFlags);

					//" Container: %S"
                    if (pInfo->pwszContainerName)
						IDSwprintf(hModule, IDS_CONTAINER, pInfo->pwszContainerName);

                    //" Params: %d" 
					if (pInfo->cProvParam)
						IDSwprintf(hModule, IDS_PARAM,pInfo->cProvParam);

					//" KeySpec: %d"
                    if (pInfo->dwKeySpec)
                        IDSwprintf(hModule, IDS_KEY_SPEC, pInfo->dwKeySpec);
                    printf("\n");
                } 

                ToolUtlFree(pInfo);
            }
        }
    }


	//"NotBefore:: %s\n"
    IDSwprintf(hModule, IDS_NOT_BEFORE, FileTimeText(&pCert->pCertInfo->NotBefore));

	//"NotAfter:: %s\n"
    IDSwprintf(hModule, IDS_NOT_AFTER, FileTimeText(&pCert->pCertInfo->NotAfter));


	//Display the aux properties if verbose
	if(dwDisplayFlags & ITEM_VERBOSE)
		PrintAuxCertProperties(pCert,dwDisplayFlags);

    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR	pszObjId;
        ALG_ID	aiPubKey;
        DWORD	dwBitLen;


		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pCert->pCertInfo->dwVersion);

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"SignatureAlgorithm:: "
		IDSwprintf(hModule, IDS_SIG_ALGO);

        printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) 
		{
			//"SignatureAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }


		//public key algorithm
        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		// "SubjectPublicKeyInfo.Algorithm:: 
		IDSwprintf(hModule, IDS_SUB_KEY_ALGO);

        printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));

        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) 
		{
			//"SubjectPublicKeyInfo.Algorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SUB_KEY_ALGO_PARAM);

            PrintBytes(L"    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);

			//display DSS sign key
            if (CALG_DSS_SIGN == aiPubKey) 
			{
                PCERT_DSS_PARAMETERS pDssParameters;
                DWORD cbDssParameters;
                if (pDssParameters =
                    (PCERT_DSS_PARAMETERS) TestNoCopyDecodeObject(
                        X509_DSS_PARAMETERS,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                        &cbDssParameters
                        )) 
				{
                    DWORD cbKey = pDssParameters->p.cbData;

					//"DSS Key Length:: %d bytes, %d bits\n"
                    IDSwprintf(hModule, IDS_DSS_LENGTH, cbKey, cbKey*8);

					//"DSS P (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_P);
                    PrintBytes(L"    ", pDssParameters->p.pbData,
                        pDssParameters->p.cbData);

					//"DSS Q (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_Q);
                    PrintBytes(L"    ", pDssParameters->q.pbData,
                        pDssParameters->q.cbData);

					//"DSS G (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_G);
                    PrintBytes(L"    ", pDssParameters->g.pbData,
                        pDssParameters->g.cbData);

                    ToolUtlFree(pDssParameters);
                }
            }
        }

		//"SubjectPublicKeyInfo.PublicKey"
        IDSwprintf(hModule, IDS_SUB_KEY_INFO);

        if (0 != (dwBitLen = CertGetPublicKeyLength(
                g_dwCertEncodingType,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
			//" (BitLength: %d)"
            IDSwprintf(hModule, IDS_BIT_LENGTH, dwBitLen);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
			//" (UnusedBits: %d)"
            IDSwprintf(hModule, IDS_UNUSED_BITS,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);

        printf("\n");

		//print public key
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) 
		{
            PrintBytes(L"    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

            if (CALG_RSA_SIGN == aiPubKey || CALG_RSA_KEYX == aiPubKey) 
			{
                PUBLICKEYSTRUC	*pPubKeyStruc=NULL;
                DWORD			cbPubKeyStruc;

				//"RSA_CSP_PUBLICKEYBLOB::\n"
                IDSwprintf(hModule, IDS_RSA_CSP);
                if (pPubKeyStruc = (PUBLICKEYSTRUC *) TestNoCopyDecodeObject(
                        RSA_CSP_PUBLICKEYBLOB,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbPubKeyStruc
                        )) 
				{
                    PrintBytes(L"    ", (BYTE *) pPubKeyStruc, cbPubKeyStruc);
                    ToolUtlFree(pPubKeyStruc);
                }
            } 
			else if (CALG_DSS_SIGN == aiPubKey) 
			{
                PCRYPT_UINT_BLOB	pDssPubKey;
                DWORD				cbDssPubKey;


				//"DSS Y (little endian)::\n"
                IDSwprintf(hModule, IDS_DSS_Y);
                
				if (pDssPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject
				(
                        X509_DSS_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDssPubKey
                        )) 
				{
                    PrintBytes(L"    ", pDssPubKey->pbData, pDssPubKey->cbData);
                    ToolUtlFree(pDssPubKey);
                }
            }
        } 
		else
			//"  No public key\n"
            IDSwprintf(hModule, IDS_NO_PUB_KEY);

        DisplaySignature
		(
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            dwDisplayFlags);

		//IssuerUniqueId
        if (pCert->pCertInfo->IssuerUniqueId.cbData) 
		{
			//"IssuerUniqueId"
			IDSwprintf(hModule, IDS_ISSUER_ID);

            if (pCert->pCertInfo->IssuerUniqueId.cUnusedBits)

				//" (UnusedBits: %d)"
				IDSwprintf(hModule, IDS_UNUSED_BITS,
                    pCert->pCertInfo->IssuerUniqueId.cUnusedBits);

            printf("\n");
            PrintBytes(L"    ", pCert->pCertInfo->IssuerUniqueId.pbData,
                pCert->pCertInfo->IssuerUniqueId.cbData);
        }

        if (pCert->pCertInfo->SubjectUniqueId.cbData) 
		{
			//"SubjectUniqueId"
			IDSwprintf(hModule, IDS_SUBJECT_ID);

            if (pCert->pCertInfo->SubjectUniqueId.cUnusedBits)
				//" (UnusedBits: %d)"
				IDSwprintf(hModule, IDS_UNUSED_BITS,
                    pCert->pCertInfo->SubjectUniqueId.cUnusedBits);


            printf("\n");
            PrintBytes(L"    ", pCert->pCertInfo->SubjectUniqueId.pbData,
                pCert->pCertInfo->SubjectUniqueId.cbData);
        }


		//extensions
		if (pCert->pCertInfo->cExtension != 0) 
		{
			PrintExtensions(pCert->pCertInfo->cExtension,
                pCert->pCertInfo->rgExtension, dwDisplayFlags);
		}


    }//ITEM_VERBOSE


	fResult=TRUE;


	return fResult;


}

//-------------------------------------------------------------------------
//
//	Display a CTL
//
//-------------------------------------------------------------------------
BOOL	DisplayCTL(PCCTL_CONTEXT	pCtl, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
    PCTL_INFO	pInfo = pCtl->pCtlInfo;
    DWORD		cId;
    LPSTR		*ppszId = NULL;
    DWORD		i;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;
 


 	// "SubjectUsage::\n"
    IDSwprintf(hModule, IDS_SUBJECT_USAGE);

    
	cId = pInfo->SubjectUsage.cUsageIdentifier;
    ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
    if (cId == 0)
	{
		//"  No Usage Identifiers\n"
        IDSwprintf(hModule, IDS_NO_USAGE_IDS );
	}
	else
	{
		for (i = 0; i < cId; i++, ppszId++)
			printf("  [%d] %s\n", i, *ppszId);
	}

	//list identifier
    if (pInfo->ListIdentifier.cbData)
	{
		//"ListIdentifier::\n"
        IDSwprintf(hModule, IDS_LIST_DIS);
        PrintBytes(L"    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }

    if (pInfo->SequenceNumber.cbData) 
	{	
		//"SequenceNumber::"
        IDSwprintf(hModule, IDS_SEQUENCE);
        DisplaySerialNumber(&pInfo->SequenceNumber);
        printf("\n");
    }

	//update 
	//"ThisUpdate:: %s\n"
	IDSwprintf(hModule, IDS_THIS_UPDATE, FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
	//"NextUpdate:: %s\n"
	IDSwprintf(hModule,IDS_NEXT_UPDATE, FileTimeText(&pCtl->pCtlInfo->NextUpdate));

	//check the time validity
    if (!IsTimeValidCtl(pCtl))
		// "****** Time Invalid CTL\n"
		IDSwprintf(hModule, IDS_TIME_INVALID);


	//Display SHA1 thumbprint

    CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );

    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

	cbHash=MAX_HASH_LEN;

	CertGetCTLContextProperty(
            pCtl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );

    DisplayThumbprint(g_wszMD5, rgbHash, cbHash);

 //   PrintAuxCtlProperties(pCtl, dwDisplayFlags);

	//Display SubjectAlgorithm
    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR pszObjId;

		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pInfo->dwVersion);


        pszObjId = pInfo->SubjectAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"SubjectAlgorithm:: "
		IDSwprintf(hModule, IDS_SUB_ALGO);
        printf("%s \n", pszObjId);

        if (pInfo->SubjectAlgorithm.Parameters.cbData) 
		{
			//"SubjectAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SUB_ALGO_PARAM);
            PrintBytes(L"    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

		if (pInfo->cExtension != 0) 
		{
			PrintExtensions(pInfo->cExtension, pInfo->rgExtension,
                dwDisplayFlags);
		}

    }



	if (pInfo->cCTLEntry == 0)
		//"-----  No Entries  -----\n"
		IDSwprintf(hModule, IDS_NO_ENTRIES);
	else
	{
		//"-----  Entries  -----\n"
		IDSwprintf(hModule, IDS_ENTRIES);
		PrintCtlEntries(pCtl,dwDisplayFlags);
	}

	//print the signer info
	DisplaySignerInfo(pCtl->hCryptMsg, dwDisplayFlags);


	fResult=TRUE;



	return fResult;


}


//-------------------------------------------------------------------------
//
//	Display a CTL entries
//
//-------------------------------------------------------------------------
 void PrintCtlEntries(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlags)
{
    PCTL_INFO	pInfo = pCtl->pCtlInfo;
    DWORD		cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY	pEntry = pInfo->rgCTLEntry;
    DWORD		i;


    for (i = 0; i < cEntry; i++, pEntry++) 
	{
		//" [%d] SubjectIdentifier::\n"
		IDSwprintf(hModule, IDS_SUB_ID,i);
        PrintBytes(L"      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);


        if (dwDisplayFlags & ITEM_VERBOSE) 
		{
            if (pEntry->cAttribute) 
			{
				//" [%d] Attributes::\n"
                IDSwprintf(hModule, IDS_ATTR, i);

                PrintAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    dwDisplayFlags);
            }
        }
    }
}

//-------------------------------------------------------------------------
//
//	Display a CRL
//
//-------------------------------------------------------------------------
BOOL	DisplayCRL(PCCRL_CONTEXT	pCrl, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;


	//"Issuer::\n"
    IDSwprintf(hModule, IDS_ISSUER);
    
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
            pCrl->pCrlInfo->Issuer.cbData, dwDisplayFlags);

	//"ThisUpdate:: %s\n"
	IDSwprintf(hModule, IDS_THIS_UPDATE, FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
	//"NextUpdate:: %s\n"
	IDSwprintf(hModule,IDS_NEXT_UPDATE, FileTimeText(&pCrl->pCrlInfo->NextUpdate));


    CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

	cbHash=MAX_HASH_LEN;
    CertGetCRLContextProperty(
            pCrl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
    DisplayThumbprint(g_wszMD5, rgbHash, cbHash);

  //  PrintAuxCrlProperties(pCrl, dwDisplayFlags);

    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR pszObjId;

		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pCrl->pCrlInfo->dwVersion);
	

        pszObjId = pCrl->pCrlInfo->SignatureAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;


		//"SignatureAlgorithm::  "
		IDSwprintf(hModule, IDS_SIG_ALGO);
        printf("%s \n", pszObjId);

        if (pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData) 
		{
			//"SignatureAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.pbData,
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData);
        }

			//extensions
		if (pCrl->pCrlInfo->cExtension != 0) 
		{
			PrintExtensions(pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension,
                dwDisplayFlags);
		}



    }


    if (pCrl->pCrlInfo->cCRLEntry == 0)
		//"-----  No Entries  -----\n"
		IDSwprintf(hModule, IDS_NO_ENTRIES);
    else 
	{
		//"-----  Entries  -----\n"
		IDSwprintf(hModule, IDS_ENTRIES);

        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
    }

	fResult=TRUE;

	return fResult;
}

//-------------------------------------------------------------------------
//
//	PrintCrlEntries
//
//-------------------------------------------------------------------------
 void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry,
        DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) 
	{	
		//" [%d] SerialNumber::"
		IDSwprintf(hModule, IDS_SERIAL_NUM_I, i);
        
		DisplaySerialNumber(&pEntry->SerialNumber);
        printf("\n");

        if (dwDisplayFlags & ITEM_VERBOSE) 
		{
			//" [%d] RevocationDate:: %s\n"
			IDSwprintf(hModule, IDS_REVOC_DATE, 
				i,FileTimeText(&pEntry->RevocationDate));
			
        }

		if (pEntry->cExtension == 0)
				//" [%d] Extensions:: NONE\n"
            IDSwprintf(hModule, IDS_NO_EXTENSION,i);
        else 
		{
			//" [%d] Extensions::\n"
            IDSwprintf(hModule, IDS_EXTENSION, i);

            PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
        }

    }
}


//-------------------------------------------------------------------------
//
//	Display a signer info
//
//-------------------------------------------------------------------------
BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem)
{

	BOOL				fResult=FALSE;
	DWORD				dwSignerCount=0;
	DWORD				cbData=0;
	DWORD				dwSignerIndex=0;
	PCRYPT_ATTRIBUTES	pAttrs;	  
	LPSTR				pszObjId=NULL;

	if(!hMsg)
		return FALSE;

    //decide the number of signers
    cbData=sizeof(dwSignerCount);

	if(!CryptMsgGetParam(hMsg, 
						CMSG_SIGNER_COUNT_PARAM,
						0,
						&dwSignerCount,
						&cbData) )
	{
		IDSwprintf(hModule, IDS_ERR_GET_SINGER_COUNT);
		return FALSE;
	}

	if(dwSignerCount==0)
	{
		IDSwprintf(hModule, IDS_DIS_NO_SIGNER);
		return TRUE;
	}

	for(dwSignerIndex=0; dwSignerIndex < dwSignerCount; dwSignerIndex++)
	{
         PCCERT_CONTEXT				pSigner;
		 PCMSG_SIGNER_INFO			pSignerInfo;

		 //"-----  Signer  [%d] -----\n");
		IDSwprintf(hModule, IDS_SIGNER_INDEX,  dwSignerIndex+1);

		//get the signerInfo
		if(pSignerInfo=(PCMSG_SIGNER_INFO) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_INFO_PARAM,
            dwSignerIndex,
            &cbData))
		{

			//Dispaly the hash algorithm
			 pszObjId = pSignerInfo->HashAlgorithm.pszObjId;
			if (pszObjId == NULL)
				pszObjId = g_szNULL;

			//"Hash Algorithm:: "
			IDSwprintf(hModule, IDS_HASH_ALGO);

			printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_HASH_ALG_OID_GROUP_ID));

			if (pSignerInfo->HashAlgorithm.Parameters.cbData) 
			{
				//"HashAlgorithm.Parameters::\n"
				IDSwprintf(hModule, IDS_HASH_ALGO_PARAM);
				PrintBytes(L"    ",
					pSignerInfo->HashAlgorithm.Parameters.pbData,
					pSignerInfo->HashAlgorithm.Parameters.cbData);
			}

			//Display the encrypt algorithm
			pszObjId = pSignerInfo->HashEncryptionAlgorithm.pszObjId;
			if (pszObjId == NULL)
				pszObjId = g_szNULL;

			//"Encrypt Algorithm:: "
			IDSwprintf(hModule, IDS_ENCRYPT_ALGO);

			printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

			if (pSignerInfo->HashEncryptionAlgorithm.Parameters.cbData) 
			{
				//"Encrypt Algorithm.Parameters::\n"
				IDSwprintf(hModule, IDS_ENCRYPT_ALGO_PARAM);
				PrintBytes(L"    ",
					pSignerInfo->HashEncryptionAlgorithm.Parameters.pbData,
					pSignerInfo->HashEncryptionAlgorithm.Parameters.cbData);
			}

			ToolUtlFree(pSignerInfo);
		}


        if (CryptMsgGetAndVerifySigner(
                        hMsg,
                        0,                  // cSignerStore
                        NULL,               // rghSignerStore
                        CMSG_USE_SIGNER_INDEX_FLAG,
                        &pSigner,
                        &dwSignerIndex
                        )) 
		{
			//"-----  Signer [%d] Certificate-----\n");
			IDSwprintf(hModule, IDS_SIGNER_INDEX_CERT,  dwSignerIndex+1);
            DisplayCert(pSigner, dwItem);
            CertFreeCertificateContext(pSigner);
		}
		else
		{
			IDSwprintf(hModule, IDS_ERR_GET_SIGNER_CERT);
			goto CLEANUP;
		}

		//DisplaySigner information
		 
	   if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_AUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) 
	   {   
		   //"-----  Signer [%d] AuthenticatedAttributes  -----\n"
		   IDSwprintf(hModule, IDS_DIS_SIGNER_AUTH_ATTR, dwSignerIndex+1);
		   PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwItem);
		   ToolUtlFree(pAttrs);
	   }

		if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) 
		{
			//"-----  Signer [%d] UnauthenticatedAttributes  -----\n",
            IDSwprintf(hModule, IDS_DIS_SIGNER_UNAUTH_ATTR, dwSignerIndex+1);
			PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwItem);
			ToolUtlFree(pAttrs);
		}

	}

	fResult=TRUE;

CLEANUP:

	return fResult;

}


//-------------------------------------------------------------------------
//
//	Open a store file using sip functions
//
//-------------------------------------------------------------------------
HCERTSTORE OpenSipStore(LPWSTR pwszStoreFilename)
{
    HCERTSTORE			hStore = NULL;
    CRYPT_DATA_BLOB		SignedData;
    memset(&SignedData, 0, sizeof(SignedData));
    DWORD				dwGetEncodingType;
	DWORD				dwMsgType=0;

    GUID				gSubject;
    SIP_DISPATCH_INFO	SipDispatch;
    SIP_SUBJECTINFO		SubjectInfo;


    if (!CryptSIPRetrieveSubjectGuid(
            pwszStoreFilename,
            NULL,                       // hFile
            &gSubject)) goto CommonReturn;

    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,                  // dwFlags
            &SipDispatch)) goto CommonReturn;

    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszStoreFilename;
    // SubjectInfo.pwsDisplayName = 
    // SubjectInfo.lpSIPInfo = 
    // SubjectInfo.dwReserved = 
    // SubjectInfo.hProv = 
    // SubjectInfo.DigestAlgorithm =
    // SubjectInfo.dwFlags =
    SubjectInfo.dwEncodingType = g_dwMsgAndCertEncodingType;
    // SubjectInfo.lpAddInfo =
        
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            NULL                        // pbSignedData
            ) || 0 == SignedData.cbData)
        goto CommonReturn;

    if (NULL == (SignedData.pbData = (BYTE *) ToolUtlAlloc(SignedData.cbData)))
        goto CommonReturn;

    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            SignedData.pbData
            ))
        goto CommonReturn;

    hStore = CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        g_dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) &SignedData
        );

	if(!hStore)
		goto CommonReturn;

	//now, we want to update the g_hMsg to hold the signer info
	if(SignNoContentWrap(SignedData.pbData, SignedData.cbData))
          dwMsgType = CMSG_SIGNED;

    if (!(g_hMsg = CryptMsgOpenToDecode(g_dwMsgAndCertEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          NULL,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
     {
		 CertCloseStore(hStore, 0);
		 hStore=NULL;
		 goto CommonReturn;
	 }

        
    if (!CryptMsgUpdate(g_hMsg,
                           SignedData.pbData,
                           SignedData.cbData,
                            TRUE))                    // fFinal
	  {

		 CertCloseStore(hStore, 0);
		 hStore=NULL;
		 CryptMsgClose(g_hMsg);
		 g_hMsg=NULL;
	  }


CommonReturn:
	if(SignedData.pbData)
		ToolUtlFree(SignedData.pbData);

    return hStore;
}

//-------------------------------------------------------------------------
//
//	BytesToBase64: ascii:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) ToolUtlAlloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        ToolUtlFree(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}

//-------------------------------------------------------------------------
//
//	BytesToBase64 wchar version:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytesW(WCHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryW(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) ToolUtlAlloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryW(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        ToolUtlFree(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}


//------------------------------------------------------------------------------------
//
// Base64 decode the file
//
//------------------------------------------------------------------------------------
BOOL	GetBase64Decoded(LPWSTR		wszStoreName, 
						 BYTE		**ppbByte,
						 DWORD		*pcbByte)
{
	BOOL	fResult=FALSE;
	BYTE	*pbEncoded=NULL;
	DWORD	cbEncoded=0;
	
    //get the blob
	if (S_OK != RetrieveBLOBFromFile(wszStoreName,&cbEncoded, &pbEncoded))
        return FALSE;
	
	//base64 decode.  ascii version
	if(S_OK != Base64ToBytes((CHAR *)pbEncoded, cbEncoded,
							ppbByte, pcbByte))
	{
		//WCHAR version 
		if(cbEncoded %2 == 0)
		{
			if(S_OK !=Base64ToBytesW((WCHAR *)pbEncoded, cbEncoded/2,
							ppbByte, pcbByte))
				goto CLEANUP;
		}
		else
		{
			goto CLEANUP;
		}
	}

	fResult=TRUE;

CLEANUP:

	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

	return fResult;


}
//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CRL.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCRL(LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore=NULL;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded,&pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCRLToStore(
            hStore,
            g_dwCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCrlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}
//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CER.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCert (LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded, &pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCertificateToStore(
            hStore,
            g_dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}

//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CTL.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCTL (LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded, &pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            g_dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}



//--------------------------------------------------------------------------------
// Set the parameters.  They can only be set once
//--------------------------------------------------------------------------------
BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue)
{
	if(*ppwszParam!=NULL)
	{
		IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
		return FALSE;
	}

	*ppwszParam=pwszValue;

	return TRUE;
}


//--------------------------------------------------------------------------------
// Convert an array of wchars to a BLOB
//--------------------------------------------------------------------------------
HRESULT	WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD	*pcbByte)
{
	HRESULT		hr=E_FAIL;
	DWORD		dwIndex=0;
	ULONG		ulHalfByte=0;
	DWORD		dw1st=0;
	DWORD		dw2nd=0;

	if((!pwsz) || (!ppbByte) || (!pcbByte))
		return E_INVALIDARG;

	*ppbByte=NULL;
	*pcbByte=0;

	//make sure the pwsz consists of 20 characters
	if(wcslen(pwsz)!= 2*SHA1_LENGTH)
		return E_FAIL;

	//memory allocation 
	*ppbByte=(BYTE *)ToolUtlAlloc(SHA1_LENGTH);
	if(NULL==(*ppbByte))
		return E_INVALIDARG;

	memset(*ppbByte, 0, SHA1_LENGTH);

	//go through two characters (one byte) at a time
	for(dwIndex=0; dwIndex<SHA1_LENGTH; dwIndex++)
	{
		dw1st=dwIndex * 2;
		dw2nd=dwIndex * 2 +1;

		//1st character
		if(((int)(pwsz[dw1st])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw1st])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw1st])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw1st]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw1st]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw1st]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//copy the 1st character
		(*ppbByte)[dwIndex]=(BYTE)ulHalfByte;

		//left shift 4 bits
		(*ppbByte)[dwIndex]= (*ppbByte)[dwIndex] <<4;

		//2nd character
	   	if(((int)(pwsz[dw2nd])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw2nd])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw2nd])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw2nd]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//ORed the second character
		(*ppbByte)[dwIndex]=(*ppbByte)[dwIndex] | ((BYTE)ulHalfByte);

	}


	hr=S_OK;

CLEANUP:

	if(hr!=S_OK)
	{
	   if(*ppbByte)
		   ToolUtlFree(*ppbByte);

	   *ppbByte=NULL;
	}
	else
		*pcbByte=SHA1_LENGTH;

	return hr;

}

//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER)
{
    DWORD cb;

    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
}


//--------------------------------------------------------------------------
//
// Print out bytes
//--------------------------------------------------------------------------
#define CROW 16
void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) 
	{
		//"%s NO Value Bytes\n"
		IDSwprintf(hModule, IDS_NO_BYTE,pwszHdr); 
        return;
    }

    while (cbSize > 0)
    {
        wprintf(L"%s", pwszHdr);

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            wprintf(L" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            wprintf(L"   ");
        wprintf(L"    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                wprintf(L"%c", pb[i]);
            else
                wprintf(L".");
        pb += cb;
        wprintf(L"'\n");
    }
}


//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
 void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwItem)
{
    DWORD	i; 
    DWORD	j; 
	LPWSTR	pwszObjId=NULL;


    for (i = 0; i < cAttr; i++, pAttr++) 
	{
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

        if (cValue) 
		{
            for (j = 0; j < cValue; j++, pValue++) 
			{
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) 
				{
                   if(dwItem & ITEM_VERBOSE)
						PrintBytes(L"    ", pValue->pbData, pValue->cbData);

                    if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0) 
					{
						//"   NextUpdateLocation::\n"
						IDSwprintf(hModule, IDS_NEXT_UPDATE_LOCATION);

                        DecodeAndDisplayAltName(pValue->pbData, pValue->cbData,
                            dwItem);
                    }

					//Display the timestamp attriute
					if(strcmp(pszObjId, szOID_RSA_counterSign)==0)
					{
						
						//"    Timestamp:: \n"
						IDSwprintf(hModule, IDS_TIMESTMAP);

						DisplayTimeStamp(pValue->pbData,
										pValue->cbData,
										dwItem);

					}

					//Display the signing time
					if(strcmp(pszObjId, szOID_RSA_signingTime)==0)
					{
						FILETIME	*pSigningTime=NULL;

						if(pSigningTime=(FILETIME *)TestNoCopyDecodeObject(
							PKCS_UTC_TIME,
							pValue->pbData,
							pValue->cbData))
						{
							//"   Signing Time:: \n %s\n"
							IDSwprintf(hModule, IDS_SIGNING_TIME, 
								FileTimeText(pSigningTime));

							ToolUtlFree(pSigningTime);
						}
					}
                } 
				else
					//"    NO Value Bytes\n"
					IDSwprintf(hModule, IDS_NO_VALUE_BYTES);
            }
        } 
		else 
		{
			if(S_OK==SZtoWSZ(pszObjId, &pwszObjId))
				//"  [%d] %s :: No Values\n"
				IDSwprintf(hModule, IDS_I_ID_NO_VALUE, i, pwszObjId);
		}
    }

	if(pwszObjId)
		ToolUtlFree(pwszObjId);
}



//+-------------------------------------------------------------------------
//  DecodeAndDisplayAltName
//--------------------------------------------------------------------------
 void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_ALT_NAME_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) TestNoCopyDecodeObject(
            X509_ALTERNATE_NAME,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    DisplayAltName(pInfo, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  Display AltName
//--------------------------------------------------------------------------
 void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags)
{
    DWORD i;
    PCERT_ALT_NAME_ENTRY pEntry = pInfo->rgAltEntry;
    DWORD cEntry = pInfo->cAltEntry;

    for (i = 0; i < cEntry; i++, pEntry++) {
        wprintf(L"    [%d] ", i);
        DisplayAltNameEntry(pEntry, dwDisplayFlags);
    }
}


//+-------------------------------------------------------------------------
//  Display an alternative name entry
//--------------------------------------------------------------------------
 void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags)
{

    switch (pEntry->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
		//"OtherName:\n"
		IDSwprintf(hModule, IDS_OTHER_NAME);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
        //"X400Address:\n");
		IDSwprintf(hModule, IDS_X400);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        //("DirectoryName:\n");
		IDSwprintf(hModule, IDS_DIRECTORY_NAME);
        DecodeName(pEntry->DirectoryName.pbData,
            pEntry->DirectoryName.cbData, dwDisplayFlags);
        break;
    case CERT_ALT_NAME_EDI_PARTY_NAME:
		//"EdiPartyName:\n"
		IDSwprintf(hModule, IDS_EDI_PARTY);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
        //"RFC822: %s\n"
		IDSwprintf(hModule, IDS_RFC,pEntry->pwszRfc822Name );
        break;
    case CERT_ALT_NAME_DNS_NAME:
        //"DNS: %s\n", 
		IDSwprintf(hModule, IDS_DNS, pEntry->pwszDNSName);
        break;
    case CERT_ALT_NAME_URL:
		//"URL: %s\n"
		IDSwprintf(hModule, IDS_ALT_NAME_URL,pEntry->pwszURL); 
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        //"IPAddress:\n"
		IDSwprintf(hModule, IDS_IP);
        PrintBytes(L"    ", pEntry->IPAddress.pbData, pEntry->IPAddress.cbData);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        //"RegisteredID:", 
		IDSwprintf(hModule, IDS_REG_ID);
		printf("%s\n", pEntry->pszRegisteredID);
        break;
    default:
		//"Unknown choice: %d\n"
		IDSwprintf(hModule, IDS_UNKNOWN_ALT_NAME,pEntry->dwAltNameChoice);
    }

}

//+-------------------------------------------------------------------------
//  Display an alternative name entry
//--------------------------------------------------------------------------
 void DisplayThumbprint(
    LPWSTR pwszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    
	//"%s Thumbprint:: "
	IDSwprintf(hModule, IDS_Thumbprint, pwszHash);

    if (cbHash == 0)
        printf("%s", g_szNULL);

    else 
	{
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                printf("%02X", *pbHash);

            printf(" ");
        }
    }

    printf("\n");
}


//+-------------------------------------------------------------------------
//  Print out the FileTime 
//--------------------------------------------------------------------------
LPWSTR FileTimeText(FILETIME *pft)
{
    static  WCHAR	wszbuf[100];
    FILETIME		ftLocal;
    struct tm		ctm;
    SYSTEMTIME		st;
	WCHAR			wszFileTime[50];
	WCHAR			wszMilliSecond[50];

	//init
	wszbuf[0]=L'\0';

	//check if the time is available
	if((pft->dwLowDateTime==0) &&
		(pft->dwHighDateTime==0))
	{
		LoadStringU(hModule, IDS_NOT_AVAILABLE, wszbuf, 100);
		return wszbuf;
	}

	//load the string we need
	//" <milliseconds:: %03d>"
	//"<FILETIME %08lX:%08lX>"
	if(!LoadStringU(hModule, IDS_FILE_TIME, wszFileTime, 50) ||
		!LoadStringU(hModule, IDS_MILLI_SECOND, wszMilliSecond, 50))
		return wszbuf;

    FileTimeToLocalFileTime(pft, &ftLocal);

    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        wcscpy(wszbuf, _wasctime(&ctm));
        wszbuf[wcslen(wszbuf)-1] = 0;

        if (st.wMilliseconds) 
		{
            WCHAR *pwch = wszbuf + wcslen(wszbuf);
            swprintf(pwch, wszMilliSecond, st.wMilliseconds);
        }
    }
    else
        swprintf(wszbuf, wszFileTime, pft->dwHighDateTime, pft->dwLowDateTime);
    return wszbuf;
}



//+-------------------------------------------------------------------------
//  Print other cer properies
//--------------------------------------------------------------------------
 void PrintAuxCertProperties(PCCERT_CONTEXT pCert, DWORD dwDisplayFlags)
{
    DWORD dwPropId = 0;

    while (dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId)) 
	{
        switch (dwPropId) 
		{
			case CERT_KEY_PROV_INFO_PROP_ID:
			case CERT_SHA1_HASH_PROP_ID:
			case CERT_MD5_HASH_PROP_ID:
			case CERT_KEY_CONTEXT_PROP_ID:
				// Formatted elsewhere
				break;
			default:
            {
                BYTE *pbData;
                DWORD cbData;

				//"Aux PropId %d (0x%x) ::\n"
				IDSwprintf(hModule, IDS_AUX_PROP_ID, dwPropId, dwPropId);

                CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) 
				{
                    if (pbData = (BYTE *) ToolUtlAlloc(cbData)) 
					{
                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbData
                                )) 
						{
                            PrintBytes(L"    ", pbData, cbData); 

                            if (CERT_CTL_USAGE_PROP_ID == dwPropId) 
							{
                                // "  EnhancedKeyUsage::\n"
								IDSwprintf(hModule, IDS_ENHANCED_KEY_USAGE);

                                DecodeAndDisplayCtlUsage(pbData, cbData,
                                    dwDisplayFlags);
                            }
                        } 

                        ToolUtlFree(pbData);
                    }
                } 
				else
					//"     NO Property Bytes\n"
					IDSwprintf(hModule, IDS_NO_PROP_BYTES);
            } 

            break;
        }
    }
}


//+-------------------------------------------------------------------------
//  DecodeAndDisplayCtlUsage
//--------------------------------------------------------------------------
 void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCTL_USAGE pInfo;
    DWORD cId;
    LPSTR *ppszId;
    DWORD i;

    if (NULL == (pInfo =
            (PCTL_USAGE) TestNoCopyDecodeObject(
                X509_ENHANCED_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto CLEANUP;

    cId = pInfo->cUsageIdentifier;
    ppszId = pInfo->rgpszUsageIdentifier;

    if (cId == 0)
		//"    No Usage Identifiers\n"
		IDSwprintf(hModule, IDS_NO_USAGE_ID);

    for (i = 0; i < cId; i++, ppszId++)
        printf("    [%d] %s\n", i, *ppszId);

CLEANUP:
    if (pInfo)
        ToolUtlFree(pInfo);
}



//+-------------------------------------------------------------------------
//  DisplaySignature
//--------------------------------------------------------------------------
 void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_SIGNED_CONTENT_INFO pSignedContent;
    
    if (pSignedContent = (PCERT_SIGNED_CONTENT_INFO) TestNoCopyDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            )) 
	{
        LPSTR pszObjId;

        pszObjId = pSignedContent->SignatureAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"Content SignatureAlgorithm:: 
		IDSwprintf(hModule, IDS_CONTENT_SIG_ALGO);

        printf("%s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

        if (pSignedContent->SignatureAlgorithm.Parameters.cbData) 
		{
			//"Content SignatureAlgorithm.Parameters::\n"
            IDSwprintf(hModule, IDS_CONTENT_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pSignedContent->SignatureAlgorithm.Parameters.pbData,
                pSignedContent->SignatureAlgorithm.Parameters.cbData);
        }

        if (pSignedContent->Signature.cbData) 
		{
            ALG_ID aiHash;
            ALG_ID aiPubKey;

			//"Content Signature (little endian)::\n"
			IDSwprintf(hModule, IDS_CONTEXT_SIG);
            PrintBytes(L"    ", pSignedContent->Signature.pbData,
                pSignedContent->Signature.cbData);

            GetSignAlgids(pszObjId, &aiHash, &aiPubKey);

            if (CALG_SHA == aiHash && CALG_DSS_SIGN == aiPubKey) 
			{
                BYTE *pbDssSignature;
                DWORD cbDssSignature;

                ReverseBytes(pSignedContent->Signature.pbData,
                    pSignedContent->Signature.cbData);

                if (pbDssSignature =
                    (BYTE *) TestNoCopyDecodeObject(
                        X509_DSS_SIGNATURE,
                        pSignedContent->Signature.pbData,
                        pSignedContent->Signature.cbData,
                        &cbDssSignature
                        )) {
                    if (CERT_DSS_SIGNATURE_LEN == cbDssSignature) 
					{
						//"DSS R (little endian)::\n"
                        IDSwprintf(hModule, IDS_DSS_R);
                        PrintBytes(L"    ", pbDssSignature, CERT_DSS_R_LEN);

						//"DSS S (little endian)::\n"
                        IDSwprintf(hModule, IDS_DSS_S);
                        PrintBytes(L"    ", pbDssSignature + CERT_DSS_R_LEN,
                            CERT_DSS_S_LEN);

                    } 
					else
					{
						//"DSS Signature (unexpected length, little endian)::\n"
						IDSwprintf(hModule, IDS_DSS_INFO);
                        PrintBytes(L"    ", pbDssSignature, cbDssSignature);
                    }
                    ToolUtlFree(pbDssSignature);
                }
            }
        } else
			//"Content Signature:: NONE\n"
			IDSwprintf(hModule, IDS_CONTENT_SIG_NONE);

		ToolUtlFree(pSignedContent);
    }
}


//+-------------------------------------------------------------------------
//  Decode an X509 Name
//--------------------------------------------------------------------------
 BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    if (NULL == (pInfo = (PCERT_NAME_INFO) TestNoCopyDecodeObject
	(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) 
	{
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) 
		{
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = g_szNULL;

            if ((dwDisplayFlags & ITEM_VERBOSE) ||
                (pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) 
			{
				printf("  [%d,%d] %s (%S) ", i, j, pszObjId, GetOIDName(pszObjId));

				//ValueType: %d\n"
				IDSwprintf(hModule, IDS_VALUE_TYPE, pAttr->dwValueType);
                PrintBytes(L"    ", pAttr->Value.pbData, pAttr->Value.cbData);
            } else if (pAttr->dwValueType == CERT_RDN_UNIVERSAL_STRING) 
			{
                printf("  [%d,%d] %s (%S)",
                    i, j, pszObjId, GetOIDName(pszObjId));

                DWORD cdw = pAttr->Value.cbData / 4;
                DWORD *pdw = (DWORD *) pAttr->Value.pbData;
                for ( ; cdw > 0; cdw--, pdw++)
                    printf(" 0x%08X", *pdw);
                printf("\n");

                DWORD csz;
                csz = CertRDNValueToStrA(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // psz
                    0                   // csz
                    );
                if (csz > 1) 
				{
                    LPSTR psz = (LPSTR) ToolUtlAlloc(csz);
                    if (psz) 
					{
                        CertRDNValueToStrA(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            psz,
                            csz
                            );

						//"    Str: "
						IDSwprintf(hModule, IDS_STR);
                        printf("%s\n", psz);
                        ToolUtlFree(psz);
                    }
                }

                DWORD cwsz;
                cwsz = CertRDNValueToStrW(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // pwsz
                    0                   // cwsz
                    );
                if (cwsz > 1) 
				{
                    LPWSTR pwsz =
                        (LPWSTR) ToolUtlAlloc(cwsz * sizeof(WCHAR));
                    if (pwsz) 
					{
                        CertRDNValueToStrW(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            pwsz,
                            cwsz
                            );

						//"    WStr: %S\n"
						IDSwprintf(hModule, IDS_WSTR, pwsz);
                        ToolUtlFree(pwsz);
                    }
                }
            } else if (pAttr->dwValueType == CERT_RDN_BMP_STRING) 
			{
                printf("  [%d,%d] %s (%S) %S\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
            } else
                printf("  [%d,%d] %s (%S) %s\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
    return fResult;
}



//+-------------------------------------------------------------------------
//  PrintExtensions
//--------------------------------------------------------------------------
 void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cExt; i++, pExt++) 
	{
        LPSTR pszObjId = pExt->pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

        int	idsCritical = pExt->fCritical ? IDS_TRUE : IDS_FALSE;

		//print the end of line
		printf("\n");


		//"Extension[%d] "
		IDSwprintf(hModule, IDS_EXTENSION_INDEX, i);

        printf("%s", pszObjId);
		
		//(%s) Critical: ",
		IDSwprintf(hModule, IDS_NAME_CRITICAL, GetOIDName(pszObjId));
		
		//"%s::\n"
		IDS_IDSwprintf(hModule, IDS_STRING, idsCritical);

		//print bytes on verbose options
		if(dwDisplayFlags & ITEM_VERBOSE)
			PrintBytes(L"    ", pExt->Value.pbData, pExt->Value.cbData);

		//try the installed formatting routine 1st
		if(TRUE==InstalledFormat(pszObjId, pExt->Value.pbData, pExt->Value.cbData))
			continue;

        if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER) == 0)
            DisplayAuthorityKeyIdExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2) == 0)
            DisplayAuthorityKeyId2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

// Will add back after PKIX stabilizes on the definition of this extension
//        else if (strcmp(pszObjId, szOID_AUTHORITY_INFO_ACCESS) == 0)
//           DisplayAuthorityInfoAccessExtension(
//               pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_CRL_DIST_POINTS) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_KEY_IDENTIFIER) == 0)
            //"  <SubjectKeyIdentifer> \n"
			DisplayOctetString(IDS_SUB_KEY_ID,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_ATTRIBUTES) == 0)
            DisplayKeyAttrExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME) == 0)
			//"  <Subject AltName> \n"
            DisplayAltNameExtension(IDS_SUB_ALT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME) == 0)
			//"  <Issuer AltName> \n"
            DisplayAltNameExtension(IDS_ISS_ALT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME2) == 0)
			//"  <Subject AltName #2> \n"
            DisplayAltNameExtension(IDS_SUB_ALT2,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME2) == 0)
            //"  <Issuer AltName #2> \n"
			DisplayAltNameExtension(IDS_ISS_ALT2,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0)
			//"  <NextUpdateLocation> \n"
            DisplayAltNameExtension(IDS_NEXT_UPDATE_LOC,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE_RESTRICTION) == 0)
            DisplayKeyUsageRestrictionExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS) == 0)
            DisplayBasicConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE) == 0)
            DisplayKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS2) == 0)
            DisplayBasicConstraints2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES) == 0)
			//"  <Certificate Policies> \n"
            DisplayPoliciesExtension(IDS_CERT_POLICIES,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_SP_AGENCY_INFO_OBJID) == 0)
            DisplaySpcSpAgencyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_FINANCIAL_CRITERIA_OBJID) == 0)
            DisplaySpcFinancialCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
       else if (strcmp(pszObjId, SPC_MINIMAL_CRITERIA_OBJID) == 0)
      		DisplaySpcMinimalCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_COMMON_NAME) == 0)
            DisplayCommonNameExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
            DisplayEnhancedKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_RSA_SMIMECapabilities) == 0)
            DisplaySMIMECapabilitiesExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // CRL extensions
        else if (strcmp(pszObjId, szOID_CRL_REASON_CODE) == 0)
            DisplayCRLReason(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // Netscape extensions
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_TYPE) == 0)
			//"  <NetscapeCertType> \n"
            DisplayBits(IDS_NSCP_CERT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_BASE_URL) == 0)
            //"  <NetscapeBaseURL> \n"
			DisplayAnyString(IDS_NSCP_BASE,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_REVOCATION_URL) == 0)
            //"  <NetscapeRevocationURL> \n"
			DisplayAnyString(IDS_NSCP_REV,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_REVOCATION_URL) == 0)
			//"  <NetscapeCARevocationURL> \n"
            DisplayAnyString(IDS_NSCP_CA_REV,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_RENEWAL_URL) == 0)
            //"  <NetscapeCertRenewalURL> \n"
			DisplayAnyString(IDS_NSCP_RENEW,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_POLICY_URL) == 0)
            //"  <NetscapeCAPolicyURL> \n"
			DisplayAnyString(IDS_NSCP_CA_URL,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_SSL_SERVER_NAME) == 0)
            //"  <NetscapeSSLServerName> \n"
			DisplayAnyString(IDS_NSCP_SSL,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_COMMENT) == 0)
			//"  <NetscapeComment> \n"
            DisplayAnyString(IDS_NSCP_COM,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
		else if(0==(dwDisplayFlags & ITEM_VERBOSE))
			PrintBytes(L"    ", pExt->Value.pbData, pExt->Value.cbData);


    }
}


//+-------------------------------------------------------------------------
//  DisplaySMIMECapabilitiesExtension
//--------------------------------------------------------------------------
 void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_SMIME_CAPABILITIES pInfo;
    DWORD cCap;
    PCRYPT_SMIME_CAPABILITY pCap;
    DWORD i;

    if (NULL == (pInfo =
            (PCRYPT_SMIME_CAPABILITIES) TestNoCopyDecodeObject(
                PKCS_SMIME_CAPABILITIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cCap = pInfo->cCapability;
    pCap = pInfo->rgCapability;

	//"  <SMIME Capabilties>\n"
	IDSwprintf(hModule, IDS_SMIME);

    if (cCap == 0)
        IDSwprintf(hModule, IDS_NONE);

    for (i = 0; i < cCap; i++, pCap++) 
	{
        LPSTR pszObjId = pCap->pszObjId;

        printf("    [%d] %s (%S)", i, pszObjId, GetOIDName(pszObjId));
        if (pCap->Parameters.cbData) 
		{
            //"  Parameters::\n"
			IDSwprintf(hModule, IDS_PARAMS);

            PrintBytes(L"      ",
                pCap->Parameters.pbData,
                pCap->Parameters.cbData);
        } else
            printf("\n");
    }

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayEnhancedKeyUsageExtension
//--------------------------------------------------------------------------
 void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    //"  <EnhancedKeyUsage> \n");
	IDSwprintf(hModule, IDS_ENH_KEY_USAGE);
    DecodeAndDisplayCtlUsage(pbEncoded, cbEncoded, dwDisplayFlags);
}

//+-------------------------------------------------------------------------
//  DisplaySpcFinancialCriteriaExtension
//--------------------------------------------------------------------------
 void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_VALUE pInfo = NULL;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_NAME_VALUE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

	//"  <Common Name> \n"
	IDSwprintf(hModule, IDS_COMMON_NAME);

    cwsz = CertRDNValueToStrW(
        pInfo->dwValueType,
        &pInfo->Value,
        NULL,               // pwsz
        0                   // cwsz
        );
    if (cwsz > 1) 
	{
        pwsz = (LPWSTR)ToolUtlAlloc(cwsz * sizeof(WCHAR));
        if (pwsz)
            CertRDNValueToStrW(
                pInfo->dwValueType,
                &pInfo->Value,
                pwsz,
                cwsz
                );
    }

    //"  ValueType: %d String: ", 
	IDSwprintf(hModule, IDS_VALUE_STRING, pInfo->dwValueType);
    if (pwsz)
        wprintf(L"%s", pwsz);
    else
        IDSwprintf(hModule, IDS_NULL);

	printf("\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
    if (pwsz)
        ToolUtlFree(pwsz);
}

//+-------------------------------------------------------------------------
//  DisplaySpcFinancialCriteriaExtension
//--------------------------------------------------------------------------
 void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    SPC_FINANCIAL_CRITERIA FinancialCriteria;
    DWORD cbInfo = sizeof(FinancialCriteria);
    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            SPC_FINANCIAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &FinancialCriteria,
            &cbInfo
            )) {
        return;
    }

    //"  <FinancialCriteria> \n "
	IDSwprintf(hModule, IDS_FIN_CRI);

    if (FinancialCriteria.fFinancialInfoAvailable)
        //"Financial Info Available.");
		IDSwprintf(hModule, IDS_FIN_AVAI);
    else
        IDSwprintf(hModule, IDS_NONE);

    if (FinancialCriteria.fMeetsCriteria)
		//" Meets Criteria."
		IDSwprintf(hModule, IDS_MEET_CRI);
    else
		//"	Doesn't Meets Criteria."
        IDSwprintf(hModule, IDS_NO_MEET_CRI);
    printf("\n");
}

//+-------------------------------------------------------------------------
//  DisplaySpcMinimalCriteriaExtension
//--------------------------------------------------------------------------
 void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL fMinimalCriteria;
    DWORD cbInfo = sizeof(fMinimalCriteria);

    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            SPC_MINIMAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &fMinimalCriteria,
            &cbInfo)) {
        return;
    }

    //"  <MinimalCriteria> \n ");
	IDSwprintf(hModule, IDS_MIN_CRI);

    if (fMinimalCriteria)
        //"Meets Minimal Criteria."
		IDSwprintf(hModule, IDS_MEET_MIN);
    else
        //"Doesn't Meet Minimal Criteria."
		IDSwprintf(hModule, IDS_NO_MEET_MIN);
    printf("\n");
}

//+-------------------------------------------------------------------------
//  DisplaySpcLink
//--------------------------------------------------------------------------
void DisplaySpcLink(PSPC_LINK pSpcLink)
{
    switch (pSpcLink->dwLinkChoice) 
	{
    case SPC_URL_LINK_CHOICE:
        //"URL=> %S\n", );
		IDSwprintf(hModule, IDS_SPC_URL, pSpcLink->pwszUrl);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        wprintf(L"%s\n", GuidText((GUID *) pSpcLink->Moniker.ClassId));

        if (pSpcLink->Moniker.SerializedData.cbData)
		{
            //"     SerializedData::\n");
			IDSwprintf(hModule, IDS_SERIAL_DATA);
            PrintBytes(L"    ", pSpcLink->Moniker.SerializedData.pbData,
                pSpcLink->Moniker.SerializedData.cbData);
        }
        break;
    case SPC_FILE_LINK_CHOICE:
        //"FILE=> %S\n", 
		IDSwprintf(hModule, IDS_SPC_FILE,pSpcLink->pwszFile);
        break;
    default:
        //"Unknown SPC Link Choice:: %d\n", 
		IDSwprintf(hModule, IDS_UNKNOWN_SPC, pSpcLink->dwLinkChoice);
    }
}

 
//+-------------------------------------------------------------------------
//  DisplaySpcSpAgencyExtension
//--------------------------------------------------------------------------
 void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSPC_SP_AGENCY_INFO pInfo;
    if (NULL == (pInfo = (PSPC_SP_AGENCY_INFO) TestNoCopyDecodeObject(
            SPC_SP_AGENCY_INFO_OBJID,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    //"  <SpcSpAgencyInfo> \n");
	IDSwprintf(hModule, IDS_SPC_AGENCY);

    if (pInfo->pPolicyInformation) 
	{
        //"    PolicyInformation: "
		IDSwprintf(hModule, IDS_POL_INFO);
        DisplaySpcLink(pInfo->pPolicyInformation);
    }

    if (pInfo->pwszPolicyDisplayText) 
	{
        //"    PolicyDisplayText: %s\n", 
		IDSwprintf(hModule, IDS_POL_DIS, pInfo->pwszPolicyDisplayText);
    }

    if (pInfo->pLogoImage) 
	{
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) 
		{
            //"    ImageLink: ");
			IDSwprintf(hModule, IDS_IMG_LINK);
            DisplaySpcLink(pImage->pImageLink);
        }
        if (pImage->Bitmap.cbData) 
		{
            //"    Bitmap:\n");
			IDSwprintf(hModule, IDS_BITMAP);
            PrintBytes(L"    ", pImage->Bitmap.pbData, pImage->Bitmap.cbData);
        }
        if (pImage->Metafile.cbData) 
		{
            //"    Metafile:\n");
			IDSwprintf(hModule, IDS_META_FILE);

            PrintBytes(L"    ", pImage->Metafile.pbData,
                pImage->Metafile.cbData);
        }
        if (pImage->EnhancedMetafile.cbData) 
		{
            //"    EnhancedMetafile:\n");
			IDSwprintf(hModule, IDS_ENH_META);

            PrintBytes(L"    ", pImage->EnhancedMetafile.pbData,
                pImage->EnhancedMetafile.cbData);
        }
        if (pImage->GifFile.cbData) 
		{
            //"    GifFile:\n"
			IDSwprintf(hModule, IDS_GIF_FILE);

            PrintBytes(L"    ", pImage->GifFile.pbData,
                pImage->GifFile.cbData);
        }
    }
    if (pInfo->pLogoLink) 
	{
        //"    LogoLink: ");
		IDSwprintf(hModule, IDS_LOGO_LINK);

        DisplaySpcLink(pInfo->pLogoLink);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayPoliciesExtension
//--------------------------------------------------------------------------
 void DisplayPoliciesExtension(
    int		idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICIES_INFO pInfo;
    DWORD cPolicy;
    PCERT_POLICY_INFO pPolicy;
    DWORD i;

    if (NULL == (pInfo =
            (PCERT_POLICIES_INFO) TestNoCopyDecodeObject(
                X509_CERT_POLICIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cPolicy = pInfo->cPolicyInfo;
    pPolicy = pInfo->rgPolicyInfo;


	//Display the name of the extension
	IDSwprintf(hModule, idsIDS);

    if (cPolicy == 0)
          IDSwprintf(hModule, IDS_NONE);

    for (i = 0; i < cPolicy; i++, pPolicy++) 
	{
        DWORD cQualifier = pPolicy->cPolicyQualifier;
        PCERT_POLICY_QUALIFIER_INFO pQualifier;
        DWORD j;
        printf("    [%d] %s", i, pPolicy->pszPolicyIdentifier);

        if (cQualifier)	
			//" Qualifiers:: \n"
			IDSwprintf(hModule, IDS_QUALI);

        pQualifier = pPolicy->rgPolicyQualifier;
        for (j = 0; j < cQualifier; j++, pQualifier++) 
		{
            printf("      [%d] %s", j, pQualifier->pszPolicyQualifierId);

            if (pQualifier->Qualifier.cbData) 
			{
                //" Encoded Data::\n"
				IDSwprintf(hModule, IDS_ENCODED_DATA);
                PrintBytes(L"    ",
                    pQualifier->Qualifier.pbData, pQualifier->Qualifier.cbData);
            } else
                printf("\n");
                    
        }
    }

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayKeyUsageExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    BYTE bFlags;

    if (NULL == (pInfo =
            (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
                X509_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    //"  <KeyUsage> \n"
	IDSwprintf(hModule, IDS_KEY_USAGE);

    if (pInfo->cbData)
        bFlags = *pInfo->pbData;
    else
        bFlags = 0;

	DisplayKeyUsage(bFlags);

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayBasicConstraints2Extension
//--------------------------------------------------------------------------
 void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    
	//"  <Basic Constraints2> \n"
	IDSwprintf(hModule, IDS_BASIC_CON2);


    if (pInfo->fCA)
		IDSwprintf(hModule, IDS_SUB_CA);
    else
		IDSwprintf(hModule, IDS_SUB_EE);

	printf("\n");

    //"  PathLenConstraint:: "
	IDSwprintf(hModule, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        IDSwprintf(hModule, IDS_NONE);

    printf("\n");

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayBasicConstraintsExtension
//--------------------------------------------------------------------------
 void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;


	//"  <Basic Constraints> \n"
	IDSwprintf(hModule, IDS_BASIC_CON);

	//"  SubjectType:: ";
	IDSwprintf(hModule, IDS_SUB_TYPE);

    if (pInfo->SubjectType.cbData == 0)
          IDSwprintf(hModule, IDS_NONE);
	else
	{
		BYTE bSubjectType = *pInfo->SubjectType.pbData;

        if (bSubjectType == 0)
          IDSwprintf(hModule, IDS_NONE);

        if (bSubjectType & CERT_CA_SUBJECT_FLAG)
            //"  CA ");
			IDSwprintf(hModule, IDS_SUB_CA);

        if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
            //"  END_ENTITY ")
			IDSwprintf(hModule, IDS_SUB_EE);
    }

    printf("\n");

    //"  PathLenConstraint:: "
	IDSwprintf(hModule, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        IDSwprintf(hModule, IDS_NONE_NOELN);

    printf("\n");

    if (pInfo->cSubtreesConstraint) 
	{
        DWORD i;
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        for (i = 0; i < pInfo->cSubtreesConstraint; i++, pSubtrees++) 
		{
            //"  SubtreesConstraint[%d]::\n"
			IDSwprintf(hModule, IDS_SUB_CON, i);
            DecodeName(pSubtrees->pbData, pSubtrees->cbData, dwDisplayFlags);
        }
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayKeyUsageRestrictionExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsage(BYTE	bFlags)
{
        if (bFlags == 0)
            IDSwprintf(hModule, IDS_NONE);
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            //"DIGITAL_SIGNATURE "
			IDSwprintf(hModule, IDS_DIG_SIG);
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            //"NON_REPUDIATION "
			IDSwprintf(hModule, IDS_NON_REP);
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            //"KEY_ENCIPHERMENT "
			IDSwprintf(hModule, IDS_KEY_ENCI);
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            //"DATA_ENCIPHERMENT ");
			IDSwprintf(hModule, IDS_DATA_ENCI);
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            //"KEY_AGREEMENT ");
			IDSwprintf(hModule, IDS_KEY_AGRE);
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            //"KEY_CERT_SIGN "
			IDSwprintf(hModule, IDS_CERT_SIGN);
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            //"OFFLINE_CRL_SIGN "
			IDSwprintf(hModule, IDS_OFFLINE_CRL);
        printf("\n");
}


//+-------------------------------------------------------------------------
//  DisplayKeyUsageRestrictionExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo;
    if (NULL == (pInfo =
            (PCERT_KEY_USAGE_RESTRICTION_INFO) TestNoCopyDecodeObject(
                X509_KEY_USAGE_RESTRICTION,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;
				   
	//Display the name of the certificate
	//"  <KeyUsageRestriction> \n "
	IDSwprintf(hModule, IDS_KEY_RESTRIC);

    if (pInfo->cCertPolicyId) 
	{
        DWORD i, j;

		//"  CertPolicySet::\n"
		IDSwprintf(hModule, IDS_CERT_POLICY);

        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        for (i = 0; i < pInfo->cCertPolicyId; i++, pPolicyId++) 
		{
            if (pPolicyId->cCertPolicyElementId == 0)
                printf("     [%d,*] %s\n", i, g_szNULL);

            LPSTR *ppszObjId = pPolicyId->rgpszCertPolicyElementId;
            for (j = 0; j < pPolicyId->cCertPolicyElementId; j++, ppszObjId++) 
			{
                LPSTR pszObjId = *ppszObjId;
                if (pszObjId == NULL)
                    pszObjId = g_szNULL;
                printf("     [%d,%d] %s\n", i, j, pszObjId);
            }
        }
    }

    if (pInfo->RestrictedKeyUsage.cbData) 
	{
        BYTE bFlags = *pInfo->RestrictedKeyUsage.pbData;

        //"  RestrictedKeyUsage:: "
		IDSwprintf(hModule, IDS_RESTRIC_KEY);
	
		DisplayKeyUsage(bFlags);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayCRLReason
//--------------------------------------------------------------------------
 void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    DWORD cbInfo;
    int CRLReason;

    cbInfo = sizeof(CRLReason);
    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            szOID_CRL_REASON_CODE,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &CRLReason,
            &cbInfo
            )) 
	{
        return;
    }

	//"  <CRL Reason> \n");
    IDSwprintf(hModule, IDS_CRL_REASON);
    switch (CRLReason) 
	{
        case CRL_REASON_UNSPECIFIED:
            //"REASON_UNSPECIFIED"
			IDSwprintf(hModule, IDS_CRL_UNSPECIFIED);
            break;
        case CRL_REASON_KEY_COMPROMISE:
            //"KEY_COMPROMISE"
			IDSwprintf(hModule, IDS_KEY_COMP);
            break;
        case CRL_REASON_CA_COMPROMISE:
            //"CA_COMPROMISE"
			IDSwprintf(hModule, IDS_CA_COMP);
            break;
        case CRL_REASON_AFFILIATION_CHANGED:
            //"AFFILIATION_CHANGED"
			IDSwprintf(hModule, IDS_AFFI_CHANGED);
            break;
        case CRL_REASON_SUPERSEDED:
            //"SUPERSEDED"
			IDSwprintf(hModule, IDS_SUPERSEDED);
            break;
        case CRL_REASON_CESSATION_OF_OPERATION:
            //"CESSATION_OF_OPERATION"
			IDSwprintf(hModule, IDS_CESS_OPER);
            break;
        case CRL_REASON_CERTIFICATE_HOLD:
            //"CERTIFICATE_HOLD"
			IDSwprintf(hModule, IDS_CERT_HOLD);
            break;
        case CRL_REASON_REMOVE_FROM_CRL:
            //REMOVE_FROM_CRL);
			IDSwprintf(hModule, IDS_REMOVE_CRL);
            break;
        default:
            printf("%d", CRLReason);
            break;
    }
    
	printf("\n");
}
//+-------------------------------------------------------------------------
//  DisplayAltNameExtension
//--------------------------------------------------------------------------
 void DisplayAltNameExtension(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    IDSwprintf(hModule, idsIDS);
    DecodeAndDisplayAltName(pbEncoded, cbEncoded, dwDisplayFlags);
}
//+-------------------------------------------------------------------------
//  DisplayKeyAttrExtension
//--------------------------------------------------------------------------
 void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_ATTRIBUTES_INFO pInfo;
    if (NULL == (pInfo = (PCERT_KEY_ATTRIBUTES_INFO) TestNoCopyDecodeObject(
            X509_KEY_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//"  <KeyAttributes>\n"
	IDSwprintf(hModule ,IDS_KEY_ATTR);

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);

        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->IntendedKeyUsage.cbData) 
	{
        BYTE bFlags = *pInfo->IntendedKeyUsage.pbData;

        //"  IntendedKeyUsage:: "
		IDSwprintf(hModule, IDS_INTEND_KEY_USAGE);

        if (bFlags == 0)
            IDSwprintf(hModule, IDS_NONE);
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            //"DIGITAL_SIGNATURE "
			IDSwprintf(hModule, IDS_DIG_SIG);
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            //"NON_REPUDIATION "
			IDSwprintf(hModule, IDS_NON_REP);
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            //"KEY_ENCIPHERMENT "
			IDSwprintf(hModule, IDS_KEY_ENCI);
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            //"DATA_ENCIPHERMENT ");
			IDSwprintf(hModule, IDS_DATA_ENCI);
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            //"KEY_AGREEMENT ");
			IDSwprintf(hModule, IDS_KEY_AGRE);
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            //"KEY_CERT_SIGN "
			IDSwprintf(hModule, IDS_CERT_SIGN);
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            //"OFFLINE_CRL_SIGN "
			IDSwprintf(hModule, IDS_OFFLINE_CRL);
        printf("\n");
    }

    if (pInfo->pPrivateKeyUsagePeriod) 
	{
        PCERT_PRIVATE_KEY_VALIDITY p = pInfo->pPrivateKeyUsagePeriod;

		//"NotBefore:: %s\n"
		IDSwprintf(hModule, IDS_NOT_BEFORE, FileTimeText(&p->NotBefore));

		IDSwprintf(hModule, IDS_NOT_AFTER, FileTimeText(&p->NotAfter));
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayCrlDistPointsExtension
//--------------------------------------------------------------------------
 void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCRL_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CRL_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 == pInfo->cDistPoint)
		//"    NO CRL Distribution Points\n"
        IDSwprintf(hModule, IDS_NO_CRL_DIS);
    else 
	{
        DWORD cPoint = pInfo->cDistPoint;
        PCRL_DIST_POINT pPoint = pInfo->rgDistPoint;

        for (i = 0; i < cPoint; i++, pPoint++) 
		{
			//"  CRL Distribution Point[%d]\n"
            IDSwprintf(hModule,IDS_CRL_IDS_I, i);
            DWORD dwNameChoice = pPoint->DistPointName.dwDistPointNameChoice;
            switch (dwNameChoice) 
			{
                case CRL_DIST_POINT_NO_NAME:
                    break;
                case CRL_DIST_POINT_FULL_NAME:
					//"    FullName:\n"
                    IDSwprintf(hModule, IDS_CRL_DIS_FULL_NAME);

                    DisplayAltName(&pPoint->DistPointName.FullName,
                        dwDisplayFlags);
                    break;

                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                    //printf("    IssuerRDN: (Not Implemented)\n");
					IDSwprintf(hModule, IDS_CRL_RDN);
                    break;

                default:
                    //"    Unknown name choice: %d\n", dwNameChoice);
					IDSwprintf(hModule, IDS_CRL_UNKNOWN, dwNameChoice);
					break;
            }

            if (pPoint->ReasonFlags.cbData) 
			{
                BYTE bFlags;

                //"    ReasonFlags: "
				IDSwprintf(hModule, IDS_REASON_FLAG);
                bFlags = *pPoint->ReasonFlags.pbData;

                if (bFlags == 0)
					//"<NONE> \n"
					IDSwprintf(hModule, IDS_NONE);
                if (bFlags & CRL_REASON_UNUSED_FLAG)
                    //"UNUSED "
					IDSwprintf(hModule, IDS_REASON_UNUSED);
                if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
                    //"KEY_COMPROMISE "
					IDSwprintf(hModule, IDS_KEY_COMP);
                if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
					//"CA_COMPROMISE "
					IDSwprintf(hModule, IDS_CA_COMP);
                if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
                    //"AFFILIATION_CHANGED "
					IDSwprintf(hModule, IDS_AFFI_CHANGED);
                if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
                    //"SUPERSEDED "
					IDSwprintf(hModule, IDS_SUPERSEDED);
                if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
                    //"CESSATION_OF_OPERATION "
  					IDSwprintf(hModule, IDS_CESS_OPER);
				if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
                    //"CERTIFICATE_HOLD "
				  	IDSwprintf(hModule, IDS_CERT_HOLD);

                printf("\n");
            }

            if (pPoint->CRLIssuer.cAltEntry) 
			{
				//"    ISSUER::\n"
				IDSwprintf(hModule, IDS_CRL_ISSUER);

                DisplayAltName(&pPoint->CRLIssuer, dwDisplayFlags);
            }
        }
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayAuthorityKeyIdExtension
//--------------------------------------------------------------------------
 void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID_INFO pInfo;

	//"  <AuthorityKeyId>\n"
	IDSwprintf(hModule, IDS_AUTH_KEY_ID);

    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);
        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->CertIssuer.cbData) 
	{
		//"  AuthorityCertIssuer::\n"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER);
        DecodeName(pInfo->CertIssuer.pbData, pInfo->CertIssuer.cbData,
            dwDisplayFlags);
    }
    if (pInfo->CertSerialNumber.cbData) 
	{
		//"  CertSerialNumber::"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER);
        DisplaySerialNumber(&pInfo->CertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
 void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo;

	//"  <AuthorityKeyId #2>\n"
	IDSwprintf(hModule, IDS_AUTH_KEY_ID2);

    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID2_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID2,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);
        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->AuthorityCertIssuer.cAltEntry) 
	{
		//"  AuthorityCertIssuer::\n"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER);
        DisplayAltName(&pInfo->AuthorityCertIssuer, dwDisplayFlags);
    }

    if (pInfo->AuthorityCertSerialNumber.cbData) 
	{
		//"  AuthorityCertSerialNumber::"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER);
        DisplaySerialNumber(&pInfo->AuthorityCertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayAnyString
//--------------------------------------------------------------------------
 void DisplayAnyString(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_NAME_VALUE pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//print the pre-fix
	IDSwprintf(hModule, idsIDS);

    if (pInfo->dwValueType == CERT_RDN_ENCODED_BLOB ||
            pInfo->dwValueType == CERT_RDN_OCTET_STRING) 
	{
		//"ValueType: %d\n"
		IDSwprintf(hModule, IDS_VALUE_TYPE, pInfo->dwValueType);
        PrintBytes(L"    ", pInfo->Value.pbData, pInfo->Value.cbData);
    } else
		//"ValueType: %d String: %s\n"
		IDSwprintf(hModule, IDS_VALUE_STRING_S,
		pInfo->dwValueType, pInfo->Value.pbData);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayBits
//--------------------------------------------------------------------------
 void DisplayBits(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    IDSwprintf(hModule, idsIDS);

    if (1 == pInfo->cbData) 
	{
        printf(" %02X", *pInfo->pbData);
        if (pInfo->cUnusedBits)
		{
			//" (UnusedBits: %d)"
            IDSwprintf(hModule, IDS_UNUSED_BITS, pInfo->cUnusedBits);
		}
        printf("\n");
    } 
	else 
	{
        if (pInfo->cbData) 
		{
            printf("\n");
            PrintBytes(L"    ", pInfo->pbData, pInfo->cbData);
            IDSwprintf(hModule, IDS_UNUSED_BITS, pInfo->cUnusedBits);
			printf("\n");
        } 
		else
            IDSwprintf(hModule, IDS_NONE);
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayOctetString
//--------------------------------------------------------------------------
 void DisplayOctetString(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_DATA_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_DATA_BLOB) TestNoCopyDecodeObject(
            X509_OCTET_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    IDSwprintf(hModule, idsIDS);

    PrintBytes(L"    ", pInfo->pbData, pInfo->cbData);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo
		(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) 
	{
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return g_wszUnKnown;
}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints2
//--------------------------------------------------------------------------
 BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	WCHAR							wszFormat[100]=L"\0";
	WCHAR							wszLength[15];
	PCERT_BASIC_CONSTRAINTS2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;

	
	//check for input parameters
	if(( pbEncoded!=NULL && cbEncoded==0)
		||(pbEncoded==NULL && cbEncoded!=0)
		|| (pcbFormat==NULL))
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	//check for simple case.  No work needed
	if(pbEncoded==NULL && cbEncoded==0)
	{
		*pcbFormat=0;
		return TRUE;
	}

    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) 
			return FALSE;

    
	//"  <Basic Constraints2> \n"
	IDSwcscat(hModule, wszFormat, IDS_BASIC_CON2);
	

    if (pInfo->fCA)
		//"  CA ");
		IDSwcscat(hModule,wszFormat,IDS_SUB_CA);
    else
		//"  End-Entity"
		IDSwcscat(hModule,wszFormat, IDS_SUB_EE);

	//"\n"
	IDSwcscat(hModule, wszFormat, IDS_ELN);

    //"  PathLenConstraint:: "
	IDSwcscat(hModule, wszFormat, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
	{
        swprintf(wszLength, L"%d",pInfo->dwPathLenConstraint);

		wcscat(wszFormat, wszLength);
	}
    else
        IDSwcscat(hModule, wszFormat, IDS_NONE_NOELN);

    if (pInfo)
        ToolUtlFree(pInfo);

	cbNeeded=sizeof(WCHAR)*(wcslen(wszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		return TRUE;
	}


	if((*pcbFormat)<cbNeeded)
	{
		SetLastError(ERROR_MORE_DATA);
		return FALSE;
	}

	//copy the data
	memcpy(pbFormat, wszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	return TRUE;
}


//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
BOOL	InstalledFormat(LPSTR	szStructType, BYTE	*pbEncoded, DWORD cbEncoded)
{
	BOOL				fResult=FALSE;
	void				*pvFuncAddr=NULL;
    HCRYPTOIDFUNCADDR   hFuncAddr=NULL;
	DWORD				cbFormat=0;
	LPWSTR				wszFormat=NULL;
    DWORD               dwFormatStrType=0;

    if(TRUE==g_fMulti)
        dwFormatStrType |=CRYPT_FORMAT_STR_MULTI_LINE;


	if(NULL==pbEncoded || 0==cbEncoded)
		return FALSE;

	//load the formatting functions
	if (!CryptGetOIDFunctionAddress(
            hFormatFuncSet,
            g_dwCertEncodingType,
            szStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
		goto CLEANUP;


	//call the functions
	if(!((PFN_FORMAT_FUNC) pvFuncAddr)(
				g_dwCertEncodingType,     
				0,      
				dwFormatStrType,   
				NULL,    
				szStructType,   
				pbEncoded,   
				cbEncoded,         
				NULL,         
				&cbFormat     
            ))
		goto CLEANUP;


	//allocate
	wszFormat=(LPWSTR)ToolUtlAlloc(cbFormat * sizeof(WCHAR));

	if(!wszFormat)
		goto CLEANUP;
		
	if(!((PFN_FORMAT_FUNC) pvFuncAddr)(
				g_dwCertEncodingType,     
				0,      
				dwFormatStrType,   
				NULL,    
				szStructType,   
				pbEncoded,   
				cbEncoded,         
				wszFormat,         
				&cbFormat     
            ))
		goto CLEANUP;

   //print
	wprintf(L"%s\n", wszFormat);

	fResult=TRUE;

CLEANUP:

	if(wszFormat)
		ToolUtlFree(wszFormat);

	if(hFuncAddr)
		CryptFreeOIDFunctionAddress(hFuncAddr, 0);

	return fResult;

}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

 WCHAR *GuidText(GUID *pguid)
{
    static WCHAR buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    swprintf(buf, L"{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:      certmgr.h
//
//  Contents:   the header for CertMgr tool 
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef CERTMGR_H
#define CERTMGR_H


#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <unicode.h>	 
#include <wchar.h>

#include "wincrypt.h"
#include "mssip.h"
#include "wintrust.h"
#include "sipbase.h"
#include "unicode.h"
#include "toolutl.h"
#include "certhlp.h"
#include "resource.h"
#include "cryptui.h"



#endif  // CERTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makecert\makecert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       makecert.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
// MakeCert - x509 certificate generator
//
//            Generates test certificates for Software Publishers. The default
//            root key and certificate is stored as a program resource.
//
// HansHu   2/20/96 created
// Philh    5/17/96 changed to use wincert      
// Xiaohs   5/12/97 localization and change the command line options
//
//--------------------------------------------------------------------------
#define _CRYPT32_
#include "global.hxx"

//+-------------------------------------------------------------------------
//  contants
//--------------------------------------------------------------------------

//allow max 10 extensions per certificate
#define MAX_EXT_CNT 10

//+-------------------------------------------------------------------------
//  Parameters configurable via command line arguments
//--------------------------------------------------------------------------
BOOL     fUseSubjectPvkFile       = FALSE;
BOOL     fUseSubjectKeyContainer  = FALSE;
BOOL     fUseIssuerPvkFile        = FALSE;
BOOL	 fSetSubjectName		  = FALSE;		//use has specify the -n option

#if (1) //DSIE: Bug 205195
BOOL     fPrivateKeyExportable    = FALSE;
#endif

WCHAR*   wszSubjectKey            = NULL;
WCHAR*   wszSubjectCertFile       = NULL;
WCHAR*   wszSubjectStore          = NULL;
WCHAR*   wszSubjectStoreLocation  = NULL;
DWORD    dwSubjectStoreFlag       = CERT_SYSTEM_STORE_CURRENT_USER;

WCHAR*   wszIssuerKey             = NULL;
WCHAR*   wszIssuerCertFile        = NULL;
WCHAR*   wszIssuerStore           = NULL;
WCHAR*   wszIssuerStoreLocation   = NULL;
DWORD    dwIssuerStoreFlag        = CERT_SYSTEM_STORE_CURRENT_USER;
WCHAR*   wszIssuerCertName        = NULL;
DWORD    dwIssuerKeySpec          = 0;

WCHAR*   wszSubjectX500Name       = NULL;
WCHAR*   wszSubjectRequestFile    = NULL;
WCHAR*   wszPolicyLink            = NULL;
WCHAR*   wszOutputFile            = NULL;
WCHAR*   wszAuthority             = NULL;
WCHAR*   wszAlgorithm             = NULL;
WCHAR*   wszCertType              = NULL;
WCHAR*   wszIssuerKeyType         = NULL;
WCHAR*   wszSubjectKeyType        = NULL;
WCHAR*   wszEKUOids               = NULL;

DWORD   dwKeySpec               = 0;
BOOL    fCertIndividual         = FALSE;
BOOL    fCertCommercial         = FALSE;
BOOL    fSelfSigned             = FALSE;
BOOL    fGlueCert               = FALSE;
BOOL    fNetscapeClientAuth     = FALSE;
BOOL    fNoPubKeyPara           = FALSE;
BOOL	fNoVerifyPublic			= FALSE;
LPWSTR  wszIssuerProviderName   = NULL;
DWORD   dwIssuerProviderType    = PROV_RSA_FULL;
LPWSTR  wszSubjectProviderName  = NULL;
DWORD   dwSubjectProviderType   = PROV_RSA_FULL;
ALG_ID  algidHash               = CALG_MD5;
ULONG   ulSerialNumber          = 0;                // In future, allow serial nubmers of larger size
BOOL    fSetSerialNumber        = FALSE;
DWORD   dwCertStoreEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
BOOL    fIssuerInformation      = FALSE;
BOOL	fSubjectInformation		= FALSE;

LPWSTR  wszDhParaCertFile       = NULL;
DWORD   dwKeyBitLen             = 0;

WCHAR   wszGlue[10];
WCHAR   wszKey[10];
WCHAR   wszName[40];
WCHAR   wszRoot[40];
WCHAR   wszMakeCertRoot[40];   //used for indicating to use the root.cer.  Root is also a registry name
WCHAR   wszPlus[10];
WCHAR   wszNULL[10];

FILETIME g_ftNotBefore          = { 0, 0 };
FILETIME g_ftNotAfter           = { 0, 0 };
FILETIME g_ftZero               = { 0, 0 };
long     nMonths                = -1;

long     pathLenConstraint      = -1;
BYTE     certTypes              = 0;                // must be of type BYTE
CHAR*    szSignatureAlgObjId     = NULL;

static CERT_RDN_ATTR GlueRDNAttr=
    {
        SPC_GLUE_RDN_OBJID, CERT_RDN_PRINTABLE_STRING,
        {0, (BYTE *) wszGlue }
    };


//Global Data for loading the string
#define OPTION_SWITCH_SIZE  5


HMODULE hModule=NULL;

//---------------------------------------------------------------------------
//   Get the hModule hanlder and init two DLLMain.
//  
//---------------------------------------------------------------------------
BOOL    InitModule()
{
    if(!(hModule=GetModuleHandle(NULL)))
       return FALSE;
    
    return TRUE;
}

//-------------------------------------------------------------------------
//
//   BasicUsage()
//
//
//-------------------------------------------------------------------------
static void BasicUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_BASIC_OPTIONS);
    IDSwprintf(hModule,IDS_OPTION_SK_DESC);
#if (1) //DSIE: Bug 205195.
    IDSwprintf(hModule,IDS_OPTION_PE_DESC);
#endif
    IDSwprintf(hModule,IDS_OPTION_SS_DESC);
    IDSwprintf(hModule,IDS_OPTION_SS_DESC1);
    IDSwprintf(hModule,IDS_OPTION_SR_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT, IDS_OPTION_CU,
                            IDS_OPTION_LM,IDS_OPTION_CU );
    IDSwprintf(hModule,IDS_OPTION_SERIAL_DESC);
    IDSwprintf(hModule,IDS_OPTION_AUTH_DESC);
    IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_2, IDS_OPTION_AUTH_IND,
                        IDS_OPTION_AUTH_COM);
    IDSwprintf(hModule,IDS_OPTION_N_DESC);
    IDSwprintf(hModule,IDS_OPTION_BASIC_DESC);
    IDSwprintf(hModule,IDS_OPTION_EXTENDED_DESC);

}

//-------------------------------------------------------------------------
//
//   ExtendedUsage()
//
//
//-------------------------------------------------------------------------
static void ExtendedUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_EXTENDED_OPTIONS);
    IDSwprintf(hModule,IDS_OPTION_SC_DESC);
    IDSwprintf(hModule,IDS_OPTION_SV_DESC);
    IDSwprintf(hModule,IDS_OPTION_IC_DESC);
    IDSwprintf(hModule,IDS_OPTION_IK_DESC);
    IDSwprintf(hModule,IDS_OPTION_IV_DESC);
    IDSwprintf(hModule,IDS_OPTION_IS_DESC);
    IDSwprintf(hModule,IDS_OPTION_IR_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT, IDS_OPTION_CU,
        IDS_OPTION_LM,IDS_OPTION_CU );
    IDSwprintf(hModule,IDS_OPTION_IN_DESC);
    IDSwprintf(hModule,IDS_OPTION_ALGO_DESC, IDS_OPTION_ALGO);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT,IDS_OPTION_ALGO_MD5,
                            IDS_OPTION_ALGO_SHA, IDS_OPTION_ALGO_MD5);
    IDSwprintf(hModule,IDS_OPTION_IP_DESC);
    IDSwprintf(hModule,IDS_OPTION_IY_DESC);
    IDSwprintf(hModule,IDS_OPTION_SP_DESC);
    IDSwprintf(hModule,IDS_OPTION_SY_DESC);
    IDSwprintf(hModule,IDS_OPTION_IKY_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_KY, IDS_OPTION_KY_SIG,
                            IDS_OPTION_KY_EXC,IDS_OPTION_KY_SIG);
    IDSwprintf(hModule,IDS_OPTION_SKY_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_KY, IDS_OPTION_KY_SIG,
                            IDS_OPTION_KY_EXC,IDS_OPTION_KY_SIG);
    IDSwprintf(hModule,IDS_OPTION_L_DESC);
    IDSwprintf(hModule,IDS_OPTION_CY_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_3, IDS_OPTION_CY_END,
                            IDS_OPTION_CY_AUTH, IDS_OPTION_CY_BOTH);
    IDSwprintf(hModule,IDS_OPTION_B_DESC);
    IDSwprintf(hModule,IDS_OPTION_M_DESC);
    IDSwprintf(hModule,IDS_OPTION_E_DESC);
    IDSwprintf(hModule,IDS_OPTION_H_DESC);
//  IDSwprintf(hModule,IDS_OPTION_G_DESC);
    IDSwprintf(hModule,IDS_OPTION_R_DESC);
    IDSwprintf(hModule,IDS_OPTION_NSCP_DESC);
    IDSwprintf(hModule,IDS_OPTION_ENHKEY_USAGE_DESC);

    IDSwprintf(hModule,IDS_OPTION_BASIC_DESC);
    IDSwprintf(hModule,IDS_OPTION_EXTENDED_DESC);
}

static void UndocumentedUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);

    IDSwprintf(hModule,IDS_OPTION_SQ_DESC);
    IDSwprintf(hModule,IDS_OPTION_NOPUBKEYPARA_DESC);
    IDSwprintf(hModule,IDS_OPTION_DH_PARA_DESC);
    IDSwprintf(hModule,IDS_OPTION_KEY_LEN_DESC);
    IDSwprintf(hModule,IDS_OPTION_NOPUBVERIFY_DESC);
}

//+=========================================================================
//  Local Support Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintLastError(int ids)
{
    DWORD       dwErr = GetLastError(); 
    IDS_IDS_DW_DWwprintf(hModule,IDS_ERR_LAST, ids, dwErr, dwErr);
}
//+-------------------------------------------------------------------------
//  Allocation and free macros
//--------------------------------------------------------------------------
#define MakeCertAlloc(p1)   ToolUtlAlloc(p1, hModule, IDS_ERR_DESC_ALLOC)

#define MakeCertFree(p1)    ToolUtlFree(p1)

//-----------------------------------------------------------------------------
//
//  Calculate the number of days
//-----------------------------------------------------------------------------
WORD DaysInMonth(WORD wMonth, WORD wYear)
{
    static int mpMonthDays[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
                            //       J   F   M   A   M   J   J   A   S   O   N   D

    WORD w = (WORD)mpMonthDays[wMonth];
    if ((wMonth == 2) && (wYear % 4 == 0) && (wYear%400 == 0 || wYear%100 != 0))
        {
        w += 1;
        }
    return w;
}



//-----------------------------------------------------------------------------
//
// Convert the string into a FILETIME. Let OLE do a bunch of work for us.
//----------------------------------------------------------------------------
BOOL FtFromWStr(LPCWSTR wsz, FILETIME* pft)
{
    memset(pft, 0, sizeof(*pft));

    WCHAR   wszMonth[3];
    DWORD   lcid=0;
    WORD    langid=0;

    //make sure wsz follows the mm/dd/yyyy
    if(wcslen(wsz)!=wcslen(L"mm/dd/yyyy"))
        return FALSE;

    //make sure wsz starts with "mm"
    wszMonth[0]=wsz[0];
    wszMonth[1]=wsz[1];
    wszMonth[2]=L'\0';

    if(!((_wtol(wszMonth)>0)&&(_wtol(wszMonth)<=12)))
        return FALSE;

    if (wsz)
        {
        //
        // The DATE Type
        //
        // The DATE type is implemented using an 8-byte floating-point number.
        // Days are represented by whole number increments starting with 30
        // December 1899, midnight as time zero. Hour values are expressed
        // as the absolute value of the fractional part of the number.
        //
        // We are using the English locale since the input format
        // should always be mm/dd/yyyy
        //
        langid=MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        lcid = MAKELCID (langid, SORT_DEFAULT);

        DATE date;
        if (VarDateFromStr((LPWSTR)wsz, lcid, 0, &date) != S_OK)
            { return FALSE; }
        if (date < 0)
            { return FALSE; }                 // not implemented

        double days   = date;
        double hours  = ((days      - (LONG)    days) *   24);
        double minutes= ((hours     - (LONG)   hours) *   60);
        double seconds= ((minutes   - (LONG) minutes) *   60);
        double ms     = ((seconds   - (LONG) seconds) * 1000);

        SYSTEMTIME st;
        st.wYear    = 1899;
        st.wMonth   = 12;
        ULONG wDay  = 30 + (ULONG)days;
        st.wHour    =      (WORD)hours;
        st.wMinute  =      (WORD)minutes;
        st.wSecond  =      (WORD)seconds;
        st.wMilliseconds = (WORD)ms;

        //
        // Correct for rounding errors in the arithmetic
        //
        if (st.wMilliseconds >= 0.5)
            st.wSecond += 1;
        st.wMilliseconds = 0;
        if (st.wSecond >= 60)
            {
            st.wMinute += 1;
            st.wSecond -= 60;
            }
        if (st.wMinute >= 60)
            {
            st.wHour += 1;
            st.wMinute -= 60;
            }
        if (st.wHour >= 24)
            {
            st.wHour -= 24;
            }


        while (wDay > DaysInMonth(st.wMonth, st.wYear))
            {
            wDay   -= DaysInMonth(st.wMonth, st.wYear);
            st.wMonth += 1;
            if (st.wMonth > 12)
                {
                st.wMonth  = 1;
                st.wYear  += 1;
                }
            }

        st.wDay       = (WORD)wDay;
        st.wDayOfWeek = 0;

        FILETIME ft;
        SystemTimeToFileTime(&st, &ft);
        LocalFileTimeToFileTime(&ft, pft);

        return TRUE;
        }
    else
        return FALSE;
}



//-------------------------------------------------------------------------
//
// Set the parameters.  Each parameter can only be set once
//
//--------------------------------------------------------------------------
BOOL    SetParam(WCHAR **pwszParam, WCHAR *wszValue)
{
    if(*pwszParam!=NULL)
    {
        IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
        return FALSE;
    }

    *pwszParam=wszValue;

    if(NULL==wszValue)
        return FALSE;
    
    return TRUE;

}



//--------------------------------------------------------------------------
//
//  Command Line Parsing
//
//--------------------------------------------------------------------------
static BOOL ParseCommandLine(int argc, WCHAR* wargv[])
{
    
    for ( int i = 1; i < argc; ++i )
    {
        WCHAR*   p = wargv[i];
        
        if(IDSwcsnicmp(hModule,p, IDS_SWITCH1, 1)!=0 &&
            IDSwcsnicmp(hModule,p,IDS_SWITCH2, 1)!=0)
        {
            if(!SetParam(&wszOutputFile,p))
                goto BasicErr;
            else
                continue;
        }

        //move over to the real option
        ++p;

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SERIAL)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto BasicErr;

            ulSerialNumber=_wtol(p);
            fSetSerialNumber=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_H)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto ExtendedErr;


            pathLenConstraint=_wtol(p);

            if(pathLenConstraint < 0)
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_CY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszCertType, p))
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_M)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto ExtendedErr;

            nMonths=_wtol(p);

            if(nMonths < 0)
                goto ExtendedErr;

            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_B)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;


            if(!FtFromWStr(p, &g_ftNotBefore))
            {
                IDSwprintf(hModule, IDS_ERR_INVALID_B);
                goto ExtendedErr;
            }

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_E)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            if(!FtFromWStr(p, &g_ftNotAfter))
            {
                IDSwprintf(hModule, IDS_ERR_INVALID_E);
                goto ExtendedErr;
            }

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_AUTH)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszAuthority, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_R)==0)
        {
            fSelfSigned=TRUE;
            continue;   
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SK)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKey, p))
            {
                if(TRUE==fUseSubjectPvkFile)
                    IDSwprintf(hModule, IDS_ERR_SK_SV);

                goto BasicErr;
            }

            fUseSubjectKeyContainer=TRUE;
			fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SQ)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectRequestFile, p))
                goto UndocumentedErr;
            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SV)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKey, p))
            {
                if(TRUE==fUseSubjectKeyContainer)
                    IDSwprintf(hModule, IDS_ERR_SK_SV);
                goto ExtendedErr;
            }

			fSubjectInformation=TRUE;
            fUseSubjectPvkFile=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SC)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectCertFile, p))
                goto ExtendedErr;

			fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SS)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectStore, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SR)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectStoreLocation, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_N)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectX500Name, p))
                goto BasicErr;

			fSetSubjectName = TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IP)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerProviderName, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IY)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            dwIssuerProviderType=_wtol(p);

            fIssuerInformation = TRUE;

            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SP)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectProviderName, p))
                goto ExtendedErr;	 

			fSubjectInformation=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SY)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            dwSubjectProviderType=_wtol(p);

			fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IK)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKey, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IV)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKey, p))
                goto ExtendedErr;

            fUseIssuerPvkFile=TRUE;
            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IS)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerStore, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IR)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerStoreLocation,p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IN)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerCertName,p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IC)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerCertFile, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_L)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszPolicyLink, p))
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SKY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKeyType, p))
                goto ExtendedErr;

 			fSubjectInformation=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IKY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKeyType, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_ALGO)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszAlgorithm, p))
                goto ExtendedErr;

            continue;
        }

        if (IDSwcsicmp(hModule,p, IDS_OPTION_ENHKEY_USAGE)==0)
        {
            i++;
            p=wargv[i];

            if (!SetParam(&wszEKUOids, p))
                goto ExtendedErr;

            continue;
        }

		if(IDSwcsicmp(hModule,p, IDS_OPTION_NSCP)==0)
		{
			fNetscapeClientAuth = TRUE;
			continue;
		}

		if(IDSwcsicmp(hModule,p, IDS_OPTION_NOPUBVERIFY)==0)
		{
			fNoVerifyPublic = TRUE;
			continue;
		}		

        if(IDSwcsicmp(hModule,p, IDS_OPTION_EXTENDED)==0)
        {
            //display extended options
            goto ExtendedErr;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_TEST)==0)
        {
            //display extended options
            goto UndocumentedErr;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_NOPUBKEYPARA)==0)
        {
            fNoPubKeyPara = TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_DH_PARA)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszDhParaCertFile, p))
                goto UndocumentedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_KEY_LEN)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto UndocumentedErr;

            dwKeyBitLen=_wtol(p);

            continue;
        }

#if (1) //DSIE: Bug 205195.
        if(IDSwcsicmp(hModule,p, IDS_OPTION_PE)==0)
        {
            fPrivateKeyExportable=TRUE;
            continue;
        }
#endif

        //display basic options
        goto BasicErr;
    }

#if (1) //DSIE: Bug 205195.
    //Only change container name if request private key
    //to be exportable. This way we maintain backward
    //compatibility, and allow user to request private
    //key to be marked as exportable.
    //Note: If the private key is not marked as exportable,
    //      the hardcoded container name, "JoeSoft", is
    //      always used, which means more than one cert
    //      can share the same key pair.
    if (fPrivateKeyExportable)
    {
        UUID uuidContainerName;
        
        UuidCreate(&uuidContainerName);
        if (RPC_S_OK != UuidToStringU(&uuidContainerName, &wszSubjectKey))
        {
            IDSwprintf(hModule, IDS_ERR_PE_CONTAINER);
            goto BasicErr;
        }
    }
#endif

    //make sure the either output file or the subject' cert store is set
    if((wszOutputFile==NULL) && (wszSubjectStore==NULL))
    {
        IDSwprintf(hModule, IDS_ERR_NO_OUTPUT);
        goto BasicErr;
    }

    //set the authority
    if(wszAuthority)
    {
        if(IDSwcsicmp(hModule,wszAuthority, IDS_OPTION_AUTH_IND) == 0)
            fCertIndividual = TRUE;
        else
        {
            if(IDSwcsicmp(hModule,wszAuthority, IDS_OPTION_AUTH_COM) == 0)
                fCertCommercial = TRUE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_AUTH);
                goto BasicErr;
            }
        }
    }

    //set the algorithm
    if(wszAlgorithm)
    {
        if(IDSwcsicmp(hModule,wszAlgorithm, IDS_OPTION_ALGO_SHA) == 0)
            algidHash = CALG_SHA;
        else
        {
            if(IDSwcsicmp(hModule,wszAlgorithm, IDS_OPTION_ALGO_MD5) == 0)
                algidHash = CALG_MD5;   
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_ALGO);
                goto ExtendedErr;
            }
        }
    }

    //set the cert type
    if(wszCertType)
    {
        if(IDSwcsicmp(hModule,wszCertType, IDS_OPTION_CY_END) == 0)
            certTypes |= CERT_END_ENTITY_SUBJECT_FLAG;
        else
        {
            if(IDSwcsicmp(hModule,wszCertType, IDS_OPTION_CY_AUTH) == 0)
                certTypes |= CERT_CA_SUBJECT_FLAG;
            else
            {
                if(IDSwcsicmp(hModule,wszCertType, IDS_OPTION_CY_BOTH) == 0)
                {
                    certTypes |= CERT_CA_SUBJECT_FLAG;
                    certTypes |= CERT_END_ENTITY_SUBJECT_FLAG;
                }
                else
                {
                    IDSwprintf(hModule,IDS_ERR_NO_CY);
                    goto ExtendedErr;
                }
            }
        }
    }

    //set the issuer key type
    if(wszIssuerKeyType)
    {
        if(IDSwcsicmp(hModule,wszIssuerKeyType, IDS_OPTION_KY_SIG) == 0)
            dwIssuerKeySpec = AT_SIGNATURE;
        else
        {
            if(IDSwcsicmp(hModule,wszIssuerKeyType, IDS_OPTION_KY_EXC) == 0)
                dwIssuerKeySpec = AT_KEYEXCHANGE;
            else
                dwIssuerKeySpec=_wtol(wszIssuerKeyType);
        }

    }

    //set the subject key type
    if(wszSubjectKeyType)
    {
        if(IDSwcsicmp(hModule,wszSubjectKeyType, IDS_OPTION_KY_SIG) == 0)
            dwKeySpec = AT_SIGNATURE;
        else
        {
            if(IDSwcsicmp(hModule,wszSubjectKeyType, IDS_OPTION_KY_EXC) == 0)
                dwKeySpec = AT_KEYEXCHANGE;
            else
                dwKeySpec=_wtol(wszSubjectKeyType); 
        }

    }

    //determing the issuer store location
    if(wszIssuerStoreLocation)
    {
        if(IDSwcsicmp(hModule,wszIssuerStoreLocation, IDS_OPTION_CU) == 0)
            dwIssuerStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
        else
        {
            if(IDSwcsicmp(hModule,wszIssuerStoreLocation, IDS_OPTION_LM) == 0)
                dwIssuerStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_IR);
                goto ExtendedErr;
            }
        }
    }

    //determind the subject store location
    if(wszSubjectStoreLocation)
    {
        if(IDSwcsicmp(hModule,wszSubjectStoreLocation, IDS_OPTION_CU) == 0)
            dwSubjectStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
        else
        {
            if(IDSwcsicmp(hModule,wszSubjectStoreLocation, IDS_OPTION_LM) == 0)
                dwSubjectStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_IR);
                goto BasicErr;
            }
        }
    }

    //wszIssuerStore and wszIssuerKey can not be set at the same time
    if(wszIssuerKey || wszIssuerProviderName || wszIssuerKeyType)
    {
        if(wszIssuerStore || wszIssuerCertName)
        {
            //remind user that -ik, -iv, -ip can not be
            //set with -is, -in options
            IDSwprintf(hModule,IDS_ERR_TOO_MANY_STORE_KEY);
            goto ExtendedErr;
        }
    }

    //wszCertFile and wszCertName can not be set at the same time
    if(wszIssuerCertFile && wszIssuerCertName)
    {
        IDSwprintf(hModule, IDS_ERR_CERT_FILE_NAME);
        goto ExtendedErr;
    }

    //is wszIsserCertFile is NULL
    if(wszIssuerCertFile==NULL)
    {
        //we init wszIssuerKey to "MakeCertRoot" if there is no store
        //information
        if(wszIssuerStore==NULL)
        {
            if(wszIssuerKey)
            {
                //if wszIssuerKey is set, we have to set the IssuerCertFile
                IDSwprintf(hModule, IDS_ERR_NO_ISSUER_CER_FILE);
                goto ExtendedErr;
            }
            else
            {
                wszIssuerKey=wszMakeCertRoot;
            }
        }
    }
    else
    {
        //either wszIssuerStore or wszIssuerKey should be set
        if((!wszIssuerStore) && (!wszIssuerKey))
        {
            IDSwprintf(hModule, IDS_ERR_EITHER_STORE_OR_KEY);
            goto ExtendedErr;
        }
    }

    //for self signed certificate, user should not supply
    //issuer information
    if(fIssuerInformation && fSelfSigned)
    {
        IDSwprintf(hModule, IDS_NO_ISSUER_FOR_SELF_SIGNED);
        goto ExtendedErr;
    }

	//user can not request a self signed certificate with
	//a PKCS10 file.  We neither generate or have access
	//to the private key
	if(fSelfSigned && wszSubjectRequestFile)
	{
        IDSwprintf(hModule, IDS_NO_PKCS10_AND_SELF_SIGNED);
        goto ExtendedErr;
	}


	if(fSubjectInformation && wszSubjectRequestFile)
	{
        IDSwprintf(hModule, IDS_NO_PKCS10_AND_SUBJECT_PVK);
        goto ExtendedErr;
	}

    //for self signed certificate, copy the provider type 
    //to the issuer so that the signatureAlgObjID will
    //be corrrect
    if(fSelfSigned)
        dwIssuerProviderType = dwSubjectProviderType;

    // Set the signature and public key algorithm parameters
    if (PROV_DSS == dwIssuerProviderType ||
            PROV_DSS_DH == dwIssuerProviderType)
        szSignatureAlgObjId     = szOID_X957_SHA1DSA;
    else if (algidHash == CALG_SHA)
        szSignatureAlgObjId     = szOID_OIWSEC_sha1RSASign;
    else
        szSignatureAlgObjId     = szOID_RSA_MD5RSA;

    return TRUE;

BasicErr:
    BasicUsage();
    return FALSE;

ExtendedErr:
    ExtendedUsage();
    return FALSE;

UndocumentedErr:
	UndocumentedUsage();
	return FALSE;
}

static BOOL MakeCert();

//+-------------------------------------------------------------------------
//  Check if creating a self signed certificate
//--------------------------------------------------------------------------
static BOOL IsSelfSignedCert()
{
    return fSelfSigned;
}


//--------------------------------------------------------------------------
//
//    wmain
//
//--------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv)
{
    int status = 0;

    //get the module handle
    if(!InitModule())
        return -1;

    //load the string for Glue cert attribute
    if(!LoadStringU(hModule, IDS_GLUE,wszGlue, sizeof(wszGlue)/sizeof(wszGlue[0])))
        return -1;
    
    //load the string for wszSubjectKey and wszSubjectX500Name
    if(!LoadStringU(hModule, IDS_JOE_SOFT,
        wszKey, sizeof(wszKey)/sizeof(wszKey[0]))
      || !LoadStringU(hModule, IDS_JOE_NAME,
        wszName, sizeof(wszName)/sizeof(wszName[0]))
      || !LoadStringU(hModule, IDS_MAKECERT_ROOT,
         wszMakeCertRoot, sizeof(wszMakeCertRoot)/sizeof(wszMakeCertRoot[0]))
      || !LoadStringU(hModule, IDS_PLUS,
         wszPlus, sizeof(wszPlus)/sizeof(wszPlus[0]))
      || !LoadStringU(hModule, IDS_ROOT,
        wszRoot, sizeof(wszRoot)/sizeof(wszRoot[0]))
      )
        return -1;

    LoadStringU(hModule, IDS_NULL,
         wszNULL, sizeof(wszNULL)/sizeof(wszNULL[0]));

    // Parse the command line
    if (!ParseCommandLine(argc, wargv))
    {
        return -1;
    }

    //init wszSubjectKey and wszSubjectX500Name
    if(wszSubjectKey==NULL)
        wszSubjectKey=wszKey;

    if(wszSubjectX500Name==NULL)
        wszSubjectX500Name=wszName;

    if (FAILED(CoInitialize(NULL)))
    {
        IDSwprintf(hModule,IDS_ERR_COINIT);
        return -1;
    }

    // Get to work and make the certificate
    if (!MakeCert())
    {
        CoUninitialize();
        goto ErrorReturn;
    }

    //print out the success information
    IDSwprintf(hModule,IDS_SUCCEEDED);

CommonReturn:
    CoUninitialize();
    return status;

ErrorReturn:
    status = -1;
    IDSwprintf(hModule,IDS_ERR_FAILED);
    goto CommonReturn;
}

//+=========================================================================
//  MakeCert support functions
//==========================================================================

static BOOL IsRootKey();
static PCCERT_CONTEXT GetRootCertContext();
static HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer);
static PCCERT_CONTEXT GetIssuerCertContext();
static BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    );
static HCRYPTPROV GetIssuerProv(OUT LPWSTR *ppwszTmpContainer);
static HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer);
static HCRYPTPROV GetProvFromStore(IN   LPWSTR pwszStoreName);


static BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
static BOOL GetSubject(
    OUT PCCERT_CONTEXT *ppCertContext,
    OUT BYTE **ppbEncodedName,
    OUT DWORD *pcbEncodedName
    );
static BOOL GetRequestInfo(
    OUT PCERT_REQUEST_INFO *ppStuff);
static BOOL EncodeSubject(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL SignAndEncodeCert(
    HCRYPTPROV hProv,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );

static BOOL CreateAuthorityKeyId(
    IN HCRYPTPROV hProv,
    PCERT_INFO pIssuerCert,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateSpcSpAgency(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateBasicConstraints(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz);

BOOL    SaveCertToStore(HCRYPTPROV  hProv,      
                        DWORD       dwEncodingType,
                        LPWSTR      wszStore,       
                        DWORD       dwFlag,
                        BYTE        *pbEncodedCert, 
                        DWORD       cbEncodedCert,
                        LPWSTR      wszPvk,         
                        BOOL        fPvkFile,
                        DWORD       dwKeySpecification,
                        LPWSTR      wszCapiProv,        
                        DWORD       dwCapiProvType);


PCCERT_CONTEXT  GetIssuerCertAndStore(HCERTSTORE *phCertStore, BOOL *pfMore);

HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **ppHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore);


BOOL	EmptySubject(CERT_NAME_BLOB *pSubject);

BOOL	GetExtensionsFromRequest(PCERT_REQUEST_INFO  pReqInfo, DWORD *pdwCount, PCERT_EXTENSIONS **pprgExtensions);



//+=========================================================================
// Support functions to generate DH keys having the 'Q'parameter
//==========================================================================
static BOOL GenDhKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags
    );
static BOOL UpdateDhPublicKey(
    IN OUT PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
static BOOL IsDh3Csp();


//+-------------------------------------------------------------------------
//  Make the subject certificate. If the subject doesn't have a private
//  key, then, create.
//--------------------------------------------------------------------------
static BOOL MakeCert()
{
    BOOL fResult;

    HCRYPTPROV      hIssuerProv = 0;
    LPWSTR          pwszTmpIssuerContainer = NULL;
    BOOL            fDidIssuerAcquire=FALSE;
    LPWSTR          pwszTmpIssuerProvName=NULL;
    DWORD           dwTmpIssuerProvType;
    PCCERT_CONTEXT  pIssuerCertContext = NULL;
    HCERTSTORE      hIssuerCertStore=NULL;
    PCERT_INFO      pIssuerCert =NULL; // not allocated
    PCERT_REQUEST_INFO  pReqInfo =NULL;
    HCRYPTPROV      hSubjectProv = 0;
    LPWSTR          pwszTmpSubjectContainer = NULL;
    PCCERT_CONTEXT  pSubjectCertContext = NULL;
	DWORD				dwRequestExtensions=0;
	PCERT_EXTENSIONS	*rgpRequestExtensions=NULL;
	DWORD				dwExtIndex=0;
	DWORD				dwPerExt=0;
	DWORD				dwExistExt=0;

    PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo = NULL;         // not allocated
    PCERT_PUBLIC_KEY_INFO pAllocSubjectPubKeyInfo = NULL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded =0;
    BYTE *pbKeyIdEncoded = NULL;
    DWORD cbKeyIdEncoded =0;
    BYTE *pbSpcSpAgencyEncoded = NULL;
    DWORD cbSpcSpAgencyEncoded =0;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded =0;
    BYTE *pbKeyUsageEncoded = NULL;
    DWORD cbKeyUsageEncoded =0;
    BYTE *pbFinancialCriteria = NULL;
    DWORD cbFinancialCriteria =0;
    BYTE *pbBasicConstraintsEncoded = NULL;
    DWORD cbBasicConstraintsEncoded =0;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded =0;
    BYTE *pbEKUEncoded = NULL;
    DWORD cbEKUEncoded = 0;

    CERT_INFO Cert;
    GUID SerialNumber;

    CERT_EXTENSION *rgExt=NULL;
	DWORD			dwExtAlloc=0;
    DWORD			cExt = 0;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        szSignatureAlgObjId, 0, 0
    };

    BYTE *pbIssuerEncoded;  // not allocated
    DWORD cbIssuerEncoded;

    if (wszSubjectRequestFile)
    {
        if (!GetRequestInfo(&pReqInfo))
		{
			IDSwprintf(hModule,IDS_INVALID_REQUEST_FILE, wszSubjectRequestFile);
            goto ErrorReturn;
		}

        pSubjectPubKeyInfo = &(pReqInfo->SubjectPublicKeyInfo);

		if(!GetExtensionsFromRequest(pReqInfo, &dwRequestExtensions, &rgpRequestExtensions))
		{
			IDSwprintf(hModule,IDS_INVALID_ATTR_REQUEST_FILE, wszSubjectRequestFile);
			goto ErrorReturn;
		}
        
		//if the subject informatin is empt or user has supplied the subject
		//name through the command line, we use the command line options
		if(fSetSubjectName || wszSubjectCertFile || EmptySubject(&(pReqInfo->Subject)))
		{
			if (wszSubjectCertFile) 
			{
				// Get encoded subject name and public key from the subject cert
				if (!GetSubject(&pSubjectCertContext,
								&pbSubjectEncoded, &cbSubjectEncoded))
					goto ErrorReturn;
			} 
			else 
			{
				// Encode the subject name
				if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
					goto ErrorReturn;
			}
		}
		else
		{
			cbSubjectEncoded = pReqInfo->Subject.cbData;

			pbSubjectEncoded = (BYTE *) MakeCertAlloc(cbSubjectEncoded);

			if(NULL == pbSubjectEncoded)
				goto ErrorReturn;

			memcpy(pbSubjectEncoded, pReqInfo->Subject.pbData, cbSubjectEncoded);

		}
    }
    else
    {
        if (wszSubjectCertFile) 
		{
            // Get encoded subject name and public key from the subject cert
            if (!GetSubject(&pSubjectCertContext,
                            &pbSubjectEncoded, &cbSubjectEncoded))
                goto ErrorReturn;
            pSubjectPubKeyInfo = &pSubjectCertContext->pCertInfo->SubjectPublicKeyInfo;
        } 
		else 
		{
            //
            // Get access to the subject's (public) key, creating it if necessary
            //
            if (0 == (hSubjectProv = GetSubjectProv(&pwszTmpSubjectContainer)))
                goto ErrorReturn;

            if (!GetPublicKey(hSubjectProv, &pAllocSubjectPubKeyInfo))
                goto ErrorReturn;
            pSubjectPubKeyInfo = pAllocSubjectPubKeyInfo;

            //
            // Encode the subject name
            //
            if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
                goto ErrorReturn;
        }
    }

    //
    // Get access to the issuer's (private) key
    //
    if( IsSelfSignedCert())
    {
        hIssuerProv=hSubjectProv;
        dwIssuerKeySpec=dwKeySpec;

        pbIssuerEncoded = pbSubjectEncoded;
        cbIssuerEncoded = cbSubjectEncoded;
        pIssuerCert = &Cert;

       if (!VerifyIssuerKey(hIssuerProv, pSubjectPubKeyInfo))
            goto ErrorReturn;

    }
    else
    {   
        //get the hProv from the certificate store
        if(wszIssuerStore)
        {
            BOOL    fMore=FALSE;

            pwszTmpIssuerContainer=NULL;

            //get the non-root private key set based on the store name

            //first, get the certificate context from the cert store
            if(NULL==(pIssuerCertContext=GetIssuerCertAndStore(
                                            &hIssuerCertStore,
                                            &fMore)))
            {
                if(fMore==FALSE)
                    IDSwprintf(hModule, IDS_ERR_NO_ISSUER_CERT,
                                wszIssuerStore);
                else
                    IDSwprintf(hModule, IDS_ERR_MORE_ISSUER_CERT,
                                wszIssuerStore);

                goto ErrorReturn;
            }

            //second, get the hProv from the certifcate context
            if(!GetCryptProvFromCert(
                                    NULL,
                                    pIssuerCertContext,
                                    &hIssuerProv,
                                    &dwIssuerKeySpec,
                                    &fDidIssuerAcquire,
                                    &pwszTmpIssuerContainer,
                                    &pwszTmpIssuerProvName,
                                    &dwTmpIssuerProvType))
            {
                IDSwprintf(hModule, IDS_ERR_NO_PROV_FROM_CERT);
                goto ErrorReturn;
            }
        }
        else
        {

            if (0 == (hIssuerProv = GetIssuerProv(&pwszTmpIssuerContainer)))
                goto ErrorReturn;

            // Get the Issuer's Certificate
            if (NULL == (pIssuerCertContext = GetIssuerCertContext()))
                goto ErrorReturn;
            
        }

        // Verify the issuer's key. Its public key must match the one
        // in the issuer's provider
        //
        pIssuerCert = pIssuerCertContext->pCertInfo;

        if ((!fNoVerifyPublic) && (!VerifyIssuerKey(hIssuerProv, &pIssuerCert->SubjectPublicKeyInfo)))
            goto ErrorReturn;

        pbIssuerEncoded = pIssuerCert->Subject.pbData;
        cbIssuerEncoded = pIssuerCert->Subject.cbData;
    }


    //
    // Update the CERT_INFO
    //
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;

    if (fSetSerialNumber) {
        Cert.SerialNumber.pbData = (BYTE *) &ulSerialNumber;
        Cert.SerialNumber.cbData = sizeof(ulSerialNumber);
    } else {
        CoCreateGuid(&SerialNumber);
        Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
        Cert.SerialNumber.cbData = sizeof(SerialNumber);
    }

    Cert.SignatureAlgorithm = SignatureAlgorithm;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME st;
        
        //decide NotBefore

        // Let the user override the default validity endpoints
        //
        if (CompareFileTime(&g_ftNotBefore, &g_ftZero) != 0)
        {
            Cert.NotBefore = g_ftNotBefore;
        }
        else
        {
            // Default validity: now through end of 2039
            GetSystemTimeAsFileTime(&Cert.NotBefore);
        }

        //decide NotAfter
        if (CompareFileTime(&g_ftNotAfter, &g_ftZero) != 0)
        {
            Cert.NotAfter = g_ftNotAfter;
        }
        else
        {
            memset(&st, 0, sizeof(st));
            st.wYear  = 2039;
            st.wMonth = 12;
            st.wDay   = 31;
            st.wHour  = 23;
            st.wMinute= 59;
            st.wSecond= 59;
            SystemTimeToFileTime(&st, &Cert.NotAfter);
        }

        //add the number of months
        if (nMonths >= 0)
        {
            //if the user has specified NotAfter with -E switch, error
            if(CompareFileTime(&g_ftNotAfter, &g_ftZero) != 0)
                goto ErrorReturn;

            if (nMonths > 0)
            {
                FILETIME    tempFT;
                DWORD       dwMonth;
                SYSTEMTIME  tempST;
                BOOL        fFirstDayOfMonth;

                // 
                // Cert.NotBefore is stored as UTC, but the user has entered
                // nMonths based on local time, so convert to local time, then:
                // NotAfter = (NotBefore - 1 second) + nMonths
                // 
                if (!FileTimeToLocalFileTime(&Cert.NotBefore, &tempFT))
                    goto ErrorReturn;

                //
                // if the day is the first day of the month, then subtract
                // one second after the months are added to the NotBefore
                // time instead of before the months are added, otherwise
                // we could end up with the wrong ending date.
                //
                if (FileTimeToSystemTime(&tempFT, &tempST)) {               
                    fFirstDayOfMonth = (tempST.wDay == 1);
                }
                else {
                    goto ErrorReturn;
                }

                // Subtract one second from the starting date, and then
                // add the number of months to that time
                //
                // FILETIME is in units of 100 nanoseconds (10**-7)
                if (!fFirstDayOfMonth) {
                    unsigned __int64* pli = (unsigned __int64*) &tempFT;
                    *pli -= 10000000;       // ten million
                }
                
                if (!FileTimeToSystemTime(&tempFT, &st))
                    goto ErrorReturn;
                
                dwMonth = (DWORD) nMonths + st.wMonth;
                while (dwMonth > 12)
                {
                    dwMonth -= 12;
                    st.wYear += 1;
                }
                st.wMonth = (WORD) dwMonth;

                //
                // This loop is because the ending month may not have as
                // many days as the starting month... so the initial
                // ending day may not even exist, thus, loop until we
                // find one that does or we go below 28 (no month ever has
                // less than 28 days)
                //
                while(!SystemTimeToFileTime(&st, &tempFT)) {
                    if(st.wDay >= 29 )
                        st.wDay--;
                    else                    
                        goto ErrorReturn;
                }

                //
                // if first day of month then subtract our one second
                // after month calculations
                //
                if (fFirstDayOfMonth) {
                    unsigned __int64* pli = (unsigned __int64*) &tempFT;
                    *pli -= 10000000;       // ten million
                }

                if (!LocalFileTimeToFileTime(&tempFT, &Cert.NotAfter))
                    goto ErrorReturn;
            
            }
            else {
                
                if (!FileTimeToSystemTime(&Cert.NotBefore, &st))
                    goto ErrorReturn;

                if (!SystemTimeToFileTime(&st, &Cert.NotAfter))
                    goto ErrorReturn;
            }
        }
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pSubjectPubKeyInfo;

	//allocate memory to hold all the extensions
	dwExtAlloc = MAX_EXT_CNT;
	 
	for(dwExtIndex=0; dwExtIndex < dwRequestExtensions; dwExtIndex++)
		dwExtAlloc += (rgpRequestExtensions[dwExtIndex])->cExtension;

	rgExt = (CERT_EXTENSION *)MakeCertAlloc(dwExtAlloc * sizeof(CERT_EXTENSION));	
	if(NULL == rgExt)
		goto ErrorReturn;

	memset(rgExt, 0, dwExtAlloc * sizeof(CERT_EXTENSION));
	cExt=0;
	
    // Cert Extensions
    if (fNetscapeClientAuth) {
        // Set Netscape specific extensions

        static BYTE  rgXxxxData[] = { 0x30, 0x03, 0x02, 0x01, 0x00 };
        rgExt[cExt].pszObjId = "2.5.29.19";
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgXxxxData;
        rgExt[cExt].Value.cbData = sizeof(rgXxxxData);
        cExt++;

        static BYTE  rgNscpData[] = { 0x03, 0x02, 0x07, 0x80 };
        rgExt[cExt].pszObjId = "2.16.840.1.113730.1.1";
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgNscpData;
        rgExt[cExt].Value.cbData = sizeof(rgNscpData);
        cExt++;
    }

    if (pathLenConstraint >= 0 || certTypes) {
        if (!CreateBasicConstraints(
                &pbBasicConstraintsEncoded,
                &cbBasicConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_BASIC_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbBasicConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbBasicConstraintsEncoded;
        cExt++;
    }


    if (fCertCommercial || fCertIndividual) {
        if (!CreateKeyUsage(
                &pbKeyUsageEncoded,
                &cbKeyUsageEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_KEY_USAGE_RESTRICTION;
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbKeyUsageEncoded;
        rgExt[cExt].Value.cbData = cbKeyUsageEncoded;
        cExt++;
    }

    if (wszPolicyLink) {
        if (!CreateSpcSpAgency(
                &pbSpcSpAgencyEncoded,
                &cbSpcSpAgencyEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSpcSpAgencyEncoded;
        rgExt[cExt].Value.cbData = cbSpcSpAgencyEncoded;
        cExt++;
    }

    //if user has specified fCertCommercial or fCertIndividual,
    //we add the code signing oid to the EKU extensions
    if (wszEKUOids || fCertCommercial || fCertIndividual) {
        if (!CreateEnhancedKeyUsage(
                &pbEKUEncoded,
                &cbEKUEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbEKUEncoded;
        rgExt[cExt].Value.cbData = cbEKUEncoded;
        cExt++;
    }

    if (!CreateAuthorityKeyId(
            hIssuerProv,
            pIssuerCert,
            &pbKeyIdEncoded,
            &cbKeyIdEncoded))
        goto ErrorReturn;
    rgExt[cExt].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER;
    rgExt[cExt].fCritical = FALSE;
    rgExt[cExt].Value.pbData = pbKeyIdEncoded;
    rgExt[cExt].Value.cbData = cbKeyIdEncoded;
    cExt++;

	//we now combine the extension from the certificate request file.
	//In case of duplication of extensions, the command line options
	//have higher priority
	for(dwExtIndex=0; dwExtIndex < dwRequestExtensions; dwExtIndex++)
	{
		for(dwPerExt=0; dwPerExt < rgpRequestExtensions[dwExtIndex]->cExtension; dwPerExt++)
		{
			for(dwExistExt=0; dwExistExt<cExt; dwExistExt++)
			{
				if(0 == strcmp(rgExt[dwExistExt].pszObjId,
							(rgpRequestExtensions[dwExtIndex]->rgExtension[dwPerExt]).pszObjId))
					break;
			}

			//we merge if this is a new extension
			if(dwExistExt == cExt)
			{	
				memcpy(&(rgExt[cExt]), &(rgpRequestExtensions[dwExtIndex]->rgExtension[dwPerExt]), sizeof(CERT_EXTENSION));
				cExt++;
			}
		}
	}

    Cert.rgExtension = rgExt;
    Cert.cExtension = cExt;

    //
    // Sign and encode the certificate
    //
    cbCertEncoded = 0;
    CryptSignAndEncodeCertificate(
        hIssuerProv,
        dwIssuerKeySpec,
        X509_ASN_ENCODING,
        X509_CERT_TO_BE_SIGNED,
        &Cert,
        &Cert.SignatureAlgorithm,
        NULL,                       // pvHashAuxInfo
        NULL,                       // pbEncoded
        &cbCertEncoded
        );
    if (cbCertEncoded == 0) {
        PrintLastError(IDS_ERR_SIGN_ENCODE_CB);
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) MakeCertAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hIssuerProv,
            dwIssuerKeySpec,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError(IDS_ERR_SIGN_ENCODE);
        goto ErrorReturn;
    }

    //output the encoded certificate to an output file
    if(wszOutputFile)
    {

        if (S_OK!=OpenAndWriteToFile(wszOutputFile, pbCertEncoded, cbCertEncoded))
        {
            PrintLastError(IDS_ERR_DESC_WRITE);
            goto ErrorReturn;
        }
    }

    //output the encoded certificate to an cerificate store
    if(wszSubjectStore)
    {
       if((!SaveCertToStore(hSubjectProv, dwCertStoreEncodingType,
                wszSubjectStore, dwSubjectStoreFlag,
                pbCertEncoded, cbCertEncoded, wszSubjectKey, fUseSubjectPvkFile,
                dwKeySpec, wszSubjectProviderName, dwSubjectProviderType)))
       {
            PrintLastError(IDS_ERR_DESC_SAVE_STORE);
            goto ErrorReturn;

       }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:

    if((!IsSelfSignedCert()) && hIssuerProv)
    {
        if(wszIssuerStore)
        {
            FreeCryptProvFromCert(fDidIssuerAcquire,
                                  hIssuerProv,
                                  pwszTmpIssuerProvName,
                                  dwTmpIssuerProvType,
                                  pwszTmpIssuerContainer);
        }
        else
        {
            PvkFreeCryptProv(hIssuerProv, wszIssuerProviderName,
                            dwIssuerProviderType, pwszTmpIssuerContainer);
        }
    }

    PvkFreeCryptProv(hSubjectProv, wszSubjectProviderName,
                    dwSubjectProviderType,pwszTmpSubjectContainer);

    if (pIssuerCertContext)
        CertFreeCertificateContext(pIssuerCertContext);
    
    if(hIssuerCertStore)
        CertCloseStore(hIssuerCertStore, 0);

    if (pSubjectCertContext)
        CertFreeCertificateContext(pSubjectCertContext);

	//pReqInfo is allocated via CryptQueryObject
    if (pReqInfo)
        LocalFree((HLOCAL)pReqInfo); 

    if (pAllocSubjectPubKeyInfo)
        MakeCertFree(pAllocSubjectPubKeyInfo);
    if (pbSubjectEncoded)
        MakeCertFree(pbSubjectEncoded);
    if (pbKeyIdEncoded)
        MakeCertFree(pbKeyIdEncoded);
    if (pbSpcSpAgencyEncoded)
        MakeCertFree(pbSpcSpAgencyEncoded);
    if (pbEKUEncoded)
        MakeCertFree(pbEKUEncoded);
    if (pbSpcCommonNameEncoded)
        MakeCertFree(pbSpcCommonNameEncoded);
    if (pbKeyUsageEncoded)
        MakeCertFree(pbKeyUsageEncoded);
    if (pbFinancialCriteria)
        MakeCertFree(pbFinancialCriteria);
    if (pbBasicConstraintsEncoded)
        MakeCertFree(pbBasicConstraintsEncoded);
    if (pbCertEncoded)
        MakeCertFree(pbCertEncoded);  
	if (rgpRequestExtensions)
	{
		for(dwExtIndex=0; dwExtIndex<dwRequestExtensions; dwExtIndex++)
		{
			if(rgpRequestExtensions[dwExtIndex])
				MakeCertFree(rgpRequestExtensions[dwExtIndex]);	 
		}

		MakeCertFree(rgpRequestExtensions);
	}
	if (rgExt)
		MakeCertFree(rgExt);

    return fResult;
}

//+-------------------------------------------------------------------------
//  save the certificate to a certificate store.  Attach private key information
//  to the certificate
//--------------------------------------------------------------------------
BOOL    SaveCertToStore(
                HCRYPTPROV hProv,       DWORD dwEncodingType,
                LPWSTR wszStore,        DWORD dwFlag,
                BYTE *pbEncodedCert,    DWORD cbEncodedCert,
                LPWSTR wszPvk,          BOOL fPvkFile,
                DWORD dwKeySpecification,
                LPWSTR wszCapiProv,     DWORD dwCapiProvType)
{
        BOOL                    fResult=FALSE;
        HCERTSTORE              hStore=NULL;
        PCCERT_CONTEXT          pCertContext=NULL;
        CRYPT_KEY_PROV_INFO     KeyProvInfo;
        CRYPT_DATA_BLOB         dataBlob;
        DWORD                   cwchar;
        LPWSTR                  pwszPvkProperty=NULL;
        HRESULT                 hr=S_OK;

        HCRYPTPROV              hDefaultProvName=NULL;
        DWORD                   cbData=0;
        LPSTR                   pszName=NULL;
        LPWSTR                  pwszName=NULL;

        //init
        memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

        //open a cert store
        hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hProv,
            CERT_STORE_NO_CRYPT_RELEASE_FLAG|dwFlag,
            wszStore);

        if(hStore==NULL)
            goto CLEANUP;

        //add the encoded certificate to store
        if(!CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    &pCertContext))
            goto CLEANUP;


		//if user has specified a request file, there is no need to
		//add the private key property
		if(wszSubjectRequestFile)
		{
			fResult = TRUE;
			goto CLEANUP;
		}

        //add properties to the certificate
        KeyProvInfo.pwszContainerName=wszPvk;
        KeyProvInfo.pwszProvName=wszCapiProv,
        KeyProvInfo.dwProvType=dwCapiProvType,
        KeyProvInfo.dwKeySpec=dwKeySpecification;

        //if wszCapiProv is NULL, we get the default provider name
        if(NULL==wszCapiProv)
        {
            //get the default provider
            if(CryptAcquireContext(&hDefaultProvName,
                                    NULL,
                                    NULL,
                                    KeyProvInfo.dwProvType,
                                    CRYPT_VERIFYCONTEXT))
            {

                //get the provider name
                if(CryptGetProvParam(hDefaultProvName,
                                    PP_NAME,
                                    NULL,
                                    &cbData,
                                    0) && (0!=cbData))
                {

                    if(pszName=(LPSTR)MakeCertAlloc(cbData))
                    {
                        if(CryptGetProvParam(hDefaultProvName,
                                            PP_NAME,
                                            (BYTE *)pszName,
                                            &cbData,
                                            0))
                        {
                            pwszName=MkWStr(pszName);

                            KeyProvInfo.pwszProvName=pwszName;
                        }
                    }
                }
            }
        }

        //free the provider as we want
        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        hDefaultProvName=NULL;


        if(fPvkFile)
        {
            //add the property related to private key file
            if(S_OK != (hr=ComposePvkString(&KeyProvInfo,
                                 &pwszPvkProperty,
                                 &cwchar)))
            {
                SetLastError(hr);
                goto CLEANUP;
            }

            //set up
            dataBlob.cbData=cwchar*sizeof(WCHAR);
            dataBlob.pbData=(BYTE *)pwszPvkProperty;

            if(!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_PVK_FILE_PROP_ID,
                    0,
                    &dataBlob))
                goto CLEANUP;


        }
        else
        {
            //add property related to the key container
            if(!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    &KeyProvInfo))
                goto CLEANUP;
        }

        fResult=TRUE;

CLEANUP:

        //free the cert context
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        //free the cert store
        if(hStore)
             CertCloseStore(hStore, 0);

        if(pwszPvkProperty)
              MakeCertFree(pwszPvkProperty);

        if(pszName)
            MakeCertFree(pszName);

        if(pwszName)
           FreeWStr(pwszName);

        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        return fResult;

}

//+-------------------------------------------------------------------------
//  Check if the root issuer.
//--------------------------------------------------------------------------
static BOOL IsRootKey()
{
     if(IDSwcsicmp(hModule,(WCHAR *)wszIssuerKey, IDS_MAKECERT_ROOT) != 0)
         return FALSE;

     //in orde to be sure that we are using the default root, wszIssuerCertFile
     //has to NULL
     if(wszIssuerCertFile!=NULL)
         return FALSE;

     return TRUE;
}


//+-------------------------------------------------------------------------
//  Get the root's certificate from the program's resources
//--------------------------------------------------------------------------
static PCCERT_CONTEXT GetRootCertContext()
{
    PCCERT_CONTEXT  pCert = NULL;
    HRSRC           hRes;
    CHAR            szCer[10];

    //load the string CER
    if(!LoadStringA(hModule, IDS_CER, szCer, sizeof(szCer)/sizeof(szCer[0])))
    {
        IDSwprintf(hModule,IDS_ERR_LOAD_ROOT);
        return pCert;
    }


    //
    // The root certificate is stored as a resource of ours.
    // Load it...
    //
    if (0 != (hRes = FindResource(NULL, MAKEINTRESOURCE(IDR_ROOTCERTIFICATE),
                        szCer))) {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(NULL, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(NULL, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes)
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbRes, cbRes);
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (pCert == NULL)
        IDSwprintf(hModule,IDS_ERR_LOAD_ROOT);
    return pCert;
}

//+-------------------------------------------------------------------------
//  Get the root's private key from the program's resources and create
//  a temporary key provider container
//--------------------------------------------------------------------------
static HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV      hProv = 0;
    HRSRC           hRes;
    CHAR            szPvk[10];
    WCHAR           wszRootSig[40];

    //load the string CER
    if(!LoadStringA(hModule, IDS_PVK, szPvk, sizeof(szPvk)/sizeof(szPvk[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return hProv;
    }

    //load the string "Root Signature"
    if(!LoadStringU(hModule, IDS_ROOT_SIGNATURE, wszRootSig, sizeof(wszRootSig)/sizeof(wszRootSig[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return hProv;
    }




    *ppwszTmpContainer = NULL;

    if (0 != (hRes = FindResource(NULL, MAKEINTRESOURCE(IDR_PVKROOT), szPvk)))
    {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(NULL, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(NULL, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes) {
                PvkPrivateKeyAcquireContextFromMemory(
                    wszIssuerProviderName,
                    dwIssuerProviderType,
                    pbRes,
                    cbRes,
                    NULL,               // hwndOwner
                    wszRootSig,
                    &dwIssuerKeySpec,
                    &hProv,
                    ppwszTmpContainer
                    );
            }
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (hProv == 0)
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
    return hProv;
}

//+-------------------------------------------------------------------------
//  Get the issuer's certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT GetIssuerCertContext()
{
    if (IsRootKey())
    {
        PCCERT_CONTEXT pCert = NULL;
        wszIssuerKey=wszRoot;   

        // Get root certificate from the program's resources
        pCert=GetRootCertContext();

        wszIssuerKey=wszMakeCertRoot;

        return pCert;
    }
    else {
        PCCERT_CONTEXT pCert = NULL;
        BYTE *pb;
        DWORD cb;

        //make sure we have issuer's certificate
        if(wszIssuerCertFile)
        {

            if (S_OK==RetrieveBLOBFromFile(wszIssuerCertFile,&cb, &pb))
            {
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
                UnmapViewOfFile(pb);
            }
        }

        if (pCert == NULL)
            IDSwprintf(hModule,IDS_ERR_LOAD_ISSUER, wszIssuerCertFile);
        return pCert;
    }
}

//+-------------------------------------------------------------------------
//  Verify the issuer's certificate. The public key in the certificate
//  must match the public key associated with the private key in the
//  issuer's provider
//--------------------------------------------------------------------------
static BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    // Get issuer's public key
    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,                      
        dwIssuerKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0)
    {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwIssuerKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            pIssuerKeyInfo,
            pPubKeyInfo)) {
        // This might be the test root with an incorrectly
        // encoded public key. Convert to the capi representation and
        // compare.
        BYTE rgProvKey[256];
        BYTE rgCertKey[256];
        DWORD cbProvKey = sizeof(rgProvKey);
        DWORD cbCertKey = sizeof(rgCertKey);

        if (!CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pIssuerKeyInfo->PublicKey.pbData,
                    pIssuerKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgProvKey,
                    &cbProvKey)                             ||
            !CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pPubKeyInfo->PublicKey.pbData,
                    pPubKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgCertKey,
                    &cbCertKey)                             ||
                cbProvKey == 0 || cbProvKey != cbCertKey    ||
                memcmp(rgProvKey, rgCertKey, cbProvKey) != 0) {
            IDSwprintf(hModule,IDS_ERR_MISMATCH);
            goto ErrorReturn;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pPubKeyInfo)
        MakeCertFree(pPubKeyInfo);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the issuer's private signature key provider
//--------------------------------------------------------------------------
static HCRYPTPROV GetIssuerProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV      hProv=0;
    WCHAR           wszIssuerSig[40];

    //load the string "Issuer Signature"
    if(!LoadStringU(hModule, IDS_ISSUER_SIGNATURE, wszIssuerSig, sizeof(wszIssuerSig)/sizeof(wszIssuerSig[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return NULL;
    }


    if (IsRootKey())
    {
        wszIssuerKey=wszRoot;

        // Get root key from the program's resoures and create a temporary
        // key container
        hProv = GetRootProv(ppwszTmpContainer);

        wszIssuerKey=wszMakeCertRoot;
    }
    else
    {
        // get the non-root private key set from either pvk file
        // of the key container
        if(fUseIssuerPvkFile)
        {
            if(S_OK!=PvkGetCryptProv(
                                    NULL,
                                    wszIssuerSig,
                                    wszIssuerProviderName,
                                    dwIssuerProviderType,
                                    wszIssuerKey,
                                    NULL,
                                    &dwIssuerKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }
        else
        {
            if(S_OK!=PvkGetCryptProv(
                                    NULL,
                                    wszIssuerSig,
                                    wszIssuerProviderName,
                                    dwIssuerProviderType,
                                    NULL,
                                    wszIssuerKey,
                                    &dwIssuerKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }

        if (hProv == 0)
            IDSwprintf(hModule,IDS_ERR_ISSUER_KEY, wszIssuerKey);
    }
    return hProv;
}

//+-------------------------------------------------------------------------
//  Get the subject's private key provider
//--------------------------------------------------------------------------
static HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV  hProv=0;
    WCHAR       wszKeyName[40];
    int         ids;
    WCHAR       *wszRegKeyName=NULL;
    BOOL        fResult;
    HCRYPTKEY   hKey=NULL;
    UUID        TmpContainerUuid;

    
    if(dwKeySpec==AT_SIGNATURE)
         ids=IDS_SUB_SIG;
    else
         ids=IDS_SUB_EXCHANGE;

    //load the string
    if(!LoadStringU(hModule, ids, wszKeyName, sizeof(wszKeyName)/sizeof(wszKeyName[0])))
        goto CreateKeyError;
    
    //try to get the hProv from either a private key file or
    //key container
    if(fUseSubjectPvkFile)
    {
        if(S_OK != PvkGetCryptProv(NULL,
                                   wszKeyName,
                                   wszSubjectProviderName,
                                   dwSubjectProviderType,
                                   wszSubjectKey,
                                   NULL,
                                   &dwKeySpec,
                                   ppwszTmpContainer,
                                   &hProv))
            hProv=0;
    }
    else
    {
        if(S_OK != PvkGetCryptProv(NULL,
                                   wszKeyName,
                                   wszSubjectProviderName,
                                   dwSubjectProviderType,
                                   NULL,
                                   wszSubjectKey,
                                   &dwKeySpec,
                                   ppwszTmpContainer,
                                   &hProv))
            hProv=0;
    }

    //generate the private keys
    if (0 == hProv)
    {
        //now that we have to generate private keys, geneate
        //AT_SIGNATURE key

        if(dwKeySpec==0)
            dwKeySpec=AT_SIGNATURE;

        //when the subject PVK file is used
        if(fUseSubjectPvkFile)
        {
            // Create a temporary keyset to load the private key into
            if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
            {
                goto CreateKeyError;
            }

            if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
                (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
                goto CreateKeyError;

            BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

            // Open a new key container
            if (!CryptAcquireContextU(
                    &hProv,
                    wszRegKeyName,
                    wszSubjectProviderName,
                    dwSubjectProviderType,
                    CRYPT_NEWKEYSET               // dwFlags
                    ))
                goto CreateKeyError;

            // generate new keys in the key container
            if (AT_KEYEXCHANGE == dwKeySpec &&
                    PROV_DSS_DH == dwSubjectProviderType) {
                if (!GenDhKey(
                        hProv,
                        CRYPT_EXPORTABLE    // dwFlags
                        ))
                    goto ErrorReturn;
            } else if (!CryptGenKey(
                hProv,
                dwKeySpec,
                (dwKeyBitLen << 16) | CRYPT_EXPORTABLE,
                &hKey
                ))
                goto CreateKeyError;
            else
                CryptDestroyKey(hKey);

            // Save the key into the file and delete from the provider
            //
            HANDLE hFile = CreateFileU(
                wszSubjectKey,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,                   // lpsa
                CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL                    // hTemplateFile
                );

            if (hFile == INVALID_HANDLE_VALUE)
            {
                if (GetLastError() == ERROR_FILE_EXISTS)
                    IDSwprintf(hModule,IDS_ERR_SUB_FILE_EXIST, wszSubjectKey);
                else
                    IDSwprintf(hModule,IDS_ERR_SUB_FILE_CREATE, wszSubjectKey);

                fResult = FALSE;
            }
            else
            {
                DWORD dwFlags = 0;

                if (AT_KEYEXCHANGE == dwKeySpec &&
                        PROV_DSS_DH == dwSubjectProviderType &&
                        IsDh3Csp())
                    dwFlags |= CRYPT_BLOB_VER3;

                fResult = PvkPrivateKeySave(
                    hProv,
                    hFile,
                    dwKeySpec,
                    NULL,               // hwndOwner
                    wszKeyName,
                    dwFlags
                    );
            }

            //release hProv
            CryptReleaseContext(hProv, 0);

            fResult &= CryptAcquireContextU(
                            &hProv,
                            wszRegKeyName,
                            wszSubjectProviderName,
                            dwSubjectProviderType,
                            CRYPT_DELETEKEYSET);
            hProv = 0;

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                if (!fResult)
                    DeleteFileU(wszSubjectKey);
            }

            if (!fResult)
                goto CreateKeyError;

            //get hProv

            if(S_OK != PvkGetCryptProv(NULL,
                                    wszKeyName,
                                    wszSubjectProviderName,
                                    dwSubjectProviderType,
                                    wszSubjectKey,
                                    NULL,
                                    &dwKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }
        else
        {            
            // Open a new key container
            if (!CryptAcquireContextU(
                    &hProv,
                    wszSubjectKey,
                    wszSubjectProviderName,
                    dwSubjectProviderType,
                    CRYPT_NEWKEYSET               // dwFlags
                    ))
            goto CreateKeyError;

#if (0) //DSIE: Bug 205195.
            // generate new keys in the key container
            if (AT_KEYEXCHANGE == dwKeySpec &&
                    PROV_DSS_DH == dwSubjectProviderType) {
                if (!GenDhKey(
                        hProv,
                        0               // dwFlags
                        ))
                    goto ErrorReturn;
            } else if (!CryptGenKey(
                hProv,
                dwKeySpec,
                (dwKeyBitLen << 16),
                &hKey
                ))
                goto CreateKeyError;
            else
                CryptDestroyKey(hKey);
#else
            DWORD dwFlags = 0;

            if (fPrivateKeyExportable)
                dwFlags |= CRYPT_EXPORTABLE;

            if (AT_KEYEXCHANGE == dwKeySpec &&
                    PROV_DSS_DH == dwSubjectProviderType) {
                if (!GenDhKey(
                        hProv,
                        dwFlags               // dwFlags
                        ))
                    goto ErrorReturn;
            } else if (!CryptGenKey(
                hProv,
                dwKeySpec,
                (dwKeyBitLen << 16) | dwFlags,
                &hKey
                ))
                goto CreateKeyError;
            else
                CryptDestroyKey(hKey);
#endif
            //try to get the user key
            if (CryptGetUserKey(
                hProv,
                dwKeySpec,
                &hKey
                ))
            {
                CryptDestroyKey(hKey);
            }
            else
            {
                // Doesn't have the specified public key
                CryptReleaseContext(hProv, 0);
                hProv=0;
            }
        }

        if (0 == hProv )
        {
            IDSwprintf(hModule,IDS_ERR_SUB_KEY, wszSubjectKey);
            goto ErrorReturn;
        }
    }//hProv==0

    goto CommonReturn;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
CommonReturn:
    if(wszRegKeyName)
        MakeCertFree(wszRegKeyName);

    return hProv;
}



//+-------------------------------------------------------------------------
//  Allocate and get the public key info for the provider
//--------------------------------------------------------------------------
static BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        dwKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (fNoPubKeyPara) {
        pPubKeyInfo->Algorithm.Parameters.cbData = 0;
        pPubKeyInfo->Algorithm.Parameters.pbData = NULL;
    }

    if (AT_KEYEXCHANGE == dwKeySpec && PROV_DSS_DH == dwSubjectProviderType) {
        if (!UpdateDhPublicKey(&pPubKeyInfo))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        MakeCertFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encode the Glue Name from the input name by prepending the following
//  CERT_RDN_ATTR:
//   pszObjID       = SPC_GLUE_RDN_OBJID
//   dwValueType    = CERT_RDN_PRINTABLE_STRING
//   Value          = "Glue"
//--------------------------------------------------------------------------
static BOOL EncodeGlueName(
    IN PCERT_NAME_BLOB pName,
    OUT BYTE **ppbEncodedGlueName,
    OUT DWORD *pcbEncodedGlueName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cbNameInfo;

    CERT_NAME_INFO GlueNameInfo;
    DWORD cGlueRDN;
    PCERT_RDN pGlueRDN = NULL;

    BYTE *pbEncodedGlueName = NULL;
    DWORD cbEncodedGlueName;

    DWORD i;

    cbNameInfo = 0;
    CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            NULL,                   // pNameInfo
            &cbNameInfo
            );
    if (cbNameInfo == 0) goto ErrorReturn;
    if (NULL == (pNameInfo = (PCERT_NAME_INFO) MakeCertAlloc(cbNameInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            pNameInfo,
            &cbNameInfo)) goto ErrorReturn;

    cGlueRDN = pNameInfo->cRDN + 1;
    if (NULL == (pGlueRDN = (PCERT_RDN) MakeCertAlloc(cGlueRDN * sizeof(CERT_RDN))))
        goto ErrorReturn;

    pGlueRDN[0].cRDNAttr = 1;
    pGlueRDN[0].rgRDNAttr = &GlueRDNAttr;
    for (i = 1; i < cGlueRDN; i++)
        pGlueRDN[i] = pNameInfo->rgRDN[i - 1];
    GlueNameInfo.cRDN = cGlueRDN;
    GlueNameInfo.rgRDN = pGlueRDN;

    cbEncodedGlueName = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            &GlueNameInfo,
            NULL,                   // pbEncodedGlueName
            &cbEncodedGlueName
            );
    if (cbEncodedGlueName == 0) goto ErrorReturn;
    if (NULL == (pbEncodedGlueName = (BYTE *) MakeCertAlloc(cbEncodedGlueName)))
        goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            &GlueNameInfo,
            pbEncodedGlueName,
            &cbEncodedGlueName)) goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncodedGlueName) {
        MakeCertFree(pbEncodedGlueName);
        pbEncodedGlueName = NULL;
    }
    cbEncodedGlueName = 0;
    fResult = FALSE;
CommonReturn:
    if (pNameInfo)
        MakeCertFree(pNameInfo);
    if (pGlueRDN)
        MakeCertFree(pGlueRDN);

    *ppbEncodedGlueName = pbEncodedGlueName;
    *pcbEncodedGlueName = cbEncodedGlueName;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the subject's cert context and encoded name
//--------------------------------------------------------------------------
static BOOL GetRequestInfo(OUT CERT_REQUEST_INFO **ppCertInfo)
{
    BOOL fResult = FALSE;

	fResult = CryptQueryObject(
					CERT_QUERY_OBJECT_FILE,
					wszSubjectRequestFile,
					CERT_QUERY_CONTENT_FLAG_PKCS10,
					CERT_QUERY_FORMAT_FLAG_ALL,
					CRYPT_DECODE_ALLOC_FLAG,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,
					(const void **)ppCertInfo);

	return fResult;

}



//+-------------------------------------------------------------------------
//  GetExtensionsFromRequest
//
//		We get all the requested extensions from the PKCS10 request
//--------------------------------------------------------------------------
BOOL GetExtensionsFromRequest(PCERT_REQUEST_INFO  pReqInfo, DWORD *pdwCount, PCERT_EXTENSIONS **pprgExtensions)
{
	DWORD				dwIndex = 0;
	BOOL				fResult = FALSE;
	PCRYPT_ATTRIBUTE	pAttr=NULL;
	DWORD				cbData=0;

	*pdwCount =0;
	*pprgExtensions=NULL;

	if(!pReqInfo)
		goto CLEANUP;

	for(dwIndex=0; dwIndex < pReqInfo->cAttribute; dwIndex++)
	{
        // compare both old and new attr oids, both shouldn't co-exist
		if(0 == strcmp((pReqInfo->rgAttribute[dwIndex]).pszObjId, szOID_RSA_certExtensions) ||
           0 == strcmp((pReqInfo->rgAttribute[dwIndex]).pszObjId, SPC_CERT_EXTENSIONS_OBJID))
			break;
	}

	if( dwIndex == pReqInfo->cAttribute)
	{
		//we could not find the requested extensions
		fResult = TRUE;
		goto CLEANUP;
	}

	pAttr=&(pReqInfo->rgAttribute[dwIndex]);

	if(0 == pAttr->cValue)
	{
		fResult=TRUE;
		goto CLEANUP;
	}

 	*pprgExtensions = (PCERT_EXTENSIONS *)MakeCertAlloc((pAttr->cValue) * sizeof(PCERT_EXTENSIONS));

	if(NULL == (*pprgExtensions))
		goto CLEANUP;

	memset(*pprgExtensions, 0, (pAttr->cValue) * sizeof(PCERT_EXTENSIONS));

	for(dwIndex=0; dwIndex<pAttr->cValue; dwIndex++)
	{
		cbData = 0;
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            X509_EXTENSIONS,
                            pAttr->rgValue[dwIndex].pbData,
                            pAttr->rgValue[dwIndex].cbData,
                            0,
                            NULL,
                            &cbData))
			goto CLEANUP;

		(*pprgExtensions)[dwIndex]=(PCERT_EXTENSIONS)MakeCertAlloc(cbData);

		if(NULL == (*pprgExtensions)[dwIndex])
			goto CLEANUP;

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            X509_EXTENSIONS,
                            pAttr->rgValue[dwIndex].pbData,
                            pAttr->rgValue[dwIndex].cbData,
							0,
                            (*pprgExtensions)[dwIndex],
                            &cbData))
			goto CLEANUP;
	} 

	*pdwCount=pAttr->cValue; 

	fResult = TRUE;

CLEANUP:

	if(FALSE == fResult)
	{
	   //we need to free the memory
		if(*pprgExtensions)
		{
			for(dwIndex=0; dwIndex<pAttr->cValue; dwIndex++)
			{
				if((*pprgExtensions)[dwIndex])
					MakeCertFree((*pprgExtensions)[dwIndex]);
			} 

			MakeCertFree(*pprgExtensions);
			*pprgExtensions = NULL;
		}

		*pdwCount=0;
	}

	return fResult;

}




//+-------------------------------------------------------------------------
//  Get the subject's cert context and encoded name
//--------------------------------------------------------------------------
static BOOL GetSubject(
    OUT PCCERT_CONTEXT *ppCertContext,
    OUT BYTE **ppbEncodedName,
    OUT DWORD *pcbEncodedName
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pb;
    DWORD cb;
    BYTE *pbEncodedName = NULL;
    DWORD cbEncodedName;

    if (S_OK==RetrieveBLOBFromFile(wszSubjectCertFile,&cb, &pb))
    {
        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
        UnmapViewOfFile(pb);
    }
    if (pCert == NULL)
        goto BadFile;

    if (0 == (cbEncodedName = pCert->pCertInfo->Subject.cbData))
        goto BadFile;
    if (fGlueCert ) {
        if (!EncodeGlueName(
                &pCert->pCertInfo->Subject,
                &pbEncodedName,
                &cbEncodedName))
            goto ErrorReturn;
    } else {
        if (NULL == (pbEncodedName = (BYTE *) MakeCertAlloc(cbEncodedName)))
            goto ErrorReturn;
        memcpy(pbEncodedName, pCert->pCertInfo->Subject.pbData, cbEncodedName);
    }

    fResult = TRUE;
    goto CommonReturn;

BadFile:
    IDSwprintf(hModule, IDS_ERR_CANNOT_LOAD_SUB_CERT,
        wszSubjectCertFile);
ErrorReturn:
    if (pbEncodedName) {
        MakeCertFree(pbEncodedName);
        pbEncodedName = NULL;
    }
    cbEncodedName = 0;
    if (pCert) {
        CertFreeCertificateContext(pCert);
        pCert = NULL;
    }
    fResult = FALSE;
CommonReturn:
    *ppCertContext = pCert;
    *ppbEncodedName = pbEncodedName;
    *pcbEncodedName = cbEncodedName;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert and encode the subject's X500 formatted name
//--------------------------------------------------------------------------
static BOOL EncodeSubject(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL            fResult;
    DWORD           cbEncodedSubject=0;
    BYTE            *pbEncodedSubject=NULL;
    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded;

    CERT_NAME_BLOB  SubjectInfo;

    //encode the wszSubjectX500Name into an encoded X509_NAME
    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        wszSubjectX500Name,
        CERT_NAME_STR_REVERSE_FLAG,
        NULL,
        NULL,
        &cbEncodedSubject,
        NULL))
    {
        PrintLastError(IDS_CERT_STR_TO_NAME);
        goto ErrorReturn;
    }

    pbEncodedSubject = (BYTE *) MakeCertAlloc(cbEncodedSubject);
    if (pbEncodedSubject == NULL) goto ErrorReturn; 

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        wszSubjectX500Name,
        CERT_NAME_STR_REVERSE_FLAG,
        NULL,
        pbEncodedSubject,
        &cbEncodedSubject,
        NULL))
    {
        PrintLastError(IDS_CERT_STR_TO_NAME);
        goto ErrorReturn;
    }

    SubjectInfo.cbData=cbEncodedSubject;
    SubjectInfo.pbData=pbEncodedSubject;


    //add the GLUE CDRT_RDN_ATTR
    if (fGlueCert)
    {
        if(!EncodeGlueName(&SubjectInfo,
            &pbEncoded,
            &cbEncoded))
            goto ErrorReturn;
    }
    else
    {
        cbEncoded=cbEncodedSubject;
        pbEncoded=pbEncodedSubject;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    //we need to free the memory for pbEncodedSubject for GlueCert
    if(fGlueCert)
    {
        if(pbEncodedSubject)
        {
            MakeCertFree(pbEncodedSubject);
            pbEncodedSubject=NULL;
        }
    }   
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


// The test root's public key isn't encoded properly in the certificate.
// It's missing a leading zero to make it a unsigned integer.
static BYTE rgbTestRoot[] = {
    #include "root.h"
};
static CERT_PUBLIC_KEY_INFO TestRootPublicKeyInfo = {
    szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0
};

static BYTE rgbTestRootInfoAsn[] = {
    #include "rootasn.h"
};

//+-------------------------------------------------------------------------
//  X509 Extensions: Allocate and Encode functions
//--------------------------------------------------------------------------
static BOOL CreateAuthorityKeyId(
        IN HCRYPTPROV hProv,
        IN PCERT_INFO pIssuerCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_AUTHORITY_KEY_ID_INFO KeyIdInfo;
#define MAX_HASH_LEN  20
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;

    // Issuer's KeyId: MD5 hash of the encoded issuer's public key info

    // First check if the issuer is the test root with an incorrectly
    // encoded public key.
    if (CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            &pIssuerCert->SubjectPublicKeyInfo,
            &TestRootPublicKeyInfo
            )) {
        if (!CryptHashCertificate(
                hProv,
                CALG_MD5,
                0,                  // dwFlags
                rgbTestRootInfoAsn,
                sizeof(rgbTestRootInfoAsn),
                rgbHash,
                &cbHash)) {
            PrintLastError(IDS_CRYPT_HASH_CERT);
            goto ErrorReturn;
        }
    } else {
        if (!CryptHashPublicKeyInfo(
                hProv,
                CALG_MD5,
                0,                  // dwFlags
                X509_ASN_ENCODING,
                &pIssuerCert->SubjectPublicKeyInfo,
                rgbHash,
                &cbHash)) {
            PrintLastError(IDS_CRYPT_HASP_PUB);
            goto ErrorReturn;
        }
    }
    KeyIdInfo.KeyId.pbData = rgbHash;
    KeyIdInfo.KeyId.cbData = cbHash;

    // Issuer's Issuer
    KeyIdInfo.CertIssuer = pIssuerCert->Issuer;

    // Issuer's SerialNumber
    KeyIdInfo.CertSerialNumber = pIssuerCert->SerialNumber;

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_AUTH_KEY);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_AUTH_KEY);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateSpcSpAgency(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SPC_LINK PolicyLink;
    SPC_SP_AGENCY_INFO AgencyInfo;

    memset(&AgencyInfo, 0, sizeof(AgencyInfo));

    if (wszPolicyLink) {
        PolicyLink.dwLinkChoice = SPC_URL_LINK_CHOICE;
        PolicyLink.pwszUrl = wszPolicyLink;
        AgencyInfo.pPolicyInformation = &PolicyLink;
    }


    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING,
                      SPC_SP_AGENCY_INFO_OBJID,
                      &AgencyInfo,
                      NULL,           // pbEncoded
                      &cbEncoded);
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_SPC_AGENCY);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
            &AgencyInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_SPC_AGENCY);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded)
    {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL               fResult = FALSE;
    LPBYTE             pbEncoded =NULL;
    DWORD              cbEncoded =0;
    DWORD              cCount =0;
    LPSTR              psz=NULL;
    LPSTR              pszTok=NULL;
    DWORD              cTok = 0;
    PCERT_ENHKEY_USAGE pUsage =NULL;
    LPSTR              pszCodeSigning = szOID_PKIX_KP_CODE_SIGNING;    
    BOOL               fFound=FALSE;

    if(wszEKUOids)
    {
        if ( WSZtoSZ(wszEKUOids, &psz) != S_OK )
            goto CLEANUP;

        //
        // Count the number of OIDs as well as converting from comma delimited
        // to NULL character delimited
        //

        pszTok = strtok(psz, ",");
        while ( pszTok != NULL )
        {
            cTok++;
            pszTok = strtok(NULL, ",");
        }

        //
        // Allocate a cert enhanced key usage structure and fill it in with
        // the string tokens
        //
        // we allocate one more string for the code signing OIDs
        //

        pUsage = (PCERT_ENHKEY_USAGE)new BYTE [sizeof(CERT_ENHKEY_USAGE) + ( (cTok + 1) * sizeof(LPSTR) )];

        if(NULL == pUsage)
            goto CLEANUP;

        pszTok = psz;
        pUsage->cUsageIdentifier = cTok;
        pUsage->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage+sizeof(CERT_ENHKEY_USAGE));

        for ( cCount = 0; cCount < cTok; cCount++ )
        {
            pUsage->rgpszUsageIdentifier[cCount] = pszTok;
            pszTok = pszTok+strlen(pszTok)+1;
        }

        //we add the code signing OID if use has specified commerical or individual signing
        if(fCertCommercial || fCertIndividual)
        {
            //check to see if the code signing OID is alreayd present
            for(cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++)
            {
                if(0 == strcmp(pszCodeSigning,pUsage->rgpszUsageIdentifier[cCount]))
                {
                    fFound=TRUE;
                    break;
                }
            }

            if(FALSE == fFound)
            {
                (pUsage->rgpszUsageIdentifier)[pUsage->cUsageIdentifier] = pszCodeSigning;
                (pUsage->cUsageIdentifier)++ ;
            }
        }
    }
    else
    {
        if(fCertCommercial || fCertIndividual)
        {

            pUsage = (PCERT_ENHKEY_USAGE)new BYTE [sizeof(CERT_ENHKEY_USAGE)];

            if(NULL == pUsage)
                goto CLEANUP;

            pUsage->cUsageIdentifier = 1;
            pUsage->rgpszUsageIdentifier = &pszCodeSigning;
        }
        else
        {
            goto CLEANUP;
        }
    }

    //
    // Encode the usage
    //

    if(!CryptEncodeObject(
                   X509_ASN_ENCODING,
                   szOID_ENHANCED_KEY_USAGE,
                   pUsage,
                   NULL,
                   &cbEncoded
                   ))
        goto CLEANUP;

    pbEncoded = new BYTE [cbEncoded];

    if(NULL == pbEncoded)
        goto CLEANUP;

    fResult = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   szOID_ENHANCED_KEY_USAGE,
                   pUsage,
                   pbEncoded,
                   &cbEncoded
                   );

    //
    // Cleanup
    //

CLEANUP:

    if(pUsage)
        delete[] pUsage;

    if(psz)
        MakeCertFree(psz);

    if ( TRUE == fResult)
    {
        *ppbEncoded = pbEncoded;
        *pcbEncoded = cbEncoded;
    }
    else
    {
        if(pbEncoded)
            delete[] pbEncoded;
    }

    return  fResult;
}


static BOOL CreateKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_USAGE_RESTRICTION_INFO KeyUsageInfo;
    BYTE bRestrictedKeyUsage;
    DWORD cCertPolicyId;

    LPSTR rgpszIndividualCertPolicyElementId[1] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID
    };
    LPSTR rgpszCommercialCertPolicyElementId[1] = {
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID
    };
    CERT_POLICY_ID rgCertPolicyId[2];

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    bRestrictedKeyUsage = CERT_DIGITAL_SIGNATURE_KEY_USAGE;
    KeyUsageInfo.RestrictedKeyUsage.pbData = &bRestrictedKeyUsage;
    KeyUsageInfo.RestrictedKeyUsage.cbData = 1;
    KeyUsageInfo.RestrictedKeyUsage.cUnusedBits = 7;

    cCertPolicyId = 0;
    if (fCertIndividual) {
        rgCertPolicyId[cCertPolicyId].cCertPolicyElementId = 1;
        rgCertPolicyId[cCertPolicyId].rgpszCertPolicyElementId =
            rgpszIndividualCertPolicyElementId;
        cCertPolicyId++;
    }
    if (fCertCommercial) {
        rgCertPolicyId[cCertPolicyId].cCertPolicyElementId = 1;
        rgCertPolicyId[cCertPolicyId].rgpszCertPolicyElementId =
            rgpszCommercialCertPolicyElementId;
        cCertPolicyId++;
    }

    if (cCertPolicyId > 0) {
        KeyUsageInfo.cCertPolicyId = cCertPolicyId;
        KeyUsageInfo.rgCertPolicyId = rgCertPolicyId;
    }

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_KEY_USAGE);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_KEY_USAGE);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateBasicConstraints(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_BASIC_CONSTRAINTS_INFO Info;

    memset(&Info, 0, sizeof(Info));
    if (certTypes == 0)
        certTypes = CERT_CA_SUBJECT_FLAG | CERT_END_ENTITY_SUBJECT_FLAG;
    Info.SubjectType.pbData = &certTypes;
    Info.SubjectType.cbData = 1;
    if (certTypes & 0x40)
        Info.SubjectType.cUnusedBits = 6;
    else
        Info.SubjectType.cUnusedBits = 7;

    if (pathLenConstraint < 0)
        Info.fPathLenConstraint = FALSE;
    else {
        Info.fPathLenConstraint = TRUE;
        Info.dwPathLenConstraint = pathLenConstraint;
    }

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_BASIC_CONSTRAINTS,
            &Info,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_BASIC_CONSTRAINTS2);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_BASIC_CONSTRAINTS,
            &Info,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_BASIC_CONSTRAINTS2);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}



//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//-----------------------------------------------------------------------
//
// Get the hash from a cert file
//
//--------------------------------------------------------------------------
HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **ppHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore)
{
    HRESULT         hr;
    HCERTSTORE      hCertStore=NULL;
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;
    PCCERT_CONTEXT  pDupCert=NULL;
    DWORD           dwCount=0;

    if(!ppHash || !pcbHash || !pfMore)
        return E_INVALIDARG;

    //init
    *pcbHash=0;
    *ppHash=NULL;
    *pfMore=FALSE;
    
    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                        dwCertStoreEncodingType,
                        NULL,
                        0,
                        pwszCertFile);

    if(hCertStore==NULL)
    {
        hr=SignError();
        goto CLEANUP;
    }

    while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                        pPreCert))
    {
        dwCount++;

        if(dwCount > 1)
        {
            CertFreeCertificateContext(pDupCert);
            pDupCert=NULL;
            CertFreeCertificateContext(pSigningCert);
            pSigningCert=NULL;

            *pfMore=TRUE;
            goto CLEANUP;
        }

        pPreCert=pDupCert;

        pSigningCert=CertDuplicateCertificateContext(pDupCert);

    }

    if(pSigningCert==NULL)
    {
        hr=CRYPT_E_NO_DECRYPT_CERT;
        goto CLEANUP;
    }

    //get the hash
    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        NULL,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

    *ppHash=(BYTE *)ToolUtlAlloc(*pcbHash);
    if(!(*ppHash))
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        *ppHash,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

    hr=S_OK;

CLEANUP:

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hr!=S_OK)
    {
        if(*ppHash)
        {
          ToolUtlFree(*ppHash);
          *ppHash=NULL;
        }

    }

    return hr;
}



//-----------------------------------------------------------------------
//
// Get the signing certificate
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT  GetIssuerCertAndStore(HCERTSTORE *phCertStore, BOOL *pfMore)
{                   
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;  
    PCCERT_CONTEXT  pDupCert=NULL;
    BYTE            *pHash=NULL;
    DWORD           cbHash;
    HCERTSTORE      hCertStore=NULL;
    CRYPT_HASH_BLOB HashBlob;
    DWORD           dwCount=0;

    //init the output
    if(!phCertStore || !pfMore)
        return NULL;

    *phCertStore=NULL;
    *pfMore=FALSE;

    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                        dwCertStoreEncodingType,
                        NULL,
                        dwIssuerStoreFlag|CERT_STORE_READONLY_FLAG,
                        wszIssuerStore);

    if(!hCertStore)
        return NULL;


    //get the hash of the certificate.  Find the cert based on
    //pwszCertFile
    if(wszIssuerCertFile)
    {
        if(S_OK != GetCertHashFromFile(wszIssuerCertFile, &pHash, &cbHash, pfMore))
            goto CLEANUP;
        
        HashBlob.cbData=cbHash;
        HashBlob.pbData=pHash;

        pSigningCert=CertFindCertificateInStore(hCertStore,
                            X509_ASN_ENCODING,
                            0,
                            CERT_FIND_SHA1_HASH,
                            &HashBlob,
                            NULL);
    }
    else
    {
        //find the certificate with the common name
        if(wszIssuerCertName)
        {
            while(pDupCert=CertFindCertificateInStore(hCertStore,
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_SUBJECT_STR_W,
                                wszIssuerCertName,
                                pPreCert))
            {
                dwCount++;

                if(dwCount > 1)
                {
                    CertFreeCertificateContext(pDupCert);
                    pDupCert=NULL;
                    CertFreeCertificateContext(pSigningCert);
                    pSigningCert=NULL;

                    *pfMore=TRUE;
                    goto CLEANUP;
                }

                pPreCert=pDupCert;

                pSigningCert=CertDuplicateCertificateContext(pDupCert);

            }
            
        }
        else
        {
            //no searching criteria, find the only cert in the store
            while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                        pPreCert))
            {
                dwCount++;

                if(dwCount > 1)
                {
                    CertFreeCertificateContext(pDupCert);
                    pDupCert=NULL;
                    CertFreeCertificateContext(pSigningCert);
                    pSigningCert=NULL;

                    *pfMore=TRUE;
                    goto CLEANUP;
                }

                pPreCert=pDupCert;

                pSigningCert=CertDuplicateCertificateContext(pDupCert);

            }
            
        }
    }
CLEANUP:

    if(pHash)
        ToolUtlFree(pHash);

    if(pSigningCert)
    {
       *phCertStore=hCertStore;
    }
    else
    {
        //free the hCertStore
        CertCloseStore(hCertStore, 0);
    }

    return pSigningCert;

}


//-----------------------------------------------------------------------
//
// EmptySubject
//
//--------------------------------------------------------------------------
BOOL	EmptySubject(CERT_NAME_BLOB *pSubject)
{
	BOOL				fEmpty = TRUE;
    CERT_NAME_INFO      *pCertNameInfo=NULL;
	DWORD				cbData =0;
	
	if(!pSubject)
		goto CLEANUP;

    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
			              pSubject->pbData, 
                          pSubject->cbData,
						  0,
						  NULL,
                          &cbData))
		goto CLEANUP;


	pCertNameInfo = (CERT_NAME_INFO  *)MakeCertAlloc(cbData);
	if(NULL == pCertNameInfo)
		goto CLEANUP;

    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
			              pSubject->pbData, 
                          pSubject->cbData,
						  0,
						  pCertNameInfo,
                          &cbData))
		goto CLEANUP;

	if((pCertNameInfo->cRDN) > 0)
		fEmpty = FALSE;

CLEANUP:

	if(pCertNameInfo)
		MakeCertFree(pCertNameInfo);	

	return fEmpty;

}



//+=========================================================================
// Support functions to generate DH keys having the 'Q'parameter
//==========================================================================

static BOOL EncodeAndAllocObject(
    IN LPCSTR       lpszStructType,
    IN const void   *pvStructInfo,
    OUT BYTE        **ppbEncoded,
    IN OUT DWORD    *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = 0;

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            NULL,
            &cbEncoded
            ))
        goto ErrorReturn;
    if (NULL == (pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    MakeCertFree(pbEncoded);
    pbEncoded = NULL;
    goto CommonReturn;
}

static BOOL DecodeAndAllocObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT void        **ppvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvStructInfo = NULL;
    DWORD cbStructInfo = 0;

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            NULL,
            &cbStructInfo
            ))
        goto ErrorReturn;
    if (NULL == (pvStructInfo = MakeCertAlloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

    fResult = TRUE;

CommonReturn:
    *ppvStructInfo = pvStructInfo;
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    MakeCertFree(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
}

static BYTE rgbDhQ[21];
static CRYPT_UINT_BLOB DhQ = {0, NULL};

static BOOL GetDhParaFromCertFile(
    OUT PCERT_X942_DH_PARAMETERS *ppX942DhPara
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pDhCert = NULL;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;

    BYTE *pb;
    DWORD cb;

    if (S_OK == RetrieveBLOBFromFile(wszDhParaCertFile, &cb, &pb)) {
        pDhCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
        UnmapViewOfFile(pb);
    }
    if (pDhCert == NULL)
        goto DhParaCertFileError;

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pDhCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pDhCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cb
            ))
        goto DhParaCertFileError;

    fResult = TRUE;
CommonReturn:
    CertFreeCertificateContext(pDhCert);
    *ppX942DhPara = pX942DhPara;
    return fResult;

DhParaCertFileError:
    IDSwprintf(hModule, IDS_ERR_DH_PARA_FILE, wszDhParaCertFile);
    MakeCertFree(pX942DhPara);
    pX942DhPara = NULL;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL GetDhParaFromDssKey(
    OUT PCERT_DSS_PARAMETERS *ppDssPara
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    WCHAR *wszRegKeyName = NULL;
    UUID TmpContainerUuid;
    PCERT_DSS_PARAMETERS pDssPara = NULL;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD cbDssPara;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto CreateKeyError;
    }

    if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
        (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
        goto CreateKeyError;

    BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

    // Open a new key container
    if (!CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_NEWKEYSET               // dwFlags
            )) {
        hProv = 0;
        goto CreateKeyError;
    }

    if (0 == dwKeyBitLen)
        dwKeyBitLen = 512;
    
    // generate new DSS key in the key container
    if (!CryptGenKey(
            hProv,
            AT_SIGNATURE,
            (dwKeyBitLen << 16) | CRYPT_EXPORTABLE,
            &hKey
            ))
        goto CreateKeyError;
    else
        CryptDestroyKey(hKey);

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!DecodeAndAllocObject(
            X509_DSS_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pDssPara,
            &cbDssPara
            ))
        goto CreateKeyError;

    // Save away the DSS 'Q' parameter. It will be used in GetPublicKey()
    // to update the DH parameters in the PublicKeyInfo
    if (pDssPara->q.cbData <= sizeof(rgbDhQ)) {
        memcpy(rgbDhQ, pDssPara->q.pbData, pDssPara->q.cbData);
        DhQ.cbData = pDssPara->q.cbData;
        DhQ.pbData = rgbDhQ;
    }

    fResult = TRUE;
CommonReturn:
    if (hProv) {
        // Delete the just created DSS key
        CryptReleaseContext(hProv, 0);
        CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_DELETEKEYSET
            );
    }
    MakeCertFree(wszRegKeyName);
    MakeCertFree(pPubKeyInfo);

    *ppDssPara = pDssPara;
    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    MakeCertFree(pDssPara);
    pDssPara = NULL;
    fResult = FALSE;
    goto CommonReturn;
}

#ifndef DH3
#define DH3 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'3'<<24))
#endif

static BOOL CreateDh3PubKeyStruc(
    IN PCERT_X942_DH_PARAMETERS pX942DhPara,
    OUT PUBLICKEYSTRUC **ppPubKeyStruc,
    OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    BYTE *pbKey;

    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    DWORD cb;

    cbP = pX942DhPara->p.cbData;
    cbQ = pX942DhPara->q.cbData;
    cbJ = pX942DhPara->j.cbData;

    if (0 == cbQ) {
        *ppPubKeyStruc = NULL;
        *pcbPubKeyStruc = 0;
        return TRUE;
    }

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]
    //  - rgbG[cbP]
    //  - rgbJ[cbJ] -- optional
    //  - rgbY[cbP] -- will be omitted here

    cbPubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP + cbQ + cbP + cbJ;

    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) MakeCertAlloc(
            cbPubKeyStruc)))
        goto ErrorReturn;
    memset(pPubKeyStruc, 0, cbPubKeyStruc);

    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    pPubKeyStruc->bType = PUBLICKEYBLOB;
    pPubKeyStruc->bVersion = 3;
    pPubKeyStruc->aiKeyAlg = CALG_DH_SF;
    pCspPubKey->magic = DH3;
    pCspPubKey->bitlenP = cbP * 8;
    pCspPubKey->bitlenQ = cbQ * 8;
    pCspPubKey->bitlenJ = cbJ * 8;

    pCspPubKey->DSSSeed.counter = 0xFFFFFFFF;
    if (pX942DhPara->pValidationParams) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;

        pValidationParams = pX942DhPara->pValidationParams;
        if (0 != pValidationParams->pgenCounter &&
                sizeof(pCspPubKey->DSSSeed.seed) ==
                    pValidationParams->seed.cbData) {
            pCspPubKey->DSSSeed.counter =
                pValidationParams->pgenCounter;
            memcpy(pCspPubKey->DSSSeed.seed,
                pValidationParams->seed.pbData,
                sizeof(pCspPubKey->DSSSeed.seed));
        }
    }

    // rgbP[cbP]
    memcpy(pbKey, pX942DhPara->p.pbData, cbP);
    pbKey += cbP;

    // rgbQ[cbQ]
    memcpy(pbKey, pX942DhPara->q.pbData, cbQ);
    pbKey += cbQ;

    // rgbG[cbP]
    cb = pX942DhPara->g.cbData;
    if (0 == cb || cb > cbP)
        goto ErrorReturn;
    memcpy(pbKey, pX942DhPara->g.pbData, cb);
    if (cbP > cb)
        memset(pbKey + cb, 0, cbP - cb);
    pbKey += cbP;

    // rgbJ[cbJ]
    if (cbJ) {
        memcpy(pbKey, pX942DhPara->j.pbData, cbJ);
        pbKey += cbJ;
    }

    fResult = TRUE;

CommonReturn:
    *ppPubKeyStruc = pPubKeyStruc;
    *pcbPubKeyStruc = cbPubKeyStruc;
    return fResult;
ErrorReturn:
    MakeCertFree(pPubKeyStruc);
    pPubKeyStruc = NULL;
    cbPubKeyStruc = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL IsDh3Csp()
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    WCHAR *wszRegKeyName = NULL;
    UUID TmpContainerUuid;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD cbX942DhPara;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto CreateKeyError;
    }

    if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
        (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
        goto CreateKeyError;

    BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

    // Open a new key container
    if (!CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_NEWKEYSET               // dwFlags
            )) {
        hProv = 0;
        goto CreateKeyError;
    }

    // generate new DH key in the key container
    if (!CryptGenKey(
            hProv,
            AT_KEYEXCHANGE,
            (512 << 16) | CRYPT_EXPORTABLE,
            &hKey
            ))
        goto CreateKeyError;
    else
        CryptDestroyKey(hKey);

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_KEYEXCHANGE,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cbX942DhPara
            ))
        goto CreateKeyError;

    if (pX942DhPara->q.cbData)
        // Q para is only supported in Dh3 version of CSP
        fResult = TRUE;
    else
        fResult = FALSE;
CommonReturn:
    if (hProv) {
        // Delete the just created DH key
        CryptReleaseContext(hProv, 0);
        CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_DELETEKEYSET
            );
    }
    MakeCertFree(wszRegKeyName);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pPubKeyInfo);

    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL GenDhKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HCRYPTKEY hKey = 0;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    PCERT_DSS_PARAMETERS pDssPara = NULL;

    PCRYPT_UINT_BLOB pP;
    PCRYPT_UINT_BLOB pG;
    DWORD cbP;

    PUBLICKEYSTRUC *pDh3PubKeyStruc = NULL;
    DWORD cbDh3PubKeyStruc;
    BOOL fSetKeyPara;

    if (wszDhParaCertFile) {
        if (!GetDhParaFromCertFile(&pX942DhPara))
            goto ErrorReturn;

        CreateDh3PubKeyStruc(pX942DhPara, &pDh3PubKeyStruc, &cbDh3PubKeyStruc);

        pP = &pX942DhPara->p;
        pG = &pX942DhPara->g;
    } else if (dwKeyBitLen > 1024 || IsDh3Csp()) {
        // generate new keys in the key container
        if (!CryptGenKey(
                hProv,
                AT_KEYEXCHANGE,
                (dwKeyBitLen << 16) | dwFlags,
                &hKey
                )) {
            hKey = 0;
            goto CreateKeyError;
        } else
            goto SuccessReturn;
    } else {
        if (!GetDhParaFromDssKey(&pDssPara))
            goto ErrorReturn;

        pP = &pDssPara->p;
        pG = &pDssPara->g;
    }

    cbP = pP->cbData;
    
    if (!CryptGenKey(
            hProv,
            CALG_DH_SF,
            ((cbP * 8) << 16) | CRYPT_PREGEN | dwFlags,
            &hKey)) {
        hKey = 0;
        goto CreateKeyError;
    }

    fSetKeyPara = FALSE;
    if (pDh3PubKeyStruc) {
        CRYPT_DATA_BLOB Dh3Blob;

        Dh3Blob.pbData = (PBYTE) pDh3PubKeyStruc;
        Dh3Blob.cbData = cbDh3PubKeyStruc;

        if (CryptSetKeyParam(
                hKey,
                KP_PUB_PARAMS,
                (PBYTE) &Dh3Blob,
                0))                 // dwFlags
            fSetKeyPara = TRUE;
    }

    if (!fSetKeyPara) {
        if (!CryptSetKeyParam(
                hKey,
                KP_P,
                (PBYTE) pP,
                0))                 // dwFlags
            goto CreateKeyError;

        // Note, the length of G can be less than length P. Pad with leading
        // zeroes in little endian form.
        if (pG->cbData < cbP) {
            DWORD cbG = pG->cbData;

            // We are done using P parameter. Overwrite with the G parameter and
            // pad with leading zeroes in little endian form.
            memcpy(pP->pbData, pG->pbData, cbG);
            memset(pP->pbData + cbG, 0, cbP - cbG);
            pG = pP;
        }
        if (!CryptSetKeyParam(
                hKey,
                KP_G,
                (PBYTE) pG,
                0))                 // dwFlags
            goto CreateKeyError;
    }

    if (!CryptSetKeyParam(
            hKey,
            KP_X,
            NULL,               // pbData
            0))                 // dwFlags
        goto CreateKeyError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hKey)
        CryptDestroyKey(hKey);
    MakeCertFree(pDh3PubKeyStruc);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pDssPara);
    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL UpdateDhPublicKey(
    IN OUT PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = *ppPubKeyInfo;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    DWORD cbDhPara;
    PCERT_X942_DH_PARAMETERS pX942DhParaCertFile = NULL;

    BYTE *pbReencodedPara = NULL;
    DWORD cbReencodedPara;
    BYTE *pbReencodedPubKeyInfo = NULL;
    DWORD cbReencodedPubKeyInfo;
    PCERT_PUBLIC_KEY_INFO pUpdatedPubKeyInfo = NULL;
    DWORD cbUpdatedPubKeyInfo;

    if (NULL == wszDhParaCertFile && 0 == DhQ.cbData)
        return TRUE;

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cbDhPara
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (wszDhParaCertFile) {
        if (!GetDhParaFromCertFile(&pX942DhParaCertFile))
            goto ErrorReturn;

        if (!CertCompareIntegerBlob(&pX942DhPara->p, &pX942DhParaCertFile->p))
            goto DhParaCertFileError;
        if (!CertCompareIntegerBlob(&pX942DhPara->g, &pX942DhParaCertFile->g))
            goto DhParaCertFileError;

        // Use Dh parameters from the CertFile
        MakeCertFree(pX942DhPara);
        pX942DhPara = pX942DhParaCertFile;
        pX942DhParaCertFile = NULL;
    } else if (pX942DhPara->q.cbData) {
        MakeCertFree(pX942DhPara);
        return TRUE;
    } else
        // Use Q parameter saved away when the DH key was generated
        pX942DhPara->q = DhQ;

    // Re-encode the DH parameters
    if (!EncodeAndAllocObject(
            X942_DH_PARAMETERS,
            pX942DhPara,
            &pbReencodedPara,
            &cbReencodedPara
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (0 == strcmp(szOID_RSA_DH, pPubKeyInfo->Algorithm.pszObjId))
        pPubKeyInfo->Algorithm.pszObjId = szOID_ANSI_X942_DH;

    // Re-encode the PublicKeyInfo using the above re-encoded DH parameters
    pPubKeyInfo->Algorithm.Parameters.pbData = pbReencodedPara;
    pPubKeyInfo->Algorithm.Parameters.cbData = cbReencodedPara;
    if (!EncodeAndAllocObject(
            X509_PUBLIC_KEY_INFO,
            pPubKeyInfo,
            &pbReencodedPubKeyInfo,
            &cbReencodedPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    // Decode to get the updated public key info
    if (!DecodeAndAllocObject(
            X509_PUBLIC_KEY_INFO,
            pbReencodedPubKeyInfo,
            cbReencodedPubKeyInfo,
            (void **) &pUpdatedPubKeyInfo,
            &cbUpdatedPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    MakeCertFree(pbReencodedPubKeyInfo);
    MakeCertFree(pbReencodedPara);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pX942DhParaCertFile);

    MakeCertFree(pPubKeyInfo);
    *ppPubKeyInfo = pUpdatedPubKeyInfo;
    return fResult;

DhParaCertFileError:
    IDSwprintf(hModule, IDS_ERR_DH_PARA_FILE, wszDhParaCertFile);
ErrorReturn:
    MakeCertFree(pUpdatedPubKeyInfo);
    pUpdatedPubKeyInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\certmgr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for CertMgr.cpp.  
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS

#define         IDI_APP                         201
 
#define			IDS_SYNTAX						6001
#define			IDS_SUCCEEDED					6002
#define			IDS_FAILED						6003
#define			IDS_OPTIONS						6004																																																																						
#define			IDS_OPTION_ADD					6005
#define			IDS_OPTION_ADD_DESC				6006                  
#define			IDS_OPTION_DEL					6007
#define			IDS_OPTION_DEL_DESC				6008
#define			IDS_OPTION_S					6009
#define			IDS_OPTION_S_DESC				6010
#define			IDS_OPTION_R					6011
#define			IDS_OPTION_R_DESC				6012
#define			IDS_OPTION_MORE_VALUE			6013
#define			IDS_R_CU						6014
#define			IDS_R_LM						6015
#define			IDS_OPTION_C					6016
#define			IDS_OPTION_C_DESC				6017
#define			IDS_OPTION_CRL					6018
#define			IDS_OPTION_CRL_DESC				6019
#define			IDS_OPTION_CTL					6020
#define			IDS_OPTION_CTL_DESC				6021
#define			IDS_OPTION_V					6022
#define			IDS_OPTION_V_DESC				6023
#define			IDS_OPTION_ALL					6024
#define			IDS_OPTION_ALL_DESC				6025
#define			IDS_OPTION_N					6026
#define			IDS_OPTION_N_DESC				6027
#define			IDS_OPTION_SHA1					6028
#define			IDS_OPTION_SHA1_DESC			6029
#define			IDS_OPTION_7					6030
#define			IDS_OPTION_7_DESC				6031
#define			IDS_OPTION_E					6032
#define			IDS_OPTION_E_DESC				6033
#define			IDS_OPTION_Y					6034
#define			IDS_OPTION_Y_DESC				6035
#define			IDS_OPTION_F					6036
#define			IDS_OPTION_F_DESC				6037
#define			IDS_OPTION_EKU					6038
#define			IDS_OPTION_EKU_DESC				6039
#define			IDS_OPTION_TEST					6040
#define			IDS_OPTION_PUT                  6041
#define			IDS_OPTION_PUT_DESC             6042
#define			IDS_OPTION_PUT_DESC1            6043
#define			IDS_OPTION_PUT_DESC2            6044

												
#define			IDS_SWITCH1						6050
#define			IDS_SWITCH2						6051
#define			IDS_ERR_TOO_MANY_PARAM			6052
#define			IDS_ERR_N_SHA1					6053
#define			IDS_ERR_ALL_N_SHA1				6054
#define			IDS_ERR_SOURCE_STORE			6055
#define			IDS_ERR_STORE_PROVIDER			6056
#define			IDS_ERR_NO_REG					6057
#define			IDS_ERR_SHA1_HASH				6058
#define			IDS_ERR_DISPLAY_TOO_MANY		6059
#define			IDS_ERR_CTL_7					6060
#define			IDS_ERR_C_CTL_CTL_ALL			6061
#define			IDS_ERR_DES_STORE				6062
#define			IDS_ERR_SOURCE_SYSTEM_7			6063
#define			IDS_ERR_OPEN_SOURCE_STORE		6064
#define			IDS_ERR_TMP_STORE				6065
#define			IDS_ERR_ADD_CERT_ALL			6066
#define			IDS_ERR_DELETE_CERT_ALL			6067
#define			IDS_ERR_NO_CERT_HASH			6068
#define			IDS_ERR_ADD_CERT				6069
#define			IDS_ERR_DELETE_CERT				6070
#define			IDS_ERR_CERT_FIND				6071
#define			IDS_ERR_ADD_NO_CERT				6072
#define			IDS_ERR_DELETE_NO_CERT			6073
#define			IDS_ERR_ADD_CRL_ALL				6074
#define			IDS_ERR_DELETE_CRL_ALL			6075
#define			IDS_ERR_NO_CRL_HASH				6076
#define			IDS_ERR_ADD_CRL					6077
#define			IDS_ERR_DELETE_CRL				6078
#define			IDS_ERR_CRL_FIND				6079
#define			IDS_ERR_ADD_CTL_ALL				6080
#define			IDS_ERR_DELETE_CTL_ALL			6081
#define			IDS_ERR_NO_CTL_HASH				6082
#define			IDS_ERR_ADD_CTL					6083
#define			IDS_ERR_DELETE_CTL				6084
#define			IDS_ERR_CTL_FIND				6085
#define			IDS_ERR_COPY_FROM_SRC			6086
#define			IDS_ERR_SAVE_DES_STORE			6087
#define			IDS_ERR_OPEN_DES_STORE			6088
#define			IDS_CERT_INDEX					6089
#define			IDS_ERR_DISPLAY					6090
#define			IDS_CRL_INDEX					6092
#define			IDS_CTL_INDEX					6093
#define			IDS_NO_CERT						6094
#define			IDS_NO_CTL						6095
#define			IDS_NO_CRL						6096
#define			IDS_ERR_SINGLE_ACTION			6097
#define			IDS_ERR_GET_SINGER_COUNT		6098
#define			IDS_ERR_GET_SIGNER_CERT			6099
#define			IDS_NULL						7000
#define			IDS_SHA1						7001
#define			IDS_MD5							7002
#define			IDS_UNKNOWN						7003
#define			IDS_SUBJECT						7004
#define			IDS_ISSUER						7005
#define			IDS_SERIAL_NUMBER				7006
#define			IDS_KEY							7007
#define			IDS_KEY_PROVIDER				7008
#define			IDS_PROV_NAME					7009
#define			IDS_FLAGS						7010
#define			IDS_CONTAINER					7011
#define			IDS_PARAMS						7012
#define			IDS_KEY_SPEC					7013
#define			IDS_NOT_BEFORE					7014
#define			IDS_NOT_AFTER					7015
#define			IDS_VERSION						7016
#define			IDS_SIG_ALGO					7017
#define			IDS_SIG_ALGO_PARAM				7018
#define			IDS_SUB_KEY_ALGO				7019
#define			IDS_SUB_KEY_ALGO_PARAM			7020
#define			IDS_DSS_LENGTH					7021
#define			IDS_DSS_P						7022
#define			IDS_DSS_Q						7023
#define			IDS_DSS_G						7024
#define			IDS_SUB_KEY_INFO				7025
#define			IDS_BIT_LENGTH					7026
#define			IDS_UNUSED_BITS					7027
#define			IDS_RSA_CSP						7028
#define			IDS_DSS_Y						7029
#define			IDS_NO_PUB_KEY					7030
#define			IDS_ISSUER_ID					7031
#define			IDS_SUBJECT_ID					7032
#define			IDS_SUBJECT_USAGE				7033
#define			IDS_NO_USAGE_IDS				7034
#define			IDS_LIST_DIS					7035
#define			IDS_SEQUENCE					7036
#define			IDS_THIS_UPDATE					7037
#define			IDS_NEXT_UPDATE					7038
#define			IDS_TIME_INVALID				7039
#define			IDS_SUB_ALGO					7040
#define			IDS_SUB_ALGO_PARAM				7041
#define			IDS_NO_ENTRIES					7042
#define			IDS_ENTRIES						7043
#define			IDS_SUB_ID						7044
#define			IDS_ATTR						7045
#define			IDS_SERIAL_NUM_I				7046
#define			IDS_REVOC_DATE					7047
#define			IDS_NO_EXTENSION				7048
#define			IDS_EXTENSION					7049
#define			IDS_DIS_NO_SIGNER				7050
#define			IDS_SIGNER_INDEX				7051
#define			IDS_DIS_SIGNER_AUTH_ATTR		7052
#define			IDS_DIS_SIGNER_UNAUTH_ATTR		7053
#define			IDS_NO_BYTE						7054
#define			IDS_NEXT_UPDATE_LOCATION		7055
#define			IDS_NO_VALUE_BYTES				7056
#define			IDS_I_ID_NO_VALUE				7057
#define			IDS_OTHER_NAME					7058
#define			IDS_X400						7059
#define			IDS_DIRECTORY_NAME				7060
#define			IDS_EDI_PARTY					7061
#define			IDS_RFC							7062
#define			IDS_DNS							7063
#define			IDS_ALT_NAME_URL				7064
#define			IDS_IP							7065
#define			IDS_REG_ID						7066
#define			IDS_UNKNOWN_ALT_NAME			7067
#define			IDS_Thumbprint					7068
#define			IDS_FILE_TIME					7069
#define			IDS_MILLI_SECOND				7070
#define			IDS_AUX_PROP_ID					7071
#define			IDS_ENHANCED_KEY_USAGE			7072
#define			IDS_NO_PROP_BYTES				7073
#define			IDS_NO_USAGE_ID					7074
#define			IDS_CONTENT_SIG_ALGO			7075
#define			IDS_CONTENT_SIG_ALGO_PARAM		7076
#define			IDS_CONTEXT_SIG					7077
#define			IDS_DSS_R						7078
#define			IDS_DSS_S						7079
#define			IDS_DSS_INFO					7080
#define			IDS_CONTENT_SIG_NONE			7081
#define			IDS_VALUE_TYPE					7082
#define			IDS_STR							7083
#define			IDS_WSTR						7084
#define			IDS_TRUE						7085
#define			IDS_FALSE						7086
#define			IDS_EXTENSION_INDEX				7087
#define			IDS_NAME_CRITICAL				7088
#define			IDS_STRING						7089
#define			IDS_SUB_KEY_ID					7090
#define			IDS_SUB_ALT						7091
#define			IDS_ISS_ALT						7092
#define			IDS_SUB_ALT2					7093
#define			IDS_NEXT_UPDATE_LOC				7094
#define			IDS_CERT_POLICIES				7095
#define			IDS_NSCP_CERT					7096
#define			IDS_NSCP_BASE					7097
#define			IDS_NSCP_REV					7098
#define			IDS_NSCP_CA_REV					7099
#define			IDS_NSCP_RENEW					7100
#define			IDS_NSCP_CA_URL					7101
#define			IDS_NSCP_SSL					7102
#define			IDS_NSCP_COM					7103
#define			IDS_SMIME						7104
#define			IDS_NONE						7105
#define			IDS_PARAM						7106
#define			IDS_ENH_KEY_USAGE				7107
#define			IDS_COMMON_NAME					7108
#define			IDS_VALUE_STRING				7109
#define			IDS_FIN_CRI						7110
#define			IDS_FIN_AVAI					7111
#define			IDS_MEET_CRI					7112
#define			IDS_NO_MEET_CRI					7113
#define			IDS_MIN_CRI						7114
#define			IDS_MEET_MIN					7115
#define			IDS_NO_MEET_MIN					7116
#define			IDS_SPC_URL						7117
#define			IDS_SERIAL_DATA					7118
#define			IDS_SPC_FILE					7119
#define			IDS_UNKNOWN_SPC					7120
#define			IDS_SPC_AGENCY					7121
#define			IDS_POL_INFO					7122
#define			IDS_POL_DIS						7123
#define			IDS_IMG_LINK					7124
#define			IDS_BITMAP						7125
#define			IDS_META_FILE					7126
#define			IDS_ENH_META					7127
#define			IDS_GIF_FILE					7128
#define			IDS_LOGO_LINK					7129
#define			IDS_QUALI						7130
#define			IDS_ENCODED_DATA				7131
#define			IDS_KEY_USAGE					7132
#define			IDS_BASIC_CON2					7133
#define			IDS_PATH_LEN					7134
#define			IDS_BASIC_CON					7135
#define			IDS_SUB_TYPE					7136
#define			IDS_SUB_CA						7137
#define			IDS_SUB_EE						7138
#define			IDS_SUB_CON						7139
#define			IDS_DIG_SIG						7140
#define			IDS_NON_REP						7141
#define			IDS_KEY_ENCI					7142
#define			IDS_DATA_ENCI					7143
#define			IDS_KEY_AGRE					7144
#define			IDS_CERT_SIGN					7145
#define			IDS_OFFLINE_CRL					7146
#define			IDS_KEY_RESTRIC					7147
#define			IDS_CERT_POLICY					7148
#define			IDS_RESTRIC_KEY					7149
#define			IDS_CRL_REASON					7150
#define			IDS_CRL_UNSPECIFIED				7151
#define			IDS_KEY_COMP					7152
#define			IDS_CA_COMP						7153
#define			IDS_AFFI_CHANGED				7154
#define			IDS_SUPERSEDED					7155
#define			IDS_CESS_OPER					7156
#define			IDS_CERT_HOLD					7157
#define			IDS_REMOVE_CRL					7158
#define			IDS_KEY_ATTR					7159
#define			IDS_KEY_ID						7160
#define			IDS_INTEND_KEY_USAGE			7161
#define			IDS_NO_CRL_DIS					7162
#define			IDS_CRL_IDS_I					7163
#define			IDS_CRL_DIS_FULL_NAME			7164
#define			IDS_CRL_RDN						7165
#define			IDS_CRL_UNKNOWN					7166
#define			IDS_REASON_FLAG					7167
#define			IDS_REASON_UNUSED				7168
#define			IDS_CRL_ISSUER					7169
#define			IDS_AUTH_KEY_ID					7170
#define			IDS_AUTH_CERT_ISSUER			7172
#define			IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER			7173
#define			IDS_AUTH_KEY_ID2				7174
#define			IDS_VALUE_STRING_S				7175
#define			IDS_ELN							7176
#define			IDS_ISS_ALT2					7177
#define			IDS_ERR_INVALID_INDEX			7178
#define			IDS_SEPERATOR					7179
#define			IDS_NOT_AVAILABLE				7180
#define			IDS_NONE_NOELN					7181
#define			IDS_TS_VERSION					7182
#define			IDS_TS_ISSUER					7183
#define			IDS_TS_SERIAL_NUMBER			7184
#define			IDS_TS_AUTHATTR					7185
#define			IDS_TS_UNAUTHATTR				7186
#define			IDS_TIMESTMAP					7187
#define			IDS_SIGNING_TIME				7188
#define			IDS_HASH_ALGO					7189
#define			IDS_HASH_ALGO_PARAM				7190
#define			IDS_ENCRYPT_ALGO				7191
#define			IDS_ENCRYPT_ALGO_PARAM			7192
#define			IDS_SIGNER_INDEX_CERT			7193
#define			IDS_SPC_SP_NAME					7197		
#define			IDS_SPC_FIN_NAME				7198
#define			IDS_SPC_MIN_NAME				7199
#define			IDS_NTSP_CERT_NAME				7200
#define			IDS_NTSP_BASE_NAME				7201
#define			IDS_NTSP_REV_NAME				7202
#define			IDS_NTSP_CA_REV_NAME			7203
#define			IDS_NTSP_RENEW_NAME				7204
#define			IDS_NTSP_POL_NAME				7205
#define			IDS_NTSP_SSL_SERVER_NAME		7206
#define			IDS_NTSP_COMMENT				7207
#define			IDS_ERR_INIT_OID_SET			7208
#define			IDS_ERR_INSTALL_OID				7209
#define			IDS_ERR_REG_OID					7210
#define			IDS_ERR_DELETE_SIGNED_FILE		7211
#define			IDS_ERR_SET_EKU					7212
#define			IDS_ERR_DISPLAY_EKU				7213
#define			IDS_SYNTAX1						7214
#define			IDS_OPTION_DEL_DESC1			7215
#define			IDS_ERR_PROVIDER_SYSTEM			7216
#define			IDS_OPTION_E_DESC1				7217
#define			IDS_ENTER_ADD_INDEX_CERT        7218
#define			IDS_ENTER_ADD_INDEX_CRL		    7219
#define			IDS_ENTER_ADD_INDEX_CTL		    7220
#define			IDS_ENTER_DELETE_INDEX_CERT     7221
#define			IDS_ENTER_DELETE_INDEX_CRL	    7222
#define			IDS_ENTER_DELETE_INDEX_CTL	    7223
#define			IDS_ENTER_PUT_INDEX_CERT        7224
#define			IDS_ENTER_PUT_INDEX_CTL	        7225
#define			IDS_ENTER_PUT_INDEX_CRL	        7226
#define			IDS_ERR_7_CTL                   7227
#define			IDS_ERR_7_CTL1                  7228
#define			IDS_TOO_MANY_DES_STORE          7229
#define			IDS_ERR_ALL_PUT                 7230
#define			IDS_ERR_PUT_ITEM                7231
#define			IDS_ERR_PUT_CERT		        7232
#define			IDS_ERR_PUT_NO_CERT             7233
#define			IDS_ERR_PUT_CRL			        7234
#define			IDS_ERR_PUT_CRL_FIND            7235
#define			IDS_ERR_PUT_CTL_FIND            7236
#define			IDS_ERR_PUT_CTL                 7237
#define			IDS_ERR_SET_NAME                7238
#define			IDS_OPTION_NAME_DESC            7239
#define			IDS_OPTION_NAME                 7240
#define			IDS_OPTION_MULTI_DESC           7241
#define			IDS_OPTION_MULTI                7242
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makectl\makectl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       makectl.cpp
//
//  Contents:   Make a CTL
//
//              See Usage() for list of options.
//
//
//  Functions:  wmain
//
//  History:    17-June-97   xiaohs   created
//              
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <unicode.h>	 
#include <wchar.h>

#include "wincrypt.h"
#include "mssip.h"
#include "softpub.h"
#include "resource.h"
#include "toolutl.h"
#include "cryptui.h"    //the UI version of the tool

//--------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

HMODULE			hModule=NULL;

BYTE			**g_rgpHash=NULL;
DWORD			*g_rgcbHash=NULL;
DWORD			g_dwCount=0;
DWORD			g_dwMsgAndCertEncodingType=CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING;
DWORD			g_dwCertEncodingType=CRYPT_ASN_ENCODING;

//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}

static void Usage(void)
{
	IDSwprintf(hModule, IDS_SYNTAX);
	IDSwprintf(hModule, IDS_SYNTAX1);
	IDSwprintf(hModule, IDS_OPTIONS);
	IDSwprintf(hModule, IDS_OPTION_U_DESC);
	IDSwprintf(hModule, IDS_OPTION_U_DESC1);
	IDSwprintf(hModule, IDS_OPTION_U_DESC2);
	IDSwprintf(hModule,IDS_OPTION_S_DESC);			
	IDSwprintf(hModule,IDS_OPTION_R_DESC);			
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE,IDS_R_CU,IDS_R_LM,IDS_R_CU);	

}


//----------------------------------------------------------------------------
//
//Build the CTL_INFO struct and encode/sign it with no signer info
//----------------------------------------------------------------------------
HRESULT	BuildAndEncodeCTL(DWORD dwMsgEncodingType, LPSTR szOid, DWORD dwCount, BYTE **rgpHash, 
				  DWORD	*rgcbHash, BYTE		**ppbEncodedCTL,	DWORD	*pcbEncodedCTL)
{
	HRESULT					hr=E_FAIL;
	CMSG_SIGNED_ENCODE_INFO sSignInfo;
    CTL_INFO                CTLInfo;
	DWORD					dwIndex=0;

	if(dwCount==0 || !rgpHash || !ppbEncodedCTL || !pcbEncodedCTL)
		return E_INVALIDARG;

	//init
	*ppbEncodedCTL=NULL;
	*pcbEncodedCTL=0;

	memset(&sSignInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    sSignInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

	memset(&CTLInfo, 0, sizeof(CTL_INFO));

	//set up CTL
	CTLInfo.dwVersion=CTL_V1;
    CTLInfo.SubjectUsage.cUsageIdentifier = 1;
    CTLInfo.SubjectUsage.rgpszUsageIdentifier = (LPSTR *)&szOid;
	GetSystemTimeAsFileTime(&(CTLInfo.ThisUpdate));
	CTLInfo.SubjectAlgorithm.pszObjId=szOID_OIWSEC_sha1;

	CTLInfo.cCTLEntry=dwCount;
	CTLInfo.rgCTLEntry=(CTL_ENTRY *)ToolUtlAlloc(sizeof(CTL_ENTRY)*dwCount);
	if(!(CTLInfo.rgCTLEntry))
	{
		hr=E_OUTOFMEMORY;
		goto CLEANUP;
	}

	//memset
	memset(CTLInfo.rgCTLEntry, 0, sizeof(CTL_ENTRY)*dwCount);

	for(dwIndex=0; dwIndex<dwCount; dwIndex++)
	{
		CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.cbData=rgcbHash[dwIndex];
 		CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.pbData=rgpHash[dwIndex];
	}


	//encode and sign the CTL
    if(!CryptMsgEncodeAndSignCTL(dwMsgEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    NULL,
                                    pcbEncodedCTL))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		goto CLEANUP;
	}

	//memory allocation
	*ppbEncodedCTL=(BYTE *)ToolUtlAlloc(*pcbEncodedCTL);

	if(!(*ppbEncodedCTL))
	{
		hr=E_OUTOFMEMORY;
		goto CLEANUP;
	}

    if(!CryptMsgEncodeAndSignCTL(dwMsgEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    *ppbEncodedCTL,
                                    pcbEncodedCTL))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		goto CLEANUP;
	}


	hr=S_OK;

CLEANUP:

	if(hr!=S_OK)
	{
		if(*ppbEncodedCTL)
		{
			ToolUtlFree(*ppbEncodedCTL);
			*ppbEncodedCTL=NULL;
		}

		*pcbEncodedCTL=0;
	}

	if(CTLInfo.rgCTLEntry)
		ToolUtlFree(CTLInfo.rgCTLEntry);

	return hr;

} 


//----------------------------------------------------------------------------
//
//Get the hash of the certificates from the store
//----------------------------------------------------------------------------
HRESULT	GetCertFromStore(LPWSTR	wszStoreName, BOOL	fSystemStore, DWORD	dwStoreFlag)
{
	HCERTSTORE		hStore=NULL;
	HRESULT			hr=E_FAIL;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;
	BYTE			*pbData=NULL;
	DWORD			cbData=0;
    void            *p = NULL;
    
	//open the store
	if(fSystemStore)
	{
	   	hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
					g_dwMsgAndCertEncodingType,
					NULL,
					dwStoreFlag | CERT_STORE_READONLY_FLAG,
					wszStoreName);


	}
	else
	{
		//Serialized Store, PKCS#7, Encoded Cert 
		hStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 wszStoreName);
	}

	if(!hStore)
	{
		hr=GetLastError();
		IDSwprintf(hModule, IDS_ERR_OPEN_STORE);
		goto CLEANUP;
	}

    //now, we need to enum all the certs in the store
	while(pCertContext=CertEnumCertificatesInStore(hStore, pCertPre))
	{

		//get the SHA1 hash of the certificate
		if(!CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID,NULL,&cbData))
		{
			hr=GetLastError();
			IDSwprintf(hModule, IDS_ERR_HASH);
			goto CLEANUP;
		}

		pbData=(BYTE *)ToolUtlAlloc(cbData);
		if(!pbData)
		{
			hr=E_OUTOFMEMORY;
			IDSwprintf(hModule, IDS_ERR_MEMORY);
			goto CLEANUP;
		}

 		//get the SHA1 hash of the certificate
		if(!CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID,pbData,&cbData))
		{
			hr=GetLastError();
			IDSwprintf(hModule, IDS_ERR_HASH);
			ToolUtlFree(pbData);
			goto CLEANUP;
		}


		//add to our global list
		g_dwCount++;

		//re-alloc memory
        p = (void *)g_rgpHash;        
		g_rgpHash=(BYTE **)realloc(g_rgpHash, sizeof(BYTE *)*g_dwCount);
        if(!g_rgpHash)
		{
			g_rgpHash = (BYTE **)p;
            hr=E_OUTOFMEMORY;
			IDSwprintf(hModule, IDS_ERR_HASH);
			ToolUtlFree(pbData);
			goto CLEANUP;
		}
        
        p = (void *)g_rgcbHash;    
		g_rgcbHash=(DWORD *)realloc(g_rgcbHash, sizeof(DWORD)*g_dwCount);
		if(!g_rgcbHash)
		{
			g_rgcbHash = (DWORD *)p;
            hr=E_OUTOFMEMORY;
			IDSwprintf(hModule, IDS_ERR_HASH);
			ToolUtlFree(pbData);
			goto CLEANUP;
		}

	    g_rgpHash[g_dwCount-1]=pbData;
		g_rgcbHash[g_dwCount-1]=cbData;

		pCertPre=pCertContext;
	}

	hr=S_OK;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(hStore)
		CertCloseStore(hStore, 0);

	return hr;

}
extern "C" int __cdecl wmain(int argc, WCHAR *wargv[])
{
    int				ReturnStatus=-1;
	HRESULT			hr=E_FAIL;
    LPWSTR			pwszOutputFilename=NULL;
   	DWORD			dwIndex=0;
	LPSTR			szOid=szOID_PKIX_KP_CODE_SIGNING;
	BOOL			fAllocated=FALSE;
	LPWSTR			pwszOption=NULL;

	BYTE			*pbEncodedCTL=NULL;
	DWORD			cbEncodedCTL=0;
	WCHAR			wszSwitch1[10];
	WCHAR			wszSwitch2[10];

	BOOL			fSystemstore=FALSE;
	LPWSTR			wszStoreLocation=NULL;
	DWORD			dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;

	
    //we call the UI version of the makectl if no parameters are passed into
    //the command line
    if(1==argc)
    {
        //build the CTL file without signing process
        //call the wizard which provides feedback
        if(CryptUIWizBuildCTL(CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL))
            return 0;
        else
            return -1;
    }

	if(argc<3)
	{
		Usage();
		return ReturnStatus;
	}

	if(!InitModule())
		goto ErrorReturn;


	//process the stores one at a time
    for (dwIndex=1; dwIndex<(DWORD)(argc-1); dwIndex++)
    {	

       	//see if this is the options
		if(IDSwcsnicmp(hModule, wargv[dwIndex], IDS_SWITCH1, 1)==0 ||
		   IDSwcsnicmp(hModule, wargv[dwIndex], IDS_SWITCH2, 1)==0)
		{
			pwszOption=wargv[dwIndex];

			//get the OIDs
			if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_U)==0)
			{
				dwIndex++;

				if(dwIndex >= (DWORD)((argc-1)))
				{
					IDSwprintf(hModule,IDS_TOO_FEW_PARAM);
					goto ErrorReturn;
				}

				if(!fAllocated)
				{
					if(S_OK != WSZtoSZ(wargv[dwIndex], &szOid))
						goto ErrorReturn;

					fAllocated=TRUE;
				}
				else
				{
					IDSwprintf(hModule,IDS_TOO_MANY_PARAM);
					goto ErrorReturn;

				}
		
			}
			//check for -s options
			else if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_S)==0)
			{
				fSystemstore=TRUE;		
			}
			//check for -r options
		    else if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_R)==0)
			{
				dwIndex++;

				if(dwIndex >= (DWORD)((argc-1)))
				{
					IDSwprintf(hModule,IDS_TOO_FEW_PARAM);
					goto ErrorReturn;
				}

				if(NULL==wszStoreLocation)
				{
					wszStoreLocation=wargv[dwIndex];

					if(IDSwcsicmp(hModule, wszStoreLocation, IDS_R_CU)==0)
						dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
					else
					{
						if(IDSwcsicmp(hModule,wszStoreLocation, IDS_R_LM)==0)
							dwStoreFlag=CERT_SYSTEM_STORE_LOCAL_MACHINE;
						else
						{
							IDSwprintf(hModule, IDS_INVALID_R);
							goto ErrorReturn;
						}
					}
				
				}
				else
				{
					IDSwprintf(hModule,IDS_TOO_MANY_PARAM);
					goto ErrorReturn;

				}
		
			}
			else
			{

				//print out the Usage
				Usage();
				return ReturnStatus;
			}
		}
		else
		{
			//build the cert hash from the store
			if(S_OK !=(hr=GetCertFromStore(wargv[dwIndex], fSystemstore, dwStoreFlag)))
				goto ErrorReturn;

			//int for the next cycle
			fSystemstore=FALSE;
			wszStoreLocation=NULL;
			dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
			hr=E_FAIL;
		}
		
    }

	if(0==g_dwCount)
	{
		IDSwprintf(hModule, IDS_TOO_FEW_PARAM);
		hr=E_FAIL;
		goto ErrorReturn;
	}

	//set up the CTL_INFO structure
	if(S_OK!=(hr=BuildAndEncodeCTL(g_dwMsgAndCertEncodingType, szOid, g_dwCount, g_rgpHash, g_rgcbHash, &pbEncodedCTL,
			&cbEncodedCTL)))
	{
		IDSwprintf(hModule, IDS_ERR_ENCODE_CTL);
		goto ErrorReturn;
	}

	//get the output file name
	pwszOutputFilename = wargv[argc-1];
    if(S_OK!=(hr=OpenAndWriteToFile(pwszOutputFilename, pbEncodedCTL, cbEncodedCTL)))
	{
		IDSwprintf(hModule, IDS_ERR_SAVE_CTL);
		goto ErrorReturn;
	}

	//mark succeed
    ReturnStatus = 0;
	hr=S_OK;
	IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;
            


ErrorReturn:
    ReturnStatus = -1;
	//print out an error msg
	IDSwprintf(hModule, IDS_FAILED,hr,hr);	   


CommonReturn:
	if(g_rgpHash)
	{
		for(dwIndex=0; dwIndex<g_dwCount; dwIndex++)
			ToolUtlFree(g_rgpHash[dwIndex]);

		ToolUtlFree(g_rgpHash);
	}

	if(fAllocated)
		ToolUtlFree(szOid);

	if(g_rgcbHash)
		ToolUtlFree(g_rgcbHash);


	if(pbEncodedCTL)
		ToolUtlFree(pbEncodedCTL);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makecert\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecert.rc
//
#define VS_VERSION_INFO1            2
#define IDR_PVKROOT                 101
#define IDR_ROOTCERTIFICATE         102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



#define IDS_SYNTAX				     6001
#define IDS_BASIC_OPTIONS		     6002
#define IDS_EXTENDED_OPTIONS	     6003
#define IDS_OPTION_SK			     6004
#define IDS_OPTION_SK_DESC		     6005
#define IDS_OPTION_SC			     6006
#define IDS_OPTION_SC_DESC		     6007
#define IDS_OPTION_SV			     6008
#define IDS_OPTION_SV_DESC		     6009
#define IDS_OPTION_IK			     6010
#define IDS_OPTION_IK_DESC		     6011
#define IDS_OPTION_IC			     6012
#define IDS_OPTION_IC_DESC		     6013
#define IDS_OPTION_IV			     6014
#define IDS_OPTION_IV_DESC		     6015
#define IDS_OPTION_SERIAL		     6016
#define IDS_OPTION_SERIAL_DESC	     6017
#define IDS_OPTION_AUTH			     6018
#define IDS_OPTION_AUTH_DESC	     6019
#define IDS_OPTION_ALL_VALUES	     6020
#define IDS_OPTION_AUTH_IND		     6021
#define IDS_OPTION_AUTH_COM		     6022
#define IDS_OPTION_ALGO			     6025
#define IDS_OPTION_ALGO_DESC	     6026
#define IDS_OPTION_ALGO_SHA		     6027
#define IDS_OPTION_ALGO_MD5		     6028
#define IDS_OPTION_VALUES_DEFAULT    6029
#define IDS_OPTION_VALUES_2		     6030
#define IDS_OPTION_VALUES_3		     6031
#define IDS_OPTION_IY			     6032
#define IDS_OPTION_IY_DESC		     6033
#define IDS_OPTION_IP			     6034
#define IDS_OPTION_IP_DESC		     6035
#define IDS_OPTION_N			     6036
#define IDS_OPTION_N_DESC		     6037
#if (1) //DSIE: Bug 205195.
#define IDS_OPTION_PE                6038
#define IDS_OPTION_PE_DESC           6039
#endif
#define IDS_OPTION_L			     6040
#define IDS_OPTION_L_DESC		     6041
#define IDS_OPTION_IKY			     6042
#define IDS_OPTION_IKY_DESC		     6043
#define IDS_OPTION_KY_SIG		     6044
#define IDS_OPTION_KY_EXC		     6045
#define IDS_OPTION_CY			     6046
#define IDS_OPTION_CY_DESC		     6047
#define IDS_OPTION_CY_END		     6048
#define IDS_OPTION_CY_AUTH		     6049
#define IDS_OPTION_CY_BOTH		     6050
#define IDS_OPTION_B			     6052
#define IDS_OPTION_B_DESC		     6053
#define IDS_OPTION_M			     6054
#define IDS_OPTION_M_DESC		     6055
#define IDS_OPTION_E			     6056
#define IDS_OPTION_E_DESC		     6057
#define IDS_OPTION_H			     6058
#define IDS_OPTION_H_DESC		     6059
#define IDS_OPTION_G			     6060
#define IDS_OPTION_G_DESC		     6061
#define IDS_OPTION_R			     6062
#define IDS_OPTION_R_DESC		     6063
#define IDS_OPTION_NSCP			     6064
#define IDS_OPTION_NSCP_DESC	     6065
#define IDS_OPTION_EXTENDED		     6066
#define IDS_OPTION_EXTENDED_DESC     6067
#define IDS_OPTION_BASIC		     6068
#define IDS_OPTION_BASIC_DESC	     6069
#define	IDS_SWITCH1				     6070
#define IDS_SWITCH2				     6071
#define IDS_OPTION_IS			     6072
#define IDS_OPTION_IS_DESC		     6073
#define IDS_OPTION_IR			     6074
#define IDS_OPTION_IR_DESC		     6075
#define IDS_OPTION_CU				 6076
#define IDS_OPTION_LM				 6077
#define IDS_OPTION_ENHKEY_USAGE      6078
#define IDS_OPTION_ENHKEY_USAGE_DESC 6079
#define IDS_OPTION_SY			     6080
#define IDS_OPTION_SY_DESC		     6081
#define IDS_OPTION_SP			     6082
#define IDS_OPTION_SP_DESC		     6083
#define	IDS_OPTION_SS				 6084
#define IDS_OPTION_SS_DESC			 6085
#define IDS_OPTION_SR				 6087
#define IDS_OPTION_SR_DESC			 6088
#define	IDS_OPTION_IN				 6089
#define	IDS_OPTION_IN_DESC			 6090
#define IDS_OPTION_SKY			     6091
#define IDS_OPTION_SKY_DESC		     6092
#define IDS_OPTION_VALUES_KY		 6093

#define IDS_OPTION_NOPUBKEYPARA      6095
#define IDS_OPTION_NOPUBKEYPARA_DESC 6096

#define IDS_OPTION_SQ				 6097
#define IDS_OPTION_SQ_DESC			 6098

#define IDS_OPTION_DH_PARA           6099
#define IDS_OPTION_DH_PARA_DESC      6100
#define IDS_OPTION_KEY_LEN           6101
#define IDS_OPTION_KEY_LEN_DESC      6102
#define IDS_OPTION_NOPUBVERIFY       6103
#define IDS_OPTION_NOPUBVERIFY_DESC  6104
#define	IDS_OPTION_TEST				 6105


#define IDS_MAKECERT_ROOT			6994
#define IDS_ERR_SELF_SIGNED			6995
#define IDS_ERR_NO_ALGO				6996
#define IDS_ERR_NO_KY				6997
#define IDS_ERR_NO_CY				6998
#define IDS_ERR_NO_AUTH	            6999
#define IDS_ERR_TOO_MANY_PARAM		7000			
#define IDS_ERR_LAST				7001
#define IDS_ERR_CANNOT_OPEN			7002
#define IDS_ERR_EMPTY_FILE			7003
#define IDS_ERR_CANNOT_ALLOC		7004
#define IDS_ERR_CANNOT_READ			7005
#define IDS_ERR_COINIT				7006
#define IDS_ERR_FAILED				7007
#define IDS_ERR_LOAD_ROOT			7008
#define IDS_ERR_ROOT_KEY			7009
#define IDS_ERR_LOAD_ISSUER			7010
#define IDS_ERR_MISMATCH			7011
#define IDS_ERR_ISSUER_KEY			7012
#define IDS_ERR_BAD_PSW				7013
#define IDS_ERR_SUB_FILE_EXIST		7014
#define IDS_ERR_SUB_FILE_CREATE		7015
#define IDS_ERR_SUB_KEY				7016
#define IDS_ERR_SUB_KEY_CREATE		7017
#define IDS_ERR_CANNOT_LOAD_SUB_CERT   7018
#define IDS_ERR_NO_OUTPUT			7019
			
#define IDS_ERR_DESC_ALLOC			7020
#define IDS_ERR_DESC_WRITE			7021
#define IDS_ERR_SIGN_ENCODE_CB		7022
#define IDS_ERR_SIGN_ENCODE			7023
#define IDS_ERR_EXPORT_PUB			7024
#define IDS_CERT_STR_TO_NAME		7025
#define IDS_CRYPT_HASH_CERT			7026
#define IDS_CRYPT_HASP_PUB			7027
#define IDS_ENCODE_AUTH_KEY			7028
#define IDS_ENCODE_SPC_AGENCY		7029
#define IDS_ENCODE_UNICODE_NAME_VALUE  7030
#define IDS_ENCODE_KEY_USAGE		7031
#define IDS_ENCODE_FINANCIAL		7032
#define IDS_ENCODE_BASIC_CONSTRAINTS2  7033
#define IDS_SUCCEEDED				7034
#define IDS_ERR_NO_IR				7035
#define IDS_ERR_DESC_SAVE_STORE		7036 
#define IDS_ERR_INVALID_B			7037
#define	IDS_ERR_INVALID_E			7038
#define	IDS_OPTION_TIME_DESC		7039

#define IDS_ROOT					7040
#define IDS_CER						7041
#define IDS_PVK						7042
#define IDS_GLUE					7043
#define IDS_BACK_SLASH				7044
#define IDS_JOE_SOFT				7045
#define IDS_JOE_NAME				7046
#define IDS_ROOT_SIGNATURE			7047
#define IDS_ISSUER_SIGNATURE		7048
#define IDS_SUB_SIG					7049
#define IDS_SUB_EXCHANGE			7050
#define IDS_NULL					7051
#define IDS_PLUS					7052
#define IDS_REG_CA					7053
#define IDS_REG_ROOT				7054
#define IDS_REG_MY					7055

#define	IDS_ERR_NO_PROV_FROM_CERT	7056
#define	IDS_ERR_NO_ISSUER_CERT		7057
#define	IDS_ERR_MORE_ISSUER_CERT	7058
#define	IDS_ERR_NO_ISSUER_CER_FILE	7059
#define	IDS_ERR_EITHER_STORE_OR_KEY	7060
#define	IDS_ERR_TOO_MANY_STORE_KEY	7061
#define	IDS_ERR_CERT_FILE_NAME		7062
#define	IDS_OPTION_SS_DESC1			7063
#define	IDS_ERR_SK_SV				7064
#define	IDS_NO_ISSUER_FOR_SELF_SIGNED   7065
#define	IDS_NO_PKCS10_AND_SELF_SIGNED	7066
#define	IDS_ERR_DH_PARA_FILE        7067
#define	IDS_INVALID_REQUEST_FILE		7068
#define	IDS_NO_PKCS10_AND_SUBJECT_PVK	7069
#define	IDS_INVALID_ATTR_REQUEST_FILE	7070

#if (1) //DSIE: Bug 205195.
#define IDS_ERR_PE_CONTAINER        7071
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makecert\root.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       root.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makecert\rootasn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rootasn.h
//
//--------------------------------------------------------------------------

0x30,0x5B,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,
0x00,0x03,0x4A,0x00,0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,
0xD6,0xE7,0xD9,0x66,0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,
0xB1,0xF7,0x87,0x30,0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,
0x5F,0x42,0xB6,0x9D,0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,
0x58,0x11,0xCB,0x40,0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\makectl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for makectl.cpp.  
//
//
//  History:    01-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS
 
#define IDS_SYNTAX					6002
#define	IDS_CAN_NOT_READ_FILE		6003
#define	IDS_CAN_NOT_PROPERTY		6004
#define	IDS_OUT_OF_MEMORY			6005
#define	IDS_OPTION_U				6006	
#define	IDS_OPTION_U_DESC			6007
#define	IDS_OPTIONS					6008
#define IDS_SYNTAX1					6009
#define	IDS_OPTION_U_DESC1			6010
#define	IDS_OPTION_U_DESC2			6011
#define IDS_FAILED					6013
#define IDS_SUCCEEDED				6014
#define	IDS_SWITCH1					6015
#define	IDS_SWITCH2					6016
#define IDS_TOO_FEW_PARAM			6017
#define	IDS_TOO_MANY_PARAM			6018
#define	IDS_OPTION_S				6019	
#define	IDS_OPTION_S_DESC			6020
#define	IDS_OPTION_R				6021
#define	IDS_OPTION_R_DESC           6022
#define	IDS_OPTION_MORE_VALUE		6023	                  
#define	IDS_R_CU					6024
#define	IDS_R_LM					6025
#define	IDS_ERR_OPEN_STORE			6026						
#define	IDS_ERR_HASH				6027			
#define	IDS_ERR_MEMORY				6028
#define	IDS_INVALID_R				6029
#define	IDS_ERR_ENCODE_CTL			6030
#define	IDS_ERR_SAVE_CTL			6031
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\signcode\javaattr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       JavaAttr.h
//
//
//----------------------------------------------------------------------------

#ifndef _JAVA_ATTR_DLL_H
#define _JAVA_ATTR_DLL_H



#ifdef __cplusplus
extern "C" {
#endif

//+-----------------------------------------------------------------------
//  
//  InitAttr:
//
//		This function should be called as the first call to the dll.
//
//		The dll has to use the input memory allocation and free routine
//		to allocate and free all memories, including internal use.
//      It has to handle when pInitString==NULL.
//
//------------------------------------------------------------------------

HRESULT WINAPI  
InitAttr(LPWSTR			pInitString); //IN: the init string
	
typedef HRESULT (*pInitAttr)(LPWSTR	pInitString);

 //+-----------------------------------------------------------------------
//  
//  GetAttrs:
//
//
//		Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttr(PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
        PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttr)(PCRYPT_ATTRIBUTES  *ppsAuthenticated,		
							PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	


 //+-----------------------------------------------------------------------
//  
//  GetAttrsEx:
//
//
//		Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttrEx(  DWORD               dwFlags,                //In:   Reserved.  Set to 0.
            LPWSTR              pwszFileName,           //In:   The file name to sign
            LPWSTR			    pInitString,            //In:   The init string, same as the input parameter to InitAttr
            PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
            PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttrEx)(DWORD                 dwFlags,
                              LPWSTR                pwszFileName,
                              LPWSTR			    pInitString,
                              PCRYPT_ATTRIBUTES     *ppsAuthenticated,		
							  PCRYPT_ATTRIBUTES     *ppsUnauthenticated);	



//+-----------------------------------------------------------------------
//  
//  ReleaseAttrs:
//
//
//		Release authenticated and unauthenticated attributes
//		returned from GetAttr(). 
//
//      psAuthenticated and psUnauthenticated should never be NULL.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
ReleaseAttr(PCRYPT_ATTRIBUTES  psAuthenticated,		// OUT: Authenticated attributes to be released
			PCRYPT_ATTRIBUTES  psUnauthenticated);	// OUT: Uunauthenticated attributes to be released
	
typedef HRESULT (*pReleaseAttr)(PCRYPT_ATTRIBUTES  psAuthenticated,		
								PCRYPT_ATTRIBUTES  psUnauthenticated);	


//+-----------------------------------------------------------------------
//  
//  ExitAttr:
//
//		This function should be called as the last call to the dll
//------------------------------------------------------------------------
HRESULT	WINAPI
ExitAttr( );	

typedef HRESULT (*pExitAttr)();



#ifdef __cplusplus
}
#endif

#endif  //#define _JAVA_ATTR_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\signcode\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for signcode.cpp
//
//
//  History:    07-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS

#define			IDS_CAPITION				5993
#define			IDS_PLUS					5994
#define			IDS_NULL					5995
#define			IDS_MY						5996
#define			IDS_SPC						5997
#define			IDS_ROOT					5998
#define			IDS_CA						5999
#define			IDS_ENFLN					6000
#define			IDS_SYNTAX					6001																																																																	               
#define			IDS_OPTIONS					6002
#define			IDS_OPTION_C				6003
#define			IDS_OPTION_C_DESC			6004
#define			IDS_OPTION_S				6005
#define			IDS_OPTION_S_DESC			6006
#define			IDS_OPTION_MORE_DESC		6007
#define			IDS_OPTION_R				6008
#define			IDS_OPTION_R_DESC			6009
#define			IDS_OPTION_MORE_VALUE		6011
#define			IDS_OPTION_V				6012
#define			IDS_OPTION_V_DESC			6013
#define			IDS_OPTION_K				6014
#define			IDS_OPTION_K_DESC			6015
#define			IDS_OPTION_N				6016
#define			IDS_OPTION_N_DESC			6017
#define			IDS_OPTION_I				6018
#define			IDS_OPTION_I_DESC			6019
#define			IDS_OPTION_P				6020
#define			IDS_OPTION_P_DESC			6021
#define			IDS_OPTION_Y				6022
#define			IDS_OPTION_Y_DESC			6023
#define			IDS_OPTION_AUTH				6024
#define			IDS_OPTION_AUTH_DESC		6025
#define			IDS_OPTION_A				6026
#define			IDS_OPTION_A_DESC			6027
#define			IDS_OPTION_T				6028
#define			IDS_OPTION_T_DESC			6029
#define			IDS_OPTION_X				6030
#define			IDS_OPTION_X_DESC			6031
#define			IDS_OPTION_H				6032
#define			IDS_OPTION_TQ				6033
#define			IDS_OPTION_TS				6034
#define			IDS_SWITCH1					6035
#define			IDS_SWITCH2					6036
#define			IDS_OPTION_SPC				6037
#define			IDS_OPTION_SPC_DESC			6039
#define			IDS_OPTION_J				6040
#define			IDS_OPTION_J_DESC			6041
#define			IDS_OPTION_JP				6042
#define			IDS_OPTION_JP_DESC			6043
#define			IDS_OPTION_TW				6044
#define			IDS_OPTION_TW_DESC			6045
#define			IDS_OPTION_TR				6046
#define			IDS_OPTION_TR_DESC			6047
#define			IDS_OPTION_CN				6048
#define			IDS_OPTION_CN_DESC			6049
		
#define			IDS_A_MD5					6050
#define			IDS_A_SHA					6051
#define			IDS_R_CU					6052
#define			IDS_R_LM					6053
#define			IDS_AUTHORITY_ID			6054
#define			IDS_AUTHORITY_CM			6055
#define			IDS_AUTHORITY_DEFAULT		6056
#define			IDS_OPTION_AUTH_VALUE		6057
#define         IDS_OPTION_AUTH_VALUE1      6058
#define			IDS_OPTION_SP_DESC1			6059

											
#define			IDS_ACTION_SIGN				6060
#define			IDS_ACTION_TIMESTAMP		6061
#define			IDS_ACTION_REQUEST			6062
#define			IDS_ACTION_RESPONSE			6063
#define			IDS_ACTION_SIGNCODE			6064
	
#define			IDS_SIGNED					6071
#define			IDS_RESIGN					6072
#define			IDS_ERROR					6073
#define			IDS_SUCCEEDED				6074
#define			IDS_FAILED					6075
#define			IDS_TEST_SUCCEEDED			6076
#define			IDS_TEST_FAILED				6077
#define			IDS_WARNING					6078
#define			IDS_ERR_TOO_MANY_PARAM		6079
#define			IDS_ERR_INPUT_INVALID   	6080
#define			IDS_ERR_RESPONSE_INVALID	6081
#define			IDS_ERR_NOMATCH				6082
#define			IDS_ERR_AUTH				6083
#define			IDS_ERR_RESIZE				6084
#define			IDS_ERR_NO_SPC				6085
#define			IDS_ERR_NO_PVK				6086
#define			IDS_ERR_NO_FILE				6087
#define			IDS_ERR_ADDR_INVALID		6088
#define			IDS_ERR_HTTP				6089
#define			IDS_ERR_TIME_RESPONSE		6090
#define			IDS_ERR_SIGN_RESPONSE		6091
#define			IDS_ERR_BOTH_PVK			6092
#define			IDS_ERR_BOTH_SPC			6093
#define			IDS_ERR_NO_ALGO				6094
#define			IDS_ERR_NO_AUTH				6095
#define			IDS_HTTP					6096
#define			IDS_ERR_NO_REG				6097
#define			IDS_ERR_TOO_FEW_PARAM		6098
#define			IDS_ERR_HRPOV_FROM_CERT		6099
#define			IDS_ERR_NO_CERT_CHAIN		7000
#define			IDS_OPTION_SP				7001			
#define			IDS_OPTION_SP_DESC			7002		
#define			IDS_OPTION_SP_CHAIN			7003	
#define			IDS_OPTION_SP_SPCSTORE		7004
#define			IDS_OPTION_ADD				7005			
#define			IDS_OPTION_ADD_DESC			7006	
#define			IDS_OPTION_ADDR				7007
#define			IDS_OPTION_ADDR_DESC		7008
#define			IDS_ERR_NO_POLICY			7009
#define			IDS_TIMESTAMP_TIMES_DELAY	7010
#define			IDS_TIMESTAMP_TIMES			7011
#define			IDS_ERR_INVALID_ADDRESS		7012
#define			IDS_ERR_TS_CERT_INVALID		7013
#define			IDS_STORE_LOCATION_NAME		7014
#define			IDS_ERR_NO_CERT				7015
#define			IDS_ERR_TOO_MANY_CERT		7016
#define			IDS_ERR_NO_PROVIDER			7017
#define			IDS_ERR_NO_CHAINING			7018
#define			IDS_ERR_EXPRIED				7019
#define         IDS_OPTION_INDEX			7020
#define			IDS_OPTION_INDEX_DESC		7021 
#define			IDS_SIGNER_INDEX			7022
#define			IDS_MORE_INFO_1             7023
#define			IDS_MORE_INFO_2             7024
#define			IDS_MORE_INFO_3             7025


#define			IDS_OPTION_KY				7030
#define			IDS_OPTION_KY_DESC			7031
#define			IDS_OPTION_KY_VALUES		7032
#define			IDS_OPTION_KY_EXC			7033
#define			IDS_OPTION_KY_SIG			7034
#define			IDS_OPTION_H_DESC			7035
#define			IDS_OPTION_TQ_DESC			7036
#define			IDS_OPTION_TS_DESC			7037
#define			IDS_OPTION_TEST				7038
#define			IDS_OPTION_SHA1_DESC        7039
#define			IDS_OPTION_SHA1		        7040
#define			IDS_ERR_BOTH_CN_SHA1        7041
#define			IDS_ERR_SHA1_HASH           7042
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\signcode\signcode.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signcode.cpp
//
//  Contents:   The signcode console tool
//
//  History:    July-1st-1997	Xiaohs    Created
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>
#include <wincrypt.h>

#include <signer.h>
#include "mssip.h"
#include "resource.h"
#include "unicode.h"
#include "signhlp.h"
#include "pvkhlpr.h"
#include "toolutl.h"
#include "javaAttr.h"
#include "cryptui.h"


#define ACTION_SIGN					0x01
#define ACTION_STAMP				0x02
#define ACTION_REQUEST				0x04 
#define ACTION_RESPONSE				0x08

#define STORE_DEFAULT_NAME_MAX			40
#define	SHA1_LENGTH				        20


// Global data for parsing the input parameters
DWORD	dwAction =		0;
DWORD   dwExpectedError = 0;

BOOL	fSigning =		TRUE;
BOOL    fTesting =      FALSE;
BOOL	fStoreTechnology=TRUE;

BOOL	fUndocumented = FALSE;

LPWSTR pwszFile =        NULL;
LPWSTR pwszCapiProvider=NULL;
LPWSTR pwszProviderType=NULL;
LPWSTR pwszPvkFile =	  NULL; 
LPWSTR pwszKeyContainer= NULL;
LPWSTR pwszOpusName =    NULL;
LPWSTR pwszOpusInfo =    NULL;
LPWSTR pwszAlgorithm =   NULL;	
LPWSTR pwszAuthority =   NULL;
LPWSTR pwszSpcFile =     NULL;
LPWSTR pwszCertFile		=NULL;
LPWSTR pwszCommonName =NULL;
LPWSTR pwszStoreName=	  NULL;
LPWSTR pwszStoreLocation=NULL;
LPWSTR pwszStorePolicy=	 NULL;
LPWSTR pwszHttpTime =    NULL;
LPWSTR pwszRequestFile  =NULL;
LPWSTR pwszResponseFile =NULL;
LPWSTR pwszWait=NULL;
LPWSTR pwszRepeat=NULL;
LPWSTR pwszKeySpec=NULL;
LPWSTR pwszSignerIndex=NULL;
LPWSTR pwszSha1Hash = NULL;

BYTE   *g_pbHash=NULL;
DWORD  g_cbHash=0;



DWORD	dwCertEncodingType=X509_ASN_ENCODING;
DWORD   dwStoreEncodingType=X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
DWORD	dwWait=0;
DWORD	dwRepeat=1;
DWORD   dwProviderType = PROV_RSA_FULL;
BOOL	fCommercial =   FALSE;
BOOL	fIndividual =   FALSE;
DWORD	dwKeySpec=0;
DWORD	dwSignerIndex=0;



LPWSTR				*prgwszDllName=NULL;
LPWSTR				*prgwszDllParam=NULL;
DWORD				dwDllIndex=0;
DWORD				dwParamIndex=0;


//default:
//Assume the store is on CERT_SYSTEM_STORE_CURRENT_USER 
DWORD	dwStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
DWORD	dwStorePolicy=SIGNER_CERT_POLICY_SPC;
WCHAR	wszMyStore[STORE_DEFAULT_NAME_MAX];
//Use MD5 as the default hashing algorithm
ALG_ID	dwAlgorithmOid = CALG_MD5;

//Global Data for loading the string
#define OPTION_SWITCH_SIZE	5
#define WSTR_LENGTH_MAX		30

WCHAR	wszCaption[WSTR_LENGTH_MAX];
WCHAR   wszNULL[WSTR_LENGTH_MAX];
WCHAR   wszPlus[WSTR_LENGTH_MAX];


HMODULE	hModule=NULL;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// function prototypes
HRESULT	InitDllParameter(PCRYPT_ATTRIBUTES pAuthAttr,
						 PCRYPT_ATTRIBUTES pUnauthAttr,
						 PCRYPT_ATTRIBUTES *ppAuthAttr, 
						 PCRYPT_ATTRIBUTES *ppUnauthAttr);

void	ReleaseDllParameter(PCRYPT_ATTRIBUTES * ppAuthAttr, 
							PCRYPT_ATTRIBUTES * ppUnauthAttr);

HRESULT SetUpSubjectInfo(SIGNER_SUBJECT_INFO		*pSubjectInfo,
						 SIGNER_FILE_INFO			*pFileInfo);

HRESULT	SetUpParameter(SIGNER_SUBJECT_INFO		*pSubjectInfo,
					   SIGNER_FILE_INFO			*pFileInfo,
					   SIGNER_SIGNATURE_INFO	*pSignatureInfo,
						SIGNER_ATTR_AUTHCODE	*pAttrAuthcode,
						SIGNER_PROVIDER_INFO	*pProviderInfo,
						SIGNER_CERT_STORE_INFO	*pCertStoreInfo,
						SIGNER_CERT				*pSignerCert,
						CRYPT_ATTRIBUTES		*pAuthenticated,
						CRYPT_ATTRIBUTES		*pUnauthenticated,
						HCERTSTORE				*phCertStore);


PCCERT_CONTEXT	GetSigningCert(HCERTSTORE *phCertStore);


HRESULT	GetCertHashFromFile(LPWSTR	pwszCertFile, 
							BYTE	**pHash, 
							DWORD	*pcbHash);
//--------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}

//--------------------------------------------------------------------------------
//
// Help command
//--------------------------------------------------------------------------------
void Usage()
{
	IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_OPTIONS);
	IDSwprintf(hModule,IDS_OPTION_SPC_DESC);

	IDSwprintf(hModule,IDS_OPTION_V_DESC);
	IDSwprintf(hModule,IDS_OPTION_K_DESC);

	IDSwprintf(hModule,IDS_OPTION_N_DESC);
	IDSwprintf(hModule,IDS_OPTION_I_DESC);
	IDSwprintf(hModule,IDS_OPTION_P_DESC);
	IDSwprintf(hModule,IDS_OPTION_Y_DESC);
	IDSwprintf(hModule,IDS_OPTION_KY_DESC);
	IDS_IDS_IDSwprintf(hModule, IDS_OPTION_KY_VALUES, IDS_OPTION_KY_SIG,
						IDS_OPTION_KY_EXC);
	IDSwprintf(hModule,IDS_OPTION_AUTH_DESC);
	IDS_IDS_IDSwprintf(hModule,IDS_OPTION_AUTH_VALUE, IDS_AUTHORITY_ID, 
		IDS_AUTHORITY_CM);
	IDS_IDSwprintf(hModule,IDS_OPTION_AUTH_VALUE1, IDS_AUTHORITY_DEFAULT);
	IDSwprintf(hModule,IDS_OPTION_A_DESC);
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_A_MD5, 
		IDS_A_SHA, IDS_A_MD5);

	IDSwprintf(hModule,IDS_OPTION_T_DESC);
	IDSwprintf(hModule,IDS_OPTION_TR_DESC);
	IDSwprintf(hModule,IDS_OPTION_TW_DESC);
	IDSwprintf(hModule,IDS_OPTION_J_DESC);
	IDSwprintf(hModule,IDS_OPTION_JP_DESC);

	IDSwprintf(hModule,IDS_OPTION_C_DESC);
	IDSwprintf(hModule,IDS_OPTION_S_DESC);
	IDSwprintf(hModule,IDS_OPTION_R_DESC);
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_R_LM, IDS_R_CU,IDS_R_CU);
	IDSwprintf(hModule,IDS_OPTION_SP_DESC);
	IDSwprintf(hModule,IDS_OPTION_SP_DESC1);
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_OPTION_SP_CHAIN, 
		IDS_OPTION_SP_SPCSTORE, IDS_OPTION_SP_SPCSTORE);
	IDSwprintf(hModule, IDS_OPTION_CN_DESC);
	IDSwprintf(hModule, IDS_OPTION_SHA1_DESC);

  	IDSwprintf(hModule,IDS_OPTION_X_DESC);



	IDSwprintf(hModule,IDS_ENFLN);
    IDSwprintf(hModule, IDS_MORE_INFO_1);
    IDSwprintf(hModule, IDS_MORE_INFO_2);
    IDSwprintf(hModule, IDS_MORE_INFO_3);
}

void UndocumentedUsage()
{
	IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_OPTIONS);

	IDSwprintf(hModule, IDS_OPTION_H_DESC);
    IDSwprintf(hModule, IDS_OPTION_TQ_DESC);
	IDSwprintf(hModule, IDS_OPTION_TS_DESC);
	IDSwprintf(hModule, IDS_OPTION_INDEX_DESC);

	//mark this is undocumented
	fUndocumented=TRUE;
}


//--------------------------------------------------------------------------------
// Print out error msg based on the HRESULT
//--------------------------------------------------------------------------------
BOOL	PrintBasedOnHResult(HRESULT hr)
{
	BOOL	fKnownResult=TRUE;

	switch(hr)
	{
		//0x80070002 is the HRESULT_FROM_WIN32(GetLastError()) when CreateFile failed
		case 0x80070002:
				IDSwprintf(hModule,IDS_ERR_INPUT_INVALID);
			break;
		case HRESULT_FROM_WIN32(ERROR_INVALID_DATA):
				IDSwprintf(hModule,IDS_ERR_RESPONSE_INVALID);
			break;
		case HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
				IDSwprintf(hModule, IDS_ERR_INVALID_ADDRESS);
			break;
		case CRYPT_E_NO_MATCH:
				IDSwprintf(hModule,IDS_ERR_NOMATCH);
			break;
		case TYPE_E_TYPEMISMATCH:
				IDSwprintf(hModule,IDS_ERR_AUTH);
			break;	
		case CRYPT_E_FILERESIZED:
				IDSwprintf(hModule,IDS_ERR_RESIZE);
			break;
		case TRUST_E_TIME_STAMP:
				IDSwprintf(hModule, IDS_ERR_TS_CERT_INVALID);
			break;
		case CRYPT_E_NO_DECRYPT_CERT:
				IDSwprintf(hModule, IDS_ERR_NO_CERT, pwszStoreName);
			break;
		case CRYPT_E_DELETED_PREV:
				IDSwprintf(hModule, IDS_ERR_TOO_MANY_CERT, pwszStoreName);
			break;
		case CRYPT_E_NO_PROVIDER:
				IDSwprintf(hModule, IDS_ERR_NO_PROVIDER);
			break;
		case CERT_E_CHAINING:
				IDSwprintf(hModule, IDS_ERR_NO_CHAINING);
			break;
		case CERT_E_EXPIRED:
				IDSwprintf(hModule, IDS_ERR_EXPRIED);
			break;
		default:
			fKnownResult=FALSE;
	}
	return fKnownResult;

}

//--------------------------------------------------------------------------------
// Convert an array of wchars to a BLOB
//--------------------------------------------------------------------------------
HRESULT	WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD	*pcbByte)
{
	HRESULT		hr=E_FAIL;
	DWORD		dwIndex=0;
	ULONG		ulHalfByte=0;
	DWORD		dw1st=0;
	DWORD		dw2nd=0;

	if((!pwsz) || (!ppbByte) || (!pcbByte))
		return E_INVALIDARG;

	*ppbByte=NULL;
	*pcbByte=0;

	//make sure the pwsz consists of 20 characters
	if(wcslen(pwsz)!= 2*SHA1_LENGTH)
		return E_FAIL;

	//memory allocation 
	*ppbByte=(BYTE *)ToolUtlAlloc(SHA1_LENGTH);
	if(NULL==(*ppbByte))
		return E_INVALIDARG;

	memset(*ppbByte, 0, SHA1_LENGTH);

	//go through two characters (one byte) at a time
	for(dwIndex=0; dwIndex<SHA1_LENGTH; dwIndex++)
	{
		dw1st=dwIndex * 2;
		dw2nd=dwIndex * 2 +1;

		//1st character
		if(((int)(pwsz[dw1st])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw1st])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw1st])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw1st]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw1st]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw1st]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//copy the 1st character
		(*ppbByte)[dwIndex]=(BYTE)ulHalfByte;

		//left shift 4 bits
		(*ppbByte)[dwIndex]= (*ppbByte)[dwIndex] <<4;

		//2nd character
	   	if(((int)(pwsz[dw2nd])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw2nd])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw2nd])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw2nd]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//ORed the second character
		(*ppbByte)[dwIndex]=(*ppbByte)[dwIndex] | ((BYTE)ulHalfByte);

	}


	hr=S_OK;

CLEANUP:

	if(hr!=S_OK)
	{
	   if(*ppbByte)
		   ToolUtlFree(*ppbByte);

	   *ppbByte=NULL;
	}
	else
		*pcbByte=SHA1_LENGTH;

	return hr;

}

//--------------------------------------------------------------------------------
//make sure the input parameters make sense for signing
//--------------------------------------------------------------------------------
BOOL CheckSignParam()
{
	//make sure pwszPvkFile and pwszKeyContainer name are not set at the same time
	if(pwszPvkFile && pwszKeyContainer)
	{
		IDSwprintf(hModule,IDS_ERR_BOTH_PVK);
		return FALSE;
	}

	//make sure spc/pvk information and store related information can not be set
	//at the same time
	if(pwszSpcFile || pwszPvkFile || pwszKeyContainer || pwszProviderType ||
		pwszCapiProvider ||pwszKeySpec)
	{
		fStoreTechnology=FALSE;

		if(pwszStoreName || pwszCertFile || pwszStoreName || pwszStorePolicy ||
			pwszStoreLocation || pwszCommonName || pwszSha1Hash)
		{
			IDSwprintf(hModule,IDS_ERR_BOTH_SPC);
			return FALSE;
		}

		//now that we are not using certStore, spc file has to be set
		if(!pwszSpcFile)
		{
			IDSwprintf(hModule, IDS_ERR_NO_SPC);
			return FALSE;
		}

		//either PVKFile or KeyContainer has to be set
		if(pwszPvkFile == NULL && pwszKeyContainer ==NULL)
		{
			IDSwprintf(hModule,IDS_ERR_NO_PVK);
			return FALSE;
		} 
	}

    //pwszCommonName, pwszCertFile and pwszSha1Hash can not be set at the same time
    if(pwszCertFile)
    {
        if(pwszCommonName || pwszSha1Hash)
        {
		    IDSwprintf(hModule, IDS_ERR_BOTH_CN_SHA1);
		    return FALSE;
        }
    }

    if(pwszCommonName && pwszSha1Hash)
    {
		IDSwprintf(hModule, IDS_ERR_BOTH_CN_SHA1);
		return FALSE;
    }

	//if pwszStoreLocation is set, then the storeName as to be set
	if(pwszStoreLocation && (pwszStoreName==NULL))
	{
		IDSwprintf(hModule, IDS_STORE_LOCATION_NAME);
		return FALSE;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------
//make sure the user has passed in a valid set of parameters
//--------------------------------------------------------------------------------
BOOL CheckParameter()
{
	BOOL	fValid=FALSE;

	//has to set the file name
	if(!pwszFile) 
	{
        IDSwprintf(hModule,IDS_ERR_NO_FILE);
        return FALSE;
    }


	if(fSigning==TRUE)
	{
		dwAction |= ACTION_SIGN;

		//make sure the input parameters make sense
		if(!CheckSignParam())
			return FALSE;
	}

	if(pwszResponseFile)
	{
		dwAction |= ACTION_RESPONSE;
	}

	if(pwszHttpTime)
	{
		dwAction |= ACTION_STAMP;


		//make sure that we have http:// in the address
		if(wcslen(pwszHttpTime)<=7)
		{
		   IDSwprintf(hModule,IDS_ERR_ADDR_INVALID);
		   return FALSE;
		}

		if(IDSwcsnicmp(hModule, pwszHttpTime, IDS_HTTP,7)!=0)
		{
		   IDSwprintf(hModule,IDS_ERR_HTTP);
		   return FALSE;
		}
	}

	if(pwszRequestFile)
	{
		dwAction |= ACTION_REQUEST;
		
	}

	//make sure timestamping and applying response do not go together
	if((dwAction & ACTION_RESPONSE) && (dwAction & ACTION_STAMP))
	{
		IDSwprintf(hModule,IDS_ERR_TIME_RESPONSE);
		return FALSE;
	}

  	//make sure apply response can not be done after a new signature
	if((dwAction & ACTION_SIGN) && (dwAction & ACTION_RESPONSE))
	{
		IDSwprintf(hModule,IDS_ERR_SIGN_RESPONSE);
		return FALSE;
	}



	//determine the algorithm OID
	if(pwszAlgorithm)
	{
		if(IDSwcsicmp(hModule, pwszAlgorithm, IDS_A_MD5) == 0) 
			dwAlgorithmOid = CALG_MD5;
		else 
		{
			if(IDSwcsicmp(hModule,pwszAlgorithm, IDS_A_SHA) == 0) 
				dwAlgorithmOid = CALG_SHA1;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_ALGO);
				return FALSE;
			}
		}

	}

	//determing the store location
	if(pwszStoreLocation)
	{
		if(IDSwcsicmp(hModule,pwszStoreLocation, IDS_R_CU) == 0) 
			dwStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
		else 
		{
			if(IDSwcsicmp(hModule,pwszStoreLocation, IDS_R_LM) == 0) 
				dwStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_REG);
				return FALSE;
			}
		}
	}


   	//determing the store policy
	if(pwszStorePolicy)
	{
		if(IDSwcsicmp(hModule,pwszStorePolicy, IDS_OPTION_SP_CHAIN) == 0) 
			dwStorePolicy=SIGNER_CERT_POLICY_CHAIN;
		else 
		{
			if(IDSwcsicmp(hModule, pwszStorePolicy, IDS_OPTION_SP_SPCSTORE) == 0) 
				dwStorePolicy=SIGNER_CERT_POLICY_SPC;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_POLICY);
				return FALSE;
			}
		}
	}

	//determine the signing authority, either individual or commercial
	if(pwszAuthority)
	{
		if(IDSwcsicmp(hModule,pwszAuthority, IDS_AUTHORITY_ID) == 0) 
			fIndividual = TRUE;
		else 
		{
			if(IDSwcsicmp(hModule,pwszAuthority, IDS_AUTHORITY_CM) == 0) 
				fCommercial = TRUE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_AUTH);
				return FALSE;
			}
		}
	}

	//determine the key specificatioin
	if(pwszKeySpec)
	{
		if(IDSwcsicmp(hModule,pwszKeySpec, IDS_OPTION_KY_SIG) == 0)
			dwKeySpec = AT_SIGNATURE;
		else
		{
			if(IDSwcsicmp(hModule,pwszKeySpec, IDS_OPTION_KY_EXC) == 0)
				dwKeySpec = AT_KEYEXCHANGE;
			else
				dwKeySpec=_wtol(pwszKeySpec);	
		}

	} 

    //get the hash 
	if(pwszSha1Hash)
	{
		if(S_OK != WSZtoBLOB(pwszSha1Hash, &g_pbHash, &g_cbHash))
		{
			//sha1 hash is invalid
			IDSwprintf(hModule, IDS_ERR_SHA1_HASH);
			return FALSE;
		}
	}


	//determine the provider Type
	if(pwszProviderType)
		dwProviderType = _wtoi(pwszProviderType);

	 //get the # of timestamp trial and the # of seconds of delay between
	 //each trial
	if(pwszWait)
		dwWait = _wtoi(pwszWait);

	if(pwszRepeat)
		dwRepeat = _wtoi(pwszRepeat);

   //determine the default store name
	if(!pwszStoreName)
		pwszStoreName=wszMyStore;

	//determin the signerIndex.  Default to 0
	if(pwszSignerIndex)
		dwSignerIndex=_wtol(pwszSignerIndex);
	
	return TRUE;
}

//--------------------------------------------------------------------------------
// Set the parameters.  They can only be set once
//--------------------------------------------------------------------------------
BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue)
{
	if(*ppwszParam!=NULL)
	{
		IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
		return FALSE;
	}

	*ppwszParam=pwszValue;

	return TRUE;
}


//--------------------------------------------------------------------------------
// Parse arguements
//--------------------------------------------------------------------------------
BOOL 
ParseSwitch (int	*pArgc,
             WCHAR	**pArgv[])
{
    WCHAR* param = **pArgv;

	//move pass '/' or '-'
    param++;

    if (IDSwcsicmp(hModule, param, IDS_OPTION_H) == 0)
    {
        fTesting = TRUE;
        if (!(param[1]))
        {
            if (!--(*pArgc)) 
                return FALSE;

            (*pArgv)++;
            param = **pArgv;
            dwExpectedError = wcstoul(&param[0], NULL, 16);
        }
        else
        {
            dwExpectedError = wcstoul(&param[1], NULL, 16);
        }

		return TRUE;
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_SPC)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;
	   return SetParam(&pwszSpcFile, **pArgv);
    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_C)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;
	   return SetParam(&pwszCertFile, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_S)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;
	   
	   return SetParam(&pwszStoreName, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_R)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;

	   return SetParam(&pwszStoreLocation, **pArgv);

    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_SP)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszStorePolicy, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_CN)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszCommonName, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_SHA1)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszSha1Hash, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_V)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszPvkFile, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_K)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszKeyContainer, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_N)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszOpusName, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_I)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszOpusInfo, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_P)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszCapiProvider, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_Y)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&pwszProviderType, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_KY)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&pwszKeySpec, **pArgv);
    }

    else if(IDSwcsicmp(hModule,param, IDS_OPTION_AUTH)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&pwszAuthority, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_A)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&pwszAlgorithm, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_X)==0) {
        fSigning=FALSE;
		
		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_T)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszHttpTime, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_TW)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszWait,**pArgv); 
   }
   else if(IDSwcsicmp(hModule,param, IDS_OPTION_TR)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszRepeat,**pArgv); 
    }

	else if(IDSwcsicmp(hModule,param, IDS_OPTION_J)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		prgwszDllName[dwDllIndex]=**pArgv;

		//mark its corresponding parameter as NULL	
		dwParamIndex=dwDllIndex;
		prgwszDllParam[dwParamIndex]=NULL;

		dwDllIndex++;

		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_JP)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		//make sure there is only one or less parameter per dll
		if(dwParamIndex+1!=dwDllIndex)
			return FALSE;

		prgwszDllParam[dwParamIndex]=**pArgv;

		dwParamIndex++;

		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_TS)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;
		
		return SetParam(&pwszResponseFile, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_TQ)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszRequestFile, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_INDEX)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&pwszSignerIndex, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_TEST)==0) {
		
		UndocumentedUsage();
		return FALSE;
	}


	return FALSE;
}


//--------------------------------------------------------------------------------
//
// wmain
//
//--------------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv)
{
    HRESULT		hr = E_FAIL;
	int			idsAction=IDS_ACTION_SIGNCODE;
	
	BYTE		*pbStampResponse=NULL;
	DWORD		cbStampResponse=0;
	BYTE		*pbStampRequest=NULL;
	DWORD		cbStampRequest=0;
	HANDLE		hFile=NULL;
	DWORD		dwWriteBytes=0;


    WCHAR		*pwChar;
	WCHAR		wszSwitch1[OPTION_SWITCH_SIZE];
	WCHAR		wszSwitch2[OPTION_SWITCH_SIZE];

	CRYPT_ATTRIBUTES	AuthAttr;
	CRYPT_ATTRIBUTES	UnauthAttr;
	PCRYPT_ATTRIBUTES	*ppAuthAttr=NULL;
	PCRYPT_ATTRIBUTES	*ppUnauthAttr=NULL;
	DWORD				dwIndex=0;
	DWORD				dwMilliSeconds=0;

	SIGNER_SUBJECT_INFO		subjectInfo;
	SIGNER_FILE_INFO		fileInfo;
	SIGNER_SIGNATURE_INFO	signatureInfo;
	SIGNER_ATTR_AUTHCODE	attrAuthcode;
	SIGNER_PROVIDER_INFO	providerInfo;
	SIGNER_CERT_STORE_INFO	certStoreInfo;
	SIGNER_CERT				signerCert;
	HCERTSTORE				hCertStore=NULL;

   CRYPTUI_WIZ_DIGITAL_SIGN_INFO    DigitalSignInfo;

    //call the UI version of the signcode
    if(1==argc)
    {

       //memset
       memset(&DigitalSignInfo, 0, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
       DigitalSignInfo.dwSize=sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);

         //call the signing wizard, which provides
         //the confirmation result.
         if(CryptUIWizDigitalSign(0,
                                NULL,
                                NULL,
                                &DigitalSignInfo,
                                NULL))
            return 0;
         else
            return -1;
    }


	//get the module handle
	if(!InitModule())
		return -1;

	//load the strings necessary for parsing the parameters
	if( !LoadStringU(hModule, IDS_SWITCH1,	wszSwitch1, OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2,	OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_CAPITION, wszCaption, WSTR_LENGTH_MAX)
	  ||!LoadStringU(hModule, IDS_PLUS,     wszPlus,    WSTR_LENGTH_MAX)
	  ||!LoadStringU(hModule, IDS_MY,		wszMyStore, STORE_DEFAULT_NAME_MAX)
	  )
		return -1;

	//load wszNULL
	LoadStringU(hModule, IDS_NULL,     wszNULL,    WSTR_LENGTH_MAX);

    if ( argc <= 1 )
	{
        Usage ();
		return -1;
	}

	//allocate memory for prgwszDllName and prgwszDllParam
	prgwszDllName=(LPWSTR *)ToolUtlAlloc(sizeof(LPWSTR)*argc);
	prgwszDllParam=(LPWSTR *)ToolUtlAlloc(sizeof(LPWSTR)*argc);
	dwDllIndex=0;
	dwParamIndex=0;

	if(!prgwszDllName || !prgwszDllParam)
	{
		hr=E_OUTOFMEMORY;
		goto CLEANUP;
	}

	//memset
	memset(prgwszDllName, 0, sizeof(LPWSTR)*argc);
	memset(prgwszDllParam, 0, sizeof(LPWSTR)*argc);
	memset(&AuthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
	memset(&UnauthAttr, 0, sizeof(CRYPT_ATTRIBUTES));


	//parse the parameters
    while (--argc) 
	{
        pwChar = *++wargv;
        if (*pwChar == *wszSwitch1 || *pwChar == *wszSwitch2) 
		{
			//parse the options
			if(!ParseSwitch (&argc, &wargv))
			{
				if(FALSE==fUndocumented)
					Usage();

				return -1;
			}
        } 
		else
		{
			//parse the file name
			if(!SetParam(&pwszFile, pwChar))
			{
				Usage();
				hr=E_FAIL;
				goto CLEANUP;
			}
		}
    }



	//Determine the parameter sets passed in by the user
	if(!CheckParameter())
	{
		Usage();
		hr=E_INVALIDARG;
		goto CLEANUP;
	}

	//memory allocation	for the dlls
	if(dwDllIndex)
	{
		ppAuthAttr=(PCRYPT_ATTRIBUTES *)ToolUtlAlloc(sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
  		ppUnauthAttr=(PCRYPT_ATTRIBUTES *)ToolUtlAlloc(sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);

		if(!ppAuthAttr || !ppUnauthAttr)
		{
			hr=E_OUTOFMEMORY;
			goto CLEANUP;
		}

		memset(ppAuthAttr, 0,sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
		memset(ppUnauthAttr, 0,sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
	}


	//init the dll parameters, call the GetAttr entry points of the dlls
	if(dwDllIndex)
	{
		if(S_OK!=(hr=InitDllParameter(&AuthAttr, &UnauthAttr,
			ppAuthAttr, ppUnauthAttr)))
			goto CLEANUP;
	}

	//Perform the requested action one at a time
	if(dwAction & ACTION_SIGN)
	{	
		idsAction=IDS_ACTION_SIGN;

		//set up the parameters for signing
		if(S_OK != (hr=SetUpParameter(&subjectInfo, &fileInfo, &signatureInfo, 
						&attrAuthcode, &providerInfo,
						&certStoreInfo, &signerCert,&AuthAttr,
						&UnauthAttr, &hCertStore)))
			goto CLEANUP;


		hr=SignerSign(&subjectInfo,
					  &signerCert,
					  &signatureInfo,
					  fStoreTechnology ? NULL : &providerInfo,
					  NULL,
					  NULL,
					  NULL);

		if (hr != S_OK)
		{
			idsAction=IDS_ACTION_SIGN;
		    goto CLEANUP;
		}

#if (0) //DSIE: Bug 236022
		//warn the user that the file is not timeStamped
		if (!(dwAction & ACTION_STAMP) && !(dwAction & ACTION_RESPONSE) && !(fTesting))
			IDSwprintf(hModule,IDS_WARNING);
#endif
		//free the certificate context
		if(certStoreInfo.pSigningCert)
			CertFreeCertificateContext(certStoreInfo.pSigningCert);

		//close the cert store which includes the signing certificate
		if(hCertStore)
			CertCloseStore(hCertStore, 0);

	}

	if(dwAction & ACTION_STAMP)
	{
		//timestamp the code
		dwMilliSeconds=dwWait*1000;

		//set up subject information
		if((dwAction & ACTION_SIGN) ==0)
		{
			if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
				goto CLEANUP;
		}


		//perform the # of trials
		for(dwIndex=0; dwIndex<dwRepeat; dwIndex++)
		{

			hr=SignerTimeStamp(&subjectInfo,pwszHttpTime,NULL,NULL);

			if(hr==S_OK)
				break;

			//wait per timestamp request
			if(dwWait!=0)
				Sleep(dwMilliSeconds);
		}

		if (hr != S_OK)
		{
			idsAction=IDS_ACTION_TIMESTAMP;
			goto CLEANUP;
		}

	}

	if(dwAction & ACTION_RESPONSE)
	{

		hr=RetrieveBLOBFromFile(pwszResponseFile,&cbStampResponse,
			&pbStampResponse);

		if (hr != S_OK)
		{
			idsAction=IDS_ACTION_RESPONSE;
			goto CLEANUP;
		}

		//set up subject information
		if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
				goto CLEANUP;

		hr=SignerAddTimeStampResponse(&subjectInfo,
						pbStampResponse,
						cbStampResponse,
						NULL);

		if (hr != S_OK)
		{
			idsAction=IDS_ACTION_RESPONSE;
			goto CLEANUP;
		}
	}

	if(dwAction & ACTION_REQUEST)
	{	
		cbStampRequest=0;

		//set up subject information
		if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
				goto CLEANUP;


		hr=SignerCreateTimeStampRequest(
			&subjectInfo,
			NULL,
			NULL,
			NULL,
			&cbStampRequest);

		if (hr != S_OK)
		{
			idsAction=IDS_ACTION_REQUEST;
			goto CLEANUP;
		}

		pbStampRequest=(BYTE *)ToolUtlAlloc(cbStampRequest);

		if(!pbStampRequest)
		{
			hr=E_OUTOFMEMORY;
			idsAction=IDS_ACTION_REQUEST;
			goto CLEANUP;
		}

		hr=SignerCreateTimeStampRequest(
			&subjectInfo,
			NULL,
			NULL,
			pbStampRequest,
			&cbStampRequest);

		if ( hr != S_OK)
		{
			idsAction=IDS_ACTION_REQUEST;
			goto CLEANUP;
		}

		//put the stamp request into a file
	    if((hFile = CreateFileU(pwszRequestFile,                 
	                            GENERIC_WRITE,                     
	                            0,                                 
	                            NULL,                              
	                            OPEN_ALWAYS,                       
	                            FILE_ATTRIBUTE_NORMAL,             
	                            NULL)) == INVALID_HANDLE_VALUE)    
		{
			hr=SignError();
			idsAction=IDS_ACTION_REQUEST;
			goto CLEANUP;
		}
		

	                                                                    
	    if(WriteFile(hFile,                                    
	                 pbStampRequest,                          
	                 cbStampRequest,                          
	                 &dwWriteBytes,                                    
	                 NULL) == FALSE ||                            
	             dwWriteBytes != cbStampRequest)                         
		{
			hr=SignError();             
			idsAction=IDS_ACTION_REQUEST;
			goto CLEANUP; 
		}

	}



CLEANUP:

    if (fTesting)
    {
        if (hr == (HRESULT)dwExpectedError)
            IDSwprintf(hModule,IDS_TEST_SUCCEEDED, hr);
        else
			IDSwprintf(hModule,IDS_TEST_FAILED, dwExpectedError, hr);
    }
	else
	{
		if(hr==S_OK)
		{
			IDSwprintf(hModule,IDS_SUCCEEDED);
			
			//we need to tell user the returned index of signature/timestamp
			if(pwszSignerIndex)
				IDSwprintf(hModule, IDS_SIGNER_INDEX, *(subjectInfo.pdwIndex));
		}
		else
		{
			//first try to print out dedebug info
			if(!PrintBasedOnHResult(hr))
			{

 				//print out addtional info for timestamping
				if(idsAction==IDS_ACTION_TIMESTAMP)
				{
					/*if(dwIndex!=1)
					IDSwprintf(hModule,IDS_TIMESTAMP_TIMES_DELAY, dwIndex+1,dwWait); */

					//file needs to be signed in order to timestamp it
					if((dwAction & ACTION_SIGN) ==0)
						//file may needs to be resigned 
						IDSwprintf(hModule,IDS_RESIGN);
				}
			}

			//then print out general information
			IDS_IDS_DW_DWwprintf(hModule,IDS_ERROR, idsAction, hr, hr);

		}
	}

	if(hFile)
		CloseHandle(hFile);

	//release the authenticated attributes
	ReleaseDllParameter(ppAuthAttr, ppUnauthAttr);

	//release prgwszDllName
	if(prgwszDllName)
		ToolUtlFree(prgwszDllName);

	//release prgwszDllParam
	if(prgwszDllParam)
		ToolUtlFree(prgwszDllParam);

	//release pAuthAttr
	if(AuthAttr.rgAttr)
		ToolUtlFree(AuthAttr.rgAttr);

	if(UnauthAttr.rgAttr)
		ToolUtlFree(UnauthAttr.rgAttr);

	//free ppAuthAttr and ppUnauthAttr
	if(ppAuthAttr)
		ToolUtlFree(ppAuthAttr);
	
	if(ppUnauthAttr)
		ToolUtlFree(ppUnauthAttr);

	
	if(pbStampResponse)
		UnmapViewOfFile(pbStampResponse);

	if(pbStampRequest)
		ToolUtlFree(pbStampRequest);


    if(g_pbHash)
		ToolUtlFree(g_pbHash);


	if(hr==S_OK)
		return 0;
	else
		return -1;


}

//-----------------------------------------------------------------------
//
// Get the hash from a cert file
//
//--------------------------------------------------------------------------
HRESULT	GetCertHashFromFile(LPWSTR	pwszCertFile, 
							BYTE	**ppHash, 
							DWORD	*pcbHash,
							BOOL	*pfMore)
{
	HRESULT			hr;
	HCERTSTORE		hCertStore=NULL;
	PCCERT_CONTEXT	pSigningCert=NULL;
	PCCERT_CONTEXT	pPreCert=NULL;
	PCCERT_CONTEXT	pDupCert=NULL;
	DWORD			dwCount=0;

	if(!ppHash || !pcbHash || !pfMore)
		return E_INVALIDARG;

	//init
	*pcbHash=0;
	*ppHash=NULL;
	*pfMore=FALSE;
	
	//open a cert store
	hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
						dwStoreEncodingType,
						NULL,
						0,
						pwszCertFile);

	if(hCertStore==NULL)
	{
		hr=SignError();
		goto CLEANUP;
	}

	while(pDupCert=CertEnumCertificatesInStore(hCertStore,  
						 				pPreCert))
	{
		dwCount++;

		if(dwCount > 1)
		{
			CertFreeCertificateContext(pDupCert);
			pDupCert=NULL;
			CertFreeCertificateContext(pSigningCert);
			pSigningCert=NULL;

			*pfMore=TRUE;
			goto CLEANUP;
		}

		pPreCert=pDupCert;

		pSigningCert=CertDuplicateCertificateContext(pDupCert);

	}

	if(pSigningCert==NULL)
	{
		hr=CRYPT_E_NO_DECRYPT_CERT;
		goto CLEANUP;
	}

	//get the hash
	if(!CertGetCertificateContextProperty(pSigningCert,
						CERT_SHA1_HASH_PROP_ID,
						NULL,
						pcbHash))
	{
		hr=SignError();
		goto CLEANUP;
	}

	*ppHash=(BYTE *)ToolUtlAlloc(*pcbHash);
	if(!(*ppHash))
	{
		hr=E_OUTOFMEMORY;
		goto CLEANUP;
	}

	if(!CertGetCertificateContextProperty(pSigningCert,
						CERT_SHA1_HASH_PROP_ID,
						*ppHash,
						pcbHash))
	{
		hr=SignError();
		goto CLEANUP;
	}

	hr=S_OK;

CLEANUP:

	if(pSigningCert)
		CertFreeCertificateContext(pSigningCert);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);

	if(hr!=S_OK)
	{
		if(*ppHash)
		{
		  ToolUtlFree(*ppHash);
		  *ppHash=NULL;
		}

	}

	return hr;
}



//-----------------------------------------------------------------------
//
// Get the signing certificate
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT	GetSigningCert(HCERTSTORE *phCertStore, BOOL *pfMore)
{
	PCCERT_CONTEXT	pSigningCert=NULL;
	PCCERT_CONTEXT	pPreCert=NULL;	
	PCCERT_CONTEXT	pDupCert=NULL;
	BYTE			*pHash=NULL;
	DWORD			cbHash;
	HCERTSTORE		hCertStore=NULL;
	CRYPT_HASH_BLOB	HashBlob;
	DWORD			dwCount=0;

	//init the output 
	if(!phCertStore || !pfMore)
		return NULL;

	*phCertStore=NULL;
	*pfMore=FALSE;

	//open a cert store
	hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						dwStoreEncodingType,
						NULL,
						dwStoreFlag |CERT_STORE_READONLY_FLAG,
						pwszStoreName);

	if(!hCertStore)
		return NULL;


	//get the hash of the certificate.  Find the cert based on
	//pwszCertFile
	if(pwszCertFile)
	{
		if(S_OK != GetCertHashFromFile(pwszCertFile, &pHash, &cbHash, pfMore))
			goto CLEANUP;
		
		HashBlob.cbData=cbHash;
		HashBlob.pbData=pHash;

		pSigningCert=CertFindCertificateInStore(hCertStore,
							dwCertEncodingType,
							0,
							CERT_FIND_SHA1_HASH,
							&HashBlob,
							NULL);
	}
	else
	{
		//find the certificate with the common name
		if(pwszCommonName)
		{
			while(pDupCert=CertFindCertificateInStore(hCertStore,  
						 		dwCertEncodingType,              
						 		0,                               
						 		CERT_FIND_SUBJECT_STR_W,             
						 		pwszCommonName,                       
						 		pPreCert))
			{
				dwCount++;

				if(dwCount > 1)
				{
					CertFreeCertificateContext(pDupCert);
					pDupCert=NULL;
					CertFreeCertificateContext(pSigningCert);
					pSigningCert=NULL;

					*pfMore=TRUE;
					goto CLEANUP;
				}

				pPreCert=pDupCert;

				pSigningCert=CertDuplicateCertificateContext(pDupCert);

			}
			   
		}
        else
        {
            //find the certificate based on the hash
			if(g_pbHash)
			{
			
		        HashBlob.cbData=g_cbHash;
		        HashBlob.pbData=g_pbHash;

		        pSigningCert=CertFindCertificateInStore(hCertStore,
							        dwCertEncodingType,
							        0,
							        CERT_FIND_SHA1_HASH,
							        &HashBlob,
							        NULL);
            }
		    else
		    {
			    //no searching criteria, find the only cert in the store
			    while(pDupCert=CertEnumCertificatesInStore(hCertStore,  
						 				    pPreCert))
			    {
				    dwCount++;

				    if(dwCount > 1)
				    {
					    CertFreeCertificateContext(pDupCert);
					    pDupCert=NULL;
					    CertFreeCertificateContext(pSigningCert);
					    pSigningCert=NULL;

					    *pfMore=TRUE;
					    goto CLEANUP;
				    }

				    pPreCert=pDupCert;

				    pSigningCert=CertDuplicateCertificateContext(pDupCert);

			    }
			       
		    }
        }
	}
CLEANUP:

	if(pHash)
		ToolUtlFree(pHash);

	if(pSigningCert)
	{
	   *phCertStore=hCertStore;
	}
	else
	{
		//free the hCertStore
		CertCloseStore(hCertStore, 0);
	}

	return pSigningCert;

}

//-----------------------------------------------------------------------
//
// Set up the subject info
//
//--------------------------------------------------------------------------
HRESULT SetUpSubjectInfo(SIGNER_SUBJECT_INFO		*pSubjectInfo,
						 SIGNER_FILE_INFO			*pFileInfo)
{
	if(!pSubjectInfo || !pFileInfo)
		return E_INVALIDARG;

	//init
	memset(pSubjectInfo, 0, sizeof(SIGNER_SUBJECT_INFO));
	memset(pFileInfo, 0, sizeof(SIGNER_FILE_INFO));

	//init cbSize
	pSubjectInfo->cbSize=sizeof(SIGNER_SUBJECT_INFO);
	pFileInfo->cbSize=sizeof(SIGNER_FILE_INFO);

	//init pSubjectInfo	
	pSubjectInfo->pdwIndex=&dwSignerIndex;
	pSubjectInfo->dwSubjectChoice=SIGNER_SUBJECT_FILE;
	pSubjectInfo->pSignerFileInfo=pFileInfo;
	pFileInfo->pwszFileName=pwszFile;

	return S_OK;
}


//-----------------------------------------------------------------------
//
// Set up the signing parameters
//
//--------------------------------------------------------------------------
HRESULT	SetUpParameter(SIGNER_SUBJECT_INFO		*pSubjectInfo,
					   SIGNER_FILE_INFO			*pFileInfo,
					   SIGNER_SIGNATURE_INFO	*pSignatureInfo,
						SIGNER_ATTR_AUTHCODE	*pAttrAuthcode,
						SIGNER_PROVIDER_INFO	*pProviderInfo,
						SIGNER_CERT_STORE_INFO	*pCertStoreInfo,
						SIGNER_CERT				*pSignerCert,
						CRYPT_ATTRIBUTES		*pAuthenticated,
						CRYPT_ATTRIBUTES		*pUnauthenticated,
						HCERTSTORE				*phCertStore
)
{
	HRESULT				hr;
	PCCERT_CONTEXT		pCertContext=NULL;
	BOOL				fMore=FALSE; 


	if(S_OK!=(hr=SetUpSubjectInfo(pSubjectInfo, pFileInfo)))
		return hr;
		

	if(!pSignatureInfo || !pAttrAuthcode || !pProviderInfo ||
		!pCertStoreInfo || !pSignerCert)
		return E_INVALIDARG;

	//init
	memset(pSignatureInfo, 0, sizeof(SIGNER_SIGNATURE_INFO));
	memset(pAttrAuthcode, 0, sizeof(SIGNER_ATTR_AUTHCODE));
	memset(pProviderInfo, 0, sizeof(SIGNER_PROVIDER_INFO));
	memset(pCertStoreInfo, 0, sizeof(SIGNER_CERT_STORE_INFO));
	memset(pSignerCert, 0, sizeof(SIGNER_CERT));


	//init cbSize
	pSignatureInfo->cbSize=sizeof(SIGNER_SIGNATURE_INFO);
	pAttrAuthcode->cbSize=sizeof(SIGNER_ATTR_AUTHCODE);
	pProviderInfo->cbSize=sizeof(SIGNER_PROVIDER_INFO);
	pCertStoreInfo->cbSize=sizeof(SIGNER_CERT_STORE_INFO);
	pSignerCert->cbSize=sizeof(SIGNER_CERT);


	//init pAttrAuthcode
	pAttrAuthcode->fCommercial=fCommercial;
	pAttrAuthcode->fIndividual=fIndividual;
	pAttrAuthcode->pwszName=pwszOpusName;
	pAttrAuthcode->pwszInfo=pwszOpusInfo;

	//init pSignatureInfo
	pSignatureInfo->algidHash=dwAlgorithmOid;
	pSignatureInfo->dwAttrChoice=SIGNER_AUTHCODE_ATTR;
	pSignatureInfo->pAttrAuthcode=pAttrAuthcode;
	pSignatureInfo->psAuthenticated=pAuthenticated;
	pSignatureInfo->psUnauthenticated=pUnauthenticated;

	//init pProviderInfo only if we are using non-cerStore tech
	if(fStoreTechnology!=TRUE)
	{
		pProviderInfo->pwszProviderName=pwszCapiProvider;
		pProviderInfo->dwProviderType=dwProviderType;
		pProviderInfo->dwKeySpec=dwKeySpec;
		if(pwszPvkFile)
		{
			pProviderInfo->dwPvkChoice=PVK_TYPE_FILE_NAME;
			pProviderInfo->pwszPvkFileName=pwszPvkFile;
		}
		else
		{
			pProviderInfo->dwPvkChoice=PVK_TYPE_KEYCONTAINER;
			pProviderInfo->pwszKeyContainer=pwszKeyContainer;
		}
	}

	//init pSignerCert
	if(fStoreTechnology)
	{
		//get the signing cert context
		pCertContext=GetSigningCert(phCertStore,&fMore );
		if(!pCertContext)
		{
			if(fMore==FALSE)
				return CRYPT_E_NO_DECRYPT_CERT;
			else
				return CRYPT_E_DELETED_PREV;
		}

		pSignerCert->dwCertChoice=SIGNER_CERT_STORE;
		pSignerCert->pCertStoreInfo=pCertStoreInfo;
		//init pCertStoreInfo
		pCertStoreInfo->pSigningCert=pCertContext;
		pCertStoreInfo->dwCertPolicy=dwStorePolicy;


	}
	else
	{
	    pSignerCert->dwCertChoice=SIGNER_CERT_SPC_FILE;
		pSignerCert->pwszSpcFile=pwszSpcFile;
	}

	return S_OK;

}



//-----------------------------------------------------------------------
//
//get the attributes from the dlls
//
//--------------------------------------------------------------------------
HRESULT	InitDllParameter(PCRYPT_ATTRIBUTES pAuthAttr,
						 PCRYPT_ATTRIBUTES pUnauthAttr,
						 PCRYPT_ATTRIBUTES *ppAuthAttr, 
						 PCRYPT_ATTRIBUTES *ppUnauthAttr)
{
	DWORD				dwIndex=0;
	DWORD				dwIndex2=0;
	DWORD				dwAttrIndex=0;
	HRESULT				hr=E_FAIL;
	HINSTANCE			hAuthInst=NULL;
	LPSTR				pszName=NULL;
	FARPROC				pProc=NULL;
	PCRYPT_ATTRIBUTES	pDllAuthAttr=NULL;
	PCRYPT_ATTRIBUTES	pDllUnauthAttr=NULL;
	DWORD				dwAuthAttrSum=0;
	DWORD				dwUnauthAttrSum=0;

	if(dwDllIndex==0)
		return S_OK;


	if(!ppAuthAttr || !ppUnauthAttr ||!pAuthAttr || !pUnauthAttr)
		return E_INVALIDARG;


	//process each dll
	for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
	{
		//get the char version of the dll name
		if((prgwszDllName[dwIndex] == NULL) || 
           (S_OK!=(hr=WSZtoSZ(prgwszDllName[dwIndex], &pszName))))
			goto CLEANUP;

		//load the libriary
		hAuthInst=LoadLibrary(pszName);

		if(!hAuthInst)
		{	
			hr=SignError();
			goto CLEANUP;
		}

		//init
		if(!(pProc=GetProcAddress(hAuthInst, "InitAttr")))
		{
			hr=SignError();
			goto CLEANUP;
		}

		if(S_OK!=(hr=((pInitAttr)pProc)(prgwszDllParam[dwIndex])))
			goto CLEANUP;

		//get the attributes for either GetAttr or GetAttrEx
		if(!(pProc=GetProcAddress(hAuthInst, "GetAttrEx")))
		{
		    if(!(pProc=GetProcAddress(hAuthInst, "GetAttr")))
		    {
			    hr=SignError();
			    goto CLEANUP;
            }

            if(S_OK!=(hr=((pGetAttr)pProc)(&pDllAuthAttr, &pDllUnauthAttr)))
			    goto CLEANUP;

		}
        else
        {
		    if(S_OK!=(hr=((pGetAttrEx)pProc)(0,
                                             pwszFile,
                                             prgwszDllParam[dwIndex],   
                                             &pDllAuthAttr, 
                                             &pDllUnauthAttr)))
			    goto CLEANUP;
        }


		//make sure valid return
		if(!pDllAuthAttr || !pDllUnauthAttr)
		{
			hr=E_UNEXPECTED;
			goto CLEANUP;
		}
		
		//add the sum pf authenticated
		if(pDllAuthAttr->cAttr)
			dwAuthAttrSum+=pDllAuthAttr->cAttr;

		ppAuthAttr[dwIndex]=pDllAuthAttr;


		//add the sume of unauthenticated
		if(pDllUnauthAttr->cAttr)
			dwUnauthAttrSum+=pDllUnauthAttr->cAttr;

		ppUnauthAttr[dwIndex]=pDllUnauthAttr;

		//exit
		if(!(pProc=GetProcAddress(hAuthInst, "ExitAttr")))
		{
			hr=SignError();
			goto CLEANUP;
		}

		if(S_OK!=(hr=((pExitAttr)pProc)()))
			goto CLEANUP;

		//free library
		FreeLibrary(hAuthInst);
		hAuthInst=NULL;

		//free memory
		ToolUtlFree(pszName);
		pszName=NULL;
	}


	//build up authenticated attribute
	if(dwAuthAttrSum)
	{
		pAuthAttr->cAttr=dwAuthAttrSum;
		pAuthAttr->rgAttr=(PCRYPT_ATTRIBUTE)ToolUtlAlloc(sizeof(CRYPT_ATTRIBUTE)*
									pAuthAttr->cAttr);

		if(!(pAuthAttr->rgAttr) )
		{
			hr=E_OUTOFMEMORY;
			goto CLEANUP;
		}

		//build up autheticated attributes
		dwAttrIndex=0;
		for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
		{
			for(dwIndex2=0;dwIndex2<ppAuthAttr[dwIndex]->cAttr; dwIndex2++)	
			{
				pAuthAttr->rgAttr[dwAttrIndex]=	ppAuthAttr[dwIndex]->rgAttr[dwIndex2];
				dwAttrIndex++;
			}

		}

		//make sure dwAttrIndex==pAuthAttr->cAttr
		if(dwAttrIndex!=pAuthAttr->cAttr)
		{
			hr=E_UNEXPECTED;
			goto CLEANUP;
		}
	}
	else
	{
		memset(pAuthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
	}


	//build up unauthenticated attribute
	if(dwUnauthAttrSum)
	{

		pUnauthAttr->cAttr=dwUnauthAttrSum;

		pUnauthAttr->rgAttr=(PCRYPT_ATTRIBUTE)ToolUtlAlloc(sizeof(CRYPT_ATTRIBUTE)*
									pUnauthAttr->cAttr);

		if(!(pUnauthAttr->rgAttr))
		{
			hr=E_OUTOFMEMORY;
			goto CLEANUP;
		}



		//build up the unauthenticated attributes
		dwAttrIndex=0;
		for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
		{
			for(dwIndex2=0; dwIndex2<ppUnauthAttr[dwIndex]->cAttr; dwIndex2++)
			{
				pUnauthAttr->rgAttr[dwAttrIndex]=ppUnauthAttr[dwIndex]->rgAttr[dwIndex2];
				dwAttrIndex++;
			}
		}

		if(dwAttrIndex != pUnauthAttr->cAttr)
		{
			hr=E_UNEXPECTED;
			goto CLEANUP;
		}
	}
	else
	{
		memset(pUnauthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
	}

	hr=S_OK;

CLEANUP:

	if(hAuthInst)
		FreeLibrary(hAuthInst);

	if(pszName)
		ToolUtlFree(pszName);

	//free up memory when hr!=S_OK
	if(hr!=S_OK)
	{
		if(pAuthAttr->rgAttr)
		{
			ToolUtlFree(pAuthAttr->rgAttr);
			pAuthAttr->rgAttr=NULL;
		}

		if(pUnauthAttr->rgAttr)
		{
			ToolUtlFree(pUnauthAttr->rgAttr);
			pUnauthAttr->rgAttr=NULL;

		}
	}

	return hr;

}

//-----------------------------------------------------------------------
//
// Release the attributes by calling the dlls's ReleaseAttr entry point
//
//--------------------------------------------------------------------------
void	ReleaseDllParameter(PCRYPT_ATTRIBUTES * ppAuthAttr, 
							PCRYPT_ATTRIBUTES * ppUnauthAttr)
{
	DWORD				dwIndex=0;
	HRESULT				hr=E_FAIL;
	HINSTANCE			hAuthInst=NULL;
	LPSTR				pszName=NULL;
	FARPROC				pProc=NULL;

	if((dwDllIndex==0) ||(!ppAuthAttr) || (!ppUnauthAttr))
		return;


	//process each dll
	for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
	{
		//free library
		if(hAuthInst)
		{
			FreeLibrary(hAuthInst);
			hAuthInst=NULL;
		}

 		//free memory
		if(pszName)
		{
			ToolUtlFree(pszName);
			pszName=NULL;
		}


		//get the char version of the dll name
		if((prgwszDllName[dwIndex]==NULL) || 
           (S_OK!=(hr=WSZtoSZ(prgwszDllName[dwIndex], &pszName))))
			continue;

		//load the libriary
		hAuthInst=LoadLibrary(pszName);

		if(!hAuthInst)
			continue;

		//init
		if(!(pProc=GetProcAddress(hAuthInst, "InitAttr")))
			continue;

		if(S_OK!=(hr=((pInitAttr)pProc)(prgwszDllParam[dwIndex])))
			continue;

		//release the attributes
		if(!(pProc=GetProcAddress(hAuthInst, "ReleaseAttr")))
			continue;

		if(S_OK!=(hr=((pReleaseAttr)pProc)(
			ppAuthAttr[dwIndex], ppUnauthAttr[dwIndex])))
			continue;

		//exit
		if(!(pProc=GetProcAddress(hAuthInst, "ExitAttr")))
			continue;

		((pExitAttr)pProc)();
	}


	//cleanup
	if(hAuthInst)
	{
		FreeLibrary(hAuthInst);
		hAuthInst=NULL;
	}

 	//free memory
	if(pszName)
	{
		ToolUtlFree(pszName);
		pszName=NULL;
	}

	 return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\toolutl\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//  Contents:   Resource header for toolutl
//
//  History:    17-Jun-97    xiaohs    Created
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\toolutl\toolutl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       toolutl
//
//  Contents:   Tools Unitilies Header
//
//----------------------------------------------------------------------------

#ifndef TOOLUTL_H
#define TOOLUTL_H

#ifdef __cplusplus
extern "C" {
#endif
 
//--------------------------------------------------------------------------
//
//  Memory routines
//--------------------------------------------------------------------------
void *ToolUtlAlloc(IN size_t cbBytes, HMODULE hModule=NULL, int idsString=0);

void ToolUtlFree(IN void *pv);


//--------------------------------------------------------------------------
//
//  string routines
//--------------------------------------------------------------------------
int IDSwcsnicmp(HMODULE hModule, WCHAR *pwsz, int idsString, DWORD dwCount);

int IDSwcsicmp(HMODULE hModule, WCHAR *pwsz, int idsString);


HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz);

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(HMODULE hModule, int idsString, ...);

void IDS_IDSwprintf(HMODULE hModule, int idString, int idStringTwo);

void IDS_IDS_DW_DWwprintf(HMODULE hModule, int idString, int idStringTwo, DWORD dwOne, DWORD dwTwo);

void IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3);

void IDS_DW_IDS_IDSwprintf(HMODULE hModule, int ids1,DWORD dw,int ids2,int ids3);

void IDS_IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3, int ids4);



//--------------------------------------------------------------------------------
//
// file routines
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb);

HRESULT OpenAndWriteToFile(LPCWSTR  pwszFileName,PBYTE   pb, DWORD   cb);

void	GetFileName(LPWSTR	pwszPath, LPWSTR  *ppwszName);


//--------------------------------------------------------------------------------
//
// compose and decompose the certificate property
//
//---------------------------------------------------------------------------------
HRESULT	ComposePvkString(	CRYPT_KEY_PROV_INFO *pKeyProvInfo,
							LPWSTR				*ppwszPvkString,
							DWORD				*pcwchar);


#ifdef __cplusplus
}
#endif

#endif  // TOOLUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\toolutl\toolutl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       toolutl.cpp
//
//  Contents:   Utilities for the tools
//
//  History:    17-Jun-97    xiaohs    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include <stdarg.h>
#include "unicode.h"
#include "toolutl.h"

#define MAX_STRING_RSC_SIZE 512

WCHAR	wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	dwBufferSize=sizeof(wszBuffer)/sizeof(wszBuffer[0]); 

WCHAR	wszBuffer2[MAX_STRING_RSC_SIZE];
WCHAR	wszBuffer3[MAX_STRING_RSC_SIZE];


//+-------------------------------------------------------------------------
//  Allocation and free routines
//--------------------------------------------------------------------------
void *ToolUtlAlloc(IN size_t cbBytes, HMODULE hModule, int idsString)
{
	void *pv=NULL;

	pv=malloc(cbBytes);

	//out put error message
	if((pv==NULL) && (hModule!=NULL) && (idsString!=0))
	{
	   IDSwprintf(hModule, idsString);
	}

	return pv;
}


void ToolUtlFree(IN void *pv)
{
	if(pv)
		free(pv);
}


//--------------------------------------------------------------------------
//
//  Output routines
//--------------------------------------------------------------------------
//---------------------------------------------------------------------------
// The private version of _wcsnicmp
//----------------------------------------------------------------------------
int IDSwcsnicmp(HMODULE hModule, WCHAR *pwsz, int idsString, DWORD dwCount)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsnicmp(pwsz, wszBuffer,dwCount);
}


//---------------------------------------------------------------------------
// The private version of _wcsicmp
//----------------------------------------------------------------------------
int IDSwcsicmp(HMODULE hModule, WCHAR *pwsz, int idsString)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsicmp(pwsz, wszBuffer);
}

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(HMODULE hModule, int idsString, ...)
{
	va_list	vaPointer;

	va_start(vaPointer, idsString);

	//load the string
	LoadStringU(hModule, idsString, wszBuffer, dwBufferSize);

	vwprintf(wszBuffer,vaPointer);

	return;
}	




void IDS_IDSwprintf(HMODULE hModule, int idString, int idStringTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	//print buffer2 on top of buffer1
	wprintf(wszBuffer,wszBuffer2);

	return;
}


void IDS_IDS_DW_DWwprintf(HMODULE hModule, int idString, int idStringTwo, DWORD dwOne, DWORD dwTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	//print buffer2 on top of buffer1
	wprintf(wszBuffer,wszBuffer2,dwOne, dwTwo);

	return;
}


void IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,wszBuffer2,wszBuffer3);

	return;
}

void IDS_DW_IDS_IDSwprintf(HMODULE hModule, int ids1,DWORD dw,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,dw,wszBuffer2,wszBuffer3,dw);

	return;
}

void IDS_IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3, int ids4)
{
	
   WCHAR	wszBuffer4[MAX_STRING_RSC_SIZE];

	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize);
	
	//load the string four
   	LoadStringU(hModule, ids4, wszBuffer4, dwBufferSize); 


	wprintf(wszBuffer,wszBuffer2,wszBuffer3,wszBuffer4);

	return;
}

///////////////////////////////////////////////////////////////
//
//	Convert WSZ to SZ
//
//
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz)
{

	DWORD	cbSize=0;

	assert(psz);
	*psz=NULL;

	if(!wsz)
		return S_OK;

	cbSize=WideCharToMultiByte(0,0,wsz,-1,
			NULL,0,0,0);

	if(cbSize==0)
	   	return HRESULT_FROM_WIN32(GetLastError());


	*psz=(LPSTR)ToolUtlAlloc(cbSize);

	if(*psz==NULL)
		return E_OUTOFMEMORY;

	if(WideCharToMultiByte(0,0,wsz,-1,
			*psz,cbSize,0,0))
	{
		return S_OK;
	}
	else
	{
		 ToolUtlFree(*psz);
		 return HRESULT_FROM_WIN32(GetLastError());
	}
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{


	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;  
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
        
    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}
    
    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,             
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
 
    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,  
		FILE_MAP_READ,     
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;
}


//+-------------------------------------------------------------------------
//  Write a blob to a file
//--------------------------------------------------------------------------
HRESULT OpenAndWriteToFile(
    LPCWSTR  pwszFileName,
    PBYTE   pb,
    DWORD   cb
    )
{
    HRESULT		hr=E_FAIL;
    HANDLE		hFile=NULL;
	DWORD		dwBytesWritten=0;

	if(!pwszFileName || !pb || (cb==0))
	   return E_INVALIDARG;

    hFile = CreateFileU(pwszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile	  

    if (INVALID_HANDLE_VALUE == hFile)
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
	}  
	else 
	{

        if (!WriteFile(
                hFile,
                pb,
                cb,
                &dwBytesWritten,
                NULL            // lpOverlapped
                ))
		{
			hr=HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{

			if(dwBytesWritten != cb)
				hr=E_FAIL;
			else
				hr=S_OK;
		}

        CloseHandle(hFile);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//	Get an absolutely name from the path, such as "c:\public\mydoc\doc.doc." 
//	This function will return doc.doc 
//
//----------------------------------------------------------------------------
void	GetFileName(LPWSTR	pwszPath, LPWSTR  *ppwszName)
{
	DWORD	dwLength=0;

	assert(pwszPath);
	assert(ppwszName);

	(*ppwszName)=pwszPath;

	if(0==(dwLength=wcslen(pwszPath)))
		return;

	(*ppwszName)=pwszPath+dwLength-1;

	for(; dwLength>0; dwLength--)
	{
		if((**ppwszName)=='\\')
			break;

		(*ppwszName)--;
	}

	(*ppwszName)++;

}


//----------------------------------------------------------------------------
//
//	Compose the private key file structure:
//	"pvkFileName"\0"keysepc"\0"provtype"\0"provname"\0\0
//
//----------------------------------------------------------------------------
HRESULT	ComposePvkString(	CRYPT_KEY_PROV_INFO *pKeyProvInfo,
							LPWSTR				*ppwszPvkString,
							DWORD				*pcwchar)
{

		HRESULT		hr=S_OK;
		DWORD		cwchar=0;
		LPWSTR		pwszAddr=0;
		WCHAR		wszKeySpec[12];
		WCHAR		wszProvType[12];

		assert(pKeyProvInfo);
		assert(ppwszPvkString);
		assert(pcwchar);

		//convert dwKeySpec and dwProvType to wchar
		swprintf(wszKeySpec, L"%lu", pKeyProvInfo->dwKeySpec);
		swprintf(wszProvType, L"%lu", pKeyProvInfo->dwProvType);

		//count of the number of characters we need
		cwchar=(pKeyProvInfo->pwszProvName) ? 
			(wcslen(pKeyProvInfo->pwszProvName)+1) : 1;

		//add the ContainerName + two DWORDs
		cwchar += wcslen(pKeyProvInfo->pwszContainerName)+1+
				  wcslen(wszKeySpec)+1+wcslen(wszProvType)+1+1;

		*ppwszPvkString=(LPWSTR)ToolUtlAlloc(cwchar * sizeof(WCHAR));
		if(!(*ppwszPvkString))
			return E_OUTOFMEMORY;

		//copy the private key file name .  
		wcscpy((*ppwszPvkString), pKeyProvInfo->pwszContainerName);

		pwszAddr=(*ppwszPvkString)+wcslen(*ppwszPvkString)+1;

		//copy the key spec
		wcscpy(pwszAddr, wszKeySpec);
		pwszAddr=pwszAddr+wcslen(wszKeySpec)+1;

		//copy the provider type
		wcscpy(pwszAddr, wszProvType);
		pwszAddr=pwszAddr+wcslen(wszProvType)+1;

		//copy the provider name
		if(pKeyProvInfo->pwszProvName)
		{
			wcscpy(pwszAddr, pKeyProvInfo->pwszProvName);
			pwszAddr=pwszAddr+wcslen(pKeyProvInfo->pwszProvName)+1;
		}
		else
		{
			*pwszAddr=L'\0';
			pwszAddr++;
		}

		//NULL terminate the string
		*pwszAddr=L'\0';

		*pcwchar=cwchar;

		return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\ccert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       CCert.cpp
//
//  Contents:   Microsoft Internet Security Certificate Class
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "signer.h"

extern "C"
{
extern BOOL WINAPI GetCryptProvFromCert(HWND hwnd, PCCERT_CONTEXT pCert, HCRYPTPROV	*phCryptProv,
                                        DWORD *pdwKeySpec, BOOL	*pfDidCryptAcquire,	
                                        LPWSTR *ppwszTmpContainer, LPWSTR *ppwszProviderName,
                                        DWORD *pdwProviderType);

extern void WINAPI FreeCryptProvFromCert(BOOL fAcquired, HCRYPTPROV hProv, LPWSTR pwszCapiProvider,
                                        DWORD dwProviderType, LPWSTR pwszTmpContainer);
};


#include    "ccert.hxx"

CCert_::CCert_(PCCERT_CONTEXT pCertContext)
{
    m_pCertContext          = CertDuplicateCertificateContext(pCertContext);
    
    m_pCCert_Issuer         = NULL;
    m_pwszPublisherName     = NULL;
    m_pwszAgencyName        = NULL;
    m_pwszProvider          = NULL;
    m_pwszKeyContainer      = NULL;
    m_dwProviderType        = 0;
    m_chStores              = 0;
    m_fTriedPrivateKey      = FALSE;
    memset(m_pahStores, 0x00, sizeof(HCERTSTORE) * CCERT_MAXSTORES);
}

CCert_::~CCert_(void)
{
    CertFreeCertificateContext(m_pCertContext);

    DELETE_OBJECT(m_pCCert_Issuer);
    DELETE_OBJECT(m_pwszPublisherName);
    DELETE_OBJECT(m_pwszAgencyName);
    DELETE_OBJECT(m_pwszProvider);
    DELETE_OBJECT(m_pwszKeyContainer);

    for (int i = 0; i < (int)m_chStores; i++)
    {
        if (m_pahStores[i])
        {
            CertCloseStore(m_pahStores[i], 0);
        }
    }
}

WCHAR *CCert_::PublisherName(void)
{
    if (m_pwszPublisherName)
    {
        return(m_pwszPublisherName);
    }

    if (!(this->ExtractCommonNameExt(&m_pwszPublisherName)))
    {
        if (!(this->ExtractCommonNameAttr(&m_pwszPublisherName)))
        {
            m_pwszPublisherName = this->GetRDNAttr(szOID_COMMON_NAME,
                                                   &m_pCertContext->pCertInfo->Subject);
        }
    }

    return(m_pwszPublisherName);
}

WCHAR *CCert_::AgencyName(void)
{
    if (m_pwszAgencyName)
    {
        return(m_pwszAgencyName);
    }

    if (!(m_pCertContext))
    {
        return(NULL);
    }

    m_pwszAgencyName = this->GetRDNAttr(szOID_ORGANIZATIONAL_UNIT_NAME,
                                        &m_pCertContext->pCertInfo->Subject);
    if (!(m_pwszAgencyName))
    {
        m_pwszAgencyName = this->GetRDNAttr(szOID_ORGANIZATION_NAME,
                                            &m_pCertContext->pCertInfo->Subject);

        if (!(m_pwszAgencyName))
        {
            m_pwszAgencyName = this->GetRDNAttr(szOID_COMMON_NAME,
                                                &m_pCertContext->pCertInfo->Subject);
        }
    }

    return(m_pwszAgencyName);
}

WCHAR *CCert_::ProviderName(void)
{
    if (m_pwszProvider)
    {
        return(m_pwszProvider);
    }

    if (!(m_pCertContext))
    {
        return(NULL);
    }

    this->FindPrivateKey();

    return(m_pwszProvider);
}

DWORD CCert_::ProviderType(void)
{
    if (m_pwszProvider)
    {
        return(m_dwProviderType);
    }

    this->FindPrivateKey();

    return(m_dwProviderType);
}

WCHAR *CCert_::PrivateKeyContainer(void)
{
    if (m_pwszKeyContainer)
    {
        return(m_pwszKeyContainer);
    }

    this->FindPrivateKey();

    return(m_pwszKeyContainer);
}

BOOL CCert_::BuildChain(FILETIME *psftVerifyAsOf)
{
    FILETIME        sft;

    if (!(m_pCertContext))
    {
        return(FALSE);
    }

    if (m_pCCert_Issuer)
    {
        return(TRUE);
    }

    if (!(psftVerifyAsOf))
    {
        GetSystemTimeAsFileTime(&sft);

        psftVerifyAsOf = &sft;
    }

    this->OpenStores();

    return(this->BuildChainPrivate(m_chStores, m_pahStores, psftVerifyAsOf));
}

//////////////////////////////////////////////////////////////////////////
////
////    protected
////
BOOL CCert_::ExtractCommonNameExt(WCHAR **ppwszRet)
{
    *ppwszRet = NULL;

    if (!(m_pCertContext))
    {
        return(FALSE);
    }

    PCERT_NAME_VALUE    pNameValue;
    PCERT_EXTENSION     pExt;

    pNameValue  = NULL;

    pExt = CertFindExtension(SPC_COMMON_NAME_OBJID,
                             m_pCertContext->pCertInfo->cExtension,
                             m_pCertContext->pCertInfo->rgExtension);
    if (pExt) 
    {
        DWORD                   cbInfo;
        PCERT_RDN_VALUE_BLOB    pValue;
        DWORD                   dwValueType;
        DWORD                   cwsz;

        cbInfo  = 0;

        CryptDecodeObject(  X509_ASN_ENCODING,
                            X509_NAME_VALUE,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            0,
                            NULL,
                            &cbInfo);

        if (cbInfo == 0)
        {
            return(FALSE);
        }

        if (!(pNameValue = (PCERT_NAME_VALUE)new BYTE[cbInfo]))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                X509_NAME_VALUE,
                                pExt->Value.pbData,
                                pExt->Value.cbData,
                                0,
                                pNameValue,
                                &cbInfo)))
        {
            delete pNameValue;
            return(FALSE);
        }

        dwValueType = pNameValue->dwValueType;
        pValue      = &pNameValue->Value;

        cwsz = CertRDNValueToStrW(dwValueType, pValue, NULL, 0);

        if (cwsz > 1) 
        {
            if (!(*ppwszRet = new WCHAR[cwsz]))
            {
                delete pNameValue;

                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            CertRDNValueToStrW(dwValueType, pValue, *ppwszRet, cwsz);

            delete pNameValue;
            return(TRUE);
        }
    }

    DELETE_OBJECT(pNameValue);

    return(FALSE);
}

BOOL CCert_::ExtractCommonNameAttr(WCHAR **ppwszRet)
{
    *ppwszRet = GetRDNAttr(szOID_COMMON_NAME, &m_pCertContext->pCertInfo->Subject);

    if (*ppwszRet)
    {
        return(TRUE);
    }

    return(FALSE);
}

WCHAR *CCert_::GetRDNAttr(char *pszObjId, PCERT_NAME_BLOB pNameBlob)
{
    LPWSTR          pwsz;
    PCERT_NAME_INFO pNameInfo;
    PCERT_RDN_ATTR  pRDNAttr;
    DWORD           cbInfo;

    pwsz        = NULL;
    pNameInfo   = NULL;

    cbInfo      = 0;

    CryptDecodeObject(  X509_ASN_ENCODING,
                        X509_NAME,
                        pNameBlob->pbData,
                        pNameBlob->cbData,
                        0,
                        NULL,
                        &cbInfo);
    
    if (cbInfo == 0) 
    {
        return(NULL);
    }

    if (!(pNameInfo = (PCERT_NAME_INFO)new BYTE[cbInfo]))
    {
        return(NULL);
    }

    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                            X509_NAME,
                            pNameBlob->pbData,
                            pNameBlob->cbData,
                            0,
                            pNameInfo,
                            &cbInfo)))
    {
        delete pNameInfo;
        return(NULL);
    }

    pRDNAttr = CertFindRDNAttr(pszObjId, pNameInfo);

    if (pRDNAttr) 
    {
        PCERT_RDN_VALUE_BLOB    pValue = &pRDNAttr->Value;
        DWORD                   dwValueType = pRDNAttr->dwValueType;
        DWORD                   cwsz;

        pValue      = &pRDNAttr->Value;
        dwValueType = pRDNAttr->dwValueType;

        cwsz = CertRDNValueToStrW(dwValueType,
                                  pValue,
                                  NULL,
                                  0);

        if (cwsz > 1) 
        {
            if (!(pwsz = new WCHAR[cwsz]))
            {
                delete pNameInfo;

                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(NULL);
            }

            CertRDNValueToStrW(dwValueType, pValue, pwsz, cwsz);
        }
    }

    DELETE_OBJECT(pNameInfo);

    return(pwsz);
}


//////////////////////////////////////////////////////////////////////////
////
////    private
////
BOOL CCert_::BuildChainPrivate(DWORD chStores, HCERTSTORE *pahStores, FILETIME *psftVerifyAsOf)
{
    DWORD           dwError;
    PCCERT_CONTEXT  pIssuerCertContext;

    DELETE_OBJECT(m_pCCert_Issuer);

    if (TrustIsCertificateSelfSigned(m_pCertContext,
                                     m_pCertContext->dwCertEncodingType, 
                                     0))
    {
        return(TRUE);
    }

    pIssuerCertContext = TrustFindIssuerCertificate(m_pCertContext, 
                                                    m_pCertContext->dwCertEncodingType,
                                                    chStores,
                                                    pahStores, 
                                                    psftVerifyAsOf,
                                                    &m_dwConfidence,
                                                    &dwError,
                                                    0);

    if (!(pIssuerCertContext))
    {
        SetLastError(dwError);
        return(FALSE);
    }

    m_pCCert_Issuer = new CCert_(pIssuerCertContext);

    CertFreeCertificateContext(pIssuerCertContext);

    if (!(m_pCCert_Issuer))
    {
        return(FALSE);
    }

    return(m_pCCert_Issuer->BuildChainPrivate(chStores, pahStores, psftVerifyAsOf));
}

    //
    // warning: if you add a store, make sure to add one to the CCERT_MAXSTORES in ccert.hxx!!!
    //
void CCert_::OpenStores(void)
{
    HCERTSTORE  hStore;

    m_chStores = 0;

    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_CURRENT_USER |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "ROOT"))
    {
        m_pahStores[m_chStores] = hStore;
        m_chStores++;
    }
    else
    {
        return;  // if we can't find the root, FAIL!
    }

    //
    //  open the Trust List store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_CURRENT_USER | 
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "TRUST"))
    {
        m_pahStores[m_chStores] = hStore;
        m_chStores++;
    }

    //
    //  CA Store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_CURRENT_USER | 
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "CA"))
    {
        m_pahStores[m_chStores] = hStore;
        m_chStores++;
    }
    
    //
    //  MY Store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_CURRENT_USER | 
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "MY"))
    {
        m_pahStores[m_chStores] = hStore;
        m_chStores++;
    }
    
    //
    //  SPC Store (historic reasons!)
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE | 
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "SPC"))
    {
        m_pahStores[m_chStores] = hStore;
        m_chStores++;
    }
}

BOOL CCert_::FindPrivateKey(void)
{
    if ((m_pwszProvider) || (m_pwszKeyContainer))
    {
        return(TRUE);
    }

    if (m_fTriedPrivateKey)
    {
        return(FALSE);
    }

    m_fTriedPrivateKey = TRUE;

    DELETE_OBJECT(m_pwszProvider);
    DELETE_OBJECT(m_pwszKeyContainer);

    //
    //  try mssign32.dll first
    //
    HCRYPTPROV      signer_hProv;
    WCHAR           *signer_pwszTmpContainer;
    WCHAR           *signer_pwszProviderName;
    DWORD           signer_dwKeySpec;
    DWORD           signer_dwProviderType;
    BOOL            signer_fDidCryptAcquire;

    signer_hProv            = NULL;
    signer_pwszTmpContainer = NULL;
    signer_pwszProviderName = NULL;

    if (GetCryptProvFromCert(NULL, 
                             m_pCertContext, 
                             &signer_hProv, 
                             &signer_dwKeySpec,
                             &signer_fDidCryptAcquire,
                             &signer_pwszTmpContainer,
                             &signer_pwszProviderName,
                             &signer_dwProviderType))
    {
        if (signer_pwszProviderName)
        {
            if (!(m_pwszProvider = new WCHAR[wcslen(signer_pwszProviderName) + 1]))
            {
                return(FALSE);
            }

            wcscpy(m_pwszProvider, signer_pwszProviderName);

            if (signer_pwszTmpContainer)
            {
                if (!(m_pwszKeyContainer  = new WCHAR[wcslen(signer_pwszTmpContainer) + 1]))
                {
                    return(FALSE);
                }

                wcscpy(m_pwszKeyContainer, signer_pwszTmpContainer);
            }

            m_dwProviderType    = signer_dwProviderType;


            FreeCryptProvFromCert(signer_fDidCryptAcquire,
                                  signer_hProv,
                                  signer_pwszProviderName,
                                  signer_dwProviderType,
                                  signer_pwszTmpContainer);
    
            return(TRUE);
        }
     
        FreeCryptProvFromCert(signer_fDidCryptAcquire,
                              signer_hProv,
                              signer_pwszProviderName,
                              signer_dwProviderType,
                              signer_pwszTmpContainer);
    }

    DWORD       dwIndexProv;
    DWORD       dwIndexContainer;
    DWORD       dwProvType;
    DWORD       cbSize;
    WCHAR       wszProv[MAX_PATH + 1];
    WCHAR       *pwszContainer;

    HCRYPTPROV  hProvEnum;

    pwszContainer   = NULL;
    dwIndexProv     = 0;

    for EVER
    {
        cbSize = MAX_PATH;

        if (!(CryptEnumProvidersU(dwIndexProv, NULL, 0, &dwProvType, &wszProv[0], &cbSize)))
        {
            break;
        }

        wszProv[cbSize] = NULL;

        dwIndexContainer    = 0;
        hProvEnum           = NULL;

        for EVER
        {
            if (!(this->EnumContainer(&hProvEnum, dwIndexContainer, dwProvType, &wszProv[0], &pwszContainer)))
            {
                break;
            }
            
            if (this->CheckContainerForKey(&wszProv[0], dwProvType, pwszContainer))
            {
                m_dwProviderType    = dwProvType;
                m_pwszKeyContainer  = pwszContainer;

                if (m_pwszProvider = new WCHAR[wcslen(&wszProv[0]) + 1])
                {
                    wcscpy(m_pwszProvider, &wszProv[0]);
                }

                CryptReleaseContext(hProvEnum, 0);
                return(TRUE);
            }

            DELETE_OBJECT(pwszContainer);

            dwIndexContainer++;
        }

        if (hProvEnum)
        {
            CryptReleaseContext(hProvEnum, 0);
        }

        dwIndexProv++;  // for our enum at the top!
    }

    return(FALSE);
}

BOOL CCert_::EnumContainer(HCRYPTPROV *phProv, DWORD dwIndex, DWORD dwProvType, WCHAR *pwszProv, WCHAR **ppwszContainer)
{
    DWORD       i;
    DWORD       cbSize;
    char        *psz;

    *ppwszContainer = NULL;

    if (!(*phProv))
    {
        if (!(CryptAcquireContextU(phProv, NULL, pwszProv, dwProvType, CRYPT_VERIFYCONTEXT)))
        {
            return(FALSE);
        }
    }
    cbSize = 0;
    CryptGetProvParam(*phProv, PP_ENUMCONTAINERS, NULL, &cbSize, CRYPT_FIRST);

    if (cbSize > 0)
    {
        if (!(psz = new char[cbSize]))
        {
            return(FALSE);
        }

        memset(psz, 0x00, cbSize);

        CryptGetProvParam(*phProv, PP_ENUMCONTAINERS, (BYTE *)psz, &cbSize, CRYPT_FIRST);

        for (i = 1; i <= dwIndex; i++)
        {
            if (!(CryptGetProvParam(*phProv, PP_ENUMCONTAINERS, (BYTE *)psz, &cbSize, 0)))
            {
                delete psz;
                return(FALSE);
            }
        }

        if (!(*ppwszContainer = new WCHAR[strlen(psz) + 1]))
        {
            delete psz;

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
        
        MultiByteToWideChar(0, 0, psz, -1, *ppwszContainer, (strlen(psz) + 1) * sizeof(WCHAR));

        delete psz;
        return(TRUE);

    }

    return(FALSE);
}

BOOL CCert_::CheckContainerForKey(WCHAR *pwszProv, DWORD dwProvType, WCHAR *pwszContainer)
{
    HCRYPTPROV              hProv;
    DWORD                   cbSize;
    PCERT_PUBLIC_KEY_INFO   pContInfo;

    if (CryptAcquireContextU(&hProv, pwszContainer, pwszProv, dwProvType, 0))
    {
        if (!(CryptExportPublicKeyInfo(hProv, AT_SIGNATURE, X509_ASN_ENCODING, NULL, &cbSize)))
        {
            CryptReleaseContext(hProv, 0);
            return(FALSE);
        }

        if (!(pContInfo = (PCERT_PUBLIC_KEY_INFO)new BYTE[cbSize]))
        {
            CryptReleaseContext(hProv, 0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if (!(CryptExportPublicKeyInfo(hProv, AT_SIGNATURE, X509_ASN_ENCODING, pContInfo, &cbSize)))
        {
            delete pContInfo;

            CryptReleaseContext(hProv, 0);

            return(FALSE);
        }

        CryptReleaseContext(hProv, 0);

        if (CertComparePublicKeyInfo(X509_ASN_ENCODING, 
                                        &m_pCertContext->pCertInfo->SubjectPublicKeyInfo,
                                        pContInfo))
        {
            delete pContInfo;

            return(TRUE);
        }

        delete pContInfo;
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\cjetblue.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cJetBlue.cpp
//
//  Contents:   Microsoft Internet Security Common
//
//  History:    23-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cjetblue.hxx"

#define     CHK_FUNC(fp, nm)  this->CheckOrLoadFunc((void **)&fp, nm)

cJetBlue_::cJetBlue_(void)
{
    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    hJet = LoadLibrary("ESE.DLL");
                                    
    fp_JetInit                      = NULL;
    fp_JetTerm                      = NULL;
    fp_JetSetSystemParameter        = NULL;
    fp_JetBeginSession              = NULL;
    fp_JetCreateDatabase            = NULL;
    fp_JetAttachDatabase            = NULL;
    fp_JetDetachDatabase            = NULL;
    fp_JetCreateTable               = NULL;
    fp_JetCreateTableColumnIndex    = NULL;
    fp_JetCloseDatabase             = NULL;
    fp_JetCloseTable                = NULL;
    fp_JetOpenDatabase              = NULL;
    fp_JetOpenTable                 = NULL;
    fp_JetBeginTransaction          = NULL;
    fp_JetCommitTransaction         = NULL;
    fp_JetRetrieveColumns           = NULL;
    fp_JetSetColumns                = NULL;
    fp_JetPrepareUpdate             = NULL;
    fp_JetSetCurrentIndex2          = NULL;
    fp_JetMove                      = NULL;
    fp_JetMakeKey                   = NULL;
    fp_JetSeek                      = NULL;

}

cJetBlue_::~cJetBlue_(void)
{
    if (hJet)
    {
        FreeLibrary(hJet);
    }
}

BOOL cJetBlue_::CheckOrLoadFunc(void **fp, char *pszfunc)
{
    if (*fp)
    {
        return(TRUE);
    }

    if (this->hJet)
    {
        *fp = GetProcAddress(this->hJet, pszfunc);
    }

    return((*fp) ? TRUE : FALSE);
}

JET_ERR cJetBlue_::JetInit(JET_INSTANCE *pinstance)    
{ 
    if (!(CHK_FUNC(fp_JetInit, "JetInit")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetInit)(pinstance)); 
}

JET_ERR cJetBlue_::JetTerm(JET_INSTANCE instance)      
{ 
    if (!(CHK_FUNC(fp_JetTerm, "JetTerm")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetTerm)(instance)); 
}

JET_ERR cJetBlue_::JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, 
                            unsigned long paramid, unsigned long lParam, 
                            const char *sz)
{ 
    if (!(CHK_FUNC(fp_JetSetSystemParameter, "JetSetSystemParameter")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetSetSystemParameter)(pinstance, sesid, paramid, lParam, sz)); 
}

JET_ERR cJetBlue_::JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
                        const char *szUserName, const char *szPassword)
{ 
    if (!(CHK_FUNC(fp_JetBeginSession, "JetBeginSession")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetBeginSession)(instance, psesid, szUserName, szPassword)); 
}

JET_ERR cJetBlue_::JetCreateDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect,
                        JET_DBID *pdbid, JET_GRBIT grbit)
{ 
    if (!(CHK_FUNC(fp_JetCreateDatabase, "JetCreateDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetCreateDatabase)(sesid, szFilename, szConnect, pdbid, grbit)); 
}

JET_ERR cJetBlue_::JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit)
{ 
    if (!(CHK_FUNC(fp_JetAttachDatabase, "JetAttachDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetAttachDatabase)(sesid, szFilename, grbit)); 
}

JET_ERR cJetBlue_::JetDetachDatabase(JET_SESID sesid, const char *szFilename)
{ 
    if (!(CHK_FUNC(fp_JetDetachDatabase, "JetDetachDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetDetachDatabase)(sesid, szFilename)); 
}

JET_ERR cJetBlue_::JetCreateTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, 
                                  unsigned long lPages, unsigned long lDensity, JET_TABLEID *ptableid)
{ 
    if (!(CHK_FUNC(fp_JetCreateTable, "JetCreateTable")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetCreateTable)(sesid, dbid, szTableName, lPages, lDensity, ptableid)); 
}

JET_ERR cJetBlue_::JetCreateTableColumnIndex(JET_SESID sesid, JET_DBID dbid,
                                JET_TABLECREATE *ptablecreate)
                { return((*fp_JetCreateTableColumnIndex)(sesid, dbid, ptablecreate)); }
JET_ERR cJetBlue_::JetCloseDatabase(JET_SESID sesid, JET_DBID dbid, JET_GRBIT grbit)
                { return((*fp_JetCloseDatabase)(sesid, dbid, grbit)); }
JET_ERR cJetBlue_::JetCloseTable(JET_SESID sesid, JET_TABLEID tableid)
                { return((*fp_JetCloseTable)(sesid, tableid)); }
JET_ERR cJetBlue_::JetOpenDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, 
                         JET_DBID *pdbid, JET_GRBIT grbit)
                { return((*fp_JetOpenDatabase)(sesid, szFilename, szConnect, 
                                                pdbid, grbit)); }
JET_ERR cJetBlue_::JetOpenTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, 
                   const void *pvParameters, unsigned long cbParameters, 
                   JET_GRBIT grbit, JET_TABLEID *ptableid)
                { return((*fp_JetOpenTable)(sesid, dbid, szTableName, pvParameters, 
                                            cbParameters, grbit, ptableid)); }
JET_ERR cJetBlue_::JetBeginTransaction(JET_SESID sesid)
                { return((*fp_JetBeginTransaction)(sesid)); }
JET_ERR cJetBlue_::JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit)
                { return((*fp_JetCommitTransaction)(sesid, grbit)); }
JET_ERR cJetBlue_::JetRetrieveColumns(JET_SESID sesid, JET_TABLEID tableid, 
                            JET_RETRIEVECOLUMN *pretrievecolumn, 
                            unsigned long cretrievecolumn)
                { return((*fp_JetRetrieveColumns)(sesid, tableid, pretrievecolumn, 
                                                  cretrievecolumn)); }
JET_ERR cJetBlue_::JetSetColumns(JET_SESID sesid, JET_TABLEID tableid, JET_SETCOLUMN *psetcolumn, 
                       unsigned long csetcolumn)
                { return((*fp_JetSetColumns)(sesid, tableid, psetcolumn, csetcolumn)); }
JET_ERR cJetBlue_::JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid, unsigned long prep)
                { return((*fp_JetPrepareUpdate)(sesid, tableid, prep)); }
JET_ERR cJetBlue_::JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,	const char *szIndexName, 
                             JET_GRBIT grbit)
                { return((*fp_JetSetCurrentIndex2)(sesid, tableid, szIndexName, grbit)); }
JET_ERR cJetBlue_::JetMove(JET_SESID sesid, JET_TABLEID tableid,	long cRow, JET_GRBIT grbit)
                { return((*fp_JetMove)(sesid, tableid, cRow, grbit)); }
JET_ERR cJetBlue_::JetMakeKey(JET_SESID sesid, JET_TABLEID tableid, const void *pvData, 
                    unsigned long cbData, JET_GRBIT grbit)
                { return((*fp_JetMakeKey)(sesid, tableid, pvData, cbData, grbit)); }
JET_ERR cJetBlue_::JetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
                        { return((*fp_JetSeek)(sesid, tableid, grbit)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\cbfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cBFile.cpp
//
//  Contents:   Microsoft Internet Security
//
//  History:    24-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "stack.hxx"
#include    "cbfile.hxx"

cBFile_::cBFile_(CRITICAL_SECTION *pCriticalSection, WCHAR *pwszBFilePath, WCHAR *pwszBFileBaseName,
                 DWORD cbKey, DWORD cbData, SHORT sVersion, BOOL *pfCreatedOK)
{
    SECURITY_ATTRIBUTES  sa;
    SECURITY_ATTRIBUTES* psa = NULL;
    SECURITY_DESCRIPTOR  sd;

    SID_IDENTIFIER_AUTHORITY    siaWorldSidAuthority    = SECURITY_WORLD_SID_AUTHORITY;
    PSID                        psidEveryone            = NULL;
    DWORD                       dwAclSize;
    PACL                        pDacl                   = NULL;
    DWORD dwErr = 0;

    pCritical       = pCriticalSection;
    fDirty          = FALSE;
    fReadOnly       = FALSE;
    hKFile          = INVALID_HANDLE_VALUE;
    hDFile          = INVALID_HANDLE_VALUE;
    pbKMap          = NULL;
    pbDMap          = NULL;
    cbDMap          = 0;
    hDMutex         = NULL;

    fUseRecNumAsKey = FALSE;

    *pfCreatedOK    = TRUE;  // will be set to FALSE in case of ANY failure

    pwszPath = NULL;
    pwszBaseName = NULL;

    __try {

    pwszPath        = (LPWSTR) new WCHAR[wcslen(pwszBFilePath) + 1];
    if (pwszPath == NULL)
    {
        goto MemoryError;
    }
    wcscpy(pwszPath, pwszBFilePath);

    pwszBaseName    = (LPWSTR) new WCHAR[wcslen(pwszBFileBaseName) + 1];
    if (pwszBaseName == NULL)
    {
        goto MemoryError;
    }
    wcscpy(pwszBaseName, pwszBFileBaseName);

    memset(&sHeader, 0x00, sizeof(BFILE_HEADER));
    memset(&sRecord, 0x00, sizeof(BFILE_RECORD));

    sHeader.sIntVersion = BFILE_VERSION_1;
    sHeader.sVersion    = (DWORD)sVersion;
    sHeader.cbKey       = cbKey;
    sHeader.cbData      = cbData;

    if ( FIsWinNT() == TRUE )
    {
        if (!AllocateAndInitializeSid(
                &siaWorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidEveryone))
        {
            goto ErrorReturn;
        }

        //
        // compute size of ACL
        //
        dwAclSize = 
            sizeof(ACL) +
            ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
            GetLengthSid(psidEveryone);

        //
        // allocate storage for Acl
        //
        if (NULL == (pDacl = (PACL) new BYTE[dwAclSize]))
        {
            goto MemoryError;
        }

        if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        {
            goto ErrorReturn;
        }

        if (!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                SYNCHRONIZE,// | MUTEX_MODIFY_STATE,
                psidEveryone))
        {
            goto ErrorReturn;
        }

        if ( InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ) == FALSE )
        {
            goto ErrorReturn;
        }

        if ( SetSecurityDescriptorDacl( &sd, TRUE, pDacl, FALSE ) == FALSE )
        {
            goto ErrorReturn;
        }

        sa.nLength = sizeof( SECURITY_ATTRIBUTES );
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = FALSE;

        psa = &sa;
    }

    hDMutex = CreateMutexU( psa, FALSE, pwszBFileBaseName );
    if ( hDMutex == NULL )
    {
        hDMutex = OpenMutexU( SYNCHRONIZE, FALSE, pwszBFileBaseName );
        if ( hDMutex == NULL )
        {
            dwErr = GetLastError();
            goto ErrorReturn;
        }
    }

    fInitialized    = TRUE;     // set it now becuase OpenFiles uses "Lock".

    if (!(this->OpenFiles()))
    {
        goto FileError;
    }

    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (pbKMap != NULL)
        {
            UnmapViewOfFile(pbKMap);
            pbKMap = NULL;
        }

        if (pbDMap != NULL)
        {
            UnmapViewOfFile(pbDMap);
            pbDMap = NULL;
        }

        if (hDFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hDFile);
            hDFile = INVALID_HANDLE_VALUE;
        }

        if (hKFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hKFile);
            hKFile = INVALID_HANDLE_VALUE;
        }

        if (hDMutex != NULL)
        {
            CloseHandle(hDMutex);
            hDMutex = NULL;
        }

        if (pwszPath != NULL)
        {
            delete[](pwszPath);
            pwszPath = NULL;
        }

        if (pwszBaseName != NULL)
        {
            delete[](pwszBaseName);
            pwszBaseName = NULL;
        }
        goto ErrorReturn;
    }

    sRecord.cbKey       = sHeader.cbKey;
    sRecord.cbData      = sHeader.cbData;

    if (!(sRecord.pvKey = (void *)new BYTE[cbKey + sizeof(DWORD)]) ||
        !(sRecord.pvData = (void *)new BYTE[cbData + sizeof(DWORD)]))
    {
        goto MemoryError;
    }

    sRecord.pvData = (BYTE *)sRecord.pvData + sizeof(DWORD);    // we use the first dword for rec # (see addrec)

    memset(sRecord.pvKey, 0x00, cbKey);
    memset(sRecord.pvData, 0x00, cbData);

CommonReturn:

    if (pDacl != NULL)
    {
        delete[] pDacl;
    }

    if (psidEveryone)
    {
        FreeSid(psidEveryone);
    }
    return;

ErrorReturn:
        fInitialized    = FALSE;
        *pfCreatedOK    = FALSE;
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, FileError,         ERROR_FILE_NOT_FOUND);
}

cBFile_::~cBFile_(void)
{
    if (fDirty)
    {
        this->Sort();
    }

    if (pbKMap != NULL)
    {
        UnmapViewOfFile(pbKMap);
    }

    if (pbDMap != NULL)
    {
        UnmapViewOfFile(pbDMap);
    }

    if (hDFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDFile);
    }

    if (hKFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hKFile);
    }

    if (hDMutex != NULL)
    {
        CloseHandle(hDMutex);
    }

    if (pwszPath != NULL)
    {
        delete[](pwszPath);
    }

    if (pwszBaseName != NULL)
    {
        delete[](pwszBaseName);
    }

    DELETE_OBJECT(sRecord.pvKey);

    if (sRecord.pvData)
    {
        sRecord.pvData = (BYTE *)sRecord.pvData - sizeof(DWORD);    // we bumped the pointer in the constructer, put it back..

        delete sRecord.pvData;
    }
}

BOOL cBFile_::Initialize(void)
{
    return(fInitialized);
}

DWORD cBFile_::GetNumKeys(void)
{
    DWORD   dwRet;

    dwRet = GetFileSize(this->hKFile, NULL);

    if (dwRet > 0)
    {
        dwRet /= BFILE_KEYSIZE;

        return(dwRet);
    }

    return(0);
}

void cBFile_::setKey(void *pvInKey)
{
    memcpy(sRecord.pvKey, pvInKey, sRecord.cbKey);
}

void cBFile_::setData(void *pvInData)
{
    memcpy(sRecord.pvData, pvInData, sRecord.cbData);
}

BOOL cBFile_::Find(void)
{
    DWORD   cbDOff;
    DWORD   dwLastGood;
    void    *pvKey;
    BOOL    fRet;

    pvKey = new BYTE[sRecord.cbKey];

    if (!(pvKey))
    {
        goto MemoryError;
    }

    memcpy(pvKey, sRecord.pvKey, sRecord.cbKey);

    if (this->BinaryFind(&cbDOff))
    {
        dwLastGood = this->dwFirstNextRecNum;

        while (this->GetPrev(dwLastGood))
        {
            if (memcmp(pvKey, sRecord.pvKey, sRecord.cbKey) != 0)
            {
                break;
            }

            dwLastGood = this->dwFirstNextRecNum;
        }

        if (dwLastGood > 0)
        {
            dwLastGood--;

            delete pvKey;

            return(this->GetNext(dwLastGood));
        }

        delete pvKey;

        __try {

        return(this->GetDataRecord(cbDOff));

        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            this->UnmapAll();
            SetLastError(GetExceptionCode());
        }

        return(FALSE);
    }

    fRet = FALSE;

    CommonReturn:
        if (pvKey)
        {
            delete pvKey;
        }

        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
}

BOOL cBFile_::GetFirst(void)
{
    BOOL    fRet;

    this->dwFirstNextRecNum = 0;

    if (!(this->pbKMap))
    {
        return(FALSE);
    }

    __try {

    if (!this->ReadHeader())
    {
        goto ErrorReturn;
    }

    DWORD       cbOff;

    memcpy(sRecord.pvKey, &this->pbKMap[0], sRecord.cbKey);
    memcpy(&cbOff, &this->pbKMap[sRecord.cbKey], sizeof(DWORD));

    if (!(this->GetDataRecord(cbOff)))
    {
        goto cBFileCorrupt;
    }

    fRet = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        this->UnmapAll();
        SetLastError(GetExceptionCode());
        goto cBFileCorrupt;
    }

    CommonReturn:
        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, cBFileCorrupt);
}

BOOL cBFile_::GetNext(DWORD dwCurRec)
{
    BOOL    fRet;

    if (!(this->pbKMap))
    {
        return(FALSE);
    }

    if (dwCurRec == 0xffffffff)
    {
        dwCurRec = this->dwFirstNextRecNum;
    }

    DWORD       cbOff;

    dwCurRec++;

    if (((dwCurRec + 1) * BFILE_KEYSIZE) > sHeader.cbSortedEOF)
    {
        goto cBFileNoNext;
    }

    __try {

    memcpy(sRecord.pvKey, &this->pbKMap[dwCurRec * BFILE_KEYSIZE], sRecord.cbKey);
    memcpy(&cbOff, &this->pbKMap[(dwCurRec * BFILE_KEYSIZE) + sRecord.cbKey], sizeof(DWORD));

    if (!(this->GetDataRecord(cbOff)))
    {
        goto cBFileCorrupt;
    }

    this->dwFirstNextRecNum = dwCurRec;

    fRet = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        this->UnmapAll();
        SetLastError(GetExceptionCode());
        goto cBFileCorrupt;
    }

    CommonReturn:
        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        this->dwFirstNextRecNum = 0;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, cBFileNoNext);
    TRACE_ERROR_EX(DBG_SS, cBFileCorrupt);
}

BOOL cBFile_::GetPrev(DWORD dwCurRec)
{
    BOOL    fRet;

    if (!(this->pbKMap) || (sHeader.cbSortedEOF == 0))
    {
        goto cBFileNoPrev;
    }

    if (dwCurRec == 0xffffffff)
    {
        dwCurRec = this->dwFirstNextRecNum;
    }

    DWORD       cb;
    DWORD       cbOff;

    if (dwCurRec < 1)
    {
        goto cBFileNoPrev;
    }

    dwCurRec--;

    if (((dwCurRec + 1) * BFILE_KEYSIZE) >= sHeader.cbSortedEOF)
    {
        goto cBFileNoPrev;
    }

    __try {

    memcpy(sRecord.pvKey, &this->pbKMap[dwCurRec * BFILE_KEYSIZE], sRecord.cbKey);
    memcpy(&cbOff, &this->pbKMap[(dwCurRec * BFILE_KEYSIZE) + sRecord.cbKey], sizeof(DWORD));

    if (!(this->GetDataRecord(cbOff)))
    {
        goto cBFileCorrupt;
    }

    this->dwFirstNextRecNum = dwCurRec;

    fRet = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        this->UnmapAll();
        SetLastError(GetExceptionCode());
        goto cBFileCorrupt;
    }

    CommonReturn:
        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        this->dwFirstNextRecNum = 0;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, cBFileNoPrev);
    TRACE_ERROR_EX(DBG_SS, cBFileCorrupt);
}

BOOL cBFile_::Update(void)
{
    DWORD   cbDOff;

    if ( fReadOnly == TRUE )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    if (this->BinaryFind(&cbDOff))
    {
        this->UpdateDataRecord(cbDOff);

        return(TRUE);
    }

    return(FALSE);
}

BOOL cBFile_::Add(void)
{
    if ( fReadOnly == TRUE )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    if (!this->AddDirtyKey())
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL cBFile_::Lock(void)
{
    WaitForSingleObject( this->hDMutex, INFINITE );
    return(TRUE);
}

BOOL cBFile_::Unlock(void)
{
    ReleaseMutex( this->hDMutex );
    return( TRUE );
}

void cBFile_::SpeedSort(void)
{
    Stack_      *pcStack;

    if ( fReadOnly == TRUE )
    {
        assert( FALSE && "A sort should not be forced in read-only mode." );
        return;
    }

    pcStack = NULL;

    if (!(this->pbKMap))
    {
        goto RemapError;
    }

    if (!(this->Lock()))
    {
        goto LockFileError;
    }

    //
    // load dirty in memory and sort it
    //
    DWORD       cbCurKey;
    DWORD       cbTotal;

    if (!(pcStack = new Stack_(pCritical)))
    {
        goto MemoryError;
    }

    cbTotal     = GetFileSize(this->hKFile, NULL);
    cbCurKey    = sHeader.cbSortedEOF;

    __try {

    while (cbCurKey < cbTotal)
    {
        pcStack->Add(BFILE_KEYSIZE, &this->pbKMap[cbCurKey]);

        cbCurKey += BFILE_KEYSIZE;
    }

    pcStack->Sort(0, sRecord.cbKey, STACK_SORTTYPE_BINARY);

    //
    //  shuffle into sorted
    //
    DWORD   dwIdx;
    DWORD   dwInsertion;
    DWORD   cbFreeSpace;
    BYTE    *pbKey;
    BYTE    *pbCurrentKey;
    BYTE    *pbStartFreeSpace;

    pbStartFreeSpace    = &this->pbKMap[sHeader.cbSortedEOF];
    cbFreeSpace         = pcStack->Count() * BFILE_KEYSIZE;

    dwIdx = (long)pcStack->Count() - 1;

    while (pbKey = (BYTE *)pcStack->Get(dwIdx))
    {
        //
        //  get the starting point of our "window"
        //
        dwInsertion = this->GetInsertionPoint(pbKey);

        //
        //  move the old data to the current free space "window"
        //
        memmove(&this->pbKMap[dwInsertion + cbFreeSpace], &this->pbKMap[dwInsertion],
                sHeader.cbSortedEOF - dwInsertion);

        //
        //  after this, the insersion point has free space the size of the "window" - key size
        //
        cbFreeSpace -= BFILE_KEYSIZE;

        //
        // add the new key to the end of the "free space" window.
        //
        memcpy(&this->pbKMap[dwInsertion + cbFreeSpace], pbKey, BFILE_KEYSIZE);

        //
        //  keep the end of the search up to date for these insertions....
        //
        sHeader.cbSortedEOF = dwInsertion;

        if (dwIdx == 0)
        {
            break;
        }

        dwIdx--;
    }

    sHeader.cbSortedEOF     = cbTotal;
    sHeader.fDirty          = FALSE;
    fDirty                  = FALSE;

    this->UpdateHeader();

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        this->UnmapAll();
        SetLastError( GetExceptionCode() );
        goto RemapError;
    }

    ErrorReturn:
        this->Unlock();
        DELETE_OBJECT(pcStack);
        return;

    TRACE_ERROR_EX(DBG_SS, LockFileError);
    TRACE_ERROR_EX(DBG_SS, RemapError);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
}

DWORD cBFile_::GetInsertionPoint(void *pvIn)
{
    DWORD   dwEnd;
    DWORD   dwMiddle;
    DWORD   dwStart;
    DWORD   dwHalf;
    DWORD   dwCur;
    DWORD   dwRet;
    BYTE    *pb;
    int     cmp;

    dwStart     = 0;
    dwEnd       = sHeader.cbSortedEOF / BFILE_KEYSIZE;
    dwMiddle    = dwEnd / 2L;
    dwHalf      = dwMiddle;
    dwCur       = 0;
    if (sHeader.cbSortedEOF >= BFILE_KEYSIZE)
    {
        dwRet   = sHeader.cbSortedEOF - BFILE_KEYSIZE;
    }
    else
    {
        dwRet   = 0;
    }

    for EVER
    {
        pb = this->pbKMap + (dwMiddle * BFILE_KEYSIZE);

        cmp = memcmp(pvIn, pb, sRecord.cbKey);

        if (cmp == 0)
        {
            dwRet = (DWORD)(pb - this->pbKMap);
            break;
        }

        if ( (dwMiddle == 0) ||
             (dwMiddle == (sHeader.cbSortedEOF / BFILE_KEYSIZE)) ||
             ((dwHalf == 0) && (dwMiddle == dwStart)) )
        {
            DWORD   dwFind;

            dwFind  = dwRet;
            cmp     = (-1);

            while ((cmp < 0) && ((dwFind + BFILE_KEYSIZE) <= sHeader.cbSortedEOF))
            {
                cmp = memcmp(pvIn, &this->pbKMap[dwFind], sRecord.cbKey);

                dwRet = dwFind;

                dwFind += BFILE_KEYSIZE;
            }

            break;
        }

        if (cmp < 0)
        {
            dwEnd   = dwMiddle;
            dwRet   = (dwMiddle * BFILE_KEYSIZE);
        }
        else
        {
            dwStart = dwMiddle;
        }

        dwHalf      = (dwEnd - dwStart) / 2L;
        dwMiddle    = dwStart + dwHalf;
    }

    return(dwRet);
}

void *cBFile_::GetDumpKey(DWORD dwIdx, void *pvRetKey, DWORD *pdwRecOffset)
{
    DWORD   dwOffset;

    dwOffset = dwIdx * BFILE_KEYSIZE;

    if (dwOffset >= GetFileSize(this->hKFile, NULL))
    {
        return(NULL);
    }

    __try {

    memcpy(pvRetKey, &this->pbKMap[dwOffset], sRecord.cbKey);

    memcpy(pdwRecOffset, &this->pbKMap[dwOffset + sRecord.cbKey], sizeof(DWORD));

    return(pvRetKey);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        this->UnmapAll();
        SetLastError(GetExceptionCode());
    }

    return(NULL);
}

BOOL cBFile_::GetHeader(BFILE_HEADER *psHeader)
{
    __try {

    if (!this->ReadHeader())
    {
        return(FALSE);
    }

    memcpy(psHeader, &sHeader, sizeof(BFILE_HEADER));

    return(TRUE);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        this->UnmapAll();
        SetLastError(GetExceptionCode());
    }

    return(FALSE);
}

void cBFile_::Sort(void)
{
    if ( fReadOnly == TRUE )
    {
        assert( FALSE && "A sort should not be forced in read-only mode." );
        return;
    }

    EnterCriticalSection(pCritical);

    if (!FIsWinNT())
    {
        //
        // The only reason this is here is to work around some underlying
        // bug in the OS.  If we just call RemapKey() and RemapData() then
        // we end up with some bogus state on the key and data files which will
        // ultimately result in a sharing violation when trying to open the files
        // at a later time.
        //
        if (this->pbKMap != NULL)
        {
            UnmapViewOfFile(this->pbKMap);
            this->pbKMap = NULL;
        }

        if (this->pbDMap != NULL)
        {
            UnmapViewOfFile(this->pbDMap);
            this->pbDMap = NULL;
        }

        if (hDFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hDFile);
            hDFile = INVALID_HANDLE_VALUE;
        }

        if (hKFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hKFile);
            hKFile = INVALID_HANDLE_VALUE;
        }  

        this->OpenFiles();
    }
    else
    {
        this->RemapKey();
        this->RemapData();
    }

#if 0
    if (sHeader.cbSortedEOF > 0)
    {
        this->SpeedSort();
        LeaveCriticalSection(pCritical);
        return;
    }
#endif

    BYTE        *pb;
    Stack_      *pcStack;

    pcStack = NULL;
    pb      = NULL;

    if (!(this->Lock()))
    {
        goto LockFileError;
    }

    DWORD       dwLen;
    DWORD       cbFile;
    DWORD       dwIdx;
    DWORD       i;
    BYTE        *pbStack;

    if (!(pcStack = new Stack_(pCritical)))
    {
        goto MemoryError;
    }

    dwLen = BFILE_KEYSIZE;

    if (!(pb = new BYTE[dwLen]))
    {
        goto MemoryError;
    }

    cbFile = GetFileSize(this->hKFile, NULL);

    __try {

    for (i = 0; i < cbFile; i += dwLen)
    {
        pcStack->Add(dwLen, &this->pbKMap[i]);
    }

    pcStack->Sort(0, sRecord.cbKey, STACK_SORTTYPE_BINARY);

    dwIdx   = 0;
    i       = 0;
    while (pbStack = (BYTE *)pcStack->Get(dwIdx))
    {
        if ((i + dwLen) > cbFile)
        {
            goto FileSizeError;
        }

        memcpy(&this->pbKMap[i], pbStack, dwLen);

        dwIdx++;
        i += dwLen;
    }


    sHeader.cbSortedEOF     = cbFile;
    sHeader.fDirty          = FALSE;
    fDirty                  = FALSE;

    this->UpdateHeader();

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        this->UnmapAll();
        SetLastError( GetExceptionCode() );
    }

    ErrorReturn:
        this->Unlock();

        DELETE_OBJECT(pcStack);
        DELETE_OBJECT(pb);

        LeaveCriticalSection(pCritical);
        return;

    TRACE_ERROR_EX(DBG_SS, FileSizeError);
    TRACE_ERROR_EX(DBG_SS, LockFileError);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
}

BOOL cBFile_::AddDirtyKey(void)
{
    DWORD   cbOff;
    DWORD   cb;

    if ( fReadOnly == TRUE )
    {
        assert( FALSE && "Add dirty key should not occur in read-only mode." );
        return(FALSE);
    }

    this->Lock();

    __try {

    if (!this->ReadHeader())
    {
        return(FALSE);
    }

    sHeader.dwLastRecNum++;
    sRecord.dwRecNum = sHeader.dwLastRecNum;

    if ((cbOff = this->AddDataRecord()) != 0xffffffff)
    {
        if (fUseRecNumAsKey)
        {
            memcpy(sRecord.pvKey, &sRecord.dwRecNum, sizeof(DWORD));
        }

        memcpy((BYTE *)sRecord.pvKey + sRecord.cbKey, &cbOff, sizeof(DWORD));   // speed...
        SetFilePointer(this->hKFile, 0, NULL, FILE_END);
        
        if (FIsWinNT())
        {
            WriteFile(this->hKFile, sRecord.pvKey, sRecord.cbKey + sizeof(DWORD), &cb, NULL);
            // WriteFile(this->hKFile, &cbOff, sizeof(DWORD), &cb, NULL);
        }
        else
        {
            if (this->pbKMap != NULL)
            {
                UnmapViewOfFile(this->pbKMap);
                this->pbKMap = NULL;
                WriteFile(this->hKFile, sRecord.pvKey, sRecord.cbKey + sizeof(DWORD), &cb, NULL);
                this->RemapKey();
            }
            else
            {
                WriteFile(this->hKFile, sRecord.pvKey, sRecord.cbKey + sizeof(DWORD), &cb, NULL);
            }
        }

        sHeader.fDirty          = TRUE;
        this->fDirty            = TRUE;

        this->UpdateHeader();
    }

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        this->UnmapAll();
        SetLastError( GetExceptionCode() );
    }

    this->Unlock();

    return(TRUE);
}

BOOL cBFile_::GetDataRecord(DWORD cbDataOffset)
{
    DWORD   cb;

    memset(sRecord.pvData, 0x00, sRecord.cbData);

    if (this->cbDMap < (cbDataOffset + sizeof(DWORD) + sRecord.cbData))
    {
        return(FALSE);
    }

    memcpy(&sRecord.dwRecNum, &this->pbDMap[cbDataOffset], sizeof(DWORD));
    memcpy(sRecord.pvData, &this->pbDMap[cbDataOffset + sizeof(DWORD)], sRecord.cbData);

    return(TRUE);
}

void cBFile_::UpdateDataRecord(DWORD cbDataOffset)
{
    DWORD   cb;

    if ( fReadOnly == TRUE )
    {
        assert( FALSE && "Update data record should not occur in read-only mode." );
        return;
    }

    this->Lock();

    if (this->cbDMap < (cbDataOffset + sizeof(DWORD) + sRecord.cbData))
    {
        this->Unlock();
        return;
    }

    __try {

    memcpy(&this->pbDMap[cbDataOffset + sizeof(DWORD)], sRecord.pvData, sRecord.cbData);

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        this->UnmapAll();
        SetLastError( GetExceptionCode() );
    }

    this->Unlock();
}

DWORD cBFile_::AddDataRecord(void)
{
    DWORD   cbRet;

    if ( fReadOnly == TRUE )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return( 0xFFFFFFFF );
    }

    //
    // no lock here because it is called from add key which
    // does a lock
    //

    if ((cbRet = SetFilePointer(this->hDFile, 0, NULL, FILE_END)) != 0xffffffff)
    {
        DWORD   cb;
        BYTE    *pv;

        pv = (BYTE *)sRecord.pvData - sizeof(DWORD);
        memcpy(pv, &sRecord.dwRecNum, sizeof(DWORD));

        if (FIsWinNT())
        {
            WriteFile(this->hDFile, pv, sizeof(DWORD) + sRecord.cbData, &cb, NULL);
            // WriteFile(this->hDFile, sRecord.pvData, sRecord.cbData, &cb, NULL);
        }
        else
        {
            if (this->pbDMap != NULL)
            {
                UnmapViewOfFile(this->pbDMap);
                this->pbDMap = NULL;
                WriteFile(this->hDFile, pv, sizeof(DWORD) + sRecord.cbData, &cb, NULL);
                this->RemapData();
            }
            else
            {
                WriteFile(this->hDFile, pv, sizeof(DWORD) + sRecord.cbData, &cb, NULL);
            }           
        }
    }

    return(cbRet);
}

BOOL cBFile_::BinaryFind(DWORD *pcbDataOffset)
{
    if (sHeader.fDirty)
    {
        this->Sort();
    }

    if (sHeader.cbSortedEOF == 0)
    {
        return(FALSE);
    }

    if (!(this->pbKMap))
    {
        return(FALSE);
    }

    DWORD   dwEnd;
    DWORD   dwMiddle;
    DWORD   dwStart;
    DWORD   dwHalf;
    DWORD   dwCur;
    void    *pv;
    int     cmp;

    dwStart     = 0;
    dwEnd       = sHeader.cbSortedEOF / BFILE_KEYSIZE;
    dwHalf = dwMiddle    = dwEnd / 2L;
    dwCur       = 0;

    __try {

    for EVER
    {
        pv = (void *)(this->pbKMap + (dwMiddle * BFILE_KEYSIZE));

        cmp = memcmp(sRecord.pvKey, pv, sRecord.cbKey);

        if (cmp == 0)
        {
            memcpy(pcbDataOffset, (char *)pv + sRecord.cbKey, sizeof(DWORD));

            this->dwFirstNextRecNum = (DWORD)((BYTE *)pv - this->pbKMap) / BFILE_KEYSIZE;

            return(TRUE);
        }

        if ((dwMiddle == 0) || (dwMiddle == (sHeader.cbSortedEOF / BFILE_KEYSIZE)) ||
            ((dwHalf == 0) && (dwMiddle == dwStart)))
        {
            break;
        }

        if (cmp < 0)
        {
            dwEnd   = dwMiddle;
        }
        else
        {
            dwStart = dwMiddle;
        }

        dwHalf      = (dwEnd - dwStart) / 2L;
        dwMiddle    = dwStart + dwHalf;
    }

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        this->UnmapAll();
        SetLastError( GetExceptionCode() );
    }

    return(FALSE);
}

BOOL cBFile_::ReadHeader(void)
{
    if ((this->pbDMap) && (this->cbDMap >= (sizeof(BFILE_HEADER) + BFILE_SIZEOFSIG)))
    {
        memcpy(&this->sHeader, &this->pbDMap[BFILE_SIZEOFSIG], sizeof(BFILE_HEADER));
    }
    else if (SetFilePointer(this->hDFile, BFILE_SIZEOFSIG, NULL, FILE_BEGIN) != 0xffffffff)
    {
        DWORD   cb;

        if (!ReadFile(this->hDFile, &this->sHeader, sizeof(BFILE_HEADER), &cb, NULL))
        {
            return(FALSE);
        }
    }
    else
    {
        memset(&this->sHeader, 0x00, sizeof(BFILE_HEADER));
    }

    return(TRUE);
}

BOOL cBFile_::UpdateHeader(void)
{
    if ( fReadOnly == TRUE )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    if ((this->pbDMap) && (this->cbDMap >= (sizeof(BFILE_HEADER) + BFILE_SIZEOFSIG)))
    {
        memcpy(&this->pbDMap[BFILE_SIZEOFSIG], &this->sHeader, sizeof(BFILE_HEADER));
        return(TRUE);
    }

    if (SetFilePointer(this->hDFile, BFILE_SIZEOFSIG, NULL, FILE_BEGIN) != 0xffffffff)
    {
        DWORD   cbWritten;

        WriteFile(this->hDFile, &this->sHeader, sizeof(BFILE_HEADER), &cbWritten, NULL);

        return(TRUE);
    }

    return(FALSE);
}

BOOL cBFile_::OpenFiles(void)
{
    BOOL    fRet = TRUE;
    WCHAR   wszFile[MAX_PATH];
    DWORD   cbWritten;
    int     iBaseEnd;

    wcscpy(&wszFile[0], pwszPath);
    if (wszFile[wcslen(pwszPath) - 1] != L'\\')
    {
        wcscat(&wszFile[0], L"\\");
    }
    wcscat(&wszFile[0], pwszBaseName);
    iBaseEnd = wcslen(&wszFile[0]);

    wcscpy(&wszFile[iBaseEnd], BFILE_DATAEXT);

    hDFile = CreateFileU(&wszFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, 0, NULL);

    if (hDFile == INVALID_HANDLE_VALUE)
    {
        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
            hDFile = CreateFileU(&wszFile[0], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL, OPEN_EXISTING, 0, NULL);

            fReadOnly = TRUE;
        }
        else
        {
            hDFile = CreateFileU(&wszFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL, CREATE_NEW, 0, NULL);
        }

        if (hDFile == INVALID_HANDLE_VALUE)
        {
            return(FALSE);
        }

        if ( fReadOnly == FALSE )
        {
            WriteFile(this->hDFile, BFILE_SIG, BFILE_SIZEOFSIG, &cbWritten, NULL);

            this->Lock();

            __try {

            fRet = this->UpdateHeader();

            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                fRet = FALSE;
            }

            this->Unlock();

            if ( fRet == FALSE )
            {
                return( FALSE );
            }

            wcscpy(&wszFile[iBaseEnd], BFILE_KEYEXT);

            hKFile = CreateFileU(&wszFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL, OPEN_ALWAYS, 0, NULL);
        }
        else
        {
            wcscpy(&wszFile[iBaseEnd], BFILE_KEYEXT);

            hKFile = CreateFileU(&wszFile[0], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL, OPEN_EXISTING, 0, NULL);
        }
    }
    else
    {
        wcscpy(&wszFile[iBaseEnd], BFILE_KEYEXT);

        hKFile = CreateFileU(&wszFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL, OPEN_ALWAYS, 0, NULL);
    }

    if ((hDFile == INVALID_HANDLE_VALUE) || (hKFile == INVALID_HANDLE_VALUE))
    {
        return(FALSE);
    }

    fRet &= this->RemapKey();
    fRet &= this->RemapData();

    if ( fRet == FALSE )
    {
        return( FALSE );
    }

    __try {

    if (!this->ReadHeader())
    {
        return FALSE;
    }

    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
    }

    return(fRet);
}


BOOL cBFile_::RemapKey(void)
{
    LPBYTE pbOldMap;
    HANDLE hMappedFile;
    DWORD  PageAccess = PAGE_READWRITE;
    DWORD  FileMapAccess = FILE_MAP_WRITE;

    pbOldMap = this->pbKMap;

    if ( fReadOnly == TRUE )
    {
        PageAccess = PAGE_READONLY;
        FileMapAccess = FILE_MAP_READ;
    }

    hMappedFile = CreateFileMapping(this->hKFile, NULL, PageAccess, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        return(TRUE);   // could be the first call!
    }

    this->pbKMap = (BYTE *)MapViewOfFile(hMappedFile, FileMapAccess, 0, 0, 0);
    if ( this->pbKMap != NULL )
    {
        if ( pbOldMap != NULL )
        {
            UnmapViewOfFile( pbOldMap );
        }

        this->cbKMap = GetFileSize(this->hKFile, NULL);
    }
    else
    {
        this->pbKMap = pbOldMap;
    }

    CloseHandle(hMappedFile);

    if ( ( pbOldMap == NULL ) && ( this->pbKMap == NULL ) )
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL cBFile_::RemapData(void)
{
    LPBYTE pbOldMap;
    HANDLE hMappedFile;
    DWORD  PageAccess = PAGE_READWRITE;
    DWORD  FileMapAccess = FILE_MAP_WRITE;

    pbOldMap = this->pbDMap;

    if ( fReadOnly == TRUE )
    {
        PageAccess = PAGE_READONLY;
        FileMapAccess = FILE_MAP_READ;
    }

    hMappedFile = CreateFileMapping(this->hDFile, NULL, PageAccess, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        return(TRUE);   // could be the first call!
    }

    this->pbDMap = (BYTE *)MapViewOfFile(hMappedFile, FileMapAccess, 0, 0, 0);
    if ( this->pbDMap != NULL )
    {
        if ( pbOldMap != NULL )
        {
            UnmapViewOfFile( pbOldMap );
        }

        this->cbDMap = GetFileSize(this->hDFile, NULL);
    }
    else
    {
        this->pbDMap = pbOldMap;
    }

    CloseHandle(hMappedFile);

    if ( ( pbOldMap == NULL ) && ( this->pbDMap == NULL ) )
    {
        return(FALSE);
    }

    return(TRUE);
}

void cBFile_::UnmapAll(void)
{
    if (this->pbKMap != NULL)
    {
        UnmapViewOfFile(this->pbKMap);
        this->pbKMap = NULL;
    }

    if (this->pbDMap != NULL)
    {
        UnmapViewOfFile(this->pbDMap);
        this->pbDMap = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\codbc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       codbc.cpp
//
//  Contents:   Microsoft Internet Security Common
//
//  History:    08-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "codbc.hxx"

cODBC_::cODBC_(void)
{
    hODBC32 = NULL;
    
    fp_SQLSetStmtOption = NULL;
    fp_SQLExecDirect    = NULL;
    fp_SQLFetch         = NULL;
    fp_SQLFreeConnect   = NULL;
    fp_SQLFreeEnv       = NULL;
    fp_SQLFreeStmt      = NULL;
    fp_SQLTransact      = NULL;
    fp_SQLError         = NULL;
    fp_SQLGetData       = NULL;
    fp_SQLAllocConnect  = NULL;
    fp_SQLAllocEnv      = NULL;
    fp_SQLAllocStmt     = NULL;
    fp_SQLDriverConnect = NULL;
    fp_SQLDisconnect    = NULL;
}

cODBC_::~cODBC_(void)
{
    if (hODBC32)
    {
        FreeLibrary(hODBC32);
    }
}

BOOL cODBC_::Initialize(void)
{
    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    if (!(hODBC32 = LoadLibrary("ODBC32.DLL")))
    {
        goto ErrorDLLLoad;
    }

    fp_SQLSetStmtOption     = (td_SQLSetStmtOption)GetProcAddress(hODBC32,  "SQLSetStmtOption");
    fp_SQLExecDirect        = (td_SQLExecDirect)GetProcAddress(hODBC32,     "SQLExecDirect");
    fp_SQLFetch             = (td_SQLFetch)GetProcAddress(hODBC32,          "SQLFetch");
    fp_SQLFreeConnect       = (td_SQLFreeConnect)GetProcAddress(hODBC32,    "SQLFreeConnect");
    fp_SQLFreeEnv           = (td_SQLFreeEnv)GetProcAddress(hODBC32,        "SQLFreeEnv");
    fp_SQLFreeStmt          = (td_SQLFreeStmt)GetProcAddress(hODBC32,       "SQLFreeStmt");
    fp_SQLTransact          = (td_SQLTransact)GetProcAddress(hODBC32,       "SQLTransact");
    fp_SQLError             = (td_SQLError)GetProcAddress(hODBC32,          "SQLError");
    fp_SQLGetData           = (td_SQLGetData)GetProcAddress(hODBC32,        "SQLGetData");
    fp_SQLAllocConnect      = (td_SQLAllocConnect)GetProcAddress(hODBC32,   "SQLAllocConnect");
    fp_SQLAllocEnv          = (td_SQLAllocEnv)GetProcAddress(hODBC32,       "SQLAllocEnv");
    fp_SQLAllocStmt         = (td_SQLAllocStmt)GetProcAddress(hODBC32,      "SQLAllocStmt");
    fp_SQLDriverConnect     = (td_SQLDriverConnect)GetProcAddress(hODBC32,  "SQLDriverConnect");
    fp_SQLDisconnect        = (td_SQLDisconnect)GetProcAddress(hODBC32,     "SQLDisconnect");

    if (!(fp_SQLSetStmtOption) ||
        !(fp_SQLExecDirect) ||
        !(fp_SQLFetch) ||
        !(fp_SQLFreeConnect) ||
        !(fp_SQLFreeEnv) ||
        !(fp_SQLFreeStmt) ||
        !(fp_SQLTransact) ||
        !(fp_SQLError) ||
        !(fp_SQLGetData) ||
        !(fp_SQLAllocConnect) ||
        !(fp_SQLAllocEnv) ||
        !(fp_SQLAllocStmt) ||
        !(fp_SQLDriverConnect) ||
        !(fp_SQLDisconnect))
    {
        goto ErrorProcAddress;
    }

    return(TRUE);

    ErrorReturn:
        return(FALSE);

    TRACE_ERROR_EX(DBG_SS, ErrorDLLLoad);
    TRACE_ERROR_EX(DBG_SS, ErrorProcAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\cryptattr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       CryptAttr.cpp
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "CryptAttr.hxx"

CryptAttribute_::CryptAttribute_(void)
{
    sAttribute.pszObjId     = NULL;
    sAttribute.Value.pbData = NULL;
}

CryptAttribute_::~CryptAttribute_(void)
{
    DELETE_OBJECT(sAttribute.pszObjId);
    DELETE_OBJECT(sAttribute.rgValue->pbData);
}

BOOL CryptAttribute_::Fill(DWORD cbAttributeData, BYTE *pbAttributeData, char *pszObjId)
{
    DELETE_OBJECT(sAttribute.pszObjId);
    DELETE_OBJECT(sAttribute.Value.pbData);

    sAttribute.pszObjId = new char[strlen(pszObjId) + 1];
    strcpy(&sAttribute.pszObjId[0], pszObjId);

    if (CryptEncodeObject(  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pszObjId,

    sAttribute.Value.pbData = new BYTE[cbAttributeData];
    sAttribute.Value.cbData = cbAttributeData;
    memcpy(&sAttribute.Value.pbData, pbAttributeData, cbAttributeData);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\cwargv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cwargv.cpp
//
//  Contents:   argv parsing api
//
//  History:    02-Oct-1997 pberkman    create
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cwargv.hxx"
#include    "fparse.hxx"

#define SID_FILES               0

typedef struct ARGVSTORAGE_
{
    DWORD       dwsidOption;
    WCHAR       *pwszOption;

    DWORD       dwsidOptionHelp;
    WCHAR       *pwszOptionHelp;

    BOOL        fHiddenCmd;

    BOOL        fSet;

    DWORD       dwValueType;
    union
    {
        WCHAR   *pwszValue;
        WCHAR   *pwszCmdFile;
        DWORD   dwValue;
        BOOL    fValue;
    };

} ARGVSTORAGE;

cWArgv_::cWArgv_(HINSTANCE hInst0, BOOL *pfFailed, BOOL fChkCmdFile)
{
    pwszThisFilename        = NULL; // don't delete!
    pwszUsageWord           = NULL;
    pwszUsageOptionsText    = NULL;
    pwszUsageCmdFileText    = NULL;
    pwszUsageAddText        = NULL;
    pwszOptionParamText     = NULL;
    pwszUsageString         = NULL;
    pwszNonParamArgBlanks   = NULL;
    fShowHiddenArgs         = FALSE;
    fNonHiddenParamArgs     = FALSE;
    dwLongestArg            = 0;
    this->hInst             = hInst0;
    this->fChkCmdF          = fChkCmdFile;
    pArgs                   = new Stack_(NULL); // no sorting!
    if (pArgs == NULL)
    {
        *pfFailed = TRUE;   
    }
    else
    {
        *pfFailed = FALSE;
    }
}

cWArgv_::~cWArgv_(void)
{
    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    DELETE_OBJECT(pwszUsageWord);
    DELETE_OBJECT(pwszUsageOptionsText);
    DELETE_OBJECT(pwszUsageCmdFileText);
    DELETE_OBJECT(pwszUsageAddText);
    DELETE_OBJECT(pwszOptionParamText);
    DELETE_OBJECT(pwszUsageString);
    DELETE_OBJECT(pwszNonParamArgBlanks);

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        DELETE_OBJECT(pArg->pwszOption);
        DELETE_OBJECT(pArg->pwszOptionHelp);

        dwIdx++;
    }

    DELETE_OBJECT(pArgs);
}

void cWArgv_::AddUsageText(DWORD dwsidUsageWord, DWORD dwsidUsageOptions, DWORD dwsidUsageCmdFileText,
                           DWORD dwsidUsageAddText, DWORD dwsidOptionParamText)
{
    WCHAR       wszString[MAX_PATH];

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageWord, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageWord = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageWord, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageOptions, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageOptionsText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageOptionsText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageCmdFileText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageCmdFileText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageCmdFileText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidOptionParamText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszOptionParamText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszOptionParamText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageAddText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageAddText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageAddText, &wszString[0]);
    }
}

WCHAR *cWArgv_::GetUsageString(void)
{
    int i;

    if (pwszUsageString)
    {
        return(pwszUsageString);
    }

    if (!(pwszThisFilename))
    {
        return(NULL);
    }

    DWORD   ccLen;

    ccLen = wcslen(pwszThisFilename);

    if (pwszUsageWord)
    {
        ccLen += wcslen(pwszUsageWord);
    }

    if (pwszUsageOptionsText)
    {
        ccLen += wcslen(pwszUsageOptionsText);
    }

    if (fChkCmdF)
    {
        if (pwszUsageCmdFileText)
        {
            ccLen += wcslen(pwszUsageCmdFileText);
        }
    }

    if (pwszUsageAddText)
    {
        ccLen += wcslen(pwszUsageAddText);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption != SID_FILES)
        {
            if (pArg->pwszOption)
            {
                if ((pArg->fHiddenCmd) && (!(fShowHiddenArgs)))
                {
                    dwIdx++;
                    continue;
                }

                ccLen += 6;             // 5 spaces + 1 for '-'
                ccLen += dwLongestArg;  // wcslen(pArg->pwszOption);

                if (((fNonHiddenParamArgs) && !(fShowHiddenArgs)) ||
                    (fShowHiddenArgs))
                {
                    if ((pwszNonParamArgBlanks) && (pwszOptionParamText))
                    {
                        ccLen++;    // space
                        ccLen += wcslen(pwszOptionParamText);
                    }
                }

                if (pArg->pwszOptionHelp)
                {
                    ccLen += 2; // : + space
                    ccLen += wcslen(pArg->pwszOptionHelp);
                }

                ccLen += 2; // cr/lf
            }
        }

        dwIdx++;
    }


    ccLen += 10;

    if (!(pwszUsageString = new WCHAR[ccLen + 1]))
    {
        return(NULL);
    }

    swprintf(pwszUsageString, L"%s: %s %s %s %s\r\n",
                            pwszUsageWord,
                            pwszThisFilename,
                            (pwszUsageOptionsText) ? pwszUsageOptionsText : L"",
                            (pwszUsageCmdFileText && fChkCmdF) ? pwszUsageCmdFileText : L"",
                            (pwszUsageAddText) ? pwszUsageAddText : L"");

    dwIdx = pArgs->Count() - 1;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption != SID_FILES)
        {
            if (pArg->pwszOption)
            {
                if ((pArg->fHiddenCmd) && (!(fShowHiddenArgs)))
                {
                    if (dwIdx == 0)
                    {
                        break;
                    }

                    dwIdx--;
                    continue;
                }

                wcscat(pwszUsageString, L"     -");
                wcscat(pwszUsageString, pArg->pwszOption);

                if ((pArg->dwValueType != WARGV_VALUETYPE_BOOL) &&
                    (pwszOptionParamText))
                {
                    wcscat(pwszUsageString, L" ");
                    wcscat(pwszUsageString, pwszOptionParamText);
                }

                if (pArg->pwszOptionHelp)
                {
                    wcscat(pwszUsageString, L": ");

                    for (i = 0; i < (int)(dwLongestArg - wcslen(pArg->pwszOption)); i++)
                    {
                        wcscat(pwszUsageString, L" ");
                    }

                    if ((pArg->dwValueType == WARGV_VALUETYPE_BOOL) &&
                        (((fNonHiddenParamArgs) && !(fShowHiddenArgs)) || (fShowHiddenArgs)) &&
                        (pwszNonParamArgBlanks))
                    {
                        wcscat(pwszUsageString, pwszNonParamArgBlanks);
                    }

                    wcscat(pwszUsageString, pArg->pwszOptionHelp);
                }

                wcscat(pwszUsageString, L"\r\n");
            }
        }

        if (dwIdx == 0)
        {
            break;
        }

        dwIdx--;
    }

    return(pwszUsageString);
}

BOOL cWArgv_::Add2List(DWORD dwsidOption, DWORD dwsidOptionHelp, DWORD dwValueType, void *pvDefaultValue,
                       BOOL fInternalCmd)
{
    if (!(pArgs))
    {
        return(FALSE);
    }

    ARGVSTORAGE *pArg;
    WCHAR       wszString[MAX_PATH];
    DWORD       i;

    if (!(pArg = (ARGVSTORAGE *)pArgs->Add(sizeof(ARGVSTORAGE))))
    {
        return(FALSE);
    }

    memset(pArg, 0x00, sizeof(ARGVSTORAGE));

    pArg->dwValueType   = dwValueType;

    if (pArg->dwValueType != WARGV_VALUETYPE_BOOL)
    {
        if (!(pwszNonParamArgBlanks))
        {
            if (pwszOptionParamText)
            {
                if (pwszNonParamArgBlanks = new WCHAR[wcslen(pwszOptionParamText) + 2])
                {
                    for (i = 0; i <= (DWORD)wcslen(pwszOptionParamText); i++)
                    {
                        pwszNonParamArgBlanks[i] = L' ';
                    }
                    pwszNonParamArgBlanks[i] = NULL;
                }
            }
        }

        fNonHiddenParamArgs = TRUE;
    }

    pArg->fHiddenCmd    = fInternalCmd;

    pArg->dwsidOption   = dwsidOption;
    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidOption, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pArg->pwszOption = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return(FALSE);
        }

        wcscpy(pArg->pwszOption, &wszString[0]);

        if ((DWORD)wcslen(&wszString[0]) > dwLongestArg)
        {
            dwLongestArg = wcslen(&wszString[0]);
        }
    }


    pArg->dwsidOptionHelp   = dwsidOptionHelp;
    wszString[0]            = NULL;
    LoadStringU(this->hInst, dwsidOptionHelp, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pArg->pwszOptionHelp = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return(FALSE);
        }

        wcscpy(pArg->pwszOptionHelp, &wszString[0]);
    }

    if (pvDefaultValue)
    {
        switch (dwValueType)
        {
            case WARGV_VALUETYPE_BOOL:      pArg->fValue    = (BOOL)((DWORD_PTR)pvDefaultValue);     break;
            case WARGV_VALUETYPE_DWORDD:
            case WARGV_VALUETYPE_DWORDH:    pArg->dwValue   = (DWORD)((DWORD_PTR)pvDefaultValue);    break;
            case WARGV_VALUETYPE_WCHAR:     pArg->pwszValue = (WCHAR *)pvDefaultValue;  break;
            default:
                return(FALSE);
        }
    }

    return(TRUE);
}

BOOL cWArgv_::Fill(int argc, WCHAR **wargv)
{
    if (!(pArgs))
    {
        return(FALSE);
    }

    if (!(pwszThisFilename))
    {
        if (pwszThisFilename = wcsrchr(&wargv[0][0], L'\\'))
        {
            pwszThisFilename++;
        }
        else
        {
            pwszThisFilename    = &wargv[0][0];
        }
    }

    int     i;

    for (i = 1; i < argc; ++i)
    {
        switch (wargv[i][0])
        {
            case L'-':
            case L'/':
                if (wargv[i][1] == L'~')
                {
                    fShowHiddenArgs     = TRUE;
                    return(FALSE);
                }

                i += this->ProcessArg(argc - i, &wargv[i]);
                break;

            case L'@':
                this->ProcessCommandFile(&wargv[i][1]);
                break;

            default:
                this->AddFile(&wargv[i][0]);
                break;
        }
    }

    return(TRUE);
}

int cWArgv_::ProcessArg(int argc, WCHAR **wargv)
{
    ARGVSTORAGE *pArg;
    DWORD       dwIdx;
    DWORD       ccOption;
    WCHAR       *pwszArg;
    int         iRet;

    iRet    = 0;

    pwszArg             = &wargv[0][1]; // skip over - or /

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->pwszOption)
        {
            ccOption = (DWORD)wcslen(pArg->pwszOption);

            if (_memicmp(pArg->pwszOption, pwszArg, ccOption * sizeof(WCHAR)) == 0)
            {
                pArg->fSet = TRUE;

                switch (pArg->dwValueType)
                {
                    case WARGV_VALUETYPE_BOOL:
                            pArg->fValue = TRUE;

                            return(iRet);

                    case WARGV_VALUETYPE_DWORDH:
                    case WARGV_VALUETYPE_DWORDD:
                            if (!(pwszArg[ccOption]))
                            {
                                pwszArg = &wargv[1][0];
                                iRet++;
                            }
                            else
                            {
                                pwszArg = &wargv[0][ccOption + 1];
                            }

                            if (pArg->dwValueType == WARGV_VALUETYPE_DWORDH)
                            {
                                pArg->dwValue = (DWORD)wcstoul(pwszArg, NULL, 16);
                            }
                            else
                            {
                                pArg->dwValue = (DWORD)wcstoul(pwszArg, NULL, 10);
                            }

                            return(iRet);

                    case WARGV_VALUETYPE_WCHAR:
                            if (!(pwszArg[ccOption]))
                            {
                                pArg->pwszValue = &wargv[1][0];
                                iRet++;
                            }
                            else
                            {
                                pArg->pwszValue = &wargv[0][ccOption];
                            }

                            return(iRet);

                    default:
                            return(iRet);
                }
            }
        }

        dwIdx++;
    }

    return(iRet);
}

BOOL cWArgv_::IsSet(DWORD dwsidOption)
{
    ARGVSTORAGE *pArg;
    DWORD   dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return((pArg->fSet) ? TRUE : FALSE);
        }

        dwIdx++;
    }

    return(FALSE);
}

void *cWArgv_::GetValue(DWORD dwsidOption)
{
    ARGVSTORAGE *pArg;
    DWORD   dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            switch (pArg->dwValueType)
            {
                case WARGV_VALUETYPE_BOOL:      return((void *)(UINT_PTR)pArg->fValue);
                case WARGV_VALUETYPE_DWORDD:
                case WARGV_VALUETYPE_DWORDH:    return((void *)(UINT_PTR)pArg->dwValue);
                case WARGV_VALUETYPE_WCHAR:     return((void *)pArg->pwszValue);
                default:
                    return(NULL);
            }
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetOptionHelp(DWORD dwsidOption)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx   = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return(pArg->pwszOptionHelp);
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetOption(DWORD dwsidOption)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx   = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return(pArg->pwszOption);
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetFileName(DWORD *pdwidxLast)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;
    DWORD       dwFIdx;

    dwIdx   = 0;
    dwFIdx  = 1;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == SID_FILES)
        {
            if (!(pdwidxLast) || (dwFIdx > *pdwidxLast))
            {
                return(pArg->pwszValue);
            }

            dwFIdx++;
        }

        dwIdx++;
    }

    return(NULL);
}

BOOL cWArgv_::AddFile(WCHAR *pwszFile)
{
    ARGVSTORAGE *pArg;

    if (!(pArg = (ARGVSTORAGE *)pArgs->Add(sizeof(ARGVSTORAGE))))
    {
        return(FALSE);
    }

    memset(pArg, 0x00, sizeof(ARGVSTORAGE));

    pArg->dwsidOption   = SID_FILES;
    pArg->dwValueType   = WARGV_VALUETYPE_WCHAR;
    pArg->pwszValue     = pwszFile;

    this->StripQuotes(pArg->pwszValue);

    return(TRUE);
}

BOOL cWArgv_::ProcessCommandFile(WCHAR *pwszFile)
{
    if (!(this->fChkCmdF))
    {
        return(FALSE);
    }

    HANDLE      hFile;
    BOOL        fFailed = FALSE;
    fParse_     fp(pwszFile, &fFailed);
    WCHAR       *pwsz;

    if (fFailed)
    {
        return FALSE;
    }

    fp.Reset();

    while (fp.GetNextLine())
    {
        fp.EOLRemove();

        if ((fp.GetCurrentLine()) && (fp.GetCurrentLine()[0]))
        {
            pwsz = fp.GetCurrentLine();
            this->Fill(1, &pwsz);
        }
    }

    return(TRUE);
}

void cWArgv_::StripQuotes(WCHAR *pwszIn)
{
    DWORD   dwSrc;
    DWORD   dwDst;
    DWORD   dwLen;

    dwSrc = 0;
    dwDst = 0;
    dwLen = wcslen(pwszIn);

    while (dwSrc < dwLen)
    {
        if (pwszIn[dwSrc] != L'\"')
        {
            pwszIn[dwDst] = pwszIn[dwSrc];
            dwDst++;
        }
        dwSrc++;
    }

    pwszIn[dwDst] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\eventlst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       eventlst.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  InitializeListLock
//              InitializeListEvent
//              LockWaitToWrite
//
//              *** local functions ***
//              LockInitialize
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include        "global.hxx"

#include        "eventlst.h"

#define PCB_LIST_DEBUG 0

BOOL LockInitialize(LIST_LOCK *pListLock, DWORD dwDebugMask);


BOOL InitializeListLock(LIST_LOCK *psListLock, DWORD dwDebugMask)
{
    return(LockInitialize(psListLock, dwDebugMask));
}

BOOL InitializeListEvent(HANDLE *phListEvent)
{
    if (!(*phListEvent = CreateEvent(NULL, TRUE, TRUE, NULL)))
    {
        return(FALSE);
    }
    
    return(TRUE);
}

BOOL EventFree(HANDLE hListEvent)
{
    if ((hListEvent) && (hListEvent != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hListEvent);
        return(TRUE);
    }

    return(FALSE);
}

BOOL LockInitialize(LIST_LOCK *pListLock, DWORD dwDebugMask) 
{
    //
    // Initialize the variable that indicates the number of 
    // reader threads that are reading.
    // Initially no reader threads are reading.
    //

    pListLock->dwDebugMask  = dwDebugMask;

    pListLock->NumReaders   = 0;

    pListLock->hMutexNoWriter = CreateMutex(NULL, FALSE, NULL);

    if (!(pListLock->hMutexNoWriter))
    {
        return(FALSE);
    }

    //
    // Create the manual-reset event that is signalled when  
    // no reader threads are reading.  Initially no reader   
    // threads are reading.                                  
    //

    pListLock->hEventNoReaders = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (pListLock->hEventNoReaders)
    {
        return(TRUE);
    }
    else 
    {
        CloseHandle(pListLock->hMutexNoWriter);

        pListLock->hMutexNoWriter = NULL;

        return(FALSE);
    }
}

BOOL LockFree(LIST_LOCK *pListLock)
{
    if (pListLock->hEventNoReaders)
    {
        CloseHandle(pListLock->hEventNoReaders);
        pListLock->hEventNoReaders = NULL;
    }

    if (pListLock->hMutexNoWriter)
    {
        CloseHandle(pListLock->hMutexNoWriter);
        pListLock->hMutexNoWriter = NULL;
    }

    return(TRUE);
}

void LockWaitToWrite(LIST_LOCK *pListLock)
{
    //
    // We can write if the following are true:
    //
    // 1. The mutex guard is available and no
    //    other threads are writing.             
    //
    // 2. No threads are reading.
    //
    // Note that, unlike an rtl resource, this attempt
    // to write does not lock out other readers.  We
    // just have to wait patiently for our turn.
    // 

    HANDLE  ahObjects[2];

    ahObjects[0]    = pListLock->hMutexNoWriter;
    ahObjects[1]    = pListLock->hEventNoReaders;

    WaitForMultipleObjects(2, ahObjects, TRUE, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Write Acquire: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), ahObjects[0], ahObjects[1]);

#   endif

    //
    // Exit with the mutex, so as to prevent any more readers or writers
    // from coming in.
    //
}

void LockDoneWriting(LIST_LOCK *pListLock) 
{
    //
    // We're done writing, release the mutex so that
    // readers or other writers may come in.
    //

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Write Release: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    ReleaseMutex(pListLock->hMutexNoWriter);
}



void LockWaitToRead(LIST_LOCK *pListLock) 
{
    //
    // Acquire the mutex that protects the list data.
    //
    WaitForSingleObject(pListLock->hMutexNoWriter, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Read  Acquire: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    //
    // Now that we have the mutex, we can modify list data without
    // fear of corrupting anyone.
    //

    //
    // Increment the number of reader threads.
    //

    if (++pListLock->NumReaders == 1) 
    {
        //
        // If this is the first reader thread, set our event to   
        // reflect this.  This is so that anyone waiting to write 
        // will block until we're done.                           
        //
        ResetEvent(pListLock->hEventNoReaders);
    }

    //
    // Allow other writer/reader threads to use
    // the lock object.
    //
    ReleaseMutex(pListLock->hMutexNoWriter);
}



void LockDoneReading(LIST_LOCK *pListLock) 
{
    //
    // Acquire the mutex that guards the list data so we can
    // decrement the number of readers safely.
    //

    WaitForSingleObject(pListLock->hMutexNoWriter, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Read  Release: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    if (--pListLock->NumReaders == 0) 
    {
        //
        // We were the last reader.  Wake up any potential
        // writers.
        //
        SetEvent(pListLock->hEventNoReaders);
    }

    //
    // Allow other writer/reader threads to use
    // the lock object.
    //
    ReleaseMutex(pListLock->hMutexNoWriter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\gendefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       GenDefs.h
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef GENDEFS_H
#define GENDEFS_H

#include        "cryptver.h"

#if (VER_PRODUCTMINOR > 101) // > IE4 (NT5 b2 and >)

#   define      USE_IEv4CRYPT32     0

#   include     "cryptui.h"
#   define      CVP_STRUCTDEF   CRYPTUI_VIEWCERTIFICATE_STRUCTW
#   define      CVP_DLL         "cryptui.dll"
#   define      CVP_FUNC_NAME   "CryptUIDlgViewCertificateW"

typedef BOOL (WINAPI *pfnCertViewProperties)(CVP_STRUCTDEF * pcvsa, BOOL *fRefreshChain);

#else                       // IE4 and <

#   define      USE_IEv4CRYPT32     1

#   include     "cryptdlg.h"
#   define      CVP_STRUCTDEF    CERT_VIEWPROPERTIES_STRUCT_A
#   define      CVP_DLL         "cryptdlg.dll"
#   define      CVP_FUNC_NAME   "CertViewPropertiesA"

typedef BOOL (WINAPI *pfnCertViewProperties)(CVP_STRUCTDEF * pcvsa);

#endif

#define EVER                (;;)

#ifdef _WINDLL
#   define      APIEXP
#   define      DLL32EXP    __declspec(dllexport)
#else
#   define      APIEXP
#   define      DLL32EXP
#endif

#define SignError()     (GetLastError() > (DWORD)0xFFFF) ? \
                            GetLastError() : \
                            HRESULT_FROM_WIN32(GetLastError())

#define _OFFSETOF(t,f)   ((DWORD)((DWORD_PTR)(&((t*)0)->f)))

#define _ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)

#define WIDEN(sz,wsz)                                           \
    int cch##wsz = sz ? strlen(sz) + 1 : 0;                     \
    int cb##wsz  = cch##wsz * sizeof(WCHAR);                    \
    LPWSTR wsz = sz ? (LPWSTR)_alloca(cb##wsz) : NULL;          \
    if (wsz) MultiByteToWideChar(0, 0, sz, -1, wsz, cch##wsz)


#ifdef __cplusplus
#       define          DELETE_OBJECT(obj0)     if (obj0)           \
                                                                        {                   \
                                                                                delete obj0;    \
                                                                                obj0 = NULL;    \
                                                                        }
#else
#       define          DELETE_OBJECT(obj0)     if (obj0)           \
                                                                        {                   \
                                                                                free(obj0);     \
                                                                                obj0 = NULL;    \
                                                                        }
#endif


#endif // GENDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\eventlst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       eventlst.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef EVENTLST_H
#define EVENTLST_H

#ifdef __cplusplus
extern "C" 
{
#endif


typedef struct _LIST_LOCK 
{
   HANDLE   hMutexNoWriter;
   HANDLE   hEventNoReaders;
   LONG     NumReaders;
   DWORD    dwDebugMask;

} LIST_LOCK, *PLIST_LOCK;

extern BOOL     InitializeListLock(LIST_LOCK *pListLock, DWORD dwDebugMask);
extern BOOL     LockFree(LIST_LOCK *pListLock);
extern BOOL     InitializeListEvent(HANDLE *phListLock);
extern BOOL     EventFree(HANDLE hListLock);
extern void     LockWaitToWrite(LIST_LOCK *pListLock);
extern void     LockDoneWriting(LIST_LOCK *pListLock);
extern void     LockWaitToRead(LIST_LOCK *pListLock);
extern void     LockDoneReading(LIST_LOCK *pListLock);

#define SetListEvent(hListEvent)                ((void)SetEvent(hListEvent))
#define ResetListEvent(hListEvent)              ((void)ResetEvent(hListEvent))
#define WaitForListEvent(hListEvent)            (WaitForSingleObject(hListEvent, INFINITE))
#define AcquireReadLock(sListLock)              (LockWaitToRead(&sListLock))
#define ReleaseReadLock(sListLock)           (LockDoneReading(&sListLock))
#define AcquireWriteLock(sListLock)          (LockWaitToWrite(&sListLock))  
#define ReleaseWriteLock(sListLock)          (LockDoneWriting(&sListLock))   


#ifdef __cplusplus
}
#endif

#endif // EVENTLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\fparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fparse.cpp
//
//  Contents:   File parsing api -- INI file types
//
//  History:    01-Oct-1997 pberkman    create
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "fparse.hxx"


fParse_::fParse_(WCHAR *pwszFilename, BOOL *pfFailed, DWORD dwMaxLine0, DWORD dwFileAccess, DWORD dwFileSharing)
{
    hFile               = INVALID_HANDLE_VALUE;
    dwMaxLine           = dwMaxLine0;
    pwszCurrentLine     = NULL;
    dwCurLineFilePos    = 0;
    dwLastGroupFilePos  = 0;
    dwLastTagFilePos    = 0;
    fEOF                = FALSE;
    pwszTempFName       = NULL;
    pwszLastGroupTag    = NULL;

    __try 
    {
        hFile = CreateFileU(
                    pwszFilename, 
                    dwFileAccess, 
                    dwFileSharing, 
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL);

        pwszCurrentLine = new WCHAR[dwMaxLine];

        if (pwszFName = new WCHAR[wcslen(pwszFilename) + 1])
        {
            wcscpy(pwszFName, pwszFilename);
        }

        if ((hFile == INVALID_HANDLE_VALUE) ||
            (pwszCurrentLine == NULL)       ||
            (pwszFName == NULL))
        {
            *pfFailed = TRUE;
        }
        else
        {
            *pfFailed = FALSE;
        }
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        if (pwszCurrentLine != NULL)
        {
            DELETE_OBJECT(pwszCurrentLine);
            pwszCurrentLine = NULL;
        }

        if (pwszFName != NULL)
        {
            DELETE_OBJECT(pwszFName);
            pwszFName = NULL;
        }

        *pfFailed = FALSE;
    }
}

fParse_::~fParse_(void)
{
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (pwszCurrentLine)
    {
        DELETE_OBJECT(pwszCurrentLine);
    }

    DELETE_OBJECT(pwszLastGroupTag);

    if (pwszTempFName)
    {
        CopyFileU(pwszTempFName, pwszFName, FALSE);

        DeleteFileU(pwszTempFName);

        delete pwszTempFName;
    }

    if (pwszFName != NULL)
    {
        DELETE_OBJECT(pwszFName);
    }
}

BOOL fParse_::AddTagToFile(WCHAR *pwszGroup, WCHAR *pwszTag, WCHAR *pwszValue)
{
    if (!(this->pwszCurrentLine) || (this->hFile == INVALID_HANDLE_VALUE))
    {
        return(FALSE);
    }

    char    szTFile[MAX_PATH * 2];
    WCHAR   wszGroup[MAX_PATH];
    HANDLE  hTFile;
    DWORD   ccTFile;
    DWORD   cbWrite;
    BOOL    fWritten;
    
    if (!(pwszLastGroupTag))
    {
        return(FALSE);
    }

    if (pwszTag[0] != L'[')
    {
        wcscpy(&wszGroup[0], L"[");
        wcscat(&wszGroup[0], pwszGroup);
        wcscat(&wszGroup[0], L"]");
    }
    else
    {
        wcscpy(&wszGroup[0], pwszTag);
    }

    szTFile[0] = NULL;
    GetTempFileName(".", "FPS", 0, &szTFile[0]);

    if (!(szTFile[0]))
    {
        return(FALSE);
    }

    ccTFile = MultiByteToWideChar(0, 0, &szTFile[0], -1, NULL, 0);

    if (ccTFile < 1)
    {
        return(FALSE);
    }

    if (!(pwszTempFName = new WCHAR[ccTFile + 1]))
    {
        return(FALSE);
    }

    MultiByteToWideChar(0, 0, &szTFile[0], -1, pwszTempFName, ccTFile + 1);

    hTFile = CreateFileU(pwszTempFName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL, NULL);

    if (hTFile == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN);

    fWritten = FALSE;

    while (this->GetNextLine())
    {
        szTFile[0] = NULL;
        WideCharToMultiByte(0, 0, this->pwszCurrentLine, wcslen(this->pwszCurrentLine) + 1,
                            &szTFile[0], MAX_PATH * 2, NULL, NULL);
        if (szTFile[0])
        {
            WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);

            if (!(fWritten))
            {
                this->EOLRemove();
    
                if (_memicmp(this->pwszCurrentLine, &wszGroup[0], 
                           wcslen(&wszGroup[0]) * sizeof(WCHAR)) == 0)
                {
                    //
                    //  add our line
                    //
                    szTFile[0] = NULL;
                    WideCharToMultiByte(0, 0, pwszTag, wcslen(pwszTag) + 1, &szTFile[0], MAX_PATH, NULL, NULL);
                    WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);
                    WriteFile(hTFile, "=", 1, &cbWrite, NULL);
                    szTFile[0] = NULL;
                    WideCharToMultiByte(0, 0, pwszValue, wcslen(pwszValue) + 1, &szTFile[0], MAX_PATH * 2, NULL, NULL);
                    WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);
                    WriteFile(hTFile, "\r\n", 2, &cbWrite, NULL);
                    fWritten = TRUE;
                }
            }
        }
    }

    CloseHandle(hTFile);

    this->Reset();

    return(TRUE);
}

void fParse_::Reset(void)
{
    this->dwCurLineFilePos      = 0;
    this->dwLastGroupFilePos    = 0;
    this->dwLastTagFilePos      = 0;

    SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN);
}


BOOL fParse_::PositionAtLastGroup(void)
{
    if (SetFilePointer(this->hFile, this->dwLastGroupFilePos, NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL fParse_::PositionAtLastTag(void)
{
    if (this->dwLastTagFilePos == 0)
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, this->dwLastTagFilePos, NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL fParse_::GetLineInCurrentGroup(void)
{
    if (this->dwLastGroupFilePos == 0)
    {
        return(FALSE);
    }

    if (this->dwLastTagFilePos == 0)
    {
        this->PositionAtLastGroup();
    }

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if (this->pwszCurrentLine[0] == L'[')
        {
            this->pwszCurrentLine[0] = NULL;

            return(FALSE);
        }

        this->EOLRemove();

        if (wcslen(this->pwszCurrentLine) > 0)
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;
            
            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;
    
    return(FALSE);
}

BOOL fParse_::FindTagInCurrentGroup(WCHAR *pwszTag)
{
    if (this->dwLastGroupFilePos == 0)
    {
        return(FALSE);
    }

    WCHAR   wszCheck[MAX_PATH];
    WCHAR   wszCheck2[MAX_PATH];
    LPWSTR  pwszEqual;
    DWORD   ccRet;
    DWORD   ccLastMember;
    BOOL    fFoundLast;

    wcscpy(&wszCheck[0], pwszTag);
    wcscat(&wszCheck[0], L"=");

    wcscpy(&wszCheck2[0], pwszTag);
    wcscpy(&wszCheck2[0], L" =");

    this->PositionAtLastGroup();

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if (this->pwszCurrentLine[0] == L'[')
        {
            this->pwszCurrentLine[0] = NULL;

            return(FALSE);
        }

        if ((_memicmp(this->pwszCurrentLine, &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0) ||
            (_memicmp(this->pwszCurrentLine, &wszCheck2[0], wcslen(&wszCheck2[0]) * sizeof(WCHAR)) == 0))
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;

            this->EOLRemove();

            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;
    
    return(FALSE);
}

BOOL fParse_::FindTagFromCurrentPos(WCHAR *pwszTag)
{
    WCHAR   wszCheck[MAX_PATH];
    WCHAR   wszCheck2[MAX_PATH];
    LPWSTR  pwszEqual;
    DWORD   ccRet;
    DWORD   ccLastMember;
    BOOL    fFoundLast;

    wcscpy(&wszCheck[0], pwszTag);
    wcscat(&wszCheck[0], L"=");

    wcscpy(&wszCheck2[0], pwszTag);
    wcscat(&wszCheck2[0], L" =");

    this->dwLastTagFilePos++;

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if ((_memicmp(this->pwszCurrentLine, &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0) ||
            (_memicmp(this->pwszCurrentLine, &wszCheck2[0], wcslen(&wszCheck2[0]) * sizeof(WCHAR)) == 0))
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;

            this->EOLRemove();

            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;
    
    return(FALSE);
}

DWORD fParse_::GetNextLine(void)
{
    if (!(this->pwszCurrentLine) ||
        (this->hFile == INVALID_HANDLE_VALUE))
    {
        return(0);
    }

	DWORD   dwHold;
	DWORD   cbRead;
    DWORD   cwbRead;
	DWORD   dw;
    int     iAmt;
    BYTE    *pb;

    if ((dwHold = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    if (!(pb = new BYTE[dwMaxLine + 2]))
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(this->hFile, pb, dwMaxLine, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            this->fEOF = TRUE;

            delete pb;

            return(0);
        }

        pb[cbRead] = 0x00;

        this->fEOF = FALSE;

        if (cbRead > 0)
        {
            iAmt = 0;
		    for (dw = 0; dw < (cbRead - 1); dw++)
		    {
		    	if ((pb[dw] == 0x0d) || 
                    (pb[dw] == 0x0a))
		    	{
                    iAmt++;
		    		if (pb[dw + 1] == 0x0a)
		    		{
                        dw++;
                        iAmt++;
		    		}
            
                    if (SetFilePointer(this->hFile, dwHold + (dw + 1),
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        this->dwCurLineFilePos = 0;
                    }
                    else
                    {
                        this->dwCurLineFilePos = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT) - iAmt;
                    }
            
		    		pb[dw + 1] = 0x00;
            
                    cwbRead = MultiByteToWideChar(0, 0, (const char *)pb, -1, 
                                                    pwszCurrentLine, dwMaxLine);

                    delete pb;

		    		return(cwbRead + 1);
		    	}
		    }
        }
	}
	else
	{
        delete pb;

		return(0);
	}

	if (pb[cbRead - 1] == 0x1a)  /* EOF */
	{
		cbRead--;
        this->dwCurLineFilePos  = 0;
        this->fEOF              = TRUE;
	}
    else
    {
        this->dwCurLineFilePos  = dwHold;
    }

	pb[cbRead] = 0x00;

    cwbRead = MultiByteToWideChar(0, 0, (const char *)pb, -1, 
                                  pwszCurrentLine, dwMaxLine);


    delete pb;

	return(cwbRead);
}

void fParse_::EOLRemove(void)
{
	DWORD   i;
    DWORD   ccLen;

    ccLen = wcslen(this->pwszCurrentLine);

	for (i = 0; i < ccLen; i++)
	{
		if ((this->pwszCurrentLine[i] == (WCHAR)0x0a) || 
            (this->pwszCurrentLine[i] == (WCHAR)0x0d))
		{
			this->pwszCurrentLine[i] = NULL;
			return;
		}
	}
	this->pwszCurrentLine[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\ispudlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ispudlg.cpp
//
//  Contents:   Microsoft Internet Security Office Helper
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "ispudlg.hxx"

INT_PTR CALLBACK UIMessageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProcessingDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

ISPUdlg_::ISPUdlg_(HWND hWndParent, HINSTANCE hInst, DWORD dwDialogId)
{
    m_dwDialogId        = dwDialogId;
    m_hInst             = hInst;
    m_hWndParent        = hWndParent;
    m_hWndMe            = NULL;
    m_hrResult          = E_NOTIMPL;
    m_hDlgProcessing    = NULL;
}

ISPUdlg_::~ISPUdlg_(void)
{
    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
    }
}

HRESULT ISPUdlg_::Invoke(void)
{

    if (DialogBoxParam(m_hInst, MAKEINTRESOURCE(m_dwDialogId), m_hWndParent,
                       UIMessageProc, (LPARAM)this) == (-1))
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return(m_hrResult);
}

void ISPUdlg_::ShowError(HWND hWnd, DWORD dwStringId, DWORD dwTitleId)
{
    char    szTitle[MAX_PATH + 1];
    char    szErr[MAX_PATH + 1];

    LoadStringA(m_hInst, dwTitleId, &szTitle[0], MAX_PATH);
    LoadStringA(m_hInst, dwStringId, &szErr[0], MAX_PATH);

    MessageBeep(MB_ICONEXCLAMATION);

    MessageBox((hWnd) ? hWnd : m_hWndParent, &szErr[0], &szTitle[0],
                MB_OK | MB_ICONERROR);
}

void ISPUdlg_::StartShowProcessing(DWORD dwDialogId, DWORD dwTextControlId, DWORD dwStringId)
{
    char    szText[MAX_PATH + 1];

    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
    }

    szText[0] = NULL;
    LoadStringA(m_hInst, dwStringId, &szText[0], MAX_PATH);

    m_hDlgProcessing = CreateDialog(m_hInst, MAKEINTRESOURCE(dwDialogId), m_hWndParent,
                                    ProcessingDialogProc);

    this->Center(m_hDlgProcessing);

    ShowWindow(m_hDlgProcessing, SW_SHOW);

    SetDlgItemText(m_hDlgProcessing, dwTextControlId, &szText[0]);
}

void ISPUdlg_::ChangeShowProcessing(DWORD dwTextControlId, DWORD dwStirngId)
{
    if (!(m_hDlgProcessing))
    {
        return;
    }

    char    szText[MAX_PATH + 1];

    szText[0] = NULL;
    LoadStringA(m_hInst, dwStirngId, &szText[0], MAX_PATH);

    SetDlgItemText(m_hDlgProcessing, dwTextControlId, &szText[0]);
}

void ISPUdlg_::EndShowProcessing(void)
{
    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
        m_hDlgProcessing = NULL;
    }
}


BOOL ISPUdlg_::OnMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
                m_hWndMe = hWnd;

                this->Center();

                return(this->OnInitDialog(hWnd, wParam, lParam));

        case WM_COMMAND:
            return(this->OnCommand(hWnd, uMsg, wParam, lParam));

        case WM_CLOSE:
            return(this->OnCancel(hWnd));

        case WM_HELP:
            return(this->OnHelp(hWnd, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}

BOOL ISPUdlg_::OnOK(HWND hWnd)
{
    EndDialog(hWnd, (int)m_hrResult);

    return(TRUE);
}

BOOL ISPUdlg_::OnCancel(HWND hWnd)
{
    EndDialog(hWnd, (int)m_hrResult);

    return(TRUE);
}

void ISPUdlg_::Center(HWND hWnd2Center)
{
    RECT    rcDlg;
    RECT    rcArea;
    RECT    rcCenter;
    HWND    hWndParent;
    HWND    hWndCenter;
    DWORD   dwStyle;
    int     w_Dlg;
    int     h_Dlg;
    int     xLeft;
    int     yTop;

    if (!(hWnd2Center))
    {
        hWnd2Center = m_hWndMe;
    }

    GetWindowRect(hWnd2Center, &rcDlg);

    dwStyle = (DWORD)GetWindowLong(hWnd2Center, GWL_STYLE);

    if (dwStyle & WS_CHILD)
    {
        hWndCenter = GetParent(hWnd2Center);

        hWndParent = GetParent(hWnd2Center);

        GetClientRect(hWndParent, &rcArea);
        GetClientRect(hWndCenter, &rcCenter);
        MapWindowPoints(hWndCenter, hWndParent, (POINT *)&rcCenter, 2);
    }
    else
    {
        hWndCenter = GetWindow(hWnd2Center, GW_OWNER);

        if (hWndCenter)
        {
            dwStyle = (DWORD)GetWindowLong(hWndCenter, GWL_STYLE);

            if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
            {
                hWndCenter = NULL;
            }
        }

        SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

        if (hWndCenter)
        {
            GetWindowRect(hWndCenter, &rcCenter);
        }
        else
        {
            rcCenter = rcArea;
        }

    }

    w_Dlg   = rcDlg.right - rcDlg.left;
    h_Dlg   = rcDlg.bottom - rcDlg.top;

    xLeft   = (rcCenter.left + rcCenter.right) / 2 - w_Dlg / 2;
    yTop    = (rcCenter.top + rcCenter.bottom) / 2 - h_Dlg / 2;

    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if ((xLeft + w_Dlg) > rcArea.right)
    {
        xLeft = rcArea.right - w_Dlg;
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if ((yTop + h_Dlg) > rcArea.bottom)
    {
        yTop = rcArea.bottom - h_Dlg;
    }

    SetWindowPos(hWnd2Center, NULL, xLeft, yTop, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}

void ISPUdlg_::SetItemText(DWORD dwControlId, WCHAR *pwszText)
{
    DWORD   cbsz;
    char    *psz;

    cbsz = (DWORD)WideCharToMultiByte(0, 0, pwszText, wcslen(pwszText) + 1, NULL, 0, NULL, NULL);

    if (cbsz < 1)
    {
        return;
    }

    if (!(psz = new char[cbsz + 1]))
    {
        return;
    }
    psz[0] = NULL;

    WideCharToMultiByte(0, 0, pwszText, wcslen(pwszText) + 1, psz, cbsz, NULL, NULL);

    SetDlgItemText(m_hWndMe, (UINT)dwControlId, psz);

    delete psz;
}

BOOL ISPUdlg_::GetItemText(DWORD dwControlId, WCHAR **ppwszText)
{
    DWORD   cbsz;
    char    *psz;

    *ppwszText = NULL;

    cbsz = (DWORD)SendDlgItemMessage(m_hWndMe, (UINT)dwControlId, WM_GETTEXTLENGTH, 0, 0);

    if (cbsz < 1)
    {
        return(FALSE);
    }

    if (!(psz = new char[cbsz + 1]))
    {
        return(FALSE);
    }

    psz[0] = NULL;

    GetDlgItemText(m_hWndMe, (UINT)dwControlId, psz, cbsz + 1);

    if (!(*ppwszText = new WCHAR[cbsz + 1]))
    {
        delete psz;
        return(FALSE);
    }

    MultiByteToWideChar(0, 0, psz, -1, *ppwszText, cbsz + 1);

    delete psz;

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////
////
////    local
////

INT_PTR CALLBACK UIMessageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ISPUdlg_ *pUI;

    if (uMsg == WM_INITDIALOG)
    {
        pUI = (ISPUdlg_ *)lParam;

        SetWindowLongPtr(hWnd, DWLP_USER, (INT_PTR)lParam);
    }
    else
    {
        pUI = (ISPUdlg_ *)GetWindowLongPtr(hWnd, DWLP_USER);
    }

    if (!(pUI))
    {
        return(FALSE);
    }

    return(pUI->OnMessage(hWnd, uMsg, wParam, lParam));
}

INT_PTR CALLBACK ProcessingDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\printfu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printfu.cpp
//
//  Contents:   Unicode Console Printf's
//
//  History:    02-May-1997 xiaohs      created
//              06-May-1997 pberkman    converted to C++
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <stdio.h>
#include    <stdarg.h>

#include    "unicode.h"
#include    "gendefs.h"
#include    "printfu.hxx"


PrintfU_::PrintfU_(DWORD ccMaxString)
{
    hModule = GetModuleHandle(NULL);
    
    pwszDispString  = (WCHAR *)new BYTE[ccMaxString * sizeof(WCHAR)];
    pwszResString   = (WCHAR *)new BYTE[ccMaxString * sizeof(WCHAR)];

    ccMax = ccMaxString;
}

PrintfU_::~PrintfU_(void)
{
    DELETE_OBJECT(pwszDispString);
    DELETE_OBJECT(pwszResString);
}

void _cdecl PrintfU_::Display(DWORD dwFmt, ...)
{
    if (!(hModule) || !(pwszDispString) || !(pwszResString))
    {
        return;
    }

    va_list    vaArgs;

    va_start(vaArgs, dwFmt);

    vwprintf(this->get_String(dwFmt, pwszDispString, ccMax), vaArgs);

    va_end(vaArgs);
}

WCHAR *PrintfU_::get_String(DWORD dwID, WCHAR *pwszRet, DWORD ccRet)
{
    if (!(hModule) || !(pwszDispString) || !(pwszResString))
    {
        return(NULL);
    }

    if (!(pwszRet))
    {
        pwszRet = pwszResString;
        ccRet   = ccMax;
    }

    LoadStringU(hModule, dwID, pwszRet, ccRet);

    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\common\stack.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Stack.cpp
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "Stack.hxx"

Stack_::Stack_(CRITICAL_SECTION *pCS)
{
    dwStackCount            = 0;
    psBottom                = NULL;
    ppsSorted               = NULL;
    ppsGet                  = NULL;
    pSortCriticalSection    = pCS;
}

Stack_::~Stack_(void)
{
    if (psBottom)
    {
        StackStruct_    *psCurrent;

        for (;;)
        {
            psCurrent = psBottom->psNext;

            delete psBottom->pvData;
            delete psBottom;

            psBottom    = psCurrent;

            if (!(psBottom))
            {
                break;
            }
        }
    }

    DELETE_OBJECT(ppsSorted);

    FlushGetStack();
}

BOOL Stack_::Add(DWORD cbData, void *pvData)
{
    BYTE    *pb;

    if (pb = (BYTE *)this->Add(cbData))
    {
        memcpy(pb, pvData, cbData);
        return(TRUE);
    }

    return(FALSE);
}

void *Stack_::Add(DWORD cbData)
{
    StackStruct_    *psWork;

    psWork = new StackStruct_;

    if (!(psWork))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    psWork->psNext = psBottom;

    psWork->pvData = new BYTE[cbData];

    if (!(psWork->pvData))
    {
        delete psWork;

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    psWork->cbData = cbData;

    psBottom = psWork;

    dwStackCount++;

    FlushGetStack();

    return((void *)psWork->pvData);
}

void *Stack_::Get(DWORD dwPosition, DWORD *cbData)
{
    DWORD           i;
    StackStruct_    *psRet;

    if (!(psBottom))
    {
        return(NULL);
    }

    if (dwPosition > (dwStackCount - 1))
    {
        return(NULL);
    }

    if ( InitGetStackIfNecessary() == TRUE )
    {
        DWORD Index = dwPosition;

        if ( cbData != NULL )
        {
            *cbData = ppsGet[ Index ]->cbData;
        }

        return( ppsGet[ Index ]->pvData );
    }

    psRet = psBottom;

    if (cbData)
    {
        *cbData = 0;
    }

    for (i = 0; i < dwPosition; i++)
    {
        psRet = psRet->psNext;
    }

    if ((psRet) && (psRet->pvData))
    {
        if (cbData)
        {
            *cbData = psRet->cbData;
        }

        return(psRet->pvData);
    }

    return(NULL);
}

void *Stack_::Get(DWORD cbStartIn_pvData, DWORD cbLengthIn_pvData, BYTE fbType, void *pvMemberOf_pvData)
{
    DWORD   dwEnd;
    DWORD   dwMiddle;
    DWORD   dwStart;
    DWORD   dwHalf;
    DWORD   dwCur;
    void    *pv;
    int     cmp;

    dwStart     = 0;
    dwEnd       = this->Count();
    dwHalf = dwMiddle    = dwEnd / 2L;
    dwCur       = 0;

    for EVER
    {
        if (dwCur++ > this->Count())
        {
            break;
        }

        pv = this->Get(dwMiddle);

        if (!(pv))
        {
            break;
        }

        switch (fbType)
        {
	    case STACK_SORTTYPE_PWSZ:
                cmp = wcscmp(*(WCHAR **)((BYTE *)pv + cbStartIn_pvData), (WCHAR *)pvMemberOf_pvData);
                break;

            case STACK_SORTTYPE_PSZ:
                cmp = strcmp(*(char **)((BYTE *)pv + cbStartIn_pvData), (char *)pvMemberOf_pvData);
                break;

	    case STACK_SORTTYPE_PWSZ_I:
		cmp = _wcsicmp(*(WCHAR **)((BYTE *)pv + cbStartIn_pvData), (WCHAR *)pvMemberOf_pvData);
                break;

	    case STACK_SORTTYPE_PSZ_I:
		cmp = _stricmp(*(char **)((BYTE *)pv + cbStartIn_pvData), (char *)pvMemberOf_pvData);
                break;

            default:
                cmp = memcmp((BYTE *)pv + cbStartIn_pvData, (BYTE *)pvMemberOf_pvData, cbLengthIn_pvData);
                break;
        }

        if (cmp == 0)
        {
            return(pv);
        }

        if ((dwMiddle == 0) || (dwMiddle == this->Count()) ||
            ((dwHalf == 0) && (dwMiddle == dwStart)))
        {
            break;
        }

        if (cmp < 0)
        {
            dwEnd   = dwMiddle;
        }
        else
        {
            dwStart = dwMiddle;
        }

        dwHalf      = (dwEnd - dwStart) / 2L;
        dwMiddle    = dwStart + dwHalf;
    }

    return(NULL);
}

static DWORD            cbSortOffset;
static DWORD            cbSortLength;
static BYTE             fbType;

int __cdecl Stack_compare(const void *arg1, const void *arg2)
{
    StackStruct_    **p1 = (StackStruct_ **)arg1;
    StackStruct_    **p2 = (StackStruct_ **)arg2;

    switch (fbType)
    {
	case STACK_SORTTYPE_PWSZ:
                return(wcscmp(*(WCHAR **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(WCHAR **)((BYTE *)(*p2)->pvData + cbSortOffset)));


        case STACK_SORTTYPE_PSZ:
                return(strcmp(*(char **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(char **)((BYTE *)(*p2)->pvData + cbSortOffset)));

	case STACK_SORTTYPE_PWSZ_I:
		return(_wcsicmp(*(WCHAR **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(WCHAR **)((BYTE *)(*p2)->pvData + cbSortOffset)));


	case STACK_SORTTYPE_PSZ_I:
		return(_stricmp(*(char **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(char **)((BYTE *)(*p2)->pvData + cbSortOffset)));

        case STACK_SORTTYPE_BINARY:
        default:
            break;
    }

    return(memcmp((void **)((BYTE *)(*p1)->pvData + cbSortOffset),
                  (void **)((BYTE *)(*p2)->pvData + cbSortOffset), cbSortLength));
}

void Stack_::Sort(DWORD cbOffset_pvData, DWORD cbLength_pvData, BYTE fbTypeIn)
{
    int     i;

    if (!(psBottom))
    {
        return;
    }

    //
    //  assign out offset & length for compare function
    //
    DELETE_OBJECT(ppsSorted);   // wipe the last one.

    if (!(ppsSorted = new StackStruct_ * [this->Count()]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    //
    //  assign the contiguous array to be sorted.
    //
    ppsSorted[0] = psBottom;

    for (i = 1; i < (int)this->Count(); i++)
    {
        ppsSorted[i] = ppsSorted[i - 1]->psNext;
    }

    //
    //  let's do the sort!
    //

    EnterCriticalSection(pSortCriticalSection);

    cbSortOffset    = cbOffset_pvData;
    cbSortLength    = cbLength_pvData;
    fbType          = fbTypeIn;

    qsort( (void *)ppsSorted, (size_t)this->Count(), sizeof(StackStruct_ *), Stack_compare);

    LeaveCriticalSection(pSortCriticalSection);

    //
    //  now, we need to adjust out psNext's
    //

    for (i = 0; i < (int)(this->Count() - 1); i++)
    {
        ppsSorted[i]->psNext = ppsSorted[i + 1];
    }

    ppsSorted[i]->psNext = NULL;

    psBottom = ppsSorted[0];

    FlushGetStack();
}

BOOL Stack_::InitGetStackIfNecessary ()
{
    DWORD         cCount;
    StackStruct_* psGet;

    if ( ppsGet != NULL )
    {
        return( TRUE );
    }

    ppsGet = new StackStruct_ * [ dwStackCount ];

    if ( ppsGet == NULL )
    {
        return( FALSE );
    }

    psGet = psBottom;

    for ( cCount = 0; cCount < dwStackCount; cCount++ )
    {
        ppsGet[ cCount ] = psGet;
        psGet = psGet->psNext;
    }

    return( TRUE );
}

VOID Stack_::FlushGetStack ()
{
    delete ppsGet;
    ppsGet = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\initacl.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       initacl.cpp
//
//  Contents:   Initialize ACLs so that Everyone only has KEY_READ access
//              for the following REGPATHs:
//                  HKLM\Software\Microsoft\Cryptography\OID ..
//                  HKLM\Software\Microsoft\Cryptography\Providers\Trust ..
//                  HKLM\Software\Microsoft\Cryptography\Services ...
//                  HKLM\Software\Microsoft\SystemCertificates ..
//                  HKLM\Software\Policies\Microsoft\SystemCertificates ..
//                  HKLM\Software\Microsoft\EnterpriseCertificates ..
//
//              Initialize ACLS so that Everyone has KEY_READ and KEY_SET_VALUE
//              access for the following REGPATH:
//                  HKLM\Software\Microsoft\Cryptography\IEDirtyFlags
//
//  Functions:  InitializeHKLMAcls
//
//  Note:       By default HKLM\Software ... gives Everyone special access.
//              Special access includes: KEY_READ, KEY_WRITE, DELETE
//
//  History:    08-May-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


static const LPCWSTR rgpwszHKLMRegPath[] = {
    OID_REGPATH,
    PROVIDERS_REGPATH,
    SERVICES_REGPATH,
    SYSTEM_STORE_REGPATH,
    GROUP_POLICY_STORE_REGPATH,
    ENTERPRISE_STORE_REGPATH,
};

#define HKLM_REGPATH_CNT    (sizeof(rgpwszHKLMRegPath) / \
                                sizeof(rgpwszHKLMRegPath[0]))


//+-------------------------------------------------------------------------
//  Predefined SIDs allocated once by GetPredefinedSids. Freed when
//  InitializeHKLMAcls() returns
//--------------------------------------------------------------------------
static PSID psidLocalSystem = NULL;
static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

//+-------------------------------------------------------------------------
//  ACL definitions used to set security on the HKLM registry keys
//--------------------------------------------------------------------------
#define HKLM_SYSTEM_ACE_MASK        KEY_ALL_ACCESS
#define HKLM_ADMIN_ACE_MASK         KEY_ALL_ACCESS
#define HKLM_EVERYONE_ACE_MASK      KEY_READ
#define HKLM_ACE_FLAGS              CONTAINER_INHERIT_ACE

#define HKLM_ACE_COUNT              3
#define HKLM_SYSTEM_ACE_INDEX       0
#define HKLM_ADMIN_ACE_INDEX        1
#define HKLM_EVERYONE_ACE_INDEX     2

//+-------------------------------------------------------------------------
//  Maximum allowed access rights for Everyone in HKLM
//--------------------------------------------------------------------------
#define MAX_HKLM_EVERYONE_ACE_MASK  (KEY_READ | GENERIC_READ)

//+-------------------------------------------------------------------------
//  Access rights for Everyone on the CERT_IE_DIRTY_FLAGS registry SubKey
//--------------------------------------------------------------------------
#define IE_EVERYONE_ACE_MASK        (KEY_READ | KEY_SET_VALUE)


//+-------------------------------------------------------------------------
//  Allocate/free predefined SIDs
//--------------------------------------------------------------------------
STATIC BOOL GetPredefinedSids()
{
    BOOL fResult;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) 
        goto AllocateAndInitializeSidError;

    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            ))
        goto AllocateAndInitializeSidError;

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            ))
        goto AllocateAndInitializeSidError;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
}

STATIC void FreePredefinedSids()
{
    FreeSid(psidLocalSystem);
    FreeSid(psidAdministrators);
    FreeSid(psidEveryone);

}

#define HKLM_SD_LEN         0x1000

//+-------------------------------------------------------------------------
//  Allocate and get the security descriptor information for the specified
//  registry key.
//--------------------------------------------------------------------------
STATIC PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd;

    cbsd = HKLM_SD_LEN;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            );
    if (ERROR_SUCCESS == err)
        goto CommonReturn;
    if (ERROR_INSUFFICIENT_BUFFER != err)
        goto RegGetKeySecurityError;

    if (0 == cbsd)
        goto NoSecurityDescriptor;

    PkiFree(psd);
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) goto RegGetKeySecurityError;

CommonReturn:
    return psd;
ErrorReturn:
    PkiFree(psd);
    psd = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegGetKeySecurityError, err)
SET_ERROR(NoSecurityDescriptor, ERROR_INVALID_SECURITY_DESCR)
}


//+-------------------------------------------------------------------------
//  Checks that "Everyone" doesn't have more than KEY_READ or GENERIC_READ
//  access rights. If valid, returns TRUE.
//--------------------------------------------------------------------------
STATIC BOOL IsValidHKLMAccessRights(
    IN HKEY hKey
    )
{
    BOOL fResult;
    PSECURITY_DESCRIPTOR psd = NULL;
    BOOL fDaclPresent;
    PACL pAcl;                      // not allocated
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;

    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKey,
            DACL_SECURITY_INFORMATION
            ))) goto GetSecurityDescriptorError;

    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted))
        goto GetSecurityDescriptorDaclError;
    if (!fDaclPresent || NULL == pAcl || 0 == pAcl->AceCount)
        goto MissingDaclError;

    for (dwAceIndex = 0; dwAceIndex < pAcl->AceCount; dwAceIndex++) {
        PACCESS_ALLOWED_ACE pAce;

        if (!GetAce(pAcl, dwAceIndex, (void **) &pAce))
            goto GetAceError;

        if (ACCESS_ALLOWED_ACE_TYPE != pAce->Header.AceType)
            continue;
        if (!EqualSid(psidEveryone, (PSID) &pAce->SidStart))
            continue;

        if (0 != (pAce->Mask & ~MAX_HKLM_EVERYONE_ACE_MASK))
            goto InvalidEveryoneAccess;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(psd);
    return fResult;
InvalidEveryoneAccess:
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSecurityDescriptorError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
SET_ERROR(MissingDaclError, ERROR_INVALID_ACL)
TRACE_ERROR(GetAceError)
}


//+-------------------------------------------------------------------------
//  Create the SecurityDescriptor to be used for HKLM SubKeys
//--------------------------------------------------------------------------
STATIC BOOL CreateHKLMSecurityDescriptor(
    IN ACCESS_MASK EveryoneAccessMask,
    OUT PSECURITY_DESCRIPTOR psd,
    OUT PACL *ppDacl
    )
{
    BOOL fResult;
    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;


    // Set DACL

    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        HKLM_ACE_COUNT * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidLocalSystem) +
        GetLengthSid(psidAdministrators) +
        GetLengthSid(psidEveryone)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            HKLM_SYSTEM_ACE_MASK,
            psidLocalSystem
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            HKLM_ADMIN_ACE_MASK,
            psidAdministrators
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            EveryoneAccessMask,
            psidEveryone
            ))
        goto AddAceError;

    //
    // make containers inherit.
    //
    for (i = 0; i < HKLM_ACE_COUNT; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce))
            goto GetAceError;
        pAce->Header.AceFlags = HKLM_ACE_FLAGS;
    }

    if (!SetSecurityDescriptorDacl(psd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;

    fResult = TRUE;
CommonReturn:
    *ppDacl = pDacl;
    return fResult;
ErrorReturn:
    PkiFree(pDacl);
    pDacl = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
}

//+-------------------------------------------------------------------------
//  Set the DACL for the SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetHKLMDacl(
    IN HKEY hKey,
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fResult;
    LONG err;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKey,
            DACL_SECURITY_INFORMATION,
            psd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetKeySecurityError, err)
}

STATIC BOOL GetSubKeyInfo(
    IN HKEY hKey,
    OUT OPTIONAL DWORD *pcSubKeys,
    OUT OPTIONAL DWORD *pcchMaxSubKey = NULL
    )
{
    BOOL fResult;
    LONG err;
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            pcSubKeys,
            pcchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            ))) goto RegQueryInfoKeyError;
    fResult = TRUE;

CommonReturn:
    // For Win95 Remote Registry Access:: returns half of the cch
    if (pcchMaxSubKey && *pcchMaxSubKey)
        *pcchMaxSubKey = (*pcchMaxSubKey + 1) * 2 + 2;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pcSubKeys)
        *pcSubKeys = 0;
    if (pcchMaxSubKey)
        *pcchMaxSubKey = 0;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
}

//+-------------------------------------------------------------------------
//  Check the HKEY for valid access rights for Everyone. If not valid, set
//  the HKEY's DACL. Enumerate the HKEY's SubKeys and recursively call.
//--------------------------------------------------------------------------
STATIC BOOL RecursiveInitializeHKLMSubKeyAcls(
    IN HKEY hKey,
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fResult = TRUE;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    LPWSTR pwszSubKey = NULL;

    if (!IsValidHKLMAccessRights(hKey))
        fResult &= SetHKLMDacl(hKey, psd);

    if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        return FALSE;

    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        cchMaxSubKey++;
        if (NULL == (pwszSubKey = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchSubKey = cchMaxSubKey;
            LONG err;
            HKEY hSubKey;

            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszSubKey,
                    &cchSubKey,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchSubKey ||
                            L'\0' == *pwszSubKey)
                continue;

            if (ERROR_SUCCESS != (err = RegOpenKeyExU(
                    hKey,
                    pwszSubKey,
                    0,                      // dwReserved
                    KEY_READ | WRITE_DAC,
                    &hSubKey))) {
#if DBG
                DbgPrintf(DBG_SS_CRYPT32,
                    "RegOpenKeyEx(%S) returned error: %d 0x%x\n",
                    pwszSubKey, err, err);
#endif
            } else {
                fResult &= RecursiveInitializeHKLMSubKeyAcls(hSubKey, psd);
                RegCloseKey(hSubKey);
            }
        }
    }

CommonReturn:
    PkiFree(pwszSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Initialize the HKLM registry used by crypt32 so that Everyone only has
//  KEY_READ access rights.
//
//  Initialize the IEDirtyFlags registry key so that Everyone has KEY_READ
//  and KEY_SET_VALUE access rights.
//--------------------------------------------------------------------------
BOOL
InitializeHKLMAcls()
{
    BOOL fResult = TRUE;
    SECURITY_DESCRIPTOR sd;
    PACL pDacl = NULL;
    SECURITY_ATTRIBUTES SecAttr;

    HKEY hKey;
    LONG err;
    DWORD dwDisposition;
    DWORD i;

    if (!FIsWinNT())
        return TRUE;

    if (!GetPredefinedSids())
        return FALSE;

    if (!CreateHKLMSecurityDescriptor(
            HKLM_EVERYONE_ACE_MASK,
            &sd,
            &pDacl
            ))
        goto ErrorReturn;

    memset(&SecAttr, 0, sizeof(SecAttr));
    SecAttr.nLength = sizeof(SecAttr);
    SecAttr.lpSecurityDescriptor = (LPVOID) &sd;
    SecAttr.bInheritHandle = FALSE;


    // Iterate through the HKLM registry locations used by crypt32. If
    // the registry key doesn't exist, create it and give Everyone READ_KEY
    // access. Otherwise, recurse through its SubKeys.  For SubKeys having
    // more than KEY_READ access rights for Everyone, set their ACLs giving
    // only KEY_READ access to Everyone.

    for (i = 0; i < HKLM_REGPATH_CNT; i++) {
        if (ERROR_SUCCESS != (err = RegCreateKeyExU(
                HKEY_LOCAL_MACHINE,
                rgpwszHKLMRegPath[i],
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED,
                &SecAttr,
                &hKey,
                &dwDisposition))) {
#if DBG
            DbgPrintf(DBG_SS_CRYPT32,
                "RegCreateKeyEx(HKLM\\%S) returned error: %d 0x%x\n",
                rgpwszHKLMRegPath[i], err, err);
#endif
            fResult = FALSE;
            continue;
        }

        if (REG_CREATED_NEW_KEY != dwDisposition)
            fResult &= RecursiveInitializeHKLMSubKeyAcls(hKey, &sd);

        RegCloseKey(hKey);
    }
    PkiFree(pDacl);

    // Allow Everyone to have KEY_READ and KEY_SET_VALUE access to
    // the IEDirtyFlags registry key
    if (!CreateHKLMSecurityDescriptor(
            IE_EVERYONE_ACE_MASK,
            &sd,
            &pDacl
            ))
        goto ErrorReturn;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_IE_DIRTY_FLAGS_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            &SecAttr,
            &hKey,
            &dwDisposition))) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "RegCreateKeyEx(HKLM\\%S) returned error: %d 0x%x\n",
            CERT_IE_DIRTY_FLAGS_REGPATH, err, err);
#endif
        fResult = FALSE;
    } else {
        if (REG_CREATED_NEW_KEY != dwDisposition)
            fResult &= SetHKLMDacl(hKey, &sd);
        RegCloseKey(hKey);
    }
    PkiFree(pDacl);

CommonReturn:
    FreePredefinedSids();
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security 
//
//  History:    09-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define OID_REGPATH             L"Software\\Microsoft\\Cryptography\\OID"
#define PROVIDERS_REGPATH       L"Software\\Microsoft\\Cryptography\\Providers\\Trust"
#define SERVICES_REGPATH        L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_STORE_REGPATH    L"Software\\Microsoft\\SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH L"Software\\Microsoft\\EnterpriseCertificates"

#define ROOT_STORE_REGPATH      L"Software\\Microsoft\\SystemCertificates\\Root"

//
//  initpki.cpp
//
extern HMODULE      hModule;

extern BOOL WINAPI InitializePKI(void);
extern HRESULT RegisterCryptoDlls(BOOL fSetFlags);
extern HRESULT UnregisterCryptoDlls(void);

void RegisterWinlogonExtension(
    IN LPCSTR pszSubKey,
    IN LPCSTR pszDll,
    IN LPCSTR pszProc
    );

void RegisterCrypt32EventSource();

//
//  initacl.cpp
//
extern BOOL InitializeHKLMAcls();

//
//  pkireg.cpp
//
typedef struct POLSET_
{
    DWORD       dwSetting;
    BOOL        fOn;

} POLSET;

extern POLSET   psPolicySettings[];

extern void CleanupRegistry(void);
extern BOOL _LoadAndRegister(char *pszDll, BOOL fUnregister);
extern BOOL _AdjustPolicyFlags(POLSET *pPolSet);




//
//  mvcerts.cpp
//
extern HRESULT  MoveCertificates(BOOL fDelete);
extern BOOL     TestIE30Store(HKEY hRegRoot, LPCSTR psLoc);
extern HRESULT  TransferIE30Certificates(HKEY hRegRoot, LPCSTR psLoc, HCERTSTORE hStore, BOOL fDelete);

#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\initpki.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       initpki.cpp
//
//  Contents:   migrates Bob Store to SPC store and adds root certificates
//
//  History:    03-Jun-97    kirtd    Created
//
//----------------------------------------------------------------------------

#include "global.hxx"
#include "cryptreg.h"
#include "..\mscat32\mscatprv.h"

HMODULE hModule = NULL;


//////////////////////////////////////////////////////////////////

#define INITPKI_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))


#define SHA1_HASH_LENGTH     20


#define wsz_ROOT_STORE      L"Root"
#define wsz_TRUST_STORE     L"Trust"
#define wsz_CA_STORE        L"CA"
#define wsz_TRUST_PUB_STORE L"TrustedPublisher"
#define wsz_DISALLOWED_STORE L"Disallowed"
static LPCWSTR rgpwszPredefinedEnterpriseStore[] = {
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_TRUST_PUB_STORE,
    wsz_DISALLOWED_STORE
};
#define NUM_PREDEFINED_ENTERPRISE_STORE \
    (sizeof(rgpwszPredefinedEnterpriseStore) / \
        sizeof(rgpwszPredefinedEnterpriseStore[0]))

void RegisterEnterpriseStores()
{
    DWORD i;

    for (i = 0; i < NUM_PREDEFINED_ENTERPRISE_STORE; i++) {
        CertRegisterSystemStore(
            rgpwszPredefinedEnterpriseStore[i],
            CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
            NULL,           // pSystemStoreInfo
            NULL            // pvReserved
            );
    }
}

void RemoveCert(HCERTSTORE hStore, BYTE *pThumbPrint)
{
    PCERT_CONTEXT   pCertContext;
    CRYPT_HASH_BLOB CryptHashBlob;

    CryptHashBlob.cbData    = SHA1_HASH_LENGTH;
    CryptHashBlob.pbData    = pThumbPrint;

    pCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(  hStore,
                                                X509_ASN_ENCODING,
                                                0,
                                                CERT_FIND_SHA1_HASH,
                                                &CryptHashBlob,
                                                NULL);
    if (pCertContext)
    {
        CertDeleteCertificateFromStore(pCertContext);
    }
}

//
// if byte 0 is null, make sure to change while loop below!
//
BYTE CertRemoveList[][SHA1_HASH_LENGTH] =
{
    { 0x4B, 0x33, 0x8D, 0xCD, 0x50, 0x18, 0x10, 0xB9, 0x36, 0xA0,
      0x63, 0x61, 0x4C, 0x3C, 0xDD, 0x3F, 0xC2, 0xC4, 0x88, 0x55 },     // GTE Glue - '96

    { 0x56, 0xB0, 0x65, 0xA7, 0x4B, 0xDC, 0xE3, 0x7C, 0x96, 0xD3,
      0xBA, 0x69, 0x81, 0x08, 0x02, 0xD5, 0x87, 0x03, 0xC0, 0xBD },     // Verisign Comm Glue - '96

    { 0x13, 0x39, 0x72, 0xAA, 0x97, 0xD3, 0x65, 0xFB, 0x6A, 0x1D,
      0x47, 0xA5, 0xC7, 0x7A, 0x5C, 0x03, 0x94, 0xBD, 0xB9, 0xED },     // Verisign Indv Glue - '96

    { 0x69, 0xD0, 0x4F, 0xFB, 0x62, 0xE1, 0xC9, 0xAE, 0x30, 0x76,
      0x99, 0x2A, 0xE7, 0x46, 0xFD, 0x69, 0x08, 0x3A, 0xBD, 0xE9 },     // MS Root cert - '96

    { 0xA7, 0xD7, 0xD5, 0xFD, 0xBB, 0x26, 0xB4, 0x10, 0xC1, 0xD6,
      0x7A, 0xFB, 0xF5, 0xC9, 0x05, 0x39, 0x42, 0xDE, 0xE0, 0xEF },     // MS SGC Root Authority - '99

//    { 0xCC, 0x7E, 0xD0, 0x77, 0xF0, 0xF2, 0x92, 0x59, 0x5A, 0x81,
//      0x66, 0xB0, 0x17, 0x09, 0xE2, 0x0C, 0x08, 0x84, 0xA5, 0xF8 },     // verisign "Class1" - '97
//
//    { 0xD4, 0x73, 0x5D, 0x8A, 0x9A, 0xE5, 0xBC, 0x4B, 0x0A, 0x0D,
//      0xC2, 0x70, 0xD6, 0xA6, 0x25, 0x38, 0xA5, 0x87, 0xD3, 0x2F },     // verisign "timestamp" - '97
//
//    { 0x68, 0x8B, 0x6E, 0xB8, 0x07, 0xE8, 0xED, 0xA5, 0xC7, 0xB1,
//      0x7C, 0x43, 0x93, 0xD0, 0x79, 0x5F, 0x0F, 0xAE, 0x15, 0x5F },     // verisign "commercial" - '97
//
//    { 0xB1, 0x9D, 0xD0, 0x96, 0xDC, 0xD4, 0xE3, 0xE0, 0xFD, 0x67, 
//      0x68, 0x85, 0x50, 0x5A, 0x67, 0x2C, 0x43, 0x8D, 0x4E, 0x9C },     // verisign "individual" - '97


    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }      // term

};

//+---------------------------------------------------------------------------
//
//  Function:   PurgeExpiringCertsFromStores
//
//  Synopsis:   blech!
//
//----------------------------------------------------------------------------
HRESULT PurgeExpiringCertsFromStores ()
{
    DWORD       cRemove;
    DWORD       cStores;
    HCERTSTORE  hStore = NULL;
    HKEY        hKey = NULL;
    char        *pszStores[] = { "SPC", "ROOT", "CU_ROOT", NULL };

    //
    //  HACKHACK!  no crypt32 UI about the root store.
    //
    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER, ROOT_STORE_REGPATH, 
                            0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

    cStores = 0;

    while (pszStores[cStores])
    {
        if (strcmp(pszStores[cStores], "CU_ROOT") == 0)
        {
            if (hKey)
                hStore = CertOpenStore(CERT_STORE_PROV_REG, 0, NULL, 0, (LPVOID)hKey);
            else
                hStore = NULL;
        }
        else
        {
            hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, NULL,
                                   CERT_SYSTEM_STORE_LOCAL_MACHINE |
                                   CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                   pszStores[cStores]);
        }

        if (hStore)
        {
            cRemove = 0;
            while (CertRemoveList[cRemove][0] != 0x00)
            {
                if (hStore)
                {
                    RemoveCert(hStore, &CertRemoveList[cRemove][0]);
                }

                cRemove++;
            }
            
            CertCloseStore(hStore, 0);
        }

        cStores++;
    }

    if (hKey)
        RegCloseKey(hKey);
    return( S_OK );
}

PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL IsCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert)) {
        CertFreeCertificateContext(pOtherCert);
        return TRUE;
    } else
        return FALSE;
}

void DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        CertDeleteCertificateFromStore(pOtherCert);
}


//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from memory and copy to the specified cert store.
//
//  Except for the SPC being loaded from memory, identical to SpcReadSpcFile.
//
//  For hLMStore != NULL: if the certificate or CRL already exists in the
//  LocalMachine store don't add it. Also if it exists in hCertstore,
//  delete it.
//--------------------------------------------------------------------------
HRESULT
SpcReadSpcFromMemory(
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags,
    IN OPTIONAL HCERTSTORE hLMStore
    )
{
    HRESULT hr = S_OK;
    HCERTSTORE hSpcStore = NULL;
    CRYPT_DATA_BLOB sSpcBlob;
    HCRYPTPROV hCryptProv = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;

    if (!(hCertStore))
    {
        goto InvalidArg;
    }

    // Set the blob data.
    sSpcBlob.pbData = pbData;
    sSpcBlob.cbData = cbData;


    // Open up the spc store
    hSpcStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED, //CERT_STORE_PROV_PKCS7,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              &sSpcBlob);
    if (!hSpcStore)
    {
        goto CertStoreError;
    }

    // Copy in the certificates from the caller.
    while (pCert = CertEnumCertificatesInStore(hSpcStore, pCert))
    {
        if (hLMStore && IsCertificateInOtherStore(hLMStore, pCert))
            // Certificate exists in LocalMachine. Delete it from
            // CurrentUser if it already exists there.
            DeleteCertificateFromOtherStore(hCertStore, pCert);
        else
            CertAddCertificateContextToStore(hCertStore,
                                             pCert,
                                             CERT_STORE_ADD_REPLACE_EXISTING,
                                             NULL);
    }

    while (pCrl = CertEnumCRLsInStore(hSpcStore, pCrl))
    {
        CertAddCRLContextToStore(hCertStore,
                                 pCrl,
                                 CERT_STORE_ADD_NEWER,
                                 NULL);

        if (hLMStore) {
            // Check if newer or same CRL exists in the hLMStore
            PCCRL_CONTEXT pLMCrl;

            pLMCrl = CertFindCRLInStore(
                hLMStore,
                pCrl->dwCertEncodingType,
                0,                          // dwFindFlags
                CRL_FIND_EXISTING,
                (const void *) pCrl,
                NULL                        // pPrevCrlContext
                );

            if (NULL != pLMCrl) {
                PCCRL_CONTEXT pCUCrl;

                pCUCrl = CertFindCRLInStore(
                    hCertStore,
                    pCrl->dwCertEncodingType,
                    0,                          // dwFindFlags
                    CRL_FIND_EXISTING,
                    (const void *) pCrl,
                    NULL                        // pPrevCrlContext
                    );

                if (NULL != pCUCrl) {
                    if (0 <= CompareFileTime(
                            &pLMCrl->pCrlInfo->ThisUpdate,
                            &pCUCrl->pCrlInfo->ThisUpdate
                            ))
                        CertDeleteCRLFromStore(pCUCrl);
                    else
                        CertFreeCRLContext(pCUCrl);
                }

                CertFreeCRLContext(pLMCrl);
            }
        }
    }
    

    CommonReturn:
        if (hSpcStore)
        {
            CertCloseStore(hSpcStore, 0);
        }
        return(hr);

    ErrorReturn:
        SetLastError((DWORD)hr);
        goto CommonReturn;

    SET_HRESULT_EX(DBG_SS, InvalidArg, E_INVALIDARG);
    SET_HRESULT_EX(DBG_SS, CertStoreError, GetLastError());
}

// For nonNULL pszLMStoreName, doesn't add certificates if already in
// pszLMStoreName store.
HRESULT AddCertificates2(
    IN LPCSTR pszStoreName,
    IN OPTIONAL LPCSTR pszLMStoreName,
    IN DWORD dwOpenStoreFlags,
    IN LPCSTR pszResourceName,
    IN LPCSTR pszResourceType
    )
{
    HRESULT    hr = S_OK;
    HCERTSTORE hCertStore = NULL;
    HCERTSTORE hLMStore = NULL;
    LPBYTE     pb = NULL;
    DWORD      cb;
    HRSRC      hrsrc;

    hCertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_A,
        0,                                  // dwEncodingType
        NULL,                               // hCryptProv
        dwOpenStoreFlags |
            CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
        (const void *) pszStoreName
        );

    if (!(hCertStore))
    {
        return(GetLastError());
    }

    if (NULL != pszLMStoreName)
    {
        hLMStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_A,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE |
                CERT_STORE_READONLY_FLAG |
                CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
            (const void *) pszLMStoreName
            );
    }


    hrsrc = FindResourceA(hModule, pszResourceName, pszResourceType);
    if ( hrsrc != NULL )
    {
        HGLOBAL hglobRes;

        hglobRes = LoadResource(hModule, hrsrc);
        if ( hglobRes != NULL )
        {
            ULONG cbRes;
            BYTE* pbRes;

            cbRes = SizeofResource(hModule, hrsrc);
            pbRes = (BYTE *)LockResource(hglobRes);

            hr = SpcReadSpcFromMemory(  pbRes,
                                        cbRes,
                                        hCertStore,
                                        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                        0,
                                        hLMStore);

            UnlockResource(hglobRes);
            FreeResource(hglobRes);

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if ( hCertStore != NULL )
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    if ( hLMStore != NULL )
    {
        CertCloseStore(hLMStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return( hr );
}


// For non-LocalMachine store, doesn't add certificates if already in
// corresponding LocalMachine store.
HRESULT AddCertificates(
    IN LPCSTR pszStoreName,
    IN DWORD dwOpenStoreFlags,
    IN LPCSTR pszResourceName,
    IN LPCSTR pszResourceType
    )
{
    LPCSTR pszLMStoreName;

    if (CERT_SYSTEM_STORE_LOCAL_MACHINE !=
            (dwOpenStoreFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
        pszLMStoreName = pszStoreName;
    else
        pszLMStoreName = NULL;

    return AddCertificates2(
        pszStoreName,
        pszLMStoreName,
        dwOpenStoreFlags,
        pszResourceName,
        pszResourceType
        );
}

HRESULT AddCurrentUserCACertificates()
{
    return AddCertificates(
        "CA",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_CAS),
        "CAS"
        );
}
HRESULT AddLocalMachineCACertificates()
{
    return AddCertificates(
        "CA",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_CAS),
        "CAS"
        );
}

HRESULT AddCurrentUserDisallowedCertificates()
{
    return AddCertificates(
        "Disallowed",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_DISALLOW),
        "DISALLOW"
        );
}
HRESULT AddLocalMachineDisallowedCertificates()
{
    return AddCertificates(
        "Disallowed",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_DISALLOW),
        "DISALLOW"
        );
}

HRESULT AddCurrentUserRootCertificates()
{
    HRESULT hr;
    HRESULT hr2;

    hr = AddCertificates(
        "Root",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    hr2 = AddCertificates2(
        "Root",
        "AuthRoot",                     // check if already in LM AuthRoot store
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    if (hr == ERROR_SUCCESS)
        hr = hr2;

    return hr;
}

HRESULT AddLocalMachineRootCertificates()
{
    HRESULT hr;
    HRESULT hr2;
    HRESULT hr3;
    HRESULT hr4;

    hr = AddCertificates(
        "AuthRoot",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    // Remove all the AuthRoots from the "Root" store
    hr2 = AddCertificates2(
        "Root",
        "AuthRoot",                     // check if already in LM AuthRoot store
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    hr3 = AddCertificates(
        "Root",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    // Remove all the Roots from the "AuthRoot" store
    hr4 = AddCertificates2(
        "AuthRoot",
        "Root",                     // check if already in LM Root store
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    if (hr == ERROR_SUCCESS)
        hr = hr2;
    if (hr == ERROR_SUCCESS)
        hr = hr3;
    if (hr == ERROR_SUCCESS)
        hr = hr4;

    return hr;
}

void CreateKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKey
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hSubKey;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            hKey,
            pwszSubKey,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hSubKey,
            &dwDisposition))) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "RegCreateKeyEx(%S) returned error: %d 0x%x\n",
            pwszSubKey, err, err);
#endif
    } else {
        RegCloseKey(hSubKey);
    }
}

// Loop through the certificates in the "My" store and get their
// KeyIdentifier property. If the certificate also has a KEY_PROV_INFO,
// then, this will cause its KeyIdentifier to be created.
void UpdateMyKeyIdentifiers(
    IN DWORD dwOpenStoreFlags
    )
{
    HCERTSTORE hStore;
    if (hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_A,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            dwOpenStoreFlags | CERT_STORE_ENUM_ARCHIVED_FLAG,
            (const void *) "My"
            )) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            DWORD cbData = 0;

            // Dummy get to force the KeyIdentifer property to be created
            // if it doesn't already exist.
            CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                NULL,                           // pvData
                &cbData
                );
        }

        CertCloseStore(hStore, 0);
    }
}

//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
BOOL SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState=0;
    DWORD	dwDisposition=0;
    DWORD	dwType=0;
    DWORD	cbData=0;
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;
    BOOL    fResult=FALSE;

    HKEY	hKey=NULL;


    // Set the State in the registry
    if (ERROR_SUCCESS != RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition))
        goto RegErr;


    dwState = 0;
    cbData = sizeof(dwState);

    if(ERROR_SUCCESS != RegQueryValueExU
	(   hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        ))
        goto RegErr;

    if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
        goto UnexpectedErr;

    switch(dwMask) 
    {
        case WTPF_IGNOREREVOCATIONONTS:
        case WTPF_IGNOREREVOKATION:
        case WTPF_IGNOREEXPIRATION:
            // Revocation and expiration are a double negative so the bit set
            // means revocation and expriation checking is off.
            fOn = !fOn;
            break;
        default:
            break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    if(ERROR_SUCCESS != RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        ))
        goto SetValueErr;


    fResult=TRUE;

CommonReturn:
    if(hKey)
        RegCloseKey(hKey);

	return fResult;

ErrorReturn:

	goto CommonReturn;

TRACE_ERROR(RegErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
TRACE_ERROR(SetValueErr);

}


//+---------------------------------------------------------------------------
//
//  Function:   GetNextRegToken
//
//  Synopsis:   
//              Find the next token with space as the deliminator
//----------------------------------------------------------------------------
LPWSTR  GetNextRegToken(LPWSTR  pwsz, LPWSTR  pwszPreToken, BOOL  *pfEnd)
{
    LPWSTR  pwszStart=NULL;
    LPWSTR  pwszSearch=NULL;
    
    if(NULL == pwsz)
        return NULL;

    if(TRUE == (*pfEnd))
        return NULL;

    pwszStart=pwsz;

    if(pwszPreToken)
        pwszStart=pwszPreToken + wcslen(pwszPreToken) + 1;

    //skip the spaces
    while((*pwszStart)==L' ')
        pwszStart++;

    //check for NULL
    if(*pwszStart==L'\0')
        return NULL;

    pwszSearch=pwszStart;

    while(((*pwszSearch) != L'\0') && ((*pwszSearch) !=L' ') )
        pwszSearch++;

    if(*pwszSearch == L'\0')
    {
        *pfEnd=TRUE;
        return pwszStart;
    }

    *pwszSearch=L'\0';

    *pfEnd=FALSE;

    return pwszStart;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitRegistryValue
//
//  Synopsis:   This function replace SetReg.exe.  The expected
//              command line would be: 1 TRUE 3 FALSE 9 TRUE 4 FALSE ....
//
//----------------------------------------------------------------------------
HRESULT InitRegistryValue(LPWSTR pwszCommand)
{
    HRESULT            hr= E_FAIL;
    DWORD              SoftPubFlags[] = 
                            {
                            WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
                            WTPF_IGNOREEXPIRATION,
                            WTPF_IGNOREREVOKATION,
                            WTPF_OFFLINEOK_IND,
                            WTPF_OFFLINEOK_COM,
                            WTPF_OFFLINEOKNBU_IND,
                            WTPF_OFFLINEOKNBU_COM,
                            WTPF_VERIFY_V1_OFF,
                            WTPF_IGNOREREVOCATIONONTS,
                            WTPF_ALLOWONLYPERTRUST
                            };


    LPWSTR              pwszNextToken=NULL;
    int                 iIndex=-1;
    BOOL                fOn=FALSE;
    int                 cFlags=sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]);
    DWORD               cParam=0;
    LPWSTR              pwszCopy=NULL;
    BOOL                fPassThrough=FALSE;

    //make a copy of the command line since we will change it
    pwszCopy=(LPWSTR)LocalAlloc(LPTR, (1+wcslen(pwszCommand)) * sizeof(WCHAR));

    if(NULL== pwszCopy)
        goto MemoryErr;

    wcscpy(pwszCopy, pwszCommand);

    while(pwszNextToken=GetNextRegToken(pwszCopy, pwszNextToken, &fPassThrough))
    {
        
        if(-1 == iIndex)
        {
            iIndex=_wtoi(pwszNextToken);

            if((iIndex <= 0) || (iIndex > cFlags))
                goto InvalidArgErr;

            cParam++;
        }
        else
        {
            
            if(0 == _wcsicmp(pwszNextToken, L"true"))
                fOn=TRUE;
            else
            {
                if(0 == _wcsicmp(pwszNextToken, L"false"))
                    fOn=FALSE;
                else
                    goto InvalidArgErr;
            } 

            cParam++;

            //set the registry value
            if(!SetSoftPubKey(SoftPubFlags[iIndex-1], 
                              fOn))
            {
                hr=INITPKI_HRESULT_FROM_WIN32(GetLastError());
                goto SetKeyErr;
            }

            //reset the value for dwIndex
            iIndex=-1;
        }
    }

    //we have to have even number of parameters
    if( (0 != (cParam %2)) || (0 == cParam))
        goto InvalidArgErr;

    hr=S_OK;

CommonReturn:

    if(pwszCopy)
        LocalFree((HLOCAL)pwszCopy);

	return hr;

ErrorReturn:

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(SetKeyErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL WINAPI DllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch ( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
         hModule = hInstDLL;
         break;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:   dll installation entry point
//
//----------------------------------------------------------------------------
STDAPI DllInstall (BOOL fRegister, LPCSTR pszCommand)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    LPWSTR  pwszCommand=NULL;

    if ( fRegister == FALSE )
    {
        return( E_NOTIMPL );
    }

    switch ( *pszCommand )
    {
        //letter S stands for setreg input parameters
        //the command line should look like following:
        //S 1 TRUE 2 FALSE 3 FALSE ...
        //pszCommand is ACTUALLY LPWSTR for BOTH
        //NT5, NT4 and Win95.
        case 'S':
        case 's':
                pwszCommand=(LPWSTR)pszCommand;

                if(wcslen(pwszCommand) <= 2)
                {
                    hr=E_INVALIDARG;
                }
                else
                {
                    hr=InitRegistryValue((LPWSTR)(&(pwszCommand[1])));
                }

            break;
        case 'M':
        case 'm':
            MoveCertificates( TRUE );
            PurgeExpiringCertsFromStores();
            break;
        
        case 'U':
        case 'u':
            _AdjustPolicyFlags(psPolicySettings);

            PurgeExpiringCertsFromStores();

            // Ensure we have a registry entry for the Group Policy
            // SystemCertificates. On NT 4.0 or Win98, we emulate NT 5.0 GPT
            // notification by doing a RegNotifyChangeKeyValue on this
            // registry key.
            CreateKey(HKEY_CURRENT_USER, GROUP_POLICY_STORE_REGPATH);

            // Before adding to CurrentUser, will check if the root or CA
            // already exists in LocalMachine. If it exists in
            // LocalMachine and also exists in CurrentUser, will delete it
            // from CurrentUser instead of adding.
            hr = AddCurrentUserRootCertificates();
            hr2 = AddCurrentUserCACertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;
            hr2 = AddCurrentUserDisallowedCertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            // Protect the CurrentUser roots and purge any existing
            // protected CurrentUser roots also in LocalMachine
            //
            // Note, once the roots are protected, all subsequent adds are
            // done by a special service executing with System privileges.
            // This special service does secure attention sequence (SAS) UI
            // before doing the add.
            //
            // Note, subsequent purges are exempt from UI. ie, this function
            // doesn't do any SAS UI.
            I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );

            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_CURRENT_USER);
            break;
        
        case 'B':
        case 'b':
        case 'R':
        case 'r':
        case 'A':
        case 'a':
            // Initialize HKLM registry locations used by PKI to
            // only give Everyone KEY_READ access. Also gives the
            // IEDirtyFlags registry key KEY_SET_VALUE access for
            // Everyone.
            InitializeHKLMAcls();

            // Ensure we have a registry entry for the IEDirtyFlags
            // This key should have already been created
            // by InitializeHKLMAcls() for NT. Ensure its also there
            // for Win95 and Win98
            CreateKey(HKEY_LOCAL_MACHINE, CERT_IE_DIRTY_FLAGS_REGPATH);

            MoveCertificates(TRUE);
            PurgeExpiringCertsFromStores();

            // Ensure we have a registry entry for the Group Policy
            // SystemCertificates. On NT 4.0 or Win98, we emulate NT 5.0 GPT
            // notification by doing a RegNotifyChangeKeyValue on this
            // registry key.
            CreateKey(HKEY_LOCAL_MACHINE, GROUP_POLICY_STORE_REGPATH);
            CreateKey(HKEY_CURRENT_USER, GROUP_POLICY_STORE_REGPATH);

            // Ensure we have existing predefined stores for the LocalMachine
            // Enterprise system stores. These stores are periodically updated
            // from the DS by a system service. RegNotifyChangeKeyValue is
            // used to signal clients about Enterprise store changes.
            RegisterEnterpriseStores();

            // Our goal is to get the roots and CAs into LocalMachine.
            // Note previously, they were only copied to CurrentUser.
            AddLocalMachineRootCertificates();
            AddLocalMachineCACertificates();
            AddLocalMachineDisallowedCertificates();

            // If the above adds to LocalMachine failed, then, add
            // to CurrentUser.
            //
            // Before adding to CurrentUser, will check if the root or CA
            // already exists in LocalMachine. If it exists in
            // LocalMachine and also exists in CurrentUser, will delete it
            // from CurrentUser instead of adding.
            hr = AddCurrentUserRootCertificates();
            hr2 = AddCurrentUserCACertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;
            hr2 = AddCurrentUserDisallowedCertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            // Protect the CurrentUser roots and purge any existing
            // protected CurrentUser roots also in LocalMachine
            //
            // Note, once the roots are protected, all subsequent adds are
            // done by a special service executing with System privileges.
            // This special service does secure attention sequence (SAS) UI
            // before doing the add.
            //
            // Note, subsequent purges are exempt from UI. ie, this function
            // doesn't do any SAS UI.
            I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );

            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_CURRENT_USER);
            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_LOCAL_MACHINE);

            CleanupRegistry();
            hr2 = RegisterCryptoDlls(TRUE);
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            if (!I_CryptCatAdminMigrateToNewCatDB())
            {
                hr2 = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                hr2 = ERROR_SUCCESS;
            }
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            break;

        case 'C':
        case 'c':
            // Win9x migration post setup cleanup. Remove any migrated
            // roots that exist in the AuthRoot store.
            AddLocalMachineRootCertificates();
            AddCurrentUserRootCertificates();
            break;

        case 'Z':
        case 'z':

            //
            // This is for componentization install
            //

            pwszCommand=(LPWSTR)pszCommand;
            
            if (_wcsicmp(pwszCommand, L"z CoreCertificateServices") == 0)
            {
                InitializeHKLMAcls();   
                AddLocalMachineRootCertificates();
                AddLocalMachineCACertificates();
                AddLocalMachineDisallowedCertificates();

                if (!_LoadAndRegister("wintrust.dll", FALSE) ||
                    !_LoadAndRegister("mssign32.dll", FALSE) ||
                    !_LoadAndRegister("xenroll.dll", FALSE)  ||
                    !_AdjustPolicyFlags(psPolicySettings))
                {
                    hr = S_FALSE;                                           
                }

                RegisterWinlogonExtension("crypt32chain", "crypt32.dll",
                    "ChainWlxLogoffEvent");
                RegisterWinlogonExtension("cryptnet", "cryptnet.dll",
                    "CryptnetWlxLogoffEvent");
            
                RegisterCrypt32EventSource();
            }
            else if (_wcsicmp(pwszCommand, L"z CertificateUIServices") == 0)
            {
                if (!_LoadAndRegister("cryptui.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else if (_wcsicmp(pwszCommand, L"z CryptographicNetworkServices") == 0)
            {
                if (!_LoadAndRegister("cryptnet.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else if (_wcsicmp(pwszCommand, L"z CertificateUIExtensions") == 0)
            {
                if (!_LoadAndRegister("cryptext.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }

            break;

        default:
            hr = E_INVALIDARG;
    }

    return( hr );
}

STDAPI DllRegisterServer(void)
{
    return(DllInstall(TRUE, "A"));
}

STDAPI DllUnregisterServer(void)
{
    return(UnregisterCryptoDlls());
}

BOOL WINAPI InitializePKI(void)
{
    if (RegisterCryptoDlls(TRUE) != S_OK)
    {
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\mvcerts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mvcerts.cpp
//
//--------------------------------------------------------------------------


#include    "global.hxx"

static HRESULT HError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}


//
// The root of the certificate store that we manage.
//
#define SZIE30CERTROOT       "Software\\Microsoft\\Cryptography\\CertificateStore"
#define SZIE30CERTPARENT     "Software\\Microsoft\\Cryptography"
#define SZIE30CERTSTORE      "CertificateStore"
#define SZIE30CERTBUCKET     "Certificates"
#define SZIE30INDEXISSUER    "IndexByIssuerName"
#define SZIE30INDEXISSUERSER "IndexByIssuerNameAndSerialNumber"
#define SZIE30INDEXSUBJECT   "IndexBySubjectName"
#define SZIE30INDEXKEY       "IndexBySubjectPublicKey"
#define SZIE30CERTCLIENTAUTH "Software\\Microsoft\\Cryptography\\PersonalCertificates\\ClientAuth"
#define SZIE30TAGS           "CertificateTags"
#define SZIE30AUXINFO        "CertificateAuxiliaryInfo"
#define IE30CONVERTEDSTORE   "My"


HRESULT PurgeDuplicateCertificate(HCERTSTORE hStore, PCCERT_CONTEXT pCert)
{
    HRESULT hr = S_OK;
    PCCERT_CONTEXT pExistingCert = NULL;
    BOOL fRes = FALSE;

    // Check for existing certificates.
    pExistingCert = CertGetSubjectCertificateFromStore(hStore,
                                                       X509_ASN_ENCODING,
                                                       pCert->pCertInfo);
    if (pExistingCert) 
    {
        if (CompareFileTime(&pExistingCert->pCertInfo->NotBefore,
                            &pCert->pCertInfo->NotBefore) <= 0) {

            fRes = CertDeleteCertificateFromStore(pExistingCert);  // Delete existing
            pExistingCert = NULL;

            if (!(fRes))
            {
                goto CertDupError;
            }
        }
        else 
        {
            hr = S_FALSE;
        }
    }

    CommonReturn:
        if (pExistingCert)
        {
            CertFreeCertificateContext(pExistingCert);
        }
        return hr;


    ErrorReturn:
        SetLastError((DWORD)hr);
        goto CommonReturn;

    SET_HRESULT_EX(DBG_SS, CertDupError, GetLastError());
}

HRESULT MoveSpcCerts(BOOL fDelete, HCERTSTORE hStore)
// Check for and copy any existing certificates stored in Bob's
// certificate store. Also, delete Bob's certificate keys from the registry.
{
    HRESULT hr = S_OK;
    LONG Status;
    HKEY hKeyRoot = NULL;
    HKEY hKeyParent = NULL;
    HKEY hKeyBucket = NULL;
    LPSTR pszName = NULL;
    BYTE *pbData = NULL;

    PKITRY {
        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          SZIE30CERTROOT,
                                          0,                  // dwReserved
                                          KEY_READ,
                                          &hKeyRoot))
            PKITHROW(S_OK);

        // Copy any existing certificates
        if (ERROR_SUCCESS != RegOpenKeyEx(hKeyRoot,
                                          SZIE30CERTBUCKET,
                                          0,                  // dwReserved
                                          KEY_READ,
                                          &hKeyBucket))
            PKITHROW(HError());

        DWORD   cValues, cchMaxName, cbMaxData;
        // see how many and how big the registry is
        if (ERROR_SUCCESS != RegQueryInfoKey(hKeyBucket,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cValues,
                                             &cchMaxName,
                                             &cbMaxData,
                                             NULL,
                                             NULL
                                             ))
            PKITHROW(HError());

        // allocate the memory needed to read the reg
        pszName = (LPSTR) LocalAlloc(LMEM_ZEROINIT, cchMaxName + 1);
        pbData = (BYTE *) LocalAlloc(LMEM_ZEROINIT, cbMaxData);
        if (NULL == pszName  || NULL == pbData)
            PKITHROW(E_OUTOFMEMORY);

        // enum the registry getting certs
        for (DWORD i = 0; i < cValues; i++ ) {
            DWORD dwType;
            DWORD cchName = cchMaxName + 1;
            DWORD cbData = cbMaxData;
            PCCERT_CONTEXT pCert = NULL;

            if (ERROR_SUCCESS != RegEnumValueA(hKeyBucket,
                                               i,
                                               pszName,
                                               &cchName,
                                               NULL,
                                               &dwType,
                                               pbData,
                                               &cbData)) {
                if (SUCCEEDED(hr))
                    hr = HError();
            } else if (cchName) {
                if((pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                         pbData,
                                                         cbData)) == NULL) {
                    hr = HError();
                }
                else {
                    HRESULT hr2 = PurgeDuplicateCertificate(hStore, pCert);
                    if(hr2 == S_OK) {
                        if(!CertAddCertificateContextToStore(hStore,
                                                             pCert,
                                                             CERT_STORE_ADD_USE_EXISTING,
                                                             NULL       // ppStoreContext
                                                             )) {
                            /*MessageBox(NULL, "Copy Certificate Failed", NULL,
                                       MB_OK);*/
                            if(SUCCEEDED(hr))
                                hr = HError();
                        }
                    }
                }
                if(pCert)
                    CertFreeCertificateContext(pCert);
                /*
                  if (!CertAddEncodedCertificateToStore(hStore,
                                                      X509_ASN_ENCODING,
                                                      pbData,
                                                      cbData,
                                                      CERT_STORE_ADD_USE_EXISTING,
                                                      NULL)) {               // ppCertContext
                    MessageBox(NULL, "Copy Certificate Failed", NULL,
                               MB_OK);
                               if (SUCCEEDED(hr))
                        hr = HError();
                        */
            }
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (pszName)
        LocalFree(pszName);
    if (pbData)
        LocalFree(pbData);
    if (hKeyBucket)
        RegCloseKey(hKeyBucket);
    if (hKeyRoot)
        RegCloseKey(hKeyRoot);


    if(SUCCEEDED(hr) && fDelete) {

        Status = ERROR_SUCCESS;
        while (Status == ERROR_SUCCESS) {
            // Re-open registry with write/delete access
            if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              SZIE30CERTROOT,
                                              0,          // dwReserved
                                              KEY_ALL_ACCESS,
                                              &hKeyRoot))
                return HError();

            // Delete all of the store's subkeys including the certificates
            CHAR szSubKey[MAX_PATH+1];
            if (ERROR_SUCCESS == (Status = RegEnumKey(hKeyRoot,
                                                      0,          // iSubKey
                                                      szSubKey,
                                                      MAX_PATH + 1
                                                      )))
                Status = RegDeleteKey(hKeyRoot, szSubKey);
            RegCloseKey(hKeyRoot);
        }

        // Open the store's parent registry so we can delete the store
        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          SZIE30CERTPARENT,
                                          0,          // dwReserved
                                          KEY_ALL_ACCESS,
                                          &hKeyParent))
            return HError();

        if (ERROR_SUCCESS != RegDeleteKey(hKeyParent, SZIE30CERTSTORE))
            hr = HError();

        RegCloseKey(hKeyParent);
    }

    return hr;
}

BOOL TestIE30Store(HKEY hRegRoot, LPCSTR psLoc)
{
    HRESULT hr = S_FALSE;
    HKEY hKeyRoot   = NULL;
    HKEY hKeyBucket = NULL;
    char pbValueName[MAX_PATH];
    DWORD cbValueName = MAX_PATH;
    DWORD cSubKeys;
    DWORD dwType;

    // __asm int 3

    PKITRY {
        if (ERROR_SUCCESS != RegOpenKeyExA(hRegRoot,
                                           psLoc,
                                           0,                  // dwReserved
                                           KEY_READ,
                                           &hKeyRoot))
            PKITHROW(S_FALSE);

        if (ERROR_SUCCESS != RegOpenKeyExA(hKeyRoot,
                                           SZIE30CERTBUCKET,
                                           0,                  // dwReserved
                                           KEY_READ,
                                           &hKeyBucket))
            PKITHROW(S_FALSE);

        DWORD   cValues, cchMaxName, cbMaxData;
        // see how many and how big the registry is
        if (ERROR_SUCCESS != RegQueryInfoKey(hKeyBucket,
                                             NULL,  // lpszClasss
                                             NULL,  // lpcchClass
                                             NULL,  // lpdwReserved
                                             &cSubKeys,
                                             NULL,  // lpcchMaxSubkey
                                             NULL,  // lpcchMaxClass
                                             &cValues,
                                             &cchMaxName,
                                             &cbMaxData,
                                             NULL,
                                             NULL
                                             ))
            PKITHROW(HError());

        if(cchMaxName < 40 && cSubKeys == 0)
            hr = S_OK;
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND

    if(hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);
    if(hKeyBucket != NULL)
        RegCloseKey(hKeyBucket);
    return hr == S_OK ? TRUE : FALSE;
}


HRESULT TransferIE30Certificates(HKEY hRegRoot, LPCSTR psLoc, HCERTSTORE hStore, BOOL fDelete)
// Check for and copy any existing certificates stored in Bob's
// certificate store.
{
    HRESULT hr = S_OK;
    LONG Status;
    HKEY hKeyRoot   = NULL;
    HKEY hKeyBucket = NULL;
    HKEY hKeyTags   = NULL;
    HKEY hKeyAux    = NULL;

    if (ERROR_SUCCESS != RegOpenKeyExA(hRegRoot,
                                       psLoc,
                                       0,                  // dwReserved
                                       KEY_READ,
                                       &hKeyRoot
                                       ))
        return S_OK;

        // Copy any existing certificates
    if (ERROR_SUCCESS == RegOpenKeyExA(hKeyRoot,
                                       SZIE30CERTBUCKET,
                                       0,                  // dwReserved
                                       KEY_READ,
                                       &hKeyBucket
                                       )               &&

        ERROR_SUCCESS == RegOpenKeyExA(hKeyRoot,
                                       SZIE30AUXINFO,
                                       0,                  // dwReserved
                                       KEY_READ,
                                       &hKeyAux
                                       )               &&

        ERROR_SUCCESS == RegOpenKeyExA(hKeyRoot,
                                       SZIE30TAGS,
                                       0,                  // dwReserved
                                       KEY_READ,
                                       &hKeyTags
                                       )) {

        DWORD   cValuesCert, cchMaxNameCert, cbMaxDataCert;
        DWORD   cValuesTag, cchMaxNameTag, cbMaxDataTag;
        DWORD   cValuesAux, cchMaxNameAux, cbMaxDataAux;
        LPSTR   szName = NULL;
        BYTE *pbLoadCert = NULL;
        BYTE *pbFixedCert = NULL;
        BYTE *pbDataCert = NULL;
        BYTE *pbDataAux = NULL;
        BYTE *pbDataTag = NULL;

        // see how many and how big the registry is
        if (ERROR_SUCCESS != RegQueryInfoKey(hKeyBucket,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cValuesCert,
                                             &cchMaxNameCert,
                                             &cbMaxDataCert,
                                             NULL,
                                             NULL
                                             )           ||
            ERROR_SUCCESS != RegQueryInfoKey(hKeyTags,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cValuesTag,
                                             &cchMaxNameTag,
                                             &cbMaxDataTag,
                                             NULL,
                                             NULL
                                             )           ||
            ERROR_SUCCESS != RegQueryInfoKey(hKeyAux,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cValuesAux,
                                             &cchMaxNameAux,
                                             &cbMaxDataAux,
                                             NULL,
                                             NULL
                                             ))
            hr = HError();
        else {
            // allocate the memory needed to read the reg
            szName = (LPSTR) LocalAlloc(LMEM_ZEROINIT, cchMaxNameCert + 1);
            pbDataCert = (BYTE *) LocalAlloc(LMEM_ZEROINIT, cbMaxDataCert);
            pbDataTag = (BYTE *) LocalAlloc(LMEM_ZEROINIT, cbMaxDataTag);
            pbDataAux = (BYTE *) LocalAlloc(LMEM_ZEROINIT, cbMaxDataAux);

            if (NULL == szName      ||
                NULL == pbDataCert  ||
                NULL == pbDataAux   ||
                NULL == pbDataTag   )
                hr = E_OUTOFMEMORY;
        }

        // enum the registry getting certs
        for (DWORD i = 0; SUCCEEDED(hr) && i < cValuesCert; i++ ) {

            DWORD dwType;
            BYTE *  pb;
            CRYPT_KEY_PROV_INFO   keyInfo;
            DWORD cchName = cchMaxNameCert + 1;
            DWORD cbDataCert = cbMaxDataCert;
            DWORD cbLoadCert = 0;
            DWORD cbFixedCert = 0;
            DWORD cbDataTag = cbMaxDataTag;
            DWORD cbDataAux = cbMaxDataAux;
            PCCERT_CONTEXT pCertContxt = NULL;
            HRESULT status = S_OK;

            // don't have to worry about errors, just skip
            // sliently just be cause there is an internal
            // error in the registry doesn't mean we should
            // get all upset about it.

            // get the cert
            if (RegEnumValueA(hKeyBucket,
                              i,
                              szName,
                              &cchName,
                              NULL,
                              &dwType,
                              pbDataCert,
                              &cbDataCert
                              ) == ERROR_SUCCESS      &&

                dwType == REG_BINARY) {


                if(Fix7FCert(cbDataCert,
                             pbDataCert,
                             &cbFixedCert,
                             &pbFixedCert) &&
                   cbFixedCert != 0) {
                    pbLoadCert = pbFixedCert;
                    cbLoadCert = cbFixedCert;
                }
                else {
                    pbLoadCert = pbDataCert;
                    cbLoadCert = cbDataCert;
                }

                // get the cert context
                if((pCertContxt = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                               pbLoadCert,
                                                               cbLoadCert)) != NULL) {

                    // See if it has a tag and aux info.
                    // get the tag
                    if(RegQueryValueExA(hKeyTags,
                                        szName,
                                        NULL,
                                        &dwType,
                                        pbDataTag,
                                        &cbDataTag) == ERROR_SUCCESS    &&

                       // get the aux info
                       RegQueryValueExA(hKeyAux,
                                        (LPTSTR) pbDataTag,
                                        NULL,
                                        &dwType,
                                        pbDataAux,
                                        &cbDataAux) == ERROR_SUCCESS ) {

                        // aux info is
                        // wszPurpose
                        // wszProvider
                        // wszKeySet
                        // wszFilename
                        // wszCredentials
                        // dwProviderType
                        // dwKeySpec

                        pb = pbDataAux;
                        memset(&keyInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

                        // skip purpose, should be client auth
                        pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                        // get the provider
                        keyInfo.pwszProvName = (LPWSTR) pb;
                        pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                        // get the container name
                        keyInfo.pwszContainerName = (LPWSTR) pb;
                        pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                        // skip filename, should be '\0'
                        pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                        // skip credential, don't really know what it is?
                        pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                        // get the provider type
                        keyInfo.dwProvType = *((DWORD *) pb);
                        pb += sizeof(DWORD);

                        // get the key spec
                        keyInfo.dwKeySpec  = *((DWORD *) pb);


                        // add the property to the certificate
                        if( !CertSetCertificateContextProperty(pCertContxt,
                                                               CERT_KEY_PROV_INFO_PROP_ID,
                                                               0,
                                                               &keyInfo))
                            status = S_FALSE;
                    }

                    if(status == S_OK) {
                        HRESULT hr2 = PurgeDuplicateCertificate(hStore, pCertContxt);
                        if(hr2 == S_OK) {
                            if(!CertAddCertificateContextToStore(hStore,
                                                                 pCertContxt,
                                                                 CERT_STORE_ADD_USE_EXISTING,
                                                                 NULL       // ppStoreContext
                                                                 )) {
                                /*MessageBox(NULL,
                                  "Copy Certificate Failed",
                                  NULL,
                                  MB_OK);*/
                                hr = HError();
                            }
                        }
                    }
                }

            }
            if(pCertContxt != NULL)
                CertFreeCertificateContext(pCertContxt);
            if(pbFixedCert) {
                LocalFree(pbFixedCert);
                pbFixedCert = NULL;
            }
        }

        if (szName)
            LocalFree(szName);
        if (pbDataCert)
            LocalFree(pbDataCert);
        if(pbDataAux)
            LocalFree(pbDataAux);
        if(pbDataTag)
            LocalFree(pbDataTag);
    }



    if(hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);
    if(hKeyBucket != NULL)
        RegCloseKey(hKeyBucket);
    if(hKeyTags != NULL)
        RegCloseKey(hKeyTags);
    if(hKeyAux != NULL)
        RegCloseKey(hKeyAux);
    if (FAILED(hr))
        return hr;

    if(SUCCEEDED(hr) && fDelete) {

        // Re-open registry with write/delete access
        if (ERROR_SUCCESS != RegOpenKeyEx(hRegRoot,
                                          psLoc,
                                          0,          // dwRes erved
                                          KEY_ALL_ACCESS,
                                          &hKeyRoot))
            return HError();

        Status = RegDeleteKey(hKeyRoot, SZIE30CERTBUCKET);
        Status = RegDeleteKey(hKeyRoot, SZIE30INDEXISSUER);
        Status = RegDeleteKey(hKeyRoot, SZIE30INDEXISSUERSER);
        Status = RegDeleteKey(hKeyRoot, SZIE30INDEXSUBJECT);
        Status = RegDeleteKey(hKeyRoot, SZIE30INDEXKEY);
        Status = RegDeleteKey(hKeyRoot, SZIE30TAGS);
        RegCloseKey(hKeyRoot);
    }

    return hr;
}


HRESULT MoveCertificates(BOOL fDelete)
{
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

    HCERTSTORE hSpcStore = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTPROV hCrypt = NULL;
    //__asm int 3
    PKITRY {
        /*
        if (!CryptAcquireContext(&hCrypt, NULL, MS_DEF_PROV, PROV_RSA_FULL, 0))
            PKITHROW(HError());
            */
        hSpcStore = CertOpenSystemStore( NULL, TEXT("SPC") );

        if(!hSpcStore)
            PKITHROW(HError());
        hr = MoveSpcCerts(fDelete, hSpcStore);

        hStore = CertOpenSystemStore(NULL, TEXT(IE30CONVERTEDSTORE));
        if(!hStore)
            PKITHROW(HError());

        hr2 = TransferIE30Certificates(HKEY_CURRENT_USER, SZIE30CERTCLIENTAUTH, hStore, fDelete);

    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(SUCCEEDED(hr)) hr = hr2;
    if(hSpcStore)
        CertCloseStore( hSpcStore, 0 );
    if(hStore)
        CertCloseStore(hStore, 0);
    if(hCrypt)
        CryptReleaseContext(hCrypt, 0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by initpki.rc
//
#define IDR_ROOTS1                      103
#define IDR_ROOTS                       1005
#define IDR_CAS                         1006
#define IDR_AUTHROOTS                   1007
#define IDR_DISALLOW                    1008
#define IDS_SYNTAX                      6004
#define IDS_INITPKI_ERROR               6005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\catadnew.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catadnew.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATAdminAcquireContext
//              CryptCATAdminReleaseContext
//              CryptCATAdminAddCatalog
//              CryptCATAdminRemoveCatalog
//              CryptCATAdminEnumCatalogFromHash
//              CryptCATCatalogInfoFromContext
//              CryptCATAdminReleaseCatalogContext
//              CryptCATAdminResolveCatalogPath
//              CryptCATAdminPauseServiceForBackup
//              CryptCATAdminCalcHashFromFileHandle
//              I_CryptCatAdminMigrateToNewCatDB
//              CatAdminDllMain
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "eventlst.h"
#include    "sipguids.h"
#include    "mscat32.h"
#include    "catdb.h"
#include    "voidlist.h"
#include    "catutil.h"
#include    "..\..\common\catdbsvc\catdbcli.h"
#include    "errlog.h"

//
//  default system guid for apps that just make calls to CryptCATAdminAddCatalog with
//  hCatAdmin == NULL...
//
//          {127D0A1D-4EF2-11d1-8608-00C04FC295EE}
//
#define DEF_CAT_SUBSYS_ID                                               \
                {                                                       \
                    0x127d0a1d,                                         \
                    0x4ef2,                                             \
                    0x11d1,                                             \
                    { 0x86, 0x8, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }    \
                }

#define WSZ_CATALOG_FILE_BASE_DIRECTORY     L"CatRoot"
#define WSZ_DATABASE_FILE_BASE_DIRECTORY    L"CatRoot2"

#define WSZ_REG_FILES_NOT_TO_BACKUP         L"System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"
#define WSZ_REG_CATALOG_DATABASE_VALUE      L"Catalog Database"
#define WSZ_PATH_NOT_TO_BACKUP              L"%SystemRoot%\\System32\\CatRoot2\\* /s\0"

static WCHAR        *gpwszDatabaseFileBaseDirectory = NULL;
static WCHAR        *gpwszCatalogFileBaseDirectory = NULL;

#define WSZ_CATALOG_SUBSYTEM_SEARCH_STRING  L"{????????????????????????????????????}"


#define CATADMIN_LOGERR_LASTERR()           ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATADMIN, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATADMIN_SETERR_LOG_RETURN(x, y)    SetLastError(x); \
                                            ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATADMIN, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE); \
                                            goto y;

typedef struct CATALOG_INFO_CONTEXT_
{
    HANDLE          hMappedFile;
    BYTE            *pbMappedFile;
    WCHAR           *pwszCatalogFile;
    PCCTL_CONTEXT   pCTLContext; 
    BOOL            fResultOfAdd;
} CATALOG_INFO_CONTEXT;

typedef struct CRYPT_CAT_ADMIN_
{
    DWORD                   cbStruct;
    BOOL                    fUseDefSubSysId;
    LPWSTR                  pwszSubSysGUID;
    LPWSTR                  pwszCatalogFileDir;     // full path to .cat files
    LPWSTR                  pwszDatabaseFileDir;    // full path to CatDB file
    DWORD                   dwLastDBError;
    LIST                    CatalogInfoContextList;
    int                     nOpenCatInfoContexts;
    CRITICAL_SECTION        CriticalSection;
    BOOL                    fCSInitialized;
    BOOL                    fCSEntered;
    HANDLE                  hClearCacheEvent;
    HANDLE                  hRegisterWaitForClearCache;
    BOOL                    fRegisteredForChangeNotification;

} CRYPT_CAT_ADMIN;

#define CATINFO_CONTEXT_ALLOCATION_SIZE 64

LPWSTR  ppwszFilesToDelete[] = {L"hashmast.cbd", 
                                L"hashmast.cbk",
                                L"catmast.cbd",
                                L"catmast.cbk",
                                L"sysmast.cbd",
                                L"sysmast.cbk"};

#define   NUM_FILES_TO_DELETE  (sizeof(ppwszFilesToDelete) / \
                                sizeof(ppwszFilesToDelete[0]))


BOOL
_CatAdminMigrateSingleDatabase(
    LPWSTR  pwszDatabaseGUID);

BOOL 
_CatAdminSetupDefaults(void);

void 
_CatAdminCleanupDefaults(void);

BOOL
_CatAdminTimeStampFilesInSync(
    LPWSTR  pwszDatabaseGUID,
    BOOL    *pfInSync);

BOOL 
_CatAdminRegisterForChangeNotification(
    CRYPT_CAT_ADMIN         *pCatAdmin
    );

BOOL 
_CatAdminFreeCachedCatalogs(
    CRYPT_CAT_ADMIN         *pCatAdmin
    );

VOID CALLBACK 
_CatAdminWaitOrTimerCallback(
    PVOID                   lpParameter, 
    BOOLEAN                 TimerOrWaitFired
    );

BOOL 
_CatAdminAddCatalogsToCache(
    CRYPT_CAT_ADMIN         *pCatAdmin,
    LPWSTR                  pwszSubSysGUID, 
    CRYPT_DATA_BLOB         *pCryptDataBlob, 
    LIST_NODE               **ppFirstListNodeAdded
    );

BOOL 
_CatAdminAddSingleCatalogToCache(
    CRYPT_CAT_ADMIN         *pCatAdmin,
    LPWSTR                  pwszCatalog, 
    LIST_NODE               **ppListNodeAdded
    );

BOOL
_CatAdminMigrateCatalogDatabase(
    LPWSTR                  pwszFrom, 
    LPWSTR                  pwszTo
    );

void
_CatAdminBToHex (
    LPBYTE                  pbDigest, 
    DWORD                   iByte, 
    LPWSTR                  pwszHashTag
    );

BOOL
_CatAdminCreateHashTag(
    BYTE                    *pbHash,
    DWORD                   cbHash,
    LPWSTR                  *ppwszHashTag,
    CRYPT_DATA_BLOB         *pCryptDataBlob
    );

BOOL 
_CatAdminRecursiveCreateDirectory(
    IN LPCWSTR              pwszDir,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes
    );

LPWSTR 
_CatAdminCreatePath(
    IN LPCWSTR              pwsz1,
    IN LPCWSTR              pwsz2,
    IN BOOL                 fAddEndingSlash
    );


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_ZEROINIT, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    if (ptr != NULL)
    {
        LocalFree(ptr);
    }
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminAcquireContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminAcquireContext_Internal(
    HCATADMIN   *phCatAdmin, 
    const GUID  *pgSubsystem, 
    DWORD       dwFlags,
    BOOL        fCalledFromMigrate)
{
    GUID            gDefault    = DEF_CAT_SUBSYS_ID;
    const GUID      *pgCatroot  = &gDefault;
    CRYPT_CAT_ADMIN *pCatAdmin  = NULL;
    BOOL            fRet        = TRUE;
    DWORD           dwErr       = 0;
    WCHAR           wszGUID[256];
    BOOL            fInSync;

    //
    // Validata parameters
    //
    if (phCatAdmin == NULL)
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }
    *phCatAdmin = NULL;

    //
    // Allocate a new CatAdmin state struct
    //
    if (NULL == (pCatAdmin = (CRYPT_CAT_ADMIN *) malloc(sizeof(CRYPT_CAT_ADMIN))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    memset(pCatAdmin, 0, sizeof(CRYPT_CAT_ADMIN));
    pCatAdmin->cbStruct = sizeof(CRYPT_CAT_ADMIN);

    LIST_Initialize(&(pCatAdmin->CatalogInfoContextList));

    //
    // Check to see if caller specified the Catroot dir to use
    //
    if (pgSubsystem == NULL)
    {
        pCatAdmin->fUseDefSubSysId = TRUE;
    }
    else
    {
        pgCatroot = pgSubsystem; 
    }

    guid2wstr(pgCatroot, wszGUID);

    //
    // Initialize the critical section
    //
    __try
    {
        InitializeCriticalSection(&(pCatAdmin->CriticalSection));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError(GetExceptionCode());
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    pCatAdmin->fCSInitialized = TRUE;
    pCatAdmin->fCSEntered = FALSE;

    //
    // Save a copy of the GUID as a string
    // 
    if (NULL == (pCatAdmin->pwszSubSysGUID = (LPWSTR)
                                malloc((wcslen(wszGUID) + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    wcscpy(pCatAdmin->pwszSubSysGUID, wszGUID);

    //
    // Get the complete paths for the catalog files and the db file
    //
    if (NULL == (pCatAdmin->pwszCatalogFileDir = _CatAdminCreatePath(
                                                        gpwszCatalogFileBaseDirectory,
                                                        wszGUID, 
                                                        TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pCatAdmin->pwszDatabaseFileDir = _CatAdminCreatePath(
                                                        gpwszDatabaseFileBaseDirectory,
                                                        wszGUID, 
                                                        TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Make sure catalog file and database file sub-directories exists
    //
    if (!_CatAdminRecursiveCreateDirectory(
            pCatAdmin->pwszCatalogFileDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

     if (!_CatAdminRecursiveCreateDirectory(
            pCatAdmin->pwszDatabaseFileDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Create the event which is notified when the catalog db changes, and register
    // a callback for when the event is signaled
    //
    if (NULL == (pCatAdmin->hClearCacheEvent = CreateEvent(NULL, FALSE, FALSE, NULL)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorCreateEvent;
    } 
    
    if (!RegisterWaitForSingleObject(
            &(pCatAdmin->hRegisterWaitForClearCache),
            pCatAdmin->hClearCacheEvent,
            _CatAdminWaitOrTimerCallback,
            pCatAdmin,
            INFINITE,
            WT_EXECUTEDEFAULT))
    {
        
        CATADMIN_LOGERR_LASTERR()
        goto ErrorRegisterWaitForSingleObject;
    }

    //
    // If we are being called by a real client (not the migrate code) then make sure
    // the TimeStamp files are in a consistent state, and if not, migrate (re-add) 
    // the catalog files for that database
    //
    if (!fCalledFromMigrate)
    {        
        if (_CatAdminTimeStampFilesInSync(wszGUID, &fInSync))
        {
            if (!fInSync)
            {
                //
                // FIX FIX - may need to migrate 
                // all DBs if the wszGUID is DEF_CAT_SUBSYS_ID
                //

                if (!_CatAdminMigrateSingleDatabase(wszGUID))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // NOTE:
    // Defer registering with the service for the change notificatation so we
    // don't rely on the service during an acquire context
    //

    *phCatAdmin = (HCATADMIN)pCatAdmin;

CommonReturn:
    return(fRet);

ErrorReturn:
        
    if (pCatAdmin != NULL)
    {
        dwErr = GetLastError();

        if (pCatAdmin->hRegisterWaitForClearCache != NULL)
        {
            UnregisterWaitEx(
                pCatAdmin->hRegisterWaitForClearCache, 
                INVALID_HANDLE_VALUE);
        }

        // call UnregisterWaitEx before deteling the critical section
        // because the cb thread tries to enter it
        if (pCatAdmin->fCSInitialized)
        {
            DeleteCriticalSection(&(pCatAdmin->CriticalSection)); 
        }

        if (pCatAdmin->hClearCacheEvent != NULL)
        {
            CloseHandle(pCatAdmin->hClearCacheEvent);
        }

        if (pCatAdmin->pwszSubSysGUID != NULL)
        {
            free(pCatAdmin->pwszSubSysGUID);
        }

        if (pCatAdmin->pwszCatalogFileDir != NULL)
        {
            free(pCatAdmin->pwszCatalogFileDir); 
        }

        if (pCatAdmin->pwszDatabaseFileDir != NULL)
        {
            free(pCatAdmin->pwszDatabaseFileDir); 
        }

        free(pCatAdmin);

        SetLastError(dwErr);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorRegisterWaitForSingleObject)  
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCreateEvent)      
} 

BOOL WINAPI 
CryptCATAdminAcquireContext(
    OUT HCATADMIN   *phCatAdmin, 
    IN const GUID  *pgSubsystem, 
    IN DWORD       dwFlags)
{
    return (CryptCATAdminAcquireContext_Internal(
                phCatAdmin,
                pgSubsystem,
                dwFlags,
                FALSE));
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminReleaseContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminReleaseContext(
    IN HCATADMIN   hCatAdmin, 
    IN DWORD       dwFlags)
{
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *)hCatAdmin;
    BOOL                    fRet                = TRUE;
    int                     i                   = 0;
    LIST_NODE               *pListNode          = NULL;
    
    //
    // Validate input params
    //
    if ((pCatAdmin == NULL) || 
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam) 
    }

    //
    // Un-Register for change notifications from DB process
    //
    // This needs to happen first thing, so that no callbacks
    // happen during cleanup
    //
    if (pCatAdmin->fRegisteredForChangeNotification)
    {
        Client_SSCatDBRegisterForChangeNotification(
                                (DWORD_PTR) pCatAdmin->hClearCacheEvent,
                                0,
                                pCatAdmin->pwszSubSysGUID,
                                TRUE);
    }
    UnregisterWaitEx(pCatAdmin->hRegisterWaitForClearCache, INVALID_HANDLE_VALUE);
    CloseHandle(pCatAdmin->hClearCacheEvent);

    _CatAdminFreeCachedCatalogs(pCatAdmin);
    
    free(pCatAdmin->pwszSubSysGUID);
    free(pCatAdmin->pwszCatalogFileDir); 
    free(pCatAdmin->pwszDatabaseFileDir);
    
    DeleteCriticalSection(&(pCatAdmin->CriticalSection));
    
    free(pCatAdmin);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminAddCatalog
//
//---------------------------------------------------------------------------------------
HCATINFO WINAPI 
CryptCATAdminAddCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags)
{
    CRYPT_CAT_ADMIN         *pCatAdmin                      = (CRYPT_CAT_ADMIN *)hCatAdmin;
    CATALOG_INFO_CONTEXT    *pCatInfoContext                = NULL;
    BOOL                    fRet;
    LPWSTR                  pwszName                        = NULL;
    DWORD                   dwErr                           = 0;
    LPWSTR                  pwszCatalogNameUsed             = NULL;
    LPWSTR                  pwszCatalogNameUsedCopy         = NULL;
    LPWSTR                  pwszFullyQualifiedCatalogFile   = NULL;
    DWORD                   dwLength                        = 0;
    LIST_NODE               *pListNode                      = NULL;
    WCHAR                   wszTmp[1];
    
    if ((pCatAdmin == NULL)                                 ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))    ||
        (pwszCatalogFile == NULL)                           ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam) 
    }

    ErrLog_LogString(NULL, L"Adding Catalog File: ", pwszSelectBaseName, TRUE);

    //
    //  first, check the catalog...
    //
    if (!(IsCatalogFile(INVALID_HANDLE_VALUE, pwszCatalogFile)))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_FORMAT, ErrorBadFileFormat) 
    }

    __try
    {
        EnterCriticalSection(&(pCatAdmin->CriticalSection));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError(GetExceptionCode());
        CATADMIN_LOGERR_LASTERR()
        return NULL;
    }
    pCatAdmin->fCSEntered = TRUE;

    if (!_CatAdminRegisterForChangeNotification(pCatAdmin))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Clear the cache, since doing the add may change things
    //
    _CatAdminFreeCachedCatalogs(pCatAdmin);

    //
    // If the file name specified by pwszCatalogFile is not a fully qualified
    // path name, we need to build one before calling the service.
    //
    if ((wcschr(pwszCatalogFile, L'\\') == NULL) &&
        (wcschr(pwszCatalogFile, L':') == NULL))
    {
        dwLength = GetCurrentDirectoryW(1, wszTmp) * sizeof(WCHAR);
        dwLength += (wcslen(pwszCatalogFile) + 1) * sizeof(WCHAR);
        if (NULL == (pwszFullyQualifiedCatalogFile = (LPWSTR) malloc(dwLength)))
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }

        if (!GetCurrentDirectoryW(
                dwLength / sizeof(WCHAR), 
                pwszFullyQualifiedCatalogFile))
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if ((pwszFullyQualifiedCatalogFile[wcslen(pwszFullyQualifiedCatalogFile) - 1] 
                != L'\\'))
        {
            wcscat(pwszFullyQualifiedCatalogFile, L"\\");
        }
        wcscat(pwszFullyQualifiedCatalogFile, pwszCatalogFile);        
    }
    
    //
    // Call the DB process to add the catalog
    //
    if (0 != (dwErr = Client_SSCatDBAddCatalog( 
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            (pwszFullyQualifiedCatalogFile != NULL) ? 
                                pwszFullyQualifiedCatalogFile : 
                                pwszCatalogFile,
                            pwszSelectBaseName,
                            &pwszCatalogNameUsed)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }
    
    //
    // Touch the TimeStamp file
    //
    TimeStampFile_Touch(pCatAdmin->pwszCatalogFileDir);

    //
    // create a psuedo list entry, that really isn't part of the list...
    // this is so the caller can call CryptCATCatalogInfoFromContext
    //
    if (NULL == (pwszCatalogNameUsedCopy = (LPWSTR)
                    malloc((wcslen(pwszCatalogNameUsed) + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
   
    wcscpy(pwszCatalogNameUsedCopy, pwszCatalogNameUsed);

    if (NULL == (pCatInfoContext = (CATALOG_INFO_CONTEXT *) 
                    malloc(sizeof(CATALOG_INFO_CONTEXT))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    
    memset(pCatInfoContext, 0, sizeof(CATALOG_INFO_CONTEXT));
    pCatInfoContext->pwszCatalogFile = pwszCatalogNameUsedCopy;
    pCatInfoContext->fResultOfAdd = TRUE;

    if (NULL == (pListNode = (LIST_NODE *) malloc(sizeof(LIST_NODE))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    
    memset(pListNode, 0, sizeof(LIST_NODE));
    pListNode->pElement = pCatInfoContext;
    
CommonReturn:

    MIDL_user_free(pwszCatalogNameUsed);
    
    if (pwszFullyQualifiedCatalogFile != NULL)
    {
        free(pwszFullyQualifiedCatalogFile);
    }

    if ((pCatAdmin != NULL) &&
        (pCatAdmin->fCSEntered))
    {              
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));   
    }

    ErrLog_LogString(NULL, L"DONE Adding Catalog File: ", pwszSelectBaseName, TRUE);

    return((HCATINFO) pListNode);

ErrorReturn:

    if (pwszCatalogNameUsedCopy != NULL)
    {
        free(pwszCatalogNameUsedCopy);
    }

    if (pCatInfoContext != NULL)
    {
        free(pCatInfoContext);
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorBadFileFormat)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminRemoveCatalog
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN LPCWSTR pwszCatalogFile,
    IN DWORD dwFlags)
{
    BOOL            fRet        = TRUE;
    DWORD           dwErr       = 0;
    CRYPT_CAT_ADMIN *pCatAdmin  = (CRYPT_CAT_ADMIN *)hCatAdmin;

    //
    // Call the DB process to delete the catalog
    //
    if (0 != (dwErr = Client_SSCatDBDeleteCatalog( 
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            pwszCatalogFile)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

    //
    // Touch the TimeStamp file
    //
    TimeStampFile_Touch(pCatAdmin->pwszCatalogFileDir);

CommonReturn:
    
    return(fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminEnumCatalogFromHash
//
//---------------------------------------------------------------------------------------
HCATINFO WINAPI
CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash, 
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN HCATINFO *phPrevCatInfo)
{
    CRYPT_CAT_ADMIN         *pCatAdmin                  = (CRYPT_CAT_ADMIN *)hCatAdmin;
    BOOL                    fFindFirstOnly;
    BOOL                    fInitializeEnum             = FALSE;
    int                     i                           = 0;
    CRYPT_DATA_BLOB         CryptDataBlobHash;
    CRYPT_DATA_BLOB         CryptDataBlobHashTag;
    LPWSTR                  pwszSearch                  = NULL;
    HANDLE                  hFindHandle                 = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW        FindData;
    LPWSTR                  pwszHashTag                 = NULL;
    DWORD                   dwErr                       = 0;
    LIST_NODE               *pPrevListNode              = NULL;
    LIST_NODE               *pListNodeToReturn          = NULL;
    LIST_NODE               *pListNode                  = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext            = NULL;
    
    //
    // Validate input params
    //
    if ((pCatAdmin == NULL)                                ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))   ||
        (cbHash == 0)                                      ||
        (cbHash > MAX_HASH_LEN)                            ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam) 
    }

    if (!_CatAdminRegisterForChangeNotification(pCatAdmin))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // If phPrevCatInfo is NULL then that means the caller is only interested
    // in the first catalog that contains the hash, thus no enum state is 
    // started.  If phPrevCatInfo is non NULL, then it contains NULL, or a
    // HCATINFO that was returned from a previous call to 
    // CryptCATAdminEnumCatalogFromHash.  If it contains NULL, then this is 
    // the start of an enum, otherwise it is enuming the next catalog containing
    // the hash.
    //
    if (phPrevCatInfo == NULL)
    {
        fFindFirstOnly = TRUE;
    }
    else
    {
        fFindFirstOnly = FALSE;
        pPrevListNode = (LIST_NODE *) *phPrevCatInfo;        
    }

    //
    // Only allow one thread to view/modify at a time
    //
    __try
    {
        EnterCriticalSection(&(pCatAdmin->CriticalSection));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError(GetExceptionCode());
        CATADMIN_LOGERR_LASTERR()
        return FALSE;
    }
    pCatAdmin->fCSEntered = TRUE;
    
    __try
    {

    //
    // This data blob is used to do the find in the database
    //
    CryptDataBlobHash.pbData = pbHash;
    CryptDataBlobHash.cbData = cbHash;

    //
    // Create the tag to be used for calls to CertFindSubjectInSortedCTL
    //
    if (!_CatAdminCreateHashTag(pbHash, cbHash, &pwszHashTag, &CryptDataBlobHashTag))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    
    //
    // The enum works as follows:
    //
    // if enum-state is not being initialized OR this is the first call to start an enum
    //
    //      loop through all currently cached catalogs until a catalog containing the 
    //      the hash is found, and return it
    //
    //      if a catalog was not found in the cache, then call the DB process to try and 
    //      find one
    //
    // else (enum state has already been started)
    //
    //      loop through currently cached catalogs, starting with the catalog just after
    //      the current catalog, and until a catalog containing the hash is found
    //

    if ((fFindFirstOnly)  || (pPrevListNode == NULL))
    {
        pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
        while (pListNode != NULL)
        {
            pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

            if (CertFindSubjectInSortedCTL(
                    &CryptDataBlobHashTag,
                    pCatInfoContext->pCTLContext,
                    NULL,
                    NULL,
                    NULL))
            {
                pListNodeToReturn = pListNode;
                goto CommonReturn;
            }

            pListNode = LIST_GetNext(pListNode);
        }

        //
        // If we are here, that means we did not find a cached catalog that contained
        // the hash, so call the DB process to try and find one or more.
        // 
        // Call the DB process once if we are not using the default sub-system ID,
        // otherwise call the DB process once for each sub-system.

        if (!pCatAdmin->fUseDefSubSysId)
        {
            if (_CatAdminAddCatalogsToCache(
                        pCatAdmin,
                        pCatAdmin->pwszSubSysGUID, 
                        &CryptDataBlobHash, 
                        &pListNodeToReturn))
            {
                if (pListNodeToReturn == NULL)
                {
                    SetLastError(ERROR_NOT_FOUND);
                    //CATADMIN_LOGERR_LASTERR()
                    goto CatNotFound;
                }

                goto CommonReturn;
            }
            else
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
        else
        {
            //
            // For each subdir, add all the catalogs that contain the hash
            //

            //
            // Create search string to find all subdirs
            //
            if (NULL == (pwszSearch = _CatAdminCreatePath(
                                            gpwszDatabaseFileBaseDirectory, 
                                            WSZ_CATALOG_SUBSYTEM_SEARCH_STRING,
                                            FALSE)))               
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Do the initial find
            //
            hFindHandle = FindFirstFileU(pwszSearch, &FindData);
            if (hFindHandle == INVALID_HANDLE_VALUE)
            {
                dwErr = GetLastError();

                //
                // no sub dirs found
                //
                if ((dwErr == ERROR_NO_MORE_FILES)  ||
                    (dwErr == ERROR_PATH_NOT_FOUND) ||
                    (dwErr == ERROR_FILE_NOT_FOUND))
                {
                    CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_FOUND, CatNotFound) 
                }
                else
                {
                    goto ErrorFindFirstFile;
                }
            }    

            while (1)
            {
                //
                // Only care about directories
                //
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    //
                    // Add all the catalogs in this subdir that contain the hash to
                    // the catalog cache
                    //
                    if (!_CatAdminAddCatalogsToCache(
                                pCatAdmin,
                                FindData.cFileName, 
                                &CryptDataBlobHash, 
                                (pListNodeToReturn == NULL) ? 
                                        &pListNodeToReturn : NULL))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }
                }                                                       

                //
                // Get next subdir
                //
                if (!FindNextFileU(hFindHandle, &FindData))            
                {
                    if (GetLastError() == ERROR_NO_MORE_FILES)
                    {
                        break;
                    }
                    else
                    {
                        goto ErrorFindNextFile;
                    }
                }
            }
            
            if (pListNodeToReturn == NULL)
            {
                SetLastError(ERROR_NOT_FOUND);
                //CATADMIN_LOGERR_LASTERR()
                goto CatNotFound; 
            }
        }        
    }
    else
    {
        //
        // Enum state already started, so just search through the rest of the cached 
        // catalogs to try and find one that contains the hash
        //
        pListNode = LIST_GetNext(pPrevListNode);
        while (pListNode != NULL)
        {
            pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

            if (CertFindSubjectInSortedCTL(
                        &CryptDataBlobHashTag,
                        pCatInfoContext->pCTLContext,
                        NULL,
                        NULL,
                        NULL))
            {
                pListNodeToReturn = pListNode;
                goto CommonReturn;
            }
            
            pListNode = LIST_GetNext(pListNode);
        }

        //
        // If we get here that means no catalog was found
        //
        SetLastError(ERROR_NOT_FOUND);
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATADMIN_SETERR_LOG_RETURN(GetExceptionCode(), ErrorException)
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszHashTag != NULL)
    {
        free(pwszHashTag);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    if (pListNodeToReturn != NULL)
    {
        pCatAdmin->nOpenCatInfoContexts++;
    }
    
    if (pPrevListNode != NULL)
    {
        *phPrevCatInfo = NULL;

        //
        // Decrement, since this is the equivalent of 
        // calling CryptCATAdminReleaseCatalogContext
        //
        pCatAdmin->nOpenCatInfoContexts--;
    }

    if ((pCatAdmin != NULL) &&
        (pCatAdmin->fCSEntered))
    {
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));        
    }

    SetLastError(dwErr);

    return((HCATINFO) pListNodeToReturn);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, CatNotFound) 
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile) 
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile) 
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorException) 
}


//---------------------------------------------------------------------------------------
//
//  CryptCATCatalogInfoFromContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATCatalogInfoFromContext(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    BOOL                    fRet        = TRUE;
    LIST_NODE               *pListNode  = (LIST_NODE *) hCatInfo;
    CATALOG_INFO_CONTEXT    *pContext   = NULL;
    

    if ((pListNode == NULL) || (psCatInfo == NULL))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    pContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

    if (pContext->pwszCatalogFile != NULL)
    {
        if ((wcslen(pContext->pwszCatalogFile) + 1) > MAX_PATH)
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorTooLong)
        }

        wcscpy(psCatInfo->wszCatalogFile, pContext->pwszCatalogFile);
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorTooLong)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminReleaseCatalogContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminReleaseCatalogContext(
    IN HCATADMIN   hCatAdmin, 
    IN HCATINFO    hCatInfo, 
    IN DWORD       dwFlags)
{
    BOOL                    fRet                = TRUE;
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *)hCatAdmin;
    LIST_NODE               *pListNode          = (LIST_NODE *) hCatInfo;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;

    if ((pCatAdmin == NULL)                                     ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))        ||
        (pListNode == NULL))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    //
    // check to see if this is from and add operation, if so, then clean
    // up allocated memory, otherwise, just decrement ref count
    // 
    pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);
    if (pCatInfoContext->fResultOfAdd)
    {
        free(pCatInfoContext->pwszCatalogFile);
        free(pCatInfoContext);
        free(pListNode);
    }
    else
    {
        // FIX FIX - may need to be smarter about this... like verify
        // the node is actually in the list.
        pCatAdmin->nOpenCatInfoContexts--;
    }
    
CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam);
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminResolveCatalogPath
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    BOOL            fRet        = TRUE;
    CRYPT_CAT_ADMIN *pCatAdmin  = (CRYPT_CAT_ADMIN *)hCatAdmin;

    if ((pCatAdmin == NULL)                                 ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))    ||
        (pwszCatalogFile == NULL)                           ||
        (psCatInfo == NULL)                                 ||
        (psCatInfo->cbStruct != sizeof(CATALOG_INFO))       ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    if ((wcslen(pCatAdmin->pwszCatalogFileDir)  +
         wcslen(pwszCatalogFile)                +
         1) > MAX_PATH)
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorTooLong)
    }

    wcscpy(psCatInfo->wszCatalogFile, pCatAdmin->pwszCatalogFileDir);
    wcscat(psCatInfo->wszCatalogFile, pwszCatalogFile);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorTooLong)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminPauseServiceForBackup
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CryptCATAdminPauseServiceForBackup(
    IN DWORD dwFlags,
    IN BOOL  fResume)
{
    BOOL    fRet = TRUE;
    DWORD   dwErr = 0;
    
    //
    // Call the DB process to delete the catalog
    //
    if (0 != (dwErr = Client_SSCatDBPauseResumeService( 
                            0,
                            fResume)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

CommonReturn:
    
    return(fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminCalcHashFromFileHandle
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminCalcHashFromFileHandle(
    IN      HANDLE  hFile, 
    IN OUT  DWORD   *pcbHash, 
    IN      BYTE    *pbHash,
    IN      DWORD   dwFlags)
{
    BYTE                *pbRet          = NULL;
    SIP_INDIRECT_DATA   *pbIndirectData = NULL;
    BOOL                fRet;
    GUID                gSubject;
    SIP_DISPATCH_INFO   sSip;

    if ((hFile == NULL)                 ||
        (hFile == INVALID_HANDLE_VALUE) ||
        (pcbHash == NULL)               ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, InvalidParam)
    }

    if (!CryptSIPRetrieveSubjectGuidForCatalogFile(L"CATADMIN", hFile, &gSubject))
    {
        goto ErrorMemory;
    }

    memset(&sSip, 0x00, sizeof(SIP_DISPATCH_INFO));

    sSip.cbSize = sizeof(SIP_DISPATCH_INFO);

    if (!CryptSIPLoad(&gSubject, 0, &sSip))
    {
        CATADMIN_LOGERR_LASTERR()
        goto SIPLoadError;
    }

    SIP_SUBJECTINFO     sSubjInfo;
    DWORD               cbIndirectData;

    memset(&sSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));
    sSubjInfo.cbSize                    = sizeof(SIP_SUBJECTINFO);
    sSubjInfo.DigestAlgorithm.pszObjId  = (char *)CertAlgIdToOID(CALG_SHA1);
    sSubjInfo.dwFlags                   =   SPC_INC_PE_RESOURCES_FLAG | 
                                            SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                                            MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;
    sSubjInfo.pgSubjectType             = &gSubject;
    sSubjInfo.hFile                     = hFile;
    sSubjInfo.pwsFileName               = L"CATADMIN";
    sSubjInfo.dwEncodingType            = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    cbIndirectData = 0;

    sSip.pfCreate(&sSubjInfo, &cbIndirectData, NULL);

    if (cbIndirectData == 0)
    {
        SetLastError(E_NOTIMPL);
        //CATADMIN_LOGERR_LASTERR()
        goto SIPError; 
    }

    if (NULL == (pbIndirectData = (SIP_INDIRECT_DATA *) malloc(cbIndirectData)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    if (!(sSip.pfCreate(&sSubjInfo, &cbIndirectData, pbIndirectData)))
    {
        if (GetLastError() == 0)
        {
            SetLastError(ERROR_INVALID_DATA);
        }

        CATADMIN_LOGERR_LASTERR()
        goto SIPError;
    }

    if ((pbIndirectData->Digest.cbData == 0) || 
        (pbIndirectData->Digest.cbData > MAX_HASH_LEN))
    {
        SetLastError( ERROR_INVALID_DATA );
        goto SIPError;
    }

    if (NULL == (pbRet = (BYTE *) malloc(pbIndirectData->Digest.cbData))) 
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memcpy(pbRet, pbIndirectData->Digest.pbData, pbIndirectData->Digest.cbData);

    fRet = TRUE;

CommonReturn:
    if (pbRet)
    {
        if (*pcbHash < pbIndirectData->Digest.cbData)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fRet = FALSE;
        }
        else if (pbHash)
        {
            memcpy(pbHash, pbRet, pbIndirectData->Digest.cbData);
        }

        *pcbHash = pbIndirectData->Digest.cbData;

        free(pbRet);
    }

    if (pbIndirectData)
    {
        free(pbIndirectData);
    }

    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) && 
        (pbHash == NULL))
    {
        fRet = TRUE;
    }

    return(fRet);

ErrorReturn:
    free(pbRet);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, SIPLoadError)
TRACE_ERROR_EX(DBG_SS_TRUST, SIPError)
TRACE_ERROR_EX(DBG_SS_TRUST, InvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  I_CryptCatAdminMigrateToNewCatDB
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
I_CryptCatAdminMigrateToNewCatDB()
{
    BOOL                fRet                = TRUE;
    LPWSTR              pwszSearchCatDirs   = NULL;
    LPWSTR              pwszDeleteFile      = NULL;
    LPWSTR              pwsz                = NULL;
    LPWSTR              pwszMigrateFromDir  = NULL;
    HCATADMIN           hCatAdmin           = NULL;
    GUID                gDefault            = DEF_CAT_SUBSYS_ID;
    HANDLE              hFindHandleCatDirs  = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatDirs;
    DWORD               dwErr               = 0;
    HKEY                hKey;
    DWORD               dwDisposition;
    int                 i;
    BOOL                fInSync;
    WCHAR               wszGUID[256];
    LPWSTR              pwszCatalogFileDir  = NULL;
    LPWSTR              pwszDatabaseFileDir = NULL;

    //
    // FIRST!!
    //
    // Clean up the old reg based catroot entry, and if needed, move 
    // the old style catalog database from its old directory to the new directory, 
    // then do the migrate from there
    //
    if (RegCreateKeyExU(    
                HKEY_LOCAL_MACHINE,
                REG_MACHINE_SETTINGS_KEY,
                0, 
                NULL, 
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS, 
                NULL,
                &hKey, 
                &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD   dwType;
        DWORD   cbSize;
        
        cbSize = 0;
        RegQueryValueExU(
            hKey, 
            WSZ_CATALOG_FILE_BASE_DIRECTORY, 
            NULL, 
            &dwType, 
            NULL, 
            &cbSize);

        if (cbSize > 0)
        {
            if (NULL == (pwszMigrateFromDir = (LPWSTR) 
                            malloc(sizeof(WCHAR) * ((cbSize / sizeof(WCHAR)) + 3))))
            {
                RegCloseKey(hKey);
                CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
            }

            pwszMigrateFromDir[0] = NULL;

            RegQueryValueExU(
                hKey, 
                WSZ_CATALOG_FILE_BASE_DIRECTORY, 
                NULL, 
                &dwType,
                (BYTE *)pwszMigrateFromDir, 
                &cbSize);

            if (!_CatAdminMigrateCatalogDatabase(
                        pwszMigrateFromDir, 
                        gpwszCatalogFileBaseDirectory))
            {
                RegCloseKey(hKey);
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }
            
            RegDeleteValueU(hKey, WSZ_CATALOG_FILE_BASE_DIRECTORY);
        }

        RegCloseKey(hKey);
    }

    //
    // NOW, that we are in a consistent state
    //
    // For each catalog sub-system, enumerate all catalogs and add them to the 
    // new catalog database under the same sub-system GUID.
    //

    //
    // Create search string to find all catalog sub dirs
    //
    if (NULL == (pwszSearchCatDirs = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory, 
                                            WSZ_CATALOG_SUBSYTEM_SEARCH_STRING,
                                            FALSE))) 

    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandleCatDirs = FindFirstFileU(pwszSearchCatDirs, &FindDataCatDirs);
    if (hFindHandleCatDirs == INVALID_HANDLE_VALUE)
    {
        //   
        // See if a real error occurred, or just no files
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There is nothing to do
            //
            SetLastError(0);
            goto RegKeyAdd; 
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }    

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindDataCatDirs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            _CatAdminMigrateSingleDatabase(FindDataCatDirs.cFileName);   
        } 

        //
        // Get rid of old files
        //
        dwErr = GetLastError();
        if (NULL != (pwsz = _CatAdminCreatePath(
                                    gpwszCatalogFileBaseDirectory, 
                                    FindDataCatDirs.cFileName,
                                    FALSE))) 
        {
            for (i=0; i<NUM_FILES_TO_DELETE; i++)
            {
                            
                if (NULL != (pwszDeleteFile = _CatAdminCreatePath(
                                                    pwsz, 
                                                    ppwszFilesToDelete[i],
                                                    FALSE))) 
                {
                    if (!DeleteFileU(pwszDeleteFile))
                    {
                        //
                        // If delete fails, then log for delete after reboot
                        //
                        MoveFileExW(pwszDeleteFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    free(pwszDeleteFile);
                }             
            }

            free(pwsz);
        }
        SetLastError(dwErr);
        
        //
        // Get next subdir
        //
        if (!FindNextFileU(hFindHandleCatDirs, &FindDataCatDirs))            
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                SetLastError(0);
                break;
            }
            else
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorFindNextFile;
            }
        }
    }

    //
    // Get rid of old files
    // 
    dwErr = GetLastError();
    for (i=0; i<NUM_FILES_TO_DELETE; i++)
    {
        if (NULL != (pwszDeleteFile = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory, 
                                            ppwszFilesToDelete[i],
                                            FALSE))) 
        {
            if (!DeleteFileU(pwszDeleteFile))
            {
                //
                // If delete fails, then log for delete after reboot
                //
                MoveFileExW(pwszDeleteFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }   
            free(pwszDeleteFile);
        }
    }
    SetLastError(dwErr);


RegKeyAdd:

    //
    // Set reg key so backup does not backup the catroot2 directory
    // which contains jet db files
    //
    if (RegCreateKeyExW(    
            HKEY_LOCAL_MACHINE,
            WSZ_REG_FILES_NOT_TO_BACKUP,
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL,
            &hKey, 
            &dwDisposition) == ERROR_SUCCESS)
    {
        if (RegSetValueExW(
                hKey, 
                WSZ_REG_CATALOG_DATABASE_VALUE,
                0, 
                REG_MULTI_SZ,
                (BYTE *) WSZ_PATH_NOT_TO_BACKUP,
                (wcslen(WSZ_PATH_NOT_TO_BACKUP) + 2) * sizeof(WCHAR)) != ERROR_SUCCESS)
        {
            CATADMIN_LOGERR_LASTERR()
        }

        RegCloseKey(hKey);
    }
    else
    {
        CATADMIN_LOGERR_LASTERR()
    }


    //
    // Force the default DB to be created
    //
    if (CryptCATAdminAcquireContext_Internal(
                &hCatAdmin, 
                &gDefault, 
                NULL, 
                TRUE))
    {
        BYTE        rgHash[20]  = {0};
        HCATINFO    hCatInfo    = NULL;

        hCatInfo = CryptCATAdminEnumCatalogFromHash(
                        hCatAdmin,
                        rgHash,
                        20,
                        0,
                        NULL);

        if (hCatInfo != NULL)
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        CryptCATAdminReleaseContext(hCatAdmin, 0);

        //
        // Need to create the timestamp files if they don't exist
        //

        guid2wstr(&gDefault, wszGUID);

        //
        // Construct full subdir path to Catalog files TimeStamp location
        //
        if (NULL == (pwszCatalogFileDir = _CatAdminCreatePath(
                                                gpwszCatalogFileBaseDirectory,
                                                wszGUID,
                                                FALSE)))
        {
            CATADMIN_LOGERR_LASTERR()
            goto CommonReturn; // non fatal for the function, so don't error out
        }

        //
        // Construct full subdir path to Database files TimeStamp location
        //
        if (NULL == (pwszDatabaseFileDir = _CatAdminCreatePath(
                                                gpwszDatabaseFileBaseDirectory,
                                                wszGUID,
                                                FALSE)))
        {
            CATADMIN_LOGERR_LASTERR()
            goto CommonReturn; // non fatal for the function, so don't error out
        }

        //
        // See if they are in sync (if they don't exist, that equals out of sync)
        //
        if (TimeStampFile_InSync(
                    pwszCatalogFileDir,
                    pwszDatabaseFileDir,
                    &fInSync))
        {
            if (!fInSync)
            {
                TimeStampFile_Touch(pwszCatalogFileDir);
                TimeStampFile_Touch(pwszDatabaseFileDir);
            }
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
        }
    }  
    else
    {
        CATADMIN_LOGERR_LASTERR()
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszMigrateFromDir != NULL)
    {
        free(pwszMigrateFromDir);
    }

    if (pwszSearchCatDirs != NULL)
    {
        free(pwszSearchCatDirs);
    }

    if (hFindHandleCatDirs != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatDirs);
    }

    if (pwszCatalogFileDir != NULL)
    {
        free(pwszCatalogFileDir);
    }

    if (pwszDatabaseFileDir != NULL)
    {
        free(pwszDatabaseFileDir);
    }

    SetLastError(dwErr);
    
    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory);
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminMigrateSingleDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminMigrateSingleDatabase(
    LPWSTR  pwszDatabaseGUID)
{
    BOOL                fRet                        = TRUE;
    LPWSTR              pwszCatalogFile             = NULL;
    LPWSTR              pwszSearchCatalogsInDir     = NULL;
    HANDLE              hFindHandleCatalogsInDir    = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatalogsInDir;
    GUID                guid;
    HCATINFO            hCatInfo                    = NULL;
    HCATADMIN           hCatAdmin                   = NULL;
    DWORD               dwErr                       = 0;
    LPWSTR              pwszSubDir                  = NULL;
    LPWSTR              pwszTempDir                 = NULL;
    LPWSTR              pwszTempCatalogFile         = NULL;

    //
    // Acquire the catadmin context to add the catalog files to
    //
    if (!wstr2guid(pwszDatabaseGUID, &guid))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    if (!CryptCATAdminAcquireContext_Internal(&hCatAdmin, &guid, NULL, TRUE))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }            

    //
    // Construct full subdir path so we can search for all cat files
    //
    if (NULL == (pwszSubDir = _CatAdminCreatePath(
                                    gpwszCatalogFileBaseDirectory,
                                    pwszDatabaseGUID,
                                    FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct temp directory path, and create the directory to back it
    //
    if (NULL == (pwszTempDir = _CatAdminCreatePath(
                                                pwszSubDir,
                                                L"TempDir",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatAdminRecursiveCreateDirectory(
            pwszTempDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct the search string
    //
    if (NULL == (pwszSearchCatalogsInDir = _CatAdminCreatePath(
                                                pwszSubDir,
                                                L"*",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // First copy all the catalogs to a temp directory, then add each catalog
    // to the database from the temporary location
    //

    //
    // Copy each file
    //
    memset(&FindDataCatalogsInDir, 0, sizeof(FindDataCatalogsInDir));
    hFindHandleCatalogsInDir = FindFirstFileU(
                                    pwszSearchCatalogsInDir, 
                                    &FindDataCatalogsInDir);
    
    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();

        //
        // no files found
        //
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            SetLastError(0);
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }
    else
    {            
        while (1)
        {
            //
            // Only care about files
            //
            if (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = _CatAdminCreatePath(
                                                    pwszSubDir,
                                                    FindDataCatalogsInDir.cFileName,
                                                    FALSE)))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
                
                //
                // Verify that this is a catalog and then copy it to the temp dir
                // which is where it will be installed from
                //
                if (IsCatalogFile(NULL, pwszCatalogFile))
                {
                    if (NULL == (pwszTempCatalogFile = _CatAdminCreatePath(
                                                            pwszTempDir,
                                                            FindDataCatalogsInDir.cFileName,
                                                            FALSE)))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }

                    if (!CopyFileU(pwszCatalogFile, pwszTempCatalogFile, FALSE))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }

                    free(pwszTempCatalogFile);
                    pwszTempCatalogFile = NULL;                    
                }
            
                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }                                                       

            //
            // Get next catalog file
            //
            if (!FindNextFileU(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))            
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorFindNextFile;
                }
            }
        }
    }

    //
    // Free up stuff used for find
    //
    free(pwszSearchCatalogsInDir);
    pwszSearchCatalogsInDir = NULL;
    FindClose(hFindHandleCatalogsInDir);
    hFindHandleCatalogsInDir = INVALID_HANDLE_VALUE;
    memset(&FindDataCatalogsInDir, 0, sizeof(FindDataCatalogsInDir));

    //
    // Construct the new search string which point to the temp dir
    //
    if (NULL == (pwszSearchCatalogsInDir = _CatAdminCreatePath(
                                                pwszTempDir,
                                                L"*",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Add each catalog in the temp dir to the database
    //
    hFindHandleCatalogsInDir = FindFirstFileU(
                                    pwszSearchCatalogsInDir, 
                                    &FindDataCatalogsInDir);
    
    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();

        //
        // no files found
        //
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            SetLastError(0);
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }
    else
    {            
        while (1)
        {
            //
            // Only care about files
            //
            if (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = _CatAdminCreatePath(
                                                    pwszTempDir,
                                                    FindDataCatalogsInDir.cFileName,
                                                    FALSE)))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
                
                hCatInfo = CryptCATAdminAddCatalog(
                                hCatAdmin,
                                pwszCatalogFile,
                                FindDataCatalogsInDir.cFileName,
                                NULL);
                
                if (hCatInfo != NULL)
                {
                    CryptCATAdminReleaseCatalogContext(
                            hCatAdmin, 
                            hCatInfo, 
                            NULL);
                    hCatInfo = NULL;
                }
                else
                {
                    // Log error
                    CATADMIN_LOGERR_LASTERR()
                }
                        
                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }                                                       

            //
            // Get next catalog file
            //
            if (!FindNextFileU(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))            
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorFindNextFile;
                }
            }
        }
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszSubDir != NULL)
    {
        free(pwszSubDir);
    }

    if (pwszCatalogFile != NULL)
    {
        free(pwszCatalogFile);
    }

    if (pwszSearchCatalogsInDir != NULL)
    {
        free(pwszSearchCatalogsInDir);
    }

    if (pwszTempDir != NULL)
    {
        I_RecursiveDeleteDirectory(pwszTempDir);
        free(pwszTempDir);
    }

    if (pwszTempCatalogFile != NULL)
    {
        free(pwszTempCatalogFile);
    }

    if (hFindHandleCatalogsInDir != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatalogsInDir);
    }

    if (hCatAdmin != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdmin, NULL);
    }

    SetLastError(dwErr);
    
    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


//---------------------------------------------------------------------------------------
//
//  CatAdminDllMain
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
CatAdminDllMain(
    HANDLE hInstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    BOOL fRet = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
                fRet = _CatAdminSetupDefaults();
                break;

        case DLL_PROCESS_DETACH:
                _CatAdminCleanupDefaults();
                break;
    }

    return(fRet);
}


//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
// Internal functions
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------
//
//  _CatAdminSetupDefaults
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminSetupDefaults(void)
{
    BOOL    fRet                    = TRUE;
    WCHAR   wszDefaultSystemDir[MAX_PATH + 1];
    
    //
    // Get System default directory
    //
    wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(wszDefaultSystemDir, MAX_PATH))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorSystemError;
    }
    
    //
    // Get catalog file base directory 
    //
    if (NULL == (gpwszCatalogFileBaseDirectory = 
                            _CatAdminCreatePath(
                                    wszDefaultSystemDir, 
                                    WSZ_CATALOG_FILE_BASE_DIRECTORY, 
                                    TRUE)))                   
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get database file base directory
    //
    if (NULL == (gpwszDatabaseFileBaseDirectory = 
                            _CatAdminCreatePath(
                                    wszDefaultSystemDir, 
                                    WSZ_DATABASE_FILE_BASE_DIRECTORY, 
                                    TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

CommonReturn:

    return(fRet);

ErrorReturn:

    if (gpwszCatalogFileBaseDirectory != NULL)
    {
        free(gpwszCatalogFileBaseDirectory);
        gpwszCatalogFileBaseDirectory = NULL;
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorSystemError);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCleanupDefaults
//
//---------------------------------------------------------------------------------------
void _CatAdminCleanupDefaults(void)
{
    if (gpwszCatalogFileBaseDirectory != NULL)
    {
        free(gpwszCatalogFileBaseDirectory);
        gpwszCatalogFileBaseDirectory = NULL;
    }

    if (gpwszDatabaseFileBaseDirectory != NULL)
    {
        free(gpwszDatabaseFileBaseDirectory);
        gpwszDatabaseFileBaseDirectory = NULL;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminTimeStampFilesInSync
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminTimeStampFilesInSync(
    LPWSTR  pwszDatabaseGUID,
    BOOL    *pfInSync)
{
    LPWSTR  pwszCatalogFileDir  = NULL;
    LPWSTR  pwszDatabaseFileDir = NULL;
    BOOL    fRet                = TRUE;

    *pfInSync = FALSE;

    //
    // Construct full subdir path to Catalog files TimeStamp location
    //
    if (NULL == (pwszCatalogFileDir = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory,
                                            pwszDatabaseGUID,
                                            FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct full subdir path to Database files TimeStamp location
    //
    if (NULL == (pwszDatabaseFileDir = _CatAdminCreatePath(
                                            gpwszDatabaseFileBaseDirectory,
                                            pwszDatabaseGUID,
                                            FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    fRet = TimeStampFile_InSync(
                pwszCatalogFileDir,
                pwszDatabaseFileDir,
                pfInSync);

CommonReturn:

    if (pwszCatalogFileDir != NULL)
    {
        free(pwszCatalogFileDir);
    }

    if (pwszDatabaseFileDir != NULL)
    {
        free(pwszDatabaseFileDir);
    }
    
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  _CatAdminRegisterForChangeNotification
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminRegisterForChangeNotification(
    CRYPT_CAT_ADMIN *pCatAdmin
    )
{
    BOOL    fRet    = TRUE;
    DWORD   dwErr   = 0;

    //
    // See if already registered
    //
    if (pCatAdmin->fRegisteredForChangeNotification)
    {
        goto CommonReturn;
    }

    //
    // NOTE:
    // Currently the service ignores the pwszSubSysGUID when registering a change
    // notification because it DOES NOT do notifications on a per pwszSubSysDir basis... 
    // it really should at some point.
    // When it does start to do notifications on per pwszSubSysGUID this will need to
    // change.  CryptCatAdminAcquireContext can be called with a NULL subSysGUID,
    // in which case all SubSysDirs are used, so we would need to register a 
    // change notification for all of them.
    //

    //
    // Register the event with the DB process, so the DB process can SetEvent() it
    // when a changed occurs
    //
    if (0 != (dwErr = Client_SSCatDBRegisterForChangeNotification(
                            (DWORD_PTR) pCatAdmin->hClearCacheEvent,
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            FALSE)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

    pCatAdmin->fRegisteredForChangeNotification = TRUE;

CommonReturn:

    return fRet;

ErrorReturn:
    
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminFreeCachedCatalogs
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminFreeCachedCatalogs(
    CRYPT_CAT_ADMIN         *pCatAdmin)
{
    BOOL                    fRet                = TRUE;
    LIST_NODE               *pListNode          = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;
    
    //
    // NOTE: the caller of this function must have entered the Critical Section for
    // the CatAdminContext
    //

    //
    // Enumerate through all the cached CATALOG_INFO_CONTEXTs and free all the 
    // resources for each
    //
    pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
    while (pListNode != NULL)
    {
        pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);
        
        free(pCatInfoContext->pwszCatalogFile);
        CertFreeCTLContext(pCatInfoContext->pCTLContext);
        UnmapViewOfFile(pCatInfoContext->pbMappedFile);
        CloseHandle(pCatInfoContext->hMappedFile);

        free(pCatInfoContext);

        pListNode = LIST_GetNext(pListNode);
    }
    LIST_RemoveAll(&(pCatAdmin->CatalogInfoContextList));

    return(fRet);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminWaitOrTimerCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatAdminWaitOrTimerCallback(
    PVOID lpParameter, 
    BOOLEAN TimerOrWaitFired)
{
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *) lpParameter;
    int                     i                   = 0;
    LIST_NODE               *pListNode          = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;

    //
    // Enter the CS before wacking anything
    //
    __try
    {
        EnterCriticalSection(&(pCatAdmin->CriticalSection));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError(GetExceptionCode());
        CATADMIN_LOGERR_LASTERR()
        return;
    }
    pCatAdmin->fCSEntered = TRUE;

    //
    // If there is an open ref count, then we can't clean up
    //
    if (pCatAdmin->nOpenCatInfoContexts != 0)
    {
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));
        return;  
    }

    //
    // Cleanup all the cached CATALOG_INFO_CONTEXTs
    //
    _CatAdminFreeCachedCatalogs(pCatAdmin);
    
    pCatAdmin->fCSEntered = FALSE;
    LeaveCriticalSection(&(pCatAdmin->CriticalSection));
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminAddCatalogsToCache
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminAddCatalogsToCache(
    CRYPT_CAT_ADMIN *pCatAdmin,
    LPWSTR pwszSubSysGUID, 
    CRYPT_DATA_BLOB *pCryptDataBlob, 
    LIST_NODE **ppFirstListNodeAdded)
{
    BOOL                    fRet                = TRUE;
    LPWSTR                  pwszCopy            = NULL;
    DWORD                   i;
    DWORD                   dwNumCatalogNames   = 0;
    LPWSTR                  *ppwszCatalogNames  = NULL;
    DWORD                   dwErr               = 0;
    LIST_NODE               *pListNode          = NULL;
    LPWSTR                  pwszSubSysDir       = NULL;   
    BOOL                    fFirstCatalogAdded  = FALSE;
    
    if (ppFirstListNodeAdded != NULL)
    {
        *ppFirstListNodeAdded = NULL;
    }

    if (NULL == (pwszSubSysDir = _CatAdminCreatePath(
                                        gpwszCatalogFileBaseDirectory, 
                                        pwszSubSysGUID, 
                                        FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Call DB process and get list of catalogs into ppwszCatalogNames
    //
    // NOTE: the order in which the service adds CatNames to the list results in
    // only the first CatName of the list being guaranteed to contain the
    // hash... all other CatNames may or may not contain the hash.  Which
    // is OK because this code only assumes the first CatName contains the 
    // hash, and then searches all other CatNames for the hash before returning them.
    //
    if (0 != (dwErr = Client_SSCatDBEnumCatalogs(
                            0,
                            pwszSubSysGUID,
                            pCryptDataBlob->pbData,
                            pCryptDataBlob->cbData,
                            &dwNumCatalogNames,
                            &ppwszCatalogNames)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorServiceError)
    }

    //
    // Loop for each catalog and create the CTL context
    //
    for (i=0; i<dwNumCatalogNames; i++)
    {
        //
        // Make a copy of the catalog file name
        //
        if (NULL == (pwszCopy = _CatAdminCreatePath(
                                        pwszSubSysDir, 
                                        ppwszCatalogNames[i], 
                                        FALSE)))                         
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (!_CatAdminAddSingleCatalogToCache(
                pCatAdmin,
                pwszCopy, 
                &pListNode))
        {
            //
            // if this isn't the first catalog, then continue since the
            // macro operation may still succeed without the current catalog
            //
            if (i != 0)
            {
                CATADMIN_LOGERR_LASTERR()
                continue;
            }
            
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // This will only be set for the first catalog added, 
        // as per the NOTE above
        //
        if ((ppFirstListNodeAdded != NULL) &&
            (*ppFirstListNodeAdded == NULL))
        {
            *ppFirstListNodeAdded = pListNode;
        }
    }

CommonReturn:

    if (ppwszCatalogNames != NULL)
    {
        for (i=0; i<dwNumCatalogNames; i++)
        {
            MIDL_user_free(ppwszCatalogNames[i]);
        }

        MIDL_user_free(ppwszCatalogNames);
    }
    
    if (pwszSubSysDir != NULL)
    {
        free(pwszSubSysDir);
    }

    return(fRet);

ErrorReturn:

    if (pwszCopy != NULL)
    {
        free(pwszCopy);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorServiceError)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminAddSingleCatalogToCache
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminAddSingleCatalogToCache(
    CRYPT_CAT_ADMIN *pCatAdmin,
    LPWSTR pwszCatalog, 
    LIST_NODE **ppListNodeAdded)
{
    BOOL                    fRet                = TRUE;
    DWORD                   dwErr               = 0;
    LIST_NODE               *pListNode          = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContextAdd = NULL;

    *ppListNodeAdded = NULL;

    //
    // If there is already a copy of this catalog, then just get out
    //
    pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
    while (pListNode != NULL)
    {
        pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

        if (_wcsicmp(pCatInfoContext->pwszCatalogFile, pwszCatalog) == 0)
        {
            *ppListNodeAdded = pListNode;
            goto CommonReturn;
        }

        pListNode = LIST_GetNext(pListNode);
    }

    //
    // Allocate space for a new cached catalog context
    //
    if (NULL == (pCatInfoContextAdd = (CATALOG_INFO_CONTEXT *) 
                    malloc(sizeof(CATALOG_INFO_CONTEXT))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    memset(pCatInfoContextAdd, 0, sizeof(CATALOG_INFO_CONTEXT));
    pCatInfoContextAdd->fResultOfAdd = FALSE;
    
    //
    // Open, create a file mapping, and create the CTL context for 
    // the catalog file
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalog,
            &pCatInfoContextAdd->hMappedFile,
            &pCatInfoContextAdd->pbMappedFile,
            &pCatInfoContextAdd->pCTLContext,
            TRUE))
    {
        CATADMIN_LOGERR_LASTERR()
        ErrLog_LogString(NULL, L"The following file was not found - ", pwszCatalog, TRUE);
        goto ErrorReturn;
    }
    
    pCatInfoContextAdd->pwszCatalogFile = pwszCatalog;

    //
    // Add to the list of cached catalog contexts
    //
    if (NULL == (pListNode = LIST_AddTail(
                                &(pCatAdmin->CatalogInfoContextList), 
                                pCatInfoContextAdd)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    *ppListNodeAdded = pListNode;
        
CommonReturn:

    return(fRet);

ErrorReturn:

    dwErr = GetLastError();
    
    if (pCatInfoContextAdd != NULL)
    {
        if (pCatInfoContextAdd->pCTLContext != NULL)
        {
            CertFreeCTLContext(pCatInfoContextAdd->pCTLContext);
        }

        if (pCatInfoContextAdd->pbMappedFile != NULL)
        {
            UnmapViewOfFile(pCatInfoContextAdd->pbMappedFile);
        }

        if (pCatInfoContextAdd->hMappedFile != NULL)
        {
            CloseHandle(pCatInfoContextAdd->hMappedFile);
        }

        free(pCatInfoContextAdd);        
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
// _CatAdminMigrateCatalogDatabase
//
// This migration code deals with very old catalog databases.  In the olden days, the 
// catroot dir location could be specified by a particular registry key... that is no 
// longer true.  So, if an old system is being upgraded that has the registry key, this 
// code moves all the catalog files from the location specified by the registry key to 
// the %SystemDefaultDir%\Catroot dir.  Then it shwacks the registry key.
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminMigrateCatalogDatabase(
    LPWSTR pwszFrom, 
    LPWSTR pwszTo)
{
    DWORD   dwAttr = 0;
    WCHAR   wszFrom[MAX_PATH];
    WCHAR   wszTo[MAX_PATH];

    //
    // If they are the same dir then just get out
    //
    if (((wcslen(pwszFrom) + 1) > MAX_PATH) ||
        ((wcslen(pwszFrom) + 1) > MAX_PATH))
    {
        return TRUE;
    }
    wcscpy(wszFrom, pwszFrom);
    wcscpy(wszTo, pwszTo);
    if (wszFrom[wcslen(wszFrom) - 1] != L'\\')
    {
        wcscat(wszFrom, L"\\");
    }
    if (wszTo[wcslen(wszTo) - 1] != L'\\')
    {
        wcscat(wszTo, L"\\");
    }
    if (_wcsicmp(wszFrom, wszTo) == 0)
    {
        return TRUE;
    }

    //
    // if the pwszTo dir already exists, then don't do a thing.
    //
    dwAttr = GetFileAttributesU(pwszTo);

    if (0xFFFFFFFF != dwAttr) 
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
        {
            //
            // dir already exists... 
            //
            return TRUE;
        }
        else
        {
            //
            // something exists with pwszTo name, but it isn't a dir
            //
            CATADMIN_LOGERR_LASTERR()
            return FALSE;
        }
    }

    //
    // if the pwszFrom dir does not exist, then don't do a thing.
    //
    dwAttr = GetFileAttributesU(pwszFrom);

    if ((0xFFFFFFFF == dwAttr) || (!(FILE_ATTRIBUTE_DIRECTORY & dwAttr)))
    {
        return TRUE;
    }

    if (!_CatAdminRecursiveCreateDirectory(pwszTo, NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        return FALSE;
    }

    if (!I_RecursiveCopyDirectory(pwszFrom, pwszTo))
    {
        CATADMIN_LOGERR_LASTERR()
        return FALSE;
    }

    //
    // Don't check for error on delete since this operation is NOT mandatory
    //
    I_RecursiveDeleteDirectory(pwszFrom);

    return TRUE;
}




//---------------------------------------------------------------------------------------
//
//  _CatAdminBToHex
//
//---------------------------------------------------------------------------------------
WCHAR rgHexDigit[] = {  L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
                        L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F' };
void 
_CatAdminBToHex (
    LPBYTE pbDigest, 
    DWORD iByte, 
    LPWSTR pwszHashTag)
{
    DWORD iTag;
    DWORD iHexDigit1;
    DWORD iHexDigit2;

    iTag = iByte * 2;
    iHexDigit1 = (pbDigest[iByte] & 0xF0) >> 4;
    iHexDigit2 = (pbDigest[iByte] & 0x0F);

    pwszHashTag[iTag] = rgHexDigit[iHexDigit1];
    pwszHashTag[iTag + 1] = rgHexDigit[iHexDigit2];
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCreateHashTag
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminCreateHashTag(
    BYTE            *pbHash,
    DWORD           cbHash,
    LPWSTR          *ppwszHashTag,
    CRYPT_DATA_BLOB *pCryptDataBlob)
{
    DWORD           cwTag;
    DWORD           cCount;
    
    cwTag = ((cbHash * 2) + 1);
    if (NULL == (*ppwszHashTag = (LPWSTR) malloc(cwTag * sizeof(WCHAR))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        CATADMIN_LOGERR_LASTERR()
        return(FALSE);
    }

    for (cCount = 0; cCount < cbHash; cCount++)
    {
        _CatAdminBToHex(pbHash, cCount, *ppwszHashTag);
    }
    (*ppwszHashTag)[cwTag - 1] = L'\0';

    pCryptDataBlob->pbData = (BYTE *) *ppwszHashTag;
    pCryptDataBlob->cbData = cwTag * sizeof(WCHAR);

    return (TRUE);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminRecursiveCreateDirectory
//
//---------------------------------------------------------------------------------------
BOOL 
_CatAdminRecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    BOOL fResult;

    DWORD dwAttr;
    DWORD dwErr;
    LPCWSTR pwsz;
    DWORD cch;
    WCHAR wch;
    LPWSTR pwszParent = NULL;

    //
    // if last char is a '\', then just strip it and recurse
    //
    if (pwszDir[wcslen(pwszDir) - 1] == L'\\')
    {
        cch = wcslen(pwszDir);
        if (NULL == (pwszParent = (LPWSTR) malloc(cch * sizeof(WCHAR))))
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }

        memcpy(pwszParent, pwszDir, (cch - 1) * sizeof(WCHAR));
        pwszParent[cch - 1] = L'\0';

        fResult = _CatAdminRecursiveCreateDirectory(
                        pwszParent, 
                        lpSecurityAttributes);

        goto CommonReturn;
    }

    //
    // See if dir already exists
    //
    dwAttr = GetFileAttributesU(pwszDir);
    if (0xFFFFFFFF != dwAttr) 
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
        {
            return TRUE;
        }

        CATADMIN_LOGERR_LASTERR()
        goto InvalidDirectoryAttr;
    }

    //
    // If it was an error other than file/path not found, error out
    //
    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
    {
        CATADMIN_LOGERR_LASTERR()
        goto GetFileAttrError;
    }

    //
    // Try creating the new dir
    //
    if (CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes)) 
    {
        SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_NORMAL);
        return TRUE;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
    {
        CATADMIN_LOGERR_LASTERR()
        goto CreateDirectoryError;
    }

    //
    // Peal off the last path name component
    //
    cch = wcslen(pwszDir);
    pwsz = pwszDir + cch;

    while (L'\\' != *pwsz) 
    {
        if (pwsz == pwszDir)
        {
            // Path didn't have a \.
            CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
        }
        pwsz--;
    }

    cch = (DWORD)(pwsz - pwszDir);
    if (0 == cch)
    {
        // Detected leading \Path
        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
    }


    // Check for leading \\ or x:\.
    wch = *(pwsz - 1);
    if ((1 == cch && L'\\' == wch) || (2 == cch && L':' == wch))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
    }

    if (NULL == (pwszParent = (LPWSTR) malloc((cch + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memcpy(pwszParent, pwszDir, cch * sizeof(WCHAR));
    pwszParent[cch] = L'\0';

    if (!_CatAdminRecursiveCreateDirectory(pwszParent, lpSecurityAttributes))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes)) 
    {
        CATADMIN_LOGERR_LASTERR()
        goto CreateDirectory2Error;
    }
    SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_NORMAL);

    fResult = TRUE;

CommonReturn:

    if (pwszParent != NULL)
    {
        free(pwszParent);
    }
    return fResult;
ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, InvalidDirectoryAttr)
TRACE_ERROR_EX(DBG_SS_TRUST, GetFileAttrError)
TRACE_ERROR_EX(DBG_SS_TRUST, CreateDirectoryError)
TRACE_ERROR_EX(DBG_SS_TRUST, BadDirectoryPath)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_TRUST, CreateDirectory2Error)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCreatePath
//
//---------------------------------------------------------------------------------------
LPWSTR 
_CatAdminCreatePath(
    IN LPCWSTR  pwsz1,
    IN LPCWSTR  pwsz2,
    IN BOOL     fAddEndingSlash
    )
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of pwsz1, length of pwsz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;
    if (fAddEndingSlash)
    {
        nTotalLen++;   
    }

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) malloc(sizeof(WCHAR) * nTotalLen)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        wcscat(pwszTemp, L"\\");
    }

    //
    // Tack on pwsz2
    //
    wcscat(pwszTemp, pwsz2);

    if (fAddEndingSlash)
    {
        wcscat(pwszTemp, L"\\");
    }

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\tcrack.cpp ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       tcrack.cpp
//
//  Contents:   API testing of CryptEncodeObject/CryptDecodeObject.
//
//  History:    29-January-97   xiaohs   created
//
//--------------------------------------------------------------------------
#include "global.hxx"

//--------------------------------------------------------------------------
//  See if the sequence "81 7f" is in the BLOB.  If it is, we need to fix it
//--------------------------------------------------------------------------
BOOL    BadCert(DWORD   cbEncoded, BYTE *pbEncoded)
{
    DWORD   iIndex=0;
    DWORD   iLimit=cbEncoded-2;
    BYTE    rgByte[2];


    assert(pbEncoded);


    memset(rgByte, 0, 2);

    //set the rgByte to be the patter of 0x81 0x7F, which is 10000001 and 01111111,
    //whic his 129 and 127 in decimal
    rgByte[0]=rgByte[0]|129;
    rgByte[1]=rgByte[1]|127;


    for(iIndex=0;iIndex<=iLimit;iIndex++)
    {
        if(memcmp(rgByte,&(pbEncoded[iIndex]),2)==0)
            return TRUE;
    }

    return FALSE;

}

//--------------------------------------------------------------------------
//  Copy the BLOBs
//--------------------------------------------------------------------------
void    SetData(DWORD   cbNewData, BYTE *pbNewData,
                DWORD   *pcbOldData, BYTE **ppbOldData)
{
    assert(pcbOldData);
    assert(ppbOldData);

    *pcbOldData=cbNewData;
    *ppbOldData=pbNewData;
}


///////////////////////////////////////////////////////////////////////////
//Certificate Manipulation Functions
//--------------------------------------------------------------------------
//  This is the functions
//--------------------------------------------------------------------------
BOOL    Fix7FCert(DWORD cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded)
{

    //init
    *pcbEncoded=0;
    *ppbEncoded=NULL;



    if(!BadCert(cbEncoded, pbEncoded))
        return TRUE;


    if(DecodeX509_CERT(cbEncoded, pbEncoded,pcbEncoded,
                        ppbEncoded))
        return TRUE;
    else
    {
        //release the memory
        SAFE_FREE(*ppbEncoded)
        *ppbEncoded=NULL;
        *pcbEncoded=0;
        return FALSE;
    }


}

//--------------------------------------------------------------------------
//  A general routine to encode a struct based on lpszStructType
//--------------------------------------------------------------------------
BOOL    EncodeStruct(LPCSTR lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
                     BYTE **ppbEncoded)
{
    BOOL    fSucceeded=FALSE;
    DWORD   cbEncoded=NULL;

    //init
    *pcbEncoded=0;
    *ppbEncoded=NULL;

    assert(lpszStructType);
    assert(pStructInfo);


    //length only calculation
    TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,lpszStructType, pStructInfo,NULL,
            &cbEncoded),TRUE)

    //the struct has to be more than 0 byte
    assert(cbEncoded);

    //allocate the correct amount of memory
    *ppbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
    CHECK_POINTER(*ppbEncoded);

    //Encode the strcut with *pcbEncoded == the correct length
    *pcbEncoded=cbEncoded;

    //Encode the struct
    TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,lpszStructType,pStructInfo,*ppbEncoded,
        pcbEncoded),TRUE)

    fSucceeded=TRUE;

TCLEANUP:

    return fSucceeded;

}

//--------------------------------------------------------------------------
//  A general routine to decode a BLOB based on lpszStructType
//
//--------------------------------------------------------------------------
BOOL  DecodeBLOB(LPCSTR lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
                  DWORD *pcbStructInfo, void **ppvStructInfo)
{
    BOOL    fSucceeded=FALSE;
    DWORD   cbStructInfo=0;

    //init
    *pcbStructInfo=0;
    *ppvStructInfo=NULL;

    assert(lpszStructType);
    assert(pbEncoded);
    assert(cbEncoded);

    //Decode.  Length Only Calculation
    TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,lpszStructType,pbEncoded,cbEncoded,
    CRYPT_DECODE_FLAG,NULL,&cbStructInfo),TRUE)

    //the struct has to be more than 0 byte
    assert(cbStructInfo);

    *ppvStructInfo=(BYTE *)SAFE_ALLOC(cbStructInfo);
    CHECK_POINTER(*ppvStructInfo);

    //Decode the BLOB with *pcbStructInfo==correct length
    *pcbStructInfo=cbStructInfo;

    TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,lpszStructType,pbEncoded,cbEncoded,
    CRYPT_DECODE_FLAG,*ppvStructInfo,pcbStructInfo),TRUE)


    fSucceeded=TRUE;

TCLEANUP:

    return fSucceeded;

}

//--------------------------------------------------------------------------
//  Decode X509_CERT BLOBs
//
//--------------------------------------------------------------------------
BOOL    DecodeX509_CERT(DWORD cbEncoded, BYTE *pbEncoded,DWORD *pcbEncoded,
                        BYTE    **ppbEncoded)
{
    BOOL    fSucceeded=FALSE;
    DWORD   cbStructInfo=0;
    void    *pStructInfo=NULL;
    LPCSTR  lpszStructType=NULL;
    DWORD   cbToBeSigned=0;
    BYTE    *pbToBeSigned=NULL;
    DWORD   cbOldSigned=0;
    BYTE    *pbOldSigned=NULL;

    //init
    lpszStructType=X509_CERT;


    //Decode the encoded BLOB
    TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,&cbStructInfo,
        &pStructInfo),TRUE)

    //Further Decode the X509_CERT_TO_BE_SIGNED
    //Notice we should use the original cbData and pbData passed in for Decode
    //but use ToBeSigned in CERT_SIGNED_CONTENT_INFO for encode purpose

    TESTC(DecodeX509_CERT_TO_BE_SIGNED(cbEncoded,
        pbEncoded,&cbToBeSigned,&pbToBeSigned),TRUE);

    //copy the new encoded BLOB
    SetData((((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
               (((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData,
               &cbOldSigned, &pbOldSigned);

    SetData(cbToBeSigned, pbToBeSigned,
                &((((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData),
                &((((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData));


    //if requested, encode the BLOB back to what it was.  Make sure no data is lost
    //by checking the size of the encoded blob and do a memcmp.
    TESTC(EncodeStruct(lpszStructType, pStructInfo,pcbEncoded, ppbEncoded),TRUE);

    fSucceeded=TRUE;

TCLEANUP:

    SetData(cbOldSigned, pbOldSigned,
            &((((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData),
            &((((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData));


    SAFE_FREE(pStructInfo)

    SAFE_FREE(pbToBeSigned)

    return fSucceeded;

}



//--------------------------------------------------------------------------
//  Decode X509_CERT_TO_BE_SIGNED BLOBs
//
//--------------------------------------------------------------------------
BOOL    DecodeX509_CERT_TO_BE_SIGNED(DWORD  cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded)
{

    BOOL    fSucceeded=FALSE;
    DWORD   cbStructInfo=0;
    void    *pStructInfo=NULL;
    LPCSTR  lpszStructType=NULL;


    DWORD   cbOldIssuer=0;
    BYTE    *pbOldIssuer=NULL;
    DWORD   cbIssuer=0;
    BYTE    *pbIssuer=NULL;


    DWORD   cbOldSubject=0;
    BYTE    *pbOldSubject=NULL;
    DWORD   cbSubject=0;
    BYTE    *pbSubject=NULL;


    //init
    lpszStructType=X509_CERT_TO_BE_SIGNED;


    //Decode the encoded BLOB
    TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,&cbStructInfo,
        &pStructInfo),TRUE)


      //Decode Issuer in CERT_INFO struct
    TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Issuer).cbData,
    (((PCERT_INFO)pStructInfo)->Issuer).pbData,&cbIssuer,&pbIssuer),TRUE)

    SetData((((PCERT_INFO)pStructInfo)->Issuer).cbData,
            (((PCERT_INFO)pStructInfo)->Issuer).pbData,&cbOldIssuer,&pbOldIssuer);

    SetData(cbIssuer, pbIssuer,
            &((((PCERT_INFO)pStructInfo)->Issuer).cbData),
            &((((PCERT_INFO)pStructInfo)->Issuer).pbData));



    //Decode Subject in CERT_INFO struct
    TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Subject).cbData,
    (((PCERT_INFO)pStructInfo)->Subject).pbData,&cbSubject,&pbSubject),TRUE)

    SetData((((PCERT_INFO)pStructInfo)->Subject).cbData,
    (((PCERT_INFO)pStructInfo)->Subject).pbData,
    &cbOldSubject, &pbOldSubject);

    SetData(cbSubject, pbSubject,
        &((((PCERT_INFO)pStructInfo)->Subject).cbData),
        &((((PCERT_INFO)pStructInfo)->Subject).pbData));




    //if requested, encode the BLOB back to what it was.  Make sure no data is lost
    //by checking the size of the encoded blob and do a memcmp.
    TESTC(EncodeStruct(lpszStructType, pStructInfo,pcbEncoded,
        ppbEncoded),TRUE);



    fSucceeded=TRUE;

TCLEANUP:

    //copy back the old values
    SetData(cbOldSubject, pbOldSubject,
        &((((PCERT_INFO)pStructInfo)->Subject).cbData),
        &((((PCERT_INFO)pStructInfo)->Subject).pbData));


    SetData(cbOldIssuer, pbOldIssuer,
            &((((PCERT_INFO)pStructInfo)->Issuer).cbData),
            &((((PCERT_INFO)pStructInfo)->Issuer).pbData));



    SAFE_FREE(pStructInfo)

    SAFE_FREE(pbSubject)

    SAFE_FREE(pbIssuer)

    return fSucceeded;

}

//--------------------------------------------------------------------------
//  Decode X509_NAME BLOBs
//
//--------------------------------------------------------------------------
BOOL    DecodeX509_NAME(DWORD   cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded)
{

    BOOL    fSucceeded=FALSE;
    DWORD   cbStructInfo=0;
    void    *pStructInfo=NULL;
    LPCSTR  lpszStructType=NULL;


    //init
    lpszStructType=X509_NAME;


    //Decode the encoded BLOB
    TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,&cbStructInfo,
        &pStructInfo),TRUE)


    //if requested, encode the BLOB back to what it was.  Make sure no data is lost
    //by checking the size of the encoded blob and do a memcmp.
    TESTC(EncodeStruct(lpszStructType, pStructInfo,pcbEncoded, ppbEncoded),TRUE);


    fSucceeded=TRUE;

TCLEANUP:

    SAFE_FREE(pStructInfo)

    return fSucceeded;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\pkireg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkireg.cpp
//
//  Contents:   Microsoft Internet Security Register
//
//  Functions:  RegisterCryptoDlls
//              CleanupRegistry
//
//              *** local functions ***
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "cryptreg.h"

char    *ppszDlls[] =
                {
                    "wintrust.dll",
                    "mssign32.dll",
                    "cryptui.dll",
                    "cryptnet.dll",
                    "cryptext.dll",
                    "xenroll.dll",

                    NULL
                };

POLSET   psPolicySettings[] =
                {
                    WTPF_IGNOREREVOKATION,      FALSE,
                    WTPF_IGNOREREVOCATIONONTS,  TRUE,
                    WTPF_OFFLINEOK_IND,         TRUE,
                    WTPF_OFFLINEOK_COM,         TRUE,
                    WTPF_OFFLINEOKNBU_IND,      TRUE,
                    WTPF_OFFLINEOKNBU_COM,      TRUE,

                    0, 0
                };

char    *ppszOldHKLMRegistryKeys[] =
                {
                    "SOFTWARE\\Microsoft\\Cryptography\\Providers\\Subject",

                    NULL
                };

void DeleteKeys(HKEY hKeyParent, char *pszKey);


#define PKIREG_WINLOGON_EXT_PREFIX \
    "Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\"

void RegisterWinlogonExtension(
    IN LPCSTR pszSubKey,
    IN LPCSTR pszDll,
    IN LPCSTR pszProc
    )
{
    HKEY  hKey;
    DWORD dwDisposition;
    DWORD dwValue;

    LPSTR pszKey;       // _alloca'ed
    DWORD cchKey;
    

    if ( FIsWinNT5() == FALSE )
    {
        return;
    }

    cchKey = strlen(PKIREG_WINLOGON_EXT_PREFIX) + strlen(pszSubKey) + 1;
    __try {
        pszKey = (LPSTR) _alloca(cchKey);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return;
    }

    strcpy(pszKey, PKIREG_WINLOGON_EXT_PREFIX);
    strcat(pszKey, pszSubKey);

    if ( RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            pszKey,
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ) != ERROR_SUCCESS )
    {
        return;
    }

    dwValue = 0;
    RegSetValueExA( hKey, "Asynchronous", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof( dwValue ) );
    RegSetValueExA( hKey, "Impersonate", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof( dwValue ) );

    RegSetValueExA( hKey, "DllName", 0, REG_EXPAND_SZ, (LPBYTE) pszDll,
        strlen(pszDll) + 1 );
    RegSetValueExA( hKey, "Logoff", 0, REG_SZ, (LPBYTE) pszProc,
        strlen(pszProc) + 1 );

    RegCloseKey( hKey );
}


void RegisterCrypt32EventSource()
{
    HKEY hKey;
    DWORD dwDisposition;
    LPCSTR pszEventMessageFile = "%SystemRoot%\\System32\\crypt32.dll";
    DWORD dwTypesSupported;

    if ( FIsWinNT5() == FALSE )
    {
        return;
    }

    if ( RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\crypt32",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ) != ERROR_SUCCESS )
    {
        return;
    }

    RegSetValueExA(
        hKey,
        "EventMessageFile",
        0,
        REG_EXPAND_SZ,
        (LPBYTE) pszEventMessageFile,
        strlen(pszEventMessageFile) + 1
        );
 
    dwTypesSupported = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE;

    RegSetValueExA(
        hKey,
        "TypesSupported",
        0,
        REG_DWORD,
        (LPBYTE) &dwTypesSupported,
        sizeof(DWORD)
        );
 
    RegCloseKey( hKey );
} 


HRESULT RegisterCryptoDlls(BOOL fSetFlags)
{
    char    **ppszDll;

    BOOL    fRet;

    fRet    = TRUE;
    ppszDll = ppszDlls;

    while (*ppszDll)
    {
        fRet &= _LoadAndRegister(*ppszDll, FALSE);

        ppszDll++;
    }

    if (fSetFlags)
    {
        fRet &= _AdjustPolicyFlags(psPolicySettings);
    }

    // Unregister previously registered DLL's

    // vsrevoke.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"vsrevoke.dll"
            );

    // mscrlrev.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            );

    // msctl.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
            L"msctl.dll"
            );

    RegisterWinlogonExtension("crypt32chain", "crypt32.dll",
        "ChainWlxLogoffEvent");
    RegisterWinlogonExtension("cryptnet", "cryptnet.dll",
        "CryptnetWlxLogoffEvent");

    RegisterCrypt32EventSource();

    return((fRet) ? S_OK : S_FALSE);

}

HRESULT UnregisterCryptoDlls(void)
{
    char    **ppszDll;

    BOOL    fRet;

    fRet    = TRUE;
    ppszDll = ppszDlls;

    while (*ppszDll)
    {
        fRet &= _LoadAndRegister(*ppszDll, TRUE);

        ppszDll++;
    }

    return((fRet) ? S_OK : S_FALSE);
}

void CleanupRegistry(void)
{
    char    **ppszKeys;

    ppszKeys    = ppszOldHKLMRegistryKeys;

    while (*ppszKeys)
    {

        DeleteKeys(HKEY_LOCAL_MACHINE, *ppszKeys);

        ppszKeys++;
    }
}

void DeleteKeys(HKEY hKeyParent, char *pszKey)
{
    HKEY    hKey;
    char    szSubKey[REG_MAX_KEY_NAME];

    if (RegOpenKeyEx(hKeyParent, pszKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        while (RegEnumKey(hKey, 0, &szSubKey[0], REG_MAX_KEY_NAME) == ERROR_SUCCESS)
        {
            // WARNING:  recursive!
            DeleteKeys(hKey, &szSubKey[0]);
        }

        RegCloseKey(hKey);

        RegDeleteKey(hKeyParent, pszKey);
    }
}


typedef HRESULT (WINAPI *DllRegisterServer)(void);

BOOL _LoadAndRegister(char *pszDll, BOOL fUnregister)
{
    DllRegisterServer   pfn;
    HINSTANCE           hDll;
    BOOL                fRet;

    fRet = TRUE;

    if (!(hDll = LoadLibrary(pszDll)))
    {
        goto LoadLibraryFail;
    }

    if (!(pfn = (DllRegisterServer)GetProcAddress(hDll, (fUnregister) ? "DllUnregisterServer" : "DllRegisterServer")))
    {
        goto ProcAddressFail;
    }

    if ((*pfn)() != S_OK)
    {
        goto DllRegisterFailed;
    }

    CommonReturn:
        if (hDll)
        {
            FreeLibrary(hDll);
        }
        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, LoadLibraryFail);
    TRACE_ERROR_EX(DBG_SS, ProcAddressFail);
    TRACE_ERROR_EX(DBG_SS, DllRegisterFailed);
}

BOOL _AdjustPolicyFlags(POLSET *pPolSet)
{
    DWORD   dwPolSettings;
    POLSET  *pPol;

    dwPolSettings = 0;

    WintrustGetRegPolicyFlags(&dwPolSettings);

// In WXP, changed to always update the settings
#if 0
    //
    //  only do this if we aren't set yet.
    //
    if (dwPolSettings != 0)
    {
        return(TRUE);
    }
#endif

    pPol = pPolSet;

    while (pPol->dwSetting > 0)
    {
        if (pPol->fOn)
        {
            dwPolSettings |= pPol->dwSetting;
        }
        else
        {
            dwPolSettings &= ~(pPol->dwSetting);
        }

        pPol++;
    }

    return(WintrustSetRegPolicyFlags(dwPolSettings));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\initpki\tcrack.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       tcrack.h
//
//  Contents:   The header of tcrack.cpp.  
//
//  History:    29-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __TCRACK_H__
#define __TCRACK_H__


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


#include "wincrypt.h"


//--------------------------------------------------------------------------
//    Contant Defines
//--------------------------------------------------------------------------
#define CRYPT_DECODE_FLAG               CRYPT_DECODE_NOCOPY_FLAG 
#define CRYPT_ENCODE_TYPE               X509_ASN_ENCODING   

//--------------------------------------------------------------------------
//   Macros
//--------------------------------------------------------------------------

//Macros for memory management
#define SAFE_FREE(p1)   {if(p1) {LocalFree(p1);p1=NULL;}}  
#define SAFE_ALLOC(p1)  LocalAlloc(LPTR,p1)
#define CHECK_POINTER(pv) { if(!pv) goto TCLEANUP;}


//Macros for error checking
#define TESTC(rev,exp)   {if(!((rev)==(exp))) goto TCLEANUP; }

//--------------------------------------------------------------------------
//  Inline Function 
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//--------------------------------------------------------------------------
//   Function Prototype
//--------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//Error Manipulations
void    SetData(DWORD   cbNewData, BYTE *pbNewData,
                DWORD   *pcbOldData, BYTE **ppbOldData);


///////////////////////////////////////////////////////////////////////////////
//Certificate Manipulations
BOOL    Fix7FCert(DWORD cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);


BOOL    DecodeBLOB(LPCSTR   lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
                   DWORD    *pcbStructInfo, void **ppvStructInfo);

BOOL    EncodeStruct(LPCSTR lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
                     BYTE **ppbEncoded);

BOOL    DecodeX509_CERT(DWORD   cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);

BOOL    DecodeX509_CERT_TO_BE_SIGNED(DWORD  cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);

BOOL    DecodeX509_NAME(DWORD   cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);




///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines
BOOL    BadCert(DWORD   cbEncoded, BYTE *pbEncoded);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // __TCRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\dbcomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbcomp.cpp
//
//  Contents:   Hash Database Compactor
//
//  History:    9-8-1998    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::CHashDbCompactor, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CHashDbCompactor::CHashDbCompactor ()
{
    m_hDbLock = NULL;
    m_pwszDbDirectory = NULL;

    m_cUniqueCatalogs = 0;
    m_cAllocatedUniqueCatalogs = 0;
    m_aUniqueCatalogs = NULL;
    m_iLastUniqueCatalogFoundByName = 0;

    m_pwszTempKeyPath[0] = L'\0';
    m_pwszTempDataPath[0] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::~CHashDbCompactor, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CHashDbCompactor::~CHashDbCompactor ()
{
    if ( m_hDbLock != NULL )
    {
        CloseHandle( m_hDbLock );
    }

    if ( m_pwszTempKeyPath[ 0 ] != L'\0' )
    {
        DeleteFileU( m_pwszTempKeyPath );
    }

    if ( m_pwszTempDataPath[ 0 ] != L'\0' )
    {
        DeleteFileU( m_pwszTempDataPath );
    }

    delete m_pwszDbDirectory;
    delete m_aUniqueCatalogs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::Initialize, public
//
//  Synopsis:   initialize the compactor
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::Initialize (
                      IN LPCWSTR pwszDbLock,
                      IN LPCWSTR pwszDbDirectory
                      )
{
    if ( ( m_hDbLock = CreateMutexU( NULL, FALSE, pwszDbLock ) ) == NULL )
    {
        return( FALSE );
    }

    m_pwszDbDirectory = new WCHAR [ wcslen( pwszDbDirectory ) + 1 ];
    if ( m_pwszDbDirectory != NULL )
    {
        wcscpy( m_pwszDbDirectory, pwszDbDirectory );
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( GrowUniqueCatalogs( INITIAL_UNIQUE_CATALOGS ) == FALSE )
    {
        return( FALSE );
    }

    assert( m_aUniqueCatalogs != NULL );
    assert( m_cAllocatedUniqueCatalogs == INITIAL_UNIQUE_CATALOGS );

    if ( ( GetTempFileNameU(
              pwszDbDirectory,
              L"",
              0,
              m_pwszTempKeyPath
              ) == FALSE ) ||
         ( GetTempFileNameU(
              pwszDbDirectory,
              L"",
              0,
              m_pwszTempDataPath
              ) == FALSE ) )
    {
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::LockDatabase, public
//
//  Synopsis:   lock the database
//
//----------------------------------------------------------------------------
VOID
CHashDbCompactor::LockDatabase ()
{
    WaitForSingleObject( m_hDbLock, INFINITE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::UnlockDatabase, public
//
//  Synopsis:   unlock the database
//
//----------------------------------------------------------------------------
VOID
CHashDbCompactor::UnlockDatabase ()
{
    ReleaseMutex( m_hDbLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::MapDatabase, public
//
//  Synopsis:   map the database
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::MapDatabase (
                     IN LPCWSTR pwszDbName,
                     OUT PCRYPT_DATA_BLOB pKey,
                     OUT LPWSTR* ppwszKeyPath,
                     OUT PCRYPT_DATA_BLOB pData,
                     OUT LPWSTR* ppwszDataPath
                     )
{
    BOOL   fResult = TRUE;
    LPWSTR pwszKeyDbPath = NULL;
    LPWSTR pwszDataDbPath = NULL;
    DWORD  cwDirectory = 0;
    DWORD  cwName = 0;
    HANDLE hKeyFile = INVALID_HANDLE_VALUE;
    HANDLE hDataFile = INVALID_HANDLE_VALUE;
    HANDLE hMappedKeyFile = NULL;
    HANDLE hMappedDataFile = NULL;
    LPBYTE pbKey = NULL;
    LPBYTE pbData = NULL;
    DWORD  cwKeyExt = 0;
    DWORD  cwDataExt = 0;
    DWORD  cbKeyFileSize = 0;
    DWORD  cbDataFileSize = 0;

    cwDirectory = wcslen( m_pwszDbDirectory );
    cwName = wcslen( pwszDbName );
    cwKeyExt = wcslen( DB_KEY_EXT );
    cwDataExt = wcslen( DB_DATA_EXT );

    pwszKeyDbPath = new WCHAR [ cwDirectory + cwName + cwKeyExt + 2 ];
    pwszDataDbPath = new WCHAR [ cwDirectory + cwName + cwDataExt + 2 ];

    if ( ( pwszKeyDbPath != NULL ) && ( pwszDataDbPath != NULL ) )
    {
        wcscpy( pwszKeyDbPath, m_pwszDbDirectory );
        wcscat( pwszKeyDbPath, L"\\" );
        wcscat( pwszKeyDbPath, pwszDbName );

        wcscpy( pwszDataDbPath, pwszKeyDbPath );

        wcscat( pwszKeyDbPath, DB_KEY_EXT );
        wcscat( pwszDataDbPath, DB_DATA_EXT );
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        DWORD dwErr = 0;

        hKeyFile = CreateFileU(
                         pwszKeyDbPath,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
        if (hKeyFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }

        hDataFile = CreateFileU(
                          pwszDataDbPath,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );

        if (hDataFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }

        if ( ( hKeyFile != INVALID_HANDLE_VALUE ) &&
             ( hDataFile != INVALID_HANDLE_VALUE ) )
        {
            cbKeyFileSize = GetFileSize( hKeyFile, NULL );
            cbDataFileSize = GetFileSize( hDataFile, NULL );

            if ( cbKeyFileSize > 0 )
            {
                hMappedKeyFile = CreateFileMapping(
                                       hKeyFile,
                                       NULL,
                                       PAGE_READONLY,
                                       0,
                                       0,
                                       NULL
                                       );
            }

            if ( cbDataFileSize > 0 )
            {
                hMappedDataFile = CreateFileMapping(
                                        hDataFile,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                        );
            }
        }

        if ( hMappedKeyFile != NULL )
        {
            pbKey = (LPBYTE)MapViewOfFile(
                               hMappedKeyFile,
                               FILE_MAP_READ,
                               0,
                               0,
                               0
                               );
        }

        if ( hMappedDataFile != NULL )
        {
            pbData = (LPBYTE)MapViewOfFile(
                                hMappedDataFile,
                                FILE_MAP_READ,
                                0,
                                0,
                                0
                                );
        }

        if ( ( ( pbKey == NULL ) && ( cbKeyFileSize != 0 ) ) ||
             ( ( pbData == NULL ) && ( cbDataFileSize != 0 ) ) )
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pKey->cbData = cbKeyFileSize;
        pKey->pbData = pbKey;
        *ppwszKeyPath = pwszKeyDbPath;

        pData->cbData = cbDataFileSize;
        pData->pbData = pbData;
        *ppwszDataPath = pwszDataDbPath;
    }
    else
    {
        delete pwszKeyDbPath;
        delete pwszDataDbPath;
    }

    if ( hKeyFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hKeyFile );
    }

    if ( hDataFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hDataFile );
    }

    if ( hMappedKeyFile != NULL )
    {
        CloseHandle( hMappedKeyFile );
    }

    if ( hMappedDataFile != NULL )
    {
        CloseHandle( hMappedDataFile );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::UnmapDatabase, public
//
//  Synopsis:   unmap the database
//
//----------------------------------------------------------------------------
VOID
CHashDbCompactor::UnmapDatabase (
                       IN PCRYPT_DATA_BLOB pKey,
                       IN PCRYPT_DATA_BLOB pData
                       )
{
    FlushCompactionAnalysis();

    if ( pKey->pbData != NULL )
    {
        UnmapViewOfFile( pKey->pbData );
    }

    if ( pData->pbData != NULL )
    {
        UnmapViewOfFile( pData->pbData );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::AnalyzeDataForCompaction, public
//
//  Synopsis:   analyze the database data for compaction
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::AnalyzeDataForCompaction (
                         IN PCRYPT_DATA_BLOB pData,
                         IN OPTIONAL LPCSTR pszUnwantedCatalog
                         )
{
    BOOL            fResult = TRUE;
    HashMastRec*    pHashMastRecord;
    DWORD           cbToNextRecord;
    DWORD           cRecord;
    DWORD           cCount;
    PUNIQUE_CATALOG pUniqueCatalog;

    if ( m_cUniqueCatalogs > 0 )
    {
        if ( FlushCompactionAnalysis() == FALSE )
        {
            return( FALSE );
        }
    }

    pHashMastRecord = (HashMastRec *)(
                           pData->pbData + BFILE_HEADERSIZE + sizeof( DWORD )
                           );

    cbToNextRecord = sizeof( HashMastRec ) + sizeof( DWORD );

    if ( pData->cbData < BFILE_HEADERSIZE )
    {
        cRecord = 0;
    }
    else
    {
        cRecord = ( pData->cbData - BFILE_HEADERSIZE ) / cbToNextRecord;
    }

    for ( cCount = 0; ( fResult == TRUE ) && ( cCount < cRecord ); cCount++ )
    {
        if ( ( pszUnwantedCatalog == NULL ) ||
             ( _strnicmp(
                   pHashMastRecord->CatName,
                   pszUnwantedCatalog,
                   MAX_PATH
                   ) != 0 ) )
        {
            pUniqueCatalog = FindUniqueCatalogByName(
                                 pHashMastRecord->CatName
                                 );

            if ( ( pUniqueCatalog == NULL ) &&
                 ( CatalogFileExists(
                          pHashMastRecord->CatName,
                          MAX_PATH
                          ) == TRUE ) )
            {
                fResult = AddUniqueCatalog( pHashMastRecord );
            }
        }

        pHashMastRecord = (HashMastRec *)(
                               (LPBYTE)pHashMastRecord + cbToNextRecord
                               );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::FlushCompactionAnalysis, public
//
//  Synopsis:   flush the last compaction analysis done
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::FlushCompactionAnalysis ()
{
    DWORD           cAllocatedUniqueCatalogs;
    DWORD           cUniqueCatalogs;
    PUNIQUE_CATALOG aUniqueCatalogs;

    if ( m_cAllocatedUniqueCatalogs == INITIAL_UNIQUE_CATALOGS )
    {
        m_cUniqueCatalogs = 0;
        m_iLastUniqueCatalogFoundByName = 0;
        return( TRUE );
    }

    aUniqueCatalogs = m_aUniqueCatalogs;
    cUniqueCatalogs = m_cUniqueCatalogs;
    cAllocatedUniqueCatalogs = m_cAllocatedUniqueCatalogs;

    m_aUniqueCatalogs = NULL;
    m_cUniqueCatalogs = 0;
    m_cAllocatedUniqueCatalogs = 0;

    if ( GrowUniqueCatalogs( INITIAL_UNIQUE_CATALOGS ) == FALSE )
    {
        m_aUniqueCatalogs = aUniqueCatalogs;
        m_cUniqueCatalogs = cUniqueCatalogs;
        m_cAllocatedUniqueCatalogs = cAllocatedUniqueCatalogs;

        return( FALSE );
    }

    delete aUniqueCatalogs;

    m_iLastUniqueCatalogFoundByName = 0;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::WriteCompactedDatabase, public
//
//  Synopsis:   write the compacted database
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::WriteCompactedDatabase (
                       IN PCRYPT_DATA_BLOB pKey,
                       IN PCRYPT_DATA_BLOB pData,
                       IN OPTIONAL LPCSTR pszUnwantedCatalog
                       )
{
    BOOL            fResult = FALSE;
    HANDLE          hFile;
    HANDLE          hDataFile;
    HANDLE          hMap;
    DWORD           cCount;
    DWORD           cbSize;
    LPBYTE          pbDataFile = NULL;
    LPBYTE          pbFile = NULL;
    HashMastRec*    pHashMastRecord;
    PUNIQUE_CATALOG pUniqueCatalog;
    LPDWORD         pdw;
    DWORD           RecordId;
    DWORD           cKey;
    LPBYTE          pbKey;
    LPBYTE          pb;
    BFILE_HEADER*   pHeader = NULL;

    hDataFile = CreateFileU(
                      m_pwszTempDataPath,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL
                      );

    if ( hDataFile == INVALID_HANDLE_VALUE )
    {
        return( FALSE );
    }

    cbSize = ( sizeof( DWORD ) + sizeof( HashMastRec ) ) * m_cUniqueCatalogs;
    cbSize += BFILE_HEADERSIZE;

    if ( SetFilePointer( hDataFile, cbSize, NULL, FILE_BEGIN ) != 0xFFFFFFFF )
    {
        fResult = SetEndOfFile( hDataFile );
    }

    if ( fResult == TRUE )
    {
        if ( ( hMap = CreateFileMapping(
                            hDataFile,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            0,
                            NULL
                            ) ) != NULL )
        {
            pbDataFile = (LPBYTE)MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, 0 );
            CloseHandle( hMap );
        }

        if ( pbDataFile != NULL )
        {
            memcpy( pbDataFile, BFILE_SIG, BFILE_SIZEOFSIG );

            pHeader = (BFILE_HEADER *)( pbDataFile + BFILE_SIZEOFSIG );

            memset( pHeader, 0, sizeof( BFILE_HEADER ) );

            pHeader->sVersion = BFILE_VERSION_1;
            pHeader->sIntVersion = CATDB_VERSION_1;
            pHeader->cbKey = KEY_SIZE;
            pHeader->cbData = sizeof( HashMastRec );
        }
        else
        {
            fResult = FALSE;
        }
    }

    pdw = (LPDWORD)( pbDataFile + BFILE_HEADERSIZE );
    pHashMastRecord = (HashMastRec *)( (LPBYTE)pdw + sizeof( DWORD ) );

    for ( cCount = 0;
          ( cCount < m_cUniqueCatalogs ) && ( fResult == TRUE );
          cCount++ )
    {
        RecordId = cCount + 1;

        memcpy( pdw, &RecordId, sizeof( DWORD ) );

        memcpy(
           pHashMastRecord,
           &m_aUniqueCatalogs[ cCount ].HashDbRecord,
           sizeof( HashMastRec )
           );

        pdw = (LPDWORD)(
                 (LPBYTE)pdw + sizeof( HashMastRec ) + sizeof( DWORD )
                 );

        pHashMastRecord = (HashMastRec *)( (LPBYTE)pdw + sizeof( DWORD ) );
    }

    if ( fResult == FALSE )
    {
        if ( pbDataFile != NULL )
        {
            UnmapViewOfFile( pbDataFile );
        }

        CloseHandle( hDataFile );

        return( FALSE );
    }

    fResult = FALSE;
    pbFile = NULL;

    hFile = CreateFileU(
                  m_pwszTempKeyPath,
                  GENERIC_READ | GENERIC_WRITE,
                  0,
                  NULL,
                  CREATE_ALWAYS,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL
                  );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        UnmapViewOfFile( pbDataFile );
        CloseHandle( hDataFile );
        return( FALSE );
    }

    if ( SetFilePointer( hFile, pKey->cbData, NULL, FILE_BEGIN ) != 0xFFFFFFFF )
    {
        fResult = SetEndOfFile( hFile );
    }

    if ( ( fResult == TRUE ) && ( pKey->cbData > 0 ) )
    {
        if ( ( hMap = CreateFileMapping(
                            hFile,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            0,
                            NULL
                            ) ) != NULL )
        {
            pbFile = (LPBYTE)MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, 0 );
            CloseHandle( hMap );
        }

        if ( pbFile == NULL )
        {
            fResult = FALSE;
        }
    }

    cKey = pKey->cbData / KEY_RECORD_SIZE;
    pdw = (LPDWORD)( pKey->pbData + KEY_SIZE );
    pbKey = pKey->pbData;
    pb = pbFile;
    RecordId = 0;

    __try
    {
        for ( cCount = 0; ( cCount < cKey ) && ( fResult == TRUE ); cCount++ )
        {
            if ( ( *pdw + sizeof( HashMastRec ) + sizeof( DWORD ) ) <= pData->cbData )
            {
                pHashMastRecord = (HashMastRec *)(
                                       pData->pbData + *pdw + sizeof( DWORD )
                                       );

                if ( ( pszUnwantedCatalog == NULL ) ||
                     ( _strnicmp(
                           pHashMastRecord->CatName,
                           pszUnwantedCatalog,
                           MAX_PATH
                           ) != 0 ) )
                {
                    pUniqueCatalog = FindUniqueCatalogByName(
                                         pHashMastRecord->CatName
                                         );

                    if ( pUniqueCatalog == NULL )
                    {
                        pdw = (LPDWORD)( (LPBYTE)pdw + KEY_RECORD_SIZE );
                        pbKey += KEY_RECORD_SIZE;
                        continue;
                    }

                    memcpy(
                       pb,
                       pbKey,
                       KEY_SIZE
                       );

                    pb += KEY_SIZE;

                    memcpy(
                       pb,
                       (LPBYTE)&pUniqueCatalog->UniqueOffset,
                       sizeof( DWORD )
                       );

                    pb += sizeof( DWORD );

                    RecordId += 1;
                }
            }

            pdw = (LPDWORD)( (LPBYTE)pdw + KEY_RECORD_SIZE );
            pbKey += KEY_RECORD_SIZE;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( GetExceptionCode() );
        fResult = FALSE;
    }

    if ( pbFile != NULL )
    {
        UnmapViewOfFile( pbFile );
    }

    if ( fResult == TRUE )
    {
        cbSize = RecordId * KEY_RECORD_SIZE;

        pHeader->cbSortedEOF = cbSize;
        pHeader->dwLastRecNum = ( RecordId > 0 ) ? ( RecordId - 1 ) : 0;
        pHeader->fDirty = FALSE;

        if ( SetFilePointer( hFile, cbSize, NULL, FILE_BEGIN ) != 0xFFFFFFFF )
        {
            fResult = SetEndOfFile( hFile );
        }
    }

    UnmapViewOfFile( pbDataFile );
    CloseHandle( hDataFile );
    CloseHandle( hFile );

    return( fResult );
}


BOOL MyMoveFileEx(
        LPCWSTR lpExistingFileName,  
        LPCWSTR lpNewFileName,      
        DWORD   dwFlags               
)
{
    BYTE rgbExisting[_MAX_PATH];
	BYTE rgbNew[_MAX_PATH];
	char * szExisting = NULL;
	char * szNew = NULL;
	BOOL bResult = FALSE;

    if (FIsWinNT())
    {
		return(MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
    }

    if ((MkMBStr(rgbExisting, _MAX_PATH, lpExistingFileName, &szExisting)) &&
		(MkMBStr(rgbNew, _MAX_PATH, lpNewFileName, &szNew)))
	{
		bResult = DeleteFile(szNew);
        if (bResult)
        {
            bResult = MoveFileA(szExisting, szNew);
        }
	}

	FreeMBStr(rgbExisting, szExisting);
	FreeMBStr(rgbNew, szNew);

    return (bResult);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::CommitCompactedDatabase, public
//
//  Synopsis:   commit the compacted database
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::CommitCompactedDatabase (
                        IN LPCWSTR pwszFinalKeyPath,
                        IN LPCWSTR pwszFinalDataPath
                        )
{
    DWORD dwErr = 0;

    if ( MyMoveFileEx(
             m_pwszTempKeyPath,
             pwszFinalKeyPath,
             MOVEFILE_COPY_ALLOWED |
             MOVEFILE_REPLACE_EXISTING |
             MOVEFILE_WRITE_THROUGH
             ) == FALSE )
    {
        dwErr = GetLastError();
        return( FALSE );
    }

    return( MyMoveFileEx(
                m_pwszTempDataPath,
                pwszFinalDataPath,
                MOVEFILE_COPY_ALLOWED |
                MOVEFILE_REPLACE_EXISTING |
                MOVEFILE_WRITE_THROUGH
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::FreeString, public
//
//  Synopsis:   free allocated string
//
//----------------------------------------------------------------------------
VOID
CHashDbCompactor::FreeString (IN LPWSTR pwsz)
{
    delete pwsz;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::GrowUniqueCatalogs, public
//
//  Synopsis:   grow the unique catalogs array
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::GrowUniqueCatalogs (DWORD cGrow)
{
    BOOL            fResult = FALSE;
    DWORD           cAllocatedUniqueCatalogs;
    PUNIQUE_CATALOG aUniqueCatalogs;

    cAllocatedUniqueCatalogs = m_cAllocatedUniqueCatalogs + cGrow;
    aUniqueCatalogs = new UNIQUE_CATALOG [ cAllocatedUniqueCatalogs ];

    if ( aUniqueCatalogs == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    memset(
       aUniqueCatalogs,
       0,
       sizeof( UNIQUE_CATALOG ) * cAllocatedUniqueCatalogs
       );

    if ( m_aUniqueCatalogs != NULL )
    {
        memcpy(
           aUniqueCatalogs,
           m_aUniqueCatalogs,
           m_cUniqueCatalogs * sizeof( UNIQUE_CATALOG )
           );

        delete m_aUniqueCatalogs;
    }

    m_cAllocatedUniqueCatalogs = cAllocatedUniqueCatalogs;
    m_aUniqueCatalogs = aUniqueCatalogs;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::FindUniqueCatalogByName, public
//
//  Synopsis:   find a unique catalog entry given a catalog name
//
//----------------------------------------------------------------------------
PUNIQUE_CATALOG
CHashDbCompactor::FindUniqueCatalogByName (LPCSTR pszCatalogName)
{
    DWORD cCount;

    if ( ( m_iLastUniqueCatalogFoundByName < m_cUniqueCatalogs ) &&
         ( _strnicmp(
               m_aUniqueCatalogs[ m_iLastUniqueCatalogFoundByName ].HashDbRecord.CatName,
               pszCatalogName,
               MAX_PATH
               ) == 0 ) )
    {
        return( &m_aUniqueCatalogs[ m_iLastUniqueCatalogFoundByName ] );
    }

    for ( cCount = 0; cCount < m_cUniqueCatalogs; cCount++ )
    {
        if ( _strnicmp(
                 m_aUniqueCatalogs[ cCount ].HashDbRecord.CatName,
                 pszCatalogName,
                 MAX_PATH
                 ) == 0 )
        {
            m_iLastUniqueCatalogFoundByName = cCount;
            return( &m_aUniqueCatalogs[ cCount ] );
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::AddUniqueCatalog, public
//
//  Synopsis:   add a unique catalog to the array
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::AddUniqueCatalog (HashMastRec* pHashMastRecord)
{
    DWORD UniqueOffset;

    if ( m_cUniqueCatalogs == m_cAllocatedUniqueCatalogs )
    {
        if ( GrowUniqueCatalogs( GROW_UNIQUE_CATALOGS ) == FALSE )
        {
            return( FALSE );
        }
    }

    UniqueOffset = ( m_cUniqueCatalogs * (
                              sizeof( HashMastRec ) + sizeof( DWORD )
                              ) ) + BFILE_HEADERSIZE;

    m_aUniqueCatalogs[ m_cUniqueCatalogs ].HashDbRecord = *pHashMastRecord;
    m_aUniqueCatalogs[ m_cUniqueCatalogs ].UniqueOffset = UniqueOffset;

    m_cUniqueCatalogs += 1;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHashDbCompactor::CatalogFileExists, public
//
//  Synopsis:   check if the catalog file exists in the database directory
//
//----------------------------------------------------------------------------
BOOL
CHashDbCompactor::CatalogFileExists (LPCSTR pszCatalogName, DWORD cbName)
{
    BOOL   fResult = FALSE;
    WCHAR  pwszFile[ MAX_PATH ];
    WCHAR  pwszPath[ MAX_PATH ];
    HANDLE hFile;

    if ( MultiByteToWideChar(
              CP_ACP,
              0,
              pszCatalogName,
              cbName,
              pwszFile,
              MAX_PATH
              ) == 0 )
    {
        return( FALSE );
    }

    if ( ( wcslen( m_pwszDbDirectory ) + wcslen( pwszFile ) + 2 ) > MAX_PATH )
    {
        return( FALSE );
    }

    wcscpy( pwszPath, m_pwszDbDirectory );
    wcscat( pwszPath, L"\\" );
    wcscat( pwszPath, pwszFile );

    if ( ( hFile = CreateFileU(
                         pwszPath,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         ) ) != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
        fResult = TRUE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CatalogCompactHashDatabase
//
//  Synopsis:   API for compacting the catalog hash database
//
//----------------------------------------------------------------------------
BOOL WINAPI
CatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       )
{
    BOOL             fResult;
    CHashDbCompactor HashDbCompactor;
    LPWSTR           pwszKeyPath = NULL;
    LPWSTR           pwszDataPath = NULL;
    CRYPT_DATA_BLOB  KeyMap;
    CRYPT_DATA_BLOB  DataMap;
    BOOL             fDatabaseMapped = FALSE;
    CHAR             szUnwantedCatalog[ MAX_PATH + 1 ];
    LPSTR            pszUnwantedCatalog = NULL;

    if ( pwszUnwantedCatalog != NULL )
    {
        pszUnwantedCatalog = szUnwantedCatalog;

        if ( WideCharToMultiByte(
                 CP_ACP,
                 0,
                 pwszUnwantedCatalog,
                 -1,
                 pszUnwantedCatalog,
                 MAX_PATH,
                 NULL,
                 NULL
                 ) == FALSE )
        {
            return( FALSE );
        }
    }

    fResult = HashDbCompactor.Initialize( pwszDbLock, pwszDbDirectory );
    if ( fResult == FALSE )
    {
        return( FALSE );
    }

    HashDbCompactor.LockDatabase();

    __try
    {
        fResult = HashDbCompactor.MapDatabase(
                                     pwszDbName,
                                     &KeyMap,
                                     &pwszKeyPath,
                                     &DataMap,
                                     &pwszDataPath
                                     );

        if ( fResult == TRUE )
        {
            fDatabaseMapped = TRUE;

            fResult = HashDbCompactor.AnalyzeDataForCompaction(
                                             &DataMap,
                                             pszUnwantedCatalog
                                             );
        }

        if ( fResult == TRUE )
        {
            fResult = HashDbCompactor.WriteCompactedDatabase(
                                           &KeyMap,
                                           &DataMap,
                                           pszUnwantedCatalog
                                           );
        }

        if ( fDatabaseMapped == TRUE )
        {
            HashDbCompactor.UnmapDatabase( &KeyMap, &DataMap );
        }

        if ( fResult == TRUE )
        {
            fResult = HashDbCompactor.CommitCompactedDatabase(
                                            pwszKeyPath,
                                            pwszDataPath
                                            );
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( GetExceptionCode() );
        fResult = FALSE;
    }

    HashDbCompactor.UnlockDatabase();

    if ( pwszKeyPath != NULL )
    {
        HashDbCompactor.FreeString( pwszKeyPath );
    }

    if ( pwszDataPath != NULL )
    {
        HashDbCompactor.FreeString( pwszDataPath );
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\catdb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catdb.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  History:    23-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "catdb.hxx"

cCatalogDB_::cCatalogDB_(WCHAR *pwszBaseDirIn, WCHAR *pwszSubDirIn)
{
    WCHAR  wszPath[MAX_PATH];
    LPWSTR pwszPath;
    BOOL   fCreatedOK = FALSE;

    pCatMast    = NULL;

    pwszPath = new WCHAR [ wcslen(pwszBaseDirIn)+wcslen(pwszSubDirIn)+1 ];
    if ( pwszPath == NULL )
    {
        return;
    }

    wcscpy(pwszPath, pwszBaseDirIn);

    CreateDirectoryU(pwszPath, NULL);

    //
    //  sysmast is in the CatRoot directory.
    //
    if ((pSysMast = new cBFile_(&MSCAT_CriticalSection, 
                                pwszPath,
                                SYSMAST_NAME, 
                                sizeof(GUID), 
                                sizeof(SysMastRec), 
                                CATDB_VERSION_1, 
                                &fCreatedOK))               &&
        fCreatedOK                                          &&
        (pSysMast->Initialize()))
    {
        wcscat(pwszPath, pwszSubDirIn);

        // create the directory!
        CreateDirectoryU(pwszPath, NULL);

        if ((pCatMast = new cBFile_(&MSCAT_CriticalSection, 
                                    pwszPath,
                                    CATMAST_NAME, 
                                    sizeof(DWORD), 
                                    sizeof(CatMastRec), 
                                    CATDB_VERSION_1,
                                    &fCreatedOK))           &&
            fCreatedOK                                      &&
            (pCatMast->Initialize()))
        {
            pCatMast->UseRecNumAsKey(TRUE);
            DELETE_OBJECT(pwszPath);
            return;
        }
    }

    DELETE_OBJECT(pSysMast);
    DELETE_OBJECT(pCatMast);
    DELETE_OBJECT(pwszPath);
}

cCatalogDB_::~cCatalogDB_(void)
{
    DELETE_OBJECT(pSysMast);
    DELETE_OBJECT(pCatMast);
}

BOOL cCatalogDB_::Initialize(void)
{
    if ((pSysMast) &&
        (pCatMast))
    {
        return(TRUE);
    }

    return(FALSE);
}

ULONG cCatalogDB_::SysMast_GetNewId(void)
{
    return(0L); // handled in the add....
}

DWORD cCatalogDB_::SysMast_NumKeys(void)
{
    return(pSysMast->GetNumKeys());
}

BOOL cCatalogDB_::SysMast_Get(const GUID *pgSubSys, SysMast *psData)
{
    SysMastRec  *rec;

    memset(psData, 0x00, sizeof(SysMast));

    pSysMast->setKey((void *)pgSubSys);

    if (pSysMast->Find())
    {
        rec = (SysMastRec *)pSysMast->getData();

        MultiByteToWideChar(0, 0, rec->SubDir, -1, psData->SubDir, REG_MAX_GUID_TEXT);
        psData->SubDir[REG_MAX_GUID_TEXT - 1] = NULL;

        memcpy(&psData->SysGuid, &rec->SysGuid, sizeof(GUID));

        psData->SysId = rec->SysId;

        return(TRUE);
    }

    return(FALSE);
}

BOOL cCatalogDB_::SysMast_GetFirst(SysMast *psData)
{
    SysMastRec  *rec;

    memset(psData, 0x00, sizeof(SysMast));

    if (pSysMast->GetFirst())
    {
        rec = (SysMastRec *)pSysMast->getData();

        MultiByteToWideChar(0, 0, rec->SubDir, -1, psData->SubDir, REG_MAX_GUID_TEXT);
        psData->SubDir[REG_MAX_GUID_TEXT - 1] = NULL;

        memcpy((void *)&psData->SysGuid, &rec->SysGuid, sizeof(GUID));

        psData->SysId = rec->SysId;

        return(TRUE);
    }

    return(FALSE);
}

BOOL cCatalogDB_::SysMast_GetNext(SysMast *psData)
{
    SysMastRec  *rec;

    memset(psData, 0x00, sizeof(SysMast));

    if (pSysMast->GetNext())
    {
        rec = (SysMastRec *)pSysMast->getData();

        MultiByteToWideChar(0, 0, rec->SubDir, -1, psData->SubDir, REG_MAX_GUID_TEXT);
        psData->SubDir[REG_MAX_GUID_TEXT - 1] = NULL;

        memcpy((void *)&psData->SysGuid, &rec->SysGuid, sizeof(GUID));

        psData->SysId = rec->SysId;

        return(TRUE);
    }

    return(FALSE);
}

BOOL cCatalogDB_::SysMast_Add(SysMast *psData)
{
    SysMastRec  rec;

    memset(&rec, 0x00, sizeof(SysMastRec));

    WideCharToMultiByte(0, 0, psData->SubDir, -1, &rec.SubDir[0], REG_MAX_GUID_TEXT, NULL, NULL);
    rec.SubDir[REG_MAX_GUID_TEXT - 1] = NULL;

    memcpy(&rec.SysGuid, &psData->SysGuid, sizeof(GUID));

    rec.SysId = psData->SysId;

    pSysMast->setKey(&psData->SysGuid);
    pSysMast->setData(&rec);

    if (pSysMast->Add())
    {
        //
        // because the id is the record number, we need to add it first, get the rec
        // number, force an index update, then update the record.
        //
        psData->SysId = pSysMast->getRecNum();
        memcpy(&rec, pSysMast->getData(), sizeof(SysMastRec));

        rec.SysId = psData->SysId;

        pSysMast->Sort();       // force update of the index!

        pSysMast->setKey(&psData->SysGuid);
        pSysMast->setData(&rec);
        pSysMast->Update();

        return(TRUE);
    }

    return(FALSE);
}

ULONG cCatalogDB_::CatMast_GetNewId(void)
{
    return(0L); // handled in the add....
}

BOOL cCatalogDB_::CatMast_Get(DWORD ulId, CatMast *psData)
{
    CatMastRec  *rec;

    memset(psData, 0x00, sizeof(CatMast));

    pCatMast->setKey(&ulId);

    if (pCatMast->Find())
    {
        rec = (CatMastRec *)pCatMast->getData();

        MultiByteToWideChar(0, 0, rec->OrigName, -1, psData->OrigName, MAX_PATH);
        psData->OrigName[MAX_PATH - 1] = NULL;

        MultiByteToWideChar(0, 0, rec->CurName, -1, psData->CurName, MAX_PATH);
        psData->CurName[MAX_PATH - 1] = NULL;

        psData->CatId = rec->CatId;
        psData->SysId = rec->SysId;

        memcpy(&psData->InstDate, &rec->InstDate, sizeof(FILETIME));

        return(TRUE);
    }

    return(FALSE);
}

BOOL cCatalogDB_::CatMast_Add(CatMast *psData)
{
    CatMastRec  rec;

    memset(&rec, 0x00, sizeof(CatMastRec));

    WideCharToMultiByte(0, 0, psData->OrigName, -1, &rec.OrigName[0], MAX_PATH, NULL, NULL);
    rec.OrigName[MAX_PATH - 1] = NULL;

    WideCharToMultiByte(0, 0, psData->CurName, -1, &rec.CurName[0], MAX_PATH, NULL, NULL);
    rec.CurName[MAX_PATH - 1] = NULL;

    rec.SysId = psData->SysId;

    pCatMast->setData(&rec);

    if (pCatMast->Add())
    {
        memcpy(&rec, pCatMast->getData(), sizeof(CatMastRec));

        psData->CatId   = pCatMast->getRecNum();
        rec.CatId       = psData->CatId;

        pCatMast->Sort();               // force index update.

        if (!(rec.CurName[0]))
        {
            sprintf(&rec.CurName[0], "%08.8lX.CAT", rec.CatId);

            MultiByteToWideChar(0, 0, &rec.CurName[0], -1, psData->CurName, MAX_PATH);
            psData->CurName[MAX_PATH - 1] = NULL;

        }

        pCatMast->setKey(&psData->CatId);
        pCatMast->setData(&rec);
        pCatMast->Update();

        return(TRUE);
    }

    return(FALSE);
}

cHashDB_::cHashDB_(WCHAR *pwszBase, WCHAR *pwszSubSysDirIn, BOOL *pfCreatedOK)
{
    *pfCreatedOK = TRUE;

    pwszSubSysDir = new WCHAR[wcslen(pwszBase) + wcslen(pwszSubSysDirIn) + 2];

    if (pwszSubSysDir)
    {
        BOOL fCreatedOK;

        wcscpy(pwszSubSysDir, pwszBase);
        wcscat(pwszSubSysDir, pwszSubSysDirIn);

        pHashMast   = new cBFile_(&MSCAT_CriticalSection, pwszSubSysDir,
                              HASHMAST_NAME, MAX_HASH_LEN, sizeof(HashMastRec), CATDB_VERSION_1, pfCreatedOK);

        if (pHashMast == NULL)
        {
            *pfCreatedOK = FALSE;
        }
    }
    else
    {
        *pfCreatedOK = FALSE;
    }
}

cHashDB_::~cHashDB_(void)
{
    DELETE_OBJECT(pHashMast);
    DELETE_OBJECT(pwszSubSysDir);
}

BOOL cHashDB_::Initialize(void)
{
    if (pHashMast)
    {
        return(TRUE);
    }

    return(FALSE);
}


BOOL cHashDB_::HashMast_Get(DWORD dwLastRec, BYTE *pbHash, DWORD cbHash, HashMast *psData)
{
    HashMastRec     *rec;
    BYTE            bHash[MAX_HASH_LEN];
    BOOL            fRet;

    if (cbHash > MAX_HASH_LEN)
    {
        return(FALSE);
    }

    memset(&bHash[0], 0x00, MAX_HASH_LEN);
    memcpy(&bHash[0], pbHash, cbHash);

    memset(psData, 0x00, sizeof(HashMast));

    pHashMast->setKey(&bHash[0]);

    if (dwLastRec == 0xFFFFFFFF)
    {
        fRet = pHashMast->Find();
    }
    else
    {
        fRet = pHashMast->GetNext(dwLastRec);
    }

    if (fRet)
    {
        if (memcmp(&bHash[0], pHashMast->getKey(), MAX_HASH_LEN) != 0)
        {
            return(FALSE);
        }

        rec = (HashMastRec *)pHashMast->getData();

        MultiByteToWideChar(0, 0, rec->CatName, -1, psData->CatName, MAX_PATH);
        psData->CatName[MAX_PATH - 1] = NULL;

        return(TRUE);
    }

    return(FALSE);
}

BOOL cHashDB_::HashMast_Add(HashMast *psData)
{
    HashMastRec  rec;

    memset(&rec, 0x00, sizeof(HashMastRec));

    WideCharToMultiByte(0, 0, psData->CatName, -1, &rec.CatName[0], MAX_PATH, NULL, NULL);
    rec.CatName[MAX_PATH - 1] = NULL;

    pHashMast->setKey(&psData->Hash[0]);
    pHashMast->setData(&rec);

    if (pHashMast->Add())
    {
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\dbcomp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbcomp.h
//
//  Contents:   Hash Database Compactor
//
//  History:    9-8-1998    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DBCOMP_H__)
#define __DBCOMP_H__

#include <cbfile.hxx>
#include <catdb.hxx>

//
// Unique catalog structure
//

typedef struct _UNIQUE_CATALOG {

    HashMastRec HashDbRecord;
    DWORD       UniqueOffset;

} UNIQUE_CATALOG, *PUNIQUE_CATALOG;

#define INITIAL_UNIQUE_CATALOGS 10
#define GROW_UNIQUE_CATALOGS    5

#define DB_KEY_EXT              L".cbk"
#define DB_DATA_EXT             L".cbd"

#define KEY_RECORD_SIZE         24
#define KEY_SIZE                20

//
// Analyzes and compacts the current icky PBerkman hash database format with
// support for removal of unwanted catalog entries
//

class CHashDbCompactor
{
public:

    //
    // Construction
    //

    CHashDbCompactor ();
    ~CHashDbCompactor ();

    //
    // Initialize
    //

    BOOL Initialize (
             IN LPCWSTR pwszDbLock,
             IN LPCWSTR pwszDbDirectory
             );

    //
    // Original database locking
    //

    VOID LockDatabase ();
    VOID UnlockDatabase ();

    //
    // Map original database
    //

    BOOL MapDatabase (
            IN LPCWSTR pwszDbName,
            OUT PCRYPT_DATA_BLOB pKey,
            OUT LPWSTR* ppwszKeyPath,
            OUT PCRYPT_DATA_BLOB pData,
            OUT LPWSTR* ppwszDataPath
            );

    VOID UnmapDatabase (
              IN PCRYPT_DATA_BLOB pKey,
              IN PCRYPT_DATA_BLOB pData
              );

    //
    // Analyze the data for compaction
    //

    BOOL AnalyzeDataForCompaction (
                IN PCRYPT_DATA_BLOB pData,
                IN OPTIONAL LPCSTR pszUnwantedCatalog
                );

    //
    // Flush compaction analysis
    //

    BOOL FlushCompactionAnalysis ();

    //
    // Write the compacted database
    //

    BOOL WriteCompactedDatabase (
              IN PCRYPT_DATA_BLOB pKey,
              IN PCRYPT_DATA_BLOB pData,
              IN OPTIONAL LPCSTR pszUnwantedCatalog
              );

    //
    // Commit compacted database
    //

    BOOL CommitCompactedDatabase (
               IN LPCWSTR pwszFinalKeyPath,
               IN LPCWSTR pwszFinalDataPath
               );

    //
    // Free memory
    //

    VOID FreeString (IN LPWSTR pwsz);

private:

    //
    // Database lock
    //

    HANDLE          m_hDbLock;

    //
    // Database directory
    //

    LPWSTR          m_pwszDbDirectory;

    //
    // Compacted database data
    //

    DWORD           m_cAllocatedUniqueCatalogs;
    DWORD           m_cUniqueCatalogs;
    PUNIQUE_CATALOG m_aUniqueCatalogs;

    //
    // Temp database names
    //

    WCHAR           m_pwszTempKeyPath[MAX_PATH+1];
    WCHAR           m_pwszTempDataPath[MAX_PATH+1];

    //
    // Cached search data
    //

    DWORD           m_iLastUniqueCatalogFoundByName;

    //
    // Private methods
    //

    BOOL GrowUniqueCatalogs (DWORD cGrow);

    PUNIQUE_CATALOG FindUniqueCatalogByName (LPCSTR pszCatalogName);

    BOOL AddUniqueCatalog (HashMastRec* pHashMastRecord);

    BOOL CatalogFileExists (LPCSTR pszCatalogName, DWORD cbName);
};

//
// API for compacting the database
//

extern "C" {
BOOL WINAPI
CatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatprv.h
//
//  History:    09-Mar-2000 reidk   created
//
//--------------------------------------------------------------------------

#ifndef MSCATPRV_H
#define MSCATPRV_H

#ifdef __cplusplus
extern "C"
{
#endif


extern BOOL WINAPI I_CryptCatAdminMigrateToNewCatDB();


#ifdef __cplusplus
}
#endif


#endif // MSCATPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatapi.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATOpen
//              CryptCATClose
//              CryptCATStoreFromHandle
//              CryptCATGetMemberInfo
//              CryptCATPutMemberInfo
//              CryptCATVerifyMember
//              CryptCATGetAttrInfo
//              CryptCATPutAttrInfo
//              CryptCATEnumerateMember
//              CryptCATEnumerateAttr
//
//              *** local functions ***
//
//              CryptCATCreateStore
//              CryptCATOpenStore
//              FillNameValue
//              CatalogCheckForDuplicateMember
//
//  History:    29-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"


BOOL    CryptCATCreateStore(CRYPTCATSTORE *pCat, LPWSTR pwszCatFile);
BOOL    CryptCATOpenStore(CRYPTCATSTORE *pCat, LPWSTR pwszCatFile);
BOOL    FillNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr);
BOOL    CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag);


/////////////////////////////////////////////////////////////////////////////
//
//  Exported Functions
//  

HANDLE WINAPI CryptCATOpen(LPWSTR pwszCatFile, DWORD fdwOpenFlags, HCRYPTPROV hProv,
                           DWORD dwPublicVersion, DWORD dwEncodingType)
{
    CRYPTCATSTORE   *pCatStore;
    
    if (!(pwszCatFile))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return((HANDLE)INVALID_HANDLE_VALUE);
    }

    if (!(pCatStore = (CRYPTCATSTORE *)CatalogNew(sizeof(CRYPTCATSTORE))))
    {
        return((HANDLE)INVALID_HANDLE_VALUE);
    }

    memset(pCatStore, 0x00, sizeof(CRYPTCATSTORE));

    pCatStore->cbStruct         = sizeof(CRYPTCATSTORE);
    pCatStore->hProv            = hProv;
    pCatStore->dwPublicVersion  = (dwPublicVersion) ? dwPublicVersion : 0x00000100;
    pCatStore->dwEncodingType   = (dwEncodingType) ? dwEncodingType :
                                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if (!(hProv))
    {
        pCatStore->hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!

        if (!(pCatStore->hProv))
        {
            goto ErrorReturn;
        }
    }

    if (fdwOpenFlags & CRYPTCAT_OPEN_CREATENEW)
    {
        if (!CryptCATCreateStore(pCatStore, pwszCatFile))
        {
            goto ErrorReturn;
        }
    }
    else
    {
        BOOL fRet;

        fRet = CryptCATOpenStore(pCatStore, pwszCatFile);
        
        if (!(fRet) && (fdwOpenFlags & CRYPTCAT_OPEN_ALWAYS))
        {
            fRet = CryptCATCreateStore(pCatStore, pwszCatFile);
        }

        if (fRet == FALSE)
        {
            goto ErrorReturn;
        }
    }

    return((HANDLE)pCatStore);
    
ErrorReturn:

    DWORD   dwLastError;

    dwLastError = GetLastError();
    CryptCATClose((HANDLE)pCatStore);
    SetLastError(dwLastError);

    return(INVALID_HANDLE_VALUE);
}

BOOL WINAPI CryptCATClose(HANDLE hCatalog)
{
    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    __try
    {
        if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    BOOL            fRet;
    DWORD           dwlerr;

    dwlerr = GetLastError();

    fRet = TRUE;

    //
    //  file name
    //
    DELETE_OBJECT(pCatStore->pwszP7File);

    //
    //  attributes
    //
    if (_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs))
    {
        if (pCatStore->hAttrs)
        {
            Stack_              *ps;
            DWORD               cStack;
            CRYPTCATATTRIBUTE   *pAttr;
        
            ps = (Stack_ *)pCatStore->hAttrs;
        
            cStack = 0;

	        while (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(cStack))
	        {
        		CatalogFreeAttribute(pAttr);

        		cStack++;
	        }
        
    	    DELETE_OBJECT(ps);
        
            pCatStore->hAttrs = NULL;
        }
    }

    //
    //  check hReserved to see if we used pStack
    //
    if (pCatStore->hReserved)
    {
        Stack_              *pStack;
        CRYPTCATMEMBER      *pCatMember;
        DWORD               dwCurPos;

        pStack = (Stack_ *)pCatStore->hReserved;

        dwCurPos = 0;

        while (pCatMember = (CRYPTCATMEMBER *)pStack->Get(dwCurPos))
        {
            CatalogFreeMember(pCatMember);
            
            dwCurPos++;
        }

        DELETE_OBJECT(pStack);

        pCatStore->hReserved = NULL;
    }

    pCatStore->cbStruct = 0;    // just in case they try to re-open it!

    DELETE_OBJECT(pCatStore);

    //
    //  restore last error
    //
    SetLastError(dwlerr);

    return(fRet);
}

CRYPTCATSTORE * WINAPI CryptCATStoreFromHandle(IN HANDLE hCatalog)
{
    return((CRYPTCATSTORE *)hCatalog);
}

HANDLE WINAPI CryptCATHandleFromStore(IN CRYPTCATSTORE *pCatStore)
{
    return((HANDLE)pCatStore);
}

BOOL WINAPI CryptCATPersistStore(IN HANDLE hCatalog)
{
    CRYPTCATSTORE   *pStore;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pStore = CryptCATStoreFromHandle(hCatalog);

    if (!(pStore->pwszP7File))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(CatalogSaveP7UData(pStore));
}

CRYPTCATATTRIBUTE * WINAPI CryptCATGetCatAttrInfo(HANDLE hCatalog, LPWSTR pwszReferenceTag)
{
    CRYPTCATATTRIBUTE   *pAttr;
    CRYPTCATSTORE       *pCatStore;

    pAttr   = NULL;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag))
    {
        goto ErrorInvalidParam;
    }

    pCatStore = CryptCATStoreFromHandle(hCatalog);


    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    while (pAttr = CryptCATEnumerateCatAttr(hCatalog, pAttr))
    {
        if (pAttr->pwszReferenceTag)
        {
            if (_wcsicmp(pwszReferenceTag, pAttr->pwszReferenceTag) == 0)
            {
                goto CommonReturn;
            }
        }
    }

    goto ErrorNotFound;

    CommonReturn:
    ErrorReturn:
        return(pAttr);

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNotFound,     CRYPT_E_NOT_FOUND);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATPutCatAttrInfo(HANDLE hCatalog, LPWSTR pwszReferenceTag,
                                                  DWORD dwAttrTypeAndAction, DWORD cbData,
                                                  BYTE *pbData)
{
    CRYPTCATATTRIBUTE   *pAttr;

    pAttr = NULL;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag) ||
        ((cbData > 0) && !(pbData)))
    {
        goto ErrorInvalidParam;
    }

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATABASE64) &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)  &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAREPLACE))
    {
        goto ErrorInvalidParam;
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    Stack_              *pStack;

    if (!(pCatStore->hAttrs))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            goto ErrorMemory;
        }

        pCatStore->hAttrs = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCatStore->hAttrs;

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAREPLACE))
    {
        if (!(pAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
        {
            goto StackError;
        }

        memset(pAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

        pAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

        if (!(pAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                                sizeof(WCHAR))))
        {
            goto ErrorMemory;
        }

        wcscpy(pAttr->pwszReferenceTag, pwszReferenceTag);

        pAttr->dwAttrTypeAndAction = dwAttrTypeAndAction;

        if (pbData)
        {
            if (dwAttrTypeAndAction &  CRYPTCAT_ATTR_DATABASE64)
            {
                CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, NULL, &pAttr->cbValue, NULL, NULL);

                if (pAttr->cbValue < 1)
                {
                    goto DecodeError;
                }

                if (!(pAttr->pbValue = (BYTE *)CatalogNew(pAttr->cbValue)))
                {
                    pAttr->cbValue = 0;
                    goto ErrorMemory;
                }

                if (!CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, pAttr->pbValue, &pAttr->cbValue, NULL, NULL))
                {
                    goto DecodeError;
                }
            }
            else if (dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)
            {
                if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
                {
                    goto ErrorMemory;
                }

                memcpy(pAttr->pbValue, pbData, cbData);
                pAttr->cbValue = cbData;
            }
        }
    }
    else
    {
        DWORD pos = 0;
        pAttr = (CRYPTCATATTRIBUTE *) pStack->Get(pos++, NULL);
        while ((pAttr != NULL) && (wcscmp(pAttr->pwszReferenceTag, pwszReferenceTag) != 0))
        {
            pAttr = (CRYPTCATATTRIBUTE *) pStack->Get(pos++, NULL);   
        }
        
        if (pAttr != NULL)
        {
            DELETE_OBJECT(pAttr->pbValue);
            pAttr->pbValue = NULL;
            pAttr->cbValue = 0;

            if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
            {
                goto ErrorMemory;
            }

            memcpy(pAttr->pbValue, pbData, cbData);
            pAttr->cbValue = cbData;
        }
    }

    // CommonReturn:
    ErrorReturn:
        return(pAttr);

    TRACE_ERROR_EX(DBG_SS, StackError);
    TRACE_ERROR_EX(DBG_SS, DecodeError);

    SET_ERROR_VAR_EX(DBG_SS, ErrorMemory,       ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateCatAttr(HANDLE hCatalog, CRYPTCATATTRIBUTE *pPrevAttr)
{
    CRYPTCATATTRIBUTE   *pAttr;

    pAttr = NULL;

    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        goto ErrorInvalidParam;
    }

    CRYPTCATSTORE   *pStore;

    pStore = CryptCATStoreFromHandle(hCatalog);

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevAttr)
    {
        if (!(_ISINSTRUCT(CRYPTCATATTRIBUTE, pPrevAttr->cbStruct, dwReserved)))
        {
            goto ErrorInvalidParam;
        }

        dwNext = pPrevAttr->dwReserved + 1;
    }

    if (pStore->hAttrs)
    {
        Stack_              *ps;

        ps = (Stack_ *)pStore->hAttrs;

        if (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pAttr->dwReserved = dwNext;

            //
            //  Done!
            //
            goto CommonReturn;
        }
    }

    goto ErrorNotFound;

    CommonReturn:
    ErrorReturn:
        return(pAttr);

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNotFound,     CRYPT_E_NOT_FOUND);
}

CRYPTCATMEMBER * WINAPI CryptCATGetMemberInfo(IN HANDLE hCatalog, 
                                              IN LPWSTR pwszReferenceTag)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;
    CRYPTCATMEMBER  *pCatMember;

    pCatStore   = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pCatMember  = NULL;

    if (pCatStore->hReserved)
    {
        Stack_          *ps;

        ps = (Stack_ *)pCatStore->hReserved;

        if (pCatMember = (CRYPTCATMEMBER *)ps->Get(WVT_OFFSETOF(CRYPTCATMEMBER, pwszReferenceTag), 
                                                   sizeof(WCHAR *), 
                                                   STACK_SORTTYPE_PWSZ,
                                                   pwszReferenceTag))
        {
            if (!(pCatMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCatStore, pCatMember, &pCatMember->sEncodedIndirectData);
            }

            if ((pCatMember->gSubjectType.Data1 == 0) &&
                (pCatMember->gSubjectType.Data2 == 0) &&
                (pCatMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCatStore, pCatMember, &pCatMember->sEncodedMemberInfo);
            }

            return(pCatMember);
        }
    }

    return(NULL);
}


CRYPTCATMEMBER * WINAPI CryptCATPutMemberInfo(HANDLE hCatalog,
                                              LPWSTR pwszFileName,
                                              LPWSTR pwszReferenceTag,
                                              GUID *pgSubjectType,
                                              DWORD dwCertVersion,
                                              DWORD cbIndirectData,
                                              BYTE *pbIndirectData)

{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag) ||
        !(pgSubjectType) ||
        !(pbIndirectData) ||
        (wcslen(pwszReferenceTag) > CRYPTCAT_MAX_MEMBERTAG))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Stack_          *pStack;
    CRYPTCATMEMBER  *pCatMember;

    if (!(pCatStore->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCatStore->hReserved = (HANDLE)pStack;
    }

    //
    //  the following is commented out -- too slow!!!!
    //
    // else if (CatalogCheckForDuplicateMember((Stack_ *)pCatStore->hReserved, pwszReferenceTag))
    // {
    //     SetLastError(CRYPT_E_EXISTS);
    //     return(NULL);
    // }

    pStack = (Stack_ *)pCatStore->hReserved;

    if (!(pCatMember = (CRYPTCATMEMBER *)pStack->Add(sizeof(CRYPTCATMEMBER))))
    {
        return(NULL);
    }

    memset(pCatMember, 0x00, sizeof(CRYPTCATMEMBER));

    pCatMember->cbStruct = sizeof(CRYPTCATMEMBER);

    if (pwszFileName)
    {
        if (!(pCatMember->pwszFileName = (LPWSTR)CatalogNew((wcslen(pwszFileName) + 1) *
                                                            sizeof(WCHAR))))
        {
            return(NULL);
        }

        wcscpy(pCatMember->pwszFileName, pwszFileName);
    }

    if (!(pCatMember->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                            sizeof(WCHAR))))
    {
        return(NULL);
    }

    wcscpy(pCatMember->pwszReferenceTag, pwszReferenceTag);

    if (cbIndirectData > 0)
    {
        SIP_INDIRECT_DATA   *pInd;

        if (!(pCatMember->pIndirectData = (SIP_INDIRECT_DATA *)CatalogNew(sizeof(SIP_INDIRECT_DATA))))
        {
            return(NULL);
        }

        memset(pCatMember->pIndirectData, 0x00, sizeof(SIP_INDIRECT_DATA));

        pInd = (SIP_INDIRECT_DATA *)pbIndirectData;

        if (pInd->Data.pszObjId)
        {
            if (!(pCatMember->pIndirectData->Data.pszObjId = 
                                    (LPSTR)CatalogNew(strlen(pInd->Data.pszObjId) + 1)))
            {
                return(NULL);
            }
            
            strcpy(pCatMember->pIndirectData->Data.pszObjId, pInd->Data.pszObjId);
        }

        if (pInd->Data.Value.cbData > 0)
        {
            if (!(pCatMember->pIndirectData->Data.Value.pbData = 
                                    (BYTE *)CatalogNew(pInd->Data.Value.cbData)))
            {
                return(NULL);
            }
            
            memcpy(pCatMember->pIndirectData->Data.Value.pbData, 
                        pInd->Data.Value.pbData, pInd->Data.Value.cbData);
        }

        pCatMember->pIndirectData->Data.Value.cbData = pInd->Data.Value.cbData;


        if (!(pCatMember->pIndirectData->DigestAlgorithm.pszObjId = 
                    (LPSTR)CatalogNew(strlen(pInd->DigestAlgorithm.pszObjId) + 1)))
        {
            return(NULL);
        }
        strcpy(pCatMember->pIndirectData->DigestAlgorithm.pszObjId,
                pInd->DigestAlgorithm.pszObjId);


        if (!(pCatMember->pIndirectData->Digest.pbData = 
                    (BYTE *)CatalogNew(pInd->Digest.cbData)))
        {
            return(NULL);
        }
        memcpy(pCatMember->pIndirectData->Digest.pbData,
                    pInd->Digest.pbData, pInd->Digest.cbData);
        pCatMember->pIndirectData->Digest.cbData = pInd->Digest.cbData;
    }

    memcpy(&pCatMember->gSubjectType, pgSubjectType, sizeof(GUID));

    pCatMember->dwCertVersion = dwCertVersion;

    return(pCatMember);
}

BOOL WINAPI CryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(hFileOrMemory) ||
        (hFileOrMemory == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // TBDTBD!!!

    return(FALSE);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATGetAttrInfo(HANDLE hCatalog,
                                               CRYPTCATMEMBER *pCatMember,
                                               LPWSTR pwszReferenceTag)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(pwszReferenceTag))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE       *pCatStore;
    CRYPTCATATTRIBUTE   *pCatAttr;

    pCatStore   = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pCatAttr  = NULL;

    while (pCatAttr = CryptCATEnumerateAttr(hCatalog, pCatMember, pCatAttr))
    {
        if (pCatAttr->pwszReferenceTag)
        {
            if (_wcsicmp(pwszReferenceTag, pCatAttr->pwszReferenceTag) == 0)
            {
                return(pCatAttr);
            }
        }
    }

    SetLastError(CRYPT_E_NOT_FOUND);

    return(NULL);
}


CRYPTCATATTRIBUTE * WINAPI CryptCATPutAttrInfo(HANDLE hCatalog,
                                               CRYPTCATMEMBER *pCatMember,
                                               LPWSTR pwszReferenceTag,
                                               DWORD dwAttrTypeAndAction,
                                               DWORD cbData,
                                               BYTE *pbData)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(pwszReferenceTag) ||
        ((cbData > 0) && !(pbData)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATABASE64) &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pAttr;

    if (!(pCatMember->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCatMember->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCatMember->hReserved;

    if (!(pAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(NULL);
    }

    memset(pAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    if (!(pAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                            sizeof(WCHAR))))
    {
        return(NULL);
    }

    wcscpy(pAttr->pwszReferenceTag, pwszReferenceTag);

    pAttr->dwAttrTypeAndAction = dwAttrTypeAndAction;

    if (pbData)
    {
        if (dwAttrTypeAndAction &  CRYPTCAT_ATTR_DATABASE64)
        {
            CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, NULL, &pAttr->cbValue, NULL, NULL);

            if (pAttr->cbValue < 1)
            {
                return(NULL);
            }

            if (!(pAttr->pbValue = (BYTE *)CatalogNew(pAttr->cbValue)))
            {
                pAttr->cbValue = 0;
                return(NULL);
            }

            memset(pAttr->pbValue, 0x00, pAttr->cbValue);

            if (!CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, pAttr->pbValue, &pAttr->cbValue, NULL, NULL))
            {
                return(NULL);
            }
        }
        else if (dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)
        {
            if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
            {
                return(NULL);
            }

            memcpy(pAttr->pbValue, pbData, cbData);
            pAttr->cbValue = cbData;
        }
    }

    return(pAttr);
}


CRYPTCATMEMBER * WINAPI CryptCATEnumerateMember(HANDLE hCatalog,
                                                CRYPTCATMEMBER *pPrevMember)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevMember)
    {
        if (!(_ISINSTRUCT(CRYPTCATMEMBER, pPrevMember->cbStruct, hReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(NULL);
        }

        dwNext = pPrevMember->dwReserved + 1;
    }

    if (pCatStore->hReserved)
    {
        CRYPTCATMEMBER  *pCatMember;
        Stack_          *ps;

        ps = (Stack_ *)pCatStore->hReserved;

        if (pCatMember = (CRYPTCATMEMBER *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pCatMember->dwReserved = dwNext;


            if (!(pCatMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCatStore, pCatMember, &pCatMember->sEncodedIndirectData);
            }

            if ((pCatMember->gSubjectType.Data1 == 0) &&
                (pCatMember->gSubjectType.Data2 == 0) &&
                (pCatMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCatStore, pCatMember, &pCatMember->sEncodedMemberInfo);
            }

            //
            //  Done!
            //
            return(pCatMember);
        }
    }

    return(NULL);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateAttr(HANDLE hCatalog,
                                                 CRYPTCATMEMBER *pCatMember,
                                                 CRYPTCATATTRIBUTE *pPrevAttr)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevAttr)
    {
        if (!(_ISINSTRUCT(CRYPTCATATTRIBUTE, pPrevAttr->cbStruct, dwReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(NULL);
        }

        dwNext = pPrevAttr->dwReserved + 1;
    }

    if (!(pCatStore) ||
        !(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if (pCatMember->hReserved)
    {
        CRYPTCATATTRIBUTE   *pCatAttr;
        Stack_              *ps;

        ps = (Stack_ *)pCatMember->hReserved;

        if (pCatAttr = (CRYPTCATATTRIBUTE *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pCatAttr->dwReserved = dwNext;

            //
            //  Done!
            //
            return(pCatAttr);
        }
    }

    return(NULL);
}


/////////////////////////////////////////////////////////////////////////////
//
//  Local Functions
//  

BOOL CryptCATCreateStore(CRYPTCATSTORE *pCatStore, LPWSTR pwszCatFile)
{
    HANDLE      hFile;
    DWORD       lErr;

    lErr = GetLastError();

    if ((hFile = CreateFileU(pwszCatFile,
                             GENERIC_WRITE | GENERIC_READ,
                             0,                 // no sharing!!
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    CloseHandle(hFile);

    SetLastError(lErr);

    return(CryptCATOpenStore(pCatStore, pwszCatFile));
}
                                            
BOOL CryptCATOpenStore(CRYPTCATSTORE *pCatStore, LPWSTR pwszCatFile)
{
    if (!(pCatStore->pwszP7File = (LPWSTR)CatalogNew((wcslen(pwszCatFile) + 1) *
                                                sizeof(WCHAR))))
    {
        return(FALSE);
    }

    wcscpy(pCatStore->pwszP7File, pwszCatFile);

    return(CatalogLoadFileData(pCatStore));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscat32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscat32.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//
//              *** local functions ***
//              CatalogNew
//              CatalogFreeMember
//              CatalogFreeAttribute
//              CatalogCheckForDuplicateMember
//
//  History:    25-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

CRITICAL_SECTION    MSCAT_CriticalSection;

HINSTANCE           hInst;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

BOOL WINAPI mscat32DllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
    BOOL fRet;
    BOOL fCritSecInitialized = FALSE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            hInst = (HINSTANCE)hInstDLL;

            __try
            {
                InitializeCriticalSection(&MSCAT_CriticalSection);
                fCritSecInitialized = TRUE;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                fRet = FALSE;
                goto Return;
            }
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&MSCAT_CriticalSection);
            break;
    }

    fRet = CatAdminDllMain(hInstDLL, fdwReason, lpvReserved);

    if (!fRet && fCritSecInitialized)
    {   
        DeleteCriticalSection(&MSCAT_CriticalSection);
    }

Return:

    return fRet;
}

STDAPI mscat32DllRegisterServer(void)
{
    return(S_OK);
}


STDAPI mscat32DllUnregisterServer(void)
{
    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  local utility functions
//
//

void *CatalogNew(DWORD cbSize)
{
    void    *pvRet;

    pvRet = (void *)new BYTE[cbSize];

    if (!(pvRet))
    {
        assert(pvRet);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return(pvRet);
}

BOOL CatalogFreeAttribute(CRYPTCATATTRIBUTE *pCatAttr)
{
    if (!(pCatAttr) ||
        (pCatAttr->cbStruct != sizeof(CRYPTCATATTRIBUTE)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    DELETE_OBJECT(pCatAttr->pwszReferenceTag);
    DELETE_OBJECT(pCatAttr->pbValue);
    pCatAttr->cbValue               = 0;
    pCatAttr->dwAttrTypeAndAction   = 0;
    pCatAttr->dwReserved            = 0;

    return(TRUE);
}

BOOL CatalogFreeMember(CRYPTCATMEMBER *pCatMember)
{
    if (!(pCatMember) ||
        (pCatMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    //  reference tag
    //
    DELETE_OBJECT(pCatMember->pwszReferenceTag);

    //
    //  file name
    //
    DELETE_OBJECT(pCatMember->pwszFileName);

    //
    //  free indirect data
    //
    if (pCatMember->pIndirectData)
    {
            // Data.pszObjId
        DELETE_OBJECT(pCatMember->pIndirectData->Data.pszObjId);

            // Data.Value.pbData
        DELETE_OBJECT(pCatMember->pIndirectData->Data.Value.pbData);

            // DigestAlgorithm.pszObjId
        DELETE_OBJECT(pCatMember->pIndirectData->DigestAlgorithm.pszObjId);

            // Digest.pbData
        DELETE_OBJECT(pCatMember->pIndirectData->Digest.pbData);

            // the structure itself!
        DELETE_OBJECT(pCatMember->pIndirectData);
    }

    //
    //  free encoded indirect data
    //
    DELETE_OBJECT(pCatMember->sEncodedIndirectData.pbData);
    pCatMember->sEncodedIndirectData.cbData = 0;

    //
    //  free encoded member info
    //
    DELETE_OBJECT(pCatMember->sEncodedMemberInfo.pbData);
    pCatMember->sEncodedMemberInfo.cbData = 0;


    //
    //  free attribute data
    //
    if (pCatMember->hReserved)
    {
        Stack_  *ps;
        DWORD               cStack;
        CRYPTCATATTRIBUTE   *pAttr;

        ps = (Stack_ *)pCatMember->hReserved;

        cStack = 0;

        while (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(cStack))
        {
            CatalogFreeAttribute(pAttr);

            cStack++;
        }

        DELETE_OBJECT(ps);

        pCatMember->hReserved = NULL;
    }

    return(TRUE);
}

BOOL CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag)
{
    CRYPTCATMEMBER  *pMem;
    DWORD           iCur;
    DWORD           ccRT;

    ccRT    = wcslen(pwszReferenceTag);
    iCur    = 0;

    while (iCur < pMembers->Count())
    {
        pMem = (CRYPTCATMEMBER *)pMembers->Get(iCur);

        if (pMem)
        {
            if (ccRT == (DWORD)wcslen(pMem->pwszReferenceTag))
            {
                if (wcscmp(pwszReferenceTag, pMem->pwszReferenceTag) == 0)
                {
                    return(TRUE);
                }
            }
        }

        //
        //  increment our index!
        //
        iCur++;
    }

    return(FALSE);
}

WCHAR aHexDigit[] = {
           L'0',
           L'1',
           L'2',
           L'3',
           L'4',
           L'5',
           L'6',
           L'7',
           L'8',
           L'9',
           L'A',
           L'B',
           L'C',
           L'D',
           L'E',
           L'F'
           };

VOID ByteToWHex (IN LPBYTE pbDigest, IN DWORD iByte, OUT LPWSTR pwszHashTag)
{
    DWORD iTag;
    DWORD iHexDigit1;
    DWORD iHexDigit2;

    iTag = iByte * 2;
    iHexDigit1 = ( pbDigest[ iByte ] & 0xF0 ) >> 4;
    iHexDigit2 = ( pbDigest[ iByte ] & 0x0F );

    pwszHashTag[ iTag ] = aHexDigit[ iHexDigit1 ];
    pwszHashTag[ iTag + 1 ] = aHexDigit[ iHexDigit2 ];
}

BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag)
{
    DWORD  cwTag;
    LPWSTR pwszHashTag;
    DWORD  cCount;

    cwTag = ( ( cbDigest * 2 ) + 1 );
    pwszHashTag = (LPWSTR)CatalogNew( cwTag * sizeof( WCHAR ) );
    if ( pwszHashTag == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    for ( cCount = 0; cCount < cbDigest; cCount++ )
    {
        ByteToWHex( pbDigest, cCount, pwszHashTag );
    }

    pwszHashTag[ cwTag - 1 ] = L'\0';

    *ppwszHashTag = pwszHashTag;

    return( TRUE );
}

VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag)
{
    DELETE_OBJECT(pwszHashTag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\inddata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       IndData.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogDecodeIndirectData
//              CatalogReallyDecodeIndirectData
//              CatalogEncodeIndirectData
//
//  History:    16-May-1997 pberkman    created
//              01-Oct-1997 pberkman    add lazy decode
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

BOOL CatalogDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    DELETE_OBJECT(pMember->sEncodedIndirectData.pbData);

    if (pAttr->rgValue->cbData < 1)
    {
        return(FALSE);
    }

    if (!(pMember->sEncodedIndirectData.pbData = (BYTE *)CatalogNew(pAttr->rgValue->cbData)))
    {
        pMember->sEncodedIndirectData.cbData = 0;

        return(FALSE);
    }

    pMember->sEncodedIndirectData.cbData = pAttr->rgValue->cbData;
    memcpy(pMember->sEncodedIndirectData.pbData, pAttr->rgValue->pbData, pAttr->rgValue->cbData);

    return(TRUE);
}

BOOL CatalogReallyDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTR_BLOB *pAttr)
{
    DWORD               cbDecode;
    SIP_INDIRECT_DATA   *pInd;

    cbDecode = 0;

    CryptDecodeObject(pCat->dwEncodingType,
                      SPC_INDIRECT_DATA_CONTENT_STRUCT,
                      pAttr->pbData,
                      pAttr->cbData,
                      0,
                      NULL,
                      &cbDecode);

    if (cbDecode > 0)
    {
        if (!(pInd = (SIP_INDIRECT_DATA *)CatalogNew(cbDecode)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(pCat->dwEncodingType,
                                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                                pAttr->pbData,
                                pAttr->cbData,
                                0,
                                pInd,
                                &cbDecode)))
        {
            delete pInd;

            return(FALSE);
        }

        if (!(pMember->pIndirectData = (SIP_INDIRECT_DATA *)CatalogNew(sizeof(SIP_INDIRECT_DATA))))
        {
            delete pInd;

            return(FALSE);
        }

        memset(pMember->pIndirectData, 0x00, sizeof(SIP_INDIRECT_DATA));

        pMember->pIndirectData->Data.pszObjId = (LPSTR)CatalogNew(strlen(pInd->Data.pszObjId) + 1);

        if (pInd->Data.Value.cbData > 0)
        {
            pMember->pIndirectData->Data.Value.pbData =
                                                (BYTE *)CatalogNew(pInd->Data.Value.cbData);
            pMember->pIndirectData->Data.Value.cbData = pInd->Data.Value.cbData;
        }

        pMember->pIndirectData->DigestAlgorithm.pszObjId =
                                                (LPSTR)CatalogNew(strlen(pInd->DigestAlgorithm.pszObjId) + 1);

        if (pInd->Digest.cbData > 0)
        {
            pMember->pIndirectData->Digest.pbData = (BYTE *)CatalogNew(pInd->Digest.cbData);
            pMember->pIndirectData->Digest.cbData = pInd->Digest.cbData;
        }

        if (!(pMember->pIndirectData->Data.pszObjId) ||
            ((pInd->Data.Value.cbData > 0) && !(pMember->pIndirectData->Data.Value.pbData)) ||
            !(pMember->pIndirectData->DigestAlgorithm.pszObjId) ||
            ((pInd->Digest.cbData > 0) && !(pMember->pIndirectData->Digest.pbData)))
        {
            delete pInd;
            return(FALSE);
        }

        strcpy(pMember->pIndirectData->Data.pszObjId, pInd->Data.pszObjId);

        if (pInd->Data.Value.cbData > 0)
        {
            memcpy(pMember->pIndirectData->Data.Value.pbData,
                    pInd->Data.Value.pbData, pInd->Data.Value.cbData);
        }

        strcpy(pMember->pIndirectData->DigestAlgorithm.pszObjId,
                pInd->DigestAlgorithm.pszObjId);

        if (pInd->Digest.cbData > 0)
        {
            memcpy(pMember->pIndirectData->Digest.pbData,
                    pInd->Digest.pbData, pInd->Digest.cbData);
        }

        delete pInd;

        return(TRUE);
    }

    return(FALSE);
}


BOOL CatalogEncodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, 
                               PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    if (!(pMember->pIndirectData))
    {
        return(FALSE);
    }

    pCryptAttr->pszObjId = SPC_INDIRECT_DATA_OBJID; 

    DWORD   cbEncoded;

    cbEncoded = 0;

    CryptEncodeObject(pCat->dwEncodingType,
                      pCryptAttr->pszObjId,
                      pMember->pIndirectData,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(cbEncoded)))
        {
            return(FALSE);
        }

        pCryptAttr->rgValue->cbData = cbEncoded;

        if (!(CryptEncodeObject(pCat->dwEncodingType,
                                pCryptAttr->pszObjId,
                                pMember->pIndirectData,
                                pCryptAttr->rgValue->pbData,
                                &cbEncoded)))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\meminfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       meminfo.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CatalogDecodeMemberInfo
//              CatalogReallyDecodeMemberInfo
//              CatalogEncodeMemberInfo
//
//  History:    16-May-1997 pberkman    created
//              01-Oct-1997 pberkman    add lazy decode
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

BOOL CatalogDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    DELETE_OBJECT(pMember->sEncodedMemberInfo.pbData);

    if (pAttr->rgValue->cbData < 1)
    {
        return(FALSE);
    }

    if (!(pMember->sEncodedMemberInfo.pbData = (BYTE *)CatalogNew(pAttr->rgValue->cbData)))
    {
        pMember->sEncodedMemberInfo.cbData = 0;

        return(FALSE);
    }

    pMember->sEncodedMemberInfo.cbData = pAttr->rgValue->cbData;
    memcpy(pMember->sEncodedMemberInfo.pbData, pAttr->rgValue->pbData, pAttr->rgValue->cbData);

    return(TRUE);
}

BOOL CatalogReallyDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTR_BLOB *pAttr)
{
    DWORD           cbDecode;
    CAT_MEMBERINFO  *pCatMemberInfo;

    cbDecode = 0;

    CryptDecodeObject(pCat->dwEncodingType,
                      CAT_MEMBERINFO_STRUCT,
                      pAttr->pbData,
                      pAttr->cbData,
                      0,
                      NULL,
                      &cbDecode);

    if (cbDecode > 0)
    {
        if (!(pCatMemberInfo = (CAT_MEMBERINFO *)CatalogNew(cbDecode)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(pCat->dwEncodingType,
                                CAT_MEMBERINFO_STRUCT,
                                pAttr->pbData,
                                pAttr->cbData,
                                0,
                                pCatMemberInfo,
                                &cbDecode)))
        {
            delete pCatMemberInfo;

            return(FALSE);
        }

        if (pCatMemberInfo->pwszSubjGuid)
        {
            if (!(wstr2guid(pCatMemberInfo->pwszSubjGuid, &pMember->gSubjectType)))
            {
                delete pCatMemberInfo;
            
                return(FALSE);
            }

            pMember->dwCertVersion  = pCatMemberInfo->dwCertVersion;

            delete pCatMemberInfo;

            return(TRUE);
        }

        delete pCatMemberInfo;
    }

    return(FALSE);
}


BOOL CatalogEncodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, 
                              PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    pCryptAttr->pszObjId = CAT_MEMBERINFO_OBJID;

    DWORD           cbEncoded;
    CAT_MEMBERINFO  sCatMemberInfo;
    WCHAR           wszGuid[41];

    sCatMemberInfo.pwszSubjGuid = &wszGuid[0];

    if (!(guid2wstr(&pMember->gSubjectType, sCatMemberInfo.pwszSubjGuid)))
    {
        assert(0);
        
        DELETE_OBJECT(pCryptAttr->rgValue);
        return(FALSE);
    }

    sCatMemberInfo.dwCertVersion = pMember->dwCertVersion;

    cbEncoded = 0;

    CryptEncodeObject(pCat->dwEncodingType,
                      pCryptAttr->pszObjId,
                      &sCatMemberInfo,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(cbEncoded)))
        {
            return(FALSE);
        }

        pCryptAttr->rgValue->cbData = cbEncoded;

        if (!(CryptEncodeObject(pCat->dwEncodingType,
                                pCryptAttr->pszObjId,
                                &sCatMemberInfo,
                                pCryptAttr->rgValue->pbData,
                                &cbEncoded)))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatctl.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogLoadFileData
//              CatalogSaveP7UData
//              CatalogSaveP7SData
//              IsCatalogFile
//
//              *** local functions ***
//              CatalogLoadData
//              CatalogFillCatStore
//              CatalogFillCTL
//              CatalogFillCTLAttr
//              CatalogFreeCTL
//              CatalogFreeCTLAttr
//              CatalogFillCatMember
//              CatalogFillMemAttr
//              CatalogFillCatAttr
//              CatalogFillCatLevelAttr
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

//
//  for each member, we have at minimum two authenticated attributes.
//      1 = Indirect Data
//      2 = Subject Guid
//
#define     CAT_RESERVE_CTL_ATTR        2


// WARNING: this function allocates pbData -- you must delete!
BOOL            CatalogLoadData(WCHAR *pwszCatFile, DWORD *cbData, BYTE **pbData);

BOOL            CatalogFillCatStore(CRYPTCATSTORE *pCat, PCTL_INFO pCTLInfo);
BOOL            CatalogFreeCTL(CTL_INFO *pCTL);
BOOL            CatalogFreeCTLAttr(CRYPT_ATTRIBUTE *pCryptAttr);
BOOL            CatalogFillCTL(CRYPTCATSTORE *pCat, CTL_INFO *pCTL);
BOOL            CatalogFillCatAttr(CRYPTCATSTORE *pCat, CERT_EXTENSION *pAttr);
BOOL            CatalogFillCatLevelAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                        CERT_EXTENSION *pCertAttr);
BOOL            CatalogFillCTLAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                   PCRYPT_ATTRIBUTE pCryptAttr);

CRYPTCATMEMBER  *CatalogFillCatMember(CRYPTCATSTORE *pCat, CTL_ENTRY *pEntry);
BOOL            CatalogFillMemAttr(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr);

static const char *pszOID = szOID_CATALOG_LIST;

BOOL CatalogLoadFileData(CRYPTCATSTORE *pCat)
{
    BOOL    fRet;
    DWORD   cbData;
    BYTE    *pbData;

    cbData  = 0;
    pbData  = NULL;

    if (!(CatalogLoadData(pCat->pwszP7File, &cbData, &pbData)))
    {
        return(FALSE);
    }

    if (cbData < 1)
    {
        if (pbData)
        {
            UnmapViewOfFile(pbData);
        }

        //
        // not signed and we are probably creating it!
        //
        return(TRUE);
    }

    PCCTL_CONTEXT   pCTLContext;

    pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        pCat->dwEncodingType,
        pbData,
        cbData,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
            CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG,
        NULL                                        // pCreatePara
        );


    if (pCTLContext)
    {
        //
        // got it...  fill our arrays!
        //

        fRet = CatalogFillCatStore(pCat, pCTLContext->pCtlInfo);
        CertFreeCTLContext(pCTLContext);
    } else
        fRet = FALSE;

    UnmapViewOfFile(pbData);

    return(fRet);
}

BOOL CatalogSaveP7SData(CRYPTCATSTORE *pCat, CTL_CONTEXT *pCTLContext)
{
    assert(0);      // should never be called!
    return(TRUE);
}

BOOL CatalogSaveP7UData(CRYPTCATSTORE *pCat)
{
    CMSG_SIGNED_ENCODE_INFO sSignInfo;
    CTL_INFO                sCTLInfo;
    DWORD                   cbEncoded;
    BYTE                    *pbEncoded;
    Stack_                  *pStack;

    //
    //  sort the data...
    //
    if (pCat->hReserved)    // member stack_
    {
        pStack = (Stack_ *)pCat->hReserved;

        pStack->Sort(WVT_OFFSETOF(CRYPTCATMEMBER, pwszReferenceTag), sizeof(WCHAR *), STACK_SORTTYPE_PWSZ);
    }

    memset(&sSignInfo, 0x00, sizeof(CMSG_SIGNED_ENCODE_INFO));
    sSignInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    if (CatalogFillCTL(pCat, &sCTLInfo))
    {
        cbEncoded = 0;

        CryptMsgEncodeAndSignCTL(   pCat->dwEncodingType,
                                    &sCTLInfo,
                                    &sSignInfo,
                                    0,
                                    NULL,
                                    &cbEncoded);

        if (cbEncoded > 0)
        {
            BOOL    fRet;

            if (!(pbEncoded = (BYTE *)CatalogNew(cbEncoded)))
            {
                CatalogFreeCTL(&sCTLInfo);
                return(FALSE);
            }

            fRet = CryptMsgEncodeAndSignCTL(    pCat->dwEncodingType,
                                                &sCTLInfo,
                                                &sSignInfo,
                                                0,
                                                pbEncoded,
                                                &cbEncoded);
            CatalogFreeCTL(&sCTLInfo);

            if (fRet)
            {
                HANDLE  hFile;
                DWORD   lErr;

                lErr = GetLastError();

                if ((hFile = CreateFileU(pCat->pwszP7File,
                                        GENERIC_WRITE | GENERIC_READ,
                                        0,                 // no sharing!!
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) != INVALID_HANDLE_VALUE)
                {
                    DWORD   cbWritten;

                    if (!(WriteFile(hFile, pbEncoded, cbEncoded, &cbWritten, NULL)) ||
                        (cbEncoded != cbWritten))
                    {
                        fRet = FALSE;
                    }

                    CloseHandle(hFile);

                    if (fRet)
                    {
                        SetLastError(lErr);
                    }
                }
            }

            delete pbEncoded;

            return(fRet);
        }

        CatalogFreeCTL(&sCTLInfo);
    }

    return(FALSE);
}

BOOL CatalogLoadData(WCHAR *pwszCatFile, DWORD *cbData, BYTE **pbData)
{
    HANDLE  hFile;

    *cbData = 0;

    if ((hFile = CreateFileU(pwszCatFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    if ((*cbData = GetFileSize(hFile, NULL)) == 0xffffffff)
    {
        *cbData = 0;
        CloseHandle(hFile);
        return(FALSE);
    }

    if (*cbData < 10)
    {
        //
        //  just created file....
        //
        *cbData = 0;
        CloseHandle(hFile);
        return(TRUE);
    }

    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        *cbData = 0;
        CloseHandle(hFile);
        return(FALSE);
    }

    *pbData = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    CloseHandle(hFile);

    if ((*pbData) == NULL)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillCatStore(CRYPTCATSTORE *pCat, CTL_INFO *pCTL)
{
    int     iAttr;

    if (pCTL->cCTLEntry > 0)
    {
        for (iAttr = 0; iAttr < (int)pCTL->cExtension; iAttr++)
        {
            if (!(CatalogFillCatAttr(pCat, &pCTL->rgExtension[iAttr])))
            {
                return(FALSE);
            }
        }

        CRYPTCATMEMBER  *pMember;

        for (int iEntry = 0; iEntry < (int)pCTL->cCTLEntry; iEntry++)
        {
            pMember = CatalogFillCatMember(pCat, &pCTL->rgCTLEntry[iEntry]);

            if (!(pMember))
            {
                return(FALSE);
            }

            if (pCTL->rgCTLEntry[iEntry].cAttribute > 0)
            {
                for (iAttr = 0; iAttr < (int)pCTL->rgCTLEntry[iEntry].cAttribute; iAttr++)
                {
                    if (!(CatalogFillMemAttr(pCat, pMember,
                                            &pCTL->rgCTLEntry[iEntry].rgAttribute[iAttr])))
                    {
                        return(FALSE);
                    }
                }
            }
        }

        return(TRUE);
    }

    return(TRUE);
}

CRYPTCATMEMBER *CatalogFillCatMember(CRYPTCATSTORE *pCat, CTL_ENTRY *pEntry)
{
    if (!(pEntry))
    {
        return(NULL);
    }

    Stack_          *pStack;
    CRYPTCATMEMBER  *pCatMember;

    if (!(pCat->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCat->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCat->hReserved;

    if (!(pCatMember = (CRYPTCATMEMBER *)pStack->Add(sizeof(CRYPTCATMEMBER))))
    {
        return(NULL);
    }

    memset(pCatMember, 0x00, sizeof(CRYPTCATMEMBER));

    pCatMember->cbStruct = sizeof(CRYPTCATMEMBER);

    // pwszFileName

    // pwszReferenceTag
    if (!(pCatMember->pwszReferenceTag = (LPWSTR)CatalogNew(pEntry->SubjectIdentifier.cbData)))
    {
        return(NULL);
    }

    memcpy(pCatMember->pwszReferenceTag, pEntry->SubjectIdentifier.pbData,
                                         pEntry->SubjectIdentifier.cbData);

    // pIndirectData (will be filled in while getting attributes!

    // gSubjectType (will be filled in while getting attributes!

    return(pCatMember);
}

BOOL CatalogFillCatAttr(CRYPTCATSTORE *pCat, CERT_EXTENSION *pAttr)
{
    if (!(pAttr))
    {
        return(FALSE);
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pCatAttr;

    if (!(pCat->hAttrs))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        pCat->hAttrs = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCat->hAttrs;

    if (!(pCatAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(FALSE);
    }

    memset(pCatAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pCatAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    CRYPT_ATTRIBUTE     sCryptAttr;

    CatalogCertExt2CryptAttr(pAttr, &sCryptAttr);

    if (!(CatalogDecodeNameValue(pCat, &sCryptAttr, pCatAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillMemAttr(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    if (!(pAttr))
    {
        return(FALSE);
    }

    if (strcmp(pAttr->pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
    {
        return(CatalogDecodeIndirectData(pCat, pMember, pAttr));
    }

    if (strcmp(pAttr->pszObjId, CAT_MEMBERINFO_OBJID) == 0)
    {
        return(CatalogDecodeMemberInfo(pCat, pMember, pAttr));
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pCatAttr;

    if (!(pMember->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        pMember->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pMember->hReserved;

    if (!(pCatAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(FALSE);
    }

    memset(pCatAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pCatAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    if (!(CatalogDecodeNameValue(pCat, pAttr, pCatAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillCTL(CRYPTCATSTORE *pCat, CTL_INFO *pCTL)
{
    typedef         HRESULT (WINAPI *pfnCoCreateGuid)(GUID FAR *pguid);
    HINSTANCE       hOLE;
    pfnCoCreateGuid pfnCreateGuid;

    memset(pCTL, 0x00, sizeof(CTL_INFO));

    // dwVersion
    pCTL->dwVersion = CTL_V1;

    // SubjectUsage
    pCTL->SubjectUsage.cUsageIdentifier = 1;
    pCTL->SubjectUsage.rgpszUsageIdentifier = (char **)&pszOID;

    // ListIdentifier
    if (hOLE = LoadLibraryA("OLE32.DLL"))
    {
        if (pfnCreateGuid = (pfnCoCreateGuid)GetProcAddress(hOLE, "CoCreateGuid"))
        {
            if (pCTL->ListIdentifier.pbData = (BYTE *)CatalogNew(sizeof(GUID)))
            {
                pCTL->ListIdentifier.cbData = sizeof(GUID);
                (*pfnCreateGuid)((GUID *)pCTL->ListIdentifier.pbData);
            }
        }

        FreeLibrary(hOLE);
    }

    // SequenceNumber
        // optional!

    // ThisUpdate
    GetSystemTimeAsFileTime(&pCTL->ThisUpdate);

    // NextUpdate
        // optional!

    // SubjectAlgorithm
    pCTL->SubjectAlgorithm.pszObjId = szOID_CATALOG_LIST_MEMBER;


    Stack_              *pStackMember;
    Stack_              *pStackAttr;
    CRYPTCATMEMBER      *pMember;
    CRYPTCATATTRIBUTE   *pAttr;
    DWORD               dwAttr;

    // cCTLEntry & rgCTLEntry
    if (pCat->hReserved)
    {
        pStackMember = (Stack_ *)pCat->hReserved;

        // cCTLEntry
        pCTL->cCTLEntry = pStackMember->Count();

        if (pCTL->cCTLEntry > 0)
        {
            if (!(pCTL->rgCTLEntry = (PCTL_ENTRY)CatalogNew(sizeof(CTL_ENTRY) *
                                                            pStackMember->Count())))
            {
                return(FALSE);
            }

            memset(pCTL->rgCTLEntry, 0x00, sizeof(CTL_ENTRY) * pStackMember->Count());
        }


        DWORD           dwMember;
        DWORD           dwSize;
        CTL_ENTRY       *pCTLEntry;
        //
        //  copy the members to the ctl_entry
        //

        dwMember = 0;

        while (dwMember < pStackMember->Count())
        {
            if (!(pMember = (CRYPTCATMEMBER *)pStackMember->Get(dwMember)))
            {
                return(FALSE);
            }

            //
            //  Subject Identifier
            //
            dwSize = (wcslen(pMember->pwszReferenceTag) + 1) * sizeof(WCHAR);

            pCTLEntry = &pCTL->rgCTLEntry[dwMember];

            if (!(pCTLEntry->SubjectIdentifier.pbData =
                                (BYTE *)CatalogNew(dwSize)))
            {
                return(FALSE);
            }

            memcpy(pCTLEntry->SubjectIdentifier.pbData,
                    pMember->pwszReferenceTag,dwSize);
            pCTLEntry->SubjectIdentifier.cbData = dwSize;

            //
            //  rgAttribute
            //              +1 for Indirect Data
            //              +1 for Subject Guid
            //
            if (pMember->hReserved)
            {
                pStackAttr = (Stack_ *)pMember->hReserved;

                pCTLEntry->cAttribute = pStackAttr->Count() + CAT_RESERVE_CTL_ATTR;
            }
            else
            {
                pCTLEntry->cAttribute = CAT_RESERVE_CTL_ATTR;
            }

            if (!(pCTLEntry->rgAttribute =
                        (PCRYPT_ATTRIBUTE)CatalogNew(sizeof(CRYPT_ATTRIBUTE) *
                                                                    pCTLEntry->cAttribute)))
            {
                return(FALSE);
            }

            memset(pCTLEntry->rgAttribute, 0x00,
                        sizeof(CRYPT_ATTRIBUTE) * pCTLEntry->cAttribute);

            //
            //  put our indirect data in an authenticated attribute
            //
            if (!(pMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCat, pMember, &pMember->sEncodedIndirectData);
            }

            CatalogEncodeIndirectData(pCat, pMember, &pCTLEntry->rgAttribute[0]);

            //
            //  put our subject guid in an authenticated attribute
            //
            if ((pMember->gSubjectType.Data1 == 0) &&
                (pMember->gSubjectType.Data2 == 0) &&
                (pMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCat, pMember, &pMember->sEncodedMemberInfo);
            }

            CatalogEncodeMemberInfo(pCat, pMember, &pCTLEntry->rgAttribute[1]);

            if (pMember->hReserved)
            {
                dwAttr = 0;

                while (dwAttr < pStackAttr->Count())
                {
                    pAttr = (CRYPTCATATTRIBUTE *)pStackAttr->Get(dwAttr);

                    CatalogFillCTLAttr(pCat, pAttr,
                                       &pCTLEntry->rgAttribute[dwAttr + CAT_RESERVE_CTL_ATTR]);

                    //
                    //  increment our attribute counter!
                    //
                    dwAttr++;
                }
            }

            //
            //  increment our member counter!
            //
            dwMember++;
        }
    }

    //
    // cExtension
    // rgExtension
    //
    if (pCat->hAttrs)
    {
        pStackAttr = (Stack_ *)pCat->hAttrs;

        pCTL->cExtension = pStackAttr->Count();

        if (!(pCTL->rgExtension =
                        (CERT_EXTENSION *)CatalogNew(sizeof(CERT_EXTENSION) * pCTL->cExtension)))
        {
            return(FALSE);
        }

        memset(pCTL->rgExtension, 0x00, sizeof(CERT_EXTENSION) * pCTL->cExtension);

        dwAttr = 0;

        while (dwAttr < pStackAttr->Count())
        {
            pAttr = (CRYPTCATATTRIBUTE *)pStackAttr->Get(dwAttr);

            if (pAttr)
            {
                CatalogFillCatLevelAttr(pCat, pAttr, &pCTL->rgExtension[dwAttr]);
            }

            dwAttr++;
        }
    }

    return(TRUE);
}

BOOL CatalogFillCatLevelAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, CERT_EXTENSION *pCertAttr)
{
    CRYPT_ATTR_BLOB sAttrBlob;
    CRYPT_ATTRIBUTE sCryptAttr;

    memset(&sAttrBlob, 0x00, sizeof(CRYPT_ATTR_BLOB));
    memset(&sCryptAttr, 0x00, sizeof(CRYPT_ATTRIBUTE));

    sCryptAttr.cValue  = 1;
    sCryptAttr.rgValue = &sAttrBlob;

    if (!(CatalogEncodeNameValue(pCatStore, pAttr, &sCryptAttr)))
    {
        return(FALSE);
    }

    CatalogCryptAttr2CertExt(&sCryptAttr, pCertAttr);

    return(TRUE);
}

BOOL CatalogFillCTLAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    if (!(CatalogEncodeNameValue(pCatStore, pAttr, pCryptAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFreeCTL(CTL_INFO *pCTL)
{
    DWORD       dwEntries;
    DWORD       dwAttributes;
    CTL_ENTRY   *pCTLEntry;

    DELETE_OBJECT(pCTL->ListIdentifier.pbData);

    dwEntries = pCTL->cCTLEntry;

    while (dwEntries > 0)
    {
        pCTLEntry = &pCTL->rgCTLEntry[dwEntries - 1];

        DELETE_OBJECT(pCTLEntry->SubjectIdentifier.pbData);

        dwAttributes = pCTLEntry->cAttribute;

        while (dwAttributes > 0)
        {
            CatalogFreeCTLAttr(&pCTLEntry->rgAttribute[dwAttributes - 1]);

            dwAttributes--;
        }

        DELETE_OBJECT(pCTLEntry->rgAttribute);

        dwEntries--;
    }

    DELETE_OBJECT(pCTL->rgCTLEntry);

    for (dwEntries = 0; dwEntries < pCTL->cExtension; dwEntries++)
    {
        DELETE_OBJECT(pCTL->rgExtension[dwEntries].Value.pbData);
    }

    DELETE_OBJECT(pCTL->rgExtension);

    return(TRUE);
}

BOOL CatalogFreeCTLAttr(CRYPT_ATTRIBUTE *pCryptAttr)
{
    if (!(pCryptAttr))
    {
        return(FALSE);
    }

    if (pCryptAttr->rgValue)
    {
        DELETE_OBJECT(pCryptAttr->rgValue->pbData);
        DELETE_OBJECT(pCryptAttr->rgValue);
    }

    return(TRUE);
}

BOOL WINAPI IsCatalogFile(HANDLE hFile, WCHAR *pwszCatalogFile)
{
    char            *pszCatalogListUsageOID = szOID_CATALOG_LIST;
    BOOL            fCloseFile;
    BOOL            fRet;
    DWORD           cbRead;
    DWORD           cbFile;
    BYTE            *pbFile;
    PCCTL_CONTEXT   pCTLContext;

    //
    // put a try-except around everything in case there is problems with the
    // memory mapped file
    //
    __try {

    pCTLContext = NULL;
    pbFile      = NULL;
    fCloseFile  = FALSE;
    fRet        = FALSE;

    if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE))
    {
        if (!(pwszCatalogFile))
        {
            goto IsCatInvalidParam;
        }

        if ((hFile = CreateFileU(pwszCatalogFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            goto IsCatFileError;
        }

        fCloseFile = TRUE;
    }

    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto CreateFileMapFailed;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    if (!(pbFile))
    {
        goto MapViewFailed;
    }

    if (((cbFile = GetFileSize(hFile, NULL)) == 0xffffffff) ||
        (cbFile < 1))
    {
        goto FileSizeError;
    }

    if (pbFile[0] != (BYTE)0x30)
    {
        goto IsCatNotCatalog;
    }

    pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
        pbFile,
        cbFile,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
            CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG |
            CERT_CREATE_CONTEXT_NO_ENTRY_FLAG,
        NULL                                        // pCreatePara
        );

    if (pCTLContext)
    {
        if (pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
        {
            if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                        pszCatalogListUsageOID) == 0)
            {
                fRet = TRUE;
                goto CommonReturn;
           }
        }
    }

    goto IsCatNotCatalog;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
    }


    CommonReturn:

        if (pCTLContext)
        {
            CertFreeCTLContext(pCTLContext);
        }

        if (pbFile)
        {
            UnmapViewOfFile(pbFile);
        }

        if (fCloseFile)
        {
            CloseHandle(hFile);
        }

        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, IsCatNotCatalog);
    TRACE_ERROR_EX(DBG_SS, IsCatFileError);
    TRACE_ERROR_EX(DBG_SS, CreateFileMapFailed);
    TRACE_ERROR_EX(DBG_SS, MapViewFailed);

    SET_ERROR_VAR_EX(DBG_SS, IsCatInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, FileSizeError,     ERROR_INVALID_PARAMETER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscat32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscat32.h
//
//  History:    25-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MSCAT32_H
#define MSCAT32_H

#ifdef __cplusplus
extern "C"
{
#endif

extern CRITICAL_SECTION     MSCAT_CriticalSection;
extern HINSTANCE            hInst;

extern BOOL     CatalogFreeMember(CRYPTCATMEMBER *pCatMember);
extern BOOL     CatalogFreeAttribute(CRYPTCATATTRIBUTE *pCatMember);

extern void     *CatalogNew(DWORD cbSize);
extern BOOL     CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag);

extern BOOL     CatalogSaveP7UData(CRYPTCATSTORE *pCat);
extern BOOL     CatalogSaveP7SData(CRYPTCATSTORE *pCat, CTL_CONTEXT *pCTLContext);
extern BOOL     CatalogLoadFileData(CRYPTCATSTORE *pCat);


extern BOOL     CatalogEncodeNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                       PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeNameValue(CRYPTCATSTORE *pCatStore, PCRYPT_ATTRIBUTE pCryptAttr,
                                       CRYPTCATATTRIBUTE *pCatAttr);

extern BOOL     CatalogEncodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                        PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                        CRYPT_ATTRIBUTE *pAttr);
extern BOOL     CatalogReallyDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                              CRYPT_ATTR_BLOB *pAttr);

extern BOOL     CatalogEncodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                          PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                          CRYPT_ATTRIBUTE *pAttr);
extern BOOL     CatalogReallyDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                                CRYPT_ATTR_BLOB *pAttr);


extern BOOL     CatAdminDllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved);

extern void     CatalogCertExt2CryptAttr(CERT_EXTENSION *pCertExt, CRYPT_ATTRIBUTE *pCryptAttr);
extern void     CatalogCryptAttr2CertExt(CRYPT_ATTRIBUTE *pCryptAttr, CERT_EXTENSION *pCertExt);


LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember);

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);

VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);


#ifdef __cplusplus
}
#endif


#endif // MSCAT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\mscdfapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscdfapi.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATCDFOpen
//              CryptCATCDFClose
//              CryptCATCDFEnumMembers
//              CryptCATCDFEnumAttributes
//
//              *** local functions ***
//
//              CDFGetAttributes
//              CDFTextToGUID
//              CDFPositionAtGroupTag
//              CDFGetNextMember
//              CDFGetParam
//              CDFGetLine
//              CDFSplitAttrLine
//              CDFEOLOut
//              CDFCheckOID
//              CDFCalcIndirectData
//
//  History:    01-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <objbase.h>

#include    "mscat32.h"
#include    "sipguids.h"

void    CDFTextToGUID(LPWSTR pwszText, GUID *pgBin, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);
BOOL    CDFPositionAtGroupTag(CRYPTCATCDF *pCDF, LPWSTR pwszTag);
BOOL    CDFPositionAtLastMember(CRYPTCATCDF *pCDF);
BOOL    CDFGetNextMember(CRYPTCATCDF *pCDF, LPWSTR pwszMember, LPWSTR pwszLastMember);
BOOL    CDFGetParam(CRYPTCATCDF *pCDF, LPWSTR pwszGroup, LPWSTR pwszItem,
                    LPWSTR pwszDefault, LPWSTR *ppwszRet, LPWSTR pwszMemberTag);
DWORD   CDFGetLine(CRYPTCATCDF *pCDF, LPWSTR pwszLineBuf, DWORD dwMaxRead);
BOOL    CDFSplitAttrLine(LPWSTR pwszLine, DWORD *pdwType, LPWSTR *pwszOID,
                         LPWSTR *pwszValue, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);
void    CDFEOLOut(WCHAR *pwsz, DWORD ccLen);

BOOL    CDFCalcIndirectData(CRYPTCATCDF *pCDF, WCHAR *pwszFileName, GUID *pgSubjectType, DWORD *pcbIndirectData,
                            BYTE **pIndirectData, DWORD *pdwCertVersion, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

BOOL    CDFCheckOID(LPWSTR pwszOID, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

#define     MAX_CDF_LINE_LEN            512

#define     CAT_HEADER_TAG              L"[CatalogHeader]"
#define     CAT_HEADER_NAME_TAG         L"Name"
#define     CAT_HEADER_RESDIR_TAG       L"ResultDir"
#define     CAT_HEADER_VERSION_TAG      L"PublicVersion"
#define     CAT_HEADER_ENCODETYPE_TAG   L"EncodingType"
#define     CAT_HEADER_ATTR_TAG         L"CATATTR"

#define     CAT_MEMBER_TAG              L"[CatalogFiles]"
#define     CAT_MEMBER_ALTSIP_TAG       L"ALTSIPID"
#define     CAT_MEMBER_ATTR_TAG         L"ATTR"
#define     CAT_MEMBER_HASH_TAG         L"<HASH>"


/////////////////////////////////////////////////////////////////////////////
//
//  Exported Functions
//

CRYPTCATCDF * WINAPI CryptCATCDFOpen(LPWSTR pwszFilePath,
                                     PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    CRYPTCATCDF *pCDF;
    HANDLE      hFile;

    if (!(pwszFilePath))
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    if ((hFile = CreateFileU(pwszFilePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(NULL);
    }

    if (!(pCDF = (CRYPTCATCDF *)CatalogNew(sizeof(CRYPTCATCDF))))
    {
        return(NULL);
    }

    WCHAR       wszRetValue[MAX_CDF_LINE_LEN + 4];
    LPWSTR      pwsz;

    memset(pCDF, 0x00, sizeof(CRYPTCATCDF));

    pCDF->cbStruct  = sizeof(CRYPTCATCDF);
    pCDF->hFile     = hFile;

    //
    //  Name
    //
    if (pwsz = wcsrchr(pwszFilePath, L'\\'))
    {
        wcscpy(&wszRetValue[0], &pwsz[1]);
    }
    else
    {
        wcscpy(&wszRetValue[0], pwszFilePath);
    }

    LPWSTR      pwszStoreName;


    pwszStoreName = NULL;

    if (!(CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG)))
    {
        CloseHandle(hFile);

        delete pCDF;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_HEADER, CRYPTCAT_E_CDF_TAGNOTFOUND,  CAT_HEADER_TAG);
        }

        return(NULL);
    }

    if (!(CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_NAME_TAG, &wszRetValue[0], &pwszStoreName, NULL)))
    {
        DELETE_OBJECT(pwszStoreName);

        CloseHandle(hFile);

        delete pCDF;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_HEADER, CRYPTCAT_E_CDF_TAGNOTFOUND,  CAT_HEADER_TAG);
        }

        return(NULL);
    }

    //
    //  ResultDir
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_RESDIR_TAG, NULL, &pCDF->pwszResultDir, NULL);

    //
    //  actual file
    //
    DWORD  cw;
    LPWSTR pwszFile = NULL;

    cw = wcslen( pwszStoreName );
    if ( pCDF->pwszResultDir != NULL )
    {
        cw += wcslen( pCDF->pwszResultDir );
    }
    cw += wcslen( CRYPTCAT_FILEEXT );
    cw += 2;

    pwszFile = new WCHAR [ cw ];
    if ( pwszFile == NULL )
    {
        DELETE_OBJECT(pwszStoreName);

        CloseHandle(hFile);

        delete pCDF;

        return( NULL );
    }

    pwszFile[ 0 ] = L'\0';

    if (pCDF->pwszResultDir)
    {
        wcscpy(pwszFile, pCDF->pwszResultDir);

        if (pCDF->pwszResultDir[wcslen(pCDF->pwszResultDir) - 1] != L'\\')
        {
            wcscat(pwszFile, L"\\");
        }
    }

    wcscat(pwszFile, pwszStoreName);

    if (!(wcsrchr(pwszFile, '.')))
    {
        wcscat(pwszFile, L".");
        wcscat(pwszFile, CRYPTCAT_FILEEXT);
    }


    DWORD   dwPublicVersion;
    DWORD   dwEncodingType;

    //
    //  PublicVersion
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    wcscpy(&wszRetValue[0], L"0x00000001");
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_VERSION_TAG, &wszRetValue[0], &pwsz, NULL);
    if (pwsz)
    {
        dwPublicVersion = wcstol(pwsz, NULL, 16);
        delete pwsz;
    }

    //
    //  EncodingType
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    wcscpy(&wszRetValue[0], L"0x00010001");   // PKCS_7_ASN_ENCODING | X509_ASN_ENCODING
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_ENCODETYPE_TAG, &wszRetValue[0], &pwsz, NULL);
    if (pwsz)
    {
        dwEncodingType = wcstol(pwsz, NULL, 16);
        delete pwsz;
    }

    pCDF->hCATStore = CryptCATOpen(pwszFile, CRYPTCAT_OPEN_CREATENEW, NULL, dwPublicVersion, dwEncodingType);

    delete pwszStoreName;
    delete pwszFile;

    if ((pCDF->hCATStore == INVALID_HANDLE_VALUE) ||
        (!(pCDF->hCATStore)))
    {
        CryptCATCDFClose(pCDF);
        pCDF = NULL;
    }

    return(pCDF);
}

BOOL WINAPI CryptCATCDFClose(CRYPTCATCDF *pCDF)
{
    BOOL    fRet;

    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    fRet = TRUE;

    if ((pCDF->hFile) && (pCDF->hFile != INVALID_HANDLE_VALUE))
    {
        fRet &= CloseHandle(pCDF->hFile);
    }

    if ((pCDF->hCATStore) && (pCDF->hCATStore != INVALID_HANDLE_VALUE))
    {
        fRet &= CatalogSaveP7UData((CRYPTCATSTORE *)pCDF->hCATStore);

        fRet &= CryptCATClose(pCDF->hCATStore);
    }

    DELETE_OBJECT(pCDF->pwszResultDir);

    delete pCDF;

    return(fRet);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumCatAttributes(CRYPTCATCDF *pCDF,
                                                        CRYPTCATATTRIBUTE *pPrevAttr,
                                                        PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    wcscpy(&wszRetValue[0], CAT_HEADER_ATTR_TAG);
    wcscat(&wszRetValue[0], _itow(iAttr, &wszTemp[0], 10));

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    if (CDFGetParam(pCDF, CAT_HEADER_TAG, &wszRetValue[0], NULL, &pwsz, NULL))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutCatAttrInfo(pCDF->hCATStore, pwszOID, dwType,
                                                    (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                    (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

CRYPTCATMEMBER * WINAPI CryptCATCDFEnumMembers(CRYPTCATCDF *pCDF, CRYPTCATMEMBER *pPrevMember,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    LPWSTR  pwszLastTag;
    BOOL    fFoundLastTag;

    pwszLastTag = NULL;

    if (pPrevMember)
    {
        if (pPrevMember->cbStruct != sizeof(CRYPTCATMEMBER))
        {
            SetLastError(ERROR_INVALID_PARAMETER);

            return(NULL);
        }

        if (pPrevMember->pwszReferenceTag)
        {
            if (!(pwszLastTag = (LPWSTR)CatalogNew(wcslen(pPrevMember->pwszReferenceTag) *
                                                   sizeof(WCHAR) + 4)))
            {
                return(NULL);
            }

            wcscpy(pwszLastTag, pPrevMember->pwszReferenceTag);
        }
    }

    if (!(pCDF) ||
        (pCDF->hFile == INVALID_HANDLE_VALUE) ||
        !(pCDF->hFile))
    {
        DELETE_OBJECT(pwszLastTag);

        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];

    CDFPositionAtLastMember(pCDF);

    if (CDFGetNextMember(pCDF, &wszRetValue[0], pwszLastTag))
    {
        LPWSTR  pwsz;

        DELETE_OBJECT(pwszLastTag);

        //
        //  file path/name (required!)
        //
        CDFPositionAtLastMember(pCDF);
        if (!(CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, &wszRetValue[0])))
        {
            if (pfnParseError)
            {
                pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILE_PATH,
                                &wszRetValue[0]);
            }
        }
        else
        {
            CRYPTCATMEMBER      *pMember;
            WCHAR               *pwszFileName;
            WCHAR               *pwszReferenceTag;
            GUID                gSubjectType;
            HANDLE              hFile;

            //
            //  file path/name
            //
            pwszFileName    = pwsz;
            // remember: don't delete pwsz this time!

            if ((hFile = CreateFileU(pwszFileName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE)
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND,
                                    pwszFileName);
                }

                DELETE_OBJECT(pwszFileName);

                return(NULL);
            }

            CloseHandle(hFile);

            //
            //  reference tag
            //
            if (!(pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(&wszRetValue[0]) + 1) * sizeof(WCHAR))))
            {
                delete pwszFileName;

                return(NULL);
            }

            wcscpy(pwszReferenceTag, &wszRetValue[0]);

            //
            //  Alt SIP GUID
            //
            wcscpy(&wszRetValue[0], pwszReferenceTag);
            wcscat(&wszRetValue[0], CAT_MEMBER_ALTSIP_TAG);

            CDFPositionAtLastMember(pCDF);
            CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszReferenceTag);

            if (pwsz)
            {
                CDFTextToGUID(pwsz, &gSubjectType, pfnParseError);

                DELETE_OBJECT(pwszFileName);

                DELETE_OBJECT(pwsz);
            }
            else
            {
                if (!(CryptSIPRetrieveSubjectGuidForCatalogFile(pwszFileName, NULL, &gSubjectType)))
                {
                    return(NULL);
                }
            }

            //
            //  Indirect Data
            //
            BYTE                *pbIndirectData;
            DWORD               cbIndirectData;
            DWORD               dwCertVersion;

            if (!(CDFCalcIndirectData(pCDF, pwszFileName, &gSubjectType, &cbIndirectData, &pbIndirectData,
                                        &dwCertVersion, pfnParseError)))
            {
                DELETE_OBJECT(pwszReferenceTag);
                DELETE_OBJECT(pwszFileName);

                return(NULL);
            }

            pMember = CryptCATPutMemberInfo(pCDF->hCATStore,
                                            pwszFileName,
                                            pwszReferenceTag,
                                            &gSubjectType,
                                            dwCertVersion,
                                            cbIndirectData,
                                            pbIndirectData);

            if (!(pMember) && (GetLastError() == CRYPT_E_EXISTS))
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_DUPLICATE,
                                    pwszReferenceTag);
                }
            }

            DELETE_OBJECT(pbIndirectData);

            //
            //  Done!
            //

            DELETE_OBJECT(pwszReferenceTag);
            DELETE_OBJECT(pwszFileName);

            return(pMember);
        }
    }

    DELETE_OBJECT(pwszLastTag);

    return(NULL);
}

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved)
{
    LPWSTR  pwszLastTag;
    BOOL    fFoundLastTag;

    pwszLastTag = pwszPrevCDFTag;

    if (!(pCDF) ||
        (pCDF->hFile == INVALID_HANDLE_VALUE) ||
        !(pCDF->hFile))
    {
        DELETE_OBJECT(pwszLastTag);

        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];

    CDFPositionAtLastMember(pCDF);

    if (CDFGetNextMember(pCDF, &wszRetValue[0], pwszLastTag))
    {
        LPWSTR  pwsz;

        DELETE_OBJECT(pwszLastTag);

        //
        //  file path/name (required!)
        //
        CDFPositionAtLastMember(pCDF);
        if (!(CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, &wszRetValue[0])))
        {
            if (pfnParseError)
            {
                pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILE_PATH,
                                &wszRetValue[0]);
            }
        }
        else
        {
            CRYPTCATMEMBER      *pMember;
            WCHAR               *pwszFileName;
            WCHAR               *pwszReferenceTag;
            GUID                gSubjectType;
            HANDLE              hFile;

            //
            //  reference tag
            //
            if (!(pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(&wszRetValue[0]) + 1) * sizeof(WCHAR))))
            {
                return(NULL);
            }

            wcscpy(pwszReferenceTag, &wszRetValue[0]);

            //
            //  file path/name
            //
            pwszFileName    = pwsz;
            // remember: don't delete pwsz this time!

            if ((hFile = CreateFileU(pwszFileName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE)
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND,
                                    pwszFileName);
                }

                DELETE_OBJECT(pwszFileName);

                if ( fContinueOnError == FALSE )
                {
                    DELETE_OBJECT(pwszReferenceTag);
                    pwszReferenceTag = NULL;
                }

                return(pwszReferenceTag);
            }

            CloseHandle(hFile);

            //
            //  Alt SIP GUID
            //
            wcscpy(&wszRetValue[0], pwszReferenceTag);
            wcscat(&wszRetValue[0], CAT_MEMBER_ALTSIP_TAG);

            CDFPositionAtLastMember(pCDF);
            CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszReferenceTag);

            if (pwsz)
            {
                CDFTextToGUID(pwsz, &gSubjectType, pfnParseError);

                DELETE_OBJECT(pwszFileName);

                DELETE_OBJECT(pwsz);
            }
            else
            {
                if (!(CryptSIPRetrieveSubjectGuidForCatalogFile(pwszFileName, NULL, &gSubjectType)))
                {
                    return(NULL);
                }
            }

            //
            //  Indirect Data
            //
            BYTE                *pbIndirectData;
            DWORD               cbIndirectData;
            DWORD               dwCertVersion;
            SIP_INDIRECT_DATA*  pIndirectData;
            LPWSTR              pwszTagToPut;
            BOOL                fHashTagUsed = FALSE;

            if (!(CDFCalcIndirectData(pCDF, pwszFileName, &gSubjectType, &cbIndirectData, &pbIndirectData,
                                        &dwCertVersion, pfnParseError)))
            {
                DELETE_OBJECT(pwszFileName);

                if ( fContinueOnError == FALSE )
                {
                    DELETE_OBJECT(pwszReferenceTag);
                    pwszReferenceTag = NULL;
                }

                return(pwszReferenceTag);
            }

            pIndirectData = (SIP_INDIRECT_DATA *)pbIndirectData;
            pwszTagToPut = pwszReferenceTag;

            if (_wcsnicmp(pwszReferenceTag, CAT_MEMBER_HASH_TAG, wcslen(CAT_MEMBER_HASH_TAG)) == 0)
            {
                fHashTagUsed = TRUE;

                if (MsCatConstructHashTag(
                         pIndirectData->Digest.cbData,
                         pIndirectData->Digest.pbData,
                         &pwszTagToPut
                         ) == FALSE)
                {
                    DELETE_OBJECT(pwszFileName);

                    if ( fContinueOnError == FALSE )
                    {
                        DELETE_OBJECT(pwszReferenceTag);
                        pwszReferenceTag = NULL;
                    }

                    return(pwszReferenceTag);
                }
            }

            pMember = CryptCATPutMemberInfo(pCDF->hCATStore,
                                            pwszFileName,
                                            pwszTagToPut,
                                            &gSubjectType,
                                            dwCertVersion,
                                            cbIndirectData,
                                            pbIndirectData);

            if (!(pMember) && (GetLastError() == CRYPT_E_EXISTS))
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_DUPLICATE,
                                    pwszReferenceTag);
                }
            }

            DELETE_OBJECT(pbIndirectData);

            //
            //  Done!
            //

            if ( fHashTagUsed == TRUE )
            {
                MsCatFreeHashTag(pwszTagToPut);
            }

            DELETE_OBJECT(pwszFileName);

            *ppMember = pMember;

            return(pwszReferenceTag);
        }
    }

    DELETE_OBJECT(pwszLastTag);

    return(NULL);
}

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember)
{
    return(CryptCATCDFEnumMembersByCDFTagEx(pCDF, pwszPrevCDFTag, pfnParseError, ppMember, FALSE, NULL));
}

BOOL CDFCalcIndirectData(CRYPTCATCDF *pCDF, WCHAR *pwszFileName, GUID *pgSubjectType, DWORD *pcbIndirectData,
                         BYTE **ppbIndirectData, DWORD *pdwCertVersion, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    SIP_SUBJECTINFO     sSubjInfo;
    SIP_DISPATCH_INFO   sSip;
    CRYPTCATSTORE       *pCatStore;

    *pcbIndirectData    = 0;
    *ppbIndirectData    = NULL;

    pCatStore = (CRYPTCATSTORE *)pCDF->hCATStore;

    memset(&sSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));
    memset(&sSip,      0x00, sizeof(SIP_DISPATCH_INFO));

    sSubjInfo.cbSize                    = sizeof(SIP_SUBJECTINFO);

    sSubjInfo.hProv                     = pCatStore ->hProv;
    sSubjInfo.DigestAlgorithm.pszObjId  = (char *)CertAlgIdToOID(CALG_SHA1);
    sSubjInfo.dwFlags                   = SPC_INC_PE_RESOURCES_FLAG | SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                                          MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;
    sSubjInfo.dwEncodingType            = pCatStore->dwEncodingType;

    sSubjInfo.pgSubjectType             = pgSubjectType;
    sSubjInfo.pwsFileName               = pwszFileName;


    if (!(CryptSIPLoad(pgSubjectType, 0, &sSip)))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    sSip.pfCreate(&sSubjInfo,
                  pcbIndirectData,
                  NULL);

    if (*pcbIndirectData < 1)
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    if (!(*ppbIndirectData = (BYTE *)CatalogNew(*pcbIndirectData)))
    {
        *pcbIndirectData = 0;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    if (!(sSip.pfCreate(&sSubjInfo,
                        pcbIndirectData,
                        (SIP_INDIRECT_DATA *)*ppbIndirectData)))
    {
        DELETE_OBJECT(*ppbIndirectData);

        *pcbIndirectData = 0;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    *pdwCertVersion = sSubjInfo.dwIntVersion;

    return(TRUE);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributes(CRYPTCATCDF *pCDF, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)) ||
        !(pMember) ||
        (pMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    wcscpy(&wszRetValue[0], pMember->pwszReferenceTag);
    wcscat(&wszRetValue[0], L"ATTR");
    wcscat(&wszRetValue[0], _itow(iAttr, &wszTemp[0], 10));

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtLastMember(pCDF);
    if (CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pMember->pwszReferenceTag))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutAttrInfo(pCDF->hCATStore, pMember, pwszOID, dwType,
                                                (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)) ||
        !(pwszMemberTag) ||
        !(pMember) ||
        (pMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    wcscpy(&wszRetValue[0], pwszMemberTag);
    wcscat(&wszRetValue[0], L"ATTR");
    wcscat(&wszRetValue[0], _itow(iAttr, &wszTemp[0], 10));

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtLastMember(pCDF);
    if (CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszMemberTag))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutAttrInfo(pCDF->hCATStore, pMember, pwszOID, dwType,
                                                (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

/////////////////////////////////////////////////////////////////////////////
//
//  Local Functions
//

BOOL CDFCheckOID(LPWSTR pwszOID, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    DWORD   cbConv;
    char    *pszOID;

    cbConv = WideCharToMultiByte(0, 0,
                                pwszOID, wcslen(pwszOID),
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO, pwszOID);
        }
        return(FALSE);
    }

    if (!(pszOID = (LPSTR)CatalogNew(cbConv)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pwszOID, wcslen(pwszOID),
                        pszOID, cbConv, NULL, NULL);

    DWORD   i;
    BOOL    fRet;

    fRet    = TRUE;
    i       = 0;

    while (i < cbConv)
    {
        if (((pszOID[i] < '0') || (pszOID[i] > '9')) &&
            (pszOID[i] != '.'))
        {
            fRet = FALSE;
            break;
        }

        i++;
    }

    delete pszOID;

    if (!(fRet))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO, pwszOID);
        }
    }

    return(fRet);

}

BOOL CDFSplitAttrLine(LPWSTR pwszLine, DWORD *pdwType, LPWSTR *ppwszOID, LPWSTR *ppwszValue,
                      PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    LPWSTR  pwszColon;
    LPWSTR  pwszStart;
    LPWSTR  pwsz;

    *pdwType    = 0;
    *ppwszValue = NULL;
    *ppwszOID   = NULL;

    if (!(pwsz = (WCHAR *)CatalogNew((wcslen(pwszLine) + 1) * sizeof(WCHAR))))
    {
        return(FALSE);
    }

    wcscpy(pwsz, pwszLine);

    pwszStart   = pwszLine;
    //
    //  first one is type
    //
    if (!(pwszColon = wcschr(pwszStart, L':')))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    *pwszColon  = NULL;
    *pdwType    = wcstol(pwszStart, NULL, 16);

    pwszStart   = &pwszColon[1];

    //
    //  next, oid/name
    //
    if (!(pwszColon = wcschr(pwszStart, L':')))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    *pwszColon  = NULL;
    *ppwszOID   = pwszStart;

    pwszStart   = &pwszColon[1];

    //
    //  next, value
    //
    if (!(pwszStart[0]))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    delete pwsz;

    *ppwszValue = pwszStart;

    return(TRUE);
}

void CDFTextToGUID(LPWSTR pwszText, GUID *pgBin, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    WCHAR   wszGuid[256];
    GUID    gTemp;

    memset(pgBin, 0x00, sizeof(GUID));

    if ((pwszText[0] != L'[') &&
        (pwszText[0] != L'{'))
    {
        wcscpy(&wszGuid[0], L"{");
        wcscat(&wszGuid[0], pwszText);
        wcscat(&wszGuid[0], L"}");
    }
    else
    {
        wcscpy(&wszGuid[0], pwszText);
    }

    if (!(wstr2guid(&wszGuid[0], pgBin)))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_BAD_GUID_CONV, &wszGuid[0]);
        }
    }
}

BOOL CDFPositionAtGroupTag(CRYPTCATCDF *pCDF, LPWSTR pwszTag)
{
    if (SetFilePointer(pCDF->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    WCHAR       wszRetValue[MAX_CDF_LINE_LEN + 4];
    DWORD       ccRet;

    while ((ccRet = CDFGetLine(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszRetValue[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszRetValue[0], ccRet);

        if (wszRetValue[0] == L'[')
        {
            if (_memicmp(&wszRetValue[0], pwszTag, wcslen(pwszTag) * sizeof(WCHAR)) == 0)
            {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOL CDFPositionAtLastMember(CRYPTCATCDF *pCDF)
{
    if (pCDF->dwLastMemberOffset == 0)
    {
        return(CDFPositionAtGroupTag(pCDF, CAT_MEMBER_TAG));
    }
    else if (SetFilePointer(pCDF->hFile, pCDF->dwLastMemberOffset,
                                            NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CDFGetNextMember(CRYPTCATCDF *pCDF, LPWSTR pwszMember, LPWSTR pwszLastMember)
{
    WCHAR   wszLine[MAX_CDF_LINE_LEN + 4];
    WCHAR   wszCheck[MAX_CDF_LINE_LEN + 1];
    LPWSTR  pwszEqual;
    DWORD   ccRet;
    DWORD   ccLastMember;
    BOOL    fFoundLast;

    if (pwszLastMember)
    {
        wcscpy(&wszCheck[0], pwszLastMember);

        ccLastMember = wcslen(&wszCheck[0]);
    }

    fFoundLast = FALSE;

    while ((ccRet = CDFGetLine(pCDF, &wszLine[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszLine[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszLine[0], ccRet);

        if (wszLine[0] == L'[')
        {
            return(FALSE);
        }

        if (!(pwszEqual = wcschr(&wszLine[0], L'=')))
        {
            continue;
        }

        *pwszEqual = NULL;

        if (pwszLastMember)
        {
            if (fFoundLast)
            {
                //
                //  before we make the determination that we are in fact on a
                //  different member tag, make sure that we aren't just on the
                //  same tag's ALTSIP or ATTRx!!!
                //
                wcscpy(&wszCheck[ccLastMember], CAT_MEMBER_ALTSIP_TAG);
                if (_memicmp(&wszLine[0], &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0)
                {
                    continue;
                }

                wcscpy(&wszCheck[ccLastMember], CAT_MEMBER_ATTR_TAG);
                if (_memicmp(&wszLine[0], &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0)
                {
                    continue;
                }

                if (_wcsicmp(&wszLine[0], pwszLastMember) != 0)
                {
                    wcscpy(pwszMember, &wszLine[0]);

                    //
                    //  remember the position of the last entry for this member
                    //
                    *pwszEqual = L'=';
                    pCDF->dwLastMemberOffset    = pCDF->dwCurFilePos - wcslen(&wszLine[0]);

                    return(TRUE);
                }
            }
            else if (_wcsicmp(&wszLine[0], pwszLastMember) == 0)
            {
                fFoundLast = TRUE;
            }

            continue;
        }

        wcscpy(pwszMember, &wszLine[0]);

        //
        //  remember the position of the last entry for this member
        //
        *pwszEqual = L'=';
        pCDF->dwLastMemberOffset    = pCDF->dwCurFilePos - wcslen(&wszLine[0]);

        return(TRUE);
    }

    return(FALSE);
}

BOOL CDFGetParam(CRYPTCATCDF *pCDF, LPWSTR pwszGroup, LPWSTR pwszItem, LPWSTR pwszDefault, LPWSTR *ppwszRet,
                 LPWSTR pwszMemberTag)
{
    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];
    DWORD   ccRet;
    WCHAR   *pwsz;

    while ((ccRet = CDFGetLine(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszRetValue[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszRetValue[0], ccRet);

        if (wszRetValue[0] == L'[')
        {
            break;
        }

        if (pwsz = wcschr(&wszRetValue[0], L'='))
        {
            //
            //  if we have a member tag and we are past it, get out!
            //
            if (pwszMemberTag)
            {
                if (_memicmp(&wszRetValue[0], pwszMemberTag, wcslen(pwszMemberTag) * sizeof(WCHAR)) != 0)
                {
                    break;
                }
            }

            *pwsz = NULL;

            if (_memicmp(&wszRetValue[0], pwszItem, wcslen(pwszItem) * sizeof(WCHAR)) == 0)
            {
                if (wcslen(&pwsz[1]) < 1)
                {
                    break;
                }

                if (*ppwszRet = (LPWSTR)CatalogNew((wcslen(&pwsz[1]) + 1) * sizeof(WCHAR)))
                {
                    wcscpy(*ppwszRet, &pwsz[1]);

                    return(TRUE);
                }

                return(FALSE);
            }
        }
    }

    if (pwszDefault)
    {
        if (*ppwszRet = (LPWSTR)CatalogNew((wcslen(pwszDefault) + 1) * sizeof(WCHAR)))
        {
            wcscpy(*ppwszRet, pwszDefault);

            return(TRUE);
        }
    }

    *ppwszRet = NULL;

    return(FALSE);
}

DWORD CDFGetLine(CRYPTCATCDF *pCDF, LPWSTR pwszLineBuf, DWORD cbMaxRead)
{
    DWORD   dwHold;
    DWORD   cbRead;
    DWORD   cwbRead;
    DWORD   dw;
    int     iAmt;
    BYTE    *pb;

    if ((dwHold = SetFilePointer(pCDF->hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    if (!(pb = (BYTE *)CatalogNew(cbMaxRead + 2)))
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(pCDF->hFile, pb, cbMaxRead, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            pCDF->fEOF = TRUE;
            delete pb;
            return(0);
        }

        pb[cbRead] = 0x00;
        pCDF->fEOF = FALSE;

        if (cbRead > 0)
        {
            iAmt = 0;
            for (dw = 0; dw < (cbRead - 1); dw++)
            {
                if ((pb[dw] == 0x0d) || (pb[dw] == 0x0a))
                {
                    iAmt++;
                    if (pb[dw + 1] == 0x0a)
                    {
                        dw++;
                        iAmt++;
                    }

                    if (SetFilePointer(pCDF->hFile, dwHold + (dw + 1),
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        pCDF->dwCurFilePos = 0;
                    }
                    else
                    {
                        pCDF->dwCurFilePos = SetFilePointer(pCDF->hFile, 0, NULL, FILE_CURRENT) - iAmt;
                    }

                    pb[dw + 1] = 0x00;

                    cwbRead = MultiByteToWideChar(
                                    CP_ACP, 
                                    0, 
                                    (const char *)pb, 
                                    -1,
                                    pwszLineBuf, 
                                    cbMaxRead / sizeof(WCHAR));

                    delete pb;

                    return(cwbRead + 1);
                }
            }
        }
    }
    else
    {
        delete pb;

        return(0);
    }

    if (pb[cbRead - 1] == 0x1a)  /* EOF */
    {
        cbRead--;
        pCDF->dwCurFilePos  = 0;
        pCDF->fEOF          = TRUE;
    }
    else
    {
        pCDF->dwCurFilePos = dwHold;
    }

    pb[cbRead] = 0x00;

    cwbRead = MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    (const char *)pb, 
                    -1,
                    pwszLineBuf, 
                    cbMaxRead / sizeof(WCHAR));

    delete pb;

    return(cwbRead);
}

void CDFEOLOut(WCHAR *pwsz, DWORD ccLen)
{
        DWORD   i;

        for (i = 0; i < ccLen; i++)
        {
                if ((pwsz[i] == (WCHAR)0x0a) || (pwsz[i] == (WCHAR)0x0d))
                {
                        pwsz[i] = NULL;
                        return;
                }
        }
        pwsz[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mscat32\nameval.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       NameVal.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogEncodeNameValue
//              CatalogDecodeNameValue
//              CatalogCertExt2CryptAttr
//              CatalogCryptAttr2CertExt
//
//              *** local functions ***
//              EncodeUserOID
//              DecodeUserOID
//
//  History:    16-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"


BOOL EncodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNameValue);
BOOL DecodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNV, BYTE **ppbUserOIDDecode, 
                   DWORD *pcbUserOIDDecode);

void CatalogCertExt2CryptAttr(CERT_EXTENSION *pCertExt, CRYPT_ATTRIBUTE *pCryptAttr)
{
    memset(pCryptAttr, 0x00, sizeof(CRYPT_ATTRIBUTE));

    pCryptAttr->pszObjId    = pCertExt->pszObjId;
    pCryptAttr->cValue      = 1;
    pCryptAttr->rgValue     = &pCertExt->Value;
}

void CatalogCryptAttr2CertExt(CRYPT_ATTRIBUTE *pCryptAttr, CERT_EXTENSION *pCertExt)
{
    memset(pCertExt, 0x00, sizeof(CERT_EXTENSION));

    pCertExt->pszObjId      = pCryptAttr->pszObjId;
    pCertExt->fCritical     = FALSE;

    if ((pCryptAttr->cValue) && (pCryptAttr->rgValue))
    {
        memcpy(&pCertExt->Value, &pCryptAttr->rgValue[0], sizeof(CRYPT_ATTR_BLOB));
    }
}

BOOL CatalogEncodeNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, 
                            PCRYPT_ATTRIBUTE pCryptAttr)
{
    CAT_NAMEVALUE   sNV;

    memset(&sNV, 0x00, sizeof(CAT_NAMEVALUE));

    sNV.pwszTag         = pAttr->pwszReferenceTag;
    sNV.fdwFlags        = pAttr->dwAttrTypeAndAction;
    sNV.Value.cbData    = pAttr->cbValue;

    if (!(sNV.Value.pbData = (BYTE *)CatalogNew(sNV.Value.cbData)))
    {
        return(FALSE);
    }

    memcpy(sNV.Value.pbData, pAttr->pbValue, sNV.Value.cbData);

    if (pAttr->dwAttrTypeAndAction & CRYPTCAT_ATTR_NAMEOBJID)
    {
        if (!(EncodeUserOID(pCatStore, &sNV)))
        {
            delete sNV.Value.pbData;

            return(FALSE);
        }
    }

    pCryptAttr->pszObjId = CAT_NAMEVALUE_OBJID;

    pCryptAttr->rgValue->cbData = 0;

    CryptEncodeObject(pCatStore->dwEncodingType,
                      pCryptAttr->pszObjId,
                      &sNV,
                      NULL,
                      &pCryptAttr->rgValue->cbData);

    if (pCryptAttr->rgValue->cbData > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(pCryptAttr->rgValue->cbData)))
        {
            delete sNV.Value.pbData;

            return(FALSE);
        }

        if (!(CryptEncodeObject(pCatStore->dwEncodingType,
                                pCryptAttr->pszObjId,
                                &sNV,
                                pCryptAttr->rgValue->pbData,
                                &pCryptAttr->rgValue->cbData)))
        {
            delete sNV.Value.pbData;

            DELETE_OBJECT(pCryptAttr->rgValue->pbData);

            pCryptAttr->rgValue->cbData = 0;

            return(FALSE);
        }

        delete sNV.Value.pbData;

        return(TRUE);
    }

    delete sNV.Value.pbData;

    return(FALSE);
}

BOOL CatalogDecodeNameValue(CRYPTCATSTORE *pCatStore, PCRYPT_ATTRIBUTE pCryptAttr,
                            CRYPTCATATTRIBUTE *pCatAttr)
{
    CAT_NAMEVALUE   *pNV;
    DWORD           cbDecoded;

    cbDecoded   = 0;


    CryptDecodeObject(  pCatStore->dwEncodingType,
                        CAT_NAMEVALUE_STRUCT,
                        pCryptAttr->rgValue->pbData,
                        pCryptAttr->rgValue->cbData,
                        0,
                        NULL,
                        &cbDecoded);

    if (cbDecoded > 0)
    {
        if (!(pNV = (CAT_NAMEVALUE *)CatalogNew(cbDecoded)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(    pCatStore->dwEncodingType,
                                    CAT_NAMEVALUE_STRUCT,
                                    pCryptAttr->rgValue->pbData,
                                    pCryptAttr->rgValue->cbData,
                                    0,
                                    pNV,
                                    &cbDecoded)))
        {
            delete pNV;

            return(FALSE);
        }

        if (!(pCatAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pNV->pwszTag) + 1) * sizeof(WCHAR))))
        {
            delete pNV;

            return(FALSE);
        }
        wcscpy(pCatAttr->pwszReferenceTag, pNV->pwszTag);

        pCatAttr->dwAttrTypeAndAction = pNV->fdwFlags;

        if (pCatAttr->dwAttrTypeAndAction & CRYPTCAT_ATTR_NAMEOBJID)
        {
            DWORD   cbUserOIDDecode;
            BYTE    *pbUserOIDDecode;

            if (!(DecodeUserOID(pCatStore, pNV, &pbUserOIDDecode, &cbUserOIDDecode)))
            {
                delete pNV;

                return(FALSE);
            }

            delete pNV;

            pCatAttr->pbValue = pbUserOIDDecode;
            pCatAttr->cbValue = cbUserOIDDecode;

            return(TRUE);
        }

        if (!(pCatAttr->pbValue = (BYTE *)CatalogNew(pNV->Value.cbData)))
        {
            delete pNV;

            return(FALSE);
        }

        memcpy(pCatAttr->pbValue, pNV->Value.pbData, pNV->Value.cbData);
        pCatAttr->cbValue = pNV->Value.cbData;

        delete pNV;

        return(TRUE);
    }

    return(FALSE);
}

BOOL EncodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNameValue)
{
    DWORD   cbEncoded;
    BYTE    *pbEncoded;
    DWORD   cbConv;
    LPSTR   pszObjId;

    pbEncoded           = NULL;

    cbConv = WideCharToMultiByte(0, 0,
                                pNameValue->pwszTag, wcslen(pNameValue->pwszTag) + 1,
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        return(FALSE);
    }

    if (!(pszObjId = (LPSTR)CatalogNew(cbConv + 1)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pNameValue->pwszTag, wcslen(pNameValue->pwszTag) + 1,
                        pszObjId, cbConv, NULL, NULL);

    pszObjId[cbConv] = NULL;

    cbEncoded = 0;

    CryptEncodeObject(pCatStore->dwEncodingType,
                      pszObjId,
                      pNameValue->Value.pbData,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pbEncoded = (BYTE *)CatalogNew(cbEncoded)))
        {
            delete pszObjId;

            return(FALSE);
        }

        if (!(CryptEncodeObject(pCatStore->dwEncodingType,
                                pszObjId,
                                pNameValue->Value.pbData,
                                pbEncoded,
                                &cbEncoded)))
        {
            delete pszObjId;

            delete pbEncoded;

            return(FALSE);
        }
    }

    delete pszObjId;

    DELETE_OBJECT(pNameValue->Value.pbData);

    pNameValue->Value.pbData    = pbEncoded;
    pNameValue->Value.cbData    = cbEncoded;

    return(TRUE);
    
}

BOOL DecodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNV, BYTE **ppbUserOIDDecode, 
                   DWORD *pcbUserOIDDecode)
{
    *ppbUserOIDDecode   = NULL;
    *pcbUserOIDDecode   = 0;

    DWORD   cbConv;
    LPSTR   pszObjId;

    cbConv = WideCharToMultiByte(0, 0,
                                pNV->pwszTag, wcslen(pNV->pwszTag) + 1,
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        return(FALSE);
    }

    if (!(pszObjId = (LPSTR)CatalogNew(cbConv + 1)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pNV->pwszTag, wcslen(pNV->pwszTag) + 1,
                        pszObjId, cbConv, NULL, NULL);

    pszObjId[cbConv] = NULL;

    CryptDecodeObject(pCatStore->dwEncodingType,
                      pszObjId,
                      pNV->Value.pbData,
                      pNV->Value.cbData,
                      0,
                      NULL,
                      pcbUserOIDDecode);

    if (*pcbUserOIDDecode > 0)
    {
        if (!(*ppbUserOIDDecode = (BYTE *)CatalogNew(*pcbUserOIDDecode)))
        {
            delete pszObjId;

            return(FALSE);
        }

        if (!(CryptDecodeObject(pCatStore->dwEncodingType,
                                pszObjId,
                                pNV->Value.pbData,
                                pNV->Value.cbData,
                                0,
                                *ppbUserOIDDecode,
                                pcbUserOIDDecode)))
        {
            delete pszObjId;

            DELETE_OBJECT(*ppbUserOIDDecode);
            *pcbUserOIDDecode = 0;

            return(FALSE);
        }

        return(TRUE);
    }

    delete pszObjId;

    return(FALSE);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\cabinet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cabinet.h
//
//--------------------------------------------------------------------------

/***    cabinet.h - Definitions for Cabinet File structure
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      15-Aug-1993 bens        Initial version
 *      05-Sep-1993 bens        Added Overview section
 *      29-Nov-1993 chuckst     Added disk names to folder first & next
 *                              Used "CF" consistently
 *                              Eliminated redundant cch fields
 *      09-Feb-1994 chuckst     merged in some related global constants
 *      09-Mar-1994 bens        Add RESERVE defintions (for encryption)
 *      17-Mar-1994 bens        Improve comments about split CFDATA structures
 *      25-Mar-1994 bens        Add cabinet set ID
 *      13-May-1994 bens        Define bad value for iCabinet
 *      15-Jun-1997 pberkman    added CABSignatureStruct_
 *
 *  Overview:
 *      This file contains definitions for the Diamond Cabinet File format.
 *      A Cabinet File exists to store one or more files.  Usually these
 *      files have been compressed, but that is not required.  It is also
 *      possible for a cabinet file to contain only a portion of a larger
 *      file.
 *
 *      In designing this format, the following goals where achieved:
 *      1) Minimize overhead in the CF format
 *         ==> Where ever possible BYTEs or USHORTs were used, rather
 *             than using LONGs, even though the latter would be easier
 *             to manipulate on certain RISC platforms.
 *      2) Support little-endian and big-endian byte ordering.
 *         ==> For simplicity on x86 systems, multi-byte numbers are
 *             stored in a little-endian form, but the code to read and
 *             write these numbers operates correctly on either type of
 *             computer.
 *
 *      A cabinet file contains the following structures in the following
 *      order:
 *          Name            Description
 *          -----------     -------------------
 *          CFHEADER        Cabinet description
 *            [CFRESERVE]   Optional RESERVED control information in CFHEADER
 *          CFFOLDER(s)     Folder descriptions
 *            [reserved]    Optional RESERVED data per folder
 *          CFFILE(s)       File descriptions
 *          CFDATA(s)       Data blocks
 *            [reserved]    Optional RESERVED data per data block
 *
 *  Data Integrity Strategy:
 *      The Cabinet File has built-in data integrity checks, since it is
 *      possible for customers to have damaged diskettes, or for accidental
 *      or malicious damage to occur.  Rather than doing an individual
 *      checksum for the entire cabinet file (which would have a dramatic
 *      impact on the speed of installation from floppy disk, since the
 *      entire file would need to be read), we have per-component
 *      checksums, and compute and check them as we read the various
 *      components of the file.
 *
 *      1)  Checksum CFHEADER
 *      2)  Store cabinet file length in CFHEADER (to detect file truncation)
 *      3)  Checksum entire set of CFFOLDER structures
 *      4)  Checksum entire set of CFFILE structures
 *      5)  Checksum each (compressed) data block independantly
 *
 *      This approach allows us to avoid reading unnecessary parts of the
 *      file cabinet (though reading all of CFFOLDER and CFFILE structures
 *      would otherwise not be required in all cases), while still providing
 *      adequate integrity checking.
 */

#ifndef INCLUDED_CABINET
#define INCLUDED_CABINET 1

typedef unsigned long CHECKSUM;
typedef unsigned long COFF;
typedef unsigned long UOFF;

//** Pack structures tightly in cabinet files!
#pragma pack(1)


/***    verCF - Cabinet File format version
 *
 *      The low-order byte is interpreted as a decimal number for the minor
 *      (1/100ths) portion of the version number.
 *      The high-order byte is interpreted as a decimal number for the major
 *      portion of the version number.
 *
 *      Examples:
 *          0x0000  0.00
 *          0x010A  1.10
 *          0x0410  4.16
 *
 *      History:
 *          1.01    Original
 *          1.02    Added flags field, changed signature
 *          1.03    Added setId,iCabinet so FDI can ensure correct cabinet
 *                      on continuation.
 */
#define verCF           0x0103      // CF version 1.03


/***    Various cabinet file limits
 *
 */
#define cMAX_FOLDERS_PER_CABINET    (ifoldMASK-1)
#define cMAX_FILES_PER_CABINET      65535


/***    cbRESERVE_XXX_MAX - Maximum size of RESERVE sections
 *
 *  NOTE: cbRESERVE_HEADER_MAX is a fair bit less than 64K because in
 *        the 16-bit version of this code, we want to have a USHORT
 *        variable that holds the size of the CFHEADER structure +
 *        the size of the CFRESERVE structure + the size of the per-header
 *        reserved data.
 */
#define cbRESERVE_HEADER_MAX        60000   // Fits in a USHORT
#define cbRESERVE_FOLDER_MAX          255   // Fits in a BYTE
#define cbRESERVE_DATA_MAX            255   // Fits in a BYTE


/***    ifoldXXXX - Special values for CFFILE.iFolder
 *
 */
#define ifoldMASK                    0xFFFC  // Low two bits zero
#define ifoldCONTINUED_FROM_PREV     0xFFFD
#define ifoldCONTINUED_TO_NEXT       0xFFFE
#define ifoldCONTINUED_PREV_AND_NEXT 0xFFFF

#define IS_CONTD_FORWARD(ifold) ((ifold & 0xfffe) == ifoldCONTINUED_TO_NEXT)
#define IS_CONTD_BACK(ifold) ((ifold & 0xfffd) == ifoldCONTINUED_FROM_PREV)


#ifndef MAKESIG
/***    MAKESIG - Construct a 4 byte signature
 *
 *  Entry:
 *      ch1,ch2,ch3,ch4 - four characters
 *
 *  Exit:
 *      returns unsigned long
 */
#define MAKESIG(ch1,ch2,ch3,ch4)          \
          (  ((unsigned long)ch1)      +  \
            (((unsigned long)ch2)<< 8) +  \
            (((unsigned long)ch3)<<16) +  \
            (((unsigned long)ch4)<<24) )
#endif // !MAKESIG


#define sigCFHEADER MAKESIG('M','S','C','F')  // CFHEADER signature


/***    cfhdrXXX - bit flags for cfheader.flags field
 *
 */
#define cfhdrPREV_CABINET       0x0001  // Set if previous cab/disk present
#define cfhdrNEXT_CABINET       0x0002  // Set if next cab/disk present
#define cfhdrRESERVE_PRESENT    0x0004  // Set if RESERVE_CONTROL is present


/***    CFHEADER - Cabinet File Header
 *
 */
typedef struct {
//**    LONGs are first, to ensure alignment
    long        sig;            // Cabinet File identification string
    CHECKSUM    csumHeader;     // Structure checksum (excluding csumHeader!)
    long        cbCabinet;      // Total length of file (consistency check)
    CHECKSUM    csumFolders;    // Checksum of CFFOLDER list
    COFF        coffFiles;      // Location in cabinet file of CFFILE list
    CHECKSUM    csumFiles;      // Checksum of CFFILE list

//**    SHORTs are next, to ensure alignment
    USHORT      version;        // Cabinet File version (verCF)
    USHORT      cFolders;       // Count of folders (CFIFOLDERs) in cabinet
    USHORT      cFiles;         // Count of files (CFIFILEs) in cabinet
    USHORT      flags;          // Flags to indicate optional data presence
    USHORT      setID;          // Cabinet set ID (identifies set of cabinets)
    USHORT      iCabinet;       // Cabinet number in set (0 based)
#define iCABINET_BAD    0xFFFF  // Illegal number for iCabinet

//**    If flags has the cfhdrRESERVE_PRESENT bit set, then a CFRESERVE
//      structure appears here, followed possibly by some CFHEADER reserved
//      space. The CFRESERVE structure has fields to define how much reserved
//      space is present in the CFHEADER, CFFOLDER, and CFDATA structures.
//      If CFRESERVE.cbCFHeader is non-zero, then abReserve[] immediately
//      follows the CFRESERVE structure.  Note that all of these sizes are
//      multiples of 4 bytes, to ensure structure alignment!
//
//  CFRESERVE   cfres;          // Reserve information
//  BYTE        abReserve[];    // Reserved data space
//

//**    The following fields presence depends upon the settings in the flags
//      field above.  If cfhdrPREV_CABINET is set, then there are two ASCIIZ
//      strings to describe the previous disk and cabinet.
//
//      NOTE: This "previous" cabinet is not necessarily the immediately
//            preceding cabinet!  While it usually will be, if a file is
//            continued into the current cabinet, then the "previous"
//            cabinet identifies the cabinet where the folder that contains
//            this file *starts*!  For example, if EXCEL.EXE starts in
//            cabinet excel.1 and is continued through excel.2 to excel.3,
//            then cabinet excel.3 will point back to *cabinet.1*, since
//            that is where you have to start in order to extract EXCEL.EXE.
//
//  char    szCabinetPrev[];    // Prev Cabinet filespec
//  char    szDiskPrev[];       // Prev descriptive disk name
//
//      Similarly, If cfhdrNEXT_CABINET is set, then there are two ASCIIZ
//      strings to describe the next disk and cabinet:
//
//  char    szCabinetNext[];    // Next Cabinet filespec
//  char    szDiskNext[];       // Next descriptive disk name
//
} CFHEADER; /* cfheader */


/***    CFRESERVE - Cabinet File Reserved data information
 *
 *  This structure is present in the middle of the CFHEADER structure if
 *  CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set.  This structure
 *  defines the sizes of all the reserved data sections in the CFHEADER,
 *  CFFOLDER, and CFDATA structures.
 *
 *  These reserved sizes can be zero (although it would be strange to have
 *  all of them be zero), but otherwise must be a multiple of 4, to ensure
 *  structure alignment for RISC machines.
 */
typedef struct {
    USHORT  cbCFHeader;         // Size of abReserve in CFHEADER structure
    BYTE    cbCFFolder;         // Size of abReserve in CFFOLDER structure
    BYTE    cbCFData;           // Size of abReserve in CFDATA   structure
} CFRESERVE; /* cfreserve */

#define cbCF_HEADER_BAD     0xFFFF      // Bad value for CFRESERVE.cbCFHeader

//
//  the following struct identifies the content of the signature area
//  of abReserved for Athenticode version 2.
//
typedef struct CABSignatureStruct_
{
    DWORD       cbFileOffset;
    DWORD       cbSig;
    BYTE        Filler[8];
} CABSignatureStruct_;



/***    CFFOLDER - Cabinet Folder
 *
 *  This structure describes a partial or complete "compression unit".
 *  A folder is by definition a stream of compressed data.  To retrieve
 *  an uncompressed data from a folder, you *must* start decompressing
 *  the data at the start of the folder, regardless of how far into the
 *  folder the data you want actually starts.
 *
 *  Folders may start in one cabinet, and continue on to one or more
 *  succeeding cabinets.  In general, if a folder has been continued over
 *  a cabinet boundary, Diamond/FCI will terminate that folder as soon as
 *  the current file has been completely compressed.  Generally this means
 *  that a folder would span at most two cabinets, but if the file is really
 *  large, it could span more than two cabinets.
 *
 *  Note: CFFOLDERs actually refer to folder *fragments*, not necessarily
 *        complete folders.  You know that a CFFOLDER is the beginning of a
 *        folder (as opposed to a continuation in a subsequent cabinet file)
 *        if a file starts in it (i.e., the CFFILE.uoffFolderStart field is
 *        0).
 */
typedef struct {
    COFF    coffCabStart;       // Offset in cabinet file of first CFDATA
                                // block for this folder.

    USHORT  cCFData;            // Count of CFDATAs for this folder that
                                //  are actually in this cabinet.  Note that
                                //  a folder can continue into another cabinet
                                //  and have many more CFDATA blocks in that
                                //  cabinet, *and* a folder may have started
                                //  in a previous cabinet.  This count is
                                //  only of CFDATAs for this folder that are
                                //  (at least partially) in this cabinet.

    short   typeCompress;       // Indicates compression type for all CFDATA
                                //   blocks for this folder.  The valid values
                                //   are defined in the types.h built into
                                //   fci.h/fdi.h.

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFFolder is non-zero, then abReserve[] appears here.
//
//  BYTE    abReserve[];        // Reserved data space
//
} CFFOLDER; /* cffolder */



/***    CFFILE - Cabinet File structure describing a single file in the cabinet
 *
 *  NOTE: iFolder is used to indicatate continuation cases, so we have to
 *        calculate the real iFolder by examining the cabinet files:
 *
 *        ifoldCONTINUED_FROM_PREV
 *            This file ends in this cabinet, but is continued from a
 *            previous cabinet.  Therefore, the portion of the file contained
 *            in *this* cabinet *must* start in the first folder.
 *
 *            NOTE: szCabinetPrev is the name of the cabinet where this file
 *                  *starts*, which is not necessarily the immediately
 *                  preceeding cabinet!  Since it only makes sense to
 *                  decompress a file from its start, the starting cabinet
 *                  is what is important!
 *
 *        ifoldCONTINUED_TO_NEXT
 *            This file starts in this cabinet, but is continued to the next
 *            cabinet.  Therfore, this file must start in the *last* folder
 *            in this cabinet.
 *
 *        ifoldCONTINUED_PREV_AND_NEXT
 *            This file is the *middle* portion of a file that started in a
 *            previous cabinet and is continued in the next cabinet.  Since
 *            this cabinet only contain this piece of a single file, there
 *            is only a single folder fragment in this cabinet.
 */
typedef struct {
    long    cbFile;             // Uncompressed size of file

    UOFF    uoffFolderStart;    // Offset in folder IN UNCOMPRESSED BYTES
                                //  of the start of this file

    USHORT  iFolder;            // Index of folder containing this file;
                                //  0 is first folder in this cabinet.
                                //  See ifoldCONTINUED_XXXX values above
                                //  for treatment of continuation files.

    USHORT  date;               // Date stamp in FAT file system format

    USHORT  time;               // Time stamp in FAT file system format

    USHORT  attribs;            // Attribute in FAT file system format

//  char    szName[];           // File name (may include path characters)
} CFFILE; /* cffile */


/***    CFDATA - Cabinet File structure describing a data block
 *
 */
typedef struct {
    CHECKSUM    csum;           // Checksum (excluding this field itself!)
                                //  of this structure and the data that
                                //  follows.  If this CFDATA structure is
                                //  continued to the next cabinet, then
                                //  the value of this field is ignored
                                //  (and set to zero).

    USHORT      cbData;         // Size of ab[] data that resides in the
                                //  current cabinet.  A CFDATA may be split
                                //  across a cabinet boundary, so this
                                //  value indicates only the amount of data
                                //  store in this cabinet.

    USHORT      cbUncomp;       // Uncompressed size of ab[] data; if this
                                //  CFDATA block is continued to the next
                                //  cabinet, then this value is zero!
                                //  If this CFDATA block the remainder of
                                //  of a CFDATA block that started in the
                                //  previous cabinet, then this value is
                                //  the total size of the uncompressed data
                                //  represented by the two CFDATA blocks!

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFData is non-zero, then abReserve[] appears here.
//
//  BYTE        abReserve[];    // Reserved data space
//

//**    The actual data follows here, cbData bytes in length.
//
//  BYTE        ab[];           // Data
//
} CFDATA; /* cfdata */



//** Attribute Bit to use for Run after extract
#define  RUNATTRIB  0x40


//** Revert to default structure packing!
#pragma pack()

#endif // !INCLUDED_CABINET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\mssip32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mssip32.h
//
//  Contents:   Microsoft SIP Provider
//
//  Functions:  DllMain
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MSSIP32_H
#define MSSIP32_H

#define     MSSIP_ID_NONE                   0       // file only types
#define     MSSIP_ID_PE                     1
#define     MSSIP_ID_JAVA                   2
#define     MSSIP_ID_CAB                    3
#define     MSSIP_ID_FLAT                   4
#define     MSSIP_ID_CATALOG                5
#define     MSSIP_ID_CTL                    6
#define     MSSIP_ID_SS                     7

#define     MSSIP_V1ID_BEGIN                200
#define     MSSIP_V1ID_PE                   201
#define     MSSIP_V1ID_PE_EX                202
#define     MSSIP_V1ID_END                  299

#define     MSSIP_SUBJECT_FORM_FILE         1
#define     MSSIP_SUBJECT_FORM_FILEANDDISP  2

#define     MSSIP_CURRENT_VERSION           0x00000300

#define     OFFSETOF(t,f)                   ((DWORD)((DWORD_PTR)&((t*)0)->f))
#define     OBSOLETE_TEXT_W                 L"<<<Obsolete>>>"   // valid since 2/14/1997

#define     HASH_CACHE_LEN                  128

typedef void *HSPCDIGESTDATA;

typedef struct DIGEST_DATA
{
    HCRYPTHASH  hHash;
    DWORD       cbCache;
    BYTE        pbCache[HASH_CACHE_LEN];
    DWORD       dwAlgId;
    void        *pvSHA1orMD5Ctx;

} DIGEST_DATA, *PDIGEST_DATA;

extern BOOL WINAPI DigestFileData(  IN HSPCDIGESTDATA hDigestData,
                                    IN const BYTE *pbData,
                                    IN DWORD cbData);

extern void SipDestroyHash(DIGEST_DATA *psDigestData);
extern BYTE *SipGetHashValue(DIGEST_DATA *psDigestData, DWORD *pcbHash);
extern BOOL SipHashData(DIGEST_DATA *psDigestData, BYTE *pbData, DWORD cbData);
extern BOOL SipCreateHash(HCRYPTPROV hProv, DIGEST_DATA *psDigestData);

extern void CryptSIPGetRegWorkingFlags(DWORD *pdwState);


#endif // MSSIP32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\mssip32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mssip32.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobj.hxx"
#include    "sipobjpe.hxx"
#include    "sipobjjv.hxx"
#include    "sipobjcb.hxx"
#include    "sipobjfl.hxx"
#include    "sipobjct.hxx"
#include    "sipobjss.hxx"

#include    "crypthlp.h"
#include    "sha.h"
#include    "md5.h"

#define     MY_NAME     L"WINTRUST.DLL"

SIPObject_ *mssip_CreateSubjectObject(const GUID *chk);

//
//  the entries in SubjectsGuid MUST be in the same
//  relative position and coalate with those in the
//  SubjectsID.
//
static const GUID SubjectsGuid[] =
                    {
                        CRYPT_SUBJTYPE_PE_IMAGE,
                        CRYPT_SUBJTYPE_JAVACLASS_IMAGE,
                        CRYPT_SUBJTYPE_CABINET_IMAGE,
                        CRYPT_SUBJTYPE_FLAT_IMAGE,
                        CRYPT_SUBJTYPE_CATALOG_IMAGE,
                        CRYPT_SUBJTYPE_CTL_IMAGE
                    };

//                        CRYPT_SUBJTYPE_SS_IMAGE

static const UINT SubjectsID[] = 
                    {
                        MSSIP_ID_PE,
                        MSSIP_ID_JAVA,
                        MSSIP_ID_CAB,
                        MSSIP_ID_FLAT,
                        MSSIP_ID_CATALOG,
                        MSSIP_ID_CTL,
                        MSSIP_ID_NONE     // MUST be at the end!
                    };
                
//                         MSSIP_ID_SS,


BOOL WINAPI CryptSIPGetSignedDataMsg(  IN      SIP_SUBJECTINFO *pSubjectInfo,
                                OUT     DWORD           *dwEncodingType,
                                IN      DWORD           dwIndex,
                                IN OUT  DWORD           *pdwDataLen,
                                OUT     BYTE            *pbData)
{
    DWORD       dwLastError=0;

    if (!(pSubjectInfo) || !(pdwDataLen) || !(dwEncodingType))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        if (!(pbData))
        {
            *pdwDataLen = 0;
        }
        return(FALSE);
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->GetSignedDataMsg(pSubjectInfo,
                                    dwIndex,pdwDataLen,pbData,dwEncodingType);

    dwLastError=GetLastError();

    delete pSubjectObj;

    SetLastError(dwLastError);

    return(bRet);
}

BOOL WINAPI CryptSIPPutSignedDataMsg(  IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                OUT     DWORD           *pdwIndex,
                                IN      DWORD           dwDataLen,
                                IN      BYTE            *pbData)
{
    if (!(pSubjectInfo) ||
        (dwDataLen < 1) ||
        !(pdwIndex)     ||
        !(pbData))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->PutSignedDataMsg(pSubjectInfo,
                                pdwIndex,dwDataLen,pbData,dwEncodingType);

    delete pSubjectObj;

    return(bRet);
}

BOOL WINAPI CryptSIPRemoveSignedDataMsg(   IN SIP_SUBJECTINFO  *pSubjectInfo,
                                    IN DWORD            dwIndex)
{
    if (!(pSubjectInfo))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }
    
    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->RemoveSignedDataMsg(pSubjectInfo,dwIndex);

    delete pSubjectObj;

    return(bRet);
}


BOOL WINAPI CryptSIPCreateIndirectData( IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                 IN OUT  DWORD               *pdwDataLen,
                                 OUT     SIP_INDIRECT_DATA   *psData)
{
    if (!(pSubjectInfo) || !(pdwDataLen))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        if (!(psData))
        {
            *pdwDataLen = 0;
        }
        return(FALSE);
    }

    //
    //  ALWAYS set the latest version when we are creating the
    //  indirect data content!
    //
    pSubjectInfo->dwIntVersion = WIN_CERT_REVISION_2_0;
    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->CreateIndirectData(pSubjectInfo,pdwDataLen,psData);

    delete pSubjectObj;

    return(bRet);
}

BOOL WINAPI CryptSIPVerifyIndirectData(    IN SIP_SUBJECTINFO      *pSubjectInfo,
                                    IN SIP_INDIRECT_DATA    *psData)
{
    if (!(pSubjectInfo))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }

    //
    //  if we are a catalog member, set the version number to whatever
    //  was set when the catalog file was created...
    //
    if ((WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwUnionChoice)) &&
        (pSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
        (pSubjectInfo->psCatMember))
    {
        if (pSubjectInfo->psCatMember->cbStruct == sizeof(MS_ADDINFO_CATALOGMEMBER))
        {
            if ((pSubjectInfo->psCatMember->pMember) &&
                (pSubjectInfo->psCatMember->pMember->cbStruct == sizeof(CRYPTCATMEMBER)))
            {
                pSubjectInfo->dwIntVersion = pSubjectInfo->psCatMember->pMember->dwCertVersion;
            }
        }
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    if (pSubjectObj->get_CertVersion() < WIN_CERT_REVISION_2_0)
    {
        DWORD   dwCAPIFlags;

        CryptSIPGetRegWorkingFlags(&dwCAPIFlags);

        if (dwCAPIFlags & WTPF_VERIFY_V1_OFF)
        {
            delete pSubjectObj;

            SetLastError((DWORD)CRYPT_E_SECURITY_SETTINGS);

            return(FALSE);
        }
    }

    BOOL    bRet;

    bRet = pSubjectObj->VerifyIndirectData(pSubjectInfo, psData);

    delete pSubjectObj;

    return(bRet);
}

//////////////////////////////////////////////////////////////////////////////////////
//
// internal utility functions
//------------------------------------------------------------------------------------
//

SIPObject_ *mssip_CreateSubjectObject(const GUID *chk)
{
    UINT        idx;
    SIPObject_  *pSO;

    pSO = NULL;
    idx = 0;

    while (SubjectsID[idx] != MSSIP_ID_NONE)
    {
        if (SubjectsGuid[idx] == *chk)
        {
            switch (SubjectsID[idx])
            {
                case MSSIP_ID_PE:
                    pSO = (SIPObject_ *)new SIPObjectPE_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_JAVA:
                    pSO = (SIPObject_ *)new SIPObjectJAVA_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_CAB:
                    pSO = (SIPObject_ *)new SIPObjectCAB_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_FLAT:
                    pSO = (SIPObject_ *)new SIPObjectFlat_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_CTL:  // currently, the same logic as catalog files!
                case MSSIP_ID_CATALOG:
                    pSO = (SIPObject_ *)new SIPObjectCatalog_(SubjectsID[idx]);
                    break;

 /*               case MSSIP_ID_SS:
                    pSO = (SIPObject_ *)new SIPObjectSS_(SubjectsID[idx]);
                    break;  */

                case MSSIP_V1ID_PE:
                case MSSIP_V1ID_PE_EX:
                default:
                    SetLastError((DWORD)TRUST_E_SUBJECT_FORM_UNKNOWN);
                    return(NULL);
            }

            if (!(pSO))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(NULL);
            }

            break;
        }

        idx++;
    }

    if (!(pSO))
    {
        SetLastError((DWORD)TRUST_E_SUBJECT_FORM_UNKNOWN);
    }

    return(pSO);
}


BOOL WINAPI DigestFileData(  IN HSPCDIGESTDATA hDigestData,
                             IN const BYTE *pbData,
                             IN DWORD cbData)
{
    BOOL            fRet;
    PDIGEST_DATA    pDigestData;

    fRet        = TRUE;
    pDigestData = (PDIGEST_DATA)hDigestData;

    if (cbData > HASH_CACHE_LEN) 
    {
        if (pDigestData->cbCache > 0) 
        {
            fRet = SipHashData(pDigestData, pDigestData->pbCache, pDigestData->cbCache);

            pDigestData->cbCache = 0;

            if (!(fRet))
            {
                return(FALSE);
            }
        }

        fRet = SipHashData(pDigestData, (BYTE *)pbData, cbData);
    } 
    else 
    {
        while (cbData > 0) 
        {
            DWORD cbCopy;

            cbCopy = min(HASH_CACHE_LEN - pDigestData->cbCache, cbData);

            memcpy(&pDigestData->pbCache[pDigestData->cbCache], pbData,
                    cbCopy);

            cbData -= cbCopy;
            pbData += cbCopy;

            pDigestData->cbCache += cbCopy;

            if (pDigestData->cbCache == HASH_CACHE_LEN) 
            {
                pDigestData->cbCache = 0;

                if (!(fRet = SipHashData(pDigestData, pDigestData->pbCache, HASH_CACHE_LEN)))
                {
                    break;
                }
            }
        }
    }

    return(fRet);
}


BOOL SipCreateHash(HCRYPTPROV hProv, DIGEST_DATA *psDigestData)
{
    BOOL    fRet;

    fRet = TRUE;

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5Init((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx);
            break;

        case CALG_SHA1:
            A_SHAInit((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx);
            break;

        default:
            if (!(hProv))
            {
                hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!
            }

            fRet = CryptCreateHash(hProv, psDigestData->dwAlgId, NULL, 0, &psDigestData->hHash);
            break;
    }

    return(fRet);
}

BOOL SipHashData(DIGEST_DATA *psDigestData, BYTE *pbData, DWORD cbData)
{
    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5Update((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);

        case CALG_SHA1:
            A_SHAUpdate((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);
    }

    return(CryptHashData(psDigestData->hHash, pbData, cbData, 0));
}

BYTE *SipGetHashValue(DIGEST_DATA *psDigestData, DWORD *pcbHash)
{
    BYTE    *pbRet;

    pbRet = NULL;

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            *pcbHash = MD5DIGESTLEN;
            break;

        case CALG_SHA1:
            *pcbHash = A_SHA_DIGEST_LEN;
            break;

        default:
            *pcbHash = 0;
            CryptGetHashParam(psDigestData->hHash, HP_HASHVAL, NULL, pcbHash,0);
    }

    if (*pcbHash < 1)
    {
        goto HashLengthError;
    }

    if (!(pbRet = new BYTE[*pcbHash]))
    {
        goto MemoryError;
    }

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5_CTX *pMD5;

            pMD5 = (MD5_CTX *)psDigestData->pvSHA1orMD5Ctx;

            MD5Final(pMD5);

            memcpy(pbRet, pMD5->digest, MD5DIGESTLEN);
            psDigestData->pvSHA1orMD5Ctx = NULL;
            break;

        case CALG_SHA1:
            A_SHAFinal((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, pbRet);
            psDigestData->pvSHA1orMD5Ctx = NULL;
            break;

        default:
            if (CryptGetHashParam(psDigestData->hHash, HP_HASHVAL, pbRet, pcbHash, 0))
            {
                goto HashParamError;
            }
            break;
    }


    CommonReturn:
        return(pbRet);

    ErrorReturn:
        DELETE_OBJECT(pbRet);
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, HashLengthError,   GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, HashParamError,    GetLastError());
}

void SipDestroyHash(DIGEST_DATA *psDigestData)
{
    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            if (psDigestData->pvSHA1orMD5Ctx)
            {
                MD5Final((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx);
            }
            break;

        case CALG_SHA1:
            if (psDigestData->pvSHA1orMD5Ctx)
            {
                BYTE    bRet[A_SHA_DIGEST_LEN];

                A_SHAFinal((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, &bRet[0]);
            }
            break;

        default:
            CryptDestroyHash(psDigestData->hHash);
            break;
    }
}

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//------------------------------------------------------------------------------------
//

BOOL WINAPI mssip32DllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
    return(TRUE);
}


STDAPI mssip32DllRegisterServer(void)
{
    BOOL                fRet;
    GUID                gFlat   = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID                gPe     = CRYPT_SUBJTYPE_PE_IMAGE;
    GUID                gCb     = CRYPT_SUBJTYPE_CABINET_IMAGE;
    GUID                gJv     = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;
    GUID                gCat    = CRYPT_SUBJTYPE_CATALOG_IMAGE;
    GUID                gCTL    = CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID                gSS     = CRYPT_SUBJTYPE_SS_IMAGE;
    SIP_ADD_NEWPROVIDER sProv;

    fRet = TRUE;


    memset(&sProv, 0x00, sizeof(SIP_ADD_NEWPROVIDER));
    
    sProv.cbStruct              = sizeof(SIP_ADD_NEWPROVIDER);
    sProv.pwszDLLFileName       = MY_NAME;

    sProv.pwszGetFuncName       = L"CryptSIPGetSignedDataMsg";
    sProv.pwszPutFuncName       = L"CryptSIPPutSignedDataMsg";
    sProv.pwszCreateFuncName    = L"CryptSIPCreateIndirectData";
    sProv.pwszVerifyFuncName    = L"CryptSIPVerifyIndirectData";
    sProv.pwszRemoveFuncName    = L"CryptSIPRemoveSignedDataMsg";


    sProv.pgSubject             = &gFlat;
    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCb;
    sProv.pwszMagicNumber       = L"MSCF";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gPe;
    sProv.pwszMagicNumber       = L"0x00004550";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gJv;
    sProv.pwszMagicNumber       = L"0xcafebabe";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCat;

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCTL;

    fRet &= CryptSIPAddProvider(&sProv);

    //
    //  structured storage is last becuase it
    //  has an "is" function...
    //
   /* sProv.pgSubject                 = &gSS;
    sProv.pwszIsFunctionNameFmt2    = L"IsStructuredStorageFile";

    fRet &= CryptSIPAddProvider(&sProv); */

    CryptSIPRemoveProvider(&gSS);

    return(fRet ? S_OK : S_FALSE);
}


STDAPI mssip32DllUnregisterServer(void)
{
    GUID                gFlat   = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID                gPe     = CRYPT_SUBJTYPE_PE_IMAGE;
    GUID                gCb     = CRYPT_SUBJTYPE_CABINET_IMAGE;
    GUID                gJv     = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;
    GUID                gCat    = CRYPT_SUBJTYPE_CATALOG_IMAGE;
    GUID                gCTL    = CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID                gSS     = CRYPT_SUBJTYPE_SS_IMAGE;


    CryptSIPRemoveProvider(&gFlat);
    CryptSIPRemoveProvider(&gPe);
    CryptSIPRemoveProvider(&gCb);
    CryptSIPRemoveProvider(&gJv);
    CryptSIPRemoveProvider(&gCat);
    CryptSIPRemoveProvider(&gCTL);
    CryptSIPRemoveProvider(&gSS);

    return(S_OK);
}


void CryptSIPGetRegWorkingFlags(DWORD *pdwState) 
{
    WintrustGetRegPolicyFlags(pdwState);
}

//
//  support for Auth2 release
//
typedef struct _SIP_INFORMATION
{
    DWORD       cbSize;         // sizeof(SIP_INFORMATION)
    DWORD       cgSubjects;     // number of guids in array
    const GUID  *pgSubjects;    // array of supported guids/subjects
} SIP_INFORMATION, *PSIP_INFORMATION;

BOOL CryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit)
{
    UINT    i;

    i = 0;

    pSIPInit->cbSize = sizeof(SIP_INFORMATION);

    while (SubjectsID[i] != MSSIP_ID_NONE)
    {
        i++;
    }

    pSIPInit->cgSubjects = i;
    pSIPInit->pgSubjects = &SubjectsGuid[0];

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipguids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipguids.h
//
//  Contents:   Microsoft SIP Provider
//
//  Functions:  DllMain
//
//  History:    01-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SIPGUIDS_H
#define SIPGUIDS_H

//all the GUIDs are now exposed and defined in the public\sdk\inc\mssig32.h

#include "mssign32.h"

#endif // SIPGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\jvimage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jvimage.cpp
//
//  Contents:   Microsoft SIP Provider (JAVA utilities)
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "global.hxx"

BOOL SeekAndReadFile(HANDLE hFile, DWORD lFileOffset,BYTE *pb,
                     DWORD cb);

BOOL SeekAndWriteFile(HANDLE hFile, DWORD lFileOffset, BYTE *pb,
                      DWORD cb);

typedef void *HSHPDIGESTDATA;
typedef BOOL (WINAPI *PFN_SHP_DIGEST_DATA)(HSHPDIGESTDATA hDigestData,
                                           BYTE *pbData,
                                           DWORD cbData);

typedef void *HSHPSIGNFILE;


typedef struct _JAVA_OPEN_ARG 
{
    HANDLE  hFile;
} JAVA_OPEN_ARG, *PJAVA_OPEN_ARG;


typedef struct _JAVA_FUNC_PARA 
{
    HANDLE              hFile;
    BYTE                *pbSignedData;
} JAVA_FUNC_PARA, *PJAVA_FUNC_PARA;

typedef struct _JAVA_DIGEST_PARA 
{
    BOOL                fDisableDigest;
    PFN_SHP_DIGEST_DATA pfnDigestData;
    HSHPDIGESTDATA      hDigestData;
} JAVA_DIGEST_PARA, *PJAVA_DIGEST_PARA;

typedef struct _JAVA_SIGN_PARA 
{
    WORD                wConstPoolCount;
    WORD                wSignConstPoolIndex;
    LONG                lSignConstPoolOffset;
    WORD                wAttrCount;
    LONG                lAttrCountOffset;
    WORD                wSignAttrIndex;
    DWORD               dwSignAttrLength;
    LONG                lSignAttrOffset;
    LONG                lEndOfFileOffset;
} JAVA_SIGN_PARA, *PJAVA_SIGN_PARA;

typedef struct _JAVA_READ_PARA 
{
    BOOL                fResult;
    DWORD               dwLastError;
    LONG                lFileOffset;
    DWORD               cbCacheRead;
    DWORD               cbCacheRemain;
} JAVA_READ_PARA, *PJAVA_READ_PARA;

#define JAVA_READ_CACHE_LEN 512

typedef struct _JAVA_PARA 
{
    JAVA_FUNC_PARA      Func;
    JAVA_DIGEST_PARA    Digest;
    JAVA_SIGN_PARA      Sign;
    JAVA_READ_PARA      Read;
    BYTE                rgbCache[JAVA_READ_CACHE_LEN];
} JAVA_PARA, *PJAVA_PARA;



#define JAVA_MAGIC          0xCAFEBABE
#define JAVA_MINOR_VERSION  3
#define JAVA_MAJOR_VERSION  45

// Constant Pool tags
//
// Note: CONSTANT_Long and CONSTANT_Double use two constant pool indexes.
enum 
{
    CONSTANT_Utf8                   = 1,
    CONSTANT_Unicode                = 2,
    CONSTANT_Integer                = 3,
    CONSTANT_Float                  = 4,
    CONSTANT_Long                   = 5,
    CONSTANT_Double                 = 6,
    CONSTANT_Class                  = 7,
    CONSTANT_String                 = 8,
    CONSTANT_Fieldref               = 9,
    CONSTANT_Methodref              = 10,
    CONSTANT_InterfaceMethodref     = 11,
    CONSTANT_NameAndType            = 12
};

// Constant Pool Info lengths (excludes the tag)
DWORD rgConstPoolLength[] = 
{
    0, // tag of zero not used
    0, // CONSTANT_Utf8 (special case)
    0, // CONSTANT_Unicode (special case)
    4, // CONSTANT_Integer_info
    4, // CONSTANT_Float_info
    8, // CONSTANT_Long_info
    8, // CONSTANT_Double_info
    2, // CONSTANT_Class_info
    2, // CONSTANT_String_info
    4, // CONSTANT_Fieldref_info
    4, // CONSTANT_Methodref_info
    4, // CONSTANT_InterfaceMethodref_info
    4  // CONSTANT_NameAndType_info
};

static inline void *ShpAlloc(DWORD cbytes)
{
    void    *pvRet;

    pvRet = (void *)new BYTE[cbytes];

    if (!(pvRet))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return(pvRet);
}

static inline void ShpFree(void *pv)
{
    if (pv)
    {
        delete pv;
    }
}

// The following functions convert to/from Java bytes which are big endian
static inline void ToJavaU2(WORD w, BYTE rgb[])
{
    rgb[0] = HIBYTE(w);
    rgb[1] = LOBYTE(w);
}
static inline WORD FromJavaU2(BYTE rgb[])
{
    return  ((WORD)rgb[0]<<8) | ((WORD)rgb[1]<<0);
}

static inline void ToJavaU4(DWORD dw, BYTE rgb[])
{
    rgb[0] = HIBYTE(HIWORD(dw));
    rgb[1] = LOBYTE(HIWORD(dw));
    rgb[2] = HIBYTE(LOWORD(dw));
    rgb[3] = LOBYTE(LOWORD(dw));
}
static inline DWORD FromJavaU4(BYTE rgb[])
{
    return  ((DWORD)rgb[0]<<24) |
            ((DWORD)rgb[1]<<16) |
            ((DWORD)rgb[2]<<8)  |
            ((DWORD)rgb[3]<<0);
}

#define CONST_POOL_COUNT_OFFSET     8
#define UTF8_HDR_LENGTH             (1+2)
#define ATTR_HDR_LENGTH             (2+4)
#define SIGN_ATTR_NAME_LENGTH       19
#define SIGN_CONST_POOL_LENGTH      (UTF8_HDR_LENGTH + SIGN_ATTR_NAME_LENGTH)

static const char rgchSignAttrName[SIGN_ATTR_NAME_LENGTH + 1] =
                                "_digital_signature_";


//+-------------------------------------------------------------------------
//  Shift the bytes in the file.
//
//  If lbShift is positive, the bytes are shifted toward the end of the file.
//  If lbShift is negative, the bytes are shifted toward the start of the file.
//--------------------------------------------------------------------------
static
BOOL
JavaShiftFileBytes(
    IN HANDLE hFile,
    IN PBYTE pbCache,
    IN LONG cbCache,
    IN LONG lStartOffset,
    IN LONG lEndOffset,
    IN LONG lbShift
    )
{
    LONG cbTotalMove, cbMove;

    cbTotalMove = lEndOffset - lStartOffset;
    while (cbTotalMove) {
        cbMove = min(cbTotalMove, cbCache);

        if (lbShift > 0) {
            if (!SeekAndReadFile(hFile, lEndOffset - cbMove,
                    pbCache, cbMove))
                return FALSE;
            if (!SeekAndWriteFile(hFile, (lEndOffset - cbMove) + lbShift,
                    pbCache, cbMove))
                return FALSE;
            lEndOffset -= cbMove;
        } else if (lbShift < 0) {
            if (!SeekAndReadFile(hFile, lStartOffset, pbCache, cbMove))
                return FALSE;
            if (!SeekAndWriteFile(hFile, lStartOffset + lbShift,
                    pbCache, cbMove))
                return FALSE;
            lStartOffset += cbMove;
        }
        cbTotalMove -= cbMove;
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Low level functions for reading the Java Class File.
//
//  If not disabled, the read bytes are also hashed.
//
//  For an error, remaining unread values are zero'ed and
//  pPara->Read.fResult = FALSE.
//--------------------------------------------------------------------------
static void ReadJavaBytes(
    IN PJAVA_PARA pPara,
    OUT OPTIONAL BYTE *pb,  // if NULL, bytes are hashed and then skipped
    IN DWORD cb
    )
{
    DWORD cbCacheRemain = pPara->Read.cbCacheRemain;
    DWORD lFileOffset = pPara->Read.lFileOffset;
    BOOL fDisableDigest = pPara->Digest.pfnDigestData == NULL ||
                                pPara->Digest.fDisableDigest;

    if (!pPara->Read.fResult)
        goto ErrorReturn;

    while (cb > 0) {
        DWORD cbCopy;
        BYTE *pbCache;

        if (cbCacheRemain == 0) {
            if (!ReadFile(pPara->Func.hFile, pPara->rgbCache,
                    sizeof(pPara->rgbCache), &cbCacheRemain, NULL))
                goto ErrorReturn;
            if (cbCacheRemain == 0) goto ErrorReturn;
            pPara->Read.cbCacheRead = cbCacheRemain;
        }

        cbCopy = min(cb, cbCacheRemain);
        pbCache = &pPara->rgbCache[pPara->Read.cbCacheRead - cbCacheRemain];
        if (!fDisableDigest) {
            if (!pPara->Digest.pfnDigestData(
                    pPara->Digest.hDigestData,
                    pbCache,
                    cbCopy)) goto ErrorReturn;
        }
        if (pb) {
            memcpy(pb, pbCache, cbCopy);
            pb += cbCopy;
        }
        cb -= cbCopy;
        cbCacheRemain -= cbCopy;
        lFileOffset += cbCopy;
    }
    goto CommonReturn;

ErrorReturn:
    if (pPara->Read.fResult) {
        // First error
        pPara->Read.fResult = FALSE;
        pPara->Read.dwLastError = GetLastError();
    }
    if (pb && cb)
        memset(pb, 0, cb);
CommonReturn:
    pPara->Read.cbCacheRemain = cbCacheRemain;
    pPara->Read.lFileOffset = lFileOffset;

}

static void SkipJavaBytes(IN PJAVA_PARA pPara, IN DWORD cb)
{
    ReadJavaBytes(pPara, NULL, cb);
}

static BYTE ReadJavaU1(IN PJAVA_PARA pPara)
{
    BYTE b;
    ReadJavaBytes(pPara, &b, 1);
    return b;
}
static WORD ReadJavaU2(IN PJAVA_PARA pPara) 
{
    BYTE rgb[2];
    ReadJavaBytes(pPara, rgb, 2);
    return FromJavaU2(rgb);
}
static DWORD ReadJavaU4(IN PJAVA_PARA pPara) 
{
    BYTE rgb[4];
    ReadJavaBytes(pPara, rgb, 4);
    return FromJavaU4(rgb);
}


//+-------------------------------------------------------------------------
//  .
//--------------------------------------------------------------------------
static
BOOL
GetSignedDataFromJavaClassFile(
    IN HSHPSIGNFILE hSignFile,
    OUT BYTE **ppbSignedData,
    OUT DWORD *pcbSignedData
    )
{
    BOOL fResult;
    PJAVA_PARA pPara = (PJAVA_PARA) hSignFile;
    BYTE *pbSignedData = NULL;
    DWORD cbSignedData;

    cbSignedData = pPara->Sign.dwSignAttrLength;
    if (cbSignedData == 0) {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        goto ErrorReturn;
    }

    pbSignedData = pPara->Func.pbSignedData;
    if (pbSignedData == NULL) {
        if (NULL == (pbSignedData = (BYTE *) ShpAlloc(cbSignedData)))
            goto ErrorReturn;
        if (!SeekAndReadFile(
                pPara->Func.hFile,
                pPara->Sign.lSignAttrOffset + ATTR_HDR_LENGTH,
                pbSignedData,
                cbSignedData))
            goto ErrorReturn;
        pPara->Func.pbSignedData = pbSignedData;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbSignedData) {
        ShpFree(pbSignedData);
        pbSignedData = NULL;
    }
    cbSignedData = 0;
    fResult = FALSE;
CommonReturn:
    *ppbSignedData = pbSignedData;
    *pcbSignedData = cbSignedData;
    return fResult;
}

//+-------------------------------------------------------------------------
//  .
//--------------------------------------------------------------------------
static
BOOL
SetSignedDataIntoJavaClassFile(
    IN HSHPSIGNFILE hSignFile,
    IN const BYTE *pbSignedData,
    IN DWORD cbSignedData
    )
{
    PJAVA_PARA pPara = (PJAVA_PARA) hSignFile;
    HANDLE hFile = pPara->Func.hFile;

    if (pbSignedData == NULL || cbSignedData == 0)
        // Length only
        return TRUE;

    if (pPara->Sign.wSignConstPoolIndex == pPara->Sign.wConstPoolCount) {
        BYTE rgb[SIGN_CONST_POOL_LENGTH];
        // Add a new constant pool entry for the name of the
        // signed data attribute.

        // First, make room in the file by shifting all the bytes that follow.
        if (!JavaShiftFileBytes(
                pPara->Func.hFile,
                pPara->rgbCache,
                sizeof(pPara->rgbCache),
                pPara->Sign.lSignConstPoolOffset,
                pPara->Sign.lEndOfFileOffset,
                SIGN_CONST_POOL_LENGTH))
            return FALSE;

        // Update offsets that have been shifted
        pPara->Sign.lAttrCountOffset += SIGN_CONST_POOL_LENGTH;
        pPara->Sign.lSignAttrOffset += SIGN_CONST_POOL_LENGTH;
        pPara->Sign.lEndOfFileOffset += SIGN_CONST_POOL_LENGTH;

        // Increment u2 constant_pool_count and update in file
        pPara->Sign.wConstPoolCount++;
        ToJavaU2(pPara->Sign.wConstPoolCount, rgb);
        if (!SeekAndWriteFile(hFile, CONST_POOL_COUNT_OFFSET, rgb, 2))
            return FALSE;

        // Add constant pool entry for the sign attr name and update in file
        rgb[0] = CONSTANT_Utf8;
        ToJavaU2(SIGN_ATTR_NAME_LENGTH, &rgb[1]);
        memcpy(&rgb[1+2], rgchSignAttrName, SIGN_ATTR_NAME_LENGTH);
        if (!SeekAndWriteFile(hFile, pPara->Sign.lSignConstPoolOffset, rgb,
                SIGN_CONST_POOL_LENGTH))
            return FALSE;
    }

    if (pPara->Sign.dwSignAttrLength == 0) {
        // Add a new attribute for the signed data. The attribute will
        // be added at the end of the file.
        assert(pPara->Sign.lSignAttrOffset == pPara->Sign.lEndOfFileOffset);
        pPara->Sign.lEndOfFileOffset += ATTR_HDR_LENGTH + cbSignedData;

        // Increment u2 attribute_count and update in file
        BYTE rgb[2];
        pPara->Sign.wAttrCount++;
        ToJavaU2(pPara->Sign.wAttrCount, rgb);
        if (!SeekAndWriteFile(hFile, pPara->Sign.lAttrCountOffset, rgb, 2))
            return FALSE;

    } else {
        // The file already has a signed data attribute.

        // If its length is different from the new signed data
        // then, the bytes that follow the attribute will
        // need to be shifted by the difference in length of the old and new
        // signed data
        LONG lbShift = cbSignedData - pPara->Sign.dwSignAttrLength;
        if (lbShift != 0) {
            if (!JavaShiftFileBytes(
                    pPara->Func.hFile,
                    pPara->rgbCache,
                    sizeof(pPara->rgbCache),
                    pPara->Sign.lSignAttrOffset +
                            (ATTR_HDR_LENGTH + pPara->Sign.dwSignAttrLength),
                    pPara->Sign.lEndOfFileOffset,
                    lbShift))
            return FALSE;
            
            pPara->Sign.lEndOfFileOffset += lbShift;
        }
    }
    pPara->Sign.dwSignAttrLength = cbSignedData;

    {
        // Update the file with the signed data attribute
        BYTE rgb[ATTR_HDR_LENGTH];
        DWORD cbWritten;
        ToJavaU2(pPara->Sign.wSignConstPoolIndex, rgb); // u2 attribute_name
        ToJavaU4(cbSignedData, &rgb[2]);                // u4 attribute_length
        if (!SeekAndWriteFile(hFile, pPara->Sign.lSignAttrOffset, rgb,
                ATTR_HDR_LENGTH))
            return FALSE;
        if (!WriteFile(hFile, pbSignedData, cbSignedData, &cbWritten, NULL) ||
                cbWritten != cbSignedData)
            return FALSE;
    }

    // Set end of file
    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            pPara->Sign.lEndOfFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    return SetEndOfFile(hFile);
}

//+-------------------------------------------------------------------------
//  Reads and optionally digests the Java Class file. Locates the signed data.
//--------------------------------------------------------------------------
static
BOOL
ProcessJavaClassFile(
    PJAVA_PARA pPara,
    BOOL fInit
    )
{
    char rgchTmpSignAttrName[SIGN_ATTR_NAME_LENGTH];
    WORD wLength;
    DWORD dwLength;
    WORD wCount;
    WORD wConstPoolCount;
    WORD wConstPoolIndex;
    WORD wSignConstPoolIndex;
    WORD wAttrCount;
    WORD wAttrIndex;
    WORD wAttrName;
    WORD wSignAttrIndex;
    LONG lAddConstPoolOffset;
    int i;

    memset(&pPara->Read, 0, sizeof(pPara->Read));
    pPara->Read.fResult = TRUE;
    if (0xFFFFFFFF == SetFilePointer(
            pPara->Func.hFile,
            0,              // lDistanceToMove
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (fInit) {
        memset(&pPara->Digest, 0, sizeof(pPara->Digest));
        memset(&pPara->Sign, 0, sizeof(pPara->Sign));
    }

    // Default is to be digested. We'll disable where appropriate. Note,
    // skipped bytes are still digested.
    pPara->Digest.fDisableDigest = FALSE;

    // Read / skip the fields at the beginning of the class file
    if (ReadJavaU4(pPara) != JAVA_MAGIC) 
    {  // u4 magic
        SetLastError(ERROR_BAD_FORMAT);
        return FALSE;
    }
    SkipJavaBytes(pPara, 2 + 2);            // u2 minor_version
                                            // u2 major_version

    pPara->Digest.fDisableDigest = TRUE;
    wConstPoolCount = ReadJavaU2(pPara);    // u2 constant_pool_count
    pPara->Digest.fDisableDigest = FALSE;

    // For fInit, wSignConstPoolIndex has already been zeroed
    wSignConstPoolIndex = pPara->Sign.wSignConstPoolIndex;

    // Iterate through the constant pools. Don't digest the constant pool
    // containing the _digital_signature_ name (wSignConstPoolIndex).
    // For fInit, find the last "_digital_signature_".
    //
    // Note: constant pool index 0 isn't stored in the file.
    wConstPoolIndex = 1;
    while (wConstPoolIndex < wConstPoolCount) {
        BYTE bTag;

        if (wConstPoolIndex == wSignConstPoolIndex)
            pPara->Digest.fDisableDigest = TRUE;

        bTag = ReadJavaU1(pPara);
        switch (bTag) {
        case CONSTANT_Utf8:
            wLength = ReadJavaU2(pPara);
            if (fInit && wLength == SIGN_ATTR_NAME_LENGTH) {
                ReadJavaBytes(pPara, (BYTE *) rgchTmpSignAttrName,
                    SIGN_ATTR_NAME_LENGTH);
                if (memcmp(rgchSignAttrName, rgchTmpSignAttrName,
                        SIGN_ATTR_NAME_LENGTH) == 0) {
                    wSignConstPoolIndex = wConstPoolIndex;
                    pPara->Sign.lSignConstPoolOffset =
                        pPara->Read.lFileOffset - SIGN_CONST_POOL_LENGTH;

                }
            } else
                SkipJavaBytes(pPara, wLength);
            break;
        case CONSTANT_Unicode:
            wLength = ReadJavaU2(pPara);
            SkipJavaBytes(pPara, ((DWORD) wLength) * 2);
            break;
        case CONSTANT_Integer:
        case CONSTANT_Float:
        case CONSTANT_Long:
        case CONSTANT_Double:
        case CONSTANT_Class:
        case CONSTANT_String:
        case CONSTANT_Fieldref:
        case CONSTANT_Methodref:
        case CONSTANT_InterfaceMethodref:
        case CONSTANT_NameAndType:
            SkipJavaBytes(pPara, rgConstPoolLength[bTag]);
            break;
        default:
            SetLastError(ERROR_BAD_FORMAT);
            return FALSE;
        }
            
        pPara->Digest.fDisableDigest = FALSE;

        if (bTag == CONSTANT_Long || bTag == CONSTANT_Double)
            wConstPoolIndex += 2;
        else
            wConstPoolIndex++;
    }

    if (fInit) {
        lAddConstPoolOffset = pPara->Read.lFileOffset;
        if (wSignConstPoolIndex == 0) {
            // Didn't find a constant pool for the digital_signature. Update
            // with where it will need to be added
            wSignConstPoolIndex = wConstPoolCount;
            pPara->Sign.lSignConstPoolOffset = lAddConstPoolOffset;
        }
    }

    // Globble up and hash the bytes until we reach the attributes which are
    // at the end of the file.

    SkipJavaBytes(pPara, 2 + 2 + 2);        // u2 access_flags
                                            // u2 this_class
                                            // u2 super_class
    wCount = ReadJavaU2(pPara);             // u2 interfaces_count
    // u2 interfaces[interfaces_count]
    SkipJavaBytes(pPara, ((DWORD) wCount) * 2);

    // Since fields and methods have identical class file storage, do this
    // twice.
    i = 2;
    while (i--) {
        wCount = ReadJavaU2(pPara);         // u2 fields_count | methods_count
        while (wCount--) {
            SkipJavaBytes(pPara, 2 + 2 + 2);    // u2 access_flags
                                                // u2 name_index
                                                // u2 signature_index
            wAttrCount = ReadJavaU2(pPara);     // u2 attributes_count
            while (wAttrCount--) {
                SkipJavaBytes(pPara, 2);            // u2 attribute_name
                dwLength = ReadJavaU4(pPara);       // u4 attribute_length
                SkipJavaBytes(pPara, dwLength);     // u1 info[attribute_length]
            }
        }
    }

    // Finally, the attributes. This is where the signed data is

    pPara->Sign.lAttrCountOffset = pPara->Read.lFileOffset;
    pPara->Digest.fDisableDigest = TRUE;
    wAttrCount = ReadJavaU2(pPara);         // u2 attributes_count
    pPara->Digest.fDisableDigest = FALSE;

    if (fInit) {
        pPara->Sign.wAttrCount = wAttrCount;
        wSignAttrIndex = 0xFFFF;
    } else
        wSignAttrIndex = pPara->Sign.wSignAttrIndex;

    for (wAttrIndex = 0; wAttrIndex < wAttrCount; wAttrIndex++) {
        if (wAttrIndex == wSignAttrIndex)
            pPara->Digest.fDisableDigest = TRUE;

        wAttrName = ReadJavaU2(pPara);
        dwLength = ReadJavaU4(pPara);       // u4 attribute_length
        SkipJavaBytes(pPara, dwLength);     // u1 info[attribute_length]
        if (fInit && wAttrName == wSignConstPoolIndex && dwLength > 0 &&
                wSignConstPoolIndex < wConstPoolCount) {
            wSignAttrIndex = wAttrIndex;
            pPara->Sign.lSignAttrOffset =
                pPara->Read.lFileOffset - (ATTR_HDR_LENGTH + dwLength);
            pPara->Sign.dwSignAttrLength = dwLength;
        }

        pPara->Digest.fDisableDigest = FALSE;
    }

    if (fInit) {
        if (wSignAttrIndex == 0xFFFF) {
            // Didn't find an attribute for the digital_signature. Update
            // with where it will need to be added
            wSignAttrIndex = wAttrCount;
            pPara->Sign.lSignAttrOffset = pPara->Read.lFileOffset;

            // Also, force us to use a new const pool for the name of the
            // attribute
            wSignConstPoolIndex = wConstPoolCount;
            pPara->Sign.lSignConstPoolOffset = lAddConstPoolOffset;
        }

        pPara->Sign.wSignConstPoolIndex = wSignConstPoolIndex;
        pPara->Sign.wConstPoolCount = wConstPoolCount;
        pPara->Sign.wSignAttrIndex = wSignAttrIndex;
        pPara->Sign.lEndOfFileOffset = pPara->Read.lFileOffset;
    }

    // Now check if we got any hash or file errors while processing the file
    return pPara->Read.fResult;
}

//+-------------------------------------------------------------------------
//  Digest the appropriate bytes from a java file, for a digital signature.
//--------------------------------------------------------------------------
BOOL
JavaGetDigestStream(
    IN      HANDLE          FileHandle,
    IN      DWORD           DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));

    assert( DigestLevel == 0);
    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    Para.Digest.pfnDigestData = DigestFunction;
    Para.Digest.hDigestData = DigestHandle;

    if (!ProcessJavaClassFile( &Para, FALSE))
        goto ProcessJavaClassFileFalseError;

    fRet = TRUE;
CommonReturn:
    if (Para.Func.pbSignedData)
        ShpFree( Para.Func.pbSignedData);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileFalseError)
}


//+-------------------------------------------------------------------------
//  Add a digital signature to a java file.
//--------------------------------------------------------------------------
BOOL
JavaAddCertificate(
    IN      HANDLE              FileHandle,
    IN      LPWIN_CERTIFICATE   Certificate,
    OUT     PDWORD              Index
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));

    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    if (!SetSignedDataIntoJavaClassFile(
                (HSHPSIGNFILE)&Para,
                (PBYTE)&(Certificate->bCertificate),
                Certificate->dwLength - OFFSETOF(WIN_CERTIFICATE,bCertificate)))
        goto SetSignedDataIntoJavaClassFileError;

    fRet = TRUE;
CommonReturn:
    if (Para.Func.pbSignedData)
        ShpFree( Para.Func.pbSignedData);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,SetSignedDataIntoJavaClassFileError)
}


//+-------------------------------------------------------------------------
//  Remove a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaRemoveCertificate(
    IN      HANDLE   FileHandle,
    IN      DWORD    Index
    )
{
    return FALSE;       
}


//+-------------------------------------------------------------------------
//  Enum the digital signatures in a java file.
//--------------------------------------------------------------------------
BOOL
JavaEnumerateCertificates(
    IN      HANDLE  FileHandle,
    IN      WORD    TypeFilter,
    OUT     PDWORD  CertificateCount,
    IN OUT  PDWORD  Indices OPTIONAL,
    IN OUT  DWORD   IndexCount  OPTIONAL
    )
{
    return FALSE;       
}


//+-------------------------------------------------------------------------
//  Get a digital signature from a java file.
//--------------------------------------------------------------------------
static
BOOL
I_JavaGetCertificate(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    OUT     LPWIN_CERTIFICATE   Certificate,
    IN OUT OPTIONAL PDWORD      RequiredLength
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));
    BYTE       *pbSignedData = NULL;
    DWORD       cbSignedData;
    DWORD       cbCert;
    DWORD       dwError;

    if (CertificateIndex != 0)
        goto IndexNonZeroError;

    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    if (!GetSignedDataFromJavaClassFile(
                (HSHPSIGNFILE)&Para,
                &pbSignedData,
                &cbSignedData))
        goto GetSignedDataFromJavaClassFileError;

    cbCert = OFFSETOF(WIN_CERTIFICATE,bCertificate) + cbSignedData;
    dwError = 0;
    __try {
        if (RequiredLength) {
            // RequiredLength non-NULL only if getting cert data
            if (*RequiredLength < cbCert) {
                *RequiredLength = cbCert;
                dwError = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy( Certificate->bCertificate, pbSignedData, cbSignedData);
            }
        }
        if (dwError == 0) {
            Certificate->dwLength         = cbCert;
            Certificate->wRevision        = WIN_CERT_REVISION_1_0;
            Certificate->wCertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError) {
        SetLastError( dwError);
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }
CommonReturn:
    ShpFree( Para.Func.pbSignedData);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,IndexNonZeroError)
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,GetSignedDataFromJavaClassFileError)
}


//+-------------------------------------------------------------------------
//  Get a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaGetCertificateData(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    OUT     LPWIN_CERTIFICATE   Certificate,
    IN OUT  PDWORD              RequiredLength
    )
{
    BOOL        fRet;

    if (RequiredLength == NULL)
        goto RequiredLengthNullError;

    fRet = I_JavaGetCertificate(
                    FileHandle,
                    CertificateIndex,
                    Certificate,
                    RequiredLength
                    );

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(RequiredLengthNullError, ERROR_INVALID_PARAMETER)
}


//+-------------------------------------------------------------------------
//  Get the header of a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   Certificateheader
    )
{
    return I_JavaGetCertificate(
                    FileHandle,
                    CertificateIndex,
                    Certificateheader,
                    NULL
                    );
}

//+-------------------------------------------------------------------------
//  Seeks and writes bytes to file
//--------------------------------------------------------------------------
BOOL
SeekAndWriteFile(
    IN HANDLE hFile,
    IN DWORD lFileOffset,
    IN BYTE *pb,
    IN DWORD cb
    )
{
    DWORD cbWritten;

    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            lFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (!WriteFile(hFile, pb, cb, &cbWritten, NULL) || cbWritten != cb)
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Seeks and reads bytes from file
//--------------------------------------------------------------------------
BOOL
SeekAndReadFile(
    IN HANDLE hFile,
    IN DWORD lFileOffset,
    OUT BYTE *pb,
    IN DWORD cb
    )
{
    DWORD cbRead;

    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            lFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (!ReadFile(hFile, pb, cb, &cbRead, NULL) || cbRead != cb)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       peimage2.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    14-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    "global.hxx"

__inline DWORD AlignIt (DWORD Value, DWORD Alignment) { return (Value + (Alignment - 1)) & ~(Alignment -1); }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define MAP_READONLY  TRUE
#define MAP_READWRITE FALSE

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    BOOL fRC = FALSE;

    // Everything is mapped. Now check the image and find nt image headers

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            __leave;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                __leave;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)LoadedImage->FileHeader <
                    (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                __leave;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)DosHeader;
        }

        if ( LoadedImage->FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        }

        // No optional header indicates an object...

        if ( !LoadedImage->FileHeader->FileHeader.SizeOfOptionalHeader ) {
            __leave;
        }

        // Check for versions < 2.50

        if ( LoadedImage->FileHeader->OptionalHeader.MajorLinkerVersion < 3 &&
             LoadedImage->FileHeader->OptionalHeader.MinorLinkerVersion < 5 ) {
            __leave;
        }

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->NumberOfSections = LoadedImage->FileHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = IMAGE_FIRST_SECTION(LoadedImage->FileHeader);
        fRC = TRUE;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) { }

    return fRC;
}

BOOL
MapIt(
    HANDLE hFile,
    PLOADED_IMAGE LoadedImage
    )
{
    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return FALSE;
    }

    LoadedImage->MappedAddress = (PUCHAR) MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMappedFile);

    LoadedImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!LoadedImage->MappedAddress) {
        return (FALSE);
    }

    if (!CalculateImagePtrs(LoadedImage)) {
        UnmapViewOfFile(LoadedImage->MappedAddress);
        return(FALSE);
    }

    LoadedImage->hFile = INVALID_HANDLE_VALUE;

    return(TRUE);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = new EXCLUDE_RANGE;

            if(m_ExRange)
                memset(m_ExRange, 0x00, sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp)
            {
                DELETE_OBJECT(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            DELETE_OBJECT(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size
    )
{
    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = new EXCLUDE_RANGE;

    if(pTmp)
    {
        pTmp->Next = pExRange->Next;
        pTmp->Offset = (PBYTE)Offset;
        pTmp->Size = Size;
        pExRange->Next = pTmp;
    }

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


BOOL
imagehack_IsImagePEOnly(
    IN HANDLE           FileHandle
    )
/*
   What we're looking for here is if there's data outside the exe.
   To do so, find the highest section header offset.  To that, find the
   highest debug directory offset.  Finally, round up to the file alignment
   size, add in the cert size, and compare to the reported image size...
*/
{
    LOADED_IMAGE    LoadedImage;
    DWORD HighOffset;
    DWORD i, Offset, Size;
    LONG DebugDirectorySize, CertSize;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    PVOID CertDir;
    BOOL rc;
    DWORD FileAlignment;
    DWORD NumberOfSections;

    if (MapIt(FileHandle, &LoadedImage) == FALSE) {
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            FileAlignment = ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.FileAlignment;
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            FileAlignment = ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.FileAlignment;
        } else {
            __leave;
        }

        NumberOfSections =  LoadedImage.FileHeader->FileHeader.NumberOfSections;
        HighOffset = 0;

        for (i = 0; i < NumberOfSections; i++) {
            Offset = LoadedImage.Sections[i].PointerToRawData;
            Size = LoadedImage.Sections[i].SizeOfRawData;
            HighOffset = max(HighOffset, (Offset + Size));
        }

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                          ImageDirectoryEntryToData(
                            LoadedImage.MappedAddress,
                            FALSE,
                            IMAGE_DIRECTORY_ENTRY_DEBUG,
                            (ULONG *) &DebugDirectorySize
                          );

        while (DebugDirectorySize > 0) {
            Offset = DebugDirectory->PointerToRawData;
            Size = DebugDirectory->SizeOfData;
            HighOffset = max(HighOffset, (Offset + Size));
            DebugDirectorySize -= sizeof(IMAGE_DEBUG_DIRECTORY);
            DebugDirectory++;
        }

        HighOffset = AlignIt(HighOffset, FileAlignment);

        CertDir = (PVOID) ImageDirectoryEntryToData(
                            LoadedImage.MappedAddress,
                            FALSE,
                            IMAGE_DIRECTORY_ENTRY_SECURITY,
                            (ULONG *) &CertSize
                          );

        if (LoadedImage.SizeOfImage <= (HighOffset + CertSize)) {
            rc = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnmapViewOfFile(LoadedImage.MappedAddress);

    return(rc);
}

BOOL
imagehack_AuImageGetDigestStream(
    IN HANDLE           FileHandle,
    IN DWORD            DigestLevel,
    IN DIGEST_FUNCTION  DigestFunction,
    IN DIGEST_HANDLE    DigestHandle
    )

/*++

Routine Description:
    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_ALL_BUT_CERTS - Include data outside the PE image itself
                                                              (may include non-mapped debug symbolic)

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    BOOL            rc;
    EXCLUDE_LIST    ExList;

    if (MapIt(FileHandle, &LoadedImage) == FALSE) {
        // Unable to map the image or invalid digest level.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    __try {

        if ((LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            (LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC))
        {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.CheckSum),
                       sizeof(NtHeader32->OptionalHeader.CheckSum));

            // Exclude the Security directory.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]),
                       sizeof(NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]));

            // Exclude the certs.
            ExList.Add((DWORD_PTR)NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress +
                                (DWORD_PTR)LoadedImage.MappedAddress,
                       NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
        } else {
            PIMAGE_NT_HEADERS64 NtHeader64 = (PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.CheckSum),
                       sizeof(NtHeader64->OptionalHeader.CheckSum));

            // Exclude the Security directory.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]),
                       sizeof(NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]));

            // Exclude the certs.
            ExList.Add((DWORD_PTR)NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress +
                                (DWORD_PTR)LoadedImage.MappedAddress,
                       NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
        }

        ExList.Emit((PBYTE) (LoadedImage.MappedAddress), LoadedImage.SizeOfImage);
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnmapViewOfFile(LoadedImage.MappedAddress);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjct.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjCT.cpp (Catalog)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    24-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjct.hxx"
#include    "mscat.h"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectCatalog_::SIPObjectCatalog_(DWORD id) : SIPObject_(id)
{
}


////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectCatalog_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                       DWORD *pdwDLen,BYTE *pbData,
                                       DWORD *pdwEncodeType)
{

    if ((dwIdx != 0) ||
        (!(pdwEncodeType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (pSI->dwUnionChoice == MSSIP_ADDINFO_BLOB)
    {
        if (!(pSI->psBlob) ||
            !(_ISINSTRUCT(MS_ADDINFO_BLOB, pSI->psBlob->cbStruct, pbMemSignedMsg)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        if (!(pbData))
        {
            *pdwDLen = pSI->psBlob->cbMemObject;
            return(TRUE);
        }

        if (*pdwDLen < pSI->psBlob->cbMemObject)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        memcpy(pbData, pSI->psBlob->pbMemObject, pSI->psBlob->cbMemObject);

        return(TRUE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
         *pdwEncodeType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

        if (!(pbData))
        {
            *pdwDLen = this->cbFileMap;
            return(TRUE);
        }

        if (this->cbFileMap > *pdwDLen)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        __try {

        memcpy(pbData, this->pbFileMap, this->cbFileMap);

        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(GetExceptionCode());
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObjectCatalog_::PutSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD *dwIdx,
                      DWORD dwDLen,BYTE *pbData,
                      DWORD dwEncodeType)
{
    if (!(pbData))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    this->fUseFileMap = FALSE;

    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ))
    {

        if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            return(FALSE);
        }

        SetEndOfFile(this->hFile);

        DWORD   cbWritten;

        cbWritten = 0;

        if (!(WriteFile(this->hFile, pbData, dwDLen, &cbWritten, NULL)) ||
            (cbWritten != dwDLen))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObjectCatalog_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                        SIP_INDIRECT_DATA *psData)
{
    if (pdwDLen)
    {
        *pdwDLen = 0;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjfl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjFL.cpp    (Flat)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjfl.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectFlat_::SIPObjectFlat_(DWORD id) : SIPObject_(id)
{
    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectFlat_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                     DWORD *pdwDLen,BYTE *pbData,
                                     DWORD *pdwEncodeType)
{
    *pdwDLen = 0;
    *pdwEncodeType  = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    return(TRUE);
}

BOOL SIPObjectFlat_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                      SIP_INDIRECT_DATA *psData)
{
    MS_ADDINFO_FLAT             *pAddInfo;
    SIP_INDIRECT_DATA           *pInd;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSI->cbSize, dwUnionChoice)) ||
        !(pSI->psFlat) ||
        !(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        return(FALSE);
    }

    if ((pSI->dwUnionChoice == MSSIP_ADDINFO_FLAT) &&
        (pSI->psFlat->cbStruct == sizeof(MS_ADDINFO_FLAT)))
    {
        pInd = pSI->psFlat->pIndirectData;
    }
    else if ((pSI->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
             (pSI->psCatMember->cbStruct == sizeof(MS_ADDINFO_CATALOGMEMBER)))
    {
        if (!(pSI->psCatMember->pMember) ||
            (pSI->psCatMember->pMember->cbStruct != sizeof(CRYPTCATMEMBER)) ||
            !(pSI->psCatMember->pMember->pIndirectData))
        {
            if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
            {
                SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            }
            return(FALSE);
        }

        pInd = pSI->psCatMember->pMember->pIndirectData;
    }
    else
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   cbDigest;
        BYTE    *pbDigest;

        if (!(pbDigest = this->DigestFile(  pSI->hProv,
                                            0,
                                            pInd->DigestAlgorithm.pszObjId,
                                            &cbDigest)))
        {
            return(FALSE);
        }

        if ((cbDigest != pInd->Digest.cbData) ||
            (memcmp(pbDigest, pInd->Digest.pbData, cbDigest) != 0))
        {
            delete pbDigest;

            SetLastError(TRUST_E_BAD_DIGEST);
            return(FALSE);
        }

        delete pbDigest;

        return(TRUE);
    }

    return(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectFlat_::GetDigestStream(DIGEST_DATA *pDigestData,
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    __try {

    if ((this->pbFileMap) && (this->cbFileMap > 0))
    {
        return(pfnCallBack((HSPCDIGESTDATA)pDigestData, this->pbFileMap, this->cbFileMap));
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjcb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjCB.cpp    (CAB)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjcb.hxx"

#include    "sha.h"
#include    "md5.h"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectCAB_::SIPObjectCAB_(DWORD id) : SIPObject_(id)
{
    memset(&Para, 0x00, sizeof(CAB_PARA));

    fUseV1Sig           = FALSE;
}

SIPObjectCAB_::~SIPObjectCAB_(void)
{
    FreeHeader();
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectCAB_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(this->RemoveCertificate(dwIdx));
    }

    return(FALSE);
}

BOOL SIPObjectCAB_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                   SIP_INDIRECT_DATA *psData)
{
    BOOL                    fRet;
    BYTE                    *pbDigest;
    BYTE                    *pbAttrData;

    SPC_LINK                SpcLink;
    DWORD                   cbDigest;
    HCRYPTPROV              hProvT;


    pbDigest    = NULL;
    pbAttrData  = NULL;
    fRet        = TRUE;

    hProvT = pSI->hProv;

    if (!(hProvT))
    {
        if (!(this->LoadDefaultProvider()))
        {
            goto GetProviderFailed;
        }

        hProvT = this->hProv;
    }

    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;

    if (!(psData))
    {
        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier...
            // obj id
        dwRetLen += strlen(pSI->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term.
            // parameters (none)...

        // crypt_attribute_type_value size...
        dwRetLen += strlen(this->GetDataObjectID());
        dwRetLen += 1; // null term.

        // size of the value
        dwEncLen = 0;
        CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            this->GetDataOIDHint(),
                            &SpcLink,
                            NULL,
                            &dwEncLen);

        if (dwEncLen < 1)
        {
            goto EncodeError;
        }

        dwRetLen += dwEncLen;

        if ((dwAlgId = CertOIDToAlgId(pSI->DigestAlgorithm.pszObjId)) == 0)
        {
            goto BadAlgId;
        }

        switch (dwAlgId)
        {
            case CALG_MD5:
                cbDigest = MD5DIGESTLEN;
                break;

            case CALG_SHA1:
                cbDigest = A_SHA_DIGEST_LEN;
                break;

            default:
                if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash)))
                {
                    goto CreateHashFailed;
                }

                // just to get hash length
                if (!(CryptHashData(hHash,(const BYTE *)" ",1,0)))
                {
                    CryptDestroyHash(hHash);

                    goto HashDataFailed;
                }

                cbDigest = 0;

                CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

                CryptDestroyHash(hHash);
        }


        dwRetLen += cbDigest;
        *pdwDLen = dwRetLen;

        goto CommonReturn;
    }

    if (!(this->FileHandleFromSubject(pSI, (pSI->dwFlags & MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE) ?
                                                    GENERIC_READ : (GENERIC_READ | GENERIC_WRITE))))
    {
        goto SubjectFileFailure;
    }

    //
    //  version 1 had the signature in the header.  We want
    //  the signature at the end and our structure in the
    //  header where the signature used to be.  -- check it.
    //
    if (!(pSI->dwFlags & MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE))
    {
        if (!(this->ReadHeader()))
        {
            goto ReadHeaderFailed;
        }

        if (!(this->ReserveSignedData(sizeof(CABSignatureStruct_))))
        {
            goto ReserveDataFailed;
        }

        if (!(this->MapFile()))
        {
            goto MapFileFailed;
        }
    }

    if (!(pbDigest = this->DigestFile(hProvT, 0, pSI->DigestAlgorithm.pszObjId, &cbDigest)))
    {
        goto DigestFileFailed;
    }

    DWORD_PTR dwOffset;
    DWORD   dwRetLen;

    dwRetLen = 0;

    CryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(), &SpcLink,
                        NULL, &dwRetLen);

    if (dwRetLen < 1)
    {
        goto EncodeError;
    }

    if (!(pbAttrData = (BYTE *)this->SIPNew(dwRetLen)))
    {
        goto MemoryError;
    }

    if (!(CryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(), &SpcLink,
                            pbAttrData, &dwRetLen)))
    {
        goto EncodeError;
    }

    dwOffset =    (DWORD_PTR)psData + sizeof(SIP_INDIRECT_DATA);

    strcpy((char *)dwOffset, this->GetDataObjectID());
    psData->Data.pszObjId   = (LPSTR)dwOffset;
    dwOffset += (strlen(SPC_LINK_OBJID) + 1);

    memcpy((void *)dwOffset, pbAttrData,dwRetLen);
    psData->Data.Value.pbData   = (BYTE *)dwOffset;
    psData->Data.Value.cbData   = dwRetLen;
    dwOffset += dwRetLen;

    strcpy((char *)dwOffset, (char *)pSI->DigestAlgorithm.pszObjId);
    psData->DigestAlgorithm.pszObjId            = (char *)dwOffset;
    psData->DigestAlgorithm.Parameters.cbData   = 0;
    psData->DigestAlgorithm.Parameters.pbData   = NULL;
    dwOffset += (strlen(pSI->DigestAlgorithm.pszObjId) + 1);

    memcpy((void *)dwOffset,pbDigest,cbDigest);
    psData->Digest.pbData   = (BYTE *)dwOffset;
    psData->Digest.cbData   = cbDigest;

CommonReturn:

    if (pbDigest)
    {
        delete pbDigest;
    }

    if (pbAttrData)
    {
        delete pbAttrData;
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, EncodeError);
    TRACE_ERROR_EX(DBG_SS, SubjectFileFailure);
    TRACE_ERROR_EX(DBG_SS, HashDataFailed);
    TRACE_ERROR_EX(DBG_SS, CreateHashFailed);
    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, ReserveDataFailed);
    TRACE_ERROR_EX(DBG_SS, MapFileFailed);
    TRACE_ERROR_EX(DBG_SS, DigestFileFailed);
    TRACE_ERROR_EX(DBG_SS, GetProviderFailed);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,   ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, BadAlgId,      NTE_BAD_ALGID);
}

////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectCAB_::GetMessageFromFile(SIP_SUBJECTINFO *pSI,
                                      WIN_CERTIFICATE *pWinCert,
                                      DWORD dwIndex,DWORD *pcbCert)
{
    DWORD       cbCert;

    if (dwIndex != 0)
    {
        goto InvalidParam;
    }

    if (!(this->ReadHeader()))
    {
        goto ReadHeaderFailed;
    }

    if (Para.Hdr.cbSig == 0)
    {
        goto NoSignature;
    }

    if (!(fUseV1Sig))
    {
        //
        //  Version 2 header
        //

        cbCert          = OFFSETOF(WIN_CERTIFICATE, bCertificate) +
                          Para.Hdr.pCabSigStruct->cbSig;

        if (*pcbCert < cbCert)
        {
            *pcbCert = cbCert;

            goto BufferTooSmall;
        }

        if (pWinCert)
        {
            if (!(this->ReadSignedData(pWinCert->bCertificate)))
            {
                goto ReadSignedFailed;
            }

        }
    }
    else
    {
        //
        //  Version 1 header
        //
        cbCert          = OFFSETOF(WIN_CERTIFICATE, bCertificate) + Para.Hdr.cbSig;

        if (*pcbCert < cbCert)
        {
            *pcbCert = cbCert;

            goto BufferTooSmall;
        }

        if (pWinCert)
        {
            BYTE    *pbSignedData;

            pbSignedData = Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk;

            pWinCert->wRevision = WIN_CERT_REVISION_1_0;

            memcpy(pWinCert->bCertificate, pbSignedData, Para.Hdr.cbSig);
        }
    }

    pWinCert->dwLength          = cbCert;
    pWinCert->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;

    return(TRUE);

ErrorReturn:
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, ReadSignedFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, BufferTooSmall,ERROR_INSUFFICIENT_BUFFER);
    SET_ERROR_VAR_EX(DBG_SS, NoSignature,   TRUST_E_NOSIGNATURE);
}

BOOL SIPObjectCAB_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->ReadHeader())
    {
        if (!(fUseV1Sig))
        {
            //
            //  version 2
            //
            if (this->WriteSignedData((BYTE *)&(pWinCert->bCertificate),
                                      pWinCert->dwLength -
                                      OFFSETOF(WIN_CERTIFICATE, bCertificate)))
            {
                return(TRUE);
            }
        }
        else
        {
            //
            //  version 1
            //
            DWORD   dwCheck;
            DWORD   cbSignedData;

            cbSignedData    = pWinCert->dwLength - OFFSETOF(WIN_CERTIFICATE, bCertificate);

            dwCheck = RESERVE_LEN_ALIGN(RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk + cbSignedData) -
                        Para.Hdr.cfres.cbCFHeader;

            if (dwCheck > 0)
            {
                SetLastError(CRYPT_E_FILERESIZED);
                return(FALSE);
            }


            if (WriteSignedDataV1((PBYTE)&(pWinCert->bCertificate), cbSignedData))
            {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOL SIPObjectCAB_::GetDigestStream(DIGEST_DATA *pDigestData,
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    if (dwFlags != 0)
    {
        goto InvalidParam;
    }

    if (!(this->ReadHeader()))
    {
        goto ReadHeaderFailed;
    }

    if (!(this->DigestHeader(pfnCallBack, pDigestData)))
    {
        goto DigestFailed;
    }

    DWORD   cbRemain;

    cbRemain = this->cbFileMap - Para.Hdr.cbTotalHdr;

    if (!(fUseV1Sig) && (Para.Hdr.pCabSigStruct))
    {
        cbRemain -= Para.Hdr.pCabSigStruct->cbSig;
    }

    if ((Para.Hdr.cfheader.cbCabinet - Para.Hdr.cbTotalHdr) != cbRemain)
    {
        goto BadFileFormat;
    }

    if (this->cbFileMap < (Para.Hdr.cbTotalHdr + cbRemain))
    {
        goto BadFileFormat;
    }

    __try {

    if (!(pfnCallBack(pDigestData, &this->pbFileMap[Para.Hdr.cbTotalHdr], cbRemain)))
    {
        goto HashFailed;
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto HashFailed;
    }


    return(TRUE);

ErrorReturn:
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, DigestFailed);
    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, HashFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, BadFileFormat, ERROR_BAD_FORMAT);
}


////////////////////////////////////////////////////////////////////////////
//
// private:
//

BOOL SIPObjectCAB_::RemoveCertificate(DWORD Index)
{
    return(FALSE);   // not yet!!! Currently, we only support 1.

#   ifdef _DONT_USE_YET

        BYTE            *pbFolders;
        DWORD           cbFolders;
        BYTE            *pbReserve;
        USHORT          cbReserve;

        if (Index != 0)
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        pbFolders   = NULL;
        cbFolders   = 0;

        Para.dwFlags = VERIFY_CAB_FLAG;

        if (this->ReadHeader())
        {
            if (Para.Hdr.cbSig <= (RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk))
            {
                SetLastError((DWORD)CRYPT_E_NO_MATCH);
                return(FALSE);
            }

            long    lShift;

            if (Para.Hdr.cbJunk)
            {
                lShift                                                  = Para.Hdr.cbSig;
                if (Para.Hdr.pbReserve)
                {
                    *((USHORT *)Para.Hdr.pbReserve)                     = Para.Hdr.cbJunk;
                    *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)))  = 0;    // no more sig
                }
            }
            else
            {
                lShift                  = Para.Hdr.cbSig + (sizeof(USHORT) * 2);
                Para.Hdr.cfheader.flags &= ~(cfhdrRESERVE_PRESENT);
                if (Para.Hdr.pbReserve)
                {
                    delete Para.Hdr.pbReserve;
                    Para.Hdr.pbReserve = NULL;
                }
            }

            Para.Hdr.cbSig              = 0;
            Para.Hdr.cfres.cbCFHeader   -= (USHORT)lShift;  // subtract the amount we want to shrink.

            // adjust the header offsets
            if (this->ShiftFileBytes(lShift))
            {
                Para.Hdr.cbTotalHdr         -= lShift;
                Para.Hdr.cfheader.cbCabinet -= lShift;
                Para.Hdr.cfheader.coffFiles -= lShift;
            }

            // redo checksums....
            this->ChecksumHeader();

            if (this->WriteHeader())
            {
                // We need to read in the folders to adjust their CFDATA file offset
                if (Para.Hdr.cfheader.cFolders)
                {
                    if (SetFilePointer(this->hFile,
                                        Para.Hdr.cbTotalHdr + lShift,
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        return(FALSE);
                    }

                    USHORT  cFolders;
                    LONG    cbFolder;

                    cFolders    = Para.Hdr.cfheader.cFolders;
                    cbFolder    = sizeof(CFFOLDER) + Para.Hdr.cfres.cbCFFolder;
                    cbFolders   = cbFolder * cFolders;

                    if (!(pbFolders = (BYTE *)this->SIPNew(cbFolders)))
                    {
                        return(FALSE);
                    }
                    DWORD   cbFile;

                    if (!(ReadFile(this->hFile, pbFolders, cbFolders, &cbFile, NULL)) ||
                         (cbFile != cbFolders))
                    {
                        delete pbFolders;
                        SetLastError(ERROR_BAD_FORMAT);
                        return(FALSE);
                    }


                    BYTE    *pb;

                    pb = pbFolders;

                    while (cFolders > 0)
                    {
                        ((CFFOLDER *)pb)->coffCabStart -= lShift;
                        pb += cbFolder;
                        cFolders--;
                    }

                    // back up and write!
                    if (SetFilePointer(this->hFile, -((LONG)cbFolders),
                                        NULL, FILE_CURRENT) == 0xFFFFFFFF)
                    {
                        delete pbFolders;
                        return(FALSE);
                    }

                    if (!(WriteFile(this->hFile, pbFolders, cbFolders, &cbFile, NULL)) ||
                            (cbFile != cbFolders))
                    {
                        delete pbFolders;
                        return(FALSE);
                    }

                    delete pbFolders;
                }

                return(TRUE);
            }
        }

        return(FALSE);

#   endif // _DONT_USE_YET
}

BOOL SIPObjectCAB_::ReadSignedData(BYTE *pbRet)
{
    //
    //  this function is NOT called for version 1 Sigs!
    //

    if (Para.Hdr.pCabSigStruct->cbFileOffset != (DWORD)Para.Hdr.cfheader.cbCabinet)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    if (this->cbFileMap < (Para.Hdr.pCabSigStruct->cbFileOffset +
                           Para.Hdr.pCabSigStruct->cbSig))
    {
        SetLastError(ERROR_BAD_FORMAT);
        return(FALSE);
    }

    __try {
    memcpy(pbRet, &this->pbFileMap[Para.Hdr.pCabSigStruct->cbFileOffset], Para.Hdr.pCabSigStruct->cbSig);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return(FALSE);
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::WriteSignedData(BYTE *pbSig, DWORD cbSig)
{
    //
    //  this function is NOT called for version 1 Sigs!
    //

    if (!(pbSig) || (cbSig == 0))
    {
        return(FALSE);
    }

    CABSignatureStruct_     sSig;

    memset(&sSig, 0x00, sizeof(CABSignatureStruct_));

    sSig.cbFileOffset   = Para.Hdr.cfheader.cbCabinet;
    sSig.cbSig          = cbSig;

    memcpy(Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk,
            &sSig, sizeof(CABSignatureStruct_));

    if (!(this->WriteHeader()))
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, Para.Hdr.cfheader.cbCabinet, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    DWORD   cbWritten;

    if (!(WriteFile(this->hFile, pbSig, cbSig, &cbWritten, NULL)) ||
        (cbWritten != cbSig))
    {
        return(FALSE);
    }

    this->UnmapFile();

    SetEndOfFile(this->hFile);    // signature is the LAST thing!!!

    return(this->MapFile());
}

BOOL SIPObjectCAB_::WriteSignedDataV1(BYTE *pbSignedData, DWORD cbSignedData)
{
    if (!(pbSignedData) || (cbSignedData == 0))
    {
        return(FALSE);
    }

    memcpy(Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk,
                        pbSignedData, cbSignedData);
    Para.Hdr.cbSig = (USHORT)cbSignedData;

    ChecksumHeader();

    return(this->WriteHeader());
}

BOOL SIPObjectCAB_::ReadHeader(void)
{
    DWORD   cbOffset;
    BOOL    fRet;

    this->FreeHeader();

    if (this->cbFileMap < sizeof(Para.Hdr.cfheader))
    {
        goto BadCABFormat;
    }

    __try {

    memcpy(&Para.Hdr.cfheader, &this->pbFileMap[0], sizeof(Para.Hdr.cfheader));

    cbOffset = sizeof(Para.Hdr.cfheader);

    if (Para.Hdr.cfheader.sig != sigCFHEADER)
    {
        goto BadCABFormat;
    }

    if (Para.Hdr.cfheader.flags & cfhdrRESERVE_PRESENT)
    {
        if (this->cbFileMap < (cbOffset + sizeof(Para.Hdr.cfres)))
        {
            goto BadCABFormat;
        }

        memcpy(&Para.Hdr.cfres, &this->pbFileMap[cbOffset], sizeof(Para.Hdr.cfres));

        cbOffset += sizeof(Para.Hdr.cfres);

        Para.Hdr.cbcfres = sizeof(Para.Hdr.cfres);

        if (Para.Hdr.cfres.cbCFHeader > 0)
        {
            if (Para.Hdr.pbReserve = (BYTE *)this->SIPNew(Para.Hdr.cfres.cbCFHeader))
            {
                if (this->cbFileMap < (cbOffset + Para.Hdr.cfres.cbCFHeader))
                {
                    goto BadCABFormat;
                }

                memcpy(Para.Hdr.pbReserve, &this->pbFileMap[cbOffset], Para.Hdr.cfres.cbCFHeader);

                cbOffset += Para.Hdr.cfres.cbCFHeader;

                if (Para.Hdr.cfres.cbCFHeader >= RESERVE_CNT_HDR_LEN)
                {
                    Para.Hdr.cbJunk = *((USHORT *)Para.Hdr.pbReserve);
                    Para.Hdr.cbSig  = *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)));

                    if (RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk + Para.Hdr.cbSig > Para.Hdr.cfres.cbCFHeader)
                    {
                        goto BadCABFormat;
                    }

                    if (Para.Hdr.cbSig == sizeof(CABSignatureStruct_))
                    {
                        fUseV1Sig = FALSE;

                        Para.Hdr.pCabSigStruct = (CABSignatureStruct_ *)(Para.Hdr.pbReserve +
                                                                         RESERVE_CNT_HDR_LEN +
                                                                         Para.Hdr.cbJunk);
                    }
                    else
                    {
                        fUseV1Sig = TRUE;
                    }
                }
            }
        }
    }

    DWORD   cStrings;
    DWORD   cb;

    cStrings = 0;

    if (Para.Hdr.cfheader.flags & cfhdrPREV_CABINET)
    {
        cStrings += 2;
    }

    if (Para.Hdr.cfheader.flags & cfhdrNEXT_CABINET)
    {
        cStrings += 2;
    }

    if (cStrings > 0)
    {
        // First read to get total length of all the strings
        cb = 0;
        for (; cStrings > 0; cStrings--)
        {
            while (this->pbFileMap[cbOffset + cb])
            {
                cb++;

                if (this->cbFileMap < (cbOffset + cb))
                {
                    goto BadCABFormat;
                }
            }

            //Increment the counter for the NULL terminator
            cb++;
        }

        if (!(Para.Hdr.pbStrings = new BYTE[cb]))
        {
            goto MemoryError;
        }

        Para.Hdr.cbStrings  = cb;

        memcpy(Para.Hdr.pbStrings, &this->pbFileMap[cbOffset], cb);

        cbOffset += cb;
    }

    Para.Hdr.cbTotalHdr = sizeof(Para.Hdr.cfheader) + Para.Hdr.cbcfres +
                            Para.Hdr.cfres.cbCFHeader + Para.Hdr.cbStrings;

    if ((long)Para.Hdr.cbTotalHdr > Para.Hdr.cfheader.cbCabinet)
    {
        goto BadCABFormat;
    }

    fRet = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, BadCABFormat, ERROR_BAD_FORMAT);
    SET_ERROR_VAR_EX(DBG_SS, MemoryError,  ERROR_NOT_ENOUGH_MEMORY);
}

void SIPObjectCAB_::FreeHeader(void)
{
    DELETE_OBJECT(Para.Hdr.pbReserve);
    DELETE_OBJECT(Para.Hdr.pbStrings);

    memset(&Para, 0x00, sizeof(CAB_PARA));
}

BOOL SIPObjectCAB_::WriteHeader(void)
{
    DWORD cbWritten;

    // Position at beginning of file
    if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    if (!(WriteFile(this->hFile, &Para.Hdr.cfheader, sizeof(Para.Hdr.cfheader),
                        &cbWritten, NULL)) ||
        (cbWritten != sizeof(Para.Hdr.cfheader)))
    {
        return(FALSE);
    }

    if (Para.Hdr.cbcfres)
    {
        if (!(WriteFile(this->hFile, &Para.Hdr.cfres, sizeof(Para.Hdr.cfres),
                        &cbWritten, NULL)) ||
            (cbWritten != sizeof(Para.Hdr.cfres)))
        {
            return(FALSE);
        }

        if (Para.Hdr.pbReserve)
        {
            *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)))  = Para.Hdr.cbSig;

            if (!(WriteFile(this->hFile, Para.Hdr.pbReserve, Para.Hdr.cfres.cbCFHeader,
                                &cbWritten, NULL)) ||
                (cbWritten != Para.Hdr.cfres.cbCFHeader))
            {
                return(FALSE);
            }
        }
    }

    if (Para.Hdr.pbStrings)
    {
        if (!(WriteFile(this->hFile, Para.Hdr.pbStrings, Para.Hdr.cbStrings,
                            &cbWritten, NULL)) ||
            (cbWritten != Para.Hdr.cbStrings))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::ShiftFileBytes(LONG lbShift)
{
    LONG    lStartOffset;
    LONG    lEndOffset;
    LONG    lNewEndOffset;
    LONG    cbTotalMove;
    LONG    cbMove;

    lStartOffset    = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT);
    lEndOffset      = (LONG)this->cbFileMap;

    lNewEndOffset   = lEndOffset + lbShift;
    cbTotalMove     = lEndOffset - lStartOffset;

    BYTE    szMove[512];

    while (cbTotalMove)
    {
        cbMove = min(cbTotalMove, sizeof(szMove));

        if (lbShift > 0)
        {
            if (!(SeekAndReadFile(lEndOffset - cbMove, &szMove[0], cbMove)))
            {
                return(FALSE);
            }
            if (!(SeekAndWriteFile((lEndOffset - cbMove) + lbShift, &szMove[0], cbMove)))
            {
                return(FALSE);
            }

            lEndOffset -= cbMove;
        }
        else if (lbShift < 0)
        {
            if (!(SeekAndReadFile(lStartOffset, &szMove[0], cbMove)))
            {
                return(FALSE);
            }
            if (!(SeekAndWriteFile(lStartOffset + lbShift, &szMove[0], cbMove)))
            {
                return(FALSE);
            }

            lStartOffset += cbMove;
        }

        cbTotalMove -= cbMove;
    }

    //
    // Set end of file
    //
    if (SetFilePointer(this->hFile, lNewEndOffset, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    this->UnmapFile();

    SetEndOfFile(this->hFile);

    return(this->MapFile());
}


BOOL SIPObjectCAB_::ReserveSignedData(DWORD cbSignedData)
{
    LONG    lbShift;
    USHORT  cbReserve;


    if (cbSignedData != sizeof(CABSignatureStruct_))
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, Para.Hdr.cbTotalHdr, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    fUseV1Sig           = FALSE;

    //
    // Calculate length needed for CFRESERVE's abReserve[] and allocate
    //
    cbReserve = (USHORT)(RESERVE_LEN_ALIGN(RESERVE_CNT_HDR_LEN +
                Para.Hdr.cbJunk + cbSignedData));

    //
    // Calculate number of bytes to grow or shrink the cab file
    //
    lbShift = cbReserve - Para.Hdr.cfres.cbCFHeader;

    //
    //  we're alread a v1 cab!
    //
    if (lbShift == 0)
    {
        return(TRUE);
    }

    BYTE    *pbReserve;
    BYTE    *pbFolders;
    DWORD   cbFolders;

    pbFolders   = NULL;
    cbFolders   = 0;


    if (!(pbReserve = (BYTE *)this->SIPNew(cbReserve)))
    {
        return(FALSE);
    }

    memset(pbReserve, 0x00, cbReserve);

    //
    // Update allocated abReserve[] with counts and old junk
    //
    if (Para.Hdr.cbJunk)
    {
        *((USHORT *)pbReserve) = Para.Hdr.cbJunk;
        memcpy(pbReserve + RESERVE_CNT_HDR_LEN,
                Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN, Para.Hdr.cbJunk);
    }
    *((USHORT *)(pbReserve + sizeof(USHORT))) = (USHORT)cbSignedData;

    //
    // Update Hdr's CFRESERVE abReserve[] to reflect above changes
    //
    if (Para.Hdr.pbReserve)
    {
        delete Para.Hdr.pbReserve;
        Para.Hdr.pbReserve = NULL;
    }
    Para.Hdr.pbReserve          = pbReserve;
    Para.Hdr.cfres.cbCFHeader   = cbReserve;
    Para.Hdr.cbSig              = (USHORT)cbSignedData;

    if (Para.Hdr.cbcfres == 0)
    {
        // Need to add CFRESERVE record
        Para.Hdr.cfheader.flags |= cfhdrRESERVE_PRESENT;
        Para.Hdr.cbcfres        = sizeof(CFRESERVE);
        lbShift                 += sizeof(CFRESERVE);
    }

    //
    // We need to read in the folders to adjust their CFDATA file offset
    //
    if (Para.Hdr.cfheader.cFolders)
    {
        USHORT  cFolders;
        LONG    cbFolder;
        BYTE    *pb;
        DWORD   cbRead;

        cFolders    = Para.Hdr.cfheader.cFolders;
        cbFolder    = sizeof(CFFOLDER) + Para.Hdr.cfres.cbCFFolder;
        cbFolders   = cbFolder * cFolders;

        if (!(pbFolders = (BYTE *)this->SIPNew(cbFolders)))
        {
            return(FALSE);
        }

        if (!(ReadFile(this->hFile, pbFolders, cbFolders, &cbRead, NULL)) ||
            (cbRead != cbFolders))
        {
            delete pbFolders;
            SetLastError(ERROR_BAD_FORMAT);
            return(FALSE);
        }

        pb = pbFolders;

        for (; cFolders > 0; cFolders--, pb += cbFolder)
        {
            ((CFFOLDER *) pb)->coffCabStart += lbShift;
        }
    }

    //
    // We need to shift the remaining contents of the cab file (CFFILE (s)
    // and CFDATA (s)) by lbShift
    //
    if (!(ShiftFileBytes(lbShift)))
    {
        if (pbFolders)
        {
            delete pbFolders;
        }
        return(FALSE);
    }

    //
    // Update lengths and offsets in the header by the delta shift needed
    // to store the signed data.
    //
    Para.Hdr.cbTotalHdr         += lbShift;
    Para.Hdr.cfheader.cbCabinet += lbShift;
    Para.Hdr.cfheader.coffFiles += lbShift;

    //
    //  pberkman - if someone starts using these, we don't want to mess them up!!!
    //
    // Para.Hdr.cfheader.csumHeader    = 0;
    // Para.Hdr.cfheader.csumFolders   = 0;
    // Para.Hdr.cfheader.csumFiles     = 0;

    //
    // Write the header and folders back to the cab file
    //
    if (!(this->WriteHeader()))
    {
        if (pbFolders)
        {
            delete pbFolders;
        }
        return(FALSE);
    }

    if (pbFolders)
    {
        DWORD cbWritten;

        cbWritten = 0;
        if (!(WriteFile(this->hFile, pbFolders, cbFolders, &cbWritten, NULL)) ||
            (cbWritten != cbFolders))
        {
            delete pbFolders;
            return(FALSE);
        }
        delete pbFolders;
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::DigestHeader(DIGEST_FUNCTION pfnDigestData, DIGEST_HANDLE hDigestData)
{
    //
    // Digest CFHEADER, skipping the csumHeader field
    //
    if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cfheader.sig,
                        sizeof(Para.Hdr.cfheader.sig))))
    {
        return(FALSE);
    }

    if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cfheader.cbCabinet,
                        sizeof(CFHEADER) - sizeof(Para.Hdr.cfheader.sig) - sizeof(CHECKSUM))))
    {
        return(FALSE);
    }

    if (Para.Hdr.cbcfres)
    {
        // skip the cfres itself!

        if (Para.Hdr.cfres.cbCFHeader >= RESERVE_CNT_HDR_LEN)
        {
            // Digest any "junk" in abReserve[] before the signature
            if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cbJunk,
                                    sizeof(Para.Hdr.cbJunk))))
            {
                return(FALSE);
            }
            if (Para.Hdr.cbJunk)
            {
                if (!(pfnDigestData(hDigestData,
                                    Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN,
                                    Para.Hdr.cbJunk)))
                {
                    return(FALSE);
                }
            }
        }
    }

    if (Para.Hdr.pbStrings)
    {
        // Digest the strings
        if (!(pfnDigestData(hDigestData, Para.Hdr.pbStrings, Para.Hdr.cbStrings)))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

void SIPObjectCAB_::ChecksumHeader(void)
{
    return;

    // version 1 set checksum to zero.  this seems to be the correct thing to do????

#   ifdef _DONT_USE_YET

        CHECKSUM csum = 0;

        if (Para.Hdr.cfheader.csumHeader == 0)
        {
            return;
        }

        // Checksum CFHEADER, skipping the csumHeader field
        csum = CSUMCompute(&Para.Hdr.cfheader.sig, sizeof(Para.Hdr.cfheader.sig), csum);
        csum = CSUMCompute(&Para.Hdr.cfheader.cbCabinet,
                            sizeof(CFHEADER) -
                            sizeof(Para.Hdr.cfheader.sig) -
                            sizeof(CHECKSUM),
                            csum);

        if (Para.Hdr.cbcfres)
        {
            csum = CSUMCompute(&Para.Hdr.cfres, sizeof(Para.Hdr.cfres), csum);
            if (Para.Hdr.pbReserve) 
            {
                csum = CSUMCompute(Para.Hdr.pbReserve, Para.Hdr.cfres.cbCFHeader, csum);
            }
        }

        if (Para.Hdr.pbStrings)
        {
            csum = CSUMCompute(Para.Hdr.pbStrings, Para.Hdr.cbStrings, csum);
        }

        Para.Hdr.cfheader.csumHeader = csum;

#   endif

}

#ifdef _DONT_USE_YET

    CHECKSUM SIPObjectCAB_::CSUMCompute(void *pv, UINT cb, CHECKSUM seed)
    {
        int         cUlong;                 // Number of ULONGs in block
        CHECKSUM    csum;                   // Checksum accumulator
        BYTE       *pb;
        ULONG       ul;

        cUlong = cb / 4;                    // Number of ULONGs
        csum = seed;                        // Init checksum
        pb = (BYTE*)pv;                            // Start at front of data block

        //** Checksum integral multiple of ULONGs
        while (cUlong-- > 0) {
            //** NOTE: Build ULONG in big/little-endian independent manner
            ul = *pb++;                     // Get low-order byte
            ul |= (((ULONG)(*pb++)) <<  8); // Add 2nd byte
            ul |= (((ULONG)(*pb++)) << 16); // Add 3nd byte
            ul |= (((ULONG)(*pb++)) << 24); // Add 4th byte

            csum ^= ul;                     // Update checksum
        }

        //** Checksum remainder bytes
        ul = 0;
        switch (cb % 4) {
            case 3:
                ul |= (((ULONG)(*pb++)) << 16); // Add 3nd byte
            case 2:
                ul |= (((ULONG)(*pb++)) <<  8); // Add 2nd byte
            case 1:
                ul |= *pb++;                    // Get low-order byte
            default:
                break;
        }
        csum ^= ul;                         // Update checksum

        //** Return computed checksum
        return csum;
    }

#endif // _DONT_USE_YET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObj.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "crypthlp.h"

#include    "sipobj.hxx"

#include    "sha.h"
#include    "md5.h"


////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObject_::SIPObject_(DWORD id)
{
    hFile           = INVALID_HANDLE_VALUE;
    hProv           = NULL;
    uSubjectForm    = MSSIP_SUBJECT_FORM_FILE;
    bCloseFile      = FALSE;
    fUseFileMap     = TRUE;
    hMappedFile     = INVALID_HANDLE_VALUE;
    pbFileMap       = NULL;
    cbFileMap       = 0;
}

SIPObject_::~SIPObject_(void)
{
    HRESULT lerr;

    lerr = GetLastError();

    if ((hFile != INVALID_HANDLE_VALUE) && (bCloseFile))
    {
        CloseHandle(hFile);
    }

    this->UnmapFile();

    SetLastError(lerr);
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObject_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                         DWORD *pdwDLen,BYTE *pbData,
                                         DWORD *pdwEncodeType)
{
    if (!(pdwDLen))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   dwOldError;

        dwOldError = GetLastError();

        if (*pdwDLen == 0)
        {
            pbData = NULL;  // just to be sure for future WIN32 style calls!
        }

        if (this->GetMessageFromFile(pSI, (LPWIN_CERTIFICATE)pbData, dwIdx, pdwDLen))
        {
            if (pbData)
            {
                LPWIN_CERTIFICATE pCertHdr;

                pCertHdr = (LPWIN_CERTIFICATE)pbData;

                pSI->dwIntVersion = (DWORD)pCertHdr->wRevision;

                switch (pCertHdr->wCertificateType)
                {
                    case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
                            *pdwEncodeType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
                            break;

                    case WIN_CERT_TYPE_X509:
                    case WIN_CERT_TYPE_RESERVED_1:
                    default:
                            *pdwEncodeType = 0;
                }

                DWORD   dwCert;
                BYTE    *pszStart;
                BYTE    *pszData;

                dwCert      = pCertHdr->dwLength - OFFSETOF(WIN_CERTIFICATE,bCertificate);
                pszStart    = (BYTE *)pCertHdr;
                pszData     = pCertHdr->bCertificate;

                memcpy(pszStart, pszData, dwCert);

                *pdwDLen = dwCert;

#               if (DBG)

                HANDLE  hDebug;
                DWORD   dwDbgwr;

                hDebug = CreateFile("C:\\SIPOBJ.DBG",GENERIC_WRITE,FILE_SHARE_WRITE,
                                    NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

                if (hDebug != INVALID_HANDLE_VALUE)
                {
                    WriteFile(hDebug, &pszData[0], dwCert, &dwDbgwr,NULL);
                    CloseHandle(hDebug);
                }

#               endif // DBG
            }
            return(TRUE);
        }
        else if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) && (pbData == NULL))
        {
            // just getting length...
            SetLastError(dwOldError);
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL SIPObject_::PutSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD *pdwIdx,
                                         DWORD dwDLen,BYTE *pbData,
                                         DWORD dwEncodeType)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        LPWIN_CERTIFICATE   pCertHdr;
        DWORD               dwData;
        DWORD               cbCheck;

        dwData  = OFFSETOF(WIN_CERTIFICATE, bCertificate) + dwDLen;

        dwData = (dwData + 7) & ~7;   // allign on 8 byte

        if (!(pCertHdr = (LPWIN_CERTIFICATE)this->SIPNew(dwData)))
        {
            return(FALSE);
        }

        memset(pCertHdr, 0x00, dwData);

        pCertHdr->dwLength          = dwData;

        pCertHdr->wRevision         = WIN_CERT_REVISION_2_0;
        pCertHdr->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;

        if (pbData)
        {
            fSizeFileOnly = FALSE;

            memcpy(&pCertHdr->bCertificate[0], &pbData[0], dwDLen);

#           if (DBG)

                HANDLE  hDebug;
                DWORD   dwDbgwr;

                hDebug = CreateFile("C:\\SIPOBJ.DBG",GENERIC_WRITE,FILE_SHARE_WRITE,
                                    NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

                if (hDebug != INVALID_HANDLE_VALUE)
                {
                    WriteFile(hDebug,&pbData[0],dwDLen,&dwDbgwr,NULL);
                    CloseHandle(hDebug);
                }

#           endif // DBG
        }
        else
        {
            fSizeFileOnly = TRUE;

            memset(&pCertHdr->bCertificate[0], 0x00, dwDLen);
        }

        if (!(this->PutMessageInFile(pSI, pCertHdr, pdwIdx)))
        {
            delete pCertHdr;

            return(FALSE);
        }

        delete pCertHdr;

        return(TRUE);
    }
    return(FALSE);
}

BOOL SIPObject_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                    SIP_INDIRECT_DATA *psData)
{
    HCRYPTPROV              hProvT;

    hProvT = pSI->hProv;

    if (!(hProvT))
    {
        if (!(this->LoadDefaultProvider()))
        {
            return(FALSE);
        }
        hProvT = this->hProv;
    }

    BYTE                    *pbDigest;
    DWORD                   cbDigest;

    if (!(psData))
    {
        //
        // length only!
        //

        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier...
            // obj id
        dwRetLen += strlen(pSI->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term.
            // parameters (none)...

        // crypt_attribute_type_value size...
        dwRetLen += strlen(this->GetDataObjectID());
        dwRetLen += 1; // null term.

        // size of the value (flags)....
        dwEncLen = 0;
        CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            this->GetDataOIDHint(),
                            this->GetMyStructure(pSI),
                            NULL,
                            &dwEncLen);
        if (dwEncLen > 0)
        {
            dwRetLen += dwEncLen;

            // hash of subject
            if ((dwAlgId = CertOIDToAlgId(pSI->DigestAlgorithm.pszObjId)) == 0)
            {
                SetLastError((DWORD)NTE_BAD_ALGID);
                return(FALSE);
            }

            switch (dwAlgId)
            {
                case CALG_MD5:
                    cbDigest = MD5DIGESTLEN;
                    break;

                case CALG_SHA1:
                    cbDigest = A_SHA_DIGEST_LEN;
                    break;

                default:
                    if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash)))
                    {
                        return(FALSE);
                    }

                    // just to get hash length
                    if (!(CryptHashData(hHash,(const BYTE *)" ",1,0)))
                    {
                        CryptDestroyHash(hHash);
                        return(FALSE);
                    }

                    cbDigest = 0;

                    CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

                    CryptDestroyHash(hHash);
            }

            if (cbDigest > 0)
            {
                dwRetLen += cbDigest;

                *pdwDLen = dwRetLen;

                return(TRUE);
            }
        }
    }
    else if (this->FileHandleFromSubject(pSI))
    {
        if (pbDigest = this->DigestFile(hProvT,
                                        this->GetDigestFlags(pSI),
                                        pSI->DigestAlgorithm.pszObjId,
                                        &cbDigest))
        {
            DWORD_PTR offset;
            DWORD   dwRetLen;

            dwRetLen = 0;
            CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                this->GetDataOIDHint(),
                                this->GetMyStructure(pSI),
                                NULL,
                                &dwRetLen);
            if (dwRetLen > 0)
            {
                BYTE    *attrdata;

                attrdata = (BYTE *)this->SIPNew(dwRetLen);

                if (attrdata)
                {
                    if (CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                            this->GetDataOIDHint(),
                                            this->GetMyStructure(pSI),
                                            attrdata,
                                            &dwRetLen))
                    {
                        //
                        //  assign allocated memory to our structure
                        //
                        offset =    (DWORD_PTR)psData + sizeof(SIP_INDIRECT_DATA);

                        strcpy((char *)offset, this->GetDataObjectID());
                        psData->Data.pszObjId   = (LPSTR)offset;
                        offset += (strlen(this->GetDataObjectID()) + 1);

                        memcpy((void *)offset,attrdata,dwRetLen);
                        psData->Data.Value.pbData   = (BYTE *)offset;
                        psData->Data.Value.cbData   = dwRetLen;
                        offset += dwRetLen;

                        strcpy((char *)offset, (char *)pSI->DigestAlgorithm.pszObjId);
                        psData->DigestAlgorithm.pszObjId            = (char *)offset;
                        psData->DigestAlgorithm.Parameters.cbData   = 0;
                        psData->DigestAlgorithm.Parameters.pbData   = NULL;
                        offset += (strlen(pSI->DigestAlgorithm.pszObjId) + 1);

                        memcpy((void *)offset,pbDigest,cbDigest);
                        psData->Digest.pbData   = (BYTE *)offset;
                        psData->Digest.cbData   = cbDigest;

                        delete pbDigest;
                        delete attrdata;

                        return(TRUE);
                    }

                    delete attrdata;
                }
            }

            delete pbDigest;
        }
    }

    return(FALSE);
}

BOOL SIPObject_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                    SIP_INDIRECT_DATA *psData)
{
    if (!(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   cbDigest;
        BYTE    *pbDigest;

        if (!(pbDigest = this->DigestFile(  pSI->hProv,
                                            this->GetDigestFlags(pSI),
                                            psData->DigestAlgorithm.pszObjId,
                                            &cbDigest)))
        {
            return(FALSE);
        }


        if ((cbDigest != psData->Digest.cbData) ||
            (memcmp(pbDigest,psData->Digest.pbData,cbDigest) != 0))
        {
            delete pbDigest;

            SetLastError(TRUST_E_BAD_DIGEST);
            return(FALSE);
        }

        delete pbDigest;

        return(TRUE);
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// protected:
//

void *SIPObject_::SIPNew(DWORD cbytes)
{
    void    *pvRet;

    pvRet = (void *)new char[cbytes];

    if (!(pvRet))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pvRet);
}

BOOL SIPObject_::OpenFile(LPCWSTR FileName, DWORD dwAccess, DWORD dwShared)
{
    if ((this->hFile != INVALID_HANDLE_VALUE) && (this->hFile))
    {
        //
        //  we've already opened it....
        //
        return(TRUE);
    }

    if ((this->hFile = CreateFileU( FileName,
                                    dwAccess,
                                    dwShared,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    this->bCloseFile = TRUE;

    return(TRUE);
}

BOOL SIPObject_::FileHandleFromSubject(SIP_SUBJECTINFO *pSubject, DWORD dwAccess, DWORD dwShared)
{
    dwFileAccess = dwAccess;

    if ((pSubject->hFile == NULL) ||
        (pSubject->hFile == INVALID_HANDLE_VALUE))
    {
        if (!(this->OpenFile(pSubject->pwsFileName, dwAccess, dwShared)))
        {
            return(FALSE);
        }
    }
    else
    {
        this->hFile = pSubject->hFile;

        if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            return(FALSE);
        }
    }

    return(this->MapFile());
}

void SIPObject_::AllocateAndFillCryptBitBlob(CRYPT_BIT_BLOB *bb,DWORD Flags,
                                             DWORD cUnusedBits)
{
    if (bb)
    {
        bb->cbData      = 1;
        bb->pbData      = new BYTE[1];
        bb->cUnusedBits = cUnusedBits;

        if(bb->pbData)
            bb->pbData[0]   = (BYTE)(Flags & 0x000000ff);
    }
}

void SIPObject_::DestroyCryptBitBlob(CRYPT_BIT_BLOB *bb)
{
    if (bb)
    {
        if (bb->pbData)
        {
            delete bb->pbData;
            bb->pbData = NULL;
        }
    }
}

DWORD SIPObject_::CryptBitBlobToFlags(CRYPT_BIT_BLOB *bb)
{
    if ((bb) && (bb->pbData))
    {
        return((DWORD)bb->pbData[0]);
    }

    return(0);
}

BYTE *SIPObject_::DigestFile(HCRYPTPROV hProv, DWORD dwFlags, char *pszObjId, DWORD *pcbDigest)
{
    DIGEST_DATA             DigestData;
    A_SHA_CTX               sShaCtx;
    MD5_CTX                 sMd5Ctx;

    *pcbDigest = 0;

    if ((DigestData.dwAlgId = CertOIDToAlgId(pszObjId)) == 0)
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        return(NULL);
    }

    DigestData.cbCache          = 0;
    DigestData.hHash            = 0;

    switch (DigestData.dwAlgId)
    {
        case CALG_MD5:
            DigestData.pvSHA1orMD5Ctx = &sMd5Ctx;
            break;

        case CALG_SHA1:
            DigestData.pvSHA1orMD5Ctx = &sShaCtx;
            break;

        default:
            DigestData.pvSHA1orMD5Ctx   = NULL;
    }

    if (!(SipCreateHash(hProv, &DigestData)))
    {
        return(NULL);
    }

    if (!(this->GetDigestStream(&DigestData, (DIGEST_FUNCTION)DigestFileData, dwFlags)))
    {
        return(NULL);
    }

    // Data left over ?
    if (DigestData.cbCache > 0)
    {
        if (!(SipHashData(&DigestData, DigestData.pbCache, DigestData.cbCache)))
        {
            SipDestroyHash(&DigestData);
            return(NULL);
        }
    }

    BYTE    *pbRet;

    pbRet = SipGetHashValue(&DigestData, pcbDigest);

    SipDestroyHash(&DigestData);

    return(pbRet);
}

BOOL SIPObject_::LoadDefaultProvider(void)
{
    if (this->hProv)
    {
        return(TRUE);
    }

    this->hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!

    if (this->hProv)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObject_::SeekAndWriteFile(DWORD lFileOffset,BYTE *pb, DWORD cb)
{
    DWORD cbWritten;

    if (SetFilePointer(this->hFile, lFileOffset, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    if (!(WriteFile(this->hFile, pb, cb, &cbWritten, NULL)) || (cbWritten != cb))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL SIPObject_::SeekAndReadFile(DWORD lFileOffset, BYTE *pb, DWORD cb)
{

    if (!(this->pbFileMap) ||
        (this->cbFileMap < (lFileOffset + cb)))
    {
        return(FALSE);
    }

    __try {
    memcpy(pb, &this->pbFileMap[lFileOffset], cb);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return(FALSE);
    }

    return(TRUE);
}

void SIPObject_::set_CertVersion(DWORD dwNewCertVersion)
{
    uCertVersion = dwNewCertVersion;

    if (uCertVersion < WIN_CERT_REVISION_1_0)   // just in case it hasn't been set yet.
    {
        uCertVersion = WIN_CERT_REVISION_2_0;
    }
}

BOOL SIPObject_::MapFile(void)
{
    if (!(this->fUseFileMap))
    {
        return(TRUE);
    }

    BOOL    fRet;

    if (this->pbFileMap)
    {
        this->UnmapFile();
    }

    hMappedFile = CreateFileMapping(this->hFile, NULL,
                            (dwFileAccess & GENERIC_WRITE) ? PAGE_READWRITE : PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapFailed;
    }

    this->pbFileMap = (BYTE *)MapViewOfFile(hMappedFile,
                                (dwFileAccess & GENERIC_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ, 0, 0, 0);

    if (!(this->pbFileMap))
    {
        goto FileViewFailed;
    }

    this->cbFileMap = GetFileSize(this->hFile, NULL);

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    this->cbFileMap = 0;

    this->UnmapFile();

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, FileMapFailed);
    TRACE_ERROR_EX(DBG_SS, FileViewFailed);
}

BOOL SIPObject_::UnmapFile(void)
{
    if ((hMappedFile != INVALID_HANDLE_VALUE) && (hMappedFile))
    {
        CloseHandle(hMappedFile);
        hMappedFile = INVALID_HANDLE_VALUE;
    }

    if (this->pbFileMap)
    {
        UnmapViewOfFile(this->pbFileMap);
        this->pbFileMap = NULL;
        this->cbFileMap = 0;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjjv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjJV.cpp (JAVA)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjjv.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectJAVA_::SIPObjectJAVA_(DWORD id) : SIPObject_(id)
{
    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;
}

BOOL SIPObjectJAVA_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(JavaRemoveCertificate(this->hFile,dwIdx));
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectJAVA_::GetMessageFromFile(SIP_SUBJECTINFO *pSI, WIN_CERTIFICATE *pWinCert,
                                        DWORD dwIndex,DWORD *pcbCert)
{
    return(JavaGetCertificateData(this->hFile,dwIndex,pWinCert,pcbCert));
}

BOOL SIPObjectJAVA_::PutMessageInFile(SIP_SUBJECTINFO *pSI, WIN_CERTIFICATE *pWinCert,
                                      DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (pdwIndex)
    {
        *pdwIndex = 0; // java only has 1
    }

    return(JavaAddCertificate(this->hFile,pWinCert,pdwIndex));
}


BOOL SIPObjectJAVA_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                     DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    return(JavaGetDigestStream( this->hFile,
                                dwFlags,
                                pfnCallBack,
                                pDigestData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjSS.cpp
//
//  Contents:   Microsoft SIP Provider - Structured Storage
//
//  History:    07-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjss.hxx"

#include    <objidl.h>
#include    <objbase.h>

#define     SIG_AUTHOR          0
#define     SIG_NOTARY          1
#define     SIG_MAX             1

typedef struct StreamIds_
{
    DWORD       dwSigIndex;
    WCHAR       *pwszName;
} StreamIds;

static StreamIds Ids[] =
{
    SIG_AUTHOR, L"\001MSDigSig(Author)",
    SIG_NOTARY, L"\001MSDigSig(Notary)",
    0xffffffff, NULL
};

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectSS_::SIPObjectSS_(DWORD id) : SIPObject_(id)
{
    GUID        gSS = CRYPT_SUBJTYPE_SS_IMAGE;

    memset(&SpcSigInfo,0x00,sizeof(SPC_SIGINFO));

    SpcSigInfo.dwSipVersion = MSSIP_CURRENT_VERSION;

    memcpy(&SpcSigInfo.gSIPGuid, &gSS, sizeof(GUID));

    pTopStg                 = NULL;

    this->fUseFileMap       = FALSE;
}

SIPObjectSS_::~SIPObjectSS_(void)
{
    if (pTopStg)
    {
        pTopStg->Commit(STGC_DEFAULT);
        pTopStg->Release();
    }
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectSS_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (dwIdx > SIG_MAX)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        if (pTopStg->DestroyElement(Ids[dwIdx].pwszName) != S_OK)
        {
            SetLastError((DWORD)TRUST_E_NOSIGNATURE);
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectSS_::GetMessageFromFile(SIP_SUBJECTINFO *pSI,
                                      WIN_CERTIFICATE *pWinCert,
                                      DWORD dwIndex,DWORD *pcbCert)
{
    if (!(pTopStg))
    {
        return(FALSE);
    }

    if (dwIndex > SIG_MAX)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    STATSTG     sStatStg;
    IStream     *pStream;
    DWORD       cbCert;

    pStream     = NULL;

    if ((pTopStg->OpenStream(Ids[dwIndex].pwszName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE,
                             0, &pStream) != S_OK) ||
        !(pStream))
    {
        SetLastError(TRUST_E_NOSIGNATURE);

        return(FALSE);
    }

    if (pStream->Stat(&sStatStg, STATFLAG_NONAME) != S_OK)
    {
        pStream->Release();

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    cbCert = sStatStg.cbSize.LowPart;

    if (cbCert == 0)
    {
        pStream->Release();

        SetLastError(TRUST_E_NOSIGNATURE);

        return(FALSE);
    }

    cbCert += WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate);

    if (*pcbCert < cbCert)
    {
        pStream->Release();

        *pcbCert = cbCert;

        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        return(FALSE);
    }

    if (pWinCert)
    {
        DWORD   cbRead;

        pWinCert->dwLength          = cbCert;
        pWinCert->wRevision         = WIN_CERT_REVISION_2_0;
        pWinCert->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
    
        cbRead = 0;

        cbCert -= WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate);

        if ((pStream->Read(pWinCert->bCertificate, cbCert, &cbRead) != S_OK) ||
            (cbRead != cbCert))
        {
            SetLastError(ERROR_BAD_FORMAT);
    
            pStream->Release();

            return(FALSE);
        }
    }

    pStream->Release();

    return(TRUE);
}

BOOL SIPObjectSS_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pdwIndex > SIG_MAX)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    IStream     *pStream;

    pStream     = NULL;

    if ((pTopStg->CreateStream(Ids[*pdwIndex].pwszName, 
                               STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
                               0, 0, &pStream) != S_OK) ||
        !(pStream))
    {
        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    if (pStream->Write(pWinCert->bCertificate, 
                        pWinCert->dwLength - WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate), 
                        NULL) != S_OK)
    {
        pStream->Release();

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    pStream->Release();

    return(TRUE);
}


BOOL SIPObjectSS_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    return(this->IStorageDigest(pTopStg, pDigestData, pfnCallBack));
}


BOOL SIPObjectSS_::IStorageDigest(IStorage *pStg, DIGEST_DATA *pDigestData, DIGEST_FUNCTION pfnCallBack)
{
    STATSTG     *pSortStg;
    STATSTG     sStatStg;
    DWORD       cSortStg;
    BOOL        fRet;


    cSortStg    = 0;
    pSortStg    = NULL;

    if (!(this->SortElements(pStg, &cSortStg, &pSortStg)))
    {
        return(FALSE);
    }

    if (cSortStg == 0)
    {
        return(TRUE);
    }

    if (!(pSortStg))
    {
        return(FALSE);
    }

    for (int i = 0; i < (int)cSortStg; i++)
    {
        switch (pSortStg[i].type)
        {
            case STGTY_STORAGE:
                
                IStorage        *pInnerStg;

                pInnerStg = NULL;

                if ((pStg->OpenStorage(pSortStg[i].pwcsName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       0, 0, &pInnerStg) != S_OK) ||
                    !(pInnerStg))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    SetLastError(ERROR_BAD_FORMAT);

                    return(FALSE);
                }

                //
                // WARNING: recursive!
                //
                fRet = this->IStorageDigest(pInnerStg, pDigestData, pfnCallBack);

                pInnerStg->Release();

                if (!(fRet))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    return(FALSE);
                }

                break;

            case STGTY_STREAM:

                IStream     *pInnerStm;
                StreamIds   *pIds;
                BOOL        fSigEntry;
                BYTE        rgb[512];
                ULONG       cbRead;

                fSigEntry   = FALSE;
                pIds        = &Ids[0];

                while (pIds->dwSigIndex != 0xffffffff)
                {
                    if (_wcsicmp(pSortStg[i].pwcsName, pIds->pwszName) == 0)
                    {
                        fSigEntry = TRUE;
                        break;
                    }

                    pIds++;
                }

                if (fSigEntry)
                {
                    break;
                }

                pInnerStm = NULL;

                if ((pStg->OpenStream(pSortStg[i].pwcsName, 
                                     NULL,
                                     STGM_READ | STGM_SHARE_EXCLUSIVE,
                                     0,
                                     &pInnerStm) != S_OK) ||
                    !(pInnerStm))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    SetLastError(ERROR_BAD_FORMAT);

                    return(FALSE);
                }

                for EVER
                {
                    cbRead = 0;
                    if (pInnerStm->Read(rgb, 512, &cbRead) != S_OK)
                    {
                        break;
                    }

                    if (cbRead == 0)
                    {
                        break;
                    }

                    if (!(pfnCallBack(pDigestData, rgb, cbRead)))
                    {
                        this->FreeElements(&cSortStg, &pSortStg);

                        pInnerStm->Release();

                        return(FALSE);
                    }

                }

                pInnerStm->Release();
                break;

            case STGTY_LOCKBYTES:
                break;

            case STGTY_PROPERTY:
                break;

            default:
                break;
        }
    }

    memset(&sStatStg, 0x00, sizeof(STATSTG));

    if (pStg->Stat(&sStatStg, STATFLAG_NONAME) != S_OK)
    {
        this->FreeElements(&cSortStg, &pSortStg);

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    //              the ctime member is changed if the file is copied....
    //        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.ctime, sizeof(FILETIME))) ||
    //
    if (!(pfnCallBack(pDigestData, (BYTE *)&sStatStg.type, sizeof(DWORD))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.cbSize, sizeof(ULARGE_INTEGER))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.clsid, sizeof(CLSID))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.grfStateBits, sizeof(DWORD))))
    {
        this->FreeElements(&cSortStg, &pSortStg);
        
        return(FALSE);
    }
    

    this->FreeElements(&cSortStg, &pSortStg);

    return(TRUE);
}

BOOL SIPObjectSS_::FileHandleFromSubject(SIP_SUBJECTINFO *pSubject, DWORD dwAccess, DWORD dwShared)
{
  /*  if ((dwAccess & GENERIC_WRITE) &&
        (pSubject->hFile != NULL) &&
        (pSubject->hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(pSubject->hFile);
        pSubject->hFile = NULL;
    }  */

    
    HRESULT hr;

    pTopStg = NULL;

  /*  if ((hr = StgOpenStorage((const WCHAR *)pSubject->pwsFileName, 
                        NULL, 
                        (dwAccess & GENERIC_WRITE) ? 
                                        (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT) : 
                                        (STGM_READ | STGM_SHARE_DENY_NONE | STGM_TRANSACTED),
                        NULL,
                        0,
                        &pTopStg)) != S_OK)
    {
        pTopStg = NULL;
        return(FALSE);
    }  */

    if ((hr = StgOpenStorage((const WCHAR *)pSubject->pwsFileName, 
                        NULL, 
                        (dwAccess & GENERIC_WRITE) ? 
                                        (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT) : 
                                        (STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT),
                        NULL,
                        0,
                        &pTopStg)) != S_OK)
    {
        pTopStg = NULL;
        
        return(FALSE);
    }  

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
// private:
//

BOOL WINAPI IsStructuredStorageFile(WCHAR *pwszFileName, GUID *pgSubject)
{
    GUID        gSS = CRYPT_SUBJTYPE_SS_IMAGE;

    if (!(pwszFileName) ||
        !(pgSubject))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (StgIsStorageFile(pwszFileName) == S_OK)
    {
        memcpy(pgSubject, &gSS, sizeof(GUID));
        return(TRUE);
    }

    return(FALSE);
}

static int __cdecl CompareSTATSTG(const void *p1, const void *p2)
{
    return(wcscmp(((STATSTG *)p1)->pwcsName, ((STATSTG *)p2)->pwcsName));
}

void SIPObjectSS_::FreeElements(DWORD *pcStg, STATSTG **ppStg)
{
    if (*ppStg) 
    {
        STATSTG *pStg;

        pStg = *ppStg;

        for (int i = 0; i < (int)*pcStg; i++)
        {
            if (pStg[i].pwcsName)
            {
                CoTaskMemFree(pStg[i].pwcsName);
            }
        }

        DELETE_OBJECT(*ppStg);
    }

    *pcStg = 0;
}

BOOL SIPObjectSS_::SortElements(IStorage *pStg, DWORD *pcSortStg, STATSTG **ppSortStg)
{
    DWORD           cb;
    IEnumSTATSTG    *pEnum;

    pEnum       = NULL;

    *pcSortStg  = 0;
    *ppSortStg  = NULL;

    if (pStg->EnumElements(0, NULL, 0, &pEnum) != S_OK)
    {
        return(FALSE);
    }

    DWORD   celtFetched;
    STATSTG rgCntStatStg[10];

    for EVER
    {
        celtFetched = 0;

        pEnum->Next(10, rgCntStatStg, &celtFetched);

        if (celtFetched == 0)
        {
            break;
        }

        *pcSortStg += celtFetched;

        while (celtFetched--)
        {
            CoTaskMemFree(rgCntStatStg[celtFetched].pwcsName);
        }
    }

    if (*pcSortStg > 0) 
    {
        cb = sizeof(STATSTG) * *pcSortStg;

        if (!(*ppSortStg = (STATSTG *)this->SIPNew(cb)))
        {
            pEnum->Release();
            return(FALSE);
        }

        memset(*ppSortStg, 0x00, cb);

        pEnum->Reset();

        celtFetched = 0;

        if ((pEnum->Next(*pcSortStg, *ppSortStg, &celtFetched) != S_OK) ||
            (celtFetched != *pcSortStg))
        {
            this->FreeElements(pcSortStg, ppSortStg);
            pEnum->Release();

            SetLastError(ERROR_BAD_FORMAT);

            return(FALSE);
        }

        qsort(*ppSortStg, *pcSortStg, sizeof(STATSTG), CompareSTATSTG);
    }

    pEnum->Release();

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\catadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catadd.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

WCHAR   *pwszCatFile    = L"FILESET\\TCATNT.CAT";
WCHAR   *pwszCatFile2   = L"FILESET\\DRIVER.CAT";


DWORD WINAPI TestCatAdd(ThreadData *psData)
{
    HCATADMIN       hCatAdmin;
    HCATINFO        hCatInfo;
    COleDateTime    tStart;
    COleDateTime    tEnd;
    DWORD           i;

    printf("\n  CAT_ADD");

    psData->dwTotalProcessed    = 0;;

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, &gDriver, 0)))
    {
        return(0);
    }

    tStart = COleDateTime::GetCurrentTime();

    if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
    {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    for (i = 0; i < cPasses; i++)
    {
        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile2, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile2, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        psData->dwTotalProcessed    += 4;
    }

    tEnd = COleDateTime::GetCurrentTime();

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    psData->tsTotal             = tEnd - tStart;

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjpe.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjPE.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjpe.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectPE_::SIPObjectPE_(DWORD id) : SIPObject_(id)
{
    this->fUseFileMap = FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectPE_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(ImageRemoveCertificate(this->hFile, dwIdx));
    }

    return(FALSE);
}

BOOL SIPObjectPE_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                   SIP_INDIRECT_DATA *psData)
{
    SPC_LINK                PeLink;
    BOOL                    fRet;

    memset(&PeInfo,0x00,sizeof(SPC_PE_IMAGE_DATA));

    PeLink.dwLinkChoice     = SPC_FILE_LINK_CHOICE;
    PeLink.pwszFile         = OBSOLETE_TEXT_W;

    PeInfo.pFile            = &PeLink;

    this->AllocateAndFillCryptBitBlob(&PeInfo.Flags,pSI->dwFlags,5);

    fRet = SIPObject_::CreateIndirectData(pSI, pdwDLen, psData);
    
    this->DestroyCryptBitBlob(&PeInfo.Flags);

    return(fRet);
}

BOOL SIPObjectPE_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                      SIP_INDIRECT_DATA *psData)
{
    SPC_PE_IMAGE_DATA       *pPeInfo;
    DWORD                   cbPeInfo;
    BOOL                    fRet;

    pPeInfo = NULL;


    if (!(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            goto InvalidParameter;
        }

        goto FileOpenFailed;
    }

    if (!(this->FileHandleFromSubject(pSI)))
    {
        goto FileOpenFailed;
    }

    if (!(TrustDecode(WVT_MODID_MSSIP, (BYTE **)&pPeInfo, &cbPeInfo, 201,
                      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(),
                      psData->Data.Value.pbData, psData->Data.Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeError;
    }


    if (uCertVersion < WIN_CERT_REVISION_2_0)
    {
        //
        // We are looking at a PE that was signed PRIOR to this version.
        // We need to:
        //      1.  if there is "extra" bits at the end (e.g.: InstallShield),
        //          FAIL!
        //      2.  if there is no "extra" bits, go through the old
        //          ImageHelper function to digest. (e.g.: set the version
        //          flag.)
        //
        if (!(imagehack_IsImagePEOnly(this->hFile)))
        {
            goto BadDigest;
        }
    }

    pSI->dwFlags = this->CryptBitBlobToFlags(&pPeInfo->Flags);

    fRet = SIPObject_::VerifyIndirectData(pSI, psData);

CommonReturn:

    if (pPeInfo)
    {
        TrustFreeDecode(WVT_MODID_MSSIP, (BYTE **)&pPeInfo);
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
 
    TRACE_ERROR_EX(DBG_SS, FileOpenFailed);
    TRACE_ERROR_EX(DBG_SS, DecodeError);

    SET_ERROR_VAR_EX(DBG_SS, BadDigest,         TRUST_E_BAD_DIGEST);
    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,  ERROR_INVALID_PARAMETER);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectPE_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if (fSizeFileOnly)
    {
        goto FileResizedError;
    }

    //
    //  check to see if we are going to align the file
    //
    DWORD   cbFSize;
    DWORD   cbCheck;
    BOOL    fRet;

    cbFSize     = GetFileSize(this->hFile, NULL);
    cbCheck     = (cbFSize + 7) & ~7;
    cbCheck     -= cbFSize;

    fRet =  ImageAddCertificate(this->hFile, pWinCert, pdwIndex);

    if ((fRet) && (cbCheck > 0))
    {
        //
        //  we aligned the file, make sure we null out the padding!
        //
        if (SetFilePointer(this->hFile, cbFSize, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            goto SetFileError;
        }

        BYTE    buf[8];
        DWORD   cbWritten;

        memset(&buf[0], 0x00, cbCheck);

        if (!(WriteFile(this->hFile, &buf[0], cbCheck, &cbWritten, NULL)) || (cbWritten != cbCheck))
        {
            goto WriteFileError;
        }
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
 
    TRACE_ERROR_EX(DBG_SS, WriteFileError);
    TRACE_ERROR_EX(DBG_SS, SetFileError);

    SET_ERROR_VAR_EX(DBG_SS, FileResizedError,  CRYPT_E_FILERESIZED);
}


BOOL SIPObjectPE_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    //
    //  Check the version flag here.  We will have set this based
    //  on which version of the image helper function we want to 
    //  call.
    //
    if (uCertVersion < WIN_CERT_REVISION_2_0)
    {
        return(ImageGetDigestStream(   this->hFile,
                                        dwFlags,
                                        pfnCallBack,
                                        pDigestData));
    }

    BOOL    fRet;
    DWORD   dwDiskLength;

    fRet = imagehack_AuImageGetDigestStream(    this->hFile,
                                                dwFlags,
                                                pfnCallBack,
                                                pDigestData);

    dwDiskLength = GetFileSize(this->hFile, NULL);

    dwDiskLength = (dwDiskLength + 7) & ~7; // padding before the certs?

    dwDiskLength -= GetFileSize(this->hFile, NULL);

    if ((fRet) && (dwDiskLength > 0))
    {
        BYTE    *pb;

        if (!(pb = (BYTE *)this->SIPNew(dwDiskLength)))
        {
            return(FALSE);
        }

        memset(pb, 0x00, dwDiskLength); // imagehlp put nulls before the signature!

        fRet = (*pfnCallBack)(pDigestData, pb, dwDiskLength);

        delete pb;
    }

    return(fRet);
}

DWORD SIPObjectPE_::ConvertSPCFlags(DWORD InFlags)
{
    DWORD ret;

    ret = 0;

    if (InFlags & SPC_INC_PE_RESOURCES_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_RESOURCES;
    }
    if (InFlags & SPC_INC_PE_DEBUG_INFO_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_DEBUG_INFO;
    }
    if (InFlags & SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO;
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\perftest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perftest.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

DWORD                   dwTotal             = 0;
DWORD                   dwExpectedError     = 0;
DWORD                   cPasses             = 1;
BOOL                    fCheckExpectedError = FALSE;
BOOL                    fVerbose            = FALSE;
WCHAR                   *pwszInFile         = NULL;

GUID                    gAuthCode       = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID                    gDriver         = DRIVER_ACTION_VERIFY;
GUID                    gCertProvider   = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

HANDLE                  *pahThreads         = NULL;

DWORD                   cThreads            = 1;
ThreadData              *pasThreads         = NULL;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                     iRet;
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    PFN_TEST                pfnTest;
    DWORD                   i;

    iRet = 0;

    pfnTest = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }
    
    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR, IDS_PARAMTEXT_EXPERROR, WARGV_VALUETYPE_DWORDH, (void *)0);

    pArgs->Add2List(IDS_PARAM_NOTHREADS,IDS_PARAMTEXT_NOTHREADS,WARGV_VALUETYPE_DWORDD, (void *)1);
    pArgs->Add2List(IDS_PARAM_NOPASSES, IDS_PARAMTEXT_NOPASSES, WARGV_VALUETYPE_DWORDD, (void *)2);

    pArgs->Add2List(IDS_PARAM_WVTCAT,   IDS_PARAMTEXT_WVTCAT,   WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_WVTCERT,  IDS_PARAMTEXT_WVTCERT,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_WVTFILE,  IDS_PARAMTEXT_WVTFILE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_CATADD,   IDS_PARAMTEXT_CATADD,   WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_CRYPTHASH,IDS_PARAMTEXT_CRYPTHASH,WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_HASHSHA1, IDS_PARAMTEXT_HASHSHA1, WARGV_VALUETYPE_BOOL,   (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    pwszInFile  = pArgs->GetFileName();
    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    cThreads    = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOTHREADS));
    cPasses     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOPASSES));

    if (!(pwszInFile))
    {
        pwszInFile = L"*.*";
    }

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fCheckExpectedError = TRUE;
    }

    if (cThreads < 1)
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    if (!(pasThreads = new ThreadData[cThreads]))
    {
        goto MemoryError;
    }

    if (!(pahThreads = new HANDLE[cThreads]))
    {
        goto MemoryError;
    }

    memset(pasThreads, 0x00, sizeof(ThreadData) * cThreads);


    if (pArgs->GetValue(IDS_PARAM_WVTCAT))
    {
        pfnTest = TestWVTCat;
    }
    else if (pArgs->GetValue(IDS_PARAM_WVTCERT))
    {
        pfnTest = TestWVTCert;
    }
    else if (pArgs->GetValue(IDS_PARAM_WVTFILE))
    {
        pfnTest = TestWVTFile;
    }
    else if (pArgs->GetValue(IDS_PARAM_CATADD))
    {
        pfnTest = TestCatAdd;
    }
    else if (pArgs->GetValue(IDS_PARAM_CRYPTHASH))
    {
        pfnTest = TestCryptHash;

        if (pArgs->GetValue(IDS_PARAM_HASHSHA1))
        {
            for (i = 0; i < cThreads; i++)
            {
                pasThreads[i].dwPassThrough = PASSTHROUGH_SHA1;
            }
        }
    }

    if (!(pfnTest))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    for (i = 0; i < cThreads; i++)
    {
        pasThreads[i].hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pfnTest,
                                             &pasThreads[i], CREATE_SUSPENDED, &pasThreads[i].dwId);

        if (!(pasThreads[i].hThread))
        {
            goto CreateThreadFailed;
        }

        pahThreads[i] = pasThreads[i].hThread;
    }

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    for (i = 0; i < cThreads; i++)
    {
        ResumeThread(pasThreads[i].hThread);
    }

    //
    //  wait to finish
    //
    WaitForMultipleObjects(cThreads, pahThreads, TRUE, INFINITE);

    //
    //  stop our timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    for (i = 0; i < cThreads; i++)
    {
        dwTotal += pasThreads[i].dwTotalProcessed;

        printf("\nThread #%d:", i + 1);
        printf("\n  Processing time:        %s", (LPCSTR)pasThreads[i].tsTotal.Format("%D:%H:%M:%S"));
        printf("\n  Total processed:        %ld", pasThreads[i].dwTotalProcessed);
        printf("\n  Average seconds per:    %f", (double)pasThreads[i].tsTotal.GetTotalSeconds() /
                                                 (double)pasThreads[i].dwTotalProcessed);
    }

    printf("\nOverall:");
    printf("\n  Processing time:        %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\n  Total processed:        %ld", dwTotal);
    printf("\n  Average seconds per:    %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\n");

    iRet = 0;

CommonReturn:

    if (pasThreads)
    {
        for (i = 0; i < cThreads; i++)
        {
            if (pasThreads[i].hThread)
            {
                CloseHandle(pasThreads[i].hThread);
            }
        }

        delete pasThreads;
    }

    DELETE_OBJECT(pArgs);
    DELETE_OBJECT(pahThreads);

    return(iRet);

ErrorReturn:
    iRet = 1;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CreateThreadFailed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtcert.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _LoadCerts(PCERT_CONTEXT *ppCerts);

#define _MAX_CERTS      4

DWORD WINAPI TestWVTCert(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;
    DWORD                   iCert;
    HRESULT                 hr;
    PCCERT_CONTEXT          pcCerts[_MAX_CERTS];
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCC;

    printf("\n  WVT_CERT");

    psData->dwTotalProcessed    = 0;

    _LoadCerts((PCERT_CONTEXT *)&pcCerts[0]);

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));
    memset(&sWTCC,  0x00,   sizeof(WINTRUST_CERT_INFO));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;
    sWTD.dwUnionChoice      = WTD_CHOICE_CERT;
    sWTD.pCert              = &sWTCC;

    sWTCC.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    sWTCC.pcwszDisplayName  = L"WVTCERT";


    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        for (iCert = 0; iCert < _MAX_CERTS; iCert++)
        {
            if (pcCerts[iCert])
            {
                sWTCC.psCertContext = (CERT_CONTEXT *)pcCerts[iCert];

                hr = WinVerifyTrust(NULL, &gCertProvider, &sWTD);

                psData->dwTotalProcessed++;

                if (fVerbose)
                {
                    printf("\n    cert check returned: 0x%08.8lX", hr);
                }
            }
        }
    }

    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    for (i = 0; i < _MAX_CERTS; i++)
    {
        if (pcCerts[i])
        {
            CertFreeCertificateContext(pcCerts[i]);
        }
    }

    return(0);
}


void _LoadCerts(PCERT_CONTEXT *ppCerts)
{
    HRSRC               hrsrc;
    int                 i;
    CRYPT_DATA_BLOB     sBlob;
    PCCERT_CONTEXT      pCert;
    HGLOBAL     hglobRes;
    HCERTSTORE  hResStore;


    for (i = 0; i < (_MAX_CERTS); i++)
    {
        ppCerts[i] = NULL;
    }

    if (hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_CERTS), TEXT("CERTS")))
    {
        if (hglobRes = LoadResource(GetModuleHandle(NULL), hrsrc))
        {
            sBlob.cbData = SizeofResource(GetModuleHandle(NULL), hrsrc);
            sBlob.pbData = (BYTE *)LockResource(hglobRes);

            hResStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED, 
                                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      NULL,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      &sBlob);

            if (!(hResStore))
            {
                UnlockResource(hglobRes);
                FreeResource(hglobRes);
                return;
            }

            i       = 0;
            pCert   = NULL;
            while (((pCert = CertEnumCertificatesInStore(hResStore, pCert)) !=NULL) &&
                    (i < _MAX_CERTS))
            {
                ppCerts[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(pCert);
                i++;
            }

            CertCloseStore(hResStore, 0);

            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtcat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtcat.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


WVTLOOPDATA saDriverLoopData[] = 
{
    L"FILESET\\SIGNED\\cert_pcb.cab", &gDriver, L"FILESET\\DRIVER.CAT",  L"cert_pcb.cab", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\good_pcb.cab", &gDriver, L"FILESET\\DRIVER.CAT",  L"good_pcb.cab", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig_pcb.cab",  &gDriver, L"FILESET\\DRIVER.CAT",  L"sig_pcb.cab",  WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\cert_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"cert_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\good_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"good_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig2_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"sig2_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig3_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"sig3_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig3_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"Handle",       WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

DWORD WINAPI TestWVTCat(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;

    HRESULT                 hr;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;

    WVTLOOPDATA             *psLoop;

    psData->dwTotalProcessed = 0;

    printf("\n  WVT_CAT");

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.dwUnionChoice          = WTD_CHOICE_CATALOG;
    sWTD.pCatalog               = &sWTCI;

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CATALOG_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);

    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        psLoop = &saDriverLoopData[0];

        while (psLoop->pwszFileName)
        {
            sWTD.dwStateAction          = psLoop->dwStateControl;

            sWTCI.pcwszCatalogFilePath  = psLoop->pwszCatalogFile;
            sWTCI.pcwszMemberTag        = psLoop->pwszTag;
            sWTCI.pcwszMemberFilePath   = psLoop->pwszFileName;
            
            hr = WinVerifyTrust(NULL, psLoop->pgProvider, &sWTD);

            if (fVerbose)
            {
                wprintf(L"\nWVT returned 0x%08.8x: %s", hr, psLoop->pwszFileName);
            }

            psData->dwTotalProcessed++;

            psLoop++;
        }
    }

    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\crypthash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypthash.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sha.h"
#include    "md5.h"


BOOL _HashFile(HANDLE hFile, char *pszFile, BOOL fSha1);

DWORD WINAPI TestCryptHash(ThreadData *psData)
{
    COleDateTime    tStart;
    COleDateTime    tEnd;
    DWORD           i;
    char            szFile[MAX_PATH];

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    HCRYPTPROV              hProv;
    HANDLE                  hFile;

    WCHAR                   *pwszLastSlash;
    WCHAR                   wszDir[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwDirLen;

    hFind   = INVALID_HANDLE_VALUE;

    psData->dwTotalProcessed = 0;

    printf("\n  CRYPT_HASH");

    if (pwszLastSlash = wcsrchr(pwszInFile, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszInFile);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }


    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        szFile[0] = NULL;
        WideCharToMultiByte(0, 0, pwszInFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

        if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
        {
            goto FileFindError;
        }

        fFind   = TRUE;

        while (fFind)
        {
            if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                if (dwDirLen > 0)
                {
                    wcscpy(&wszFile[0], &wszDir[0]);
                }

                wszFile[dwDirLen] = NULL;
                MultiByteToWideChar(0, 0, &sFindData.cFileName[0], -1, &wszFile[dwDirLen], MAX_PATH * sizeof(WCHAR));

                hFile = CreateFileU(&wszFile[0], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    if (_HashFile(hFile, sFindData.cFileName, 
                                        (psData->dwPassThrough & PASSTHROUGH_SHA1) ? TRUE : FALSE))
                    {
                        psData->dwTotalProcessed++;
                    }
            
                    CloseHandle(hFile);
                }
            }
    
            fFind = FindNextFile(hFind, &sFindData);
        }

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }
    }

ErrorReturn:
    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);

    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
}

BOOL _HashFile(HANDLE hFile, char *pszFile, BOOL fSha1)
{
    DWORD       cbHash;
    BYTE        bHash[30];
    BYTE        *pbFile;
    DWORD       cbFile;
    HANDLE      hMappedFile;
    BOOL        fRet;

    MD5_CTX     sMD5;
    A_SHA_CTX   sSHA1;

    pbFile      = NULL;
    hMappedFile = NULL;

    if (fVerbose)
    {
        printf("\n   %s   ", pszFile);
    }

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        hMappedFile = NULL;
        goto CreateMapError;
    }

    if (!(pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0)))
    {
        goto MapViewError;
    }

    cbFile = GetFileSize(hFile, NULL);

    if (fSha1)
    {
        memset(&sSHA1, 0x00, sizeof(A_SHA_CTX));
        A_SHAInit(&sSHA1);
        A_SHAUpdate(&sSHA1, pbFile, cbFile);
        A_SHAFinal(&sSHA1, &bHash[0]);
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        memset(&sMD5, 0x00, sizeof(MD5_CTX));
        MD5Init(&sMD5);
        MD5Update(&sMD5, pbFile, cbFile);
        MD5Final(&sMD5);

        memcpy(&bHash[0], sMD5.digest, MD5DIGESTLEN);
        cbHash = MD5DIGESTLEN;
    }

    //dwTotalBytes += cbFile;

    if (fVerbose)
    {
        DWORD   i;

        for (i = 0; i < cbHash; i++)
        {
            printf("%02.2X", bHash[i]);
        }
    }

    fRet = TRUE;

CommonReturn:

    if (hMappedFile)
    {
        CloseHandle(hMappedFile);
    }

    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

    return(fRet);

ErrorReturn:
    if (fVerbose)
    {
        printf("*failed*");
    }

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, CreateMapError);
    TRACE_ERROR_EX(DBG_SS_APP, MapViewError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtfile.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

DWORD WINAPI TestWVTFile(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;
    char                    szFile[MAX_PATH];

    HRESULT                 hr;
    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    WCHAR                   *pwszLastSlash;
    WCHAR                   wszDir[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwDirLen;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;


    hFind   = INVALID_HANDLE_VALUE;

    psData->dwTotalProcessed = 0;

    printf("\n  WVT_FILE");

    if (pwszLastSlash = wcsrchr(pwszInFile, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszInFile);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;
    sWTD.dwUnionChoice      = WTD_CHOICE_FILE;
    sWTD.pFile              = &sWTFI;

    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);

    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        szFile[0] = NULL;
        WideCharToMultiByte(0, 0, pwszInFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

        if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
        {
            goto FileFindError;
        }

        fFind   = TRUE;

        while (fFind)
        {
            if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {

                if (dwDirLen > 0)
                {
                    wcscpy(&wszFile[0], &wszDir[0]);
                }

                wszFile[dwDirLen] = NULL;
                MultiByteToWideChar(0, 0, &sFindData.cFileName[0], -1, &wszFile[dwDirLen], MAX_PATH * sizeof(WCHAR));

                sWTFI.pcwszFilePath     = &wszFile[0];

                hr = WinVerifyTrust(NULL, &gAuthCode, &sWTD);

                if (fVerbose)
                {
                    printf("\n   WVT return: 0x%08.8lX - %s", hr, &sFindData.cFileName[0]);
                }

                psData->dwTotalProcessed++;
            }
    
            fFind = FindNextFile(hFind, &sFindData);
        }

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }
    }

ErrorReturn:
    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);

    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\performance\perftest\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by perftest.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_SSGUID                11
#define IDS_PARAMTEXT_SSGUID            12
#define IDS_PARAM_ADD2DB                13
#define IDS_PARAMTEXT_ADD2DB            14
#define IDS_PARAM_EXPERROR              16
#define IDS_PARAMTEXT_EXPERROR          17
#define IDS_PARAM_NOTHREADS             18
#define IDS_PARAMTEXT_NOTHREADS         19
#define IDS_PARAM_NOPASSES              20
#define IDS_PARAMTEXT_NOPASSES          21
#define IDS_PARAM_WVTCAT                22
#define IDS_PARAMTEXT_WVTCAT            23
#define IDS_PARAM_CATADD                24
#define IDS_PARAMTEXT_CATADD            25
#define IDS_PARAM_WVTFILE               26
#define IDS_PARAMTEXT_WVTFILE           27
#define IDS_PARAM_CRYPTHASH             28
#define IDS_PARAMTEXT_CRYPTHASH         29
#define IDS_PARAM_WVTCERT               30
#define IDS_PARAMTEXT_WVTCERT           31
#define IDS_PARAM_HASHSHA1              32
#define IDS_PARAMTEXT_HASHSHA1          33
#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\authcode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       authcode.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubAuthenticode
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

// Following is also called from .\httpsprv.cpp

void UpdateCertError(
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = pSgnr->pChainContext;
    LONG lChainIndex = pPolicyStatus->lChainIndex;
    LONG lElementIndex = pPolicyStatus->lElementIndex;
    DWORD dwProvCertIndex;
    LONG i;

    assert (lChainIndex < (LONG) pChainContext->cChain);
    if (0 > lChainIndex || lChainIndex >= (LONG) pChainContext->cChain ||
            0 > lElementIndex) {
        if (CERT_E_CHAINING == pPolicyStatus->dwError) {
            if (0 < pSgnr->csCertChain) {
                PCRYPT_PROVIDER_CERT pProvCert;

                pProvCert = WTHelperGetProvCertFromChain(
                    pSgnr, pSgnr->csCertChain - 1);
                if (0 == pProvCert->dwError)
                    pProvCert->dwError = pPolicyStatus->dwError;
            }
        }
        return;
    }

    dwProvCertIndex = 0;
    for (i = 0; i < lChainIndex; i++) {
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        dwProvCertIndex += pChain->cElement;
    }
    dwProvCertIndex += lElementIndex;

    if (dwProvCertIndex < pSgnr->csCertChain) {
        PCRYPT_PROVIDER_CERT pProvCert;

        pProvCert = WTHelperGetProvCertFromChain(pSgnr, dwProvCertIndex);
        pProvCert->dwError = pPolicyStatus->dwError;
    }
}

    
HRESULT WINAPI SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD dwError;
    DWORD i1;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA ExtraPolicyPara;
    memset(&ExtraPolicyPara, 0, sizeof(ExtraPolicyPara));
    ExtraPolicyPara.cbSize = sizeof(ExtraPolicyPara);
    ExtraPolicyPara.dwRegPolicySettings = pProvData->dwRegPolicySettings;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) &ExtraPolicyPara;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS ExtraPolicyStatus;
    memset(&ExtraPolicyStatus, 0, sizeof(ExtraPolicyStatus));
    ExtraPolicyStatus.cbSize = sizeof(ExtraPolicyStatus);

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.pvExtraPolicyStatus = (void *) &ExtraPolicyStatus;


    //
    // check the high level error codes. For SAFER, must also have a
    // signer and subject hash.
    //
    dwError = checkGetErrorBasedOnStepErrors(pProvData);


    // Check if we have a valid signature

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0 ||
            NULL == pProvData->pPDSip ||
            NULL == pProvData->pPDSip->psIndirectData ||
            0 == pProvData->pPDSip->psIndirectData->Digest.cbData)
    {
        if (pProvData->dwProvFlags & (WTD_SAFER_FLAG | WTD_HASH_ONLY_FLAG))
        {
            pProvData->dwFinalError = dwError;
            return TRUST_E_NOSIGNATURE;
        }
    }
    else if (pProvData->dwProvFlags & WTD_HASH_ONLY_FLAG)
    {
        pProvData->dwFinalError = 0;
        return S_OK;
    }

    if (0 != dwError)
    {
        goto CommonReturn;
    }



    //
    //  check each signer
    //
    for (i1 = 0; i1 < pProvData->csSigners; i1++) {
        CRYPT_PROVIDER_SGNR *pSgnr;
        LPSTR pszUsage;

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i1, FALSE, 0);

        pszUsage = pProvData->pszUsageOID;
        if (pszUsage && 0 != strcmp(pszUsage, szOID_PKIX_KP_CODE_SIGNING))
            // Inhibit checking of signer purpose
            ExtraPolicyPara.pSignerInfo = NULL;
        else
            ExtraPolicyPara.pSignerInfo = pSgnr->psSigner;

        if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_AUTHENTICODE,
                pSgnr->pChainContext,
                &PolicyPara,
                &PolicyStatus
                )) {
            dwError = TRUST_E_SYSTEM_ERROR;
            goto CommonReturn;
        }

        if (CERT_E_REVOCATION_FAILURE == PolicyStatus.dwError &&
                (pProvData->dwProvFlags & WTD_SAFER_FLAG)) {
            // For SAFER, ignore NO_CHECK errors
            if (0 == (pSgnr->pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_OFFLINE_REVOCATION)) {
                PolicyStatus.dwError = 0;
            }
        }

        if (0 != PolicyStatus.dwError) {
            dwError = PolicyStatus.dwError;
            UpdateCertError(pSgnr, &PolicyStatus);
            goto CommonReturn;
        } else if (0 < pSgnr->csCertChain) {
            PCRYPT_PROVIDER_CERT pProvCert;

            pProvCert = WTHelperGetProvCertFromChain(pSgnr, 0);
            if (CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                // Policy says to ignore offline revocation errors
                pProvCert->dwError = 0;
                pProvCert->dwRevokedReason = 0;
            }
        }

        if (pSgnr->csCounterSigners) {
            AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA TSExtraPolicyPara;
            memset(&TSExtraPolicyPara, 0, sizeof(TSExtraPolicyPara));
            TSExtraPolicyPara.cbSize = sizeof(TSExtraPolicyPara);
            TSExtraPolicyPara.dwRegPolicySettings =
                pProvData->dwRegPolicySettings;
            TSExtraPolicyPara.fCommercial = ExtraPolicyStatus.fCommercial;

            CERT_CHAIN_POLICY_PARA TSPolicyPara;
            memset(&TSPolicyPara, 0, sizeof(TSPolicyPara));
            TSPolicyPara.cbSize = sizeof(TSPolicyPara);
            TSPolicyPara.pvExtraPolicyPara = (void *) &TSExtraPolicyPara;

            CERT_CHAIN_POLICY_STATUS TSPolicyStatus;
            memset(&TSPolicyStatus, 0, sizeof(TSPolicyStatus));
            TSPolicyStatus.cbSize = sizeof(TSPolicyStatus);


            //
            //  check counter signers
            //
            for (DWORD i2 = 0; i2 < pSgnr->csCounterSigners; i2++)
            {
                PCRYPT_PROVIDER_SGNR pCounterSgnr =
                    WTHelperGetProvSignerFromChain(pProvData, i1, TRUE, i2);

                //
                //  do we care about this counter signer?
                //
                if (pCounterSgnr->dwSignerType != SGNR_TYPE_TIMESTAMP)
                    continue;

                if (!CertVerifyCertificateChainPolicy(
                        CERT_CHAIN_POLICY_AUTHENTICODE_TS,
                        pCounterSgnr->pChainContext,
                        &TSPolicyPara,
                        &TSPolicyStatus
                        )) {
                    dwError = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                }

                if (CERT_E_REVOCATION_FAILURE == TSPolicyStatus.dwError &&
                        (pProvData->dwProvFlags & WTD_SAFER_FLAG)) {
                    // For SAFER, ignore NO_CHECK errors
                    if (0 == (pCounterSgnr->pChainContext->TrustStatus.dwErrorStatus &
                            CERT_TRUST_IS_OFFLINE_REVOCATION)) {
                        TSPolicyStatus.dwError = 0;
                    }
                }

                if (0 != TSPolicyStatus.dwError) {
                    // On April 13, 1999 changed to map all time stamp errors
                    // to TRUST_E_TIME_STAMP
                    dwError = TRUST_E_TIME_STAMP;
//                    dwError = TSPolicyStatus.dwError;
                    UpdateCertError(pCounterSgnr, &TSPolicyStatus);
                    goto CommonReturn;
                } else if (0 < pCounterSgnr->csCertChain) {
                    PCRYPT_PROVIDER_CERT pProvCert;

                    pProvCert = WTHelperGetProvCertFromChain(pCounterSgnr, 0);
                    if (CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                        // Policy says to ignore offline revocation errors
                        pProvCert->dwError = 0;
                        pProvCert->dwRevokedReason = 0;
                    }
                }
            }
        }
    }
    
    dwError = 0;
CommonReturn:
    pProvData->dwFinalError = dwError;

    return SoftpubCallUI(pProvData, dwError, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\callui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       callui.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubCallUI
//
//              *** local functions ***
//              _AllocGetOpusInfo
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "trustdb.h"
#include    "acui.h"
#include    "winsafer.h"

SPC_SP_OPUS_INFO *_AllocGetOpusInfo(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSigner,
                                    DWORD *pcbOpusInfo);



#define MIN_HASH_LEN                16
#define MAX_HASH_LEN                20

// Returns:
//   S_FALSE
//      not found in the database
//   TRUST_E_SYSTEM_ERROR
//      system errors while attempting to do the check
//   S_OK
//      found in the database
//   TRUST_E_EXPLICIT_DISTRUST
//      explicitly disallowed in the database or revoked
HRESULT _CheckTrustedPublisher(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD dwError,
    BOOL fOnlyDisallowed
    )
{
    CRYPT_PROVIDER_SGNR *pSigner;
    PCCERT_CONTEXT pPubCert;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    HCERTSTORE hStore;

    if (CERT_E_REVOKED == dwError)
    {
        return TRUST_E_EXPLICIT_DISTRUST;
    }

    pSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    if (NULL == pSigner || pSigner->csCertChain <= 0)
    {
        return S_FALSE;
    }

    pPubCert = WTHelperGetProvCertFromChain(pSigner, 0)->pCert;

    // Check if disallowed.

    // Since the signature component can be altered, must use the signature
    // hash

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pPubCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
    {
        return TRUST_E_SYSTEM_ERROR;
    }

    hStore = OpenDisallowedStore();

    if (hStore)
    {
        PCCERT_CONTEXT pFoundCert;

        pFoundCert = CertFindCertificateInStore(
            hStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );

        CertCloseStore(hStore, 0);
        if (pFoundCert)
        {
            CertFreeCertificateContext(pFoundCert);
            return TRUST_E_EXPLICIT_DISTRUST;
        }
    }

    if (fOnlyDisallowed)
    {
        return S_FALSE;
    }

    if (S_OK != dwError)
    {
        // Everything must be valid to allow a trusted publisher
        return S_FALSE;
    }

    // Check if trusted publisher

    hStore = OpenTrustedPublisherStore();

    if (hStore)
    {
        PCCERT_CONTEXT pFoundCert;

        pFoundCert = CertFindCertificateInStore(
            hStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );

        CertCloseStore(hStore, 0);
        if (pFoundCert)
        {
            CertFreeCertificateContext(pFoundCert);
            return S_OK;
        }
    }

    return S_FALSE;
}


typedef BOOL (WINAPI *PFN_SAFERI_SEARCH_MATCHING_HASH_RULES)(
        IN ALG_ID       HashAlgorithm OPTIONAL,
        IN PBYTE        pHashBytes,
        IN DWORD        dwHashSize,
        IN DWORD        dwOriginalImageSize OPTIONAL,
        OUT PDWORD      pdwFoundLevel,
        OUT PDWORD      pdwUIFlags
        );

// Returns:
//   S_FALSE
//      not found in the database
//   S_OK
//      fully trusted in the database
//   TRUST_E_EXPLICIT_DISTRUST
//      explicitly disallowed in the database
HRESULT _CheckTrustedCodeHash(CRYPT_PROVIDER_DATA *pProvData)
{
    static BOOL fGotProcAddr = FALSE;
    static PFN_SAFERI_SEARCH_MATCHING_HASH_RULES
                    pfnCodeAuthzSearchMatchingHashRules = NULL;

    DWORD cbHash;

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] == 0 &&
        pProvData->pPDSip && pProvData->pPDSip->psIndirectData)
    {
        cbHash = pProvData->pPDSip->psIndirectData->Digest.cbData;
    }
    else
    {
        cbHash = 0;
    }

    if (0 == cbHash)
    {
        return S_FALSE;
    }

    // wintrust.dll has a static dependency on advapi32.dll. However, not
    // all advapi32.dll's will export "SaferiSearchMatchingHashRules"
    if (!fGotProcAddr)
    {
        HMODULE hModule;

        hModule = GetModuleHandleA("advapi32.dll");
        if (NULL != hModule)
        {
            pfnCodeAuthzSearchMatchingHashRules =
                (PFN_SAFERI_SEARCH_MATCHING_HASH_RULES) GetProcAddress(
                    hModule, "SaferiSearchMatchingHashRules");
        }

        fGotProcAddr = TRUE;
    }

    if (NULL != pfnCodeAuthzSearchMatchingHashRules)
    {
        __try
        {
            DWORD dwFoundLevel = 0xFFFFFFFF;
            DWORD dwUIFlags = 0;

            if (pfnCodeAuthzSearchMatchingHashRules(
                    CertOIDToAlgId(pProvData->pPDSip->psIndirectData->DigestAlgorithm.pszObjId),
                    pProvData->pPDSip->psIndirectData->Digest.pbData,
                    cbHash,
                    0,                      // dwOriginalImageSize
                    &dwFoundLevel,
                    &dwUIFlags
                    ))
            {
                switch (dwFoundLevel)
                {
                    case SAFER_LEVELID_FULLYTRUSTED:
                        return S_OK;
                    case SAFER_LEVELID_DISALLOWED:
                        return TRUST_E_EXPLICIT_DISTRUST;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return S_FALSE;
}


HRESULT SoftpubCallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError, BOOL fFinalCall)
{
    HRESULT hr;
    DWORD dwUIChoice;

    if (!(fFinalCall))
    {
        //  TBDTBD:  if we want the user to get involved along the way???
        return(ERROR_SUCCESS);
    }

    if (0 == (pProvData->dwProvFlags & WTD_SAFER_FLAG))
    {
        if (!(pProvData->dwRegPolicySettings & WTPF_ALLOWONLYPERTRUST) &&
            (pProvData->pWintrustData->dwUIChoice == WTD_UI_NONE))
        {
            if (S_OK == dwError)
            {
                //
                // Check for untrusted publisher
                //
                hr = _CheckTrustedPublisher(pProvData, dwError, TRUE);
                if (TRUST_E_EXPLICIT_DISTRUST == hr)
                {
                    return TRUST_E_EXPLICIT_DISTRUST;
                }
            }

            return(dwError);
        }
    }


    //
    // Check for trusted or disallowed subject hash
    //
    hr = _CheckTrustedCodeHash(pProvData);
    if (S_FALSE != hr)
    {
        if (S_OK == hr)
        {
            // Ensure we always indicate trust.
            pProvData->dwFinalError = 0;
        }
        return hr;
    }

    //
    // Check for trusted or disallowed publisher
    //
    hr = _CheckTrustedPublisher(pProvData, dwError, FALSE);
    if (S_FALSE != hr)
    {
        if (S_OK == hr)
        {
            // Ensure we always indicate trust.
            pProvData->dwFinalError = 0;
        }
        return hr;
    }

    if (pProvData->dwRegPolicySettings & WTPF_ALLOWONLYPERTRUST)
    {
        if (0 == dwError)
        {
            return CRYPT_E_SECURITY_SETTINGS;
        }
        return dwError;
    }

    dwUIChoice  = pProvData->pWintrustData->dwUIChoice;

    if ((dwUIChoice == WTD_UI_NONE) ||
        ((dwUIChoice == WTD_UI_NOBAD) && (dwError != ERROR_SUCCESS)) ||
        ((dwUIChoice == WTD_UI_NOGOOD) && (dwError == ERROR_SUCCESS)))
    {
        if (0 == dwError)
        {
            // No explicit trust
            pProvData->dwFinalError = TRUST_E_SUBJECT_NOT_TRUSTED;
        }
        return dwError;
    }

    //
    //  call the ui
    //
    HINSTANCE               hModule = NULL;
    IPersonalTrustDB        *pTrustDB = NULL;
    ACUI_INVOKE_INFO        aii;
    pfnACUIProviderInvokeUI pfn = NULL;
    DWORD                   cbOpusInfo;
    CRYPT_PROVIDER_SGNR     *pRootSigner;

    pRootSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    OpenTrustDB(NULL, IID_IPersonalTrustDB, (LPVOID*)&pTrustDB);

    memset(&aii, 0x00, sizeof(ACUI_INVOKE_INFO));

    //
    // Setup the UI invokation
    //

    aii.cbSize                  = sizeof(ACUI_INVOKE_INFO);
    aii.hDisplay                = pProvData->hWndParent;
    aii.pProvData               = pProvData;
    aii.hrInvokeReason          = dwError;
    aii.pwcsAltDisplayName      = WTHelperGetFileName(pProvData->pWintrustData);
    aii.pPersonalTrustDB        = (IUnknown *)pTrustDB;

    if (pRootSigner)
    {
        aii.pOpusInfo   = _AllocGetOpusInfo(pProvData, pRootSigner, &cbOpusInfo);
    }

    //
    // Load the default authenticode UI.
    //
    if (hModule = LoadLibraryA(CVP_DLL))
    {
        pfn = (pfnACUIProviderInvokeUI)GetProcAddress(hModule, "ACUIProviderInvokeUI");
    }

    //
    // Invoke the UI
    //
    if (pfn)
    {
        hr = (*pfn)(&aii);
    }
    else
    {
        hr = TRUST_E_PROVIDER_UNKNOWN;
        pProvData->dwError = hr;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_UIPROV] = hr;

        DBG_PRINTF((DBG_SS, "Unable to load CRYPTUI.DLL\n"));

    }

    //
    // Return the appropriate code
    //

    if (pTrustDB)
    {
        pTrustDB->Release();
    }

    if (aii.pOpusInfo)
    {
        TrustFreeDecode(WVT_MODID_SOFTPUB, (BYTE **)&aii.pOpusInfo);
    }

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return hr;
}


SPC_SP_OPUS_INFO *_AllocGetOpusInfo(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSigner,
                                    DWORD *pcbOpusInfo)
{
    PCRYPT_ATTRIBUTE    pAttr;
    PSPC_SP_OPUS_INFO   pInfo;

    pInfo   = NULL;

    if (!(pSigner->psSigner))
    {
        goto NoSigner;
    }

    if (pSigner->psSigner->AuthAttrs.cAttr == 0)
    {
        goto NoOpusAttribute;
    }

    if (!(pAttr = CertFindAttribute(SPC_SP_OPUS_INFO_OBJID,
                                    pSigner->psSigner->AuthAttrs.cAttr,
                                    pSigner->psSigner->AuthAttrs.rgAttr)))
    {
        goto NoOpusAttribute;
    }

    if (!(pAttr->rgValue))
    {
        goto NoOpusAttribute;
    }

    if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pInfo, pcbOpusInfo, 200,
                      pProvData->dwEncoding, SPC_SP_OPUS_INFO_STRUCT,
                      pAttr->rgValue->pbData, pAttr->rgValue->cbData, CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeError;
    }

    return(pInfo);

ErrorReturn:
    return(NULL);

    TRACE_ERROR_EX(DBG_SS, NoSigner);
    TRACE_ERROR_EX(DBG_SS, NoOpusAttribute);
    TRACE_ERROR_EX(DBG_SS, DecodeError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\chkcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chkcert.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubCheckCert
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL WINAPI SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                             BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\certprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubDefCertInit
//
//  History:    02-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HRESULT WINAPI SoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    HRESULT                     hr;
    GUID                        gAuthenticode = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

    //
    //  fill in the Authenticode Functions
    //
    memset(&sAuthenticodePfns, 0x00, sizeof(CRYPT_PROVIDER_FUNCTIONS));
    sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &sAuthenticodePfns)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    hr = S_OK;

    if (sAuthenticodePfns.pfnInitialize)
    {
        hr = sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    if (pProvData->pWintrustData)
    {
        if (pProvData->pWintrustData->pPolicyCallbackData)
        {
            pProvData->pszUsageOID = (char *)pProvData->pWintrustData->pPolicyCallbackData;
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\clnprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       clnprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubInitialize
//
//  History:    23-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


HRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\checks.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       checks.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  checkGetErrorBasedOnStepErrors
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


DWORD checkGetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // problem with file
    if ((pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO] != 0) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE] != 0))
    {
        return(CRYPT_E_FILE_ERROR);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\drvprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drvprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  DriverInitializePolicy
//              DriverCleanupPolicy
//              DriverFinalPolicy
//              DriverRegisterServer
//              DriverUnregisterServer
//
//              *** local functions ***
//              _ValidCatAttr
//              _CheckVersionAttributeNEW
//              _CheckVersionNEW
//              _GetVersionNumbers
//
//  History:    29-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include        "global.hxx"

BOOL _GetVersionNumbers(
                        WCHAR *pwszMM, 
                        DWORD *pdwMajor, 
                        DWORD *pdwMinor, 
                        DWORD *pdwBuild, 
                        WCHAR *pwcFlagMinor, 
                        WCHAR *pwcFlagBuild);
BOOL _ValidCatAttr(CRYPTCATATTRIBUTE *pAttr);
BOOL _CheckVersionAttributeNEW(DRIVER_VER_INFO *pVerInfo, CRYPTCATATTRIBUTE *pAttr);
DWORD _CheckVersionNEW(OSVERSIONINFO *pVersion, WCHAR *pwszAttr, BOOL fUseBuildNumber);

static LPSTR   rgDriverUsages[] = {szOID_WHQL_CRYPTO, szOID_NT5_CRYPTO, szOID_OEM_WHQL_CRYPTO};
static CERT_USAGE_MATCH RequestUsage = {USAGE_MATCH_TYPE_OR, {sizeof(rgDriverUsages)/sizeof(LPSTR), rgDriverUsages}};

typedef struct _DRVPROV_PRIVATE_DATA
{
    DWORD                       cbStruct;

    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

} DRVPROV_PRIVATE_DATA, *PDRVPROV_PRIVATE_DATA;

#define VER_CHECK_EQ    1
#define VER_CHECK_GT    2
#define VER_CHECK_LT    3
#define VER_CHECK_FAIL  4

HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return (S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pRequestUsage)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return (S_FALSE);
    }

    GUID                        gAuthenticode   = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                        gDriverProv     = DRIVER_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     sPrivData;
    CRYPT_PROVIDER_PRIVDATA     *pPrivData;
    DRVPROV_PRIVATE_DATA        *pDriverData;
    HRESULT                     hr;

    hr = S_OK;

    pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (!(pPrivData))
    {
        memset(&sPrivData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
        sPrivData.cbStruct      = sizeof(CRYPT_PROVIDER_PRIVDATA);

        memcpy(&sPrivData.gProviderID, &gDriverProv, sizeof(GUID));

        //
        //  add my data to the chain!
        //
        if (!pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sPrivData))
        {
            return (S_FALSE);    
        }

        //
        //  get the new reference
        //
        pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);
    }


    //
    //  allocate space for my struct
    //
    if (!(pPrivData->pvProvData = pProvData->psPfns->pfnAlloc(sizeof(DRVPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return (S_FALSE);
    }

    memset(pPrivData->pvProvData, 0x00, sizeof(DRVPROV_PRIVATE_DATA));
    pPrivData->cbProvData   = sizeof(DRVPROV_PRIVATE_DATA);

    pDriverData             = (DRVPROV_PRIVATE_DATA *)pPrivData->pvProvData;
    pDriverData->cbStruct   = sizeof(DRVPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    pDriverData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &pDriverData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sPrivData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return (S_FALSE);
    }

    if (pDriverData->sAuthenticodePfns.pfnInitialize)
    {
        hr = pDriverData->sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    pProvData->pRequestUsage = &RequestUsage;

    // for backwards compatibility
    pProvData->pszUsageOID  = szOID_WHQL_CRYPTO;


    //
    //  do NOT allow test certs EVER!
    //
    //  changed July 27, 2000
    //
    pProvData->dwRegPolicySettings  &= ~(WTPF_TRUSTTEST | WTPF_TESTCANBEVALID);

    //
    //  do NOT require the publisher to be in the trusted database
    //
    //  (changed July 27, 2000)
    //
    pProvData->dwRegPolicySettings  &= ~WTPF_ALLOWONLYPERTRUST;

    return (hr);
}

HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gDriverProv = DRIVER_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;
    DRVPROV_PRIVATE_DATA        *pDriverData;
    HRESULT                     hr;

    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return (S_FALSE);
    }

    hr = S_OK;

    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (pMyData)
    {
        pDriverData = (DRVPROV_PRIVATE_DATA *)pMyData->pvProvData;

        if (pDriverData != NULL)
        {
            //
            // remove the data we allocated except for the "MyData" 
            // which WVT will clean up for us!
            //
            if (pDriverData->sAuthenticodePfns.pfnCleanupPolicy)
            {
                hr = pDriverData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
            }
        }

        pProvData->psPfns->pfnFree(pMyData->pvProvData);
        pMyData->pvProvData = NULL;
        pMyData->cbProvData = 0;
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
static void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = malloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        free(pvData);
        goto GetParamError;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

//+-------------------------------------------------------------------------
//  Alloc and NOCOPY Decode
//--------------------------------------------------------------------------
static void *AllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            );
    if (cbStructInfo == 0)
        goto ErrorReturn;
    if (NULL == (pvStructInfo = malloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            )) {
        free(pvStructInfo);
        goto ErrorReturn;
    }

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

static void CopyBytesToMaxPathString(
    IN const BYTE *pbData,
    IN DWORD cbData,
    OUT WCHAR wszDst[MAX_PATH]
    )
{
    DWORD cchDst;

    if (pbData) {
        cchDst = cbData / sizeof(WCHAR);
        if (cchDst > MAX_PATH - 1)
            cchDst = MAX_PATH - 1;
    } else
        cchDst = 0;

    if (cchDst)
        memcpy(wszDst, pbData, cchDst * sizeof(WCHAR));

    wszDst[cchDst] = L'\0';
}

void UpdateDriverVersion(
    IN CRYPT_PROVIDER_DATA *pProvData,
    OUT WCHAR wszVersion[MAX_PATH]
    )
{
    HCRYPTMSG hMsg = pProvData->hMsg;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    PCTL_INFO pCtlInfo = NULL;
    PCERT_EXTENSION pExt;               // not allocated
    PCAT_NAMEVALUE pNameValue = NULL;

    if (NULL == hMsg)
        goto NoMessage;

    // Get the inner content.
    if (NULL == (pbContent = (BYTE *) AllocAndGetMsgParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            &cbContent))) goto GetContentError;

    if (NULL == (pCtlInfo = (PCTL_INFO) AllocAndDecodeObject(
            PKCS_CTL,
            pbContent,
            cbContent
            )))
        goto DecodeCtlError;

    if (NULL == (pExt = CertFindExtension(
            CAT_NAMEVALUE_OBJID,
            pCtlInfo->cExtension,
            pCtlInfo->rgExtension
            )))
        goto NoVersionExt;

    if (NULL == (pNameValue = (PCAT_NAMEVALUE) AllocAndDecodeObject(
            CAT_NAMEVALUE_STRUCT,
            pExt->Value.pbData,
            pExt->Value.cbData
            )))
        goto DecodeNameValueError;

    CopyBytesToMaxPathString(pNameValue->Value.pbData,
        pNameValue->Value.cbData, wszVersion);

CommonReturn:
    if (pNameValue)
        free(pNameValue);
    if (pCtlInfo)
        free(pCtlInfo);
    if (pbContent)
        free(pbContent);

    return;
ErrorReturn:
    wszVersion[0] = L'\0';
    goto CommonReturn;

TRACE_ERROR(NoMessage)
TRACE_ERROR(GetContentError)
TRACE_ERROR(DecodeCtlError)
TRACE_ERROR(NoVersionExt)
TRACE_ERROR(DecodeNameValueError)
}


BOOL _ValidCatAttr(CRYPTCATATTRIBUTE *pAttr)
{
    if (!(pAttr) || (pAttr->cbValue < 1) || !(pAttr->pbValue))
    {
        return(FALSE);
    }

    return TRUE;
}

HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gDriverProv = DRIVER_ACTION_VERIFY;
    HRESULT                     hr;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;

    CRYPTCATATTRIBUTE           *pCatAttr;
    CRYPTCATATTRIBUTE           *pMemAttr;

    DRIVER_VER_INFO             *pVerInfo;

    DWORD                       dwExceptionCode;
    BOOL                        fUseCurrentOSVer = FALSE;

    hr  = ERROR_SUCCESS;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)) ||
        !(pProvData->pWintrustData) ||
        !(_ISINSTRUCT(WINTRUST_DATA, pProvData->pWintrustData->cbStruct, hWVTStateData)))
    {
        goto ErrorInvalidParam;
    }

    //
    // Initialize the fUseCurrentOSVer variable
    //
    if (_ISINSTRUCT(WINTRUST_DATA, pProvData->pWintrustData->cbStruct, dwProvFlags))
    {
        fUseCurrentOSVer = 
            (pProvData->pWintrustData->dwProvFlags & WTD_USE_DEFAULT_OSVER_CHECK) != 0;
    }

    //
    //  
    //
    pVerInfo = (DRIVER_VER_INFO *)pProvData->pWintrustData->pPolicyCallbackData;

    if (pVerInfo)
    {
        CRYPT_PROVIDER_SGNR *pSgnr;
        CRYPT_PROVIDER_CERT *pCert;

        // KeithV
        // Today we do not support ranges of versions, so the version
        // number must be the same. Also must be none zero

        // Removed this check so that ranges can now be used - 9-10-99 (reidk)

        /*if ((_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionLow)) &&
            (_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionHigh)))
        {
            if(memcmp(&pVerInfo->sOSVersionLow,
                  &pVerInfo->sOSVersionHigh,
                  sizeof(DRIVER_VER_MAJORMINOR)) )
            {
                    goto ErrorInvalidParam;
            }
        }*/

        if (!(_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, pcSignerCertContext)))
        {
            goto ErrorInvalidParam;
        }

        pVerInfo->wszVersion[0] = NULL;

        if (!(pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
        {
            goto ErrorNoSigner;
        }

        if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 0)))
        {
            goto ErrorNoCert;
        }

        if (pCert->pCert)
        {
            CertGetNameStringW(
                pCert->pCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,                                  // dwFlags
                NULL,                               // pvTypePara
                pVerInfo->wszSignedBy,
                MAX_PATH
                );

            pVerInfo->pcSignerCertContext = CertDuplicateCertificateContext(pCert->pCert);

            if (pVerInfo->dwReserved1 == 0x1 && pVerInfo->dwReserved2 == 0) {
                HCRYPTMSG hMsg = pProvData->hMsg;

                // Return the message's store
                if (hMsg) {
                    HCERTSTORE hStore;
                    hStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                      // hCryptProv
                        0,                      // dwFlags
                        (const void *) hMsg
                        );
                    pVerInfo->dwReserved2 = (ULONG_PTR) hStore;
                }
            }
        }

    }


    if (pProvData->padwTrustStepErrors)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] = ERROR_SUCCESS;
    }

    if ((hr = checkGetErrorBasedOnStepErrors(pProvData)) != ERROR_SUCCESS)
    {
        goto StepError;
    }

    pCatAttr = NULL;
    pMemAttr = NULL;


    if ((pProvData->pPDSip) &&
        (_ISINSTRUCT(PROVDATA_SIP, pProvData->pPDSip->cbStruct, psIndirectData)) &&
        (pProvData->pPDSip->psSipSubjectInfo) &&
        (pProvData->pPDSip->psSipSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember->pStore) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember->pMember) &&
        (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG))
    {
      // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
      // DELAYLOAD fails an exception is raised.
      __try {
        HANDLE  hCatStore;

        hCatStore   = CryptCATHandleFromStore(pProvData->pPDSip->psSipSubjectInfo->psCatMember->pStore);

        //
        //  first look at the members attr
        //
        pMemAttr = CryptCATGetAttrInfo(hCatStore,
                                       pProvData->pPDSip->psSipSubjectInfo->psCatMember->pMember,
                                       L"OSAttr");

        pCatAttr = CryptCATGetCatAttrInfo(hCatStore, L"OSAttr");

        //
        // This statement is to honor old _weird_ semantics where if there is a
        // pointer to a pVerInfo struct and both the dwPlatformId/dwVersion fields         
        // of it are zero then don't do a version check. (probably for sigverif, or maybe
        // even un-intentional, but keep old semantics regardless)
        //
        if ((pVerInfo == NULL)          ||
            (pVerInfo->dwPlatform != 0) ||
            (pVerInfo->dwVersion != 0)  ||
            fUseCurrentOSVer)
        {
            
            if (_ValidCatAttr(pMemAttr))
            {
                if (!(_CheckVersionAttributeNEW(
                            fUseCurrentOSVer ? NULL : pVerInfo, 
                            pMemAttr)))
                {
                    goto OSAttrVersionError;
                }
            }
            else
            {
                if (!_ValidCatAttr(pCatAttr) && !_ValidCatAttr(pMemAttr))
                {
                    goto ValidOSAttrNotFound;
                }

                if (!(_CheckVersionAttributeNEW(
                            fUseCurrentOSVer ? NULL : pVerInfo,
                            pCatAttr)))
                {
                    goto OSAttrVersionError;                
                }
            }
        }

      } __except(EXCEPTION_EXECUTE_HANDLER) {
          dwExceptionCode = GetExceptionCode();
          goto CryptCATException;
      }
    }
    else if ((pProvData->pWintrustData) &&
             (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG))
    {
        goto ErrorInvalidParam;
    }

    //
    //  fill our name for SigVerif...
    //
    if (pVerInfo)
    {
        if (!(pVerInfo->wszVersion[0]))
        {
            if ((pMemAttr) && (pMemAttr->cbValue > 0) && (pMemAttr->pbValue))
            {
                CopyBytesToMaxPathString(pMemAttr->pbValue, pMemAttr->cbValue,
                    pVerInfo->wszVersion);
            }
            else if ((pCatAttr) && (pCatAttr->cbValue > 0) && (pCatAttr->pbValue))
            {
                CopyBytesToMaxPathString(pCatAttr->pbValue, pCatAttr->cbValue,
                    pVerInfo->wszVersion);
            }
            else
            {
                UpdateDriverVersion(pProvData, pVerInfo->wszVersion);
            }
        }
    }

    //
    //  retrieve my data from the provider struct
    //
    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (pMyData)
    {
        DRVPROV_PRIVATE_DATA    *pDriverData;

        pDriverData = (DRVPROV_PRIVATE_DATA *)pMyData->pvProvData;

        //
        //  call the standard final policy
        //
        if (pDriverData)
        {
            if (pDriverData->sAuthenticodePfns.pfnFinalPolicy)
            {
                DWORD   dwOldUIFlags;

                dwOldUIFlags = pProvData->pWintrustData->dwUIChoice;
                pProvData->pWintrustData->dwUIChoice    = WTD_UI_NONE;

                hr = pDriverData->sAuthenticodePfns.pfnFinalPolicy(pProvData);

                pProvData->pWintrustData->dwUIChoice    = dwOldUIFlags;
            }
        }
    }

    CommonReturn:
        if (hr != ERROR_INVALID_PARAMETER)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] = hr;
        }

        return (hr);

    ErrorReturn:
        hr = GetLastError();
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoSigner,     TRUST_E_NOSIGNATURE);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoCert,       TRUST_E_NO_SIGNER_CERT);
    SET_ERROR_VAR_EX(DBG_SS, ValidOSAttrNotFound,ERROR_APP_WRONG_OS);
    SET_ERROR_VAR_EX(DBG_SS, OSAttrVersionError,ERROR_APP_WRONG_OS);
    SET_ERROR_VAR_EX(DBG_SS, StepError,         hr);
    SET_ERROR_VAR_EX(DBG_SS, CryptCATException, dwExceptionCode);
}


#define         OSATTR_ALL          L'X'
#define         OSATTR_GTEQ         L'>'
#define         OSATTR_LTEQ         L'-'
#define         OSATTR_LTEQ2        L'<'
#define         OSATTR_OSSEP        L':'
#define         OSATTR_VERSEP       L'.'
#define         OSATTR_SEP          L','
#define         OSATTR_RANGE_SEP    L';'

//
// NEW
//
BOOL _CheckVersionAttributeNEW(DRIVER_VER_INFO *pVerInfo, CRYPTCATATTRIBUTE *pAttr)
{
    OSVERSIONINFO   sVersion;
    OSVERSIONINFO   sVersionSave;
    WCHAR           *pwszCurrent;
    WCHAR           *pwszEnd = NULL;
    WCHAR           *pwszRangeSeperator = NULL;
    BOOL            fCheckRange = FALSE;
    BOOL            fUseBuildNumber = FALSE;
    DWORD           dwLowCheck;
    DWORD           dwHighCheck;
    
    //
    // If no version info was passed in, get the current 
    // OS version to that verification can be done against it
    //
    memset(&sVersion, 0x00, sizeof(OSVERSIONINFO));
    if ((NULL == pVerInfo) || (pVerInfo->dwPlatform == 0))
    {
        sVersion.dwOSVersionInfoSize    = sizeof(OSVERSIONINFO);
        if (!GetVersionEx(&sVersion))
        {
            return FALSE;
        }
        fUseBuildNumber = TRUE;
    }
    else
    {
        //
        // Analyze the pVerInfo struct and deduce whether we are checking a range,
        // and/or whether the dwBuildNumber* fields exist and are being used.
        //
        if (_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionHigh))        
        {
            //
            // If version are different then a range is being used
            //
            if (memcmp( &(pVerInfo->sOSVersionLow),
                        &(pVerInfo->sOSVersionHigh),
                        sizeof(DRIVER_VER_MAJORMINOR)) != 0)
            {
                fCheckRange = TRUE;   
            }
            
            //
            // Just set these here since the first check is the same regardless
            // of whetther we are doing range checking or not.
            //
            sVersion.dwPlatformId   = pVerInfo->dwPlatform;
            sVersion.dwMajorVersion = pVerInfo->sOSVersionLow.dwMajor;
            sVersion.dwMinorVersion = pVerInfo->sOSVersionLow.dwMinor;

            //
            // Check to see if the dwBuildNumber* members exists, and
            // if they are being used (not 0).
            //
            if ((_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, dwBuildNumberHigh)) &&
                pVerInfo->dwBuildNumberLow != 0)
            {
                fUseBuildNumber = TRUE;
                
                fCheckRange |= (pVerInfo->dwBuildNumberLow == pVerInfo->dwBuildNumberHigh) ? 
                                FALSE : TRUE; 
                    
                //
                // Just set this in case we aren't doing range checking
                //
                sVersion.dwBuildNumber = pVerInfo->dwBuildNumberLow;
            }
        }
        else
        {
            sVersion.dwPlatformId   = pVerInfo->dwPlatform;
            sVersion.dwMajorVersion = pVerInfo->dwVersion;
            sVersion.dwMinorVersion = 0;
        }
    }

    //
    // Save this in case multiple OSAttr elements need to be checked against
    // a range
    //
    memcpy(&sVersionSave, &sVersion, sizeof(OSVERSIONINFO));
    
    //
    // Loop for each version in the attribute, and check to see if 
    // it satifies our criteria
    //
    pwszCurrent = (WCHAR *)pAttr->pbValue;
    
    while ((pwszCurrent != NULL) && (*pwszCurrent))     
    {
        //
        // Find version seperator, insert '/0' if needed, and keep
        // track of location for next time through the loop
        //
        pwszEnd = wcschr(pwszCurrent, OSATTR_SEP);

        if (pwszEnd)
        {
            *pwszEnd = L'\0';
        }

        //
        // Check to see if this version string is a range
        //
        pwszRangeSeperator = wcschr(pwszCurrent, OSATTR_RANGE_SEP);
        if (pwszRangeSeperator != NULL)
        {
            //
            // The version string in the cat file is a range
            //

            *pwszRangeSeperator = L'\0';
            pwszRangeSeperator++;

            dwLowCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);
            
            //
            // The only difference between checking a single OS version against a range,
            // and checking a range of OS versions agains a range is the value used for the
            // upper limit.
            //
            if (fCheckRange)
            {
                sVersion.dwPlatformId   = pVerInfo->dwPlatform;
                sVersion.dwMajorVersion = pVerInfo->sOSVersionHigh.dwMajor;
                sVersion.dwMinorVersion = pVerInfo->sOSVersionHigh.dwMinor;
                sVersion.dwBuildNumber  = (fUseBuildNumber) ? pVerInfo->dwBuildNumberHigh : 0;
            }
            dwHighCheck = _CheckVersionNEW(&sVersion, pwszRangeSeperator, fUseBuildNumber);

            if (((dwLowCheck == VER_CHECK_EQ)  || (dwLowCheck == VER_CHECK_GT))  &&
                ((dwHighCheck == VER_CHECK_EQ) || (dwHighCheck == VER_CHECK_LT)))
            {
                if (pVerInfo)
                {
                    CopyBytesToMaxPathString(
                            pAttr->pbValue, 
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                }

                *(--pwszRangeSeperator) = OSATTR_RANGE_SEP;
                if (pwszEnd != NULL)
                {
                    *pwszEnd = OSATTR_SEP;   
                }
                return (TRUE);
            }
            
            *(--pwszRangeSeperator) = OSATTR_RANGE_SEP;

            //
            // copy back the low OSVER to get ready for the next pass
            //
            memcpy(&sVersion, &sVersionSave, sizeof(OSVERSIONINFO));
        }
        else
        {
            if (!fCheckRange)
            {
                if (_CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber) == VER_CHECK_EQ)
                {
                    if (pVerInfo)
                    {
                        CopyBytesToMaxPathString(
                            pAttr->pbValue, 
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                    }

                    if (pwszEnd != NULL)
                    {
                        *pwszEnd = OSATTR_SEP;   
                    }
                    return (TRUE);
                }
            }
            else
            {
                dwLowCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);
                
                sVersion.dwPlatformId   = pVerInfo->dwPlatform;
                sVersion.dwMajorVersion = pVerInfo->sOSVersionHigh.dwMajor;
                sVersion.dwMinorVersion = pVerInfo->sOSVersionHigh.dwMinor;
                sVersion.dwBuildNumber  = (fUseBuildNumber) ? pVerInfo->dwBuildNumberHigh : 0;
                dwHighCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);

                if (((dwLowCheck == VER_CHECK_EQ) || (dwLowCheck == VER_CHECK_LT)) &&
                    ((dwHighCheck == VER_CHECK_EQ) || (dwHighCheck == VER_CHECK_GT)))
                {
                    if (pVerInfo)
                    {
                        CopyBytesToMaxPathString(
                            pAttr->pbValue, 
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                    }

                    if (pwszEnd != NULL)
                    {
                        *pwszEnd = OSATTR_SEP;   
                    }
                    return (TRUE);
                }

                //
                // copy back the low OSVER to get ready for the next pass
                //
                memcpy(&sVersion, &sVersionSave, sizeof(OSVERSIONINFO));
            }
        }

        //
        // If there aren't anymore version in the attribute, then break,
        // which means the version check failed
        //
        if (!(pwszEnd))
        {
            break;
        }

        //
        // Set up for next iteration
        //
        *pwszEnd = OSATTR_SEP;
        pwszCurrent = pwszEnd;
        pwszCurrent++;
    }

    return (FALSE);
}

//
// Comparison is done such that pVersion is VER_CHECK_LT, VER_CHECK_GT, or
// VER_CHECK_EQ to pwszAttr
//
DWORD _CheckVersionNEW(OSVERSIONINFO *pVersion, WCHAR *pwszAttr, BOOL fUseBuildNumber)
{
    WCHAR   *pwszCurrent;
    WCHAR   *pwszEnd;
    DWORD   dwPlatform;
    DWORD   dwMajor;
    DWORD   dwMinor;
    DWORD   dwBuild;
    WCHAR   wcFlagMinor;
    WCHAR   wcFlagBuild;

    pwszCurrent = pwszAttr;

    //
    //  format:  os:major.minor, os:major.minor, ...
    //          2:4.x   = NT 4 (all)
    //          2:4.>   = NT 4 (all) and beyond
    //          2:4.-   = NT 4 (all) and before
    //          2:4.<   = NT 4 (all) and before
    //          2:4.1.x = NT 4.1 (all)
    //          2:4.1.> = NT 4.1 (all) and beyond
    //          2:4.1.- = NT 4.1 (all) and before
    //          2:4.1.< = NT 4.1 (all) and before
    //          2:4.1   = NT 4.1 only
    //          2:4.1.1 = NT 4.1 build # 1 only
    //
    if (!(pwszEnd = wcschr(pwszAttr, OSATTR_OSSEP)))
    {
        return(VER_CHECK_FAIL);
    }

    *pwszEnd = NULL;

    //
    // Check platform first
    //
    dwPlatform = (DWORD) _wtol(pwszCurrent);
    *pwszEnd = OSATTR_OSSEP;

    //
    // MUST be same platform
    //
    if (dwPlatform != pVersion->dwPlatformId)
    {
        return(VER_CHECK_FAIL);
    }
    
    pwszCurrent = pwszEnd;
    pwszCurrent++;

    if (!(_GetVersionNumbers(pwszCurrent, &dwMajor, &dwMinor, &dwBuild, &wcFlagMinor, &wcFlagBuild)))
    {
        return(VER_CHECK_FAIL);
    }

    //
    // The only way we can check against a build# is if the OSAttr has some build# node...
    // which is not the case for an OSAttr like 2.4.x
    //
    if ((fUseBuildNumber && (dwBuild != 0)) ||
        (wcFlagBuild != L'\0'))
    {
        switch (wcFlagBuild)
        {
        case OSATTR_ALL:
            // 2:4.1.x = NT 4.1 (all)
            if ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion == dwMinor))
            {
                return(VER_CHECK_EQ);   
            }
            else if ((pVersion->dwMajorVersion < dwMajor) || 
                     ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion < dwMinor)))
            {
                return(VER_CHECK_LT);
            }
            else
            {
                return(VER_CHECK_GT);
            }
            break;

        case OSATTR_GTEQ:
            // 2:4.1.> = NT 4.1 (all) and beyond
            if ((pVersion->dwMajorVersion > dwMajor) || 
                ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion >= dwMinor)))
            {
                return(VER_CHECK_EQ);
            }
            else 
            {
                return(VER_CHECK_LT);
            }
            break;

        case OSATTR_LTEQ:
        case OSATTR_LTEQ2:
            // 2:4.1.- = NT 4.1 (all) and before  
            // 2:4.1.< = NT 4.1 (all) and before
            if ((pVersion->dwMajorVersion < dwMajor) || 
                ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion <= dwMinor)))
            {
                return(VER_CHECK_EQ);
            }
            else 
            {
                return(VER_CHECK_GT);
            }
            break;
        default:
            // 2:4.1.1 = NT 4.1 build # 1 only

            if (pVersion->dwMajorVersion < dwMajor)
            {
                return(VER_CHECK_LT);
            }
            else if (pVersion->dwMajorVersion > dwMajor)
            {
                return(VER_CHECK_GT);
            }
            else
            {
                if (pVersion->dwMinorVersion < dwMinor)
                {
                    return(VER_CHECK_LT);
                }
                else if (pVersion->dwMinorVersion > dwMinor)
                {
                    return(VER_CHECK_GT);
                }
                else
                {
                    if (pVersion->dwBuildNumber == dwBuild)
                    {
                        return(VER_CHECK_EQ);
                    }
                    else if (pVersion->dwBuildNumber < dwBuild)
                    {
                        return(VER_CHECK_LT);
                    }
                    else
                    {
                        return(VER_CHECK_GT);
                    }
                }
            }

            break;
        }
    }

    switch (wcFlagMinor)
    {
    case OSATTR_ALL:
        // 2:4.x   = NT 4 (all)
        if (pVersion->dwMajorVersion == dwMajor)
        {
            return(VER_CHECK_EQ);   
        }
        else if (pVersion->dwMajorVersion < dwMajor)
        {
            return(VER_CHECK_LT);
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;

    case OSATTR_GTEQ:
        // 2:4.>   = NT 4 (all) and beyond
        if (pVersion->dwMajorVersion >= dwMajor)
        {
            return(VER_CHECK_EQ);   
        }
        else
        {
            return(VER_CHECK_LT);
        }

        break;

    case OSATTR_LTEQ:
    case OSATTR_LTEQ2:
        // 2:4.-   = NT 4 (all) and before
        // 2:4.<   = NT 4 (all) and before
        if (pVersion->dwMajorVersion <= dwMajor)
        {
            return(VER_CHECK_EQ);   
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;
    default:
        // 2:4.1   = NT 4.1 only
        if ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion == dwMinor))
        {
             return(VER_CHECK_EQ);   
        }
        else if (pVersion->dwMajorVersion == dwMajor)
        {
            if (pVersion->dwMinorVersion < dwMinor)
            {   
                return(VER_CHECK_LT);
            }
            else
            {
                return(VER_CHECK_GT);
            }
        }
        else if (pVersion->dwMajorVersion < dwMajor)
        {
            return(VER_CHECK_LT);
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;
    }

    return(VER_CHECK_FAIL);
}


BOOL _GetVersionNumbers(
                        WCHAR *pwszMM, 
                        DWORD *pdwMajor, 
                        DWORD *pdwMinor, 
                        DWORD *pdwBuild, 
                        WCHAR *pwcFlagMinor, 
                        WCHAR *pwcFlagBuild)
{
    //
    //  special characters:
    //      - = all versions less than or equal to
    //      < = all versions less than or equal to
    //      > = all versions greater than or equal to
    //      X = all sub-versions.
    //
    WCHAR   *pwszEnd;

    *pdwMajor = 0;
    *pdwMinor = 0; 
    *pdwBuild = 0; 
    *pwcFlagMinor = L'\0'; 
    *pwcFlagBuild = L'\0'; 

    if (pwszEnd = wcschr(pwszMM, OSATTR_VERSEP))
    {
        *pwszEnd = NULL;
    }

    *pdwMajor = (DWORD) _wtol(pwszMM);

    //
    // If there is only a major ver then return now, otherwise,
    // continue processiing
    //
    if (pwszEnd == NULL) 
    {
        return (TRUE);
    }

    *pwszEnd = OSATTR_VERSEP;
    pwszMM = pwszEnd;
    pwszMM++;

    if (*pwszMM == '/0')
    {
        return (TRUE);
    }

    //
    // Get the minor ver/wildcard
    //
    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlagMinor = towupper(*pwszMM);
        return(TRUE);
    }

    if (!(pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
    {
        *pdwMinor = (DWORD) _wtol(pwszMM);
        
        //
        // This grandfathers all catalog files that had an OSAttr string of
        // 2:4.1 to be 2:4.1.*
        //
        *pwcFlagBuild = OSATTR_ALL; 

        return(TRUE);
    }

    *pwszEnd = NULL;
    *pdwMinor = (DWORD) _wtol(pwszMM);
    *pwszEnd = OSATTR_VERSEP;
    pwszMM = pwszEnd;
    pwszMM++;
    
    //
    // Get the build#/wildcard
    //
    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlagBuild = towupper(*pwszMM);
        return(TRUE);
    }

    *pdwBuild = (DWORD) _wtol(pwszMM);
    *pwcFlagBuild = L'\0';

    return(TRUE);
}


STDAPI DriverRegisterServer(void)
{
    GUID                            gDriver = DRIVER_ACTION_VERIFY;
    CRYPT_REGISTER_ACTIONID         sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    //  use our init policy
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = DRIVER_INITPROV_FUNCTION;

    //  use standard object policy
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    //  use standard signature policy
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    //  use standard cert builder
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION;

    //  use standard cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    //  use our final policy
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = DRIVER_FINALPOLPROV_FUNCTION;

    //  use our cleanup policy
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = DRIVER_CLEANUPPOLICY_FUNCTION;

    //
    //  Register our provider GUID...
    //
    if (!(WintrustAddActionID(&gDriver, 0, &sRegAID)))
    {
        return (S_FALSE);
    }

    return (S_OK);
}

STDAPI DriverUnregisterServer(void)
{
    GUID    gDriver = DRIVER_ACTION_VERIFY;

    if (!(WintrustRemoveActionID(&gDriver)))
    {
        return (S_FALSE);
    }

    return (S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\chainprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chainprv.cpp
//
//  Contents:   Microsoft Internet Security Generic Chain Policy Provider
//
//  Functions:  GenericChainRegisterServer
//              GenericChainUnregisterServer
//              GenericChainCertificateTrust
//              GenericChainFinalProv
//
//  History:    21-Feb-1998 philh      created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


//////////////////////////////////////////////////////////////////////////////
//
// GenericChainRegisterServer
//----------------------------------------------------------------------------
//  Register the GenericChain provider
//  

STDAPI GenericChainRegisterServer(void)
{
    GUID gGenericChainProv = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;
    BOOL fRet;
    CRYPT_REGISTER_ACTIONID sRegAID;

    fRet = TRUE;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    //------------------------------------------------------------------------
    // Our Generic Chain certificate provider (builds the chain)
    //+-----------------------------------------------------------------------
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = GENERIC_CHAIN_CERTTRUST_FUNCTION;

    // authenticode cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    //------------------------------------------------------------------------
    // Our Generic Chain final provider (chain policy callback)
    //+-----------------------------------------------------------------------
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = GENERIC_CHAIN_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gGenericChainProv, 0, &sRegAID);
    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters GenericChain provider
//  

STDAPI GenericChainUnregisterServer(void)
{
    GUID gGenericChainProv = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;

    WintrustRemoveActionID(&gGenericChainProv);
    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// GenericChainCertificateTrust
//----------------------------------------------------------------------------
//  Creates the chains for the signers and counter signers
//  

void GenericChainWalkSigner(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN OUT PCRYPT_PROVIDER_SGNR pSgnr,
    IN PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO pChainInfo
    );

HRESULT
WINAPI
GenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;
    WTD_GENERIC_CHAIN_POLICY_DATA DefaultPolicyData;
    PWTD_GENERIC_CHAIN_POLICY_DATA pPolicyData;

    if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct,
            fRecallWithState) && pProvData->fRecallWithState == TRUE)
        return S_OK;

    pPolicyData = (PWTD_GENERIC_CHAIN_POLICY_DATA)
        pProvData->pWintrustData->pPolicyCallbackData;

    if (NULL == pPolicyData) {
        memset(&DefaultPolicyData, 0, sizeof(DefaultPolicyData));
        DefaultPolicyData.cbSize = sizeof(DefaultPolicyData);
        pPolicyData = &DefaultPolicyData;
    }

    if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_DATA,
            pPolicyData->cbSize, pvPolicyArg) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwProvFlags) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG)) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 
            ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    if (pProvData->csSigners < 1) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            TRUST_E_NOSIGNATURE;
        return S_FALSE;
    }

    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
    hr = S_OK;
    //
    //  loop through all signers
    //
    for (DWORD i = 0; i < pProvData->csSigners; i++) {
        PCRYPT_PROVIDER_SGNR pSgnr;

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        if (pSgnr->csCertChain < 1) {
            pSgnr->dwError = TRUST_E_NO_SIGNER_CERT;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
                TRUST_E_NO_SIGNER_CERT;
            hr = S_FALSE;
            continue;
        }

        GenericChainWalkSigner(
            pProvData,
            pSgnr,
            pPolicyData->pSignerChainInfo
            );

        //
        //  loop through all counter signers
        //
        for (DWORD j = 0; j < pSgnr->csCounterSigners; j++) {
            PCRYPT_PROVIDER_SGNR pCounterSgnr;

            pCounterSgnr = WTHelperGetProvSignerFromChain(
                pProvData, i, TRUE, j);
            if (pCounterSgnr->csCertChain < 1) {
                pCounterSgnr->dwError = TRUST_E_NO_SIGNER_CERT;
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
                     TRUST_E_COUNTER_SIGNER;
                hr = S_FALSE;
                continue;
            }

            GenericChainWalkSigner(
                pProvData,
                pCounterSgnr,
                pPolicyData->pCounterSignerChainInfo
                );
        }
    }

    return hr;
}


HCERTSTORE GenericChainGetAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pProvData->pahStores[0]);
}

void GenericChainWalkSigner(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN OUT PCRYPT_PROVIDER_SGNR pSgnr,
    IN PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO pChainInfo
    )
{
    DWORD dwSgnrError;
    WTD_GENERIC_CHAIN_POLICY_CREATE_INFO DefaultChainInfo;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCRYPT_PROVIDER_CERT pCert = NULL;

    if (pChainInfo) {
        if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_CREATE_INFO,
                pChainInfo->cbSize, pvReserved)) {
            dwSgnrError = ERROR_INVALID_PARAMETER;
            goto InvalidParameter;
        }
    } else {
        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        memset(&DefaultChainInfo, 0, sizeof(DefaultChainInfo));
        DefaultChainInfo.cbSize =  sizeof(DefaultChainInfo);
        DefaultChainInfo.pChainPara = &ChainPara;
        pChainInfo = &DefaultChainInfo;
    }

    hAdditionalStore = GenericChainGetAdditionalStore(pProvData);
    pCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    if (pCert == NULL)
    {   
        // Not really sure what error to put here
        pProvData->dwError = E_UNEXPECTED;
        dwSgnrError = E_UNEXPECTED;
        goto ErrorReturn;
    }

    if (!CertGetCertificateChain (
            pChainInfo->hChainEngine,
            pCert->pCert,
            &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            pChainInfo->pChainPara,
            pChainInfo->dwFlags,
            pChainInfo->pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    pSgnr->pChainContext = pChainContext;

CommonReturn:
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    return;

ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, InvalidParameter)
TRACE_ERROR_EX(DBG_SS, GetChainError)
}


//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: GenericChainFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  


DWORD GenericChainGetErrorBasedOnStepErrors(
    IN PCRYPT_PROVIDER_DATA pProvData
    );

HRESULT
WINAPI
GenericChainDefaultPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

HRESULT
WINAPI
GenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;

    WTD_GENERIC_CHAIN_POLICY_DATA DefaultPolicyData;
    PWTD_GENERIC_CHAIN_POLICY_DATA pPolicyData;
    DWORD dwStepError;
    DWORD cSigner = 0;
    DWORD i;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *ppSignerInfo = NULL;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSignerInfo;      // not allocated
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK pfnPolicyCallback;

    pPolicyData = (PWTD_GENERIC_CHAIN_POLICY_DATA)
        pProvData->pWintrustData->pPolicyCallbackData;
    if (NULL == pPolicyData) {
        memset(&DefaultPolicyData, 0, sizeof(DefaultPolicyData));
        DefaultPolicyData.cbSize = sizeof(DefaultPolicyData);
        pPolicyData = &DefaultPolicyData;
    }

    if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_DATA,
            pPolicyData->cbSize, pvPolicyArg) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG) ||
            0 == (pProvData->dwProvFlags & CPD_USE_NT5_CHAIN_FLAG))
        goto InvalidParameter;

    dwStepError = GenericChainGetErrorBasedOnStepErrors(pProvData);

    cSigner = pProvData->csSigners;
    if (0 == cSigner)
        goto NoSignature;

    if (NULL == (ppSignerInfo =
        (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *) malloc(
            sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner +
            sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner)))
        goto OutOfMemory;
    memset(ppSignerInfo, 0,
            sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner +
            sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner);

    //
    //  Update allocated info for each signer
    //
    pSignerInfo = (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO)
         &ppSignerInfo[cSigner];
    i = 0;
    for ( ; i < cSigner; i++, pSignerInfo++) {
        CRYPT_PROVIDER_SGNR *pSgnr;
        DWORD cCounterSigner;

        ppSignerInfo[i] = pSignerInfo;
        pSignerInfo->cbSize = sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO);

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        pSignerInfo->pChainContext = pSgnr->pChainContext;
        pSignerInfo->dwSignerType = pSgnr->dwSignerType;
        pSignerInfo->pMsgSignerInfo = pSgnr->psSigner;
        pSignerInfo->dwError = pSgnr->dwError;

        cCounterSigner = pSgnr->csCounterSigners;
        if (cCounterSigner) {
            DWORD j;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *ppCounterSignerInfo;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSignerInfo;

            if (NULL == (ppCounterSignerInfo =
                (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *) malloc(
                    sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) *
                        cCounterSigner +
                    sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) *
                        cCounterSigner)))
                goto OutOfMemory;
            memset(ppCounterSignerInfo, 0,
                sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cCounterSigner +
                sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cCounterSigner);
            pSignerInfo->cCounterSigner = cCounterSigner;
            pSignerInfo->rgpCounterSigner = ppCounterSignerInfo;

            //
            //  Update allocated info for each counter signer
            //
            pCounterSignerInfo = (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO)
                &ppCounterSignerInfo[cCounterSigner];
            j = 0;
            for ( ; j < cCounterSigner; j++, pCounterSignerInfo++) {
                PCRYPT_PROVIDER_SGNR pCounterSgnr;

                ppCounterSignerInfo[j] = pCounterSignerInfo;
                pCounterSignerInfo->cbSize =
                    sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO);

                pCounterSgnr = WTHelperGetProvSignerFromChain(pProvData, i,
                    TRUE, j);
                pCounterSignerInfo->pChainContext = pCounterSgnr->pChainContext;
                pCounterSignerInfo->dwSignerType = pCounterSgnr->dwSignerType;
                pCounterSignerInfo->pMsgSignerInfo = pCounterSgnr->psSigner;
                pCounterSignerInfo->dwError = pCounterSgnr->dwError;
            }
        }
    }

    if (pPolicyData->pfnPolicyCallback)
        pfnPolicyCallback = pPolicyData->pfnPolicyCallback;
    else
        pfnPolicyCallback = GenericChainDefaultPolicyCallback;

    hr = pfnPolicyCallback(
        pProvData,
        dwStepError,
        pProvData->dwRegPolicySettings,
        cSigner,
        ppSignerInfo,
        pPolicyData->pvPolicyArg
        );

CommonReturn:
    if (ppSignerInfo) {
        while (cSigner--) {
            pSignerInfo = ppSignerInfo[cSigner];
            if (pSignerInfo && pSignerInfo->rgpCounterSigner)
                free(pSignerInfo->rgpCounterSigner);
        }
        free(ppSignerInfo);
    }
    pProvData->dwFinalError = (DWORD) hr;
    return hr;

ErrorReturn:
    hr = (HRESULT) GetLastError();
    if (S_OK == hr)
        hr = E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR_EX(DBG_SS, InvalidParameter, ERROR_INVALID_PARAMETER)
SET_ERROR_EX(DBG_SS, OutOfMemory, ERROR_NOT_ENOUGH_MEMORY)
SET_ERROR_EX(DBG_SS, NoSignature, TRUST_E_NOSIGNATURE);
}

DWORD GenericChainGetErrorBasedOnStepErrors(
    IN PCRYPT_PROVIDER_DATA pProvData
    )
{
    //
    //  initial allocation of the step errors?
    //
    if (NULL == pProvData->padwTrustStepErrors)
        return ERROR_NOT_ENOUGH_MEMORY;

    // problem with file
    if ((pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO] != 0) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE] != 0))
    {
        return(CRYPT_E_FILE_ERROR);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}

HRESULT
WINAPI
GenericChainDefaultPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    )
{
    HRESULT hr;
    DWORD i;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA ExtraPolicyPara;
    memset(&ExtraPolicyPara, 0, sizeof(ExtraPolicyPara));
    ExtraPolicyPara.cbSize = sizeof(ExtraPolicyPara);
    ExtraPolicyPara.dwRegPolicySettings = dwRegPolicySettings;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) &ExtraPolicyPara;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS ExtraPolicyStatus;
    memset(&ExtraPolicyStatus, 0, sizeof(ExtraPolicyStatus));
    ExtraPolicyStatus.cbSize = sizeof(ExtraPolicyStatus);

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.pvExtraPolicyStatus = (void *) &ExtraPolicyStatus;

    //
    // check the high level error codes.
    //
    if (0 != dwStepError) {
        hr = (HRESULT) dwStepError;
        goto CommonReturn;
    }


    //
    //  check each signer
    //
    for (i = 0; i < cSigner; i++) {
        PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner = rgpSigner[i];
        ExtraPolicyPara.pSignerInfo = pSigner->pMsgSignerInfo;

        if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_AUTHENTICODE,
                pSigner->pChainContext,
                &PolicyPara,
                &PolicyStatus
                )) {
            hr = TRUST_E_SYSTEM_ERROR;
            goto CommonReturn;
        }

        if (0 != PolicyStatus.dwError) {
            hr = (HRESULT) PolicyStatus.dwError;
            goto CommonReturn;
        }

        if (pSigner->cCounterSigner) {
            AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA TSExtraPolicyPara;
            memset(&TSExtraPolicyPara, 0, sizeof(TSExtraPolicyPara));
            TSExtraPolicyPara.cbSize = sizeof(TSExtraPolicyPara);
            TSExtraPolicyPara.dwRegPolicySettings = dwRegPolicySettings;
            TSExtraPolicyPara.fCommercial = ExtraPolicyStatus.fCommercial;

            CERT_CHAIN_POLICY_PARA TSPolicyPara;
            memset(&TSPolicyPara, 0, sizeof(TSPolicyPara));
            TSPolicyPara.cbSize = sizeof(TSPolicyPara);
            TSPolicyPara.pvExtraPolicyPara = (void *) &TSExtraPolicyPara;

            CERT_CHAIN_POLICY_STATUS TSPolicyStatus;
            memset(&TSPolicyStatus, 0, sizeof(TSPolicyStatus));
            TSPolicyStatus.cbSize = sizeof(TSPolicyStatus);


            //
            //  check counter signers
            //
            for (DWORD j = 0; j < pSigner->cCounterSigner; j++) {
                PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSigner =
                    pSigner->rgpCounterSigner[j];

                //
                //  do we care about this counter signer?
                //
                if (pCounterSigner->dwSignerType != SGNR_TYPE_TIMESTAMP)
                    continue;

                if (!CertVerifyCertificateChainPolicy(
                        CERT_CHAIN_POLICY_AUTHENTICODE_TS,
                        pCounterSigner->pChainContext,
                        &TSPolicyPara,
                        &TSPolicyStatus
                        )) {
                    hr = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                } else if (0 != TSPolicyStatus.dwError) {
                    hr = (HRESULT) TSPolicyStatus.dwError;
                    goto CommonReturn;
                }
            }
        }
    }
    
    hr = S_OK;
CommonReturn:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\defusage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       defusage.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  
//
//  History:    18-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL WINAPI SoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, psDefUsage->cbStruct, pDefSIPClientData)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    HTTPSPolicyCallbackData polHttps;

    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));

    polHttps.cbStruct   =  sizeof(HTTPSPolicyCallbackData);
    polHttps.fdwChecks  = INTERNET_FLAG_IGNORE_CERT_CN_INVALID;

    psDefUsage->pDefPolicyCallbackData  = NULL;
    psDefUsage->pDefSIPClientData       = NULL;

    if (strcmp(pszUsageOID, szOID_PKIX_KP_SERVER_AUTH) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (strcmp(pszUsageOID, szOID_PKIX_KP_CLIENT_AUTH) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_CLIENT;
    }

    if (strcmp(pszUsageOID, szOID_SERVER_GATED_CRYPTO) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (strcmp(pszUsageOID, szOID_SGC_NETSCAPE) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (polHttps.dwAuthType == 0)
    {
        return(TRUE);
    }

    if (!(psDefUsage->pDefPolicyCallbackData = (HTTPSPolicyCallbackData *)malloc(sizeof(HTTPSPolicyCallbackData))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    memset(psDefUsage->pDefPolicyCallbackData, 0x00, sizeof(HTTPSPolicyCallbackData));
    memcpy(psDefUsage->pDefPolicyCallbackData, &polHttps, sizeof(HTTPSPolicyCallbackData));

    return(TRUE);
}

BOOL WINAPI SoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, psDefUsage->cbStruct, pDefSIPClientData)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (psDefUsage->pDefPolicyCallbackData)
    {
        free(psDefUsage->pDefPolicyCallbackData);
    }
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              OpenTrustedPublisherStore
//              OpenDisallowedStore
//
//              *** local functions ***
//              SPNew
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HINSTANCE   hinst;

HCERTSTORE g_hStoreTrustedPublisher;
HCERTSTORE g_hStoreDisallowed;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

BOOL WINAPI SoftpubDllMain(HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            hinst = (HINSTANCE)hInstDLL;
            break;

        case DLL_PROCESS_DETACH:
            if (g_hStoreTrustedPublisher)
                CertCloseStore(g_hStoreTrustedPublisher, 0);
            if (g_hStoreDisallowed)
                CertCloseStore(g_hStoreDisallowed, 0);
            break;
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return(TRUE);
}

HCERTSTORE
WINAPI
_OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    hStore = *phStoreCache;
    if (NULL == hStore) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                CERT_STORE_SHARE_CONTEXT_FLAG,
            (const void *) pwszStore
            );

        if (hStore) {
            HCERTSTORE hPrevStore;

            CertControlStore(
                hStore,
                0,                  // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL                // pvCtrlPara
                );

            hPrevStore = InterlockedCompareExchangePointer(
                phStoreCache, hStore, NULL);

            if (hPrevStore) {
                CertCloseStore(hStore, 0);
                hStore = hPrevStore;
            }
        }
    }

    if (hStore)
        hStore = CertDuplicateStore(hStore);

    return hStore;
}

HCERTSTORE
WINAPI
OpenTrustedPublisherStore()
{
    return _OpenCachedHKCUStore(&g_hStoreTrustedPublisher,
        L"TrustedPublisher");
}

HCERTSTORE
WINAPI
OpenDisallowedStore()
{
    return _OpenCachedHKCUStore(&g_hStoreDisallowed, L"Disallowed");
}

#include    "wvtver1.h"

STDAPI SoftpubDllRegisterServer(void)
{
    GUID                            gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID                            gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;
    GUID                            gV2         = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                            gV2TrstTest = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
    GUID                            gCert       = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    CRYPT_REGISTER_ACTIONID         sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE      sDefUsage;

    BOOL                            fRet;

    fRet = TRUE;

    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gV2;

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_CODE_SIGNING, &sDefUsage);

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION;

    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = SP_FINALPOLICY_FUNCTION;

    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;


    //
    //  V2
    //
    fRet &= WintrustAddActionID(&gV2, 0, &sRegAID);

    //
    //  support for V1
    //
    fRet &= WintrustAddActionID(&gV1UISup, 0, &sRegAID);
    fRet &= WintrustAddActionID(&gV1UINoBad, 0, &sRegAID);

    sRegAID.sInitProvider.pwszFunctionName              = SP_GENERIC_CERT_INIT_FUNCTION;
    fRet &= WintrustAddActionID(&gCert, 0, &sRegAID);
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    //
    //  testing support
    //
    sRegAID.sTestPolicyProvider.cbStruct                = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sTestPolicyProvider.pwszDLLName             = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sTestPolicyProvider.pwszFunctionName        = SP_TESTDUMPPOLICY_FUNCTION_TEST;
    fRet &= WintrustAddActionID(&gV2TrstTest, 0, &sRegAID);

    memset(&sRegAID.sTestPolicyProvider, 0x00, sizeof(CRYPT_TRUST_REG_ENTRY));

    if (fRet)
    {
        HTTPSRegisterServer();
        OfficeRegisterServer();
        DriverRegisterServer();
        GenericChainRegisterServer();

        return(S_OK);
    }

    return(S_FALSE);
}

STDAPI SoftpubDllUnregisterServer(void)
{
    GUID    gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;
    GUID    gV2         = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID    gV2TrstTest = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
    GUID    gCert       = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    WintrustRemoveActionID(&gV1UISup);
    WintrustRemoveActionID(&gV1UINoBad);
    WintrustRemoveActionID(&gV2);
    WintrustRemoveActionID(&gV2TrstTest);
    WintrustRemoveActionID(&gCert);

    HTTPSUnregisterServer();
    OfficeUnregisterServer();
    DriverUnregisterServer();
    GenericChainUnregisterServer();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\expapis.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       expapis.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  FindCertsByIssuer
//
//  History:    01-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
/////////////////////////////////////////////////////////////////////////////

//
// The root of the certificate store that we manage.
//
#define HEAPALLOC(size)  HeapAlloc ( GetProcessHeap(), 0, size )
#define HEAPFREE(data)   HeapFree  ( GetProcessHeap(), 0, data )


#define SZIE30CERTCLIENTAUTH "Software\\Microsoft\\Cryptography\\PersonalCertificates\\ClientAuth"
#define SZIE30TAGS       "CertificateTags"
#define SZIE30AUXINFO        "CertificateAuxiliaryInfo"
#define SZIE30CERTBUCKET     "Certificates"

#define ALIGN_LEN(Len)  ((Len + 7) & ~7)

#define IE30CONVERTEDSTORE  "My"

static LPCSTR rgpszMyStore[] = {
    "My"
};
#define NMYSTORES (sizeof(rgpszMyStore)/sizeof(rgpszMyStore[0]))

static const struct {
    LPCSTR      pszStore;
    DWORD       dwFlags;
} rgCaStoreInfo[] = {
    "ROOT",     CERT_SYSTEM_STORE_CURRENT_USER,
    "CA",       CERT_SYSTEM_STORE_CURRENT_USER,
    "SPC",      CERT_SYSTEM_STORE_LOCAL_MACHINE
};
#define NCASTORES (sizeof(rgCaStoreInfo)/sizeof(rgCaStoreInfo[0]))

#define MAX_CHAIN_LEN   16
typedef struct _CHAIN_INFO CHAIN_INFO, *PCHAIN_INFO;
struct _CHAIN_INFO {
    DWORD           cCert;
    PCCERT_CONTEXT  rgpCert[MAX_CHAIN_LEN];
    DWORD           cbKeyProvInfo;          // aligned
    DWORD           cbCert;                 // aligned
    PCHAIN_INFO     pNext;
};

//+-------------------------------------------------------------------------
//  AuthCert allocation and free functions
//--------------------------------------------------------------------------
static void *ACAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = (void *)new BYTE[cbBytes];
    if (pv == NULL)
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
static void ACFree(
    IN void *pv
    )
{
    if (pv)
    {
        delete pv;
    }
}

static HRESULT GetAndIe30ClientAuthCertificates(HCERTSTORE hStore)
// Check for and copy any existing certificates stored in Bob's
// certificate store.
{
    HRESULT hr = S_OK;
    LONG Status;
    HKEY hKeyRoot   = NULL;
    HKEY hKeyBucket = NULL;
    HKEY hKeyTags   = NULL;
    HKEY hKeyAux    = NULL;

    if (ERROR_SUCCESS != RegOpenKeyExA(
            HKEY_CURRENT_USER,
            SZIE30CERTCLIENTAUTH,
            0,                  // dwReserved
            KEY_READ,
            &hKeyRoot
            ))
        return S_OK;

    // Copy any existing certificates
    if (ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30CERTBUCKET,
            0,                  // dwReserved
            KEY_READ,
            &hKeyBucket
        )               &&

        ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30AUXINFO,
            0,                  // dwReserved
            KEY_READ,
            &hKeyAux
            )               &&

        ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30TAGS,
            0,                  // dwReserved
            KEY_READ,
            &hKeyTags
            )) {

            DWORD   cValuesCert, cchMaxNameCert, cbMaxDataCert;
            DWORD   cValuesTag, cchMaxNameTag, cbMaxDataTag;
            DWORD   cValuesAux, cchMaxNameAux, cbMaxDataAux;
            LPSTR   szName = NULL;
            BYTE *pbDataCert = NULL;
            BYTE *pbDataAux = NULL;
            BYTE *pbDataTag = NULL;


            // see how many and how big the registry is
            if (ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyBucket,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesCert,
                        &cchMaxNameCert,
                        &cbMaxDataCert,
                        NULL,
                        NULL
                        )           ||
                ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyTags,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesTag,
                        &cchMaxNameTag,
                        &cbMaxDataTag,
                        NULL,
                        NULL
                        )           ||
                ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyAux,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesAux,
                        &cchMaxNameAux,
                        &cbMaxDataAux,
                        NULL,
                        NULL
                        ))
            {
                hr = SignError();
                goto Return;
            }       
            else {
                // allocate the memory needed to read the reg
                szName = (LPSTR) HEAPALLOC(cchMaxNameCert + 1);
                pbDataCert = (BYTE *) HEAPALLOC(cbMaxDataCert);
                pbDataTag = (BYTE *) HEAPALLOC(cbMaxDataTag);
                pbDataAux = (BYTE *) HEAPALLOC(cbMaxDataAux);
                
                if (NULL == szName      ||
                    NULL == pbDataCert  ||
                    NULL == pbDataAux   ||
                    NULL == pbDataTag   )
                    hr = E_OUTOFMEMORY;
            }

        // enum the registry getting certs
        for (DWORD i = 0; SUCCEEDED(hr) && i < cValuesCert; i++ ) {

            DWORD dwType;
            BYTE *  pb;
            CRYPT_KEY_PROV_INFO   keyInfo;
            DWORD cchName = cchMaxNameCert + 1;
            DWORD cbDataCert = cbMaxDataCert;
            DWORD cbDataTag = cbMaxDataTag;
            DWORD cbDataAux = cbMaxDataAux;

            PCCERT_CONTEXT pCertContxt = NULL;

            // don't have to worry about errors, just skip
            // sliently just be cause there is an internal
            // error in the registry doesn't mean we should
            // get all upset about it.

            // get the cert
            if (RegEnumValueA(
                hKeyBucket,
                i,
                szName,
                &cchName,
                NULL,
                &dwType,
                pbDataCert,
                &cbDataCert
                ) == ERROR_SUCCESS      &&

                dwType == REG_BINARY    &&

            // get the cert context
            (pCertContxt = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                pbDataCert,
                cbDataCert)) != NULL        &&

            // get the tag
            RegQueryValueExA(
                hKeyTags,
                szName,
                NULL,
                &dwType,
                pbDataTag,
                &cbDataTag) == ERROR_SUCCESS    &&

            // get the aux info
            RegQueryValueExA(
                hKeyAux,
                (LPTSTR) pbDataTag,
                NULL,
                &dwType,
                pbDataAux,
                &cbDataAux) == ERROR_SUCCESS ) {

                // aux info is
                // wszPurpose
                // wszProvider
                // wszKeySet
                // wszFilename
                // wszCredentials
                // dwProviderType
                // dwKeySpec

                pb = pbDataAux;
                memset(&keyInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

                // skip purpose, should be client auth
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the provider
                keyInfo.pwszProvName = (LPWSTR) pb;
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the container name
                keyInfo.pwszContainerName = (LPWSTR) pb;
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // skip filename, should be '\0'
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // skip credential, don't really know what it is?
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the provider type
                keyInfo.dwProvType = *((DWORD *) pb);
                pb += sizeof(DWORD);

                // get the key spec
                keyInfo.dwKeySpec  = *((DWORD *) pb);

                // add the property to the certificate
                if( !CertSetCertificateContextProperty(
                    pCertContxt,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    &keyInfo)           ||

                !CertAddCertificateContextToStore(
                    hStore,
                    pCertContxt,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL                            // ppStoreContext
                    )) {

                    MessageBox(
                        NULL,
                        "Copy Certificate Failed",
                        NULL,
                        MB_OK);


                   hr = SignError();
                }
            }

            if(pCertContxt != NULL)
                CertFreeCertificateContext(pCertContxt);
        }

        if (szName)
            HEAPFREE(szName);
        if (pbDataCert)
            HEAPFREE(pbDataCert);
        if(pbDataAux)
            HEAPFREE(pbDataAux);
        if(pbDataTag)
            HEAPFREE(pbDataTag);
    }

Return:

    if(hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);
    if(hKeyBucket != NULL)
        RegCloseKey(hKeyBucket);
    if(hKeyTags != NULL)
        RegCloseKey(hKeyTags);
    if(hKeyAux != NULL)
        RegCloseKey(hKeyAux);
    if (FAILED(hr))
        return hr;

    return hr;
}


// Return List is Null terminated
static HCERTSTORE * GetMyStoreList()
{
    int i;
    HCERTSTORE *phStoreList;
    if (NULL == (phStoreList = (HCERTSTORE *) ACAlloc(
            sizeof(HCERTSTORE) * (NMYSTORES + 1))))
        return NULL;
    memset(phStoreList, 0, sizeof(HCERTSTORE) * (NMYSTORES + 1));
    for (i = 0; i < NMYSTORES; i++) {
    if (NULL == (phStoreList[i] = CertOpenSystemStore(
        NULL,
                rgpszMyStore[i])))
            goto ErrorReturn;
    }
    goto CommonReturn;

ErrorReturn:
    for (i = 0; i < NMYSTORES; i++) {
        if (phStoreList[i])
            CertCloseStore(phStoreList[i], 0);
    }

    ACFree(phStoreList);
    phStoreList = NULL;

CommonReturn:
    return phStoreList;
}

static HCERTSTORE * GetCaStoreList()
{
    int i;
    int cStore;
    HCERTSTORE *phStoreList;
    if (NULL == (phStoreList = (HCERTSTORE *) ACAlloc(
            sizeof(HCERTSTORE) * (NCASTORES + 1))))
        return NULL;
    memset(phStoreList, 0, sizeof(HCERTSTORE) * (NCASTORES + 1));

    cStore = 0;
    for (i = 0; i < NCASTORES; i++) {
        DWORD dwFlags;

        dwFlags = rgCaStoreInfo[i].dwFlags | CERT_STORE_READONLY_FLAG;
        if (phStoreList[cStore] = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_A,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                dwFlags,
                (const void *) rgCaStoreInfo[i].pszStore
                ))
            cStore++;
    }
    return phStoreList;
}

// Find first Issuer match. Don't verify anything. Returns TRUE if an
// issuer was found. For a self-signed issuer returns TRUE with *ppIssuer
// set to NULL.
static BOOL GetIssuer(
    IN PCCERT_CONTEXT pSubject,
    IN HCERTSTORE *phCaStoreList,
    OUT PCCERT_CONTEXT *ppIssuer
    )
{
    BOOL fResult = FALSE;
    PCCERT_CONTEXT pIssuer = NULL;
    HCERTSTORE hStore;
    while (hStore = *phCaStoreList++) {
        DWORD dwFlags = 0;
        pIssuer = CertGetIssuerCertificateFromStore(
            hStore,
            pSubject,
            NULL,       // pPrevIssuer,
            &dwFlags
            );
        if (pIssuer || GetLastError() == CRYPT_E_SELF_SIGNED) {
            fResult = TRUE;
            break;
        }
    }

    *ppIssuer = pIssuer;
    return fResult;
}

//+-------------------------------------------------------------------------
// If issuer name matches any cert in the chain, return allocated
// chain info. Otherwise, return NULL.
//
// If pbEncodedIssuerName == NULL || cbEncodedIssuerName = 0, match any
// issuer.
//--------------------------------------------------------------------------
static PCHAIN_INFO CreateChainInfo(
    IN PCCERT_CONTEXT pCert,
    IN BYTE *pbEncodedIssuerName,
    IN DWORD cbEncodedIssuerName,
    IN HCERTSTORE *phCaStoreList,
    IN HCERTSTORE *phMyStoreList
    )
{
    BOOL fIssuerMatch = FALSE;
    DWORD cCert = 1;
    DWORD cbCert = 0;
    PCHAIN_INFO pChainInfo;
    if (NULL == (pChainInfo = (PCHAIN_INFO) ACAlloc(sizeof(CHAIN_INFO))))
        return NULL;
    memset(pChainInfo, 0, sizeof(CHAIN_INFO));
    pChainInfo->rgpCert[0] = CertDuplicateCertificateContext(pCert);

    if (pbEncodedIssuerName == NULL)
        cbEncodedIssuerName = 0;

    while (pCert) {
        PCCERT_CONTEXT pIssuer;
        cbCert += ALIGN_LEN(pCert->cbCertEncoded);
        if (!fIssuerMatch) {
            if (cbEncodedIssuerName == 0 ||
                (cbEncodedIssuerName == pCert->pCertInfo->Issuer.cbData &&
                    memcmp(pbEncodedIssuerName,
                        pCert->pCertInfo->Issuer.pbData,
                        cbEncodedIssuerName) == 0))
                fIssuerMatch = TRUE;
        }
        if (GetIssuer(pCert, phCaStoreList, &pIssuer) ||
                GetIssuer(pCert, phMyStoreList, &pIssuer)) {
            pCert = pIssuer;
            if (pCert) {
                assert (cCert < MAX_CHAIN_LEN);
                if (cCert < MAX_CHAIN_LEN)
                    pChainInfo->rgpCert[cCert++] = pCert;
                else {
                    CertFreeCertificateContext(pCert);
                    pCert = NULL;
                }
            }
            // else
            //  Self-signed
        }
        else
            pCert = NULL;
    }

    if (fIssuerMatch) {
        pChainInfo->cCert = cCert;
        pChainInfo->cbCert = cbCert;
        return pChainInfo;
    } else {
        while (cCert--)
            CertFreeCertificateContext(pChainInfo->rgpCert[cCert]);
        ACFree(pChainInfo);
        return NULL;
    }
}

//+-------------------------------------------------------------------------
//  Check if the certificate has key provider information.
//  If dwKeySpec != 0, also check that the provider's public key matches the
//  public key in the certificate.
//--------------------------------------------------------------------------
static BOOL CheckKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec,
    OUT DWORD *pcbKeyProvInfo
    )
{
    BOOL fResult = FALSE;
    HCRYPTPROV hCryptProv = 0;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    DWORD cbData;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbKeyProvInfo = 0;
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        NULL,                           // pvData
        &cbKeyProvInfo
        );
    if (cbKeyProvInfo) {
        if (dwKeySpec == 0)
            fResult = TRUE;
        else {
            DWORD dwIdx;
            if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ACAlloc(cbKeyProvInfo)))
                goto CommonReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pKeyProvInfo,
                    &cbKeyProvInfo
                    )) goto CommonReturn;
            if (!CryptAcquireContextU(
                    &hCryptProv,
                    pKeyProvInfo->pwszContainerName,
                    pKeyProvInfo->pwszProvName,
                    pKeyProvInfo->dwProvType,
                    pKeyProvInfo->dwFlags & ~CERT_SET_KEY_PROV_HANDLE_PROP_ID
                    )) {
                hCryptProv = NULL;
                goto CommonReturn;
            }
            for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) {
                PCRYPT_KEY_PROV_PARAM pKeyProvParam =
                    &pKeyProvInfo->rgProvParam[dwIdx];
                if (!CryptSetProvParam(
                        hCryptProv,
                        pKeyProvParam->dwParam,
                        pKeyProvParam->pbData,
                        pKeyProvParam->dwFlags
                        )) goto CommonReturn;
            }

            // Get public key to compare certificate with
            cbPubKeyInfo = 0;
            CryptExportPublicKeyInfo(
                hCryptProv,
                dwKeySpec,
                pCert->dwCertEncodingType,
                NULL,               // pPubKeyInfo
                &cbPubKeyInfo
                );
            if (cbPubKeyInfo == 0) goto CommonReturn;
            if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) ACAlloc(
                    cbPubKeyInfo)))
                goto CommonReturn;
            if (!CryptExportPublicKeyInfo(
                    hCryptProv,
                    dwKeySpec,
                    pCert->dwCertEncodingType,
                    pPubKeyInfo,
                    &cbPubKeyInfo
                    )) goto CommonReturn;
            fResult = CertComparePublicKeyInfo(
                    pCert->dwCertEncodingType,
                    &pCert->pCertInfo->SubjectPublicKeyInfo,
                    pPubKeyInfo);
        }
    }
CommonReturn:
    if (hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);
        SetLastError(dwErr);
    }
    if (pKeyProvInfo)
        ACFree(pKeyProvInfo);
    if (pPubKeyInfo)
        ACFree(pPubKeyInfo);
    *pcbKeyProvInfo = cbKeyProvInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Find all certificate chains tying the given issuer name to any certificate
//  that the current user has a private key for.
//
//  If pbEncodedIssuerName == NULL || cbEncodedIssuerName = 0, match any
//  issuer.
//--------------------------------------------------------------------------
HRESULT
WINAPI
FindCertsByIssuer(
    OUT PCERT_CHAIN pCertChains,
    IN OUT DWORD *pcbCertChains,
    OUT DWORD *pcCertChains,        // count of certificates chains returned
    IN BYTE* pbEncodedIssuerName,   // DER encoded issuer name
    IN DWORD cbEncodedIssuerName,   // count in bytes of encoded issuer name
    IN LPCWSTR pwszPurpose,         // "ClientAuth" or "CodeSigning"
    IN DWORD dwKeySpec              // only return signers supporting this
                                    // keyspec

    )
{
    HRESULT hr;
    HCERTSTORE *phMyStoreList = NULL;
    HCERTSTORE *phCaStoreList = NULL;
    HCERTSTORE *phStore;
    HCERTSTORE hStore;

    DWORD cChain = 0;
    DWORD cbChain;
    DWORD cTotalCert = 0;
    PCHAIN_INFO pChainInfoHead = NULL;
    LONG cbExtra = 0;

    // get the certs out of the IE30 tree and put it in ours
    // open the IE30 store

    if (NULL != (hStore = CertOpenSystemStore(
    NULL,
    IE30CONVERTEDSTORE))) {

    // don't care about errors, and we don't
    // want to delete the old store just yet.
    GetAndIe30ClientAuthCertificates(hStore);
    CertCloseStore(hStore, 0);
    }


    // copy the IE30 certs


    if (NULL == (phMyStoreList = GetMyStoreList()))
        goto ErrorReturn;
    if (NULL == (phCaStoreList = GetCaStoreList()))
        goto ErrorReturn;

    // Iterate through all "My" cert stores to find certificates having a
    // CRYPT_KEY_PROV_INFO property
    phStore = phMyStoreList;
    while (hStore = *phStore++) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            DWORD cbKeyProvInfo;
            if (CheckKeyProvInfo(pCert, dwKeySpec, &cbKeyProvInfo)) {
                // Create a cert chain and check for an issuer name match
                // of any cert in the chain.
                PCHAIN_INFO pChainInfo;
                if (pChainInfo = CreateChainInfo(
                        pCert,
                        pbEncodedIssuerName,
                        cbEncodedIssuerName,
                        phCaStoreList,
                        phMyStoreList
                        )) {
                    // Add to list of chains
                    pChainInfo->pNext = pChainInfoHead;
                    pChainInfoHead = pChainInfo;

                    // Update bytes needed for KeyProvInfo
                    pChainInfo->cbKeyProvInfo = ALIGN_LEN(cbKeyProvInfo);

                    // Update totals
                    cbExtra += pChainInfo->cbKeyProvInfo + pChainInfo->cbCert;
                    cChain++;
                    cTotalCert += pChainInfo->cCert;
                }
            }
        }
    }

    cbChain = sizeof(CERT_CHAIN) * cChain +
        sizeof(CERT_BLOB) * cTotalCert + cbExtra;

    {
        // Check and update output lengths and counts
        DWORD cbIn;

        if (cChain == 0) {
            hr = CRYPT_E_NOT_FOUND;
            goto HrError;
        }
        if (pCertChains == NULL)
            *pcbCertChains = 0;
        cbIn = *pcbCertChains;
        *pcCertChains = cChain;
        *pcbCertChains = cbChain;

        if (cbIn == 0) {
            hr = S_OK;
            goto CommonReturn;
        } else if (cbIn < cbChain) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
            goto CommonReturn;
        }
    }

    {
        // Copy cert chains to output

        PCERT_CHAIN pOutChain;
        PCERT_BLOB pCertBlob;
        BYTE *pbExtra;
        PCHAIN_INFO pChainInfo;

        pOutChain = pCertChains;
        pCertBlob = (PCERT_BLOB) (((BYTE *) pOutChain) +
            sizeof(CERT_CHAIN) * cChain);
        pbExtra = ((BYTE *) pCertBlob) + sizeof(CERT_BLOB) * cTotalCert;
        pChainInfo = pChainInfoHead;
        for ( ;  pChainInfo != NULL;
                                pChainInfo = pChainInfo->pNext, pOutChain++) {
            DWORD cb;
            DWORD cCert = pChainInfo->cCert;
            PCCERT_CONTEXT *ppCert = pChainInfo->rgpCert;
    
            pOutChain->cCerts = cCert;
            pOutChain->certs = pCertBlob;
            cb = pChainInfo->cbKeyProvInfo;
            cbExtra -= cb;
            assert(cbExtra >= 0);
            if (cbExtra < 0) goto UnexpectedError;
            if (!CertGetCertificateContextProperty(
                    *ppCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pbExtra,
                    &cb
                    ))
                goto UnexpectedError;
            pOutChain->keyLocatorInfo = * ((PCRYPT_KEY_PROV_INFO) pbExtra);
            pbExtra += pChainInfo->cbKeyProvInfo;
    
            for ( ; cCert > 0; cCert--, ppCert++, pCertBlob++) {
                cb = (*ppCert)->cbCertEncoded;
                cbExtra -= ALIGN_LEN(cb);
                assert(cbExtra >= 0);
                if (cbExtra < 0) goto UnexpectedError;

                pCertBlob->cbData = cb;
                pCertBlob->pbData = pbExtra;
                memcpy(pbExtra, (*ppCert)->pbCertEncoded, cb);
                pbExtra += ALIGN_LEN(cb);
            }
        }
        assert(cbExtra == 0);
        assert(pCertBlob == (PCERT_BLOB) ((BYTE *) pCertChains +
            sizeof(CERT_CHAIN) * cChain +
            sizeof(CERT_BLOB) * cTotalCert));
    }

    hr = S_OK;
    goto CommonReturn;

UnexpectedError:
    hr = E_UNEXPECTED;
    goto HrError;
ErrorReturn:
    hr = SignError();
HrError:
    *pcbCertChains = 0;
    *pcCertChains = 0;
CommonReturn:
    while (pChainInfoHead) {
        PCHAIN_INFO pChainInfo = pChainInfoHead;
        DWORD cCert = pChainInfo->cCert;
        while (cCert--)
            CertFreeCertificateContext(pChainInfo->rgpCert[cCert]);
        pChainInfoHead = pChainInfo->pNext;
        ACFree(pChainInfo);
    }

    if (phMyStoreList) {
        phStore = phMyStoreList;
        while (hStore = *phStore++)
            CertCloseStore(hStore, 0);
        ACFree(phMyStoreList);
    }
    if (phCaStoreList) {
        phStore = phCaStoreList;
        while (hStore = *phStore++)
            CertCloseStore(hStore, 0);
        ACFree(phCaStoreList);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\emailprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       emailprv.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  EmailRegisterServer
//              EmailUnregisterServer
//              EmailCertCheckProv
//              EmailFinalProv
//
//  History:    18-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

//////////////////////////////////////////////////////////////////////////////
//
// EmailRegisterServer
//----------------------------------------------------------------------------
//  Register the Email provider
//  

STDAPI EmailRegisterServer(void)
{
    GUID                        gProv = EMAIL_ACTIONID_VERIFY;
    BOOL                        fRet;
    CRYPT_REGISTER_ACTIONID     sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE  sDefUsage;

    fRet = TRUE;

    //
    //  set the usages we want
    //
    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gProv;
    sDefUsage.pwszDllName                               = SP_POLICY_PROVIDER_DLL_NAME;
    sDefUsage.pwszLoadCallbackDataFunctionName          = "SoftpubLoadDefUsageCallData";
    sDefUsage.pwszFreeCallbackDataFunctionName          = "SoftpubFreeDefUsageCallData";

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_EMAIL_PROTECTION, &sDefUsage);

    //
    //  set our provider
    //
    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    // custom cert check due to different CTL usages
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
//TBDTBD    sRegAID.sCertificatePolicyProvider.pwszFunctionName = HTTPS_CHKCERT_FUNCTION;

    // custom final ...
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
//TBDTBD    sRegAID.sFinalPolicyProvider.pwszFunctionName       = HTTPS_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gProv, 0, &sRegAID);

    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters email provider
//  

STDAPI HTTPSUnregisterServer(void)
{
    GUID    gProv = EMAIL_ACTIONID_VERIFY;

    WintrustRemoveActionID(&gProv);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// Exported functions for wintrust
//

BOOL WINAPI EmailCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                               BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
}

HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
}

///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\msgprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubLoadMessage
//
//              *** local functions ***
//              _LoadSIP
//              _SetSubjectInfo
//              _GetMessage
//              _ExplodeMessage
//              _NoContentWrap
//              _SkipOverIdentifierAndLengthOctets
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "crypthlp.h"

#include    "sipguids.h"    // located in pki/mssip32

BOOL _LoadSIP(CRYPT_PROVIDER_DATA *pProvData);
BOOL _SetSubjectInfo(CRYPT_PROVIDER_DATA *pProvData);
BOOL _GetMessage(CRYPT_PROVIDER_DATA *pProvData);
BOOL _ExplodeMessage(CRYPT_PROVIDER_DATA *pProvData);
BOOL _NoContentWrap(const BYTE *pbDER, DWORD cbDER);
DWORD _SkipOverIdentifierAndLengthOctets(const BYTE *pbDER, DWORD cbDER);
extern "C" BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);
extern "C" VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);


HRESULT WINAPI SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = ERROR_SUCCESS;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    //
                    // this is handled in the signature provider
                    //
                    return(ERROR_SUCCESS);

        case WTD_CHOICE_FILE:
        case WTD_CHOICE_CATALOG:
        case WTD_CHOICE_BLOB:
                    break;

        default:
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = ERROR_INVALID_PARAMETER;
                    return(S_FALSE);
    }

    //
    //  extract the message from object.
    //
    if (!(_SetSubjectInfo(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_LoadSIP(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_GetMessage(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_ExplodeMessage(pProvData)))
    {
        return(S_FALSE);
    }


    //
    //  verify the object that the message pertains to
    //
    if ((pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG) &&
        (_ISINSTRUCT(WINTRUST_CATALOG_INFO, pProvData->pWintrustData->pCatalog->cbStruct,
                     cbCalculatedFileHash)) &&
        (pProvData->pWintrustData->pCatalog->pbCalculatedFileHash) &&
        (pProvData->pWintrustData->pCatalog->cbCalculatedFileHash > 0))
    {
        //
        //  we've been passed in the calculated file hash so don't redo it, just check it!
        //
        if (!(pProvData->pPDSip->psIndirectData) ||
            !(pProvData->pPDSip->psIndirectData->Digest.pbData) ||
            (pProvData->pWintrustData->pCatalog->cbCalculatedFileHash !=
                pProvData->pPDSip->psIndirectData->Digest.cbData) ||
            (memcmp(pProvData->pWintrustData->pCatalog->pbCalculatedFileHash,
                    pProvData->pPDSip->psIndirectData->Digest.pbData,
                    pProvData->pPDSip->psIndirectData->Digest.cbData) != 0))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_BAD_DIGEST;
            return(S_FALSE);
        }

    }
    else
    {
        //
        //  we need to calculate the hash from the file.... do it!
        //
        if (!(pProvData->pPDSip->pSip->pfVerify(pProvData->pPDSip->psSipSubjectInfo,
                                                 pProvData->pPDSip->psIndirectData)))
        {
            if (GetLastError() == CRYPT_E_SECURITY_SETTINGS)
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_SECURITY_SETTINGS;
            }
            else
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_BAD_DIGEST;
            }

            return(S_FALSE);
        }
    }

    return(ERROR_SUCCESS);
}

static GUID     _gCATSubject = CRYPT_SUBJTYPE_CATALOG_IMAGE;

BOOL _LoadSIP(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->pPDSip->pSip))
    {
        if (!(pProvData->pPDSip->pSip = (SIP_DISPATCH_INFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_DISPATCH_INFO))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        if (!(CryptSIPLoad(&pProvData->pPDSip->gSubject, 0, pProvData->pPDSip->pSip)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP]             = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_PROVIDER_UNKNOWN;
            return(FALSE);
        }
    }

    if (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG)
    {
        if (!(pProvData->pPDSip->pCATSip))
        {
            if (!(pProvData->pPDSip->pCATSip = (SIP_DISPATCH_INFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_DISPATCH_INFO))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            if (!(CryptSIPLoad(&_gCATSubject, 0, pProvData->pPDSip->pCATSip)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_PROVIDER_UNKNOWN;
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

BOOL _SetSubjectInfo(CRYPT_PROVIDER_DATA *pProvData)
{
    SIP_SUBJECTINFO     *pSubjInfo;
    SIP_DISPATCH_INFO   sSIPDisp;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_BLOB:
            if (!(pProvData->pWintrustData->pBlob) ||
                !(_ISINSTRUCT(WINTRUST_BLOB_INFO, pProvData->pWintrustData->pBlob->cbStruct, pbMemSignedMsg)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            memcpy(&pProvData->pPDSip->gSubject, &pProvData->pWintrustData->pBlob->gSubject, sizeof(GUID));
            break;

        case WTD_CHOICE_FILE:
            if (!(pProvData->pWintrustData->pFile) ||
                !(_ISINSTRUCT(WINTRUST_FILE_INFO, pProvData->pWintrustData->pFile->cbStruct, hFile)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            if ((_ISINSTRUCT(WINTRUST_FILE_INFO, pProvData->pWintrustData->pFile->cbStruct, pgKnownSubject)) &&
                (pProvData->pWintrustData->pFile->pgKnownSubject))
            {
                memcpy(&pProvData->pPDSip->gSubject, pProvData->pWintrustData->pFile->pgKnownSubject, sizeof(GUID));
            }
            else if (!(CryptSIPRetrieveSubjectGuid(pProvData->pWintrustData->pFile->pcwszFilePath,
                                                   pProvData->pWintrustData->pFile->hFile,
                                                   &pProvData->pPDSip->gSubject)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP]             = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = TRUST_E_SUBJECT_FORM_UNKNOWN;
                return(FALSE);
            }
            break;

        case WTD_CHOICE_CATALOG:
            if (!(pProvData->pWintrustData->pCatalog) ||
                !(_ISINSTRUCT(WINTRUST_CATALOG_INFO, pProvData->pWintrustData->pCatalog->cbStruct,
                              hMemberFile)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
                (pProvData->fRecallWithState))
            {
                break;
            }

            if (!(pProvData->pPDSip->psSipCATSubjectInfo =
                    (SIP_SUBJECTINFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_SUBJECTINFO))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memset(pProvData->pPDSip->psSipCATSubjectInfo, 0x00, sizeof(SIP_SUBJECTINFO));

            pProvData->pPDSip->psSipCATSubjectInfo->cbSize              = sizeof(SIP_SUBJECTINFO);
            pProvData->pPDSip->psSipCATSubjectInfo->hProv               = pProvData->hProv;
            pProvData->pPDSip->psSipCATSubjectInfo->pClientData         = pProvData->pWintrustData->pSIPClientData;
            pProvData->pPDSip->psSipCATSubjectInfo->pwsFileName         =
                            (WCHAR *)pProvData->pWintrustData->pCatalog->pcwszCatalogFilePath;
            pProvData->pPDSip->psSipCATSubjectInfo->pwsDisplayName      =
                                                        pProvData->pPDSip->psSipCATSubjectInfo->pwsFileName;

            pProvData->pPDSip->psSipCATSubjectInfo->fdwCAPISettings     = pProvData->dwRegPolicySettings;
            pProvData->pPDSip->psSipCATSubjectInfo->fdwSecuritySettings = pProvData->dwRegPolicySettings;

            if (!(pProvData->pPDSip->psSipCATSubjectInfo->pgSubjectType =
                            (GUID *)pProvData->psPfns->pfnAlloc(sizeof(GUID))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memcpy(pProvData->pPDSip->psSipCATSubjectInfo->pgSubjectType, &_gCATSubject, sizeof(GUID));
            break;

        default:
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = CRYPT_E_FILE_ERROR;
            return(FALSE);
    }


    //
    //  setup the subject info for the SIP
    //
    if (!(pProvData->pPDSip->psSipSubjectInfo))
    {
        if (!(pProvData->pPDSip->psSipSubjectInfo =
                (SIP_SUBJECTINFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_SUBJECTINFO))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        pSubjInfo = pProvData->pPDSip->psSipSubjectInfo;

        memset(pSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));

        pSubjInfo->cbSize   = sizeof(SIP_SUBJECTINFO);

        pSubjInfo->hProv    = pProvData->hProv;

    }
    else
    {
        pSubjInfo = pProvData->pPDSip->psSipSubjectInfo;
    }


    pSubjInfo->pClientData          = pProvData->pWintrustData->pSIPClientData;

    pSubjInfo->pwsFileName          = WTHelperGetFileName(pProvData->pWintrustData);
    pSubjInfo->hFile                = WTHelperGetFileHandle(pProvData->pWintrustData);
    pSubjInfo->pwsDisplayName       = pSubjInfo->pwsFileName;

    pSubjInfo->fdwCAPISettings      = pProvData->dwRegPolicySettings;
    pSubjInfo->fdwSecuritySettings  = pProvData->dwRegSecuritySettings;

    if (!(pSubjInfo->pgSubjectType = (GUID *)pProvData->psPfns->pfnAlloc(sizeof(GUID))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    switch(pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
            break;

        case WTD_CHOICE_BLOB:
            pSubjInfo->dwUnionChoice    = MSSIP_ADDINFO_BLOB;
            if (!(pSubjInfo->psBlob = (MS_ADDINFO_BLOB *)pProvData->psPfns->pfnAlloc(sizeof(MS_ADDINFO_BLOB))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memset(pSubjInfo->psBlob, 0x00, sizeof(MS_ADDINFO_BLOB));
            pSubjInfo->psBlob->cbStruct         = sizeof(MS_ADDINFO_BLOB);
            pSubjInfo->psBlob->cbMemObject      = pProvData->pWintrustData->pBlob->cbMemObject;
            pSubjInfo->psBlob->pbMemObject      = pProvData->pWintrustData->pBlob->pbMemObject;
            pSubjInfo->psBlob->cbMemSignedMsg   = pProvData->pWintrustData->pBlob->cbMemSignedMsg;
            pSubjInfo->psBlob->pbMemSignedMsg   = pProvData->pWintrustData->pBlob->pbMemSignedMsg;

            pSubjInfo->pwsDisplayName       = pProvData->pWintrustData->pBlob->pcwszDisplayName;
            break;

        case WTD_CHOICE_CATALOG:
          // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
          // DELAYLOAD fails an exception is raised.
          __try {

            HANDLE                      hCatStore;
            MS_ADDINFO_CATALOGMEMBER    *pCatAdd;


            if (!(pSubjInfo->psCatMember))
            {
                if (!(pSubjInfo->psCatMember =
                    (MS_ADDINFO_CATALOGMEMBER *)pProvData->psPfns->pfnAlloc(sizeof(MS_ADDINFO_CATALOGMEMBER))))
                {
                    pProvData->dwError = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                    return(FALSE);
                }

                memset(pSubjInfo->psCatMember, 0x00, sizeof(MS_ADDINFO_CATALOGMEMBER));

                pSubjInfo->dwUnionChoice    = MSSIP_ADDINFO_CATMEMBER;

                pCatAdd                     = pSubjInfo->psCatMember;
                pCatAdd->cbStruct           = sizeof(MS_ADDINFO_CATALOGMEMBER);

                hCatStore = CryptCATOpen((WCHAR *)pProvData->pWintrustData->pCatalog->pcwszCatalogFilePath,
                                         CRYPTCAT_OPEN_EXISTING,
                                         pProvData->hProv,
                                         pProvData->pWintrustData->pCatalog->dwCatalogVersion,
                                         NULL);

                if (!(hCatStore) || (hCatStore == INVALID_HANDLE_VALUE))
                {
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = CRYPT_E_FILE_ERROR;
                    return(FALSE);
                }

                pCatAdd->pStore     = CryptCATStoreFromHandle(hCatStore);
            }
            else
            {
                pCatAdd     = pSubjInfo->psCatMember;
                hCatStore   = CryptCATHandleFromStore(pCatAdd->pStore);
            }

            pCatAdd->pMember = NULL;

            if ( ( pProvData->pWintrustData->pCatalog->pbCalculatedFileHash != NULL ) &&
                 ( pProvData->pWintrustData->pCatalog->cbCalculatedFileHash != 0 ) )
            {
                LPWSTR pwszHashTag;

                if ( MsCatConstructHashTag(
                          pProvData->pWintrustData->pCatalog->cbCalculatedFileHash,
                          pProvData->pWintrustData->pCatalog->pbCalculatedFileHash,
                          &pwszHashTag
                          ) == TRUE )
                {
                    pCatAdd->pMember = CryptCATGetMemberInfo(hCatStore, pwszHashTag);
                    MsCatFreeHashTag(pwszHashTag);
                }
            }

            if (!(pCatAdd->pMember))
            {
                pCatAdd->pMember    = CryptCATGetMemberInfo(hCatStore,
                                             (WCHAR *)pProvData->pWintrustData->pCatalog->pcwszMemberTag);
            }

            if (!(pCatAdd->pMember))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = TRUST_E_NOSIGNATURE;
                return(FALSE);
            }

            memcpy(&pProvData->pPDSip->gSubject, &pCatAdd->pMember->gSubjectType, sizeof(GUID));


            //
            //  assign the correct cert version so hashes will match if the file was already signed!
            //
            pSubjInfo->dwIntVersion = pCatAdd->pMember->dwCertVersion;

          } __except(EXCEPTION_EXECUTE_HANDLER) {
              pProvData->dwError = GetExceptionCode();
              pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] =
                  TRUST_E_SYSTEM_ERROR;
              return(FALSE);
          }
          break;
    }

    //
    //  set the GUID for the SIP...  this is done at the end because the pProvData member
    //  can get changed above!
    //
    memcpy(pSubjInfo->pgSubjectType, &pProvData->pPDSip->gSubject, sizeof(GUID));

    return(TRUE);
}

BOOL _GetMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD               dwMsgEncoding;
    SIP_SUBJECTINFO     *pSubjInfo;
    SIP_DISPATCH_INFO   *pSip;

    DWORD               cbEncodedMsg;
    BYTE                *pbEncodedMsg;

    DWORD               dwMsgType;
    HCRYPTMSG           hMsg;
    HCRYPTPROV          hProv;

    dwMsgEncoding   = 0;
    dwMsgType       = 0;

    switch(pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CATALOG:
            if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
                (pProvData->fRecallWithState) &&
                (pProvData->hMsg))
            {
                return(TRUE);
            }

            pSip        = pProvData->pPDSip->pCATSip;
            pSubjInfo   = pProvData->pPDSip->psSipCATSubjectInfo;
            break;

        case WTD_CHOICE_BLOB:
        case WTD_CHOICE_FILE:
            pSip        = pProvData->pPDSip->pSip;
            pSubjInfo   = pProvData->pPDSip->psSipSubjectInfo;
            break;

        default:
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;
            return(FALSE);
    }

    cbEncodedMsg = 0;

    pSip->pfGet(pSubjInfo, &dwMsgEncoding, 0, &cbEncodedMsg, NULL);

    if (cbEncodedMsg == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;
        return(FALSE);
    }

    if (!(pbEncodedMsg = (BYTE *)pProvData->psPfns->pfnAlloc(cbEncodedMsg)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    if (!(pSip->pfGet(pSubjInfo, &dwMsgEncoding, 0, &cbEncodedMsg, pbEncodedMsg)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->dwEncoding = dwMsgEncoding;

    if ((pProvData->dwEncoding & PKCS_7_ASN_ENCODING) &&
        (_NoContentWrap(pbEncodedMsg,  cbEncodedMsg)))
    {
        dwMsgType = CMSG_SIGNED;    // support for IE v3.0
    }

    // The default hProv to use depends on the type of the public key used to
    // do the signing.
    hProv = pProvData->hProv;
    if (hProv && hProv == I_CryptGetDefaultCryptProv(0))
        hProv = 0;

    if (!(hMsg = CryptMsgOpenToDecode(pProvData->dwEncoding, 0, dwMsgType,
                                      hProv, NULL, NULL)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MESSAGE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_BAD_MSG;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->hMsg = hMsg;

    // encoded message
    if (!(CryptMsgUpdate(hMsg, pbEncodedMsg, cbEncodedMsg, TRUE)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MESSAGE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_BAD_MSG;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->psPfns->pfnFree(pbEncodedMsg);

    return(TRUE);
}

BOOL _ExplodeMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD               cbSize;
    DWORD               cbContent;
    BYTE                *pb;
    HCERTSTORE          hStore;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) ||
        !(pProvData->fRecallWithState))
    {
        // message cert store
        hStore = CertOpenStore(CERT_STORE_PROV_MSG,
                               pProvData->dwEncoding,
                               pProvData->hProv,
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               pProvData->hMsg);
        if (hStore)
        {
            if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, hStore)))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;

                CertCloseStore(hStore, 0);

                return(FALSE);
            }

            CertCloseStore(hStore, 0);
        }
        else
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = GetLastError();
            return(FALSE);
        }
    }

    // inner content type
    cbSize = 0;

    CryptMsgGetParam(pProvData->hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, 0, NULL, &cbSize);

    if (cbSize == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNTTYPE] = GetLastError();

        return(FALSE);
    }

    if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cbSize + 1)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(FALSE);
    }

    if (!(CryptMsgGetParam(pProvData->hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, 0,
                           pb, &cbSize)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNTTYPE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;

        delete pb;

        return(FALSE);
    }

    pb[cbSize] = NULL;

    if (strcmp((char *)pb, SPC_INDIRECT_DATA_OBJID) == 0)
    {
        pProvData->psPfns->pfnFree(pb);

        cbContent = 0;

        CryptMsgGetParam(pProvData->hMsg, CMSG_CONTENT_PARAM, 0, NULL, &cbContent);

        if (cbContent == 0)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            return(FALSE);
        }

        if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cbContent)))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(FALSE);
        }

        if (!(CryptMsgGetParam(pProvData->hMsg, CMSG_CONTENT_PARAM, 0,
                                pb, &cbContent)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            pProvData->psPfns->pfnFree(pb);

            return(FALSE);
        }

        if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pProvData->pPDSip->psIndirectData, &cbSize, 202,
                          pProvData->dwEncoding, SPC_INDIRECT_DATA_CONTENT_STRUCT,
                          pb, cbContent, 0)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            pProvData->psPfns->pfnFree(pb);

            return(FALSE);
        }

        pProvData->psPfns->pfnFree(pb);
    }
    else
    {
        pProvData->psPfns->pfnFree(pb);

        if ((pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG) &&
            (pProvData->pPDSip->psSipSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER))
        {
            //
            //  get the indirect data from the pMember!!!  Also, we want to
            //  allocate just the structure and copy the pointers over to it.
            //  this is so we can have a generic cleanup.
            //
            MS_ADDINFO_CATALOGMEMBER    *pCatAdd;

            pCatAdd = pProvData->pPDSip->psSipSubjectInfo->psCatMember;

            if ((pCatAdd) && (pCatAdd->pMember) && (pCatAdd->pMember->pIndirectData))
            {
                if (!(pProvData->pPDSip->psIndirectData =
                            (SIP_INDIRECT_DATA *)pProvData->psPfns->pfnAlloc(sizeof(SIP_INDIRECT_DATA))))
                {
                    pProvData->dwError = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

                    return(FALSE);
                }

                memcpy(pProvData->pPDSip->psIndirectData, pCatAdd->pMember->pIndirectData,
                                    sizeof(SIP_INDIRECT_DATA));
            }
        }
    }

    return(TRUE);
}

DWORD _SkipOverIdentifierAndLengthOctets(const BYTE *pbDER, DWORD cbDER)
{
#       define  TAG_MASK        0x1f

    DWORD           cb;
    DWORD           cbLength;
    const BYTE      *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
    {
        return(0);
    }

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK))
    {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++)
        {
            if (cb >= cbDER)
            {
                return(0);
            }
        }
    }
    else
    {
        // low-tag-number form
        cb = 1;
    }

    // need at least one more byte for length
    if (cb >= cbDER)
    {
        return(0);
    }

    if (0x80 == *pb)
    {
        // Indefinite
        cb++;
    }
    else if ((cbLength = *pb) & 0x80)
    {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;

        if (cb > cbDER)
        {
            return(0);
        }
    }
    else
    {
        cb++;
    }

    return(cb);
}


BOOL _NoContentWrap(const BYTE *pbDER, DWORD cbDER)
{
    DWORD cb;

    cb = _SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if ((cb > 0) && (cb < cbDER) && (pbDER[cb] == 0x02))
    {
        return TRUE;
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\pertrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pertrust.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    WCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    WCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
	{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	// Answer whether the indicated certificate is trusted at the 
	// indicated level of the certificate chain.
	//
	//		S_OK     == yes
	//		S_FALSE  == no
	//		other    == error, can't tell
	//
	STDMETHOD(IsTrustedCert)(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial) PURE;

	//
	// Add the given certificate to the trust data base
	//
	STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

	//
	// Remove the given certificate from the trust data base
	//
	STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPWSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
	//		S_OK     == yes
	//		S_FALSE  == no
	//		other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

	};

//
// Creation function for default implementation
//
HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\offprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       offprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  OfficeRegisterServer
//              OfficeUnregisterServer
//              OfficeInitializePolicy
//              OfficeCleanupPolicy
//
//              *** local functions ***
//              _SetOverrideText
//
//  History:    18-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _SetOverrideText(CRYPT_PROVIDER_DATA *pProvData, WCHAR **ppwszRet, DWORD dwStringId);

//////////////////////////////////////////////////////////////////////////////
//
// OfficeRegisterServer
//----------------------------------------------------------------------------
//  Register the office provider
//  

STDAPI OfficeRegisterServer(void)
{
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;

    CRYPT_REGISTER_ACTIONID     sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // my initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = OFFICE_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = OFFICE_INITPROV_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    // Authenticode certificate checker
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    // Authenticode final
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = SP_FINALPOLICY_FUNCTION;

    // Authenticode cleanup
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = OFFICE_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = OFFICE_CLEANUPPOLICY_FUNCTION;

    if (WintrustAddActionID(&gOfficeProv, 0, &sRegAID))
    {
        return(S_OK);
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters office provider
//  

STDAPI OfficeUnregisterServer(void)
{
    GUID    gOfficeProv = OFFICESIGN_ACTION_VERIFY;

    WintrustRemoveActionID(&gOfficeProv);

    return(S_OK);
}


typedef struct _OFFPROV_PRIVATE_DATA
{
    DWORD                       cbStruct;

    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

} OFFPROV_PRIVATE_DATA, *POFFPROV_PRIVATE_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// Initialize Policy Provider function: OfficeInitializePolicy
//----------------------------------------------------------------------------
//  change the OID to the email OID for Usage....
//  

static char *pszOfficeUsage = szOID_PKIX_KP_CODE_SIGNING;

HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    GUID                        gAuthenticode = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     sPrivData;
    CRYPT_PROVIDER_PRIVDATA     *pPrivData;
    OFFPROV_PRIVATE_DATA        *pOfficeData;
    HRESULT                     hr;

    memset(&sPrivData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
    sPrivData.cbStruct      = sizeof(CRYPT_PROVIDER_PRIVDATA);

    memcpy(&sPrivData.gProviderID, &gOfficeProv, sizeof(GUID));

    //
    //  add my data to the chain!
    //
    if (!pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sPrivData))
    {
        return(S_FALSE);
    }

    //
    //  get the new reference
    //
    pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gOfficeProv);


    //
    //  allocate space for my struct
    //
    if (!(pPrivData->pvProvData = pProvData->psPfns->pfnAlloc(sizeof(OFFPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return(S_FALSE);
    }

    memset(pPrivData->pvProvData, 0x00, sizeof(OFFPROV_PRIVATE_DATA));
    pPrivData->cbProvData   = sizeof(OFFPROV_PRIVATE_DATA);

    pOfficeData             = (OFFPROV_PRIVATE_DATA *)pPrivData->pvProvData;
    pOfficeData->cbStruct   = sizeof(OFFPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    pOfficeData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &pOfficeData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sPrivData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    if (pOfficeData->sAuthenticodePfns.pfnInitialize)
    {
        hr = pOfficeData->sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    pProvData->pszUsageOID  = pszOfficeUsage;

    //
    //  change the text on the dialog buttons
    //
    if (pProvData->psPfns->psUIpfns)
    {
        if (pProvData->psPfns->psUIpfns->psUIData)
        {
            if (!(_ISINSTRUCT(CRYPT_PROVUI_DATA, pProvData->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionTextNotSigned)))
            {
                return(hr);
            }

            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pYesButtonText,        
                             IDS_OFFICE_YES_BUTTON_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pNoButtonText,         
                             IDS_OFFICE_NO_BUTTON_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionText,       
                             IDS_OFFICE_COPYACTION_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS,   
                             IDS_OFFICE_COPYACTION_NOTS_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned, 
                             IDS_OFFICE_COPYACTION_NOSIGN_TEXT);
        }
    }

    return(hr);
}

void _SetOverrideText(CRYPT_PROVIDER_DATA *pProvData, WCHAR **ppwszRet, DWORD dwStringId)
{
    WCHAR                       wsz[MAX_PATH];

    if (*ppwszRet)
    {
        pProvData->psPfns->pfnFree(*ppwszRet);
        *ppwszRet = NULL;
    }

    wsz[0] = NULL;
    LoadStringU(hinst, dwStringId, &wsz[0], MAX_PATH);

    if (wsz[0])
    {
        if (*ppwszRet = (WCHAR *)pProvData->psPfns->pfnAlloc((wcslen(&wsz[0]) + 1) * sizeof(WCHAR)))
        {
            wcscpy(*ppwszRet, &wsz[0]);
        }
    }
}

HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;
    OFFPROV_PRIVATE_DATA        *pOfficeData;
    HRESULT                     hr = S_OK;

    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gOfficeProv);

    if (pMyData)
    {
        pOfficeData = (OFFPROV_PRIVATE_DATA *)pMyData->pvProvData;
        //
        //  remove the data we allocated except for the "MyData" which WVT will clean up for us!
        //

        if (pOfficeData->sAuthenticodePfns.pfnCleanupPolicy)
        {
            hr = pOfficeData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
        }

        pProvData->psPfns->pfnFree(pMyData->pvProvData);
        pMyData->pvProvData = NULL;
    }

    if (pProvData->psPfns->psUIpfns)
    {
        if (pProvData->psPfns->psUIpfns->psUIData)
        {
            if (_ISINSTRUCT(CRYPT_PROVUI_DATA, pProvData->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionText))
            {
                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pYesButtonText);
                pProvData->psPfns->psUIpfns->psUIData->pYesButtonText = NULL;

                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pNoButtonText);
                pProvData->psPfns->psUIpfns->psUIData->pNoButtonText = NULL;

                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pCopyActionText);
                pProvData->psPfns->psUIpfns->psUIData->pCopyActionText = NULL;
            }
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\initprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       initprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubInitialize
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

static char *pwszUsageOID = szOID_PKIX_KP_CODE_SIGNING;

HRESULT WINAPI SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = ERROR_SUCCESS;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO]          = ERROR_SUCCESS;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) ||
        (!(pProvData->fRecallWithState)))
    {
        if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID))
        {
            pProvData->pszUsageOID = pwszUsageOID;
        }

    }

    //
    //  for file type calls, make sure the file handle is valid -- open if necessary.
    //
    HANDLE      *phFile;
    const WCHAR *pcwszFile;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                phFile      = &pProvData->pWintrustData->pFile->hFile;
                pcwszFile   = pProvData->pWintrustData->pFile->pcwszFilePath;
                break;

        case WTD_CHOICE_CATALOG:
                phFile      = &pProvData->pWintrustData->pCatalog->hMemberFile;
                pcwszFile   = pProvData->pWintrustData->pCatalog->pcwszMemberFilePath;
                break;

        case WTD_CHOICE_BLOB:
                pcwszFile   = NULL;
                break;

        default:
                return(ERROR_SUCCESS);
    }

    if (!(pProvData->pPDSip))
    {
        if (!(pProvData->pPDSip = (PROVDATA_SIP *)pProvData->psPfns->pfnAlloc(sizeof(PROVDATA_SIP))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = TRUST_E_SYSTEM_ERROR;
            return(S_FALSE);
        }

        pProvData->dwSubjectChoice  = CPD_CHOICE_SIP;

        memset(pProvData->pPDSip, 0x00, sizeof(PROVDATA_SIP));
        pProvData->pPDSip->cbStruct = sizeof(PROVDATA_SIP);
    }


    if (pcwszFile)
    {
        //
        //  we're looking at a file based object...
        //
        pProvData->fOpenedFile = FALSE;

        if (!(*phFile) || (*phFile == INVALID_HANDLE_VALUE))
        {
            if ((*phFile = CreateFileU(pcwszFile,
                                        GENERIC_READ,
                                        FILE_SHARE_READ, // we're only reading!
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO]          = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = CRYPT_E_FILE_ERROR;
            }
            else
            {
                pProvData->fOpenedFile = TRUE;
            }
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\httpsprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httpsprv.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  HTTPSRegisterServer
//              HTTPSUnregisterServer
//              HTTPSCertificateTrust
//              HTTPSFinalProv
//
//  History:    29-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <wininet.h>

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);

//////////////////////////////////////////////////////////////////////////////
//
// HTTPSRegisterServer
//----------------------------------------------------------------------------
//  Register the HTTPS provider
//  

STDAPI HTTPSRegisterServer(void)
{
    GUID                        gHTTPSProv = HTTPSPROV_ACTION;
    BOOL                        fRet;
    CRYPT_REGISTER_ACTIONID     sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE  sDefUsage;

    fRet = TRUE;

    //
    //  set the usages we want
    //
    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gHTTPSProv;
    sDefUsage.pwszDllName                               = SP_POLICY_PROVIDER_DLL_NAME;
    sDefUsage.pwszLoadCallbackDataFunctionName          = "SoftpubLoadDefUsageCallData";
    sDefUsage.pwszFreeCallbackDataFunctionName          = "SoftpubFreeDefUsageCallData";

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_SERVER_AUTH, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_CLIENT_AUTH, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_SERVER_GATED_CRYPTO, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_SGC_NETSCAPE, &sDefUsage);


    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);

#if 0
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!
#else
    // philh changed on Feb 19, 1998 to use HTTPS
    sRegAID.sCertificateProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = HTTPS_CERTTRUST_FUNCTION;
#endif

    // authenticode cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    // custom final ...
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = HTTPS_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gHTTPSProv, 0, &sRegAID);

    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters schannel provider
//  

STDAPI HTTPSUnregisterServer(void)
{
    GUID    gHTTPSProv = HTTPSPROV_ACTION;

    WintrustRemoveActionID(&gHTTPSProv);

    return(S_OK);
}


HCERTCHAINENGINE HTTPSGetChainEngine(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    CERT_CHAIN_ENGINE_CONFIG Config;
    HCERTSTORE hStore = NULL;
    HCERTCHAINENGINE hChainEngine = NULL;

    if (NULL == pProvData->pWintrustData ||
            pProvData->pWintrustData->dwUnionChoice != WTD_CHOICE_CERT ||
            !_ISINSTRUCT(WINTRUST_CERT_INFO,
                pProvData->pWintrustData->pCert->cbStruct, dwFlags) ||
            0 == (pProvData->pWintrustData->pCert->dwFlags & 
                    (WTCI_DONT_OPEN_STORES | WTCI_OPEN_ONLY_ROOT)))
        return NULL;

    memset(&Config, 0, sizeof(Config));
    Config.cbSize = sizeof(Config);

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        Config.hRestrictedRoot = hStore;
    Config.hRestrictedTrust = hStore;
    Config.hRestrictedOther = hStore;

    if (!CertCreateCertificateChainEngine(
            &Config,
            &hChainEngine
            ))
        goto CreateChainEngineError;

CommonReturn:
    CertCloseStore(hStore, 0);
    return hChainEngine;
ErrorReturn:
    hChainEngine = NULL;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, OpenMemoryStoreError)
TRACE_ERROR_EX(DBG_SS, CreateChainEngineError)
}


HCERTSTORE HTTPSGetChainAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pProvData->pahStores[0]);
}

// Following is in ..\wintrust\certtrst.cpp
extern
BOOL UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD idxSigner,
    OUT DWORD *pdwError, 
    IN BOOL fCounterSigner,
    IN DWORD idxCounterSigner,
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    );

// Following is in .\authcode.cpp
extern
void UpdateCertError(
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

HRESULT WINAPI HTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    HTTPSPolicyCallbackData *pHTTPS;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_CERT *pProvCert;

    DWORD dwError;
    DWORD dwSgnrError;
    DWORD dwCreateChainFlags;
    CERT_CHAIN_PARA ChainPara;
    HCERTCHAINENGINE hChainEngine = NULL;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    LPSTR rgpszClientUsage[] = {
        szOID_PKIX_KP_CLIENT_AUTH,
    };
#define CLIENT_USAGE_COUNT      (sizeof(rgpszClientUsage) / \
                                     sizeof(rgpszClientUsage[0]))
    LPSTR rgpszServerUsage[] = {
        szOID_PKIX_KP_SERVER_AUTH,
        szOID_SERVER_GATED_CRYPTO,
        szOID_SGC_NETSCAPE,
    };
#define SERVER_USAGE_COUNT      (sizeof(rgpszServerUsage) / \
                                     sizeof(rgpszServerUsage[0]))

    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState == TRUE))
    {
        return(S_OK);
    }

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
    if (pSgnr)
        pProvCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    if (NULL == pSgnr || NULL == pProvCert) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            TRUST_E_NOSIGNATURE;
        return S_FALSE;
    }


    pHTTPS = (HTTPSPolicyCallbackData *) pProvData->pWintrustData->pPolicyCallbackData;

    if (!pHTTPS || !WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(
            HTTPSPolicyCallbackData, pHTTPS->cbStruct, pwszServerName) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwProvFlags) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_SGNR, pSgnr->cbStruct, pChainContext))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 
            ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;

    dwCreateChainFlags = 0;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    if (pHTTPS->dwAuthType == AUTHTYPE_CLIENT) {
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = CLIENT_USAGE_COUNT;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszClientUsage;
    } else {
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = SERVER_USAGE_COUNT;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszServerUsage;
    }
    if (0 == (pHTTPS->fdwChecks & SECURITY_FLAG_IGNORE_REVOCATION)) {
        if (pProvData->pWintrustData->fdwRevocationChecks != WTD_REVOKE_NONE)
            // On 4-16-01 changed from END_CERT to EXCLUDE_ROOT
            dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    }
    hChainEngine = HTTPSGetChainEngine(pProvData);
    hAdditionalStore = HTTPSGetChainAdditionalStore(pProvData);


    if (!CertGetCertificateChain (
            hChainEngine,
            pProvCert->pCert,
            &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
        DWORD dwUpdateError;

        UpdateCertProvChain(
            pProvData,
            0,              // idxSigner
            &dwUpdateError,
            FALSE,          // fCounterSigner
            0,              // idxCounterSigner
            pSgnr,
            pChainContext
            );

        dwSgnrError = pSgnr->dwError;
        if (CERT_E_REVOKED == dwSgnrError ||
                CERT_E_REVOCATION_FAILURE == dwSgnrError) {

            // Clear the updated errors. Will be updated in the final policy
            pSgnr->dwError = 0;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 0;

            if (CERT_E_REVOKED == pProvCert->dwError ||
                    CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                pProvCert->dwError = 0;
            }
        }
    }

    dwError = S_OK;
                                        
CommonReturn:
    if (hChainEngine)
        CertFreeCertificateChainEngine(hChainEngine);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    pSgnr->pChainContext = pChainContext;
    return dwError;
ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    dwError = S_FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, GetChainError)

}
//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: HTTPSFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  


// On July 26, 2000, disabled the use of the test root
#if 0

void MapHTTPSRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;

    *pdwFlags = dwFlags;
}

#endif

HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{

    HTTPSPolicyCallbackData *pHTTPS;

    pHTTPS = (HTTPSPolicyCallbackData *)
        pProvData->pWintrustData->pPolicyCallbackData;

    if (!(pHTTPS) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(HTTPSPolicyCallbackData,
            pHTTPS->cbStruct, pwszServerName)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }


    DWORD dwError;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) pHTTPS;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);


    //
    // check the high level error codes.
    //
    if (0 != (dwError = GetErrorBasedOnStepErrors(pProvData)))
        goto CommonReturn;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
    if (pSgnr == NULL) {
        dwError = TRUST_E_SYSTEM_ERROR;
        goto CommonReturn;
    }


// On July 26, 2000, disabled the use of the test root
#if 0
    MapHTTPSRegPolicySettingsToBaseChainPolicyFlags(
        pProvData->dwRegPolicySettings,
        &PolicyPara.dwFlags
        );
#endif

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_SSL,
            pSgnr->pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        dwError = TRUST_E_SYSTEM_ERROR;
        goto CommonReturn;
    } else if (0 != PolicyStatus.dwError) {
        dwError = PolicyStatus.dwError;
        UpdateCertError(pSgnr, &PolicyStatus);
        goto CommonReturn;
    }
    
    dwError = 0;
CommonReturn:
    pProvData->dwFinalError = dwError;
    return dwError;
}


///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security Policy Provider
//
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" 
{
#endif



extern HINSTANCE   hinst;

#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#   define szOID_SERVER_GATED_CRYPTO                "1.3.6.1.4.1.311.10.3.3"
#endif

#ifndef szOID_SGC_NETSCAPE
#   define szOID_SGC_NETSCAPE                       "2.16.840.1.113730.4.1"
#endif



//
//  checks.cpp
//
extern DWORD        checkGetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);
extern BOOL         checkIsTrustedRoot(CRYPT_PROVIDER_CERT *pRoot);
extern BOOL         checkCertificateChain(CRYPT_PROVIDER_DATA *pProvData, 
                                          CRYPT_PROVIDER_SGNR *pProvSngr, 
                                          DWORD *dwError);
extern BOOL         checkTimeStampCertificateChain(CRYPT_PROVIDER_DATA *pProvData, 
                                                   CRYPT_PROVIDER_SGNR *pProvSngr, 
                                                   DWORD *dwError);
extern BOOL         checkSetCommercial(CRYPT_PROVIDER_DATA *pProvData, 
                                        CRYPT_PROVIDER_SGNR *pSgnr, 
                                        BOOL *pfCommercial);
extern BOOL         checkBasicConstraints(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_CERT *pCert,
                                            DWORD CertIndex, PCERT_INFO pCertInfo);
extern BOOL         checkBasicConstraints2(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_CERT *pCert,
                                            DWORD idxCert, PCERT_INFO pCertInfo);
extern BOOL         checkCertPurpose(CRYPT_PROVIDER_DATA *pProvData, 
                                     CRYPT_PROVIDER_CERT *pCert, BOOL fCommercialMsg);
extern BOOL         checkCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, 
                                                        PCERT_INFO pCertInfo);

extern BOOL         checkMeetsMinimalFinancialCriteria(CRYPT_PROVIDER_DATA *pProvData,
                                                    PCCERT_CONTEXT pCert,
                                                    BOOL *pfAvail, BOOL *pfMeets);

extern BOOL         checkRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr, 
                                    BOOL fCommercial, DWORD *pdwError);

//
//  authcode.cpp
//
extern HRESULT WINAPI       SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData);

//
//  msgprov.cpp
//
extern HRESULT WINAPI       SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData);

//
//  chkcert.cpp
//
extern BOOL WINAPI          SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                            BOOL fCounterSignerChain, DWORD idxCounterSigner);

extern BOOL IsInTrustList(CRYPT_PROVIDER_DATA *pProvData, PCCERT_CONTEXT pCertContext, PCCERT_CONTEXT *ppCTLSigner,
                          LPSTR pszUsage);
//
//  sigprov.cpp
//
extern HRESULT WINAPI       SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData);

//
//  initprov.cpp
//
extern HRESULT WINAPI       SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData);

//
//  clnprov.cpp
//
extern HRESULT WINAPI       SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData);

//
//  test.cpp
//
extern HRESULT WINAPI       SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData);

//
//  callui.cpp
//
extern HRESULT      SoftpubCallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError, BOOL fFinalCall);

//
//  httpsprv.cpp
//
STDAPI                      HTTPSRegisterServer(void);
STDAPI                      HTTPSUnregisterServer(void);
extern BOOL WINAPI          HTTPSCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                            BOOL fCounterSignerChain, DWORD idxCounterSigner);
extern HRESULT WINAPI       HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData);

//
//  offprov.cpp
//
STDAPI OfficeRegisterServer(void);
STDAPI OfficeUnregisterServer(void);
extern HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

//
//  drvprov.cpp
//
STDAPI DriverRegisterServer(void);
STDAPI DriverUnregisterServer(void);
extern HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData);


//
//  sphelper.cpp
//
extern WCHAR *spGetAgencyNameOfCert(PCCERT_CONTEXT pCert);
extern WCHAR *spGetPublisherNameOfCert(IN PCCERT_CONTEXT pCert);
extern WCHAR *spGetCommonNameExtension(PCCERT_CONTEXT pCert);
extern WCHAR *spGetAgencyName(IN PCERT_NAME_BLOB pNameBlob);
extern WCHAR *spGetRDNAttrWStr(IN LPCSTR pszObjId, IN PCERT_NAME_BLOB pNameBlob);

//
//  chainprv.cpp
//
STDAPI GenericChainRegisterServer(void);
STDAPI GenericChainUnregisterServer(void);

//
//  dllmain.cpp
//
HCERTSTORE
WINAPI
OpenTrustedPublisherStore();

HCERTSTORE
WINAPI
OpenDisallowedStore();


#ifdef __cplusplus
}
#endif

#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by softpub.rc
//
#define IDS_OFFICE_YES_BUTTON_TEXT      1
#define IDS_OFFICE_NO_BUTTON_TEXT       2
#define IDC_RRN_ADVANCED                3
#define IDOK2                           3
#define IDC_DETAILS                     3
#define IDS_OFFICE_COPYACTION_TEXT      3
#define IDS_OFFICE_COPYACTION_NOTS_TEXT 4
#define IDS_OFFICE_COPYACTION_NOSIGN_TEXT 5
#define IDS_DEFAULTAPPNAME              100
#define IDS_UNKNOWNAGENCY               101
#define IDD_TRUSTDIALOG                 102
#define IDS_UNKNOWNPUBLISHER            102
#define IDI_TRUSTDB                     103
#define IDS_UNKNOWNPROGRAM              103
#define IDD_BADTRUST                    105
#define IDC_POINTINGHAND                107
#define IDR_PREINST                     108
#define IDR_WINTRUSTHELPFILE            109
#define IDR_CTROOT                      110
#define IDB_LICENSEIND                  112
#define IDD_RUNORNOT                    132
#define IDB_LICENSE                     142
#define IDB_SEAL                        149
#define IDC_TRUSTCOMMERCIAL             701
#define IDC_TRUSTLIST                   1001
#define IDC_WILDCARDPUBLISHER           1002
#define IDC_TRUSTREMOVE                 1002
#define IDC_WILDCARDAGENCY              1003
#define IDC_LICENSEBMP                  1004
#define IDC_BADTRUSTICON                1005
#define IDC_LICENSEINSET                1006
#define IDC_BADTRUSTBANTER2             1006
#define IDC_BADTRUSTBANTER1             1007
#define IDC_BADTRUSTBANTER3             1008
#define IDC_BANTER                      1012
#define IDC_CLICKLINKS                  1013
#define IDC_DONTSHOW                    1014
#define IDS_BADTRUSTBANTER1             1024
#define IDS_BADTRUSTBANTER2             1025
#define IDS_BADTRUSTBANTER3             1026
#define IDS_BADTRUSTBANTER31            1026
#define IDS_BADTRUSTBANTER32            1027
#define IDS_BADTRUSTBANTER33            1028
#define IDS_BADTRUSTBANTER34            1029
#define IDS_TRUSTDIALOG                 1030
#define IDS_REVOKED                     1031
#define IDS_BADTRUSTBANTER35            1032
#define IDS_BANTER                      2001
#define IDS_ISPUBLISHEDBY               2002
#define IDS_UNDERINDIVIDUAL             2003
#define IDS_UNDERCOMMERCIAL             2004
#define IDS_UNDERTESTINGINDIVIDUAL      2005
#define IDS_UNDERTESTINGCOMMERCIAL      2006
#define IDS_TESTINGBANTER               2007
#define IDS_ENDORSEMENTS                2010
#define IDS_EXPIRES                     2011
#define IDS_ALLBYPUBLISHER              2012
#define IDS_ALLBYAGENCY                 2013
#define IDS_CLOSE                       2014
#define IDS_LOC_OPUS                    5000
#define IDS_LOC_ISPUBLISHEDBY           5001
#define IDS_LOC_PUBLISHER               5002
#define IDS_LOC_UNDERCREDENTIALS        5003
#define IDS_LOC_AGENCY                  5004
#define IDS_LOC_ENDORSEMENTS            5005
#define IDS_LOC_EXPIRES                 5006
#define IDS_TESTSIZE                    5007
#define IDS_TESTORIENT                  5008
#define IDS_BADTRUSTSPACING             5009
#define IDS_FONTNAME                    5010
#define IDS_FONTPITCHANDFAMILY          5011
#define IDS_HLINKHEIGHT                 5012
#define IDS_BANTERHEIGHT                5013
#define IDS_CHARSET                     5014
#define IDS_LOC_MAX                     5015
#define IDS_NO_COMPONENT_SIGNATURE      6100
#define IDS_NO_PUBLISHER_CREDENTIALS    6101
#define IDS_CORRUPT_CONTENT             6102
#define IDS_BAD_CONTENT_DIGEST          6103
#define IDS_BAD_CONTENT_SIGNATURE       6104
#define IDS_NO_TRUSTED_ROOT             6105
#define IDS_UNTRUSTED_ROOT              6106
#define IDS_BAD_CERT_TIME_VALIDITY      6107
#define IDS_BAD_CERT_SIGNATURE          6108
#define IDS_MULTIPLE_GLUE_CERT          6109
#define IDS_VALIDITY_NESTING            6110
#define IDS_BAD_ROLE                    6111
#define IDS_BAD_PATH_LEN_CONST          6112
#define IDS_MALFORMED_CERT              6113
#define IDS_UNSUPPORTED_CERT            6114
#define IDS_BAD_PURPOSE                 6115
#define IDS_TEST_ROOT                   6116
#define IDS_FILE_NOT_FOUND              6117
#define IDS_REVOCATION_OFFLINE          6118
#define IDS_TIMESTAMP_VALIDITY          6120
#define IDS_TIMESTAMP_CHAIN             6121
#define IDS_TIMESTAMP_CHECKED           6122
#define IDS_COLUMN_HEADER               6123
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\test.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       test.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubDumpStructure
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#define     TEST_POLICY_DUMP_FILE       L"C:\\TRUSTPOL.TXT"

void _cdecl FPrintfU(HANDLE hFile, WCHAR *pwszFmt, ...);
void PrintfPFNs(HANDLE hFile, CRYPT_PROVIDER_DATA *pProvData);
void PrintfSignerStruct(HANDLE hFile, CRYPT_PROVIDER_SGNR *pS, int idxSigner, BOOL fCounter, int idxCounter);
void PrintfCertStruct(HANDLE hFile, int cCert, CRYPT_PROVIDER_CERT *pC, int idxCert);
void GetStringDateTime(FILETIME *pFTime, WCHAR *pwszRetTime, WCHAR *pwszRetDate);
WCHAR *GetNameFromBlob(CERT_NAME_BLOB *psNameBlob);

HRESULT WINAPI SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData)
{
    HANDLE  hFile;

    if ((hFile = CreateFileU(TEST_POLICY_DUMP_FILE,
                             GENERIC_WRITE | GENERIC_READ,
                             0,                 // no sharing!!
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(S_FALSE);
    }

    WCHAR           wszTime[64];
    WCHAR           wszDate[128];
    WCHAR           wszGuid[64];
    int             i, i2, i3;

    //
    //  CRYPT_PROVIDER_DATA
    //
    FPrintfU(hFile, L"CRYPT_PROVIDER_DATA:\r\n");


    //
    //  WINTRUST_DATA
    //
    WINTRUST_DATA   *pWT;

    pWT = pProvData->pWintrustData;

    FPrintfU(hFile, L"+======================================================\r\n");
    FPrintfU(hFile, L"+-- pWintrustData:\r\n");
    FPrintfU(hFile, L"|   |.. cbStruct:                     %ld\r\n", pWT->cbStruct);
    FPrintfU(hFile, L"|   |.. pPolicyCallbackData:          %p\r\n", pWT->pPolicyCallbackData);
    FPrintfU(hFile, L"|   |.. dwUIChoice:                   %ld\r\n", pWT->dwUIChoice);
    FPrintfU(hFile, L"|   |.. fdRevocationChecks:           %ld\r\n", pWT->fdwRevocationChecks);
    FPrintfU(hFile, L"|   |.. dwUnionChoice:                %ld\r\n", pWT->dwUnionChoice);

    switch (pWT->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
            if (!(pWT->pFile) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_FILE_INFO, pWT->pFile->cbStruct, hFile)))
            {
                FPrintfU(hFile, L"|   +-- pFile: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pFile:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pFile->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszFilePath:            %s\r\n", pWT->pFile->pcwszFilePath);
            FPrintfU(hFile, L"|       |.. hFile:                    0x%p\r\n", pWT->pFile->hFile);

            wszGuid[0] = NULL;
            if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_FILE_INFO,
                    pWT->pFile->cbStruct, pgKnownSubject) &&
                        pWT->pFile->pgKnownSubject)
            {
                guid2wstr(pWT->pFile->pgKnownSubject, &wszGuid[0]);
            }
            FPrintfU(hFile, L"|       +-- pgKnownSubject:           %s\r\n", &wszGuid[0]);
            break;

        case WTD_CHOICE_CATALOG:
            if (!(pWT->pCatalog) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CATALOG_INFO, pWT->pCatalog->cbStruct, hMemberFile)))
            {
                FPrintfU(hFile, L"|   +-- pCatalog: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pCatalog:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pCatalog->cbStruct);
            FPrintfU(hFile, L"|       |.. dwCatalogVersion:         0x%lx\r\n", pWT->pCatalog->dwCatalogVersion);
            FPrintfU(hFile, L"|       |.. pcwszCatalogFilePath:     %s\r\n", pWT->pCatalog->pcwszCatalogFilePath);
            FPrintfU(hFile, L"|       |.. pcwszMemberTag:           %s\r\n", pWT->pCatalog->pcwszMemberTag);
            FPrintfU(hFile, L"|       |.. pcwszMemberFilePath:      %s\r\n", pWT->pCatalog->pcwszMemberFilePath);
            FPrintfU(hFile, L"|       |.. hMemberFile:              0x%p\r\n", pWT->pCatalog->hMemberFile);
            FPrintfU(hFile, L"|       |.. pbCaclulatedFileHash:     ");

            for (i = 0; i < (int)pWT->pCatalog->cbCalculatedFileHash; i++)
            {
                FPrintfU(hFile, L"%02.2X", pWT->pCatalog->pbCalculatedFileHash[i]);
            }
            FPrintfU(hFile, L"\r\n");
            FPrintfU(hFile, L"|       +-- cbCaclulatedFileHash:     %ld\r\n", pWT->pCatalog->cbCalculatedFileHash);
            break;

        case WTD_CHOICE_BLOB:
            if (!(pWT->pBlob) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_BLOB_INFO, pWT->pBlob->cbStruct, pbMemSignedMsg)))
            {
                FPrintfU(hFile, L"|   +-- pBlob: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pBlob:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pBlob->cbStruct);
            wszGuid[0] = NULL;
            guid2wstr(&pWT->pBlob->gSubject, &wszGuid[0]);
            FPrintfU(hFile, L"        |.. gSubject:                 %s\r\n", &wszGuid[0]);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pBlob->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. cbMemObject:              %ld\r\n", pWT->pBlob->cbMemObject);
            FPrintfU(hFile, L"|       |.. pbMemObject:              0x%p\r\n", pWT->pBlob->pbMemObject);
            FPrintfU(hFile, L"|       |.. cbMemSignedMsg:           %ld\r\n", pWT->pBlob->cbMemSignedMsg);
            FPrintfU(hFile, L"|       +.. pbMemSignedMsg:           0x%p\r\n", pWT->pBlob->pbMemSignedMsg);
            break;

        case WTD_CHOICE_SIGNER:
            if (!(pWT->pSgnr) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_SGNR_INFO, pWT->pSgnr->cbStruct, pahStores)))
            {
                FPrintfU(hFile, L"|   +-- pSgnr: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pSgnr:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pSgnr->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pSgnr->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. psSignerInfo:             0x%p\r\n", pWT->pSgnr->psSignerInfo);
            FPrintfU(hFile, L"|       |.. chStores:                 %ld\r\n", pWT->pSgnr->chStores);
            for (i = 0; i < (int)pWT->pSgnr->chStores; i++)
            {
                if (i == (int)(pWT->pSgnr->chStores - 1))
                {
                    FPrintfU(hFile, L"|       +.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pSgnr->pahStores[i]);
                }
                else
                {
                    FPrintfU(hFile, L"|       |.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pSgnr->pahStores[i]);
                }
            }
            break;

        case WTD_CHOICE_CERT:
            if (!(pWT->pCert) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CERT_INFO, pWT->pCert->cbStruct, psftVerifyAsOf)))
            {
                FPrintfU(hFile, L"|   +-- pCert: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pCert:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pCert->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pCert->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. psCertContext:            0x%p\r\n", pWT->pCert->psCertContext);
            FPrintfU(hFile, L"|       |.. chStores:                 %ld\r\n", pWT->pCert->chStores);
            for (i = 0; i < (int)pWT->pCert->chStores; i++)
            {
                FPrintfU(hFile, L"|       |.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pCert->pahStores[i]);
            }

            FPrintfU(hFile, L"|       |.. dwFlags:                  0x%08.8lX\r\n", pWT->pCert->dwFlags);

            wszTime[0] = NULL;
            wszDate[0] = NULL;

            if (pWT->pCert->psftVerifyAsOf)
            {
                GetStringDateTime(pWT->pCert->psftVerifyAsOf, &wszTime[0], &wszDate[0]);
            }

            FPrintfU(hFile, L"|       |-- psftVerifyAsOf:               %s - %s\r\n", &wszDate[0], &wszTime[0]);
            break;

        default:
            FPrintfU(hFile, L"|       +.. ***Unknown structure type***\r\n");
            break;
    }

    FPrintfU(hFile, L"|.. WndParent:                        0x%p\r\n", pProvData->hWndParent);

    wszGuid[0] = NULL;
    guid2wstr(pProvData->pgActionID, &wszGuid[0]);
    FPrintfU(hFile, L"|.. pgActionID:                       %s\r\n", &wszGuid[0]);
    FPrintfU(hFile, L"|.. hProv:                            0x%p\r\n", pProvData->hProv);
    FPrintfU(hFile, L"|.. dwError:                          0x%08.8lx\r\n", pProvData->dwError);
    FPrintfU(hFile, L"|.. dwRegSecuritySettings:            0x%08.8lx\r\n", pProvData->dwRegSecuritySettings);
    FPrintfU(hFile, L"|.. dwRegPolicySettings:              0x%08.8lx\r\n", pProvData->dwRegPolicySettings);
    FPrintfU(hFile, L"|.. dwEncoding:                       0x%08.8lx\r\n", pProvData->dwEncoding);

    PrintfPFNs(hFile, pProvData);

    FPrintfU(hFile, L"|.. padwTrustStepErrors:\r\n");

    for (i = 0; i < (int)pProvData->cdwTrustStepErrors; i++)
    {
        if (i == (int)(pProvData->cdwTrustStepErrors - 1))
        {
            FPrintfU(hFile, L"|   +.. Step[%02.2d]:                     0x%08.8lx\r\n", i, pProvData->padwTrustStepErrors[i]);
        }
        else
        {
            FPrintfU(hFile, L"|   |.. Step[%02.2d]:                     0x%08.8lx\r\n", i, pProvData->padwTrustStepErrors[i]);
        }
    }

    FPrintfU(hFile, L"|.. pahStores:\r\n");

    for (i = 0; i < (int)pProvData->chStores; i++)
    {
        if (i == (int)(pProvData->chStores - 1))
        {
            FPrintfU(hFile, L"|   +.. Store[%02.2d]:                    0x%lx\r\n", i, pProvData->pahStores[i]);
        }
        else
        {
            FPrintfU(hFile, L"|   |.. Store[%02.2d]:                    0x%lx\r\n", i, pProvData->pahStores[i]);
        }
    }

    FPrintfU(hFile, L"|.. hMsg:                             0x%p\r\n", pProvData->hMsg);

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        wszGuid[0] = NULL;
        guid2wstr(&pProvData->pPDSip->gSubject, &wszGuid[0]);
        FPrintfU(hFile, L"|.. pPDSip:\r\n");
        FPrintfU(hFile, L"|   |.. gSubject:                     %s\r\n", &wszGuid[0]);

        FPrintfU(hFile, L"|   |.. pSip:                         0x%p\r\n", pProvData->pPDSip->pSip);
        FPrintfU(hFile, L"|   |.. pCATSip:                      0x%p\r\n", pProvData->pPDSip->pCATSip);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   |.. psSipSubjectInfo:             0x%p\r\n", pProvData->pPDSip->psSipSubjectInfo);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   |.. psSipCATSubjectInfo:          0x%p\r\n", pProvData->pPDSip->psSipCATSubjectInfo);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   +.. psIndirectData:               0x%p\r\n", pProvData->pPDSip->psIndirectData);
    }

    FPrintfU(hFile, L"|.. csSigners:                        %lu\r\n", pProvData->csSigners);

    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR *pCounterSgnr;

    for (i = 0; i < (int)pProvData->csSigners; i++)
    {
        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);

        PrintfSignerStruct(hFile, pSgnr, i, FALSE, 0);

        if (pSgnr->csCounterSigners > 0)
        {
            for (i2 = 0; i2 < (int)pSgnr->csCounterSigners; i2++)
            {
                pCounterSgnr = WTHelperGetProvSignerFromChain(pProvData, i, TRUE, i2);
                PrintfSignerStruct(hFile, pCounterSgnr, i, TRUE, i2);
            }
        }
    }

    FPrintfU(hFile, L"|.. pszUsageOID:                      %p\r\n", pProvData->pszUsageOID);
    FPrintfU(hFile, L"|.. fRecallWithState:                 %s\r\n", (pProvData->fRecallWithState) ? "TRUE" : "FALSE");

    GetStringDateTime(&pProvData->sftSystemTime, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|.. sftSystemTime:                    %s - %s\r\n", &wszDate[0], &wszTime[0]);


    FPrintfU(hFile, L"+======================================================\r\n");

    CloseHandle(hFile);

    return(S_OK);
}

void PrintfPFNs(HANDLE hFile, CRYPT_PROVIDER_DATA *pPD)
{
    FPrintfU(hFile, L"|.. psPfns:\r\n");

    if (!(pPD->psPfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPD->psPfns->cbStruct, pfnTestFinalPolicy)))
    {
        FPrintfU(hFile, L"|   +.. *** invalid parameter ***\r\n");
        return;
    }
    FPrintfU(hFile, L"|   |.. cbStruct:                     %lu\r\n", pPD->psPfns->cbStruct);
    FPrintfU(hFile, L"|   |.. pfnAlloc:                     0x%p\r\n", pPD->psPfns->pfnAlloc);
    FPrintfU(hFile, L"|   |.. pfnFree:                      0x%p\r\n", pPD->psPfns->pfnFree);
    FPrintfU(hFile, L"|   |.. pfnAddStore2Chain:            0x%p\r\n", pPD->psPfns->pfnAddStore2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddSgnr2Chain:             0x%p\r\n", pPD->psPfns->pfnAddSgnr2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddCert2Chain:             0x%p\r\n", pPD->psPfns->pfnAddCert2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddPrivData2Chain:         0x%p\r\n", pPD->psPfns->pfnAddPrivData2Chain);
    FPrintfU(hFile, L"|   |.. pfnInitialize:                0x%p\r\n", pPD->psPfns->pfnInitialize);
    FPrintfU(hFile, L"|   |.. pfnObjectTrust:               0x%p\r\n", pPD->psPfns->pfnObjectTrust);
    FPrintfU(hFile, L"|   |.. pfnSignatureTrust:            0x%p\r\n", pPD->psPfns->pfnSignatureTrust);
    FPrintfU(hFile, L"|   |.. pfnCertificateTrust:          0x%p\r\n", pPD->psPfns->pfnCertificateTrust);
    FPrintfU(hFile, L"|   |.. pfnFinalPolicy:               0x%p\r\n", pPD->psPfns->pfnFinalPolicy);
    FPrintfU(hFile, L"|   |.. pfnCertCheckPolicy:           0x%p\r\n", pPD->psPfns->pfnCertCheckPolicy);
    FPrintfU(hFile, L"|   |.. pfnTestFinalPolicy:           0x%p\r\n", pPD->psPfns->pfnTestFinalPolicy);

    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPD->psPfns->cbStruct, pfnCleanupPolicy))
    {
        FPrintfU(hFile, L"|   |.. pfnCleanupPolicy:             0x%p\r\n", pPD->psPfns->pfnCleanupPolicy);
    }

    FPrintfU(hFile, L"|   +.. psUIpfns:\r\n");
    if (!(pPD->psPfns->psUIpfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVUI_FUNCS, pPD->psPfns->psUIpfns->cbStruct, pfnOnAdvancedClickDefault)))
    {
        FPrintfU(hFile, L"|       +.. *** invalid parameter ***\r\n");
        return;
    }

    FPrintfU(hFile, L"|       |.. cbStruct:                 %lu\r\n", pPD->psPfns->psUIpfns->cbStruct);
    FPrintfU(hFile, L"|       |.. psUIData:\r\n");

    if (!(pPD->psPfns->psUIpfns->psUIData) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVUI_DATA, pPD->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionTextNotSigned)))
    {
        FPrintfU(hFile, L"|       |   +.. *** invalid parameter ***\r\n");
    }
    else
    {
        FPrintfU(hFile, L"|       |   |.. cbStruct:             %lu\r\n", pPD->psPfns->psUIpfns->psUIData->cbStruct);
        FPrintfU(hFile, L"|       |   |.. dwFinalError:         0x%08.8lx\r\n", pPD->psPfns->psUIpfns->psUIData->dwFinalError);
        FPrintfU(hFile, L"|       |   |.. pYesButtonText:       %s\r\n", pPD->psPfns->psUIpfns->psUIData->pYesButtonText);
        FPrintfU(hFile, L"|       |   |.. pNoButtonText:        %s\r\n", pPD->psPfns->psUIpfns->psUIData->pNoButtonText);
        FPrintfU(hFile, L"|       |   |.. pMoreInfoButtonText:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pMoreInfoButtonText);
        FPrintfU(hFile, L"|       |   |.. pAdvancedLinkText:    %s\r\n", pPD->psPfns->psUIpfns->psUIData->pAdvancedLinkText);
        FPrintfU(hFile, L"|       |   |.. pCopyActionText:      %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionText);
        FPrintfU(hFile, L"|       |   |.. pCopyActionTextNoTS:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS);
        FPrintfU(hFile, L"|       |   |.. pCopyActionTextNotSigned:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned);
    }

    FPrintfU(hFile, L"|       |.. pfnOnMoreInfoClick:       0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnMoreInfoClick);
    FPrintfU(hFile, L"|       |.. pfnOnMoreInfoClickDefault:0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnMoreInfoClickDefault);
    FPrintfU(hFile, L"|       |.. pfnOnAdvancedClick:       0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnAdvancedClick);
    FPrintfU(hFile, L"|       +.. pfnOnAdvancedClickDefault:0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnAdvancedClickDefault);
}

void PrintfSignerStruct(HANDLE hFile, CRYPT_PROVIDER_SGNR *pS, int idxSigner, BOOL fCounter, int idxCounter)
{
    if (!(fCounter))
    {
        FPrintfU(hFile, L"|.. pasSigners[%d]:\r\n", idxSigner);
    }
    else
    {
        FPrintfU(hFile, L"|.. pasSigners[%d] - CounterSigner[%d]:\r\n", idxSigner, idxCounter);
    }

    FPrintfU(hFile, L"|   |.. cbStruct:                     %lu\r\n", pS->cbStruct);

    WCHAR           wszTime[64];
    WCHAR           wszDate[128];



    GetStringDateTime(&pS->sftVerifyAsOf, &wszTime[0], &wszDate[0]);

    FPrintfU(hFile, L"|   |.. sftVerifyAsOf:                %s - %s\r\n", &wszDate[0], &wszTime[0]);
    FPrintfU(hFile, L"|   |.. dwSignerType:                 0x%08.8lX\r\n", pS->dwSignerType);
    FPrintfU(hFile, L"|   |.. csCertChain:                  %lu\r\n", pS->csCertChain);

    CRYPT_PROVIDER_CERT *pCert;

    for (int i = 0; i < (int)pS->csCertChain; i++)
    {
        pCert = WTHelperGetProvCertFromChain(pS, i);

        PrintfCertStruct(hFile, pS->csCertChain, pCert, i);
    }

    FPrintfU(hFile, L"|   |.. psSigner:                     0x%p\r\n", pS->psSigner);
    FPrintfU(hFile, L"|   |.. dwError:                      0x%08.8lx\r\n", pS->dwError);
    FPrintfU(hFile, L"|   +.. csCounterSigners:             %ld\r\n", pS->csCounterSigners);
}

void PrintfCertStruct(HANDLE hFile, int cCert, CRYPT_PROVIDER_CERT *pC, int idxCert)
{
    WCHAR           wszTime[64];
    WCHAR           wszDate[128];

    if (idxCert < (cCert - 1))
    {
        FPrintfU(hFile, L"|   |   |.. casCertChain[%d]:\r\n", idxCert);
    }
    else
    {
        FPrintfU(hFile, L"|   |   +.. casCertChain[%d]:\r\n", idxCert);
    }
    FPrintfU(hFile, L"|   |   |   |.. cbStruct:             %ld\r\n", pC->cbStruct);
    FPrintfU(hFile, L"|   |   |   |.. pCert:                0x%p\r\n", pC->pCert);
    FPrintfU(hFile, L"|   |   |   |   |.. dwCertEncoding:   0x%08.8lx\r\n", pC->pCert->dwCertEncodingType);
    FPrintfU(hFile, L"|   |   |   |   |.. pCertInfo:\r\n");
    FPrintfU(hFile, L"|   |   |   |   |   |.. Issuer:       %s\r\n", GetNameFromBlob(&pC->pCert->pCertInfo->Issuer));

    GetStringDateTime(&pC->pCert->pCertInfo->NotBefore, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|   |   |   |   |   |.. NotBefore:    %s - %s\r\n", &wszDate[0], &wszTime[0]);

    GetStringDateTime(&pC->pCert->pCertInfo->NotAfter, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|   |   |   |   |   |.. NotAfter:     %s - %s\r\n", &wszDate[0], &wszTime[0]);
    FPrintfU(hFile, L"|   |   |   |   |   +.. Subject:      %s\r\n", GetNameFromBlob(&pC->pCert->pCertInfo->Subject));
    FPrintfU(hFile, L"|   |   |   |   +.. hCertStore:       0x%p\r\n", pC->pCert->hCertStore);

    FPrintfU(hFile, L"|   |   |   |.. fCommercial:          %s\r\n", (pC->fCommercial) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fTrustedRoot:         %s\r\n", (pC->fTrustedRoot) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fSelfSigned:          %s\r\n", (pC->fSelfSigned) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fTestCert:            %s\r\n", (pC->fTestCert) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. dwRevokedReason:      0x%08.8lx\r\n", pC->dwRevokedReason);
    FPrintfU(hFile, L"|   |   |   |.. dwConfidence:         0x%08.8lx\r\n", pC->dwConfidence);
    FPrintfU(hFile, L"|   |   |   |.. pTrustListContext:    0x%p\r\n", pC->pTrustListContext);

    if (idxCert == (cCert - 1))
    {
        FPrintfU(hFile, L"|   |   +-- +.. dwError:              0x%08.8lx\r\n", pC->dwError);
    }
    else
    {
        FPrintfU(hFile, L"|   |   |   +.. dwError:              0x%08.8lx\r\n", pC->dwError);
    }
}

void _cdecl FPrintfU(HANDLE hFile, WCHAR *pwszFmt, ...)
{
    va_list     vaArgs;
    WCHAR       wsz[2048];
    char        sz[2048];
    DWORD       cbWritten;
    DWORD       cbConv;

    va_start(vaArgs, pwszFmt);

    vswprintf(&wsz[0], pwszFmt, vaArgs);

    va_end(vaArgs);

    cbConv = 2048;

    cbConv = WideCharToMultiByte(0, 0,
                                &wsz[0], wcslen(&wsz[0]) + 1,
                                &sz[0], cbConv, NULL, NULL);

    sz[cbConv] = NULL;

    cbWritten = 0;

    WriteFile(hFile, &sz[0], cbConv, &cbWritten, NULL);
}


void GetStringDateTime(FILETIME *pFTime, WCHAR *pwszRetTime, WCHAR *pwszRetDate)
{
    SYSTEMTIME      sSysTime;
    char            szTime[128];
    char            szDate[128];

    memset(&sSysTime, 0x00, sizeof(SYSTEMTIME));
    FileTimeToSystemTime(pFTime, &sSysTime);

    szTime[0] = 0;
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT, &sSysTime, NULL, &szTime[0], 64);
    MultiByteToWideChar(CP_ACP, 0, (const char *)&szTime[0], -1, pwszRetTime, 64);

    szDate[0] = 0;
    GetDateFormat(LOCALE_USER_DEFAULT, 0, &sSysTime, TEXT("dd'-'MMM'-'yyyy"), &szDate[0], 128);
    MultiByteToWideChar(CP_ACP, 0, (const char *)&szDate[0], -1, pwszRetDate, 128);

}

WCHAR *GetNameFromBlob(CERT_NAME_BLOB *psNameBlob)
{
    static WCHAR    wsz[256];
    PCERT_NAME_INFO pNameInfo;
    PCERT_RDN_ATTR  pRDNAttr;
    DWORD           cbInfo;

    cbInfo      = 0;
    wsz[0]      = NULL;


    CryptDecodeObject(X509_ASN_ENCODING, X509_NAME, psNameBlob->pbData, psNameBlob->cbData,
                        0, NULL, &cbInfo);
    if (cbInfo > 0)
    {
        if (pNameInfo = (PCERT_NAME_INFO)new BYTE[cbInfo])
        {
            if (CryptDecodeObject(X509_ASN_ENCODING, X509_NAME, psNameBlob->pbData, psNameBlob->cbData,
                                  0, pNameInfo, &cbInfo))
            {
                if (pRDNAttr = CertFindRDNAttr(szOID_COMMON_NAME, pNameInfo))
                {
                    CertRDNValueToStrW(pRDNAttr->dwValueType, &pRDNAttr->Value, wsz, 256);;
                }
            }

            delete pNameInfo;
        }
    }

    return(&wsz[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\sigprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sigprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubLoadSignature
//
//              *** local functions ***
//              _ExtractSigner
//              _ExtractCounterSigners
//              _HandleCertChoice
//              _HandleSignerChoice
//              _FindCertificate
//              _FindCounterSignersCert
//              _IsValidTimeStampCert
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL _ExtractSigner(HCRYPTMSG hMsg, CRYPT_PROVIDER_DATA *pProvData,
                    int idxSigner);
BOOL _ExtractCounterSigners(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner);
HRESULT _HandleCertChoice(CRYPT_PROVIDER_DATA *pProvData);
HRESULT _HandleSignerChoice(CRYPT_PROVIDER_DATA *pProvData);
PCCERT_CONTEXT _FindCertificate(CRYPT_PROVIDER_DATA *pProvData, CERT_INFO *pCert);
PCCERT_CONTEXT _FindCounterSignersCert(CRYPT_PROVIDER_DATA *pProvData, 
                                            CERT_NAME_BLOB *psIssuer,
                                            CRYPT_INTEGER_BLOB *psSerial);
BOOL WINAPI _IsValidTimeStampCert(
    PCCERT_CONTEXT pCertContext,
    BOOL *pfVerisignTimeStampCert
    );

#ifdef CMS_PKCS7
BOOL _VerifyMessageSignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN DWORD dwSignerIndex,
    IN PCCERT_CONTEXT pSigner
    );

BOOL _VerifyCountersignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PBYTE pbSignerInfo,
    IN DWORD cbSignerInfo,
    IN PBYTE pbSignerInfoCountersignature,
    IN DWORD cbSignerInfoCountersignature,
    IN PCCERT_CONTEXT pSigner
    );
#endif  // CMS_PKCS7

HRESULT SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
                    return(_HandleCertChoice(pProvData));

        case WTD_CHOICE_SIGNER:
                    return(_HandleSignerChoice(pProvData));

        case WTD_CHOICE_FILE:
        case WTD_CHOICE_CATALOG:
        case WTD_CHOICE_BLOB:
                    break;

        default:
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
                    return(S_FALSE);
    }

    if (!(pProvData->hMsg))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERCOUNT] = GetLastError();

        return(S_FALSE);
    }

    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState))
    {
        return(S_OK);
    }

    int                 i;
    DWORD               cbSize;
    DWORD               csSigners;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR sSgnr;
    CRYPT_PROVIDER_CERT *pCert;


    cbSize = sizeof(DWORD);

    // signer count
    if (!(CryptMsgGetParam(pProvData->hMsg,
                           CMSG_SIGNER_COUNT_PARAM,
                           0,
                           &csSigners,
                           &cbSize)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERCOUNT] = GetLastError();

        return(S_FALSE);
    }

    if (csSigners == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;

        return(S_FALSE);
    }

    for (i = 0; i < (int)csSigners; i++)
    {
        memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

        sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

        if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, i, &sSgnr)))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);

        if (_ExtractSigner(pProvData->hMsg, pProvData, i))
        {
            memcpy(&pSgnr->sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

            _ExtractCounterSigners(pProvData, i);
        }
    }

    //
    //  verify the integrity of the signature(s)
    //
    for (i = 0; i < (int)pProvData->csSigners; i++)
    {
        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        pCert = WTHelperGetProvCertFromChain(pSgnr, 0);

        if (pSgnr->csCertChain > 0)
        {
#ifdef CMS_PKCS7
            if(!_VerifyMessageSignatureWithChainPubKeyParaInheritance(
                                pProvData,
                                i,
                                pCert->pCert))
#else
            if (!(CryptMsgControl(pProvData->hMsg, 
                                  0,
                                  CMSG_CTRL_VERIFY_SIGNATURE,
                                  pCert->pCert->pCertInfo)))
#endif  // CMS_PKCS7
            {
                if (pSgnr->dwError == 0)
                {
                    pSgnr->dwError = GetLastError();
                }
                
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = TRUST_E_NOSIGNATURE;

                return(S_FALSE);
            }
        }
    }

    return(S_OK);
}


HRESULT _HandleCertChoice(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->pWintrustData->pCert) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CERT_INFO, 
                                          pProvData->pWintrustData->pCert->cbStruct,
                                          pahStores)) ||
        !(pProvData->pWintrustData->pCert->psCertContext))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = ERROR_INVALID_PARAMETER;
        
        return(S_FALSE);
    }

    //
    //  add the stores passed in by the client
    //
    for (int i = 0; i < (int)pProvData->pWintrustData->pCert->chStores; i++)
    {
        if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, 
                                                pProvData->pWintrustData->pCert->pahStores[i])))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }
    }

    //
    //  add a dummy signer
    //
    CRYPT_PROVIDER_SGNR sSgnr;

    memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

    sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    memcpy(&sSgnr.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if ((_ISINSTRUCT(WINTRUST_CERT_INFO, pProvData->pWintrustData->pCert->cbStruct, psftVerifyAsOf)) &&
        (pProvData->pWintrustData->pCert->psftVerifyAsOf))
    {
        memcpy(&sSgnr.sftVerifyAsOf, pProvData->pWintrustData->pCert->psftVerifyAsOf, sizeof(FILETIME));
    }

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, 0, &sSgnr)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }


    //
    //  add the "signer's" cert...
    //
    pProvData->psPfns->pfnAddCert2Chain(pProvData, 0, FALSE, 0, 
                                        pProvData->pWintrustData->pCert->psCertContext);

    return(ERROR_SUCCESS);

}

HRESULT _HandleSignerChoice(CRYPT_PROVIDER_DATA *pProvData)
{

    if (!(pProvData->pWintrustData->pSgnr) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_SGNR_INFO, 
                                          pProvData->pWintrustData->pSgnr->cbStruct,
                                          pahStores)) ||
        !(pProvData->pWintrustData->pSgnr->psSignerInfo))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = ERROR_INVALID_PARAMETER;
        
        return(S_FALSE);
    }

    int     i;

    if (1 < pProvData->pWintrustData->pCert->chStores &&
            0 == pProvData->chStores) 
        WTHelperOpenKnownStores(pProvData);

    //
    //  add the stores passed in by the client
    //
    for (i = 0; i < (int)pProvData->pWintrustData->pCert->chStores; i++)
    {
        if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, 
                                                pProvData->pWintrustData->pCert->pahStores[i])))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }
    }

    CRYPT_PROVIDER_SGNR sSgnr;
    CRYPT_PROVIDER_SGNR *pSgnr;

    memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

    sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    if (!(sSgnr.psSigner = (CMSG_SIGNER_INFO *)pProvData->psPfns->pfnAlloc(sizeof(CMSG_SIGNER_INFO))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }

    memcpy(sSgnr.psSigner, pProvData->pWintrustData->pSgnr->psSignerInfo, 
                sizeof(CMSG_SIGNER_INFO));

    memcpy(&sSgnr.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, 0, &sSgnr)))
    {
        pProvData->psPfns->pfnFree(sSgnr.psSigner);

        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }

    if (!(pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = GetLastError();
        return(S_FALSE);
    }

    CERT_INFO       sCert;
    PCCERT_CONTEXT  pCertContext;

    memset(&sCert, 0x00, sizeof(CERT_INFO));

    sCert.Issuer.cbData         = pSgnr->psSigner->Issuer.cbData;
    sCert.Issuer.pbData         = pSgnr->psSigner->Issuer.pbData;

    sCert.SerialNumber.cbData   = pSgnr->psSigner->SerialNumber.cbData;
    sCert.SerialNumber.pbData   = pSgnr->psSigner->SerialNumber.pbData;

    if (!(pCertContext = _FindCertificate(pProvData, &sCert)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        return(FALSE);
    }

    pProvData->psPfns->pfnAddCert2Chain(pProvData, 0, FALSE, 0, pCertContext);

    _ExtractCounterSigners(pProvData, 0);

    return(ERROR_SUCCESS);
}

BOOL _ExtractSigner(HCRYPTMSG hMsg, CRYPT_PROVIDER_DATA *pProvData, int idxSigner)
{
    DWORD               cb;
    BYTE                *pb;
    CRYPT_PROVIDER_SGNR *pSgnr;
    PCCERT_CONTEXT      pCertContext;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, FALSE, 0);
    if (pSgnr == NULL)
    {
        return(FALSE);
    }

    //
    //  signer info
    //
    cb = 0;

    CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, idxSigner, NULL, &cb);

    if (cb == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    if (!(pSgnr->psSigner = (CMSG_SIGNER_INFO *)pProvData->psPfns->pfnAlloc(cb)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    memset(pSgnr->psSigner, 0x00, cb);

    if (!(CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, idxSigner, pSgnr->psSigner, &cb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    //
    //  cert info
    //
    cb = 0;

    CryptMsgGetParam(hMsg, CMSG_SIGNER_CERT_INFO_PARAM, idxSigner, NULL, &cb);

    if (cb == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cb)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    memset(pb, 0x00, cb);

    if (!(CryptMsgGetParam(hMsg, CMSG_SIGNER_CERT_INFO_PARAM, idxSigner, pb, &cb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();

        pProvData->psPfns->pfnFree(pb);

        return(FALSE);
    }

    if (!(pCertContext = _FindCertificate(pProvData, (CERT_INFO *)pb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->psPfns->pfnFree(pb);
        return(FALSE);
    }

    pProvData->psPfns->pfnFree(pb);

    pProvData->psPfns->pfnAddCert2Chain(pProvData, idxSigner, FALSE, 0, pCertContext);

    CertFreeCertificateContext(pCertContext);

    return(TRUE);
}

BOOL _ExtractCounterSigners(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner)
{
    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState))
    {
        return(TRUE);
    }

    CRYPT_ATTRIBUTE     *pAttr;
    PCCERT_CONTEXT      pCertContext;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR sCS;
    CRYPT_PROVIDER_SGNR *pCS;
    CRYPT_PROVIDER_CERT *pCert;
    DWORD               cbSize;
    BOOL                fVerisignTimeStampCert = FALSE;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, FALSE, 0);
    if (pSgnr == NULL)
    {
        return(FALSE);
    }

    //
    //  counter signers are stored in the UN-authenticated attributes of the
    //  signer.
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pSgnr->psSigner->UnauthAttrs.cAttr,
                                   pSgnr->psSigner->UnauthAttrs.rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        return(FALSE);
    }


    memset(&sCS, 0x00, sizeof(CRYPT_PROVIDER_SGNR));
    sCS.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    memcpy(&sCS.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, TRUE, idxSigner, &sCS)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    pCS = WTHelperGetProvSignerFromChain(pProvData, idxSigner, TRUE, pSgnr->csCounterSigners - 1);

    // Crack the encoded signer

    if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pCS->psSigner, &cbSize, 1024,
                      pProvData->dwEncoding, PKCS7_SIGNER_INFO, pAttr->rgValue[0].pbData, pAttr->rgValue[0].cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
        pCS->dwError = GetLastError();
        return(FALSE);
    }

    //
    //  counter signers cert
    //

    if (!(pCertContext = _FindCounterSignersCert(pProvData, 
                                                 &pCS->psSigner->Issuer,
                                                 &pCS->psSigner->SerialNumber)))
    {
        pCS->dwError = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGCERT] = GetLastError();
        return(FALSE);
    }


    pProvData->psPfns->pfnAddCert2Chain(pProvData, idxSigner, TRUE, 
                                      pProvData->pasSigners[idxSigner].csCounterSigners - 1, 
                                      pCertContext);

    CertFreeCertificateContext(pCertContext);

    pCert           = WTHelperGetProvCertFromChain(pCS, pCS->csCertChain - 1);
    pCertContext    = pCert->pCert;

    {
        //
        // Verify the counter's signature
        //

        BYTE *pbEncodedSigner = NULL;
        DWORD cbEncodedSigner;
        BOOL fResult;

        // First need to re-encode the Signer.
        fResult = CryptEncodeObjectEx(
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pSgnr->psSigner,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) &pbEncodedSigner,
            &cbEncodedSigner
            );

        if (fResult)
#ifdef CMS_PKCS7
            fResult = _VerifyCountersignatureWithChainPubKeyParaInheritance(
                                pProvData,
                                pbEncodedSigner,
                                cbEncodedSigner,
                                pAttr->rgValue[0].pbData,
                                pAttr->rgValue[0].cbData,
                                pCertContext
                                );
#else
            fResult = CryptMsgVerifyCountersignatureEncoded(
                                NULL,   //HCRYPTPROV
                                PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                                pbEncodedSigner,
                                cbEncodedSigner,
                                pAttr->rgValue[0].pbData,
                                pAttr->rgValue[0].cbData,
                                pCertContext->pCertInfo
                                );
#endif  // CMS_PKCS7
        if (pbEncodedSigner)
            LocalFree((HLOCAL) pbEncodedSigner);

        if (!fResult)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
            pCS->dwError = GetLastError();
            return(FALSE);
        }
    }

    //
    // see if the counter signer is a TimeStamp.
    //
    if (!(_IsValidTimeStampCert(pCertContext, &fVerisignTimeStampCert)))
    {
        return(TRUE);
    }

    // get the time
    if (!(pAttr = CertFindAttribute(szOID_RSA_signingTime, 
                                   pCS->psSigner->AuthAttrs.cAttr,
                                   pCS->psSigner->AuthAttrs.rgAttr)))
    {
        //
        //  not a time stamp...
        //
        return(TRUE);
    }

    //
    // the time stamp counter signature must have 1 value!
    //
    if (pAttr->cValue <= 0) 
    {
        //
        //  not a time stamp...
        //
        return(TRUE);
    }

    //
    // Crack the time stamp and get the file time.
    //
    FILETIME        ftHold;

    cbSize = sizeof(FILETIME);

    CryptDecodeObject(pProvData->dwEncoding, 
                      PKCS_UTC_TIME,
                      pAttr->rgValue[0].pbData, 
                      pAttr->rgValue[0].cbData,
                      0, 
                      &ftHold, 
                      &cbSize);

    if (cbSize == 0)
    {
        pCS->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_TIME_STAMP;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
        return(FALSE);
    }
        

    //
    //  set the signer's verify date to the date in the time stamp!
    //
    memcpy(&pSgnr->sftVerifyAsOf, &ftHold, sizeof(FILETIME));

    // On 12-January-99 Keithv gave me the orders to change the
    // countersigning to use the current time
    //
    // On 25-January-99 backed out the above change
    //
    // On 28-August-99 changed to use the current time for all
    // countersigners excluding the first Verisign Time Stamp
    // certificate
    //
    // On 12-January-00 added a second Verisign Time Stamp cert to exclude
    //
    // On 05-April-01 changed back to W2K semantics. A time stamp chain
    // never expires.
    //
    memcpy(&pCS->sftVerifyAsOf, &ftHold, sizeof(FILETIME));
    

    pCS->dwSignerType |= SGNR_TYPE_TIMESTAMP;

    return(TRUE);
}

PCCERT_CONTEXT _FindCertificate(CRYPT_PROVIDER_DATA *pProvData, CERT_INFO *pCert)
{
    PCCERT_CONTEXT pCertContext;
    DWORD i;

    if (!(pCert))
    {
        return(NULL);
    }

    for (i = 0; i < pProvData->chStores; i++)
    {
        if (pCertContext = CertGetSubjectCertificateFromStore(pProvData->pahStores[i],
                                                                            pProvData->dwEncoding,
                                                                            pCert))
        {
            return(pCertContext);
        }
    }

    if (1 >= pProvData->chStores) {
        DWORD cOrig = pProvData->chStores;

        WTHelperOpenKnownStores(pProvData);
        for (i = cOrig; i < pProvData->chStores; i++) {
            if (pCertContext = CertGetSubjectCertificateFromStore(
                    pProvData->pahStores[i],
                    pProvData->dwEncoding,
                    pCert))
                return (pCertContext);
        }
    }

    return(NULL);
}

PCCERT_CONTEXT _FindCounterSignersCert(CRYPT_PROVIDER_DATA *pProvData, 
                                            CERT_NAME_BLOB *psIssuer,
                                            CRYPT_INTEGER_BLOB *psSerial)
{
    CERT_INFO       sCert;
    PCCERT_CONTEXT  pCertContext;
    DWORD           i;

    memset(&sCert, 0x00, sizeof(CERT_INFO));

    sCert.Issuer        = *psIssuer;
    sCert.SerialNumber  = *psSerial;

    for (i = 0; i < pProvData->chStores; i++)
    {
        if (pCertContext = CertGetSubjectCertificateFromStore(pProvData->pahStores[i],
                                                                            pProvData->dwEncoding,
                                                                            &sCert))
        {
            return(pCertContext);
        }
    }

    if (1 >= pProvData->chStores) {
        DWORD cOrig = pProvData->chStores;

        WTHelperOpenKnownStores(pProvData);
        for (i = cOrig; i < pProvData->chStores; i++) {
            if (pCertContext = CertGetSubjectCertificateFromStore(
                    pProvData->pahStores[i],
                    pProvData->dwEncoding,
                    &sCert))
                return (pCertContext);
        }
    }

    return(NULL);
}

#define SH1_HASH_LENGTH     20

BOOL WINAPI _IsValidTimeStampCert(
    PCCERT_CONTEXT pCertContext,
    BOOL *pfVerisignTimeStampCert
    )
{
    DWORD               cbSize;
    PCERT_ENHKEY_USAGE  pCertEKU;
    BYTE                baSignersThumbPrint[SH1_HASH_LENGTH];
    static BYTE         baVerisignTimeStampThumbPrint[SH1_HASH_LENGTH] =
                            { 0x38, 0x73, 0xB6, 0x99, 0xF3, 0x5B, 0x9C, 0xCC, 0x36, 0x62,
                              0xB6, 0x48, 0x3A, 0x96, 0xBD, 0x6E, 0xEC, 0x97, 0xCF, 0xB7 };

    static BYTE         baVerisignTimeStampThumbPrint2[SH1_HASH_LENGTH] = {
        0x9A, 0x3F, 0xF0, 0x5B, 0x42, 0x88, 0x52, 0x64,
        0x84, 0xA9, 0xFC, 0xB8, 0xBC, 0x14, 0x7D, 0x53,
        0xE1, 0x5A, 0x43, 0xBB
    };

    cbSize = SH1_HASH_LENGTH;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                                          &baSignersThumbPrint[0], &cbSize)))
    {
        return(FALSE);
    }

    //
    //  1st, check to see if it's Verisign's first timestamp certificate.  This one did NOT
    //  have the enhanced key usage in it.
    //
    //  12-January-00
    //  Also, check for the second Verisign timestamp certificate. Its only
    //  valid for 5 years. Will grandfather in to be valid forever.
    //
    if (memcmp(&baSignersThumbPrint[0], &baVerisignTimeStampThumbPrint[0],
            SH1_HASH_LENGTH) == 0
                    ||
        memcmp(&baSignersThumbPrint[0], &baVerisignTimeStampThumbPrint2[0],
            SH1_HASH_LENGTH) == 0)
    {
        *pfVerisignTimeStampCert = TRUE;
        return(TRUE);
    }
    else
    {
        *pfVerisignTimeStampCert = FALSE;
    }

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    CertGetEnhancedKeyUsage(pCertContext, 
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize);

    if (cbSize == 0)
    {
        return(FALSE);
    }
                      
    if (!(pCertEKU = (PCERT_ENHKEY_USAGE)new BYTE[cbSize]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
    {
        delete pCertEKU;
        return(FALSE);
    }

    for (int i = 0; i < (int)pCertEKU->cUsageIdentifier; i++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_KP_TIME_STAMP_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }

        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_PKIX_KP_TIMESTAMP_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }
    }

    delete pCertEKU;

    return(FALSE);
}

#ifdef CMS_PKCS7

void _BuildChainForPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PCCERT_CONTEXT pSigner
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore;

    if (0 == pProvData->chStores)
        hAdditionalStore = NULL;
    else if (1 < pProvData->chStores) {
        if (hAdditionalStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hAdditionalStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
    } else
        hAdditionalStore = CertDuplicateStore(pProvData->pahStores[0]);

    // Build a chain. Hopefully, the signer inherit's its public key
    // parameters from up the chain

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (CertGetCertificateChain(
            NULL,                   // hChainEngine
            pSigner,
            NULL,                   // pTime
            hAdditionalStore,
            &ChainPara,
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            NULL,                   // pvReserved
            &pChainContext
            ))
        CertFreeCertificateChain(pChainContext);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
}

//+-------------------------------------------------------------------------
//  If the verify signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the signer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
BOOL _VerifyMessageSignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN DWORD dwSignerIndex,
    IN PCCERT_CONTEXT pSigner
    )
{
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

    memset(&CtrlPara, 0, sizeof(CtrlPara));
    CtrlPara.cbSize = sizeof(CtrlPara);
    // CtrlPara.hCryptProv =
    CtrlPara.dwSignerIndex = dwSignerIndex;
    CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
    CtrlPara.pvSigner = (void *) pSigner;

    if (CryptMsgControl(
            pProvData->hMsg, 
            0,                              // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &CtrlPara
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        _BuildChainForPubKeyParaInheritance(pProvData, pSigner);

        // Try again. Hopefully the above chain building updated the signer's
        // context property with the missing public key parameters
        return CryptMsgControl(
            pProvData->hMsg, 
            0,                              // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &CtrlPara
            );
    }
}

//+-------------------------------------------------------------------------
//  If the verify counter signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the signer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
BOOL _VerifyCountersignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PBYTE pbSignerInfo,
    IN DWORD cbSignerInfo,
    IN PBYTE pbSignerInfoCountersignature,
    IN DWORD cbSignerInfoCountersignature,
    IN PCCERT_CONTEXT pSigner
    )
{
    if (CryptMsgVerifyCountersignatureEncodedEx(
            0,                                      // hCryptProv
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            CMSG_VERIFY_SIGNER_CERT,
            (void *) pSigner,
            0,                                      // dwFlags
            NULL                                    // pvReserved
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        _BuildChainForPubKeyParaInheritance(pProvData, pSigner);

        // Try again. Hopefully the above chain building updated the signer's
        // context property with the missing public key parameters
        return CryptMsgVerifyCountersignatureEncodedEx(
                0,                                      // hCryptProv
                PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                pbSignerInfo,
                cbSignerInfo,
                pbSignerInfoCountersignature,
                cbSignerInfoCountersignature,
                CMSG_VERIFY_SIGNER_CERT,
                (void *) pSigner,
                0,                                      // dwFlags
                NULL                                    // pvReserved
                );
    }
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\hshstrss\hshstrss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hshstrss.cpp
//
//  Contents:   Hashing Stress
//
//  History:    21-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "crypthlp.h"


BOOL _HashFile(HANDLE hFile, HCRYPTPROV hProv, char *pszFile);

BOOL    fVerbose        = FALSE;
DWORD   dwTotalBytes    = 0;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    WCHAR                   *pwszFile;
    BOOL                    fFailed;
    DWORD                   dwTotal;
    HANDLE                  hFile;
    int                     iRet;

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    HCRYPTPROV              hProv;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    iRet                = 1;    // cmd fail
    dwTotal             = 0;
    hFind               = INVALID_HANDLE_VALUE;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());

        goto NeededHelp;
    }

    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    //
    //  start our timer
    //
    tStart              = COleDateTime::GetCurrentTime();

    if (fVerbose)
    {
        printf("\nProcessing:");
    }

    char    szFile[MAX_PATH];

    szFile[0] = NULL;
    WideCharToMultiByte(0, 0, pwszFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

    if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
    {
        goto FileFindError;
    }

    fFind   = TRUE;

    hProv = I_CryptGetDefaultCryptProv(0);

    while (fFind)
    {
        if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            hFile = CreateFile(sFindData.cFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (_HashFile(hFile, hProv, sFindData.cFileName))
                {
                    dwTotal++;
                }
            }
        }

        fFind = FindNextFile(hFind, &sFindData);
    }

    //
    //  end timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTiming:");
    printf("\nTotal files:                  %ld", dwTotal);
    printf("\nProcessing time:              %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage per file:             %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\nTotal bytes:                  %ld (k)", dwTotalBytes / 1000L);
    printf("\nAverage per (k):              %f", (double)tsTotal.GetTotalSeconds() / (double)(dwTotalBytes / 1000L));
    printf("\nAverage bytes per file (k):   %f", (double)(dwTotalBytes / 1000L) / (double)dwTotal);
    printf("\n");

    iRet = 0;

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}


BOOL _HashFile(HANDLE hFile, HCRYPTPROV hProv, char *pszFile)
{
    HCRYPTHASH  hHash;
    DWORD       cbHash;
    BYTE        bHash[30];
    BYTE        *pbFile;
    DWORD       cbFile;
    HANDLE      hMappedFile;
    BOOL        fRet;

    pbFile      = NULL;
    hMappedFile = NULL;
    hHash       = NULL;

    if (fVerbose)
    {
        printf("\n   %s   ", pszFile);
    }

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        hMappedFile = NULL;
        goto CreateMapError;
    }

    if (!(pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0)))
    {
        goto MapViewError;
    }

    cbFile = GetFileSize(hFile, NULL);

    if (!(CryptCreateHash(hProv, CALG_SHA1, NULL, 0, &hHash)))
    {
        goto CreateHashError;
    }

    if (!(CryptHashData(hHash, pbFile, cbFile, 0)))
    {
        goto HashDataError;
    }

    cbHash = 30;

    if (!(CryptGetHashParam(hHash, HP_HASHVAL, bHash, &cbHash, 0)))
    {
        goto HashParamError;
    }

    dwTotalBytes += cbFile;

    if (fVerbose)
    {
        DWORD   i;

        for (i = 0; i < cbHash; i++)
        {
            printf("%02.2X", bHash[i]);
        }
    }

    fRet = TRUE;

CommonReturn:

    if (hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (hMappedFile)
    {
        CloseHandle(hMappedFile);
    }

    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

    return(fRet);

ErrorReturn:
    if (fVerbose)
    {
        printf("*failed*");
    }

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, CreateMapError);
    TRACE_ERROR_EX(DBG_SS_APP, MapViewError);
    TRACE_ERROR_EX(DBG_SS_APP, CreateHashError);
    TRACE_ERROR_EX(DBG_SS_APP, HashDataError);
    TRACE_ERROR_EX(DBG_SS_APP, HashParamError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\sphelper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sphelper.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  spGetAgencyNameOfCert
//              spGetAgencyNameOfCert
//              spGetPublisherNameOfCert
//              spGetCommonNameExtension
//              spGetAgencyName
//              spGetRDNAttrWStr
//
//  History:    05-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


WCHAR *spGetAgencyNameOfCert(PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz;

    if (pwsz = spGetCommonNameExtension(pCert))
    {
        return(pwsz);
    }
    return(spGetAgencyName(&pCert->pCertInfo->Subject));
}

WCHAR *spGetPublisherNameOfCert(IN PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz;

    if (pwsz = spGetCommonNameExtension(pCert))
    {
        return(pwsz);
    }

    return(spGetRDNAttrWStr(szOID_COMMON_NAME, &pCert->pCertInfo->Subject));
}


WCHAR *spGetCommonNameExtension(PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz = NULL;
    PCERT_NAME_VALUE pNameValue = NULL;
    PCERT_EXTENSION pExt;

    pwsz        = NULL;
    pNameValue  = NULL;

    pExt = CertFindExtension(SPC_COMMON_NAME_OBJID,
                             pCert->pCertInfo->cExtension,
                             pCert->pCertInfo->rgExtension);
    if (pExt) 
    {
        DWORD                   cbInfo;
        PCERT_RDN_VALUE_BLOB    pValue;
        DWORD                   dwValueType;
        DWORD                   cwsz;

        cbInfo  = 0;

        CryptDecodeObject(  X509_ASN_ENCODING,
                            X509_NAME_VALUE,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            0,
                            NULL,
                            &cbInfo);

        if (cbInfo == 0)
        {
            return(NULL);
        }

        if (!(pNameValue = (PCERT_NAME_VALUE)new BYTE[cbInfo]))
        {
            return(NULL);
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                X509_NAME_VALUE,
                                pExt->Value.pbData,
                                pExt->Value.cbData,
                                0,
                                pNameValue,
                                &cbInfo)))
        {
            delete pNameValue;
            return(NULL);
        }

        dwValueType = pNameValue->dwValueType;
        pValue      = &pNameValue->Value;

        cwsz = CertRDNValueToStrW(dwValueType,
                                  pValue,
                                  NULL,
                                  0);
        if (cwsz > 1) 
        {
            pwsz = new WCHAR[cwsz];
            if (pwsz)
            {
                CertRDNValueToStrW(dwValueType,
                                   pValue,
                                   pwsz,
                                   cwsz);
            }
        }
    }

    delete pNameValue;

    return(pwsz);
}

WCHAR *spGetAgencyName(IN PCERT_NAME_BLOB pNameBlob)
{
    LPWSTR pwsz;

    if (pwsz = spGetRDNAttrWStr(szOID_ORGANIZATIONAL_UNIT_NAME, pNameBlob))
    {
        return(pwsz);
    }

    if (pwsz = spGetRDNAttrWStr(szOID_ORGANIZATION_NAME, pNameBlob))
    {
        return(pwsz);
    }

    return(spGetRDNAttrWStr(szOID_COMMON_NAME, pNameBlob));
}

WCHAR *spGetRDNAttrWStr(IN LPCSTR pszObjId, IN PCERT_NAME_BLOB pNameBlob)
{
    LPWSTR          pwsz;
    PCERT_NAME_INFO pNameInfo;
    PCERT_RDN_ATTR  pRDNAttr;
    DWORD           cbInfo;

    pwsz        = NULL;
    pNameInfo   = NULL;

    cbInfo      = 0;

    CryptDecodeObject(  X509_ASN_ENCODING,
                        X509_NAME,
                        pNameBlob->pbData,
                        pNameBlob->cbData,
                        0,
                        NULL,
                        &cbInfo);
    
    if (cbInfo == 0) 
    {
        return(NULL);
    }

    if (!(pNameInfo = (PCERT_NAME_INFO)new BYTE[cbInfo]))
    {
        return(NULL);
    }

    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                            X509_NAME,
                            pNameBlob->pbData,
                            pNameBlob->cbData,
                            0,
                            pNameInfo,
                            &cbInfo)))
    {
        delete pNameInfo;
        return(NULL);
    }

    pRDNAttr = CertFindRDNAttr(pszObjId, pNameInfo);

    if (pRDNAttr) 
    {
        PCERT_RDN_VALUE_BLOB    pValue = &pRDNAttr->Value;
        DWORD                   dwValueType = pRDNAttr->dwValueType;
        DWORD                   cwsz;

        pValue      = &pRDNAttr->Value;
        dwValueType = pRDNAttr->dwValueType;

        cwsz = CertRDNValueToStrW(dwValueType,
                                  pValue,
                                  NULL,
                                  0);

        if (cwsz > 1) 
        {
            pwsz = new WCHAR[cwsz];
            if (pwsz)
            {
                CertRDNValueToStrW(dwValueType,
                                   pValue,
                                   pwsz,
                                   cwsz);
            }
        }
    }

    delete pNameInfo;

    return(pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\trustdb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdb.cpp
//
//--------------------------------------------------------------------------

//
// PersonalTrustDb.cpp
//
// Code that maintains a list of trusted publishers, agencies, and so on.

#include    "global.hxx"
#include    "cryptreg.h"
#include    "trustdb.h"

/////////////////////////////////////////////////////////

DECLARE_INTERFACE (IUnkInner)
    {
    STDMETHOD(InnerQueryInterface) (THIS_ REFIID iid, LPVOID* ppv) PURE;
    STDMETHOD_ (ULONG, InnerAddRef) (THIS) PURE;
    STDMETHOD_ (ULONG, InnerRelease) (THIS) PURE;
    };

/////////////////////////////////////////////////////////


extern "C" const GUID IID_IPersonalTrustDB = IID_IPersonalTrustDB_Data;

/////////////////////////////////////////////////////////

HRESULT WINAPI OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);

class CTrustDB : IPersonalTrustDB, IUnkInner
    {
        LONG        m_refs;             // our reference count
        IUnknown*   m_punkOuter;        // our controlling unknown (may be us ourselves)

        HCERTSTORE  m_hPubStore;        // publisher store

public:
    static HRESULT CreateInstance(IUnknown* punkOuter, REFIID iid, void** ppv);

private:
    STDMETHODIMP         QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef(THIS);
    STDMETHODIMP_(ULONG) Release(THIS);

    STDMETHODIMP         InnerQueryInterface(REFIID iid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) InnerAddRef();
    STDMETHODIMP_(ULONG) InnerRelease();

    STDMETHODIMP         IsTrustedCert(DWORD dwEncodingType, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert);
    STDMETHODIMP         AddTrustCert(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo);

    STDMETHODIMP         RemoveTrustCert(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo);
    STDMETHODIMP         RemoveTrustToken(LPWSTR,           LONG iLevel, BOOL fLowerLevelsToo);

    STDMETHODIMP         AreCommercialPublishersTrusted();
    STDMETHODIMP         SetCommercialPublishersTrust(BOOL fTrust);

    STDMETHODIMP         GetTrustList(
                            LONG                iLevel,             // the cert chain level to get
                            BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
                            TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
                            ULONG*              pcTrustList         // place to return the size of the returned trust list
                            );
private:
                        CTrustDB(IUnknown* punkOuter);
                        ~CTrustDB();
    HRESULT             Init();

    };


// Helper functions

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20
#define SHA1_HASH_LEN               20

// Null terminated ascii hex characters of the hash.
#define MAX_HASH_NAME_LEN           (2 * MAX_HASH_LEN + 1)

PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LEN != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL IsCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppOtherCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert)) {
        if (ppOtherCert)
            *ppOtherCert = pOtherCert;
        else
            CertFreeCertificateContext(pOtherCert);
        return TRUE;
    } else {
        if (ppOtherCert)
            *ppOtherCert = NULL;
        return FALSE;
    }
}

BOOL DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        fResult = CertDeleteCertificateFromStore(pOtherCert);
    else
        fResult = FALSE;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the UNICODE ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
void WStrToBytes(
    IN const WCHAR wsz[MAX_HASH_NAME_LEN],
    OUT BYTE rgb[MAX_HASH_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    LPCWSTR pwsz = wsz;
    WCHAR wch;

    while (cb < MAX_HASH_LEN && (wch = *pwsz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (wch >= L'0' && wch <= L'9')
            b = (BYTE) (wch - L'0');
        else if (wch >= L'a' && wch <= L'f')
            b = (BYTE) (10 + wch - L'a');
        else if (wch >= L'A' && wch <= L'F')
            b = (BYTE) (10 + wch - L'A');
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = b << 4;
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = rgb[cb] | b;
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}




/////////////////////////////////////////////////////////////////////////////

HRESULT CTrustDB::IsTrustedCert(DWORD dwEncodingType,
                                PCCERT_CONTEXT pCert,
                                LONG iLevel,
                                BOOL fCommercial,
                                PCCERT_CONTEXT *ppPubCert
                                )
{
    HRESULT hr;


    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    // See if the cert is in the trusted publisher store
    if (IsCertificateInOtherStore(m_hPubStore, pCert, ppPubCert))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CTrustDB::AddTrustCert(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;

    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    if (CertAddCertificateContextToStore(
            m_hPubStore,
            pCert,
            CERT_STORE_ADD_USE_EXISTING,
            NULL
            ))
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT CTrustDB::RemoveTrustCert(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;

    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    CertDuplicateCertificateContext(pCert);
    if (DeleteCertificateFromOtherStore(
            m_hPubStore,
            pCert
            ))
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT CTrustDB::RemoveTrustToken(LPWSTR szToken, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    PCCERT_CONTEXT pDeleteCert;


    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    WStrToBytes(szToken, rgbHash, &cbHash);
    HashBlob.pbData = rgbHash;
    HashBlob.cbData = cbHash;
    pDeleteCert = CertFindCertificateInStore(
            m_hPubStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
    if (NULL == pDeleteCert)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (CertDeleteCertificateFromStore(pDeleteCert))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


HRESULT CTrustDB::AreCommercialPublishersTrusted()
// Answer whether commercial publishers are trusted.
//      S_OK == yes
//      S_FALSE == no
//      other == can't tell
    {
        return( S_FALSE );
    }

HRESULT CTrustDB::SetCommercialPublishersTrust(BOOL fTrust)
// Set the commercial trust setting
    {
        return( S_OK );
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT CTrustDB::GetTrustList(
// Return the (unsorted) list of trusted certificate names and their
// corresponding display names
//
    LONG                iLevel,             // the cert chain level to get
    BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
    TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
    ULONG*              pcTrustList         // place to return the size of the returned trust list
    ) {
    HRESULT hr = S_OK;
    ULONG cTrust = 0;
    ULONG cAllocTrust = 0;
    TRUSTLISTENTRY* rgTrustList = NULL;
    PCCERT_CONTEXT pCert = NULL;


    *prgTrustList = NULL;
    *pcTrustList  = 0;

    if (NULL == m_hPubStore)
    {
        return S_OK;
    }

    // Get count of trusted publisher certs
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(m_hPubStore, pCert))
    {
        cTrust++;
    }

    if (0 == cTrust)
    {
        return S_OK;
    }

    

    rgTrustList = (TRUSTLISTENTRY*) CoTaskMemAlloc(cTrust *
        sizeof(TRUSTLISTENTRY));

    if (NULL == rgTrustList)
    {
        return E_OUTOFMEMORY;
    }

    memset(rgTrustList, 0, cTrust * sizeof(TRUSTLISTENTRY));

    cAllocTrust = cTrust;
    cTrust = 0;
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(m_hPubStore, pCert))
    {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the thumbprint
        if(!CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash))
        {
            continue;
        }

        // convert to a string
        BytesToWStr(cbHash, rgbHash, rgTrustList[cTrust].szToken);

        if (1 >= CertGetNameStringW(
                pCert,
                CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                0,                                  // dwFlags
                NULL,                               // pvTypePara
                rgTrustList[cTrust].szDisplayName,
                sizeof(rgTrustList[cTrust].szDisplayName)/sizeof(WCHAR)
                ))
        {
            continue;
        }

        cTrust++;
        if (cTrust >= cAllocTrust)
        {
            CertFreeCertificateContext(pCert);
            break;
        }
    }

    if (0 == cTrust)
    {
        CoTaskMemFree(rgTrustList);
        rgTrustList = NULL;
    }

    *pcTrustList = cTrust;
    *prgTrustList = rgTrustList;
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CTrustDB::QueryInterface(REFIID iid, LPVOID* ppv)
    {
    return (m_punkOuter->QueryInterface(iid, ppv));
    }
STDMETHODIMP_(ULONG) CTrustDB::AddRef(void)
    {
    return (m_punkOuter->AddRef());
    }
STDMETHODIMP_(ULONG) CTrustDB::Release(void)
    {
    return (m_punkOuter->Release());
    }

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CTrustDB::InnerQueryInterface(REFIID iid, LPVOID* ppv)
    {
    *ppv = NULL;
    while (TRUE)
        {
        if (iid == IID_IUnknown)
            {
            *ppv = (LPVOID)((IUnkInner*)this);
            break;
            }
        if (iid == IID_IPersonalTrustDB)
            {
            *ppv = (LPVOID) ((IPersonalTrustDB *) this);
            break;
            }
        return E_NOINTERFACE;
        }
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
    }
STDMETHODIMP_(ULONG) CTrustDB::InnerAddRef(void)
    {
    return ++m_refs;
    }
STDMETHODIMP_(ULONG) CTrustDB::InnerRelease(void)
    {
    ULONG refs = --m_refs;
    if (refs == 0)
        {
        m_refs = 1;
        delete this;
        }
    return refs;
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv)
    {
    return CTrustDB::CreateInstance(punkOuter, iid, ppv);
    }

HRESULT CTrustDB::CreateInstance(IUnknown* punkOuter, REFIID iid, void** ppv)
    {
    HRESULT hr;

    *ppv = NULL;
    CTrustDB* pnew = new CTrustDB(punkOuter);
    if (pnew == NULL) return E_OUTOFMEMORY;
    if ((hr = pnew->Init()) != S_OK)
        {
        delete pnew;
        return hr;
        }
    IUnkInner* pme = (IUnkInner*)pnew;
    hr = pme->InnerQueryInterface(iid, ppv);
    pme->InnerRelease();                // balance starting ref cnt of one
    return hr;
    }

CTrustDB::CTrustDB(IUnknown* punkOuter) :
        m_refs(1),
        m_hPubStore(NULL)
    {
    if (punkOuter == NULL)
        m_punkOuter = (IUnknown *) ((LPVOID) ((IUnkInner *) this));
    else
        m_punkOuter = punkOuter;
    }

CTrustDB::~CTrustDB()
    {
    if (m_hPubStore)
        CertCloseStore(m_hPubStore, 0);
    }

HRESULT CTrustDB::Init()
{
    m_hPubStore = OpenTrustedPublisherStore();

    if (NULL == m_hPubStore)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\hshstrss\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hshstrss.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_MODINF                11
#define IDS_PARAMTEXT_MODINF            12
#define IDS_PARAM_VSTRING               13
#define IDS_PARAMTEXT_VSTRING           14
#define IDS_PARAM_INFTAGCHKSTRING       15
#define IDS_PARAMTEXT_INFTAGCHKSTRING   16
#define IDS_PARAM_COUNT                 17
#define IDS_PARAMTEXT_COUNT             18
#define IDS_PARAM_TESTCAT               19
#define IDS_PARAMTEXT_TESTCAT           20
#define IDS_PARAM_TESTDRIVER            21
#define IDS_PARAMTEXT_TESTDRIVER        22
#define IDS_PARAM_TESTCERT              23
#define IDS_PARAMTEXT_TESTCERT          24
#define IDS_PARAM_CATPREPATH            25
#define IDS_PARAMTEXT_CATPREPATH        26

#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\trustdb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdb.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    WCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    WCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
    {
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // Answer whether the indicated certificate is trusted at the 
    // indicated level of the certificate chain.
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    //

    STDMETHOD(IsTrustedCert)(DWORD dwEncoding, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert) PURE;

    //
    // Add the given certificate to the trust data base
    //
    STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Remove the given certificate from the trust data base
    //
    STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPWSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

    };

//
// Creation function for default implementation
//
HRESULT WINAPI OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\softpub\trustdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdlg.cpp
//
//--------------------------------------------------------------------------

//
// PersonalTrustDialog.cpp
//
// Implementation of the dialog that manages the personal trust database editing.
//
#include    "global.hxx"
#include    "cryptreg.h"
#include    "pkialloc.h"
#include    "pertrust.h"
#include    "resource.h"
#include    "cryptui.h"
#include    <ole2.h>
#include    <commctrl.h>

#include    "secauth.h"

#include    <md5.h>

inline LONG Width(const RECT& rc)
    {
    return rc.right - rc.left;
    }

inline LONG Height(const RECT& rc)
    {
    return rc.bottom - rc.top;
    }

inline POINT Center(const RECT& rc)
	{
    POINT pt;
    pt.x = (rc.left + rc.right) / 2;
    pt.y = (rc.top + rc.bottom) / 2;
    return pt;
	}


void EnsureOnScreen(HWND hwnd)
//
// Ensure the window is on the screen
//
    {
    RECT rcScreen, rcWindow;
    if (SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0)
        && GetWindowRect(hwnd, &rcWindow))
        {
        int dx = 0;
        int dy = 0;

        if (rcWindow.top < rcScreen.top)
            dy = rcScreen.top - rcWindow.top;         // move down
        else if (rcWindow.bottom > rcScreen.bottom)
            dy = rcScreen.bottom - rcWindow.bottom;   // move up

        if (rcWindow.left < rcScreen.left)
            dx = rcScreen.left - rcWindow.left;       // move right
        else if (rcWindow.right > rcScreen.right)
            dx = rcScreen.right - rcWindow.right;     // move left

        if (dx || dy)
            {
            SetWindowPos(hwnd,
                NULL,
                rcWindow.left+dx,
                rcWindow.top+dy,
                0,0,
                SWP_NOSIZE | SWP_NOZORDER
                );
            }
        }
    }


/////////////////////////////////////////////////

class CDialogTrustDB
    {
private:
    HWND                m_hWnd;
    HWND                m_hWndParent;
    IPersonalTrustDB*   m_pdb;
    BOOL                m_fPropertySheet;
    ULONG               m_cTrust;
    TRUSTLISTENTRY*     m_rgTrust;

public:
                    CDialogTrustDB(BOOL fPropSheet = TRUE, HWND hWndParent = NULL);
                    ~CDialogTrustDB();
	void            OnInitDialog();
    HWND            GetWindow();
    void            SetWindow(HWND);
    void            OnOK();
    void            OnCancel();
    void            OnApplyNow();
    void            NotifySheetOfChange();
    void            NoteIrrevocableChange();
    void            RemoveSelectedTrustEntries();

private:
    HWND            WindowOf(UINT id);
    void            RefreshTrustList();
    void            FreeTrustList();
    HRESULT         Init();
    };

/////////////////////////////////////////////////

int __cdecl CompareTrustListEntries(const void*pelem1, const void* pelem2)
	{
	TRUSTLISTENTRY* p1 = (TRUSTLISTENTRY*)pelem1;
	TRUSTLISTENTRY* p2 = (TRUSTLISTENTRY*)pelem2;
    return _wcsicmp(p1->szDisplayName, p2->szDisplayName);
	}

/////////////////////////////////////////////////

void CDialogTrustDB::OnInitDialog()
    {
    //
    // Initialize our internals
    //
    if (Init() != S_OK)
        return;

    //
    // Set the state of our commercial checkbox per the current registry setting
    //
    ::SendMessage(
        WindowOf(IDC_TRUSTCOMMERCIAL),
        BM_SETCHECK,
        (m_pdb->AreCommercialPublishersTrusted()==S_OK) ? BST_CHECKED : BST_UNCHECKED,
        0L);

    //
    // If we are a property sheet, then hide the OK & Cancel buttons and
    // make the banter wider
    //
    if (m_fPropertySheet)
        {
        RECT rcBanter, rcOk;
        GetWindowRect(WindowOf(IDC_BANTER), &rcBanter);     // get in screen coords
        GetWindowRect(WindowOf(IDOK      ), &rcOk);         // get in screen coords
        ::SetWindowPos(WindowOf(IDC_BANTER), NULL,
            0, 0, Width(rcBanter) + (rcOk.right - rcBanter.right), Height(rcBanter),
            SWP_NOMOVE | SWP_NOZORDER);

        ::ShowWindow(WindowOf(IDOK),     SW_HIDE);
        ::ShowWindow(WindowOf(IDCANCEL), SW_HIDE);
        }
    else
        {
        //
        // We are the modal dialog variation. Center ourselves in our
        // parent window
        //
	    RECT rcParent, rcMe;
        ::GetWindowRect(m_hWndParent,  &rcParent);
	    ::GetWindowRect(GetWindow(), &rcMe);

        POINT ptParent = Center(rcParent);
        POINT ptMe     = Center(rcMe);
        POINT pt;
        pt.x = ptParent.x - ptMe.x + rcMe.left;
        pt.y = ptParent.y - ptMe.y + rcMe.top;

	    ::SetWindowPos
            (
            GetWindow(),
            NULL,
            pt.x,
            pt.y,
            0,
            0,
            SWP_NOZORDER | SWP_NOSIZE
            );

        //
        // Make sure we're on the screen
        //
        EnsureOnScreen(GetWindow());
        }

    //
    // Add the one column to list view control
    //
    LV_COLUMNW  lvC;
    WCHAR       szText[512];
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.iSubItem = 0;
    lvC.cx = 250;
    lvC.pszText = szText; 
    LoadStringU(hinst, IDS_COLUMN_HEADER, szText, 512);
    if (ListView_InsertColumnU(WindowOf(IDC_TRUSTLIST), 0, &lvC) == -1)
    {
        // error
    }

    //
    // Populate our list box
    //
    RefreshTrustList();

    }

void CDialogTrustDB::RefreshTrustList()
    {
    //
    // Remove all the entries presently in the trust list and on the display
    //
    FreeTrustList();
    HWND hwndList = WindowOf(IDC_TRUSTLIST);
    ListView_DeleteAllItems(hwndList);
    ::SendMessage(GetWindow(), WM_NEXTDLGCTL, 0 , (LPARAM) FALSE);
    EnableWindow(WindowOf(IDC_TRUSTREMOVE), FALSE);

    //
    // Populate our listbox with the current list of trusted publishers
    //
    if (m_pdb->GetTrustList(1, TRUE, &m_rgTrust, &m_cTrust) == S_OK)
        {
        //
        // Sort the trust entries alphabetically
        //
        if (m_cTrust > 1)
            {
            qsort(m_rgTrust, m_cTrust, sizeof(TRUSTLISTENTRY), CompareTrustListEntries);
            }

        //
        // Add them to the list box
        //
        LV_ITEMW    lvI;
        
        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_TEXT | LVIF_STATE;
        lvI.state = 0;
        lvI.stateMask = 0;
        lvI.iSubItem = 0;
        lvI.iItem = 0;
        for (ULONG i=0; i < m_cTrust; i++)
            {
            lvI.pszText = m_rgTrust[i].szDisplayName;
            lvI.cchTextMax = wcslen(m_rgTrust[i].szDisplayName);
            ListView_InsertItemU(hwndList, &lvI);
            lvI.iItem++;
            }

        EnableWindow(WindowOf(IDC_TRUSTREMOVE), m_cTrust > 0);
        }
    }

//////////////////////////////////////////////////////////////////////

void CDialogTrustDB::OnApplyNow()
    {
    //
    // Update the registry settings per the current commercial checkbox setting
    //
    m_pdb->SetCommercialPublishersTrust(
        ::SendMessage
                (
                WindowOf(IDC_TRUSTCOMMERCIAL),
                BM_GETCHECK, 0, 0L
                ) == BST_CHECKED
        );
    }

void CDialogTrustDB::OnOK()
    {
    OnApplyNow();
    ::EndDialog(GetWindow(), IDOK);
    }

void CDialogTrustDB::OnCancel()
    {
    ::EndDialog(GetWindow(), IDCANCEL);
    }


//////////////////////////////////////////////////////////////////////

void CDialogTrustDB::RemoveSelectedTrustEntries()
    {
    //
    // Remove from trust those items that are presently selected
    //
    HWND hwndList = WindowOf(IDC_TRUSTLIST);
    int  itemIndex = -1;

    if (ListView_GetSelectedCount(hwndList) >= 1)
        {

        while (-1 != (itemIndex = ListView_GetNextItem(hwndList, itemIndex, LVNI_SELECTED)))
        {
        m_pdb->RemoveTrustToken
            (
            &m_rgTrust[itemIndex].szToken[0],
             m_rgTrust[itemIndex].iLevel,
            FALSE
            );
        }

        //
        // Update the display
        //
        RefreshTrustList();

        //
        // Note the change
        //
        NoteIrrevocableChange();
        }
    }

void CDialogTrustDB::NoteIrrevocableChange()
//
// An irrevocable change has taken place in the UI. Note that
// as appropriate
//
    {
    if (!m_fPropertySheet)
        {
        //
        // Change 'cancel' to 'close'
        //
        WCHAR sz[30];
        ::LoadStringU(hinst, IDS_CLOSE, &sz[0], 30);
        ::SetWindowTextU(WindowOf(IDCANCEL), sz);
        }
    }

void CDialogTrustDB::NotifySheetOfChange()
//
// Inform our sheet that something on this page has changed
//
    {
    HWND hwndSheet = ::GetParent(GetWindow());
    PropSheet_Changed(hwndSheet, GetWindow());
    }


/////////////////////////////////////////////////

INT_PTR CALLBACK TrustPropSheetDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CDialogTrustDB* This = (CDialogTrustDB*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
        {

    case WM_INITDIALOG:
        {
        PROPSHEETPAGE* ppsp = (PROPSHEETPAGE*)lParam;
        This = (CDialogTrustDB*)ppsp->lParam;
        This->SetWindow(hwnd);
        This->OnInitDialog();
        break;
        }

    case WM_NOTIFY:
        {
        // Property sheet notifications are sent to us by the property
        // sheet using the WM_NOTIFY message
        //
        switch (((NMHDR*)lParam)->code)
            {
        case PSN_APPLY:
            // The user chose OK or Apply Now and wants all changes to take effect
            This->OnApplyNow();
            }
        break;
        }

    case WM_COMMAND:
        {
        WORD wNotifyCode = HIWORD(wParam); // notification code
        UINT wID = LOWORD(wParam);         // item, control, or accelerator identifier
        HWND hwndCtl = (HWND) lParam;      // handle of control

        if (wID==IDC_TRUSTCOMMERCIAL && wNotifyCode == BN_CLICKED)
            {
            // If something on our page changes then inform the property sheet
            // so that it can enable the Apply Now button.
            //
            This->NotifySheetOfChange();
            }

        if (wID==IDC_TRUSTREMOVE && wNotifyCode == BN_CLICKED)
            {
            // If the user clicks the 'Remove' button then remove
            // the selected entries from the trust data base.
            //
            This->RemoveSelectedTrustEntries();
            }

        break;
        }

    default:
        return FALSE;   // I did not process the message
        }

    return TRUE; // I did process the message
    }

/////////////////////////////////////////////////

UINT CALLBACK TrustPropSheetDialogReleaseProc(
    HWND  hwnd,	            // reserved, must be null
    UINT  uMsg,	            // PSPCB_CREATE or PSPCB_RELEASE
    LPPROPSHEETPAGEW ppsp	// the page being created or destroyed
    ){
    if (uMsg==PSPCB_RELEASE)
        {
        CDialogTrustDB* pdlg = (CDialogTrustDB*)(ppsp->lParam);
        delete pdlg;
        ppsp->lParam = NULL;
        }
    return TRUE; // significant only in the PSPCB_CREATE case
    }

/////////////////////////////////////////////////

INT_PTR CALLBACK TrustModalDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CDialogTrustDB* This = (CDialogTrustDB*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
        {

    case WM_HELP:
    case WM_CONTEXTMENU:
        {
        // Define an array of dword pairs,
        // where the first of each pair is the control ID,
        // and the second is the context ID for a help topic,
        // which is used in the help file.
        static const DWORD aMenuHelpIDs[] =
            {
            IDC_TRUSTCOMMERCIAL, IDH_TRUSTCOMMERCIAL,
            IDC_TRUSTLIST,       IDH_TRUSTLIST,
            IDC_TRUSTREMOVE,     IDH_TRUSTREMOVE,
            0, 0
            };

        if (uMsg == WM_HELP)
        {
            LPHELPINFO lphi;
            lphi = (LPHELPINFO)lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
                {
                WinHelp
                    (
                    (HWND)(lphi->hItemHandle),
                    SECAUTH_HELPFILENAME,
                    HELP_WM_HELP,
                    (ULONG_PTR)(LPVOID)aMenuHelpIDs
                    );
                }
        }
        else
        {
                WinHelp 
                    (
                    (HWND) wParam, 
                    SECAUTH_HELPFILENAME, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)aMenuHelpIDs
                    );
        }
        return TRUE;
        }

    case WM_INITDIALOG:
        {
        This = (CDialogTrustDB*)lParam;
        This->SetWindow(hwnd);
        This->OnInitDialog();
        break;
        }

    case WM_COMMAND:
        {
        WORD wNotifyCode = HIWORD(wParam); // notification code
        UINT wID = LOWORD(wParam);         // item, control, or accelerator identifier
        HWND hwndCtl = (HWND) lParam;      // handle of control

        if (wNotifyCode == BN_CLICKED)
            {
            if (wID==IDC_TRUSTREMOVE)
                {
                // If the user clicks the 'Remove' button then remove
                // the selected entries from the trust data base.
                //
                This->RemoveSelectedTrustEntries();
                }

            else if (wID == IDOK)
                {
                // The user clicked the OK button
                This->OnOK();
                }
            else if (wID == IDCANCEL)
                {
                // The user clicked the Cancel button
                This->OnCancel();
                }
            }

        break;
        }

    default:
        return FALSE;   // I did not process the message
        }

    return TRUE; // I did process the message
    }


/////////////////////////////////////////////////////////////////////////////
//
// The version of the trust db dialog that brings it up
// as a property sheet.

extern "C" BOOL CALLBACK AddPersonalTrustDBPages(
//
// Add the pages of our trust database editor to the indicated property
// sheet by using the indicated callback function. Return success or failure
//
    LPVOID lpv, 	
    LPFNADDPROPSHEETPAGE lpfnAddPage, 	
    LPARAM lParam	
   ) {
    PROPSHEETPAGEW psp;

    CDialogTrustDB* pdlg = new CDialogTrustDB;
    if (!pdlg)
        return FALSE;

    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.hInstance   = hinst;
    psp.pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_TRUSTDIALOG);
    psp.pfnDlgProc  = TrustPropSheetDialogProc;
    psp.pfnCallback = TrustPropSheetDialogReleaseProc;
    psp.lParam      = (LPARAM)pdlg;
    psp.pszTitle    = (LPWSTR) MAKEINTRESOURCE(IDS_TRUSTDIALOG);

    BOOL fSuccess = TRUE;

    // The following APIs are in DELAYLOAD'ed comctl32.dll. If the
    // DELAYLOAD fails an exception is raised.
    __try {
        HPROPSHEETPAGE hpage = CreatePropertySheetPageU(&psp);
        if (hpage)
            {
            if (!lpfnAddPage(hpage, lParam))
                {
                DestroyPropertySheetPage(hpage);
                fSuccess = FALSE;
                }
            }
        else
            fSuccess = FALSE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD dwExceptionCode = GetExceptionCode();
        fSuccess = FALSE;
    }

    return fSuccess;
    }

/////////////////////////////////////////////////////////////////////////////
//
// The version of the trust dialog that brings it up as a
// simple modal dialog
//

#define REGPATH_LEGACY_TRUSTED_PUBLISHER REGPATH_WINTRUST_POLICY_FLAGS \
                                            L"\\Trust Database\\0"


// Convert the bytes into some string form.
// Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in sz
void Legacy_BytesToString(
    ULONG cb,
    void* pv,
    LPWSTR sz
    )
{
    BYTE* pb = (BYTE*)pv;
    for (ULONG i = 0; i<cb; i++)
        {
        int b = *pb;
        *sz++ = (((b & 0xF0)>>4) + L'a');
        *sz++ =  ((b & 0x0F)     + L'a');
        pb++;
        }
    *sz++ = 0;
}


//
// X500 names can have VERY long encodings, so we can't just
// do a literal vanilla encoding
//
// There must be CBX500NAME characters of space in the destination
//
// NOTE: We rely on the lack of collision in the hash values.
// Chance of a collision for a set of 'p' names is approx:
//
//         p^2 / n
//
// (if p<<n) where n (with MD5) is 2^128. An amazingly small chance.
//
HRESULT Legacy_X500NAMEToString(
    ULONG cb,
    void *pv,
    LPWSTR szDest
    )
{
    #define CBHASH      16                  // MD5
    #define CBX500NAME  (2*CBHASH + 1)
    BYTE rgb[CBHASH];

    MD5_CTX md5ctx;

    MD5Init( &md5ctx );
    MD5Update( &md5ctx, (BYTE*)pv, cb );
    MD5Final( &md5ctx );

    assert(CBHASH == MD5DIGESTLEN);
    memcpy(rgb, md5ctx.digest, CBHASH);
    Legacy_BytesToString(CBHASH, rgb, szDest);

    return S_OK;
}

// Convert the issuer and serial number to some reasonable string form.
HRESULT Legacy_GetIssuerSerialString(
    PCCERT_CONTEXT pCert,
    LPWSTR *ppsz
    )
{
    HRESULT hr = S_OK;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    ULONG cbIssuer = CBX500NAME * sizeof(WCHAR);
    ULONG cbSerial = (pCertInfo->SerialNumber.cbData*2+1) * sizeof(WCHAR);
    WCHAR* sz      = (WCHAR*)PkiZeroAlloc(cbSerial + sizeof(WCHAR) + cbIssuer);
    if (sz)
        {
        if (S_OK == (hr = Legacy_X500NAMEToString(
                pCertInfo->Issuer.cbData,
                pCertInfo->Issuer.pbData,
                sz
                )))
            {
            WCHAR* szNext = &sz[CBX500NAME-1];

            *szNext++ = L' ';
            Legacy_BytesToString(
                pCertInfo->SerialNumber.cbData,
                pCertInfo->SerialNumber.pbData,
                szNext
                );
            }
        else
            {
            PkiFree(sz);
            sz = NULL;
            }
        }
    else
        {
            hr = E_OUTOFMEMORY;
        }
    *ppsz = sz;
    return hr;
}

BOOL ConvertAndAddLegacyPublisherCertificate(
    IN HKEY hLegacyKey,
    IN PCCERT_CONTEXT pPubCert
    )
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    HRESULT hr;
    LONG lErr;
    LPWSTR pwszValueName = NULL;
    LPWSTR pwszPubName = NULL;

    hr = Legacy_GetIssuerSerialString(pPubCert, &pwszValueName);
    if (FAILED(hr))
        goto GetIssuerSerialStringError;

    pwszPubName = spGetPublisherNameOfCert(pPubCert);
    if (NULL == pwszPubName) {
        hr = E_UNEXPECTED;
        goto GetPublisherNameOfCertError;
    }

    if (ERROR_SUCCESS != (lErr = RegSetValueExU(
            hLegacyKey,
            pwszValueName,
            NULL,
            REG_SZ,
            (BYTE *) pwszPubName,
            (wcslen(pwszPubName) + 1) * sizeof(WCHAR)
            )))
        goto RegSetValueError;

CommonReturn:
    if (pwszValueName)
        PkiFree(pwszValueName);
    if (pwszPubName)
        delete pwszPubName;

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

SET_ERROR_VAR_EX(DBG_SS, GetIssuerSerialStringError, hr)
SET_ERROR_VAR_EX(DBG_SS, GetPublisherNameOfCertError, hr)
SET_ERROR_VAR_EX(DBG_SS, RegSetValueError, lErr)
}

BOOL WriteTrustedPublisherLegacyRegistry()
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    LONG lErr;
    HCERTSTORE hPubStore = NULL;
    HKEY hLegacyKey = NULL;
    DWORD dwDisposition;
    PCCERT_CONTEXT pCert;

    hPubStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG,
        (const void *) L"TrustedPublisher"
        );
    if (NULL == hPubStore)
        goto OpenTrustedPublisherStoreError;

    // Delete the legacy registry key to remove any existing publishers
    if (ERROR_SUCCESS != (lErr = RegDeleteKeyU(
            HKEY_CURRENT_USER,
            REGPATH_LEGACY_TRUSTED_PUBLISHER
            ))) {
        if (ERROR_FILE_NOT_FOUND != lErr) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = (DWORD) lErr;
        }
    }

    // Create the legacy registry key 
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_LEGACY_TRUSTED_PUBLISHER,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,                   // lpSecurityAttributes
            &hLegacyKey,
            &dwDisposition
            )))
        goto CreateLegacyKeyError;

    // Loop through the TrustedPublisher certs: convert and add to
    // the legacy registry subkey
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hPubStore, pCert)) {
        if (!ConvertAndAddLegacyPublisherCertificate(
                hLegacyKey,
                pCert
                )) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

CommonReturn:
    if (hPubStore)
        CertCloseStore(hPubStore, 0);
    if (hLegacyKey)
        RegCloseKey(hLegacyKey);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisherStoreError)
SET_ERROR_VAR_EX(DBG_SS, CreateLegacyKeyError, lErr)
}

BOOL WriteTrustedPublisher_IEAKStore()
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    HCERTSTORE hPubStore = NULL;
    HCERTSTORE hIEAKStore = NULL;
    PCCERT_CONTEXT pCert;

    hPubStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG,
        (const void *) L"TrustedPublisher"
        );
    if (NULL == hPubStore)
        goto OpenTrustedPublisherStoreError;

    hIEAKStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER,
        (const void *) L"TrustedPublisher_IEAK"
        );
    if (NULL == hIEAKStore)
        goto OpenTrustedPublisher_IEAKStoreError;

    // Remove any existing certs that may already exist in the IEAK store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hIEAKStore, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);

        if (!CertDeleteCertificateFromStore(pDeleteCert)) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

    // Copy all certs from the logical TrustedPublisher to the IEAK registry
    // store

    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hPubStore, pCert)) {
        if (!CertAddCertificateContextToStore(
                hIEAKStore,
                pCert,
                CERT_STORE_ADD_USE_EXISTING,
                NULL                            // ppStoreContext
                )) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

CommonReturn:
    if (hPubStore)
        CertCloseStore(hPubStore, 0);
    if (hIEAKStore)
        CertCloseStore(hIEAKStore, 0);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisherStoreError)
TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisher_IEAKStoreError)

}

typedef BOOL (WINAPI *PFN_CRYPTUI_DLG_CERT_MGR)(
    IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr
    );

extern "C" BOOL WINAPI OpenPersonalTrustDBDialogEx(
    IN OPTIONAL HWND hwndParent,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved
    )
{
    DWORD dwLastErr = 0;
    BOOL fResult = TRUE;
    HMODULE hDll = NULL;

    if (!(dwFlags & WT_TRUSTDBDIALOG_NO_UI_FLAG)) {
        PFN_CRYPTUI_DLG_CERT_MGR pfnCryptUIDlgCertMgr;
        CRYPTUI_CERT_MGR_STRUCT CertMgrStruct;

        if (NULL == (hDll = LoadLibraryA("cryptui.dll")))
            goto LoadCryptUIDllError;

        if (NULL == (pfnCryptUIDlgCertMgr =
                (PFN_CRYPTUI_DLG_CERT_MGR) GetProcAddress(hDll,
                    "CryptUIDlgCertMgr")))
            goto CryptUICertMgrProcAddressError;

        memset(&CertMgrStruct, 0, sizeof(CRYPTUI_CERT_MGR_STRUCT));
        CertMgrStruct.dwSize=sizeof(CRYPTUI_CERT_MGR_STRUCT);
        CertMgrStruct.hwndParent = hwndParent;
        CertMgrStruct.dwFlags = CRYPTUI_CERT_MGR_PUBLISHER_TAB;
        if (dwFlags & WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG)
            CertMgrStruct.dwFlags |= CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG;

        if (!pfnCryptUIDlgCertMgr(&CertMgrStruct)) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
        
    }
    // else
    //  Being called to only write the TrustedPublisher store to the
    //  registry and/or IEAK store

    if (dwFlags & WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG) {
        if (!WriteTrustedPublisherLegacyRegistry()) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

    if (dwFlags & WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG) {
        if (!WriteTrustedPublisher_IEAKStore()) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }


CommonReturn:
    if (hDll)
        FreeLibrary(hDll);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, LoadCryptUIDllError)
TRACE_ERROR_EX(DBG_SS, CryptUICertMgrProcAddressError)
}


extern "C" BOOL WINAPI OpenPersonalTrustDBDialog(
    IN OPTIONAL HWND hwndParent
    )
{
    return OpenPersonalTrustDBDialogEx(
                hwndParent,
                0,          // dwFlags
                NULL        // pvReserved
                );
}

/////////////////////////////////////////////////////////////////////////////

HWND CDialogTrustDB::WindowOf(UINT id)
// Return the HWND of this control of ours
    {
    return ::GetDlgItem(GetWindow(), id);
    }

HWND CDialogTrustDB::GetWindow()
    {
    return m_hWnd;
    }

void CDialogTrustDB::SetWindow(HWND hwnd)
    {
    m_hWnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (INT_PTR)this);
    }

CDialogTrustDB::CDialogTrustDB(BOOL fPropSheet, HWND hWndParent) :
    m_hWnd(NULL),
    m_pdb(NULL),
    m_fPropertySheet(fPropSheet),
    m_rgTrust(NULL),
    m_hWndParent(hWndParent),
    m_cTrust(0)
    {
    INITCOMMONCONTROLSEX        initcomm = {
    sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES 
    };

    InitCommonControlsEx(&initcomm);
    }

void CDialogTrustDB::FreeTrustList()
    {
    if (m_rgTrust)
        {
        CoTaskMemFree(m_rgTrust);
        m_rgTrust = NULL;
        }
    }


CDialogTrustDB::~CDialogTrustDB()
    {
    if (m_pdb)
        m_pdb->Release();
    FreeTrustList();
    }

HRESULT CDialogTrustDB::Init()
    {
    HRESULT hr = OpenTrustDB(NULL, IID_IPersonalTrustDB, (LPVOID*)&m_pdb);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\tcatdb\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcatdb.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_SSGUID                11
#define IDS_PARAMTEXT_SSGUID            12
#define IDS_PARAM_ADD2DB                13
#define IDS_PARAMTEXT_ADD2DB            14

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\tcbfile\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcatdb.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_SSGUID                11
#define IDS_PARAMTEXT_SSGUID            12
#define IDS_PARAM_ADD2DB                13
#define IDS_PARAMTEXT_ADD2DB            14

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\testprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       testprov.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    25-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef TESTPROV_H
#define TESTPROV_H

#ifdef __cplusplus
extern "C" 
{
#endif

#include    "wtoride.h"

// Test Trust Provider: {684D31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define TESTPROV_ACTION_TEST                                    \
            { 0x684d31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }


//////////////////////////////////////////////////////////////////////////////
//
// TESTPROV Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Test Policy Provider
//  (TESTPROV.DLL's Policy Provider)
//  

#define TP_DLL_NAME                         L"TPROV1.DLL"

#define TP_INIT_FUNCTION                    L"TestprovInitialize"
#define TP_OBJTRUST_FUNCTION                L"TestprovObjectProv"
#define TP_SIGTRUST_FUNCTION                L"TestprovSigProv"
#define TP_CHKCERT_FUNCTION                 L"TestprovCheckCertProv"
#define TP_FINALPOLICY_FUNCTION             L"TestprovFinalProv"
#define TP_TESTDUMPPOLICY_FUNCTION_TEST     L"TestprovTester"
#define TP_CLEANUPPOLICY_FUNCTION           L"TestprovCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// TESTPROV_PRIVATE_DATE
//----------------------------------------------------------------------------
//  This structure defines TESTPROV.DLL's private data that is stored
//  in the CRYPT_PROVIDER_PRIVDATA array.
//  

typedef struct _TESTPROV_PRIVATE_DATA
{
    DWORD                   cbStruct;

    CRYPT_PROVIDER_FUNCTIONS_ORMORE    sAuthenticodePfns;
    CRYPT_PROVIDER_FUNCTIONS_ORLESS    sAuthenticodePfns_less;

} TESTPROV_PRIVATE_DATA, *PTESTPROV_PRIVATE_DATA;


#ifdef __cplusplus
}
#endif

#endif // TESTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\tcatdb\tcatdb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtstrss.cpp
//
//  Contents:   WinVerifyTrust Stress
//
//  History:    13-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


#define     STRING_SEPERATOR            L'*'

typedef struct STATEINFO_
{
    WCHAR           wszCatalogFile[MAX_PATH];
    HANDLE          hState;

} STATEINFO;

void            _StripQuotes(WCHAR *pwszIn);
void            _Add2CatDB(WCHAR *pwszCatFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn);
void            _VerifyMember(WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn);
void            _CloseWVTHandles(void);
STATEINFO *     _FindStateHandle(WCHAR *pwszCatalogFile);
void            _ToLower(WCHAR *pwszInOut);


Stack_      *pStateHandles  = NULL;
GUID        gAction         = DRIVER_ACTION_VERIFY;
GUID        gSS             = DRIVER_ACTION_VERIFY;
HCATADMIN   hCatAdmin       = NULL;
BOOL        fCatalogAdded   = FALSE;
BOOL        fVerbose;
DWORD       dwTotalCatalogs = 0;
DWORD       dwTotalErrors   = 0;
HWND        hWnd            = NULL;


extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    WCHAR                   *pwszLoopFile;
    WCHAR                   *pwszCatFile;
    WCHAR                   *pwszMemFile;
    WCHAR                   *pwsz;
    DWORD                   dwExpectedReturn;
    DWORD                   dwCount;
    DWORD                   dwTotalFiles;
    BOOL                    fVerbose;
    int                     iRet;

    cWArgv_                 *pArgs;
    fParse_                 *pLoopFile;
    BOOL                    fFailed;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    pLoopFile           = NULL;

    dwTotalFiles        = 0;
    dwCount             = 1;
    iRet                = 0;
    dwExpectedReturn    = S_OK;

    hWnd                = GetDesktopWindow();

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    if (!(pStateHandles = new Stack_(NULL)))
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_SSGUID,   IDS_PARAMTEXT_SSGUID,   WARGV_VALUETYPE_WCHAR,  NULL);
    pArgs->Add2List(IDS_PARAM_ADD2DB,   IDS_PARAMTEXT_ADD2DB,   WARGV_VALUETYPE_WCHAR,  NULL);

    pArgs->Fill(argc, wargv);

    if (pArgs->GetValue(IDS_PARAM_HELP))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    if (!(pwszLoopFile = pArgs->GetFileName()))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto ParamError;
    }

    if (!(pLoopFile = new fParse_(pwszLoopFile, &fFailed, MAX_PATH * 2)) ||
        fFailed)
    {
        goto MemoryError;
    }

    pLoopFile->Reset();

    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->GetValue(IDS_PARAM_SSGUID))
    {
        if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_SSGUID), &gSS)))
        {
            wprintf(L"%s\n", pArgs->GetUsageString());
            goto ParamError;
        }
    }

    pwszCatFile = (WCHAR *)pArgs->GetValue(IDS_PARAM_ADD2DB);

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, (pwszCatFile) ? &gSS : NULL, 0)))
    {
        if (GetLastError() != dwExpectedReturn)
        {
            printf("\nERROR: unable to aquire CatAdminContext: return 0x%08X\n", GetLastError());
        }

        goto MSCATError;
    }

    while (pLoopFile->GetNextLine())
    {
        pLoopFile->EOLRemove();

        //
        //  format:
        //          catalog member tag^catalog member file^expected return code
        //
        if (!(pwszMemFile = wcschr(pLoopFile->GetCurrentLine(), STRING_SEPERATOR)))
        {
            if (fVerbose)
            {
                wprintf(L"   parse error at line: %s\n", pLoopFile->GetCurrentLine());
            }
            continue;
        }

        *pwszMemFile = NULL;
        pwszMemFile++;

        if (!(pwsz = wcschr(pwszMemFile, STRING_SEPERATOR)))
        {
            if (fVerbose)
            {
                pwszMemFile--;
                *pwszMemFile = STRING_SEPERATOR;
                wprintf(L"   parse error at line: %s\n", pLoopFile->GetCurrentLine());
            }
            continue;
        }

        *pwsz = NULL;
        pwsz++;
        dwExpectedReturn = (DWORD)_wtol(pwsz);

        _StripQuotes(pwszMemFile);
        _StripQuotes(pLoopFile->GetCurrentLine());

        if (pwszCatFile)
        {
            //
            //  we're adding
            //
            _Add2CatDB(pwszCatFile, pLoopFile->GetCurrentLine(), pwszMemFile, dwExpectedReturn);
        }
        else
        {
            //
            //  we're verifying
            //
            _VerifyMember(pLoopFile->GetCurrentLine(), pwszMemFile, dwExpectedReturn);
        }

        if (fVerbose)
        {
            wprintf(L"processed: %s\n", pwszMemFile);
        }

        dwTotalFiles++;
    }

    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTotal files processed:    %ld", dwTotalFiles);
    printf("\nTotal Catalogs loaded:    %ld", dwTotalCatalogs);
    printf("\nTotal errors:             %ld", dwTotalErrors);
    printf("\nProcessing time:          %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage seconds per file: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotalFiles);
    printf("\n");

    CommonReturn:
        _CloseWVTHandles();

        if (hCatAdmin)
        {
            CryptCATAdminReleaseContext(hCatAdmin, 0);
        }


        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pStateHandles);
        DELETE_OBJECT(pLoopFile);

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MSCATError);
    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

void _Add2CatDB(WCHAR *pwszCatFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn)
{
    if (!(fCatalogAdded))
    {
        HCATINFO    hCatInfo;

        if (!(hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0)))
        {
            if (GetLastError() != dwExpectedReturn)
            {
                wprintf(L"\nERROR: unable to add catalog: %s: return 0x%08X\n", pwszCatFile, GetLastError());
                dwTotalErrors++;
            }

            return;
        }

        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);


        fCatalogAdded = TRUE;
    }
}

void _VerifyMember(WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn)
{
    HCATINFO                hCatInfo;
    CATALOG_INFO            sCatInfo;
    WCHAR                   wszCatFile[MAX_PATH];
    BYTE                    bHash[40];
    BYTE                    *pbHash;
    DWORD                   cbHash;
    HANDLE                  hFile;


    SetLastError(0);

    hCatInfo    = NULL;
    hFile       = INVALID_HANDLE_VALUE;

    if ((hFile = CreateFileU(pwszMemberFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
    {
        goto FailedOpenFile;
    }

    cbHash  = 40;
    pbHash  = &bHash[0];
    if (!(CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pbHash, 0)))
    {
        goto FailedHashCalc;
    }

    if (!(hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, NULL)))
    {
        goto FailedEnumCatalog;
    }

    memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
    sCatInfo.cbStruct = sizeof(CATALOG_INFO);

    if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
    {
        goto FailedEnumCatalog;
    }

    wcscpy(&wszCatFile[0], sCatInfo.wszCatalogFile);

    pwszMemberTag = wcsrchr(pwszMemberFile, L'\\');

    if (pwszMemberTag)
    {
        pwszMemberTag++;
    }
    else
    {
        pwszMemberTag = pwszMemberFile;
    }

    _ToLower(pwszMemberTag);

    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    STATEINFO               *psState;
    HRESULT                 hr;

    if (!(psState = _FindStateHandle(&wszCatFile[0])))
    {
        goto MemoryError;
    }

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_CATALOG;
    sWTD.pCatalog       = &sWTCI;
    sWTD.dwStateAction  = WTD_STATEACTION_VERIFY;
    sWTD.hWVTStateData  = psState->hState;

    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
    sWTCI.pcwszCatalogFilePath  = &wszCatFile[0];
    sWTCI.pcwszMemberTag        = pwszMemberTag;
    sWTCI.pcwszMemberFilePath   = pwszMemberFile;
    sWTCI.hMemberFile           = hFile;
    sWTCI.pbCalculatedFileHash  = pbHash;
    sWTCI.cbCalculatedFileHash  = cbHash;

    hr = WinVerifyTrust(hWnd, &gAction, &sWTD);

    psState->hState = sWTD.hWVTStateData;

    CommonReturn:
        if (hr != (HRESULT)dwExpectedReturn)
        {
            wprintf(L"\nERROR: unexpected error from WVT for %s: return 0x%08X expected: 0x%08X lasterror: 0x%08X\n",
                    pwszMemberTag, hr, dwExpectedReturn, GetLastError());
            dwTotalErrors++;
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }

        if (hCatInfo)
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }
        return;

    ErrorReturn:
        if (GetLastError() != dwExpectedReturn)
        {
            wprintf(L"\nERROR: unable to find member: %s: return 0x%08X expected: 0x%08X\n",
                    pwszMemberTag, GetLastError(), dwExpectedReturn);
            dwTotalErrors++;
        }

        hr = dwExpectedReturn;
        goto CommonReturn;


    TRACE_ERROR_EX(DBG_SS_APP, FailedHashCalc);
    TRACE_ERROR_EX(DBG_SS_APP, FailedOpenFile);
    TRACE_ERROR_EX(DBG_SS_APP, FailedEnumCatalog);

    SET_ERROR_VAR_EX(DBG_SS_APP, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
}


void _CloseWVTHandles(void)
{
    DWORD                   dwIdx;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    STATEINFO               *psState;

    dwIdx = 0;

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_CATALOG;
    sWTD.pCatalog       = &sWTCI;
    sWTD.dwStateAction  = WTD_STATEACTION_CLOSE;

    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);


    while (psState = (STATEINFO *)pStateHandles->Get(dwIdx))
    {
        if (psState->hState)
        {
            sWTD.hWVTStateData  = psState->hState;

            WinVerifyTrust(NULL, &gAction, &sWTD);
        }

        dwIdx++;
    }
}

STATEINFO * _FindStateHandle(WCHAR *pwszCatalogFile)
{
    STATEINFO   *psState;
    DWORD       dwIdx;

    dwIdx = 0;

    while (psState = (STATEINFO *)pStateHandles->Get(dwIdx))
    {
        if (wcscmp(&psState->wszCatalogFile[0], pwszCatalogFile) == 0)
        {
            return(psState);
        }

        dwIdx++;
    }

    if (!(psState = (STATEINFO *)pStateHandles->Add(sizeof(STATEINFO))))
    {
        return(NULL);
    }

    memset(psState, 0x00, sizeof(STATEINFO));

    wcscpy(&psState->wszCatalogFile[0], pwszCatalogFile);

    dwTotalCatalogs++;

    return(psState);
}

void _StripQuotes(WCHAR *pwszIn)
{
    DWORD   dwSrc;
    DWORD   dwDst;
    DWORD   dwLen;

    dwSrc = 0;
    dwDst = 0;
    dwLen = wcslen(pwszIn);

    while (dwSrc < dwLen)
    {
        if (pwszIn[dwSrc] != L'\"')
        {
            pwszIn[dwDst] = pwszIn[dwSrc];
            dwDst++;
        }
        dwSrc++;
    }

    pwszIn[dwDst] = NULL;
}


void _ToLower(WCHAR *pwszInOut)
{
    while (*pwszInOut)
    {
        *pwszInOut = towlower(*pwszInOut);
        pwszInOut++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\tcbfile\tcbfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       tcbfile.cpp
//
//  Contents:   cbfile tests
//
//  History:    13-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cbfile.hxx"

CRITICAL_SECTION    MyCriticalSection;

void _DumpIndex(cBFile_ *pcBFile);
void _DumpHeader(cBFile_ *pcBFile);

DWORD                   dwTotal;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    WCHAR                   *pwszFile;
    DWORD                   dwExpectedReturn;
    BOOL                    fVerbose;
    int                     iRet;

    cWArgv_                 *pArgs;
    BOOL                    fFailed;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    cBFile_                 *pcBFile;
    BOOL                    fCreatedOK = FALSE;

    pcBFile             = NULL;
    dwTotal             = 0;
    iRet                = 0;
    dwExpectedReturn    = S_OK;
    
    InitializeCriticalSection(&MyCriticalSection);

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (pArgs->GetValue(IDS_PARAM_HELP))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto ParamError;
    }

    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (!(pcBFile = new cBFile_(&MyCriticalSection, L".\\", pwszFile, 1, 1, BFILE_VERSION_1, &fCreatedOK)))
    {
        goto MemoryError;
    }

    if (!fCreatedOK)
    {
        goto DBError;
    }

    if (!(pcBFile->Initialize()))
    {
        goto DBError;
    }

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    //
    // dump the file's index
    //
    _DumpIndex(pcBFile);

    //
    //  dump the file's header
    //
    _DumpHeader(pcBFile);

    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nProcessing time:      %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage seconds per:  %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\n");

    iRet = 0;

    CommonReturn:
        DeleteCriticalSection(&MyCriticalSection);

        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pcBFile);

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, DBError);
}

void _DumpIndex(cBFile_ *pcBFile)
{
    BYTE    *pb;
    DWORD   dwIdx;
    DWORD   dwRecOffset;
    DWORD   i;

    pb = new BYTE[pcBFile->KeySize()];

    dwIdx = 0;

    while (pcBFile->GetDumpKey(dwIdx, pb, &dwRecOffset))
    {
        printf("\n");

        for (i = 0; i < pcBFile->KeySize(); i++)
        {
            printf("%02.2X", (int)pb[i]);
        }

        printf("  --> %lu", dwRecOffset);

        dwTotal++;

        dwIdx++;
    }

}


void _DumpHeader(cBFile_ *pcBFile)
{
    BFILE_HEADER    sHeader;

    if (pcBFile->GetHeader(&sHeader))
    {
        printf("\n");
        printf("\nHeader:");
        printf("\n   fDirty:        %s", (sHeader.fDirty) ? "TRUE" : "FALSE");
        printf("\n   sVersion:      %lu", (DWORD)sHeader.sVersion);
        printf("\n   sIntVersion:   %lu", (DWORD)sHeader.sIntVersion);
        printf("\n   cbSortedEOF:   %lu", sHeader.cbSortedEOF);
        printf("\n   cbKey:         %lu", sHeader.cbKey);
        printf("\n   cbData:        %lu", sHeader.cbData);
        printf("\n   dwLastRecNum:  %lu", sHeader.dwLastRecNum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\testprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       testprov.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              TestprovInitialize
//              TestprovObjectProv
//              TestprovSigProv
//              TestprovCertCheckProv
//              TestprovFinalProv
//              TestprovCleanup
//              TestprovTester
//
//  History:    28-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <wincrypt.h>
#include    <wintrust.h>    // structures and APIs
#include    "wintrustp.h"    // structures and APIs
#include    <softpub.h>     // reference for Authenticode
#include    <acui.h>        // ui module DACUI.DLL

#include    "testprov.h"    // my stuff


HRESULT     CallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError);
DWORD       GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);
HRESULT     CheckCertificateChain(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pProvSgnr);
HRESULT     CheckRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr);
BOOL        CheckCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, PCERT_INFO pCertInfo);


//////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//----------------------------------------------------------------------------
//  Register "my" provider
//  

STDAPI DllRegisterServer(void)
{
    GUID                        gTestprov = TESTPROV_ACTION_TEST;

    CRYPT_REGISTER_ACTIONID     sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = TP_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = TP_INIT_FUNCTION;

    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = TP_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = TP_OBJTRUST_FUNCTION;

    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = TP_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = TP_SIGTRUST_FUNCTION;

    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = TP_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = TP_CHKCERT_FUNCTION;

    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = TP_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = TP_FINALPOLICY_FUNCTION;

    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = TP_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = TP_CLEANUPPOLICY_FUNCTION;

    sRegAID.sTestPolicyProvider.cbStruct                = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sTestPolicyProvider.pwszDLLName             = TP_DLL_NAME;
    sRegAID.sTestPolicyProvider.pwszFunctionName        = TP_TESTDUMPPOLICY_FUNCTION_TEST;

    
    if (WintrustAddActionID(&gTestprov, 0, &sRegAID))
    {
        return(S_OK);
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters "my" provider
//  

STDAPI DllUnregisterServer(void)
{
    GUID    gTestprov = TESTPROV_ACTION_TEST;

    WintrustRemoveActionID(&gTestprov);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// Initialization Provider function: testprovInitialize
//----------------------------------------------------------------------------
//  allocates and sets up "my" data.
//  

HRESULT WINAPI TestprovInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    //
    //  add our private data to the array...
    //
    CRYPT_PROVIDER_PRIVDATA sMyData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    memset(&sMyData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
    sMyData.cbStruct        = sizeof(CRYPT_PROVIDER_PRIVDATA);

    memcpy(&sMyData.gProviderID, &gMyId, sizeof(GUID));

    if (!(sMyData.pvProvData = pProvData->psPfns->pfnAlloc(sizeof(TESTPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return(S_FALSE);
    }

    memset(sMyData.pvProvData, 0x00, sizeof(TESTPROV_PRIVATE_DATA));

    pMyData             = (TESTPROV_PRIVATE_DATA *)sMyData.pvProvData;
    pMyData->cbStruct   = sizeof(TESTPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    GUID                        gSP = WINTRUST_ACTION_TRUSTPROVIDER_TEST;

    pMyData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS_ORMORE);

    if (!(WintrustLoadFunctionPointers(&gSP, (CRYPT_PROVIDER_FUNCTIONS *)&pMyData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sMyData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    //
    //  add my data to the chain!
    //
    pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sMyData);


    return(pMyData->sAuthenticodePfns.pfnInitialize(pProvData));
}

//////////////////////////////////////////////////////////////////////////////
//
// Object Provider function: TestprovObjectProv
//----------------------------------------------------------------------------
//  we don't do anything here -- we're not authenticating a signed object.
//  

HRESULT WINAPI TestprovObjectProv(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    //
    //  we are verifying a low-level type choice (eg: cert or signer)
    //
    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    break;

        default:
                    return(pMyData->sAuthenticodePfns.pfnObjectTrust(pProvData));
    }

    //
    //  no object to be verified here!
    //
    return(ERROR_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//
// Signature Provider function: TestprovInitialize
//----------------------------------------------------------------------------
//  We are going to let Authenticode take care of most of this stuff!
//  

HRESULT WINAPI TestprovSigProv(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    //
    //  we are verifying a low-level type choice (eg: cert or signer)
    //
    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    break;

        default:
                    return(pMyData->sAuthenticodePfns.pfnSignatureTrust(pProvData));
    }

    if (pMyData->sAuthenticodePfns.pfnSignatureTrust)
    {
        return(pMyData->sAuthenticodePfns.pfnSignatureTrust(pProvData));
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// Certificate Check Provider function: TestprovCertCheckProv
//----------------------------------------------------------------------------
//  just check basic stuff about a certificate.  return FALSE to stop
//  building the chain, TRUE to continue.
//  

BOOL WINAPI TestprovCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                  BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;
    PCCERT_CONTEXT          pCertContext;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, fCounterSignerChain, idxCounterSigner);

    pCert = WTHelperGetProvCertFromChain(pSgnr, pSgnr->csCertChain - 1);

    pCert->fTrustedRoot = FALSE;

    //
    //  only self signed certificates in the root store are "trusted" roots
    //
    if (pCert->fSelfSigned)
    {
        pCertContext = pCert->pCert;

        if (pCertContext)
        {
            if (pProvData->chStores > 0)
            {
                if (pCertContext->hCertStore == pProvData->pahStores[0])
                {
                    //
                    //  it's in the root store!
                    //
                    pCert->fTrustedRoot = TRUE;
                    
                    return(FALSE);
                }
            }

            if (!(pCert->fTrustedRoot))
            {
                if (pCert->fTestCert)
                {
                    //
                    //  check the policy flags (setreg.exe) to see if we trust
                    //  the test root.
                    //
                    if (pProvData->dwRegPolicySettings & WTPF_TRUSTTEST)
                    {
                        pCert->fTrustedRoot = TRUE;
                        return(FALSE);
                    }
                }
            }
        }

        //
        //  the cert is self-signed... we need to stop regardless
        //
        return(FALSE);
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: TestprovFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  

HRESULT WINAPI TestprovFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
    CRYPT_PROVIDER_SGNR *pSigner;
    DWORD               dwError;

    if ((dwError = GetErrorBasedOnStepErrors(pProvData)) != ERROR_SUCCESS)
    {
        return(CallUI(pProvData, dwError));
    }

    pSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    if ((dwError = CheckCertificateChain(pProvData, pSigner)) != ERROR_SUCCESS)
    {
        return(CallUI(pProvData, dwError));
    }

    return(CallUI(pProvData, dwError));
}

//////////////////////////////////////////////////////////////////////////////
//
// Cleanup Provider function: TestprovCleanup
//----------------------------------------------------------------------------
//  call all other policy provider cleanup functions, then, free "my" stuff.
//  

HRESULT WINAPI TestprovCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                    gMyId = TESTPROV_ACTION_TEST;
    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;

    //
    //  we have used the Authenticode Provider.  we need to call its
    //  cleanup routine just in case....  so, get our private data
    //  which will have the Authenticode functions in our structure..
    //

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        return(S_FALSE);
    }

    if (!(pPrivData->pvProvData))
    {
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    if (pMyData->sAuthenticodePfns.pfnCleanupPolicy)
    {
        pMyData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
    }

    //
    //  now, we need to delete our private data
    //
    pProvData->psPfns->pfnFree(pPrivData->pvProvData);
    pPrivData->cbProvData   = 0;
    pPrivData->pvProvData   = NULL;

    return(ERROR_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//
// Test Provider function: TestprovTester
//----------------------------------------------------------------------------
//  In here, we are going to check an environment variable and if set we 
//  will call Authenticode's "dump" function.
//  

HRESULT WINAPI TestprovTester(CRYPT_PROVIDER_DATA *pProvData)
{
    BYTE                    abEnv[MAX_PATH + 1];
    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    abEnv[0] = NULL;

    if (GetEnvironmentVariable("TestProvUseDump", (char *)&abEnv[0], MAX_PATH) < 1)
    {
        return(ERROR_SUCCESS);
    }

    if ((abEnv[0] != '1') && (toupper(abEnv[0]) != 'T'))
    {
        return(ERROR_SUCCESS);
    }

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    if (pMyData->sAuthenticodePfns.pfnTestFinalPolicy)
    {
        return(pMyData->sAuthenticodePfns.pfnTestFinalPolicy(pProvData));
    }

    return(S_FALSE);
}

///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}

HRESULT CheckCertificateChain(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pProvSgnr)
{
    CRYPT_PROVIDER_CERT *pCert;

    for (int i = 0; i < (int)pProvSgnr->csCertChain; i++)
    {
        pCert = WTHelperGetProvCertFromChain(pProvSgnr, i);


        if (!(pProvData->dwRegPolicySettings  & WTPF_IGNOREEXPIRATION))
        {
            //
            //  this check was done in the Certificate Provider, however, it may not have passed
            //  because all its looking for is a confidence level and didn't check the end..
            //
            if (CertVerifyTimeValidity(&pProvSgnr->sftVerifyAsOf, pCert->pCert->pCertInfo) != 0)
            {
                pCert->dwError  = CERT_E_EXPIRED;

                return(pCert->dwError);
            }
        }

        //
        //  check any unknown critical extensions
        //
        if (!(CheckCertAnyUnknownCriticalExtensions(pProvData, pCert->pCert->pCertInfo)))
        {
            pCert->dwError  = CERT_E_MALFORMED;

            return(pCert->dwError);
        }

        if ((i + 1) < (int)pProvSgnr->csCertChain)
        {
            //
            //  check time nesting...
            //
            if (!(pCert->dwConfidence & CERT_CONFIDENCE_TIMENEST))
            {
                pCert->dwError  = CERT_E_VALIDITYPERIODNESTING;

                return(pCert->dwError);
            }
            
        }
    }

    if (!(pProvData->dwRegPolicySettings & WTPF_IGNOREREVOKATION))
    {
        // root cert is test?
        pCert = WTHelperGetProvCertFromChain(pProvSgnr, pProvSgnr->csCertChain - 1);

        if (pCert)
        {
            if (!(pCert->fTestCert))
            {
                //
                //  if the caller already told WVT to check, we don't have to!
                //
                if (pProvData->pWintrustData->fdwRevocationChecks != WTD_REVOKE_NONE)
                {
                    //
                    //  not a test root, check signer cert for revocation
                    //
                    pCert = WTHelperGetProvCertFromChain(pProvSgnr, 0);

                    return(CheckRevocation(pProvData, pProvSgnr));
                }
            }
        }
    }

    return(ERROR_SUCCESS);
}


HRESULT CallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError)
{
    HRESULT                 hr;
    HINSTANCE               hModule;
    ACUI_INVOKE_INFO        aii;
    pfnACUIProviderInvokeUI pfn;
    DWORD                   idxSigner;
    BOOL                    fTrusted;
    BOOL                    fCommercial;
    DWORD                   dwUIChoice;
    CRYPT_PROVIDER_SGNR     *pRootSigner;
    CRYPT_PROVIDER_CERT     *pPubCert;

    hr          = E_NOTIMPL;

    pfn         = NULL;

    fTrusted    = FALSE;

    fCommercial = FALSE;

    idxSigner   = 0;

    dwUIChoice  = pProvData->pWintrustData->dwUIChoice;

    pRootSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);


    if ((dwUIChoice == WTD_UI_NONE) ||
        ((dwUIChoice == WTD_UI_NOBAD) && (dwError != ERROR_SUCCESS)) ||
        ((dwUIChoice == WTD_UI_NOGOOD) && (dwError == ERROR_SUCCESS)))
    {
        return(dwError);
    }

    //
    // Setup the UI invokation
    //
    memset(&aii, 0x00, sizeof(ACUI_INVOKE_INFO));

    aii.cbSize                  = sizeof(ACUI_INVOKE_INFO);
    aii.hDisplay                = pProvData->hWndParent;
    aii.pProvData               = pProvData;
    aii.hrInvokeReason          = dwError;
    aii.pwcsAltDisplayName      = WTHelperGetFileName(pProvData->pWintrustData);

    //
    // Load the default authenticode UI.
    //
    if (hModule = LoadLibrary("dacui.dll"))
    {
        pfn = (pfnACUIProviderInvokeUI)GetProcAddress(hModule, "ACUIProviderInvokeUI");
    }

    //
    // Invoke the UI
    //
    if (pfn)
    {
        hr = (*pfn)(&aii);
    }
    else if ((pProvData->pWintrustData->dwUIChoice != WTD_UI_NONE) &&
             (pProvData->pWintrustData->dwUIChoice != WTD_UI_NOBAD))
    {
        //TBDTBD!!!
        //
        //  display error dialog "unable to load UI provider"
        //
        if (hr == E_NOTIMPL)
        {
            hr = TRUST_E_PROVIDER_UNKNOWN;
        }
        pProvData->dwError = hr;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_UIPROV] = hr;
    }

    //
    //  free the ui library
    //

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    //
    // Return the appropriate code
    //
    return(hr);
}

static const char *rgpszKnownExtObjId[] = 
{
    szOID_AUTHORITY_KEY_IDENTIFIER,
    szOID_KEY_ATTRIBUTES,
    szOID_KEY_USAGE_RESTRICTION,
    szOID_SUBJECT_ALT_NAME,
    szOID_ISSUER_ALT_NAME,
    szOID_BASIC_CONSTRAINTS,
    SPC_COMMON_NAME_OBJID,
    SPC_SP_AGENCY_INFO_OBJID,
    SPC_MINIMAL_CRITERIA_OBJID,
    SPC_FINANCIAL_CRITERIA_OBJID,
    szOID_CERT_POLICIES,
    szOID_POLICY_MAPPINGS,
    szOID_SUBJECT_DIR_ATTRS,
    NULL
};


BOOL CheckCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, PCERT_INFO pCertInfo)
{
    PCERT_EXTENSION     pExt;
    DWORD               cExt;
    const char          **ppszObjId;
    const char          *pszObjId;
    
    cExt = pCertInfo->cExtension;
    pExt = pCertInfo->rgExtension;

    for ( ; cExt > 0; cExt--, pExt++) 
    {
        if (pExt->fCritical) 
        {
            ppszObjId = (const char **)rgpszKnownExtObjId;

            while (pszObjId = *ppszObjId++) 
            {
                if (strcmp(pszObjId, pExt->pszObjId) == 0)
                {
                    break;
                }
            }
            if (!(pszObjId))
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

HRESULT CheckRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr)
{
    CERT_REVOCATION_PARA    sRevPara;
    CERT_REVOCATION_STATUS  sRevStatus;
    PCERT_CONTEXT           pasCertContext[1];
    CRYPT_PROVIDER_CERT     *pCert;


    memset(&sRevPara, 0x00, sizeof(CERT_REVOCATION_PARA));

    sRevPara.cbSize         = sizeof(CERT_REVOCATION_PARA);

    // issuer cert = 1
    pCert = WTHelperGetProvCertFromChain(pSgnr, 1);
    sRevPara.pIssuerCert    = pCert->pCert;

    memset(&sRevStatus, 0x00, sizeof(CERT_REVOCATION_STATUS));

    sRevStatus.cbSize       = sizeof(CERT_REVOCATION_STATUS);

    // publisher cert = 0
    pCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    pasCertContext[0]       = (PCERT_CONTEXT)pCert->pCert;

    if (!(CertVerifyRevocation(pProvData->dwEncoding,
                               CERT_CONTEXT_REVOCATION_TYPE,
                               1,
                               (void **)pasCertContext,
                               0, // CERT_VERIFY_REV_CHAIN_FLAG,
                               &sRevPara,
                               &sRevStatus)))
    {
        pCert->dwRevokedReason  = sRevStatus.dwReason;

        switch(sRevStatus.dwError)
        {
            case CRYPT_E_REVOKED:
                return(CERT_E_REVOKED);

            case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
                return(ERROR_SUCCESS);

            case CRYPT_E_REVOCATION_OFFLINE:
                if ((pProvData->dwRegPolicySettings & WTPF_OFFLINEOK_IND) ||
                    (pProvData->dwRegPolicySettings & WTPF_OFFLINEOKNBU_IND))
                {
                    return(ERROR_SUCCESS);
                }
                
                return(CERT_E_REVOCATION_FAILURE);

            default:
                return(CERT_E_REVOCATION_FAILURE);

        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\wtoride.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wtoride.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    28-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WTORIDE_H
#define WTORIDE_H

#ifdef __cplusplus
extern "C" 
{
#endif

//
//  override wintrust data with both more than and less than
//

typedef struct _WINTRUST_DATA_ORLESS
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)
    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.
    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
    DWORD           dwUnionChoice;              // required: which structure is being passed in?
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

} WINTRUST_DATA_ORLESS, *PWINTRUST_DATA_ORLESS;

typedef struct WINTRUST_FILE_INFO_ORLESS_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)
    LPCWSTR         pcwszFilePath;              // required, file name to be verified

} WINTRUST_FILE_INFO_ORLESS, *PWINTRUST_FILE_INFO_ORLESS;



typedef struct _WINTRUST_DATA_ORMORE
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)
    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.
    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
    DWORD           dwUnionChoice;              // required: which structure is being passed in?
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };
    DWORD           dwStateAction;                      // optional
    HANDLE          hWVTStateData;                      // optional
    WCHAR           *pwszURLReference;          // optional: currently used to determine zone.

    DWORD           dwExtra[40];

} WINTRUST_DATA_ORMORE, *PWINTRUST_DATA_ORMORE;


typedef struct WINTRUST_FILE_INFO_OR_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)
    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    DWORD           dwExtra[20];
      
} WINTRUST_FILE_INFO_OR, *PWINTRUST_FILE_INFO_OR;


typedef struct _CRYPT_PROVIDER_FUNCTIONS_ORMORE
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

                    // the following was added on 7/23/1997: pberkman
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

    DWORD                               dwExtra[40];

} CRYPT_PROVIDER_FUNCTIONS_ORMORE, *PCRYPT_PROVIDER_FUNCTIONS_ORMORE;

typedef struct _CRYPT_PROVIDER_FUNCTIONS_ORLESS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

} CRYPT_PROVIDER_FUNCTIONS_ORLESS, *PCRYPT_PROVIDER_FUNCTIONS_ORLESS;




typedef struct _CRYPT_PROVIDER_CERT_ORMORE
{
    DWORD                               cbStruct;
                                        
    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!
                                        
    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider
                                        
    BOOL                                fTestCert;          // certchk policy will set
                                        
    DWORD                               dwRevokedReason;
                                        
    DWORD                               dwConfidence;       // set in the Certificate Provider
                                        
    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    DWORD                               dwExtra[40];

} CRYPT_PROVIDER_CERT_ORMORE, *PCRYPT_PROVIDER_CERT_ORMORE;

typedef struct _CRYPT_PROVIDER_CERT_ORLESS
{
    DWORD                               cbStruct;
                                        
    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!
                                        
    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider
                                        
    BOOL                                fTestCert;          // certchk policy will set
                                        
    DWORD                               dwRevokedReason;
                                        
    DWORD                               dwConfidence;       // set in the Certificate Provider
                                        
    DWORD                               dwError;

} CRYPT_PROVIDER_CERT_ORLESS, *PCRYPT_PROVIDER_CERT_ORLESS;



#ifdef __cplusplus
}
#endif

#endif // WTORIDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\calchash\calchash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\wvtstrss\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wvtstrss.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_MODINF                11
#define IDS_PARAMTEXT_MODINF            12
#define IDS_PARAM_VSTRING               13
#define IDS_PARAMTEXT_VSTRING           14
#define IDS_PARAM_INFTAGCHKSTRING       15
#define IDS_PARAMTEXT_INFTAGCHKSTRING   16
#define IDS_PARAM_COUNT                 17
#define IDS_PARAMTEXT_COUNT             18
#define IDS_PARAM_TESTCAT               19
#define IDS_PARAMTEXT_TESTCAT           20
#define IDS_PARAM_TESTDRIVER            21
#define IDS_PARAMTEXT_TESTDRIVER        22
#define IDS_PARAM_TESTCERT              23
#define IDS_PARAMTEXT_TESTCERT          24
#define IDS_PARAM_CATPREPATH            25
#define IDS_PARAMTEXT_CATPREPATH        26

#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tests\wvtstrss\wvtstrss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtstrss.cpp
//
//  Contents:   WinVerifyTrust Stress
//
//  History:    13-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

typedef struct LOOPDATA_
{
    WCHAR       *pwszFileName;
    GUID        *pgProvider;

    WCHAR       *pwszCatalogFile;
    WCHAR       *pwszTag;

    DWORD       dwExpectedError;

    DWORD       dwStateControl;

} LOOPDATA;

typedef struct CERTDATA_
{
    PCCERT_CONTEXT  pContext;

} CERTDATA;

#define WVTSTRSS_MAX_CERTS      4

CERTDATA    sCerts[WVTSTRSS_MAX_CERTS + 1];

GUID            gAuthCode       = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID            gDriver         = DRIVER_ACTION_VERIFY;
GUID            gCertProvider   = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

LOOPDATA    sGeneralTest[] =
{
    L"signing\\bad\\b_dig.cab",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\b_dig.exe",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\b_dig.ocx",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,

    L"signing\\good\\brill.cab",    &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good.cab",     &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\timstamp.cab", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.exe",     &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\signwold.exe", &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\wz_named.exe", &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,

    L"signing\\good\\b_ok.doc",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.xls",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.ppt",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"signing\\good\\good_pcb.exe", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good_pcb.cat", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good_pcb.cab", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"signing\\bad\\cert_pcb.cab",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.cat",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.exe",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.doc",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,

    L"signing\\bad\\sig_pcb.cab",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.cat",   &gAuthCode, NULL,                   NULL,          0x8009200e, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.exe",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.doc",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,

    L"catalogs\\test.p7s",          &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"catalogs\\testrev.exe",       &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedEXE",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\test2.exe",         &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedEXENoAttr", 0, WTD_STATEACTION_VERIFY,
    L"catalogs\\nosntest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"TestUnsignedCAB",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\signtest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedCAB",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlat",            0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlatNotThere", 0x800b0100, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"CloseTheHandle",      0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

LOOPDATA    sCatalogTest[] =
{
    L"catalogs\\publish.spc",       &gAuthCode, L"catalogs\\test.p7s",  L"publish.spc",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\publish.pvk",       &gAuthCode, L"catalogs\\test.p7s",  L"publish.pvk",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\regress.cdf",       &gAuthCode, L"catalogs\\test.p7s",  L"regress.cdf",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\regress2.cdf",      &gAuthCode, L"catalogs\\test.p7s",  L"regress2.cdf",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\testrev.exe",       &gAuthCode, L"catalogs\\test.p7s",  L"testrev.exe",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\test2.exe",         &gAuthCode, L"catalogs\\test.p7s",  L"test2.exe",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\nosntest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"nosntest.cab",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\signtest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"signtest.cab",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"create.bat",      0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlatNotThere",0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"CloseTheHandle",  0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

LOOPDATA    sDriverTest[] =
{
    L"calc.cnt",                    &gDriver,   L"wvtstrss\\dtest.cat", L"calc.cnt",        0, WTD_STATEACTION_VERIFY,
    L"calc.exe",                    &gDriver,   L"wvtstrss\\dtest.cat", L"calc.exe",        0, WTD_STATEACTION_VERIFY,
    L"cmd.exe",                     &gDriver,   L"wvtstrss\\dtest.cat", L"cmd.exe",         0, WTD_STATEACTION_VERIFY,
    L"close",                       &gDriver,   L"close",               L"cmd.exe",         0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

void _LoadCerts(void);

HGLOBAL     hglobRes    = NULL;
HCERTSTORE  hResStore   = NULL;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    LOOPDATA                *psData;
    LOOPDATA                *psUseTest;
    CERTDATA                *psCerts;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    WINTRUST_CATALOG_INFO   sWTCI;
    WINTRUST_CERT_INFO      sWTCC;
    WCHAR                   wszPrePath[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwCount;
    HRESULT                 hResult;
    DWORD                   dwTotalFiles;
    int                     i;
    int                     iRet;
    BOOL                    fVerbose;
    BOOL                    fCheckCerts;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    iRet                = 0;

    dwTotalFiles        = 0;
    dwCount             = 1;
    psUseTest           = &sGeneralTest[0];
    fCheckCerts         = FALSE;
    wszPrePath[0]       = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_COUNT,        IDS_PARAMTEXT_COUNT,        WARGV_VALUETYPE_DWORDD, NULL);
    pArgs->Add2List(IDS_PARAM_CATPREPATH,   IDS_PARAMTEXT_CATPREPATH,   WARGV_VALUETYPE_WCHAR, NULL);
    pArgs->Add2List(IDS_PARAM_TESTCAT,      IDS_PARAMTEXT_TESTCAT,      WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_TESTDRIVER,   IDS_PARAMTEXT_TESTDRIVER,   WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_TESTCERT,     IDS_PARAMTEXT_TESTCERT,     WARGV_VALUETYPE_BOOL, (void *)FALSE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());

        goto NeededHelp;
    }


    fVerbose            = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->GetValue(IDS_PARAM_CATPREPATH))
    {
        wcscpy(&wszPrePath[0], (WCHAR *)pArgs->GetValue(IDS_PARAM_CATPREPATH));

        if (wszPrePath[wcslen(&wszPrePath[0]) - 1] != L'\\')
        {
            wcscat(&wszPrePath[0], L"\\");
        }
    }

    if (pArgs->GetValue(IDS_PARAM_TESTCAT))
    {
        psUseTest       = &sCatalogTest[0];
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTDRIVER))
    {
        psUseTest       = &sDriverTest[0];
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTCERT))
    {
        psUseTest       = NULL;
        fCheckCerts     = TRUE;

        _LoadCerts();
    }

    if (pArgs->GetValue(IDS_PARAM_COUNT))
    {
        dwCount = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_COUNT));
    }


    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));
    memset(&sWTFI,  0x00,   sizeof(WINTRUST_FILE_INFO));
    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));
    memset(&sWTCC,  0x00,   sizeof(WINTRUST_CERT_INFO));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);

    sWTCI.cbStruct          = sizeof(WINTRUST_CATALOG_INFO);

    sWTCC.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    sWTCC.pcwszDisplayName  = L"WVTSTRSS";

    //
    //  start our timer
    //
    tStart              = COleDateTime::GetCurrentTime();

    for (i = 0; i < (int)dwCount; i++)
    {
        psData  = psUseTest;

        if (psData)
        {
            while (psData->pwszFileName)
            {
                wcscpy(&wszFile[0], &wszPrePath[0]);
                wcscat(&wszFile[0], psData->pwszFileName);

                sWTD.dwStateAction              = psData->dwStateControl;

                if (psData->pwszCatalogFile)
                {
                    sWTD.dwUnionChoice          = WTD_CHOICE_CATALOG;
                    sWTD.pCatalog               = &sWTCI;
                    sWTCI.pcwszCatalogFilePath  = psData->pwszCatalogFile;
                    sWTCI.pcwszMemberTag        = psData->pwszTag;
                    sWTCI.pcwszMemberFilePath   = &wszFile[0];
                }
                else
                {
                    sWTD.dwUnionChoice          = WTD_CHOICE_FILE;
                    sWTD.pFile                  = &sWTFI;
                    sWTFI.pcwszFilePath         = &wszFile[0];
                }

                hResult = WinVerifyTrust(NULL, psData->pgProvider, &sWTD);

                if (fVerbose)
                {
                    wprintf(L"\nround %d: 0x%08.8x: %s", i, hResult, &wszFile[0]);
                }

                dwTotalFiles++;

                psData++;
            }
        }
        else if (fCheckCerts)
        {
            psCerts = &sCerts[0];

            while (psCerts->pContext)
            {
                sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
                sWTD.pCert                  = &sWTCC;
                sWTCC.psCertContext         = (CERT_CONTEXT *)psCerts->pContext;

                hResult = WinVerifyTrust(NULL, &gCertProvider, &sWTD);

                if (fVerbose)
                {
                    wprintf(L"\nround %d: 0x%08.8x", i, hResult);
                }

                dwTotalFiles++;

                psCerts++;
            }
        }
    }

    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n\nTotal files verified:   %ld", dwTotalFiles);
    printf("\nProcessing time:          %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage seconds per file: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotalFiles);
    printf("\n");

    CommonReturn:
        DELETE_OBJECT(pArgs);

        for (i = 0; i < WVTSTRSS_MAX_CERTS; i++)
        {
            if (sCerts[i].pContext)
            {
                CertFreeCertificateContext(sCerts[i].pContext);
            }
        }

        if (hResStore)
        {
            CertCloseStore(hResStore, 0);
        }

        if (hglobRes)
        {
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }


        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

void _LoadCerts(void)
{
    HRSRC               hrsrc;
    int                 i;
    CRYPT_DATA_BLOB     sBlob;
    PCCERT_CONTEXT      pCert;

    for (i = 0; i < (WVTSTRSS_MAX_CERTS + 1); i++)
    {
        sCerts[i].pContext = NULL;
    }

    if (hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_CERTS), TEXT("CERTS")))
    {
        if (hglobRes = LoadResource(GetModuleHandle(NULL), hrsrc))
        {
            sBlob.cbData = SizeofResource(GetModuleHandle(NULL), hrsrc);
            sBlob.pbData = (BYTE *)LockResource(hglobRes);

            hResStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED,
                                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      NULL,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      &sBlob);

            if (!(hResStore))
            {
                return;
            }

            i       = 0;
            pCert   = NULL;
            while ((pCert = CertEnumCertificatesInStore(hResStore, pCert)) !=NULL)
            {
                sCerts[i].pContext = CertDuplicateCertificateContext(pCert);
                i++;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\calchash\usage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usage.h
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef USAGE_H
#define USAGE_H

extern BOOL     ParseArgs(int argc, WCHAR **wargv);
extern void     Usage(void);

#endif // USAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\calchash\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_FILENAME          8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\chckhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\calchash\calchash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>
#include    <malloc.h>
#include    <memory.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"


WCHAR       *pwszFile    = NULL;
PrintfU_    *pPrint         = NULL;
int         iRet            = 0;

WCHAR       gszUsage[] = L"usage: calchash filename\n   -?:         this screen\n"  ;

const char     RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FormatHashString(LPSTR *ppString, DWORD cbBlob, BYTE *pblob)
{
    DWORD   i, j = 0;
    BYTE    *pb = NULL;
    DWORD   numCharsInserted = 0;
    LPSTR   psz;

    *ppString = NULL;
    pb = pblob;
    
    // fill the buffer
    i=0;
    while (j < cbBlob) 
    {
        if ((*ppString) == NULL)
        {
            psz = NULL;
            *ppString = (LPSTR) malloc(3 * sizeof(char));
        }
        else
        {
            psz = *ppString;
            *ppString = (LPSTR) realloc(*ppString, (j+1) * 3 * sizeof(char));
        }

        if (*ppString == NULL)
        {
            if (psz != NULL)
            {
                free(psz);                
            }

            return;
        }

        (*ppString)[i++] = RgchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgchHex[*pb & 0x0f];
        (*ppString)[i++] = ' ';
        
        pb++;
        j++;
    }
    
    (*ppString)[i-1] = 0;
}


extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                 cMember;
    cWArgv_             *pArgs;
    BOOL                fFailed;
    CRYPTCATCDF         *pCDF;
    CRYPTCATMEMBER      *pMember;
    LPWSTR              pwszMemberTag;
    CRYPTCATATTRIBUTE   *pAttr;
    BOOL                fContinueOnError;
    BYTE                pbHash[40];
    DWORD               cbHash = sizeof(pbHash);
    HANDLE               hFile;
    LPSTR               psz;

    pCDF = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_OPTPARAM, IDS_USAGETEXT_FILENAME, IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);
    
    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", gszUsage);
        goto NeededHelp;
    }

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s",gszUsage);
        goto ParamError;
    }

    pPrint = new PrintfU_;

    SetLastError(0);

    if ((hFile = CreateFileU(pwszFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        
        wprintf(L"Cannot open file - GLE = %lx\n", GetLastError());
        goto CATCloseError;
    }

    if (!CryptCATAdminCalcHashFromFileHandle(hFile, 
                                             &cbHash, 
                                             pbHash,
                                             0))
    {
        goto CATCloseError;
    }
    
    FormatHashString(&psz, cbHash, pbHash);
    if (psz != NULL)
    {
        printf("%s\n", psz);
        free(psz);
    }
    else
    {
        goto MemoryError;
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\catdbchk\catdbchk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcatdb.cpp
//
//  Contents:   
//
//              
//
//
//  Functions:  main
//
//  History:    11-Apr-00   reidk   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "mscat.h"
#include "unicode.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <memory.h>
#include <time.h>

#include "catutil.h"

#define WSZ_CATALOG_NEW_BASE_DIRECTORY      L"CatRoot2"

typedef struct _CTL_SLOT
{
    PCCTL_CONTEXT   pCTLContext;
    HANDLE          hMappedFile;
    BYTE            *pbMappedFile;
    LPWSTR          pwszCatalog;

} CTL_SLOT, *PCTL_SLOT;


GUID            g_guidCatRoot;
BOOL            g_fUseSingleContext = TRUE;
BOOL            g_fDatabaseConsistencyCheck = FALSE;
BOOL            g_fUseDefaultGUID = FALSE;
BOOL            g_fVerbose = FALSE;
BOOL            g_fDatabaseReverseConsistencyCheck = FALSE;
WCHAR           g_wszDefaultSystemDir[MAX_PATH + 1];

LPWSTR          g_pwszCatalogDir = NULL;
WCHAR           g_wszSubSysGUID[1024];
LPWSTR          g_pwszCatalogSearchString = NULL;


const char     RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FormatHashString(LPSTR *ppString, DWORD cbBlob, BYTE *pblob)
{
    DWORD   i, j = 0;
    BYTE    *pb = NULL;
    DWORD   numCharsInserted = 0;
    LPSTR   psz;

    *ppString = NULL;
    pb = pblob;
    
    // fill the buffer
    i=0;
    while (j < cbBlob) 
    {
        if ((*ppString) == NULL)
        {
            psz = NULL;
            *ppString = (LPSTR) malloc(3 * sizeof(char));
        }
        else
        {
            psz = *ppString;
            *ppString = (LPSTR) realloc(*ppString, (j+1) * 3 * sizeof(char));
        }

        if (*ppString == NULL)
        {
            if (psz != NULL)
            {
                free(psz);                
            }

            return;
        }

        (*ppString)[i++] = RgchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgchHex[*pb & 0x0f];
        (*ppString)[i++] = ' ';
        
        pb++;
        j++;
    }
    
    (*ppString)[i-1] = 0;
}

//---------------------------------------------------------------------------------------
//
//  FindAndDecodeHashInCatEntry
//
//---------------------------------------------------------------------------------------
BOOL
FindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectData)
{
    BOOL    fRet = TRUE;
    DWORD   i;
    DWORD   cbIndirectData = 0;

    *ppIndirectData = NULL;

    //
    // Search for the hash in the attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
        {
            break;
        }
    }

    //
    // Make sure the hash was found
    //
    if (i >= pctlEntry->cAttribute)
    {
        printf("Unexpected error... hash not found in CTL entry\n");
        goto ErrorReturn;
    }

    //
    // decode the indirect data
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                NULL,
                &cbIndirectData))
    {
        printf("CryptDecodeObject failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

    if (NULL == (*ppIndirectData = (SPC_INDIRECT_DATA_CONTENT *) 
                    malloc(cbIndirectData)))
    {
        printf("malloc failure\n");
        goto ErrorReturn;
    }

    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                *ppIndirectData,
                &cbIndirectData))
    {
        printf("CryptDecodeObject failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }
    
CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

}


BOOL 
CheckCatFileEntries(HCATADMIN hCatAdmin, LPWSTR pwszCatalogFile)
{
    BOOL                        fRet = TRUE;
    PCCTL_CONTEXT               pCTLContext = NULL;
    HANDLE                      hMappedFile = NULL;
    BYTE                        *pbMappedFile = NULL;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData = NULL;
    HCATINFO                    hCatInfo; 
    BOOL                        fCatalogFound;
    CATALOG_INFO                sCatInfo;
    LPSTR                       pszHash = NULL;
    HCATADMIN                   hCatAdminLocal = NULL;
    
    LPWSTR                      pwszShortCatName = wcsrchr(pwszCatalogFile, L'\\');
    pwszShortCatName++;

    if (g_fVerbose)
    {
        printf("    Processing cat file: %S\n", pwszShortCatName);
    }

    //
    // Open, and create a file mapping of the catalog file
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalogFile,
            &hMappedFile, 
            &pbMappedFile, 
            &pCTLContext,                         
            FALSE))
    {
        printf("    Error opening catalog file: %S\n", pwszCatalogFile);
        goto ErrorReturn;
    }

    //
    // Go through each entry in the catalog
    //
    for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (!FindAndDecodeHashInCatEntry(
                &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                &pIndirectData))
        {
            goto ErrorReturn;
        }
        
        if (!g_fUseSingleContext)
        {
            if (!(CryptCATAdminAcquireContext(&hCatAdminLocal, &g_guidCatRoot, 0)))
            {
                printf("    CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
                goto ErrorReturn;
            }
        }
        
        fCatalogFound = FALSE;
        hCatInfo = NULL;
        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(
                            g_fUseSingleContext ? hCatAdmin : hCatAdminLocal,
                            pIndirectData->Digest.pbData,
                            pIndirectData->Digest.cbData,
                            0,
                            &hCatInfo))
        {
            memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
            sCatInfo.cbStruct = sizeof(CATALOG_INFO);
            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                printf("    CryptCATCatalogInfoFromContext failure\nGLE = %lx\n", GetLastError());
                goto ErrorReturn;
            }

            if (_wcsicmp(&(sCatInfo.wszCatalogFile[0]), pwszCatalogFile) == 0)
            {
                fCatalogFound = TRUE;
                break;
            }
        }

        if (!fCatalogFound)
        {
            FormatHashString(&pszHash, pIndirectData->Digest.cbData, pIndirectData->Digest.pbData); 
            printf("    FAILURE: Could not enum: %S\n   from hash: %s\n", pwszShortCatName, pszHash);
            if (g_fVerbose)
            {
                printf("        GLE: %lx\n", GetLastError());
            }
        }

        if (!g_fUseSingleContext)
        {
            CryptCATAdminReleaseContext(hCatAdminLocal, NULL);
            hCatAdminLocal = NULL;
        }

        free(pIndirectData);
        pIndirectData = NULL;
    }
    

CommonReturn:
    
    if (pIndirectData != NULL)
    {
        free(pIndirectData);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (pszHash != NULL)
    {
        free(pszHash);
    }

    if (hCatAdminLocal != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdminLocal, NULL);
    }
    
    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL DoDatabaseConsistencyCheck()
{
    BOOL                fRet = TRUE;
    HCATADMIN           hCatAdmin = NULL;
    LPWSTR              pwszCatalogFile = NULL;
    HANDLE              hFindHandleCatalogsInDir = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatalogsInDir;
    PCCTL_CONTEXT       pCTLContext = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hMappedFile = NULL;
    DWORD               cbFile = 0;
    BYTE                *pbMappedFile = NULL;

    printf("Starting database consistency check\n");

    if (g_fUseSingleContext)
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, &g_guidCatRoot, 0)))
        {
            printf("    CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
            goto ErrorReturn;
        }
    }

    //
    // Find each catalog in the dir
    //

    //
    // Start the catalog enumeration
    //
    hFindHandleCatalogsInDir = FindFirstFileW(
                                    g_pwszCatalogSearchString, 
                                    &FindDataCatalogsInDir);
    
    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        // no files found
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            SetLastError(0);
        }
        else
        {
            goto ErrorReturn;
        }
    }
    else
    { 
        while (1)
        {
            if ((wcscmp(FindDataCatalogsInDir.cFileName, L".") != 0)     &&
                (wcscmp(FindDataCatalogsInDir.cFileName, L"..") != 0)    &&
                (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = (LPWSTR)
                                malloc(sizeof(WCHAR) * 
                                            (wcslen(g_pwszCatalogDir) +
                                             wcslen(FindDataCatalogsInDir.cFileName) +
                                             1))))
                {
                    printf("    malloc failure\n");     
                    goto ErrorReturn;
                }
                wcscpy(pwszCatalogFile, g_pwszCatalogDir);
                wcscat(pwszCatalogFile, FindDataCatalogsInDir.cFileName);

                //
                // Verify that this is a catalog 
                //
                if (IsCatalogFile(NULL, pwszCatalogFile))
                {
                    CheckCatFileEntries(hCatAdmin, pwszCatalogFile);                                       
                }
                else
                {
                    LPWSTR pwsz = wcsrchr(pwszCatalogFile, L'\\');
                    pwsz++;
                    if (_wcsicmp(pwsz, L"CatDB") != 0)
                    {
                        printf("    File found that is not a catalog file: %s\n", pwsz);     
                    }
                }

                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }

            //
            // Get next catalog file
            //
            if (!FindNextFileW(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))            
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    goto ErrorReturn;
                }
            }
        }
    }

CommonReturn:

    printf("Database consistency check complete\n");

    if (pwszCatalogFile != NULL)
    {
        free(pwszCatalogFile);
    }

    if (hFindHandleCatalogsInDir != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatalogsInDir);
    }

    if (hCatAdmin != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdmin, NULL);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}





static void Usage(void)
{
    printf("Usage: tcatdb [options] <GUID>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -v                    - Verbose output\n");
    printf("  -d                    - Use default GUID (system GUID)\n");
    printf("  -c                    - Check database consistency\n");
    printf("  -s                    -       Use a single HCATADMIN for all calls (default)\n");
    printf("  -n                    -       Use a new HCATADMIN for every call\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[])
{
    LPSTR       pszGUID = NULL;
    WCHAR       wsz[1024];
    int         ret = 0;
    LPSTR       pszCatalogToDelete = NULL;
    HCATADMIN   hCatAdminLocal = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
            case 'C':
                g_fDatabaseConsistencyCheck = TRUE;
                break;
            case 'd':
            case 'D':
                g_fUseDefaultGUID = TRUE;
                break;
            case 's':
            case 'S':
                g_fUseSingleContext = TRUE;
                break;
            case 'n':
            case 'N':
                g_fUseSingleContext = FALSE;
                break;
            case 'v':
            case 'V':
                g_fVerbose = TRUE;
                break;
            
            case 'h':
            case 'H':
            default:
                Usage();
                return -1;
            }
        } else
            pszGUID = argv[0];
    }

    if (!g_fUseDefaultGUID && (pszGUID == NULL))
    {
        printf("missing <GUID>\n");
        Usage();
        return -1;
    }
    else if (g_fUseDefaultGUID)
    {
        wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &g_guidCatRoot);
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszGUID, -1, wsz, 1024);

        if (!(wstr2guid(wsz, &g_guidCatRoot)))
        {
            return -1;
        }
    }
    
    //
    // setup defaults
    //
    guid2wstr(&g_guidCatRoot, g_wszSubSysGUID);

    g_wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(&g_wszDefaultSystemDir[0], MAX_PATH))
    {
        printf("GetSystemDirectory failure\nGLE = %lx\n", GetLastError());            
        goto ErrorReturn;
    }

    if (NULL == (g_pwszCatalogDir = (LPWSTR) 
                    malloc(sizeof(WCHAR) * 
                            (wcslen(g_wszDefaultSystemDir) + 
                            wcslen(WSZ_CATALOG_NEW_BASE_DIRECTORY) +
                            wcslen(g_wszSubSysGUID) +
                            4))))
    {
        printf("malloc failure\n");            
        goto ErrorReturn;
    }
    wcscpy(g_pwszCatalogDir, g_wszDefaultSystemDir);
    if ((g_pwszCatalogDir[0]) && 
        (g_pwszCatalogDir[wcslen(&g_wszDefaultSystemDir[0]) - 1] != L'\\'))
    {
        wcscat(g_pwszCatalogDir, L"\\");
    }
    wcscat(g_pwszCatalogDir, WSZ_CATALOG_NEW_BASE_DIRECTORY);
    wcscat(g_pwszCatalogDir, L"\\");
    wcscat(g_pwszCatalogDir, g_wszSubSysGUID);
    wcscat(g_pwszCatalogDir, L"\\");

    //
    // make the search string
    //
    if (NULL == (g_pwszCatalogSearchString = (LPWSTR) 
                    malloc(sizeof(WCHAR) * 
                            (wcslen(g_wszDefaultSystemDir) + 
                            wcslen(WSZ_CATALOG_NEW_BASE_DIRECTORY) +
                            wcslen(g_wszSubSysGUID) +
                            wcslen(L"*") +
                            4))))
    {
        printf("    malloc failure\n");            
        goto ErrorReturn;
    }
    wcscpy(g_pwszCatalogSearchString, g_wszDefaultSystemDir);
    if ((g_pwszCatalogSearchString[0]) && 
        (g_pwszCatalogSearchString[wcslen(&g_wszDefaultSystemDir[0]) - 1] != L'\\'))
    {
        wcscat(g_pwszCatalogSearchString, L"\\");
    }
    wcscat(g_pwszCatalogSearchString, WSZ_CATALOG_NEW_BASE_DIRECTORY);
    wcscat(g_pwszCatalogSearchString, L"\\");
    wcscat(g_pwszCatalogSearchString, g_wszSubSysGUID);
    wcscat(g_pwszCatalogSearchString, L"\\");
    wcscat(g_pwszCatalogSearchString, L"*");


    //
    // run requested operations
    //
    
    if (g_fDatabaseConsistencyCheck)
    {
        DoDatabaseConsistencyCheck();
    }

    //
    // cleanup
    //
CommonReturn:

    if (hCatAdminLocal != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdminLocal, 0);
    }

    if (g_pwszCatalogDir != NULL)
    {
        free(g_pwszCatalogDir);
    }
    if (g_pwszCatalogSearchString != NULL)
    {
        free(g_pwszCatalogSearchString);
    }

    printf("Done\n");
    return (ret);

ErrorReturn:
    ret = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\dumpcat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\chckhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  main
//
//  History:    05-May-1999 reidk   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>
#include    <malloc.h>
#include    <memory.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"

static void Usage(void)
{
    printf("Usage: chckhash [options] filename\n");
    printf("Options are:\n");
    printf("  -?                    - This message\n");
    printf("  -catdb <param>        - The catroot to search (default is the system DB)\n");
    printf("  -r [0|1]              - Called from regress, 0 implies not found is expected, 1 implies found is expected\n");
    printf("  -l                    - Filename is a list of hyphen seperated files\n");
    printf("  -p                    - Expect 'paused' failure\n");
    printf("\n");
}

int __cdecl main(int argc, char * argv[])
{
    int             cMember;
    BYTE            pbHash[40];
    DWORD           cbHash              = sizeof(pbHash);
    HANDLE          hFile;
    HCATINFO        hCatInfo;
    BOOL            fFileFound          = FALSE;
    CATALOG_INFO    sCatInfo;
    LPSTR           pszGUID             = NULL;
    LPWSTR          pwszGUID            = NULL;
    BOOL            fCalledFromRegress  = FALSE;
    BOOL            fFoundExpected      = FALSE;
    BOOL            fFileList           = FALSE;
    BOOL            fExpectPaused        = FALSE;
    char            *pszFile            = NULL;
    int             iRet                = 1;
    GUID            guidPassedIn        = DRIVER_ACTION_VERIFY;
    GUID            *pguidCatRoot       = NULL;
    HCATADMIN       hCatAdmin           = NULL;
    char            *pChar              = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
            case 'C':
                argv++;
                argc--;
                pszGUID = argv[0];
                break;

            case 'r':
            case 'R':
                argv++;
                argc--;
                fCalledFromRegress = TRUE;
                fFoundExpected = (argv[0][0] == '1');
                break;  
                
            case 'l':
            case 'L':
                fFileList = TRUE;
                break; 
                
            case 'p':
            case 'P':
                fExpectPaused = TRUE;
                break;  
            
            case '?':
            default:
                Usage();
                return 1;
            }
        } 
        else
        {
            pszFile = argv[0];
        }
            
    }

    SetLastError(0);

    //
    //  get provider
    //
    if (pszGUID != NULL)
    {
        if (NULL == (pwszGUID = MkWStr(pszGUID)))
        {
            goto ErrorReturn;
        }
        
        if (!(wstr2guid(pwszGUID, &guidPassedIn)))
        {
            FreeWStr(pwszGUID);
            goto ErrorReturn;
        }        
        FreeWStr(pwszGUID);
    }
    pguidCatRoot   = &guidPassedIn;
    
    if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
    {
        printf("CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

    while (pszFile != NULL)
    {
        if (fFileList)
        {
            pChar = strchr(pszFile, '-');
            if (pChar != NULL)
            {
                *pChar = '\0';
            }
        }

        //
        // Open the file who's hash is being looked up, then calculate its hash
        //
        if ((hFile = CreateFileA(pszFile,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            printf("Cannot open file\nGLE = %lx\n", GetLastError());
            goto CATCloseError;
        }

        if (!CryptCATAdminCalcHashFromFileHandle(hFile, 
                                                 &cbHash, 
                                                 pbHash,
                                                 0))
        {
            printf("Cannot calculate file hash\nGLE = %lx\n", GetLastError());
            goto CATCloseError;
        }
    
        hCatInfo = NULL;
        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, &hCatInfo))
        {
            fFileFound = TRUE;

            memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
            sCatInfo.cbStruct = sizeof(CATALOG_INFO);

            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                // should do something (??)
                continue;
            }

            if (!fCalledFromRegress)
            {
                printf("%S contains %s\n", &sCatInfo.wszCatalogFile[0], pszFile); 
            }
        }

        if (fCalledFromRegress)
        {
            if (fFileFound)
            {
                if (fFoundExpected)
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else
                {
                    printf("Failed: %s should NOT have been found\n", pszFile);
                    iRet = 0;
                }                
            }
            else
            {
                if (fFoundExpected)
                {
                    printf("Failed: %s was not found: GLE - %lx\n", pszFile, GetLastError());
                    iRet = 0;
                }
                else if ((GetLastError() == ERROR_SHARING_PAUSED) && (fExpectPaused))
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else if (GetLastError() == ERROR_NOT_FOUND)
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else
                {
                    if (fExpectPaused)
                    {
                        printf("Failed: ERROR_SHARING_PAUSED expected, but got %lx\n", GetLastError());
                    }
                    else
                    {
                        printf("Failed: ERROR_NOT_FOUND expected, but got %lx\n", GetLastError());
                    }
                }
            }
        }
        else if (!fFileFound)
        {
             printf("There are no catalog files registered that contain %s: GLE - %lx\n", pszFile, GetLastError());
        }

        if (fFileList)
        {
            if (pChar != NULL)
            {
                pszFile = ((LPSTR) pChar) + 1;
            }
            else
            {
                pszFile = NULL;
            }
        }
        else
        {
            pszFile = NULL;
        }
    }

CommonReturn:
    
    if (hCatAdmin)
    {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return(iRet);

ErrorReturn:
    iRet = 0;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\dumpcat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dumpcat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    21-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _DisplayStore(CRYPTCATSTORE *pStore);
void _DisplayMember(CRYPTCATMEMBER *pMember);
void _DisplayAttribute(CRYPTCATATTRIBUTE *pAttr, BOOL fCatalogLevel);

BOOL        fVerbose        = FALSE;
BOOL        fTesting        = FALSE;
DWORD       dwExpectedError = 0;

DWORD       dwTotal         = 0;

WCHAR       *pwszFile       = NULL;

int         iRet            = 0;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    HANDLE                  hCatStore;
    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;


    hCatStore  = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,    WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,   WARGV_VALUETYPE_DWORDH, NULL, TRUE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose        = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fTesting        = TRUE;
    }

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    SetLastError(0);

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    if ((hCatStore = CryptCATOpen(pwszFile, 0, NULL, 0, 0)) == INVALID_HANDLE_VALUE)
    {
        goto CatOpenError;
    }

    CRYPTCATSTORE       *pStore;
    CRYPTCATMEMBER      *pMember;
    CRYPTCATATTRIBUTE   *pAttr;

    printf("\n");
    wprintf(L"\nCatalog File: %s", pwszFile);

    if (pStore = CryptCATStoreFromHandle(hCatStore))
    {
        if (fVerbose)
        {
            _DisplayStore(pStore);
        }
    }

    pAttr = NULL;
    while (pAttr = CryptCATEnumerateCatAttr(hCatStore, pAttr))
    {
        if (fVerbose)
        {
            _DisplayAttribute(pAttr, TRUE);
        }
    }

    pMember = NULL;
    while (pMember = CryptCATEnumerateMember(hCatStore, pMember))
    {
        dwTotal++;

        if (fVerbose)
        {
            _DisplayMember(pMember);
        }

        pAttr = NULL;
        while (pAttr = CryptCATEnumerateAttr(hCatStore, pMember, pAttr))
        {
            if (fVerbose)
            {
                _DisplayAttribute(pAttr, FALSE);
            }
        }
    }

    //
    //  end timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTiming:");
    printf("\n  Processing time:    %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\n  Total members:      %lu", dwTotal);
    printf("\n  Average per member: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\n");

    iRet = 0;

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hCatStore)
        {
            CryptCATClose(hCatStore);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CatOpenError);
}
void _DisplayStore(CRYPTCATSTORE *pStore)
{
    wprintf(L"\n    Catalog Store Info:");
    wprintf(L"\n        dwPublicVersion:    0x%08.8lX", pStore->dwPublicVersion);
    wprintf(L"\n        dwEncodingType:     0x%08.8lX", pStore->dwEncodingType);
}

void _DisplayMember(CRYPTCATMEMBER *pMember)
{
    wprintf(L"\n        member:             ");

    if ((pMember->pIndirectData) &&
        (pMember->pIndirectData->Digest.pbData))
    {
        DWORD   i;

        for (i = 0; i < pMember->pIndirectData->Digest.cbData; i++)
        {
            printf("%02.2X", pMember->pIndirectData->Digest.pbData[i]);
        }
    }
    else
    {
        BYTE        bEmpty[21];

        memset(&bEmpty[0], ' ', 20);
        bEmpty[20] = 0x00;

        printf("%s", &bEmpty[0]);
    }

    wprintf(L"  %s", pMember->pwszReferenceTag);
}

void _DisplayAttribute(CRYPTCATATTRIBUTE *pAttr, BOOL fCatalogLevel)
{
    if (fCatalogLevel)
    {
        wprintf(L"\n        attribute:          ");
    }
    else
    {
        wprintf(L"\n            attribute:      ");
    }

    wprintf(L"%s   ", pAttr->pwszReferenceTag);

    DWORD   i;

    for (i = 0; i < pAttr->cbValue; i++)
    {
        printf("%c", pAttr->pbValue[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\makecat\makecat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_PARAM_GUID                  5
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_FILENAME          8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_PARAMTEXT_GUID              17
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\chktrust\chktrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chktrust.cpp
//
//  Contents:   Microsoft Internet Security Trust Checker
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    <stdio.h>
#include    <windows.h>
#include    <io.h>	
#include    <wchar.h>					

#include    "cryptreg.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "mscat.h"
#include    "unicode.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "cwargv.hxx"
#include    "printfu.hxx"

#include    "mssip.h"
#include    "resource.h"

HRESULT _CallWVT(WCHAR *pwszFilename);
HRESULT _ExplodeCatalog(WCHAR *pwszCatalogFile);
HRESULT _CallCatalogWVT(WCHAR *pwszCatalogFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile);
int     _ShowError(DWORD dwError, WCHAR *pwszFile);
void    _ToLower(WCHAR *pwszInOut);
HRESULT _AddCatalogToDatabase(WCHAR *pwszFileIn);
HRESULT _DelCatalogFromDatabase(WCHAR *pwszFileIn);


GUID        guidPublishedSoftware   = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID        guidProviderTest        = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
GUID        guidProviderDriver      = DRIVER_ACTION_VERIFY;
GUID        guidPassedIn;
GUID        guidCatRoot;

GUID        *pguidActionID          = &guidPublishedSoftware;
GUID        *pguidCatRoot           = NULL;

DWORD       dwExpectedError         = ERROR_SUCCESS;

WCHAR       *pwszCatalogFile        = NULL;
WCHAR       *pwszCatalogMember      = NULL;
WCHAR       *pwszOSVerLow           = NULL;
WCHAR       *pwszOSVerHigh          = NULL;
BOOL        fUseOldDriverVerInfoSize = FALSE;

PrintfU_    *pPrint                 = NULL;

HCATADMIN   hCatAdmin               = NULL;

BOOL        fVerbose;
BOOL        fQuiet;
BOOL        fIECall;
BOOL        fTestDump;
BOOL        fCheckExpectedError     = FALSE;
BOOL        fProcessAllCatMembers;
BOOL        fCatalogMemberVerify    = FALSE;
BOOL        fUseCatalogDatabase;
BOOL        fAdd2CatalogDatabase;
BOOL        fDelFromCatalogDatabase;
BOOL        fReplaceCatfile;
BOOL        fNT5;
#if (0) //DSIE: Remove, since this is a feature not used by anyone, and the API it
        //      needs, CryptCatAdminPauseServiceForBackup, is not available in Win2K.
BOOL        fPause;
BOOL        fResume;
#endif
BOOL        fNoTimeStampWarning;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATAW        sFindData;

    int                     iRet;
    HRESULT                 hr = ERROR_SUCCESS;

    WCHAR                   *pwszFileIn;
    WCHAR                   *pwszLastSlash;
    WCHAR                   wszFile[MAX_PATH];
    WCHAR                   wszDir[MAX_PATH];
    char                    szFile[MAX_PATH * 2];
    DWORD                   dwFiles;
    DWORD                   dwDirLen;

    iRet    = 0;
    pPrint  = NULL;
    hFind   = INVALID_HANDLE_VALUE;
    dwFiles = 0;

    if (!(pPrint = new PrintfU_()))
    {
        goto MemoryError;
    }

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed, FALSE)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_QUIET,        IDS_PARAMTEXT_QUIET,        WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_TPROV,        IDS_PARAMTEXT_TPROV,        WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_IECALL,       IDS_PARAMTEXT_IECALL,       WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_TESTDUMP,     IDS_PARAMTEXT_TESTDUMP,     WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,     WARGV_VALUETYPE_DWORDH, NULL,        TRUE);
    pArgs->Add2List(IDS_PARAM_TESTDRV,      IDS_PARAMTEXT_TESTDRV,      WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATFILE,      IDS_PARAMTEXT_CATFILE,      WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_CATMEMBER,    IDS_PARAMTEXT_CATMEMBER,    WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_ALLCATMEM,    IDS_PARAMTEXT_ALLCATMEM,    WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATUSELIST,   IDS_PARAMTEXT_CATUSELIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATADDLIST,   IDS_PARAMTEXT_CATADDLIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATDELLIST,   IDS_PARAMTEXT_CATDELLIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_REPLACECATFILE,IDS_PARAMTEXT_REPLACECATFILE,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATROOT,      IDS_PARAMTEXT_CATROOT,      WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_NT5,          IDS_PARAMTEXT_NT5,          WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
#if (0) //DSIE
    pArgs->Add2List(IDS_PARAM_PAUSE,        IDS_PARAMTEXT_PAUSE,        WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_RESUME,       IDS_PARAMTEXT_RESUME,       WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
#endif
    pArgs->Add2List(IDS_PARAM_TSWARN,       IDS_PARAMTEXT_TSWARN,       WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_OSVERLOW,     IDS_PARAMTEXT_OSVERLOW,     WARGV_VALUETYPE_WCHAR, NULL, TRUE);
    pArgs->Add2List(IDS_PARAM_OSVERHIGH,    IDS_PARAMTEXT_OSVERHIGH,    WARGV_VALUETYPE_WCHAR, NULL, TRUE);
    
    
    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    pwszCatalogFile         = (WCHAR *)pArgs->GetValue(IDS_PARAM_CATFILE);
    pwszCatalogMember       = (WCHAR *)pArgs->GetValue(IDS_PARAM_CATMEMBER);
    fVerbose                = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    fQuiet                  = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_QUIET));
    fIECall                 = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_IECALL));
    fTestDump               = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_TESTDUMP));
    fProcessAllCatMembers   = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_ALLCATMEM));
    fUseCatalogDatabase     = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATUSELIST));
    fAdd2CatalogDatabase    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATADDLIST));
    fDelFromCatalogDatabase = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATDELLIST));
    fReplaceCatfile         = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_REPLACECATFILE));
    fNT5                    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NT5));
#if (0) //DSIE
    fPause                  = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_PAUSE));
    fResume                 = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_RESUME));
#endif
    fNoTimeStampWarning     = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_TSWARN));
    pwszOSVerLow            = (WCHAR *)pArgs->GetValue(IDS_PARAM_OSVERLOW);
    pwszOSVerHigh           = (WCHAR *)pArgs->GetValue(IDS_PARAM_OSVERHIGH);

#if (0) //DSIE    
    //
    // the pause and resume switches override everything
    //
    if (fPause)
    {
        if (!CryptCATAdminPauseServiceForBackup(0, FALSE))
        {
            hr = GetLastError();
        }
        iRet = _ShowError(hr, &wszFile[0]);
        goto CommonReturn;   
    }
    else if (fResume)
    {
        if(!CryptCATAdminPauseServiceForBackup(0, TRUE))
        {
            hr = GetLastError();
        }
        iRet = _ShowError(hr, &wszFile[0]);
        goto CommonReturn;
    }
#endif

    //
    // the win2k flag implies -q and -ucl (unless -acl or -del is used, then it just implies -q)
    //
    if (fNT5)
    {
        fQuiet = TRUE;
        if (!fAdd2CatalogDatabase  && !fDelFromCatalogDatabase)
        {
            fUseCatalogDatabase = TRUE;
        }
    }

    if (fUseCatalogDatabase || fNT5)
    {
        fCatalogMemberVerify = TRUE;
    }

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fCheckExpectedError = TRUE;
    }

    if (!(pwszFileIn = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if (((pwszCatalogFile) && !(pwszCatalogMember)) ||
        (!(pwszCatalogFile) && (pwszCatalogMember)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if ((pwszCatalogFile) && (pwszCatalogMember))
    {
        fCatalogMemberVerify = TRUE;
    }

    //
    //  set the appropriete provider
    //
    if (pArgs->IsSet(IDS_PARAM_TPROV) || fNT5)
    {
        if (fNT5)
        {
            wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidPassedIn);
        }
        else if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_TPROV), &guidPassedIn)))
        {
            goto GuidError;
        }

        pguidActionID   = &guidPassedIn;
    }
    else if (fTestDump)
    {
        pguidActionID   = &guidProviderTest;
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTDRV))
    {
        pguidActionID   = &guidProviderDriver;
    }
    else
    {
        pguidActionID   = &guidPublishedSoftware;
    }

    //
    // Get the catalog subsystem GUID to use
    //
    if (pArgs->IsSet(IDS_PARAM_CATROOT) || fNT5)
    {
        if (fNT5)
        {
            wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidCatRoot);
        }
        else if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_CATROOT), &guidCatRoot)))
        {
            goto GuidError;
        }

        pguidCatRoot   = &guidCatRoot;
    }

    //
    //  if we are calling just like IE, we only have one file and don't want to
    //  check if it exists or not... just call WVT.
    //
    if (fIECall)
    {
        dwFiles++;

        hr = _CallWVT(pwszFileIn);

        iRet = _ShowError(hr, pwszFileIn);

        goto CommonReturn;
    }

    //
    // Check to see if we are supposed to be using the old DRIVER_VER_INFO struct
    //
    while (--argc>0)
    {
        if (**++wargv == L'-')
        {
            if (wcscmp(*wargv, L"-UseOldDriverVerInfoStruct") == 0)
            {
                fUseOldDriverVerInfoSize = TRUE;
                break;
            }
        }
    }

    //
    // If a delete is being done, then just execute that and get out
    //
    if (fDelFromCatalogDatabase)
    {
        hr = _DelCatalogFromDatabase(pwszFileIn);
        iRet = _ShowError(hr, &wszFile[0]);
        goto CommonReturn;
    }
                

    //
    //  OK....   go into a findfirst/next loop we could have been called with *.*
    //
    if (pwszLastSlash = wcsrchr(pwszFileIn, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszFileIn);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }

#if (0) //DSIE: Bug 8213
    szFile[0] = NULL;
    WideCharToMultiByte(0, 0, pwszFileIn, -1, &szFile[0], MAX_PATH * 2, NULL, NULL);

    if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
    {
        pPrint->Display(IDS_CAN_NOT_OPEN_FILE, pwszFileIn);
        goto FileNotFound;
    }
#else
    if ((hFind = FindFirstFileU(pwszFileIn, &sFindData)) == INVALID_HANDLE_VALUE)
    {
        pPrint->Display(IDS_CAN_NOT_OPEN_FILE, pwszFileIn);
        goto FileNotFound;
    }
#endif

    fFind   = TRUE;
    dwFiles = 0;

    while (fFind)
    {
        if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (dwDirLen > 0)
            {
                wcscpy(&wszFile[0], &wszDir[0]);
            }

            wszFile[dwDirLen] = NULL;
#if (0)
            MultiByteToWideChar(0, 0, &sFindData.cFileName[0], -1, &wszFile[dwDirLen], MAX_PATH * sizeof(WCHAR));
#else
            wcscat(wszFile, sFindData.cFileName);
#endif

            if (wszFile[0])
            {
                if (fAdd2CatalogDatabase)
                {
                    hr = _AddCatalogToDatabase(&wszFile[0]);
                }
                else
                {
                    hr = _CallWVT(&wszFile[0]);
                }

                iRet = _ShowError(hr, &wszFile[0]);

                if (iRet == 0)
                {
                    hr = ERROR_SUCCESS;
                }

                dwFiles++;
            }
        }

#if (0)
        fFind = FindNextFile(hFind, &sFindData);
#else
        fFind = FindNextFileU(hFind, &sFindData);
#endif
	}

    if (dwFiles < 1)
    {
        pPrint->Display(IDS_CAN_NOT_OPEN_FILE, pwszFileIn);
        goto FileNotFound;
    }


    CommonReturn:
    
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }

        if (hCatAdmin)
        {
            CryptCATAdminReleaseContext(hCatAdmin, 0);
        }


        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, FileNotFound);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, GuidError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

HRESULT _CallWVT(WCHAR *pwszFilename)
{
    if (fCatalogMemberVerify)
    {
        return(_CallCatalogWVT(pwszCatalogFile, pwszCatalogMember, pwszFilename));
    }

    HRESULT                 hr;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = (fQuiet) ? WTD_UI_NONE : WTD_UI_ALL;
    sWTD.dwUnionChoice      = WTD_CHOICE_FILE;
    sWTD.pFile              = &sWTFI;

    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
    sWTFI.pcwszFilePath     = pwszFilename;
    sWTFI.hFile             = CreateFileU(pwszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL, NULL);

    hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

    if (sWTFI.hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(sWTFI.hFile);
    }

    if ((fCheckExpectedError) && ((DWORD)hr == dwExpectedError) && (fProcessAllCatMembers))
    {
        if (IsCatalogFile(INVALID_HANDLE_VALUE, pwszFilename))
        {
            return(_ExplodeCatalog(pwszFilename));
        }
    }

    return(hr);
}

HRESULT _ExplodeCatalog(WCHAR *pwszCatalogFile)
{
    HRESULT         hrReturn;
    HANDLE          hCat;
    CRYPTCATMEMBER  *psMember;

    hrReturn = ERROR_SUCCESS;

    //
    // open the catalog
    //
    if (!(hCat = CryptCATOpen(pwszCatalogFile, 0, NULL, 0, 0)))
    {
        goto ErrorCatOpen;
    }

    psMember = NULL;

    while (psMember = CryptCATEnumerateMember(hCat, psMember))
    {
        hrReturn |= _CallCatalogWVT(pwszCatalogFile, psMember->pwszReferenceTag,
                                    psMember->pwszReferenceTag);
    }

    CommonReturn:
        if (hCat)
        {
            CryptCATClose(hCat);
        }

        return(hrReturn);

    ErrorReturn:
        hrReturn = GetLastError();
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, ErrorCatOpen);
}

HRESULT _CallCatalogWVT(WCHAR *pwszCatalogFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile)
{
    HRESULT                 hr;
    DWORD                   cbHash;
    BYTE                    bHash[40];
    WCHAR                   *pwsz;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    DRIVER_VER_INFO         sDriverInfo;

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = (fQuiet) ? WTD_UI_NONE : WTD_UI_ALL;
    sWTD.dwUnionChoice      = WTD_CHOICE_CATALOG;
    sWTD.pCatalog           = &sWTCI;

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
    sWTCI.pcwszCatalogFilePath  = pwszCatalogFile;
    sWTCI.pcwszMemberTag        = pwszMemberTag;
    sWTCI.pcwszMemberFilePath   = pwszMemberFile;
    sWTCI.hMemberFile           = CreateFileU(pwszMemberFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                              FILE_ATTRIBUTE_NORMAL, NULL);

#if (0) //DSIE
    if (fUseCatalogDatabase && (pwszOSVerLow != NULL))
#else
    if (pwszOSVerLow != NULL)
#endif
    {
        WCHAR   *pwszEnd;
        WCHAR   *pwszCurrent;

        memset(&sDriverInfo, 0x00, sizeof(DRIVER_VER_INFO));
        sDriverInfo.cbStruct = fUseOldDriverVerInfoSize ? _OFFSETOF(DRIVER_VER_INFO, dwBuildNumberLow) : sizeof(DRIVER_VER_INFO);

        pwszEnd = wcschr(pwszOSVerLow, L':');
        if (pwszEnd == NULL)
        {
            goto OSVerError;
        }
        *pwszEnd = L'\0';
        sDriverInfo.dwPlatform = _wtol(pwszOSVerLow);
        *pwszEnd = L':';

        pwszCurrent = pwszEnd + 1;
        pwszEnd = wcschr(pwszCurrent, L'.');
        if (pwszEnd == NULL)
        {
            goto OSVerError;
        }
        *pwszEnd = L'\0';
        sDriverInfo.sOSVersionLow.dwMajor = sDriverInfo.sOSVersionHigh.dwMajor = _wtol(pwszCurrent);
        *pwszEnd = L'.';

        pwszCurrent = pwszEnd + 1;
        pwszEnd = wcschr(pwszCurrent, L'.');
        if (pwszEnd == NULL)
        {
            sDriverInfo.sOSVersionLow.dwMinor = sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);  
        }
        else
        {
            *pwszEnd = L'\0';
            sDriverInfo.sOSVersionLow.dwMinor = sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
            *pwszEnd = L'.';

            pwszCurrent = pwszEnd + 1;
            sDriverInfo.dwBuildNumberLow = sDriverInfo.dwBuildNumberHigh = _wtol(pwszCurrent);
        }       
        
        if (pwszOSVerHigh != NULL)
        {
            pwszEnd = wcschr(pwszOSVerHigh, L':');
            if (pwszEnd == NULL)
            {
                goto OSVerError;
            }
            *pwszEnd = L'\0';
            if (sDriverInfo.dwPlatform != (DWORD) _wtol(pwszOSVerHigh))
            {
                goto OSVerError;
            }
            *pwszEnd = L':';

            pwszCurrent = pwszEnd + 1;
            pwszEnd = wcschr(pwszCurrent, L'.');
            if (pwszEnd == NULL)
            {
                goto OSVerError;
            }
            *pwszEnd = L'\0';
            sDriverInfo.sOSVersionHigh.dwMajor = _wtol(pwszCurrent);
            *pwszEnd = L'.';

            pwszCurrent = pwszEnd + 1;
            pwszEnd = wcschr(pwszCurrent, L'.');
            if (pwszEnd == NULL)
            {
                sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
            }
            else
            {
                *pwszEnd = L'\0';
                sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
                *pwszEnd = L'.';
            
                pwszCurrent = pwszEnd + 1;
                sDriverInfo.dwBuildNumberHigh = _wtol(pwszCurrent);            
            }          
        }

        sWTD.pPolicyCallbackData = &sDriverInfo;
    }

    cbHash  = 40;

    if (!(CryptCATAdminCalcHashFromFileHandle(sWTCI.hMemberFile, &cbHash, &bHash[0], 0)))
    {
        goto CatAdminCalcHashError;
    }

    sWTCI.pbCalculatedFileHash  = &bHash[0];
    sWTCI.cbCalculatedFileHash  = cbHash;

    if (fUseCatalogDatabase)
    {
        HCATINFO                hCatInfo;
        CATALOG_INFO            sCatInfo;

        if (!(hCatAdmin))
        {
            if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
            {
                goto CatAdminAcquireError;
            }
        }

        pwsz    = NULL;

        if (pwsz = wcsrchr(pwszMemberFile, L'\\'))
        {
            pwsz++;
        }
        else
        {
            pwsz = pwszMemberFile;
        }

        _ToLower(pwsz);

        sWTCI.pcwszMemberTag = pwsz;

        memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
        sCatInfo.cbStruct = sizeof(CATALOG_INFO);

        hCatInfo = NULL;

        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, &bHash[0], cbHash, 0, &hCatInfo))
        {
            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                // should do something (??)
                continue;
            }

            sWTCI.pcwszCatalogFilePath = &sCatInfo.wszCatalogFile[0];

            hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

            if ((sWTD.pPolicyCallbackData != 0) && (sDriverInfo.pcSignerCertContext != NULL))
            {
                CertFreeCertificateContext(sDriverInfo.pcSignerCertContext); 
            }

            if (hr == (HRESULT)dwExpectedError)
            {
                CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

                goto CommonReturn;
            }
        }
        
        goto CatMemberNotFound;
    }

    hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

    CommonReturn:
        if (sWTCI.hMemberFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(sWTCI.hMemberFile);
        }

        return(hr);

    ErrorReturn:
        hr = GetLastError();
        goto CommonReturn;

    OSVerError:
        wprintf(L"Invalid osverl or osverh\n");
        return S_FALSE;

    TRACE_ERROR_EX(DBG_SS_APP, CatAdminCalcHashError);
    TRACE_ERROR_EX(DBG_SS_APP, CatAdminAcquireError);
    TRACE_ERROR_EX(DBG_SS_APP, CatMemberNotFound);
}



BOOL 
OpenSIP(const WCHAR* pwsFileName,
		SIP_SUBJECTINFO** ppSubjectInfo,
		SIP_DISPATCH_INFO** ppDispatchInfo,
		GUID* pgSubject)
{

    if (pgSubject == NULL)
    {
        return FALSE;
    }

	if (NULL == (*ppSubjectInfo = (SIP_SUBJECTINFO*) new(BYTE[sizeof(SIP_SUBJECTINFO)])))
    {
        return FALSE;
    }
    
	if (NULL == (*ppDispatchInfo = (SIP_DISPATCH_INFO*) new(BYTE[sizeof(SIP_DISPATCH_INFO)])))
    {
        delete[] (*ppSubjectInfo);
        return FALSE;
    }

	memset((void*)*ppSubjectInfo, 0, sizeof(SIP_SUBJECTINFO));
	memset((void*)*ppDispatchInfo, 0, sizeof(SIP_DISPATCH_INFO));
	memset((void*)pgSubject, 0, sizeof(GUID));

	// Get the type of SIP
	if (!CryptSIPRetrieveSubjectGuid(
					pwsFileName,
					NULL,
					pgSubject))
	{
		goto ErrorReturn;
	}

	(*ppDispatchInfo)->cbSize = sizeof(SIP_DISPATCH_INFO);

	// Load the SIP
	if (!CryptSIPLoad(
				pgSubject,
				0,
				*ppDispatchInfo))
	{
		goto ErrorReturn;
	}

	// Fill in the SIP_SUBJECTINFO struct
	(*ppSubjectInfo)->cbSize = sizeof(SIP_SUBJECTINFO);
	(*ppSubjectInfo)->pgSubjectType = pgSubject;
	(*ppSubjectInfo)->pwsFileName = pwsFileName;

	goto CommonReturn;

ErrorReturn:
	delete[](*ppSubjectInfo);
	delete[](*ppDispatchInfo);
	return FALSE;

CommonReturn:
	return TRUE;
}


BOOL 
ReadMsgBlob(const WCHAR* pwsFileName,
			CRYPT_DATA_BLOB* pData)
{
	if ((pwsFileName == NULL)	||
		(pData == NULL))
	{
		return FALSE;
	}

	SIP_SUBJECTINFO* pSubjectInfo = NULL;
	SIP_DISPATCH_INFO* pDispatchInfo = NULL;
	GUID gSubject;

	memset((void*)&gSubject, 0, sizeof(gSubject));

	// Get the SIP
	if (!OpenSIP(
				pwsFileName,
				&pSubjectInfo,
				&pDispatchInfo,
				&gSubject))
	{
		return FALSE;
	}

	// Load the message blob
	DWORD dwEncodingType = 0;
	pData->cbData = 0;

	if (!pDispatchInfo->pfGet(
						pSubjectInfo,
						&dwEncodingType,
						0,
						&(pData->cbData),
						NULL))
	{
		delete[](pSubjectInfo);
		delete[](pDispatchInfo);
		return FALSE;
	}

	pData->pbData = (BYTE*)new(BYTE[pData->cbData]);
	if (pData->pbData == NULL)
		return FALSE;

	memset((void*)pData->pbData, 0, pData->cbData);

	if (!pDispatchInfo->pfGet(
						pSubjectInfo,
						&dwEncodingType,
						0,
						&(pData->cbData),
						pData->pbData))
	{
		delete[](pData->pbData);
		delete[](pSubjectInfo);
		delete[](pDispatchInfo);
		return FALSE;
	}

	delete[](pSubjectInfo);
	delete[](pDispatchInfo);
	return TRUE;
}


BOOL
CheckForTimeStamp(WCHAR *pwszFile)
{
    BOOL        fRet = TRUE;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HCRYPTMSG   hMsg = NULL;
    BYTE        *pb = NULL;
    DWORD       cb = 0;
    DWORD       cbRead = 0;
    PCMSG_ATTR  pMsgAttr = NULL;
    DWORD       cbMsgAttr = 0;
    CRYPT_ATTRIBUTE     *pAttr = NULL;
    CRYPT_DATA_BLOB blob;
    DWORD       dwEncodingType;

    if (!ReadMsgBlob(pwszFile, &blob))
    {
        return FALSE;
    }

    //
    // If the encoded message was passed in the use CryptMsg to crack the encoded PKCS7 Signed Message
    //
    if (!(hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING ,
                                      0,
                                      0,
                                      0,
                                      NULL,
                                      NULL)))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgUpdate(hMsg,
                        blob.pbData,
                        blob.cbData,
                        TRUE))                    // fFinal
    {
        CryptMsgClose(hMsg);
        goto ErrorReturn;
    }
    
    //
    // get the unauthenticated attributes because that is where the counter signer is
    //
    CryptMsgGetParam(hMsg,
                     CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                     0,
                     NULL,
                     &cbMsgAttr);

    if (cbMsgAttr == 0)
    {
        goto ErrorReturn;
    }

    if (NULL == (pMsgAttr = (CMSG_ATTR *) new(BYTE[cbMsgAttr])))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgGetParam(hMsg,
                          CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                          0,
                          (void *) pMsgAttr,
                          &cbMsgAttr))
    {
        goto ErrorReturn;
    }

    //
    // search for the counter signer in the unauthenticated attributes
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pMsgAttr->cAttr,
                                   pMsgAttr->rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        goto ErrorReturn;
    }

    
Cleanup:

    delete[](blob.pbData);

    if (pMsgAttr)
        delete[](pMsgAttr);

    if (hMsg != NULL)
        CryptMsgClose(hMsg);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto Cleanup;


}

int _ShowError(DWORD dwError, WCHAR *pwszFile)
{
    pPrint->Display(IDS_FILEREF, pwszFile);

    if (fCheckExpectedError)
    {
        if (dwError == dwExpectedError)
        {
            pPrint->Display(IDS_SUCCEEDED);
            return(0);
        }
        else
        {
            pPrint->Display(IDS_EXPECTED_HRESULT, dwExpectedError, dwError);
            return(1);
        }
    }

	switch(dwError)
	{
		case S_OK:
            pPrint->Display(IDS_SUCCEEDED);
            if (fNoTimeStampWarning)
            {
                if (!CheckForTimeStamp(pwszFile))
                {
                    pPrint->Display(IDS_NO_TIMESTAMP_WARNING);
                }
            }
            return(0);

		case TRUST_E_SUBJECT_FORM_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_FILE_TYPE);
			break;

		case TRUST_E_PROVIDER_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_PROVIDER);
			break;

		case TRUST_E_ACTION_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_ACTION);
			break;

        case TRUST_E_SUBJECT_NOT_TRUSTED:
            pPrint->Display(IDS_SUBJECT_NOT_TRUSTED);
			break;

		default:
            pPrint->Display(IDS_FAIL, GetLastError());

			break;
    }
    return(1);
}

HRESULT _AddCatalogToDatabase(WCHAR *pwszFileIn)
{
    HCATINFO                hCatInfo;
    WCHAR                   *pwszBaseName;
    
    if (!(hCatAdmin))
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
        {
            return(GetLastError());
        }
    }

    //
    //  set the base file name
    //
    if (!(pwszBaseName = wcsrchr(pwszFileIn, L'\\')))
    {
        pwszBaseName = wcsrchr(pwszFileIn, L':');
    }

    if (pwszBaseName)
    {
        *pwszBaseName++;
    }
    else
    {
        pwszBaseName = pwszFileIn;
    }

    if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszFileIn, fReplaceCatfile ? pwszBaseName : NULL, 0))
    {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}

HRESULT _DelCatalogFromDatabase(WCHAR *pwszFileIn)
{
    HCATINFO                hCatInfo;
    WCHAR                   *pwszBaseName;

#if (1) //DSIE
    typedef BOOL (WINAPI * PCRYPTCATADMINREMOVECATALOG)(HCATADMIN, WCHAR *, DWORD);

    HRESULT                     hr                          = S_OK;
    HMODULE                     hMSCAT32L                   = NULL;
    PCRYPTCATADMINREMOVECATALOG pCryptCATAdminRemoveCatalog = NULL;
#endif

    if (!(hCatAdmin))
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
        {
            return(GetLastError());
        }
    }

    //
    //  set the base file name
    //
    if (!(pwszBaseName = wcsrchr(pwszFileIn, L'\\')))
    {
        pwszBaseName = wcsrchr(pwszFileIn, L':');
    }

    if (pwszBaseName)
    {
        *pwszBaseName++;
    }
    else
    {
        pwszBaseName = pwszFileIn;
    }

#if (0) //DSIE: Use GetProcAddress to CryptCATAdminRemoveCatalog, since it 
        //      is not available to Win2K.
    if (!CryptCATAdminRemoveCatalog(
            hCatAdmin,
            pwszBaseName,
            0))
    {
        return(GetLastError());
    }

    return (ERROR_SUCCESS);
#else
    if (hMSCAT32L = LoadLibraryA("mscat32l.dll"))
    {
        if (pCryptCATAdminRemoveCatalog = (PCRYPTCATADMINREMOVECATALOG) 
                                                GetProcAddress(hMSCAT32L, 
                                                               "CryptCATAdminRemoveCatalog"))
        {
            if (!pCryptCATAdminRemoveCatalog(hCatAdmin, pwszBaseName, 0))
            {
                hr = GetLastError();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        FreeLibrary(hMSCAT32L);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
#endif
}

void _ToLower(WCHAR *pwszInOut)
{
    while (*pwszInOut)
    {
        *pwszInOut = towlower(*pwszInOut);
        pwszInOut++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\makecat\usage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usage.h
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef USAGE_H
#define USAGE_H

extern BOOL     ParseArgs(int argc, WCHAR **wargv);
extern void     Usage(void);

#endif // USAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\chktrust\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chktrust.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_CATFILE               15
#define IDS_PARAMTEXT_CATFILE           16
#define IDS_PARAM_CATMEMBER             17
#define IDS_PARAMTEXT_CATMEMBER         18
#define IDS_PARAM_TPROV                 19
#define IDS_PARAMTEXT_TPROV             20
#define IDS_PARAM_IECALL                21
#define IDS_PARAMTEXT_IECALL            22
#define IDS_PARAM_TESTDUMP              23
#define IDS_PARAMTEXT_TESTDUMP          24
#define IDS_PARAM_QUIET                 25
#define IDS_PARAMTEXT_QUIET             26
#define IDS_PARAM_ALLCATMEM             27
#define IDS_PARAMTEXT_ALLCATMEM         28
#define IDS_PARAM_TESTDRV               29
#define IDS_PARAMTEXT_USECATDB          30
#define IDS_PARAMTEXT_TESTDRV           30
#define IDS_PARAM_CATUSELIST            31
#define IDS_PARAMTEXT_CATUSELIST        32
#define IDS_PARAM_CATADDLIST            33
#define IDS_PARAMTEXT_CATADDLIST        34
#define IDS_PARAM_CATROOT               35
#define IDS_PARAMTEXT_CATROOT           36
#define IDS_PARAM_REPLACECATFILE        37
#define IDS_PARAMTEXT_REPLACECATFILE    38
#define IDS_PARAM_NT5                   39
#define IDS_PARAMTEXT_NT5               40
#define IDS_PARAM_TSWARN                41
#define IDS_PARAMTEXT_TSWARN            42
#define IDS_NO_TIMESTAMP_WARNING        43
#define IDS_PARAM_OSVERLOW              44
#define IDS_PARAMTEXT_OSVERLOW          45
#define IDS_PARAM_OSVERHIGH             46
#define IDS_PARAMTEXT_OSVERHIGH         47
#define IDS_PARAM_OSVEROLD              48
#define IDS_PARAMTEXT_OSVEROLD          49
#define IDS_PARAM_CATDELLIST            50
#define IDS_PARAMTEXT_CATDELLIST        51
#define IDS_PARAM_PAUSE                 52
#define IDS_PARAMTEXT_PAUSE             53
#define IDS_PARAM_RESUME                54
#define IDS_PARAMTEXT_RESUME            55
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_CAN_NOT_OPEN_FILE           7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_UNKNOWN_FILE_TYPE           7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_UNKNOWN_PROVIDER            7003
#define IDS_ERROR_PARSE                 7004
#define IDS_UNKNOWN_ACTION              7004
#define IDS_SUBJECT_NOT_TRUSTED         7005
#define IDS_FILEREF                     7007
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FAIL                        9013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dumpcat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\makecat\makecat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"


BOOL        fVerbose        = FALSE;
BOOL        fFailAllErrors  = FALSE;
BOOL        fParseError     = FALSE;
BOOL        fTesting        = FALSE;
DWORD       dwExpectedError = 0;

WCHAR       *pwszCDFFile    = NULL;
PrintfU_    *pPrint         = NULL;

int         iRet            = 0;

void WINAPI DisplayParseError(DWORD dwErrorArea, DWORD dwLocalError, WCHAR *wszName);

extern "C" CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

extern "C" LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);


#define DEFAULT_STRING_BUFFER_SIZE 20
char szDefaultBuffer[DEFAULT_STRING_BUFFER_SIZE];

static LPSTR MakeMBSTR(LPWSTR pwsz, BOOL *pfAlloced)
{
    int     numChars = 0;
    LPSTR   pszString = NULL;

    numChars = WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);

    if ((numChars + 1) > DEFAULT_STRING_BUFFER_SIZE)
    {
        pszString = new(char[numChars + 1]);
        WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        pszString,
                        numChars + 1,
                        NULL,
                        NULL);
        
        *pfAlloced = TRUE;
        return pszString;
    }
    else
    {
        WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        szDefaultBuffer,
                        numChars + 1,
                        NULL,
                        NULL);
        
        *pfAlloced = FALSE;
        return szDefaultBuffer;
    }
}

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                 cMember;
    cWArgv_             *pArgs;
    BOOL                fFailed;
    CRYPTCATCDF         *pCDF;
    CRYPTCATMEMBER      *pMember;
    LPWSTR              pwszMemberTag;
    CRYPTCATATTRIBUTE   *pAttr;
    BOOL                fContinueOnError;
    LPWSTR              pwszOutputFile = NULL;
    HANDLE              hOutputFile = INVALID_HANDLE_VALUE;
    BOOL                fAlloced;
    LPSTR               psz;
    DWORD               dwBytesWritten;

    pCDF = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,    WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_FAILALWAYS,   IDS_PARAMTEXT_FAILALWAYS, WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,   WARGV_VALUETYPE_DWORDH, NULL, TRUE);
    pArgs->Add2List(IDS_PARAM_NOSTOPONERROR, IDS_PARAMTEXT_NOSTOPONERROR, WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_OUTPUTFILE,   IDS_PARAMTEXT_OUTPUTFILE, WARGV_VALUETYPE_WCHAR, NULL, FALSE);

    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose        = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    fFailAllErrors  = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_FAILALWAYS));
    fContinueOnError = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOSTOPONERROR));

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fTesting        = TRUE;
    }

    if (!(pwszCDFFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if (pArgs->IsSet(IDS_PARAM_OUTPUTFILE))
    {
        pwszOutputFile = (LPWSTR) pArgs->GetValue(IDS_PARAM_OUTPUTFILE);
    }

    pPrint = new PrintfU_;

    if (pPrint == NULL)
    {
        goto MemoryError;
    }

    SetLastError(0);

    if (!(pCDF = CryptCATCDFOpen(pwszCDFFile, DisplayParseError)))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFOpen", GetLastError());
        }

        goto CDFOpenError;
    }

    if (fVerbose)
    {
        pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_OPENED), pwszCDFFile);
    }

    pAttr   = NULL;

    while (pAttr = CryptCATCDFEnumCatAttributes(pCDF, pAttr, DisplayParseError))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_ATTR),
                            pAttr->pwszReferenceTag);
        }
    }

    //
    // If we are logging the the catalog members, then create the output file
    //
    if (pwszOutputFile != NULL)
    {
        hOutputFile = CreateFileU(
                        pwszOutputFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hOutputFile == INVALID_HANDLE_VALUE)
        {
            printf("Error creating %S:  %x", pwszOutputFile, GetLastError());
            goto ErrorReturn;
        }
    }

    pMember = NULL;
    pwszMemberTag = NULL;
    cMember = 0;

    while (pwszMemberTag = CryptCATCDFEnumMembersByCDFTagEx(pCDF, pwszMemberTag, DisplayParseError, &pMember, fContinueOnError, NULL))
    {
        //
        // Log to file
        //
        if (hOutputFile != INVALID_HANDLE_VALUE)
        {
            psz = MakeMBSTR(pMember->pwszFileName, &fAlloced);
            WriteFile(hOutputFile, psz, strlen(psz), &dwBytesWritten, NULL);
            if (fAlloced)
            {
                delete[]psz;
            }

            WriteFile(hOutputFile, " - ", 3, &dwBytesWritten, NULL);

            psz = MakeMBSTR(pMember->pwszReferenceTag, &fAlloced);
            WriteFile(hOutputFile, psz, strlen(psz), &dwBytesWritten, NULL);
            if (fAlloced)
            {
                delete[]psz;
            }

            WriteFile(hOutputFile, "\n", strlen("\n"), &dwBytesWritten, NULL);
        }

        if (fVerbose)
        {
            pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_PROCESSED), pwszMemberTag);
        }
        cMember++;

        pAttr = NULL;
        while (pAttr = CryptCATCDFEnumAttributesWithCDFTag(pCDF, pwszMemberTag, pMember, pAttr, DisplayParseError))
        {
            if (fVerbose)
            {
                pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_ATTR),
                                pAttr->pwszReferenceTag);
            }
        }
    }

    if ((fVerbose) && (cMember == 0))
    {
        pPrint->Display(IDS_ERROR_FUNCTION, pPrint->get_String(IDS_ERROR_NOMEMBERS), GetLastError());
    }

    if (!(CryptCATCDFClose(pCDF)))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFClose", GetLastError());
        }

        if (fFailAllErrors)
        {
            goto CATCloseError;
        }
    }

    if (fTesting)
    {
        pPrint->Display(IDS_FILEREF, pwszCDFFile);

        if (GetLastError() != dwExpectedError)
        {
            iRet = 1;
            pPrint->Display(IDS_EXPECTED_HRESULT, dwExpectedError, GetLastError());
        }
        else
        {
            iRet = 0;
            pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_SUCCEEDED), L"");
        }
    }
    else if ((cMember > 0) && (!(fParseError)))
    {
        pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_SUCCEEDED), L"");
    }
    else
    {
        if (fParseError)
        {
            pPrint->Display(IDS_ERROR_PARSE);
        }
        else
        {
            pPrint->Display(IDS_FAILED, GetLastError(), GetLastError());
        }
        iRet = 1;
    }


    if ((fFailAllErrors) && (cMember == 0) && !(fTesting))
    {
        iRet = 1;
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        if (hOutputFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hOutputFile);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
    TRACE_ERROR_EX(DBG_SS_APP, CDFOpenError);
}

void WINAPI DisplayParseError(DWORD dwWhichArea, DWORD dwLocalError, WCHAR *pwszLine)
{
    DWORD   idErr;
    DWORD   idFmt;

    fParseError = TRUE;

    switch (dwWhichArea)
    {
        case CRYPTCAT_E_AREA_HEADER:                idFmt = IDS_PARSE_E_HEADER_FMT;         break;
        case CRYPTCAT_E_AREA_MEMBER:                idFmt = IDS_PARSE_E_MEMBER_FMT;         break;
        case CRYPTCAT_E_AREA_ATTRIBUTE:             idFmt = IDS_PARSE_E_ATTRIBUTE_FMT;      break;
        default:                                    idFmt = IDS_PARSE_E_ATTRIBUTE_FMT;      break;
    }

    switch (dwLocalError)
    {
        case CRYPTCAT_E_CDF_MEMBER_FILE_PATH:       idErr = IDS_PARSE_ERROR_FILE_PATH;      break;
        case CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA:    idErr = IDS_PARSE_ERROR_INDIRECTDATA;   break;
        case CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND:    idErr = IDS_PARSE_ERROR_FILENOTFOUND;   break;
        case CRYPTCAT_E_CDF_BAD_GUID_CONV:          idErr = IDS_PARSE_ERROR_GUID_CONV;      break;
        case CRYPTCAT_E_CDF_ATTR_TYPECOMBO:         idErr = IDS_PARSE_ERROR_TYPECOMBO;      break;
        case CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES:      idErr = IDS_PARSE_ERROR_TOOFEWVALUES;   break;
        case CRYPTCAT_E_CDF_UNSUPPORTED:            idErr = IDS_PARSE_ERROR_UNSUPPORTED;    break;
        case CRYPTCAT_E_CDF_DUPLICATE:              idErr = IDS_PARSE_ERROR_DUPLICATE;      break;
        case CRYPTCAT_E_CDF_TAGNOTFOUND:            idErr = IDS_PARSE_ERROR_NOTAG;          break;
        default:                                    idErr = IDS_PARSE_ERROR_UNKNOWN;        break;
    }

    pPrint->Display(idFmt, pPrint->get_String(idErr), pwszLine);

    if (fFailAllErrors)
    {
        iRet = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\iesetreg\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for setreg.cpp 
//
//
//  History:    05-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS
#define	IDS_TRUE							6002
#define	IDS_FALSE							6003
#define	IDS_KEY_STATE						6004
#define	IDS_NAME_TEST_ROOT					6111
#define	IDS_NAME_EXPIRATION					6112
#define	IDS_NAME_REVOCATION					6113
#define	IDS_NAME_OFFLINE_INDIVIDUAL			6114
#define	IDS_NAME_OFFLINE_COMMERCIAL			6115
#define	IDS_NAME_JAVA_INDIVIDUAL			6116
#define	IDS_NAME_JAVA_COMMERCIAL			6117
#define	IDS_NAME_VERSION_ONE				6118
#define IDS_NAME_REVOCATIONONTS             6119
#define	IDS_NAME_ALLOWONLYPERTRUST			6120
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\iesetreg\iesetreg.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       iesetreg.cpp
//
//  Contents:   Set Registry Key Values
//
//              See Usage() for syntax and list of options.
//
//  Functions:  wmain
//
//  History:    28-Jul-96   philh   created
//              02-May-97   xiaohs	updated for Localiztion and Consistency
//				28-July-97	xiaohs  reduce size for ie
//              31-Oct-97   pberkman    changed to be a Windows App instead of Console.
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include "malloc.h"
#include "wintrust.h"
#include "cryptreg.h"
#include "unicode.h"
#include "resource.h"


typedef struct _FlagNames
{
    int			idsName;
    DWORD       dwMask;
} FlagNames;


static FlagNames SoftPubFlags[] =
{
    IDS_NAME_TEST_ROOT,				WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
    IDS_NAME_EXPIRATION,			WTPF_IGNOREEXPIRATION,
    IDS_NAME_REVOCATION,			WTPF_IGNOREREVOKATION,
    IDS_NAME_OFFLINE_INDIVIDUAL,	WTPF_OFFLINEOK_IND,
    IDS_NAME_OFFLINE_COMMERCIAL,	WTPF_OFFLINEOK_COM,
    IDS_NAME_JAVA_INDIVIDUAL,		WTPF_OFFLINEOKNBU_IND,
    IDS_NAME_JAVA_COMMERCIAL,		WTPF_OFFLINEOKNBU_COM,
    IDS_NAME_VERSION_ONE,			WTPF_VERIFY_V1_OFF,
    IDS_NAME_REVOCATIONONTS,        WTPF_IGNOREREVOCATIONONTS,
    IDS_NAME_ALLOWONLYPERTRUST,     WTPF_ALLOWONLYPERTRUST
};
#define NSOFTPUBFLAGS (sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]))

HMODULE	hModule=NULL;

static BOOL IsWinNt(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}


int __cdecl _mywcsicmp(const wchar_t * wsz1, const wchar_t * wsz2)
//
// REVIEW: Who calls this function, and should they be doing so?
//
// Return:
//       <0 if wsz1 < wsz2
//        0 if wsz1 = wsz2
//       >0 if wsz1 > wsz2
    {
    if(IsWinNt())
        {
        //
        // Just do the Unicode compare
        //
        return lstrcmpiW(wsz1, wsz2);
        }
    else
        {
        //
        // Convert to multibyte and let the system do it
        //
        int cch1 = lstrlenW(wsz1);
        int cch2 = lstrlenW(wsz2);
        int cb1 = (cch1+1) * sizeof(WCHAR);
        int cb2 = (cch2+1) * sizeof(WCHAR);
        char* sz1= (char*) _alloca(cb1);
        char* sz2= (char*) _alloca(cb2);
        WideCharToMultiByte(CP_ACP, 0, wsz1, -1, sz1, cb1, NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, wsz2, -1, sz2, cb2, NULL, NULL);

        return lstrcmpiA(sz1, sz2);
        }
    }


//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	
//---------------------------------------------------------------------------
static void SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState;
    LONG	lErr;
    HKEY	hKey;
    DWORD	dwDisposition;
    DWORD	dwType;
    DWORD	cbData;
	//WCHAR	wszState[10];
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
	//	return;


    // Set the State in the registry
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition)))
	{
        return;
    }

    dwState = 0;
    cbData = sizeof(dwState);
    lErr = RegQueryValueExU
	(
        hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        );


    if (ERROR_SUCCESS != lErr)
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
        {
             dwState = 0;
		}
		else
		{
			goto CLEANUP;
		}

    }
	else if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
	{
        goto CLEANUP;
    }

    switch(dwMask)
	{
    case WTPF_IGNOREREVOCATIONONTS:
    case WTPF_IGNOREREVOKATION:
    case WTPF_IGNOREEXPIRATION:
        // Revocation and expiration are a double negative so the bit set
        // means revocation and expriation checking is off.
        fOn = !fOn;
        break;
    default:
        break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    lErr = RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );


CLEANUP:
	if(hKey)
		RegCloseKey(hKey);
}


//---------------------------------------------------------------------------
//	 wmain
//	
//---------------------------------------------------------------------------

#define MAX_ARGV_PARAMS         32

extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
    WCHAR       *wargv1[MAX_ARGV_PARAMS];
    WCHAR       **wargv;
    WCHAR       *pwsz;
    int         argc;
    WCHAR       wszExeName[MAX_PATH];

    memset(wargv1, 0x00, sizeof(WCHAR *) * MAX_ARGV_PARAMS);
    wargv = &wargv1[0];

    wszExeName[0] = NULL;
    GetModuleFileNameU(GetModuleHandle(NULL), &wszExeName[0], MAX_PATH);

    argc        = 1;
    wargv[0]    = &wszExeName[0];
    wargv[1]    = NULL;

    if (lpCmdLine)
    {
        while (*lpCmdLine == L' ')
        {
            lpCmdLine++;
        }

        if (*lpCmdLine)
        {
            wargv[argc] = lpCmdLine;
            argc++;
            wargv[argc] = NULL;
        }
    }

    pwsz        = lpCmdLine;

    while ((pwsz) && (*pwsz) && (argc < MAX_ARGV_PARAMS))
    {
        if (*pwsz == L' ')
        {
            *pwsz = NULL;
            pwsz++;

            while (*pwsz == L' ')
            {
                pwsz++;
            }

            wargv[argc] = pwsz;
            argc++;
        }

        pwsz++;
    }

    //
    //  now that we have argv/argc style params, go into existing code ...
    //

    int		ReturnStatus = 0;

    LPWSTR	*prgwszKeyName=NULL;
    LPWSTR	*prgwszValue=NULL;
	DWORD	dwIndex=0;
	DWORD	dwCountKey=0;
	DWORD	dwCountValue=0;
    DWORD	dwMask = 0;
    BOOL	fOn=TRUE;
    BOOL	fQuiet = FALSE;
	DWORD	dwEntry=0;
	WCHAR	*pArg=NULL;
	WCHAR	wszTRUE[10];
	WCHAR	wszFALSE[10];


	if(!(hModule=GetModuleHandle(NULL)))
	{
		ReturnStatus=-1;
		goto CommonReturn;
	}

	//load the string
	if(!LoadStringU(hModule, IDS_TRUE, wszTRUE, 10) ||
		!LoadStringU(hModule, IDS_FALSE, wszFALSE, 10))
	{
		ReturnStatus=-1;
		goto CommonReturn;
	}

	//convert the multitype registry path to the wchar version
	prgwszKeyName=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);
	prgwszValue=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);

	if(!prgwszKeyName || !prgwszValue)
	{
		ReturnStatus = -1;
		goto CommonReturn;

	}

	//memset
	memset(prgwszKeyName, 0, sizeof(LPWSTR)*argc);
	memset(prgwszValue, 0, sizeof(LPWSTR)*argc);  	

    while (--argc>0)
    {
		pArg=*++wargv;

		if(dwCountKey==dwCountValue)
		{
			prgwszKeyName[dwCountKey]=pArg;
			dwCountKey++;
		}
		else
		{
			if(dwCountKey==(dwCountValue+1))
			{
				prgwszValue[dwCountValue]=pArg;
				dwCountValue++;
			}
			else
			{
				goto BadUsage;
			}
		}

     }

	if(dwCountKey!=dwCountValue)
	{
		goto BadUsage;
	}


	if(dwCountKey==0)
	{
	 	//Display the Software Publisher State Key Values
        //DisplaySoftPubKeys();
        goto CommonReturn;
	}


	for(dwIndex=0; dwIndex<dwCountKey; dwIndex++)
	{
		
		//the choice has to be one character long
		if((prgwszKeyName[dwIndex][0]==L'1') && (prgwszKeyName[dwIndex][1]==L'0') &&
			(prgwszKeyName[dwIndex][2]==L'\0'))
			dwEntry=10;
		else
		{
			if(prgwszKeyName[dwIndex][1]!=L'\0')
				goto BadUsage;

			//get the character
			dwEntry=(ULONG)(prgwszKeyName[dwIndex][0])-(ULONG)(L'0');
		}

		if((dwEntry < 1) || (dwEntry > NSOFTPUBFLAGS+1))
			goto BadUsage;

		//get the Key mask
		dwMask = SoftPubFlags[dwEntry-1].dwMask;

		if (0 == _mywcsicmp(prgwszValue[dwIndex], wszTRUE))
			fOn = TRUE;
		else if (0 == _mywcsicmp(prgwszValue[dwIndex], wszFALSE))
			fOn = FALSE;
		else
		{
			goto BadUsage;
		}

		SetSoftPubKey(dwMask, fOn);
	}


    goto CommonReturn;

BadUsage:
    ReturnStatus = -1;
CommonReturn:
	//free the memory
	if(prgwszKeyName)
		free(prgwszKeyName);

	if(prgwszValue)
		free(prgwszValue);	

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\makerootctl\makerootctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       makerootctl.cpp
//
//  Contents:   Makes a CTL used for the Auto Update of the "AuthRoot" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    08-Sep-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"

#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void Usage(void)
{
    printf("Usage: makerootctl [options] [<CtlFilename>]\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -c                        - Include certs in the CTL\n");
    printf("  -C <Directory>            - Write certs into directory\n");
    printf("  -a <AddStoreFilename>     - Add\n");
    printf("  -d <DeleteStoreFilename>  - Delete\n");
    printf("  -t <Number>               - Timeout hint in SequenceNumber (secs)\n");
    printf("\n");
    printf("Supports multiple -a and/or -d options\n");
    printf("\n");
    printf("The -c and -C options are ignored for deleted roots\n");
    printf("\n");
    printf("For -C option, defaults to authroot.stl. Also writes authrootseq.txt\n");
    printf("\n");
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR) malloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("Failed, bad AllocAndSzToWsz\n");
failed:
    if (pwsz) {
        free(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

BOOL OpenAndAddStoreToCollection(
    IN LPCSTR pszStoreFilename,
    IN OUT HCERTSTORE hCollectionStore
    )
{
    BOOL fResult;
    HCERTSTORE hStore;

    hStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME_A,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,                      // hCryptProv
        0,
        (const void *) pszStoreFilename
        );
    if (NULL == hStore) {
        PrintLastError("Open StoreFilename");
        return FALSE;
    }

    fResult = CertAddStoreToCollection(
        hCollectionStore,
        hStore,
        CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
        0                                       // dwPriority
        );
    if (!fResult)
        PrintLastError("CertAddStoreToCollection");

    CertCloseStore(hStore, 0);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(char) bytes of space in sz
//--------------------------------------------------------------------------
void BytesToStr(DWORD cb, void* pv, LPSTR sz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb & 0x0F;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        pb++;
    }
    *sz++ = 0;
}

BOOL
WriteCertToDirectory(
    IN LPCWSTR pwszCertDirectory,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    DWORD cchDir;
    LPWSTR pwszFilename = NULL;
    DWORD cchFilename;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];
    HANDLE hFile = NULL;
    DWORD cbBytesWritten;

    // Get cert's SHA1 hash
    cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) || SHA1_HASH_LEN != cbData) {
        PrintLastError("GetCertificate SHA1 Hash Property");
        goto ErrorReturn;
    }

    // Format filename:
    //  L"CertDirectory" L"\\" L"AsciiHexHash" L".cer"
    // For example:
    //  L"c:\\authroot\\216B2A29E62A00CE820146D8244141B92511B279.cer"

    cchDir = wcslen(pwszCertDirectory);
    cchFilename =
        cchDir + 1 + SHA1_HASH_NAME_LEN + wcslen(CERT_AUTH_ROOT_CERT_EXT) + 1;
    
    if (NULL == (pwszFilename = (LPWSTR) malloc(sizeof(WCHAR) * cchFilename)))
        goto OutOfMemory;
    
    wcscpy(pwszFilename, pwszCertDirectory);
    pwszFilename[cchDir] = L'\\';
    BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, pwszFilename + cchDir + 1);
    wcscpy(pwszFilename + cchDir + 1 + SHA1_HASH_NAME_LEN,
        CERT_AUTH_ROOT_CERT_EXT);

    hFile = CreateFileU(
            pwszFilename,
            GENERIC_WRITE,
            0,                  // fdwShareMode
            NULL,               // lpsa
            CREATE_ALWAYS,
            0,                  // fdwAttrsAndFlags
            0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        PrintLastError("Create File");
        printf("failed for: %S\n", pwszFilename);
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        PrintLastError("Write File");
        printf("failed for: %S\n", pwszFilename);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (NULL != hFile && INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (pwszFilename)
        free(pwszFilename);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    printf("Failed:: out of memory\n");
    goto ErrorReturn;
}

// Sequence Number consists of FileTime, Timeout hint byte
#define SEQ_LEN     (sizeof(FILETIME) + 1)

int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus = 0;
    LPWSTR pwszCtlFilename = NULL;          // malloc'ed
    LPWSTR pwszSeqFilename = NULL;          // malloc'ed
    HCERTSTORE hAddStore = NULL;
    HCERTSTORE hDeleteStore = NULL;
    BOOL fIncludeCerts = FALSE;
    LPWSTR pwszCertDirectory = NULL;        // malloc'ed
    BYTE bTimeout = 20;                     // default to 20 seconds

    DWORD cCert = 0;

    LPSTR pszSubjectUsage = szOID_ROOT_LIST_SIGNER;

    BYTE rgbDelete[] = {0x02, 0x01, 0x1};   // 0x02 - INTEGER tag
    CRYPT_ATTR_BLOB DeleteValue = {sizeof(rgbDelete), rgbDelete};
    CRYPT_ATTRIBUTE rgDeleteAttr[1] = {
        szOID_REMOVE_CERTIFICATE, 1, &DeleteValue
    };

    BYTE rgbSequenceNumber[SEQ_LEN];

    CTL_INFO CtlInfo;
    PCTL_ENTRY pCtlEntry = NULL;
    PCTL_ENTRY *ppCtlEntry = NULL;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    PCERT_BLOB pCertEncoded = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    PCCERT_CONTEXT pCert;
    HANDLE hCtlFile = NULL;
    DWORD cbBytesWritten = 0;

    PCCTL_CONTEXT pCtl = NULL;
    HANDLE hSeqFile = NULL;

    // Create the add and delete collection stores
    hAddStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        0,                      // dwEncodingType
        0,                      // hCryptProv
        0,                      // dwFlags
        NULL                    // pvPara
        );
    if (NULL == hAddStore) {
        PrintLastError("CertOpenStore(Add Collection)");
        goto ErrorReturn;
    }

    hDeleteStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        0,                      // dwEncodingType
        0,                      // hCryptProv
        0,                      // dwFlags
        NULL                    // pvPara
        );
    if (NULL == hDeleteStore) {
        PrintLastError("CertOpenStore(Delete Collection)");
        goto ErrorReturn;
    }

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                fIncludeCerts = TRUE;
                break;
            case 'C':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-C : missing Directory argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                pwszCertDirectory = AllocAndSzToWsz(argv[0]);
                break;
            case 'a':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-a : missing AddStoreFilename argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                if (!OpenAndAddStoreToCollection(argv[0], hAddStore))
                    goto ErrorReturn;
                break;
            case 'd':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-a : missing DeleteStoreFilename argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                if (!OpenAndAddStoreToCollection(argv[0], hDeleteStore))
                    goto ErrorReturn;
                break;
            case 't':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-t : missing timeout number argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                {
                    DWORD dwTimeout;
                    dwTimeout = (DWORD) strtoul(argv[0], NULL, 0);
                    if (dwTimeout > 0xFF)
                        dwTimeout = 0xFF;
                    bTimeout = (BYTE) dwTimeout;
                }
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pwszCtlFilename == NULL)
                pwszCtlFilename = AllocAndSzToWsz(argv[0]);
            else {
                printf("too many CTL filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (NULL == pwszCtlFilename && NULL == pwszCertDirectory) {
        printf("missing CTL filename\n");
        goto BadUsage;
    }

    // Get count of the add and delete certs
    pCert = NULL;
    cCert = 0;
    while (pCert = CertEnumCertificatesInStore(hAddStore, pCert))
        cCert++;

    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hDeleteStore, pCert))
        cCert++;

    if (cCert) {
        DWORD i;

        if (NULL == (pCtlEntry = (PCTL_ENTRY) malloc(
                cCert * sizeof(CTL_ENTRY))))
            goto OutOfMemory;
        memset(pCtlEntry, 0, cCert * sizeof(CTL_ENTRY));
        if (NULL == (ppCtlEntry = (PCTL_ENTRY *) malloc(
                cCert * sizeof(PCTL_ENTRY))))
            goto OutOfMemory;
        memset(ppCtlEntry, 0, cCert * sizeof(PCTL_ENTRY));

        if (fIncludeCerts) {
            if (NULL == (pCertEncoded = (PCERT_BLOB) malloc(
                    cCert * sizeof(CERT_BLOB))))
                goto OutOfMemory;
            memset(pCertEncoded, 0, cCert * sizeof(CERT_BLOB));
        }


        // Create CTL and add CTL entry for each certificate. If enabled,
        // add to list of encoded certificates
        //

        i = 0;

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hAddStore, pCert)) {
            DWORD cbCtlEntry;

            if (i >= cCert) {
                printf("Unexpected error, too many add certs\n");
                goto ErrorReturn;
            }

            cbCtlEntry = 0;
            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    0,              // cOptAttr
                    NULL,           // pOptAttr
                    CTL_ENTRY_FROM_PROP_CHAIN_FLAG,
                    NULL,           // pvReserved
                    NULL,           // pCtlEntry
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            if (NULL == (ppCtlEntry[i] = (PCTL_ENTRY) malloc(cbCtlEntry)))
                goto OutOfMemory;

            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    0,              // cOptAttr
                    NULL,           // pOptAttr
                    CTL_ENTRY_FROM_PROP_CHAIN_FLAG,
                    NULL,           // pvReserved
                    ppCtlEntry[i],
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            pCtlEntry[i] = *ppCtlEntry[i];

            if (fIncludeCerts) {
                pCertEncoded[i].cbData = pCert->cbCertEncoded;
                pCertEncoded[i].pbData = pCert->pbCertEncoded;
            }

            if (pwszCertDirectory) {
                if (!WriteCertToDirectory(pwszCertDirectory, pCert))
                    goto ErrorReturn;
            }

            i++;
        }

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hDeleteStore, pCert)) {
            DWORD cbCtlEntry;

            if (i >= cCert) {
                printf("Unexpected error, too many delete certs\n");
                goto ErrorReturn;
            }

            cbCtlEntry = 0;
            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    1,              // cOptAttr
                    rgDeleteAttr,
                    0,              // dwFlags
                    NULL,           // pvReserved
                    NULL,           // pCtlEntry
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            if (NULL == (ppCtlEntry[i] = (PCTL_ENTRY) malloc(cbCtlEntry)))
                goto OutOfMemory;

            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    1,              // cOptAttr
                    rgDeleteAttr,
                    0,              // dwFlags
                    NULL,           // pvReserved
                    ppCtlEntry[i],
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            pCtlEntry[i] = *ppCtlEntry[i];

            i++;
        }

        if (i != cCert) {
            printf("Unexpected error, didn't process all the certs\n");
            goto ErrorReturn;
        }
    }

    memset(&CtlInfo, 0, sizeof(CtlInfo));
    CtlInfo.dwVersion = CTL_V1;
    CtlInfo.SubjectUsage.cUsageIdentifier = 1;
    CtlInfo.SubjectUsage.rgpszUsageIdentifier = &pszSubjectUsage;
    // CtlInfo.ListIdentifier =
    GetSystemTimeAsFileTime(&CtlInfo.ThisUpdate);

    // Use the 8 byte filetime, 1 byte timeout for the sequence number.
    memcpy(rgbSequenceNumber, (BYTE *) &CtlInfo.ThisUpdate, sizeof(FILETIME));
    rgbSequenceNumber[sizeof(FILETIME)] = bTimeout;
    CtlInfo.SequenceNumber.pbData = rgbSequenceNumber;
    CtlInfo.SequenceNumber.cbData = sizeof(rgbSequenceNumber);

    // CtlInfo.NextUpdate =
    CtlInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    CtlInfo.cCTLEntry = cCert;
    CtlInfo.rgCTLEntry = pCtlEntry;
    // CtlInfo.cExtension =
    // CtlInfo.rgExtension =

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    // SignInfo.cSigners =
    // SignInfo.rgSigners =
    if (fIncludeCerts) {
        SignInfo.cCertEncoded = cCert;
        SignInfo.rgCertEncoded = pCertEncoded;
    }
    // SignInfo.cCrlEncoded =
    // SignInfo.rgCrlEncoded =

    cbEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &CtlInfo,
            &SignInfo,
            0,                  // dwFlags
            NULL,               // pbEncoded
            &cbEncoded
            )) {
        PrintLastError("EncodeAndSignCTL");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) malloc(cbEncoded)))
        goto OutOfMemory;

    if (!CryptMsgEncodeAndSignCTL(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &CtlInfo,
            &SignInfo,
            0,                  // dwFlags
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeAndSignCTL");
        goto ErrorReturn;
    }

    if (NULL == pwszCtlFilename) {
        DWORD cchDir;
        DWORD cchFilename;

        cchDir = wcslen(pwszCertDirectory);
        cchFilename = cchDir + 1 + wcslen(CERT_AUTH_ROOT_CTL_FILENAME) + 1;
    
        if (NULL == (pwszCtlFilename = (LPWSTR) malloc(
                sizeof(WCHAR) * cchFilename)))
            goto OutOfMemory;
    
        wcscpy(pwszCtlFilename, pwszCertDirectory);
        pwszCtlFilename[cchDir] = L'\\';
        wcscpy(pwszCtlFilename + cchDir + 1, CERT_AUTH_ROOT_CTL_FILENAME);
    }

    hCtlFile = CreateFileU(
            pwszCtlFilename,
            GENERIC_WRITE,
            0,                  // fdwShareMode
            NULL,               // lpsa
            CREATE_ALWAYS,
            0,                  // fdwAttrsAndFlags
            0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hCtlFile) {
        PrintLastError("Create Ctl File");
        goto ErrorReturn;
    }

    if (!WriteFile(
            hCtlFile,
            pbEncoded,
            cbEncoded,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        PrintLastError("Write Ctl File");
        goto ErrorReturn;
    }

    if (pwszCertDirectory) {
        // Create the authroot.seq file containing the CTL's SequenceNumber.
        // Write to the file as big endian. The decoded value is little
        // endian.

        BYTE rgbSeq[SEQ_LEN];
        char szSeq[SEQ_LEN * 2 + 1];      // Ascii Hex
        DWORD cbSeq;
        DWORD i;
        DWORD cchDir;
        DWORD cchFilename;

        // Decode the encoded CTL to get the "real" sequence number. 
        pCtl = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pbEncoded,
            cbEncoded
            );

        if (NULL == pCtl) {
            PrintLastError("CreateCTLContext");
            goto ErrorReturn;
        }

        cbSeq = pCtl->pCtlInfo->SequenceNumber.cbData;
        if (0 == cbSeq || sizeof(rgbSeq) < cbSeq) {
            printf("failed, invalid SequenceNumber\n");
            goto ErrorReturn;
        }

        // Convert the SequenceNumber to big endian ascii hex before writing to
        // the file.
        for (i = 0; i < cbSeq; i++)
            rgbSeq[i] = pCtl->pCtlInfo->SequenceNumber.pbData[cbSeq - 1 - i];

        BytesToStr(cbSeq, rgbSeq, szSeq);
        

        cchDir = wcslen(pwszCertDirectory);
        cchFilename = cchDir + 1 + wcslen(CERT_AUTH_ROOT_SEQ_FILENAME) + 1;
    
        if (NULL == (pwszSeqFilename = (LPWSTR) malloc(
                sizeof(WCHAR) * cchFilename)))
            goto OutOfMemory;
    
        wcscpy(pwszSeqFilename, pwszCertDirectory);
        pwszSeqFilename[cchDir] = L'\\';
        wcscpy(pwszSeqFilename + cchDir + 1, CERT_AUTH_ROOT_SEQ_FILENAME);

        hSeqFile = CreateFileU(
                pwszSeqFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
        if (INVALID_HANDLE_VALUE == hSeqFile) {
            PrintLastError("Create Seq File");
            goto ErrorReturn;
        }

        if (!WriteFile(
                hSeqFile,
                szSeq,
                cbSeq * 2,
                &cbBytesWritten,
                NULL            // lpOverlapped
                )) {
            PrintLastError("Write Seq File");
            goto ErrorReturn;
        }
    }


    ReturnStatus = 0;
    printf("Succeeded\n");

CommonReturn:
    if (pwszCtlFilename)
        free(pwszCtlFilename);
    if (pwszSeqFilename)
        free(pwszSeqFilename);
    if (pwszCertDirectory)
        free(pwszCertDirectory);
    if (pCtl)
        CertFreeCTLContext(pCtl);

    if (hAddStore)
        CertCloseStore(hAddStore, 0);
    if (hDeleteStore)
        CertCloseStore(hDeleteStore, 0);

    if (pCtlEntry)
        free(pCtlEntry);
    if (ppCtlEntry) {
        DWORD i;

        for (i = 0; i < cCert; i++)
            free(ppCtlEntry[i]);
        free(ppCtlEntry);
    }
    if (pCertEncoded)
        free(pCertEncoded);
    if (pbEncoded)
        free(pbEncoded);

    if (NULL != hCtlFile && INVALID_HANDLE_VALUE != hCtlFile)
        CloseHandle(hCtlFile);
    if (NULL != hSeqFile && INVALID_HANDLE_VALUE != hSeqFile)
        CloseHandle(hSeqFile);

    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;

OutOfMemory:
    printf("Failed:: out of memory\n");
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\makecat\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_PARAM_OUTPUTFILE            17
#define IDS_PARAMTEXT_OUTPUTFILE        18
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\osacheck\osacheck.cpp ===
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File : OSACHECK.CPP
//
// Synopsis: Tools to check OSATTR(s) of catalog file(s).
//
// History: DSIE - January 30, 2001
//
// Microsoft Corporation (c) Copy Rights 2001.
//

#include <io.h>
#include <tchar.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <crtdbg.h>
#include <direct.h>
#include <atlbase.h>
#include <windows.h>
#include <cryptui.h>
#include <wintrust.h>


////////////////////
//
// macros
//

#define ASSERT(x)      _ASSERT(x)
#define ARRAYSIZE(a)   (sizeof(a) / sizeof(a[0]))


////////////////////
//
// Global variables
//

_TCHAR * g_pszFilePath        = _T("");     // Pointer to catalog file path.
BOOL     g_bCatalogOSAttrOnly = FALSE;      // OSAttr listing only flag.
BOOL     g_bIncludeSubDir     = FALSE;      // Inlcude sub-dir flag.
BOOL     g_bIgnoreError       = FALSE;      // Ignore error flag.
BOOL     g_bVerbose           = FALSE;      // Verbose flag.
BOOL     g_bViewCatalog       = FALSE;      // Display catalog dialog flag.


//------------------------------------------------------------------------------
//
//  Function: DebugTrace
//
//------------------------------------------------------------------------------

#ifdef PKIDEBUG

BOOL g_bUseOutputDebugString = FALSE; // Use OutputDebugString flag.

void DebugTrace (char * pszFormat, ...)
{
    char szMessage[512] = "";
   
    va_list arglist;

    va_start(arglist, pszFormat);

    _vsnprintf(szMessage, ARRAYSIZE(szMessage), pszFormat, arglist);

    if (g_bUseOutputDebugString)
    {
        OutputDebugString(szMessage);
    }
    else
    {
        fprintf(stderr, szMessage);
    }

    va_end(arglist);

    return;
}
#else
inline void DebugTrace (char * pszFormat, ...) {}
#endif


//------------------------------------------------------------------------------
//
//  Function: DisplayHelp
//
//------------------------------------------------------------------------------

void DisplayHelp (_TCHAR * pszFullExePath, BOOL bExtraHelp)
{
    _TCHAR szDrive[_MAX_DRIVE] = _T("");
    _TCHAR szDir[_MAX_DIR]     = _T("");
    _TCHAR szFName[_MAX_FNAME] = _T("");
    _TCHAR szExt[_MAX_EXT]     = _T("");

    _TCHAR * pszExeName = _T("OSACheck");

    if (pszFullExePath)
    {
        _splitpath(pszFullExePath, szDrive, szDir, szFName, szExt);
        pszExeName = szFName;
    }

    _ftprintf(stderr, _T("Usage: %s [drive:][path][filename] [options]\n"), pszExeName);
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("    [drive:][path][filename]\n"));
    _ftprintf(stderr, _T("        Specifies drive, directory, and/or catalog files to scan.\n"));
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("    [options]\n"));
    _ftprintf(stderr, _T("        -c   List only catalog OSAttrs (no file listing).\n"));
    _ftprintf(stderr, _T("        -s   Scan catalog files in specified directory and all subdirectories.\n"));
    _ftprintf(stderr, _T("        -i   Ignore error and continue with next catalog file.\n"));
    _ftprintf(stderr, _T("        -v   Verbose.\n"));
    if (bExtraHelp)
    {
#ifdef PKIDEBUG
        _ftprintf(stderr, _T("        ~d   Display catalog dialog.\n"));
        _ftprintf(stderr, _T("        ~o   Use OutputDebugString() for debug trace.\n"));
#endif
        _ftprintf(stderr, _T("        ~h   This help screen.\n"));
    }
    else
    {
        _ftprintf(stderr, _T("        -h   This help screen.\n"));
    }
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("Note: If filename is not provided, *.CAT is assumed.\n"));
    _ftprintf(stderr, _T("\n"));
    return;
}


//------------------------------------------------------------------------------
//
//  Function: ParseCommandLine
//
//------------------------------------------------------------------------------

int ParseCommandLine (int argc, _TCHAR * argv[])
{
    int  nResult      = 0;
    BOOL bDisplayHelp = FALSE;
    BOOL bExtraHelp   = FALSE;

    ASSERT(argc);
   
    for (int i = 1; i < argc; i++)
    {
        ASSERT(argv[i]);

        if (_T('-') == argv[i][0] || _T('/') == argv[i][0])
        {
            switch (toupper(argv[i][1]))
            {
                case _T('C'):
                {
                    g_bCatalogOSAttrOnly = TRUE;
                    break;
                }

                case _T('I'):
                {
                    g_bIgnoreError = TRUE;
                    break;
                }

                case _T('S'):
                {
                    g_bIncludeSubDir = TRUE;
                    break;
                }

                 case _T('V'):
                {
                    g_bVerbose = TRUE;
                    break;
                }

                case _T('?'):
                case _T('H'):

                default:
                {
                    nResult = -1;
                    bDisplayHelp = TRUE;
                    break;
                }
            }
        }
        else if (_T('~') == argv[i][0])
        {
            switch (toupper(argv[i][1]))
            {
                case _T('D'):
                {
                    g_bViewCatalog = TRUE;
                    break;
                }

#ifdef PKIDEBUG
                case _T('O'):
                {
                    g_bUseOutputDebugString = TRUE;
                    break;
                }
#endif
                case _T('?'):
                case _T('H'):

                default:
                {
                    nResult = -1;
                    bExtraHelp = TRUE;
                    bDisplayHelp = TRUE;
                    break;
                }
            }
        }
        else if (0 == _tcslen(g_pszFilePath))
        {
            g_pszFilePath = argv[i];

            if (NULL == _tcschr(g_pszFilePath, _T('*')) && NULL == strchr(g_pszFilePath, _T('?')))
            {
                long   hFile;
                struct _finddata_t fd;

                if (-1 != (hFile = _tfindfirst(g_pszFilePath, &fd)))
                {
                    if (_A_SUBDIR & fd.attrib)
                    {
                        if (_T('\\') != g_pszFilePath[_tcslen(g_pszFilePath) - 1])
                        {
                            if (g_pszFilePath = (_TCHAR *) malloc((_tcslen(g_pszFilePath) + 
                                                                   _tcslen(_T("\\")) + 1) * 
                                                                   sizeof(_TCHAR)))
                            {
                                _tcscpy(g_pszFilePath, argv[i]);
                                _tcscat(g_pszFilePath, _T("\\"));
                            }
                            else
                            {
                                nResult = -2;
                            }
                        }
                    }

                    _findclose(hFile);
                }
            }
        }
        else
        {
            nResult = -3;
            bDisplayHelp = TRUE;
        }

        if (bDisplayHelp)
        {
            DisplayHelp(argv[0], bExtraHelp);
            break;
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ViewCatalog
//
//------------------------------------------------------------------------------

int ViewCatalog (PCCTL_CONTEXT pCTLContext)
{
    CRYPTUI_VIEWCTL_STRUCT ViewCTLStruct;

    ASSERT(pCTLContext);

    memset(&ViewCTLStruct, 0, sizeof(ViewCTLStruct));
    ViewCTLStruct.dwSize = sizeof(ViewCTLStruct);
    ViewCTLStruct.pCTLContext = pCTLContext;

    CryptUIDlgViewCTL(&ViewCTLStruct);

    return 0;
}


//------------------------------------------------------------------------------
//
// Function: DecodeObject
//
//------------------------------------------------------------------------------

int DecodeObject (LPCSTR            pszStructType, 
                  BYTE            * pbEncoded,
                  DWORD             cbEncoded,
                  CRYPT_DATA_BLOB * pDecodedBlob)
{
    int    nResult   = 0;
    DWORD  cbDecoded = 0;
    BYTE * pbDecoded = NULL;

    ASSERT(pszStructType);
    ASSERT(pbEncoded);
    ASSERT(pDecodedBlob);

    __try
    {
        pDecodedBlob->cbData = 0;
        pDecodedBlob->pbData = NULL;

        if (!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pszStructType,
                               (const BYTE *) pbEncoded,
                               cbEncoded,
                               0,
                               NULL,
                               &cbDecoded))
        {
            nResult = GetLastError();
            DebugTrace("\nError [%#x]: CryptDecodeObject() failed.\n", nResult);
            __leave;
        }

        if (!(pbDecoded = (BYTE *) malloc(cbDecoded)))
        {
            nResult = E_OUTOFMEMORY;
            DebugTrace("\nError: out of memory.\n");
            __leave;
        }

        if (!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pszStructType,
                               (const BYTE *) pbEncoded,
                               cbEncoded,
                               0,
                               pbDecoded,
                               &cbDecoded))
        {
            nResult = GetLastError();
            DebugTrace("\nError [%#x]: CryptDecodeObject() failed.\n", nResult);
            __leave;
        }

        pDecodedBlob->cbData = cbDecoded;
        pDecodedBlob->pbData = pbDecoded;
    }

    __finally
    {
        if (nResult && pbDecoded)
        {
            free(pbDecoded);
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessFileOSAttr
//
//------------------------------------------------------------------------------

int ProcessFileOSAttr (PCTL_INFO pCTLInfo)
{
    int  nResult = 0;

    ASSERT(pCTLInfo);
 
    for (DWORD i = 0; i < pCTLInfo->cCTLEntry; i++)
    {
        DWORD      cOSAttr = 0;
        DWORD      cFiles  = 0;
        PCTL_ENTRY pCTLEntry = &pCTLInfo->rgCTLEntry[i];
 
        if (i)
        {
            if (g_bVerbose)
            {
                _ftprintf(stdout, _T("\n%-10s"), _T(""));
            }
            else
            {
                _ftprintf(stdout, _T("\n%-14s"), _T(""));
            }
        }

        _ftprintf(stdout, _T("%-40S "), pCTLEntry->SubjectIdentifier.pbData);

        for (DWORD j = 0; j < pCTLEntry->cAttribute; j++)
        {
            PCRYPT_ATTRIBUTE pAttribute    = &pCTLEntry->rgAttribute[j];
            CRYPT_DATA_BLOB  DataBlob      = {0, NULL};
            PCAT_NAMEVALUE   pCATNameValue = NULL;

            if (0 != strcmp(pAttribute->pszObjId, CAT_NAMEVALUE_OBJID))
            {
                continue;
            }

            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pAttribute->rgValue[0].pbData,
                                             pAttribute->rgValue[0].cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"File", pCATNameValue->pwszTag))
            {
                j = pCTLEntry->cAttribute;
                _ftprintf(stdout, _T("%-15S "), pCATNameValue->Value.pbData);
                cFiles++;
            }

            free(DataBlob.pbData);
        }

        if (0 == cFiles)
        {
            _ftprintf(stdout, _T("%-15s "), "");
        }

        for (j = 0; j < pCTLEntry->cAttribute; j++)
        {
            PCRYPT_ATTRIBUTE pAttribute    = &pCTLEntry->rgAttribute[j];
            CRYPT_DATA_BLOB  DataBlob      = {0, NULL};
            PCAT_NAMEVALUE   pCATNameValue = NULL;

            if (0 != strcmp(pAttribute->pszObjId, CAT_NAMEVALUE_OBJID))
            {
                continue;
            }

            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pAttribute->rgValue[0].pbData,
                                             pAttribute->rgValue[0].cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"OSAttr", pCATNameValue->pwszTag))
            {
                j = pCTLEntry->cAttribute;
                _ftprintf(stdout, _T("%S "), pCATNameValue->Value.pbData);
                cOSAttr++;
            }

            free(DataBlob.pbData);
        }
    }
 
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalogOSAttr
//
//------------------------------------------------------------------------------

int ProcessCatalogOSAttr (PCTL_INFO pCTLInfo)
{
    int   nResult = 0;
    DWORD cOSAttr = 0;

    ASSERT(pCTLInfo);

    for (DWORD i = 0; i < pCTLInfo->cExtension; i++)
    {
        PCERT_EXTENSION pExtension = &pCTLInfo->rgExtension[i];

        if (0 == strcmp(CAT_NAMEVALUE_OBJID, pExtension->pszObjId))
        {
            BOOL            bDuplicate    = TRUE;
            CRYPT_DATA_BLOB DataBlob      = {0, NULL};
            PCAT_NAMEVALUE  pCATNameValue = NULL;
    
            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pExtension->Value.pbData,
                                             pExtension->Value.cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"OSAttr", pCATNameValue->pwszTag))
            {
                i = pCTLInfo->cExtension;
                _ftprintf(stdout, _T("%S"), pCATNameValue->Value.pbData);
                cOSAttr++;
            }

            free(DataBlob.pbData);
        }
    }

    if (0 == cOSAttr)
    {
        _ftprintf(stdout, _T("None"));
    }
    
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalog
//
//------------------------------------------------------------------------------

int ProcessCatalog (_TCHAR * pszFileName)
{
    int           nResult     = 0;
    PCCTL_CONTEXT pCTLContext = NULL;

    ASSERT(pszFileName);

    __try
    {
        USES_CONVERSION;
        WCHAR * pwszFileName = NULL;

        if (g_bVerbose)
        {
            _TCHAR szCWD[_MAX_PATH] = _T("");

            if (_tgetcwd(szCWD, ARRAYSIZE(szCWD)))
            {
                if (szCWD[_tcslen(szCWD) - 1] != _T('\\'))
                {
                    szCWD[_tcslen(szCWD) + 1] = _T('\0');
                    szCWD[_tcslen(szCWD)] = _T('\\');
                }

                _ftprintf(stdout, _T("-------------------------------------------------------------------------------\n"));
                _ftprintf(stdout, _T("Catalog = %s%s\n"), szCWD, pszFileName);
            }
        }
        else
        {
            _ftprintf(stdout, _T("%-14s"), pszFileName);
        }

        if (NULL == (pwszFileName = T2W(pszFileName)))
        {
            nResult = E_OUTOFMEMORY;
            DebugTrace(_T("Error: out of memory.\n"));
            __leave;
        }

        if (!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                              pwszFileName,
                              CERT_QUERY_CONTENT_FLAG_CTL,
                              CERT_QUERY_FORMAT_FLAG_ALL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              (const void **) &pCTLContext))
        {
            nResult = GetLastError();
            DebugTrace(_T("Error [%#x]: CryptQueryObject() failed.\n"), nResult);
            __leave;
        }

        if (g_bVerbose)
        {
            _ftprintf(stdout, _T("Entries = %d\n"), pCTLContext->pCtlInfo->cCTLEntry);
            if (g_bCatalogOSAttrOnly)
            {
                _ftprintf(stdout, _T("OSAttrs = "));
            }
            else
            {
                _ftprintf(stdout, _T("Details = "));
            }
        }

        if (g_bCatalogOSAttrOnly)
        {
            nResult = ProcessCatalogOSAttr(pCTLContext->pCtlInfo);
        }
        else
        {
            nResult = ProcessFileOSAttr(pCTLContext->pCtlInfo);
        }

        _ftprintf(stdout, _T("\n"));

        if (0 != nResult)
        {
            __leave;
        }

        if (g_bViewCatalog)
        {
            ViewCatalog(pCTLContext);
        }
    }

    __finally
    {
        if (pCTLContext)
        {
            CertFreeCTLContext(pCTLContext);
        }
    }
    
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalogs
//
//------------------------------------------------------------------------------

int ProcessCatalogs (_TCHAR * pszFilePath, BOOL bIncludeSubDir)
{
    int   nResult = 0;
    long  hFile   = -1;
    TCHAR szFilePath[_MAX_PATH] = _T("");

    ASSERT(pszFilePath);

    __try
    {
        DWORD cDirs = 0;
        struct _finddata_t fd;

        if (0 == _tcslen(pszFilePath))
        {
            _tcscpy(szFilePath, _T("*.cat"));
        }
        else
        {
            _tcscpy(szFilePath, pszFilePath);
        }

        if (-1 != (hFile = _tfindfirst(szFilePath, &fd)))
        {
            do
            {
                if (_A_SUBDIR & fd.attrib)
                {    
                    if (_tcscmp(_T("."), fd.name) && _tcscmp(_T(".."), fd.name))
                    {
                        cDirs++;
                    }
                }
                else 
                {
                    if (0 != (nResult = ProcessCatalog(fd.name)))
                    {
                        if (g_bIgnoreError)
                        {
                            nResult = 0;
                        }
                        else
                        {
                            __leave;
                        }
                    }
                }
             } while (0 == _tfindnext(hFile, &fd));

            _findclose(hFile);
            hFile = -1;
        }

        if (bIncludeSubDir)
        {
            if (0 == cDirs)
            {
                _tcscpy(szFilePath, _T("*.*"));
            }

            if (-1 != (hFile = _tfindfirst(szFilePath, &fd)))
            {
                do
                {
                    if ((_A_SUBDIR & fd.attrib) && _tcscmp(_T("."), fd.name) && _tcscmp(_T(".."), fd.name))
                    {
                        _TCHAR szCWD[_MAX_PATH] = _T("");

                        if (_tgetcwd(szCWD, ARRAYSIZE(szCWD)))
                        {
                            _tchdir(fd.name);

                            nResult = ProcessCatalogs(pszFilePath, bIncludeSubDir);

                            _tchdir(szCWD);
                        }
                        else
                        {
                            nResult = errno;
                            DebugTrace(_T("\nError [%#x]: _tgetcwd() failed.\n"), errno);
                        }

                        if (0 != nResult)
                        {
                            if (g_bIgnoreError)
                            {
                                nResult = 0;
                            }
                            else
                            {
                                __leave;
                            }
                        }
                    }
                } while (0 == _tfindnext(hFile, &fd));

                _findclose(hFile);
                hFile = -1;
            }
        }
    }

    __finally
    {
        if (-1 != hFile)
        {
            _findclose(hFile);
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: main
//
//------------------------------------------------------------------------------

int __cdecl _tmain (int argc, _TCHAR  * argv[])
{
    int    nResult          = 0;
    int    CurrentDrive     = _getdrive();
    _TCHAR szCWD[_MAX_PATH] = _T("");

    _tgetcwd(szCWD, sizeof(szCWD) / sizeof(szCWD[0]));

    __try
    {
        _TCHAR szDrive[_MAX_DRIVE]   = _T("");
        _TCHAR szDir[_MAX_DIR]       = _T("");
        _TCHAR szFName[_MAX_FNAME]   = _T("");
        _TCHAR szExt[_MAX_EXT]       = _T("");
        _TCHAR szFilePath[_MAX_PATH] = _T("");

        if (0 != (nResult = ParseCommandLine(argc, argv)))
        {
            __leave;
        }

        if (g_bVerbose)
        {
            _ftprintf(stdout, _T("Current drive = %c:\n"), CurrentDrive - 1 + _T('A'));
            _ftprintf(stdout, _T("Current directory = %s\n"), szCWD);
            _ftprintf(stdout, _T("Command line ="));
            for (int i = 0; i < argc; i++)
            {
                _ftprintf(stdout, _T(" %s"), argv[i]);
            }
            _ftprintf(stdout, _T("\n"));
        }

        _splitpath(g_pszFilePath, szDrive, szDir, szFName, szExt);

        if (_tcslen(szDrive))
        {
            if (0 != _chdrive(toupper(szDrive[0]) - _T('A') + 1))
            {
                nResult = ENOENT;
                _ftprintf(stdout, _T("Error: _chdrive() to %s failed.\n"), szDrive);
                __leave;
            }
        }

        if (_tcslen(szDir))
        {
            if (0 != _tchdir(szDir))
            {
                nResult = ENOENT;
                _ftprintf(stdout, _T("Error: _tchdir() to %s failed.\n"), szDir);
                __leave;
            }
        }

        _tcscpy(szFilePath, szFName);
        _tcscat(szFilePath, szExt);

        nResult = ProcessCatalogs(szFilePath, g_bIncludeSubDir);
    }

    __finally
    {
        _chdrive(CurrentDrive);

        _tchdir(szCWD);
    }

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\mscrlrev\mscrlrev.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:	    mscrlrev.cpp
//
//  Contents:   Check CRLs in CA store version of CertDllVerifyRevocation.
//
//              Restrictions:
//               - Only support CRYPT_ASN_ENCODING
//               - CRL must already be in the CA system store
//               - CRL must be issued and signed by the issuer of the
//                 certificate
//               - CRL must not have any critical extensions
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyRevocation
//
//  History:	15-Mar-01	philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


//+-------------------------------------------------------------------------
// Default stores searched to find an issuer of the subject certificate
//--------------------------------------------------------------------------
struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultIssuerStores[] = {
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER
};
#define NUM_DEFAULT_ISSUER_STORES (sizeof(rgDefaultIssuerStores) / \
                                    sizeof(rgDefaultIssuerStores[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//  DllRegisterServer
//--------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_FIRST_INDEX,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllUnregisterServer
//--------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    if (!CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  Local functions called by CertDllVerifyRevocation
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    );

BOOL GetSubjectCrl (
    IN PCCERT_CONTEXT pSubject,
    IN PCCERT_CONTEXT pIssuer,
    OUT PCCRL_CONTEXT* ppCrl
    );

PCRL_ENTRY FindCertInCrl(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN PCERT_REVOCATION_PARA pRevPara
    );

DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    );

//+-------------------------------------------------------------------------
//  CertDllVerifyRevocation using pre-loaded CRLs in the CA store
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    DWORD dwReason = 0;
    PCCERT_CONTEXT pCert;                       // not allocated
    PCCERT_CONTEXT pIssuer = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    PCRL_ENTRY pCrlEntry;

    if (cContext == 0)
        goto NoContextError;
    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    pCert = (PCCERT_CONTEXT) rgpvContext[0];

    // Get the certificate's issuer
    if (NULL == (pIssuer = GetIssuerCert(
            cContext,
            (PCCERT_CONTEXT *) rgpvContext,
            dwFlags,
            pRevPara
            )))
        goto NoIssuerError;

    if (!GetSubjectCrl(
            pCert,
            pIssuer,
            &pCrl
            ))
        goto NoCrl;

    // Check if revoked
    pCrlEntry = FindCertInCrl(pCert, pCrl, pRevPara);
    if (pCrlEntry) {
        dwError = (DWORD) CRYPT_E_REVOKED;
        dwReason = GetCrlReason(pCrlEntry);
        goto Revoked;
    }

CommonReturn:
    if (pIssuer)
        CertFreeCertificateContext(pIssuer);
    if (pCrl)
        CertFreeCRLContext(pCrl);

    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;
    SetLastError(dwError);
    return FALSE;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(NoContextError)
TRACE_ERROR(NoRevocationCheckForEncodingTypeError)
TRACE_ERROR(NoRevocationCheckForRevTypeError)
TRACE_ERROR(NoIssuerError)
TRACE_ERROR(NoCrl)
TRACE_ERROR(Revoked)
}


//+-------------------------------------------------------------------------
//  If the CRL entry has a CRL Reason extension, the enumerated reason
//  code is returned. Otherwise, a reason code of 0 is returned.
//--------------------------------------------------------------------------
DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    )
{
    DWORD dwReason = 0;
    PCERT_EXTENSION pExt;

    // Check if the certificate has a szOID_CRL_REASON_CODE extension
    if (pExt = CertFindExtension(
            szOID_CRL_REASON_CODE,
            pCrlEntry->cExtension,
            pCrlEntry->rgExtension
            )) {
        DWORD cbInfo = sizeof(dwReason);
        CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            X509_CRL_REASON_CODE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            &dwReason,
            &cbInfo);
    }
    return dwReason;
}

//+=========================================================================
//  Get Issuer Certificate Functions
//==========================================================================

PCCERT_CONTEXT FindIssuerCertInStores(
    IN PCCERT_CONTEXT pSubjectCert,
    IN DWORD cStore,
    IN HCERTSTORE rgStore[]
    )
{
    PCCERT_CONTEXT pIssuerCert = NULL;
    DWORD i;

    for (i = 0; i < cStore; i++) {
        while (TRUE) {
            DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
            pIssuerCert = CertGetIssuerCertificateFromStore(
                rgStore[i],
                pSubjectCert,
                pIssuerCert,
                &dwFlags);
            if (NULL == pIssuerCert)
                break;
            else if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                return pIssuerCert;
        }
    }

    return NULL;
}

PCCERT_CONTEXT FindIssuerCertInDefaultStores(
    IN PCCERT_CONTEXT pSubjectCert
    )
{
    PCCERT_CONTEXT pIssuerCert;
    HCERTSTORE hStore;
    DWORD i;

    for (i = 0; i < NUM_DEFAULT_ISSUER_STORES; i++) {    
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_W,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                rgDefaultIssuerStores[i].dwFlags | CERT_STORE_READONLY_FLAG,
                (const void *) rgDefaultIssuerStores[i].pwszStore
                )) {
            pIssuerCert = FindIssuerCertInStores(pSubjectCert, 1, &hStore);
            CertCloseStore(hStore, 0);
            if (pIssuerCert)
                return pIssuerCert;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the issuer of the first certificate in the array
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    PCCERT_CONTEXT pSubjectCert;
    PCCERT_CONTEXT pIssuerCert = NULL;

    assert(cCert >= 1);
    pSubjectCert = rgpCert[0];
    if (cCert == 1) {
        if (pRevPara && pRevPara->cbSize >=
                (offsetof(CERT_REVOCATION_PARA, pIssuerCert) +
                    sizeof(pRevPara->pIssuerCert)))
            pIssuerCert = pRevPara->pIssuerCert;
        if (NULL == pIssuerCert && CertCompareCertificateName(
                pSubjectCert->dwCertEncodingType,
                &pSubjectCert->pCertInfo->Subject,
                &pSubjectCert->pCertInfo->Issuer))
            // Self issued
            pIssuerCert = pSubjectCert;
    } else if (dwFlags && CERT_VERIFY_REV_CHAIN_FLAG)
        pIssuerCert = rgpCert[1];

    if (pIssuerCert)
        pIssuerCert = CertDuplicateCertificateContext(pIssuerCert);
    else {
        if (pRevPara && pRevPara->cbSize >=
                (offsetof(CERT_REVOCATION_PARA, rgCertStore) +
                    sizeof(pRevPara->rgCertStore)))
            pIssuerCert = FindIssuerCertInStores(
                pSubjectCert, pRevPara->cCertStore, pRevPara->rgCertStore);
        if (NULL == pIssuerCert)
            pIssuerCert = FindIssuerCertInDefaultStores(pSubjectCert);
    }

    if (NULL == pIssuerCert)
        SetLastError(CRYPT_E_NO_REVOCATION_CHECK);
    return pIssuerCert;
}



//+-------------------------------------------------------------------------
//  Check that the CRL doesn't have any critical extensions
//--------------------------------------------------------------------------
BOOL IsExtensionValidCrl(
    IN PCCRL_CONTEXT pCrl
    )
{
    DWORD cExt = pCrl->pCrlInfo->cExtension;
    PCERT_EXTENSION pExt = pCrl->pCrlInfo->rgExtension;

    for ( ; cExt > 0; cExt--, pExt++) {
        if (pExt->fCritical)
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSubjectCrl
//
//  Synopsis:   get the CRL associated with the subject certificate
//
//----------------------------------------------------------------------------
BOOL GetSubjectCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        OUT PCCRL_CONTEXT* ppCrl
        )
{
    BOOL  fResult;
    HCERTSTORE hStore;
    PCCRL_CONTEXT pFindCrl = NULL;
    DWORD dwGetCrlFlags = CERT_STORE_SIGNATURE_FLAG;

    *ppCrl = NULL;

    hStore = CertOpenSystemStoreW( NULL, L"CA" );
    if ( hStore != NULL )
    {
        while ( ( pFindCrl = CertGetCRLFromStore(
                                 hStore,
                                 pIssuer,
                                 pFindCrl,
                                 &dwGetCrlFlags
                                 ) ) != NULL )
        {
            if ( dwGetCrlFlags != 0 || !IsExtensionValidCrl( pFindCrl ))
            {
                dwGetCrlFlags = CERT_STORE_SIGNATURE_FLAG;
                continue;
            }

            *ppCrl = pFindCrl;
            break;
        }

        CertCloseStore( hStore, 0 );

        if ( *ppCrl != NULL )
        {
            return( TRUE );
        }

    }

    return( FALSE );
}

//+-------------------------------------------------------------------------
//  Find a certificate identified by its serial number in the CRL.
//--------------------------------------------------------------------------
PCRL_ENTRY FindCertInCrl(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    DWORD cEntry = pCrl->pCrlInfo->cCRLEntry;
    PCRL_ENTRY pEntry = pCrl->pCrlInfo->rgCRLEntry;
    DWORD cbSerialNumber = pCert->pCertInfo->SerialNumber.cbData;
    BYTE *pbSerialNumber = pCert->pCertInfo->SerialNumber.pbData;

    if (0 == cbSerialNumber)
        return NULL;

    for ( ; 0 < cEntry; cEntry--, pEntry++) {
        if (cbSerialNumber == pEntry->SerialNumber.cbData &&
                0 == memcmp(pbSerialNumber, pEntry->SerialNumber.pbData,
                                cbSerialNumber))
        {
            if (pRevPara && pRevPara->cbSize >=
                    (offsetof(CERT_REVOCATION_PARA, pftTimeToUse) +
                        sizeof(pRevPara->pftTimeToUse))
                            &&
                    NULL != pRevPara->pftTimeToUse
                            &&
                    0 > CompareFileTime(pRevPara->pftTimeToUse,
                            &pEntry->RevocationDate))
                // It was used before being revoked
                return NULL;
            else
                return pEntry;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\updcat\updcat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       updcat.cpp
//
//  Contents:   Update Catalog Entry
//
//  History:    02-Sep-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <mscat.h>
#include <mssip.h>
#include <sipguids.h>
#include <wintrust.h>

// Prototypes

BOOL AddFileToCatalog (IN HANDLE hCatalog, IN LPWSTR pwszFileName);
BOOL RemoveHashFromCatalog(IN LPWSTR pwszCatalogFile, IN LPSTR pszHash);
extern "C" BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);
extern "C" VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);


#define PWSZ_SPATTR         L"SpAttr"
#define PSZ_SPATTR_OPTION   "-SpAttr:"

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: updcat <Catalog File> [-a <FileName>]\n");
    printf("Usage: updcat <Catalog File> [-d <Hash>]\n");
    printf("Usage: updcat <Catalog File> [-r <Hash> <FileName>]\n");
    printf("       -a, add the file by hash to the catalog\n");
    printf("       -d, delete the hash from the catalog\n");
    printf("       -r, replace the hash in the catalog with the hash of the file\n");
    printf("       -SpAttr:, replace the current SpAttr in the catalog file (will add if does not already exist)\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
    BOOL   fResult = TRUE;
    LPSTR  pszCatalogFile = NULL;
    LPWSTR pwszCatalogFile = NULL;
    LPSTR  pszFileName = NULL;
    LPSTR  pszHash = NULL;
    LPWSTR pwszFileName = NULL;
    BOOL   fAddEntry = FALSE;
    DWORD  cch = 0;
    HANDLE hCatalog = NULL;
    BOOL   fOptionChosen = FALSE; 
    LPWSTR pwszSpAttr = NULL;
    CRYPTCATATTRIBUTE *pCatAttr = NULL;

    if ( argc < 2 )
    {
        Usage();
        return( 1 );
    }

    argv++;
    argc--;

    printf( "command line: %s\n", GetCommandLineA() );

    pszCatalogFile = argv[0];
    cch = strlen( pszCatalogFile );

    while ( --argc > 0 )
    {
        if ( **++argv == '-' )
        {
            switch( argv[0][1] )
            {
            case 'a':
            case 'A':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszFileName = argv[1];
                fAddEntry = TRUE;
                break;

            case 'd':
            case 'D':
                
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszHash = argv[1];
                break;

            case 'r':
            case 'R':
                
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszHash = argv[1];
                fAddEntry = TRUE;
                pszFileName = argv[2];
                break;

            case 'S':
                
                if (memcmp(&(argv[0][0]), (void *) PSZ_SPATTR_OPTION, strlen(PSZ_SPATTR_OPTION)) == 0)
                {
                    DWORD dwNumChars;

                    dwNumChars = MultiByteToWideChar(
                                      CP_ACP,
                                      0,
                                      &(argv[0][strlen(PSZ_SPATTR_OPTION)]),
                                      -1,
                                      NULL,
                                      0
                                      );

                    if (dwNumChars == 0)
                    {
                        printf( "Error calling MultiByteToWideChar on %s\n", &(argv[0][strlen(PSZ_SPATTR_OPTION)]));
                        return -1;
                    }

                    pwszSpAttr = new WCHAR [ dwNumChars ];

                    if (pwszSpAttr == NULL)
                    {
                        printf("Out of memory error\n");
                        return -1;
                    }
                    
                    if ( MultiByteToWideChar(
                              CP_ACP,
                              0,
                              &(argv[0][strlen(PSZ_SPATTR_OPTION)]),
                              -1,
                              pwszSpAttr,
                              dwNumChars
                              ) == 0 )
                    {
                        
                        delete pwszSpAttr;
                        printf( "Error calling MultiByteToWideChar on %s\n", &(argv[0][strlen(PSZ_SPATTR_OPTION)]));
                        return -1;
                    }
                }
                else
                {
                    Usage();
                    return -1;
                }

                break;

            default:
                Usage();
                return -1;
            }
            
            fOptionChosen = TRUE;
            argc -= 1;
            argv++;
        }
    }

    pwszCatalogFile = new WCHAR [ cch + 1 ];
    if ( pwszCatalogFile != NULL )
    {
        if ( MultiByteToWideChar(
                  CP_ACP,
                  0,
                  pszCatalogFile,
                  -1,
                  pwszCatalogFile,
                  cch + 1
                  ) == 0 )
        {
            delete pwszCatalogFile;
            return( 1 );
        }
    }

    if (!fOptionChosen)
    {
        Usage();
        delete pwszCatalogFile;
        return -1;
    }

    if (pszFileName != NULL)
    {
        cch = strlen( pszFileName );

        pwszFileName = new WCHAR [ cch + 1 ];
        if ( pwszFileName != NULL )
        {
            if ( MultiByteToWideChar(
                      CP_ACP,
                      0,
                      pszFileName,
                      -1,
                      pwszFileName,
                      cch + 1
                      ) == 0 )
            {
                delete pwszCatalogFile;
                delete pwszFileName;
                return( 1 );
            }
        }
    }

    if ( pszHash != NULL )
    {
        fResult = RemoveHashFromCatalog(pwszCatalogFile, pszHash);

        if ( fResult == FALSE )
        {
            printf("Error removing <%s> from catalog <%s>\n", pszHash, pszCatalogFile);
        }
    }

    //
    // If there hasn't been any errors, and we are adding a hash 
    //
    if (( fResult == TRUE ) && ( fAddEntry == TRUE ))
    {
        hCatalog = CryptCATOpen(
                        pwszCatalogFile,
                        CRYPTCAT_OPEN_ALWAYS,
                        NULL,
                        0x00000001,
                        0x00010001
                        );

        if ( hCatalog == NULL )
        {
            fResult = FALSE;
        }

        if ( fResult == TRUE )
        {
            fResult = AddFileToCatalog( hCatalog, pwszFileName );
            CryptCATClose( hCatalog );
        }

        if ( fResult == FALSE )
        {
            printf("Error adding <%s> to catalog <%s>\n", pszFileName, pszCatalogFile);
        }        
    }

    if ( pwszSpAttr != NULL )
    {
        hCatalog = CryptCATOpen(
                        pwszCatalogFile,
                        CRYPTCAT_OPEN_ALWAYS,
                        NULL,
                        0x00000001,
                        0x00010001
                        );

        if ( hCatalog == NULL )
        {
            fResult = FALSE;
            goto Return;
        }

        //
        // Check to see if it already has an SpAttr
        //
        pCatAttr = CryptCATGetCatAttrInfo(hCatalog, PWSZ_SPATTR);

        if ( pCatAttr == NULL )
        {
           if (NULL == CryptCATPutCatAttrInfo(
                            hCatalog, 
                            PWSZ_SPATTR, 
                            0x10010001,
                            (wcslen(pwszSpAttr) + 1) * sizeof(WCHAR),
                            (BYTE *) pwszSpAttr))
           {
                printf("Error adding SpAttr to catalog <%s>\n", pszCatalogFile);
                fResult = FALSE;
                goto Return;
           }          
        }
        else
        {
            if (NULL == CryptCATPutCatAttrInfo(
                            hCatalog, 
                            PWSZ_SPATTR, 
                            0x10040001,
                            (wcslen(pwszSpAttr) + 1) * sizeof(WCHAR),
                            (BYTE *) pwszSpAttr))
           {
                if (GetLastError() == ERROR_INVALID_PARAMETER)
                {
                    printf("The SpAttr modification failed, it is likely due to an old wintrust.dll\n");
                }
                else
                {
                    printf("Error changing SpAttr in catalog <%s>\n", pszCatalogFile);
                }
                fResult = FALSE;
                goto Return;
           }

            
        }

        CryptCATPersistStore(hCatalog);
        CryptCATClose( hCatalog );
    }

Return:
    return( !fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   AddFileToCatalog
//
//  Synopsis:   add a file as an entry to the catalog.  The tag will be the
//              hash
//
//----------------------------------------------------------------------------
BOOL AddFileToCatalog (IN HANDLE hCatalog, IN LPWSTR pwszFileName)
{
    BOOL               fResult;
    GUID               FlatSubject = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID               SubjectType;
    SIP_SUBJECTINFO    SubjectInfo;
    SIP_DISPATCH_INFO  DispatchInfo;
    DWORD              cbIndirectData;
    SIP_INDIRECT_DATA* pIndirectData;
    CRYPTCATSTORE*     pCatStore = CryptCATStoreFromHandle( hCatalog );
    LPWSTR             pwszHashTag = NULL;

    memset( &SubjectInfo, 0, sizeof( SubjectInfo ) );
    memset( &DispatchInfo, 0, sizeof( DispatchInfo ) );

    if ( CryptSIPRetrieveSubjectGuid(
              pwszFileName,
              NULL,
              &SubjectType
              ) == FALSE )
    {
        memcpy( &SubjectType, &FlatSubject, sizeof( GUID ) );
    }

    if ( CryptSIPLoad( &SubjectType, 0, &DispatchInfo ) == FALSE )
    {
        return( FALSE );
    }

    // Some of this subject info stuff should be configurable but
    // since the CDF API does not allow it, we won't worry about it
    // yet.  
    SubjectInfo.cbSize = sizeof( SubjectInfo );
    SubjectInfo.hProv = pCatStore->hProv;
    SubjectInfo.DigestAlgorithm.pszObjId = (char *)CertAlgIdToOID( CALG_SHA1 );

    SubjectInfo.dwFlags = SPC_INC_PE_RESOURCES_FLAG |
                          SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                          MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;

    SubjectInfo.dwEncodingType = pCatStore->dwEncodingType;
    SubjectInfo.pgSubjectType = &SubjectType;
    SubjectInfo.pwsFileName = pwszFileName;

    fResult = DispatchInfo.pfCreate( &SubjectInfo, &cbIndirectData, NULL );

    if ( fResult == TRUE )
    {
        pIndirectData = (SIP_INDIRECT_DATA *)new BYTE [ cbIndirectData ];
        if ( pIndirectData != NULL )
        {
            fResult = DispatchInfo.pfCreate(
                                     &SubjectInfo,
                                     &cbIndirectData,
                                     pIndirectData
                                     );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        fResult = MsCatConstructHashTag(
                       pIndirectData->Digest.cbData,
                       pIndirectData->Digest.pbData,
                       &pwszHashTag
                       );
    }

    if ( fResult == TRUE )
    {
        CRYPTCATMEMBER* pMember;

        pMember = CryptCATPutMemberInfo(
                       hCatalog,
                       pwszFileName,
                       pwszHashTag,
                       &SubjectType,
                       SubjectInfo.dwIntVersion,
                       cbIndirectData,
                       (LPBYTE)pIndirectData
                       );

        if ( pMember != NULL )
        {
            fResult = CryptCATPersistStore( hCatalog );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( pwszHashTag != NULL )
    {
        MsCatFreeHashTag( pwszHashTag );
    }

    delete (LPBYTE)pIndirectData;

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveHashFromCatalog
//
//  Synopsis:   removes a hash entry from the catalog.  
//
//----------------------------------------------------------------------------
BOOL
RemoveHashFromCatalog(IN LPWSTR pwszCatalogFile, IN LPSTR pszHash)
{
    BOOL            fRet = TRUE;
    LPSTR           pChar = NULL;
    int             i, j;
    DWORD           dwContentType;
    PCTL_CONTEXT    pCTLContext = NULL;
    CTL_CONTEXT     CTLContext;
    CTL_INFO        CTLInfo;
    DWORD           cbEncodedCTL = 0;
    BYTE            *pbEncodedCTL = NULL;
    DWORD           cbWritten = 0;
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    DWORD           cch = 0;
    LPWSTR          pwszHash = NULL;
    BOOL            fHashFound = FALSE;

    CMSG_SIGNED_ENCODE_INFO signedInfo;
    memset(&signedInfo, 0, sizeof(signedInfo));
    signedInfo.cbSize = sizeof(signedInfo);


    CTLInfo.rgCTLEntry = NULL;

    cch = strlen( pszHash );

    pwszHash = new WCHAR [ cch + 1 ];
    if ( pwszHash == NULL )
    {
       goto ErrorReturn;   
    }
    if ( MultiByteToWideChar(
                  CP_ACP,
                  0,
                  pszHash,
                  -1,
                  pwszHash,
                  cch + 1
                  ) == 0 )
    {
        goto ErrorReturn;
    }

    //
    // Get rid of all the ' ' chars
    //
    i = 0;
    j = 0;
    for (i=0; i<(int)wcslen(pwszHash); i++)
    {
        if (pwszHash[i] != ' ')
        {
            pwszHash[j++] = pwszHash[i];
        }
    }
    pwszHash[j] = '\0';
        
    //
    // Open the cat file as a CTL
    //
    if (!CryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            pwszCatalogFile,
            CERT_QUERY_CONTENT_FLAG_CTL,
            CERT_QUERY_FORMAT_FLAG_BINARY,
            0, //flags
            NULL,
            &dwContentType,
            NULL,
            NULL,
            NULL,
            (const void **) &pCTLContext))
    {
        goto ErrorReturn;
    }

    if (dwContentType != CERT_QUERY_CONTENT_CTL)
    {
        goto ErrorReturn;
    }

    //
    // Create another CTL context just like pCTLContext
    //
    CTLInfo = *(pCTLContext->pCtlInfo);
    CTLInfo.rgCTLEntry = (PCTL_ENTRY) new CTL_ENTRY[pCTLContext->pCtlInfo->cCTLEntry];

    if (CTLInfo.rgCTLEntry == NULL)
    {
        goto ErrorReturn;
    }

    //
    // Loop through all the ctl entries and remove the entry
    // that corresponds to the hash given
    //
    CTLInfo.cCTLEntry = 0;
    for (i=0; i<(int)pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (wcscmp(
                (LPWSTR) pCTLContext->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData, 
                pwszHash) != 0)
        {
            CTLInfo.rgCTLEntry[CTLInfo.cCTLEntry++] = pCTLContext->pCtlInfo->rgCTLEntry[i];
        }
        else
        {
            fHashFound = TRUE;
        }
    }

    if (!fHashFound)
    {
        printf("<%S> not found in <%S>\n", pwszHash, pwszCatalogFile);
        goto ErrorReturn;
    }

    //
    // now save the CTL which is exactly the same as the previous one,
    // except it doesn't doesn't have the hash being removed, back to
    // the original filename
    //
    if (!CryptMsgEncodeAndSignCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CTLInfo,
                &signedInfo,
                0,
                NULL,
                &cbEncodedCTL))
    {
        goto ErrorReturn;
    }

    if (NULL == (pbEncodedCTL = new BYTE[cbEncodedCTL]))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgEncodeAndSignCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CTLInfo,
                &signedInfo,
                0,
                pbEncodedCTL,
                &cbEncodedCTL))
    {
        goto ErrorReturn;
    }



    if (INVALID_HANDLE_VALUE == (hFile = CreateFileW(
                                            pwszCatalogFile,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,
                                            NULL,
                                            CREATE_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL)))
    {
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            pbEncodedCTL,
            cbEncodedCTL,
            &cbWritten,
            NULL))
    {
        printf("WriteFile of <%S> failed with %x\n", pwszCatalogFile, GetLastError());
        goto ErrorReturn;
    }

    if (cbWritten != cbEncodedCTL)
    {
        goto ErrorReturn;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

CommonReturn:
    if (pwszHash != NULL)
    {
        delete (pwszHash);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (CTLInfo.rgCTLEntry != NULL)
    {
        delete (CTLInfo.rgCTLEntry);
    }

    if (pbEncodedCTL != NULL)
    {
        delete (pbEncodedCTL);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            fRet = FALSE;
        }
    }

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\setreg\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for setreg.cpp 
//
//
//  History:    05-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS
#define	IDS_SWITCH1							5999																																																															               
#define IDS_SWITCH2							6000		              
#define	IDS_OPTION_Q                		6001
#define	IDS_TRUE							6002
#define	IDS_FALSE							6003
#define	IDS_SYNTAX							6004
#define	IDS_OPTIONS				    		6005
#define	IDS_OPTION_Q_DESC					6006
#define	IDS_ENDLN							6007
#define	IDS_CHOICES							6008
#define	IDS_DESC							6009
#define	IDS_DISPLAY							6010
#define IDS_DISPLAY_LT_10                   6011

#define	IDS_NAME_TEST_ROOT					6111
#define	IDS_NAME_EXPIRATION					6112
#define	IDS_NAME_REVOCATION					6113
#define	IDS_NAME_OFFLINE_INDIVIDUAL			6114
#define	IDS_NAME_OFFLINE_COMMERCIAL			6115
#define	IDS_NAME_JAVA_INDIVIDUAL			6116
#define	IDS_NAME_JAVA_COMMERCIAL			6117
#define	IDS_NAME_VERSION_ONE				6118
#define IDS_NAME_REVOCATIONONTS             6119
#define IDS_NAME_ALLOWONLYPERTRUST          6120

#define	IDS_FAILED							6201
#define	IDS_MANY_ARG						6202
#define	IDS_INVALID_CHOICE					6203
#define	IDS_MISS_ARG						6204
#define	IDS_BAD_VALUE						6205
#define	IDS_NO_VALUE						6206
#define	IDS_REG_OPEN_FAILED					6207
#define	IDS_REG_QUERY_FAILED				6208
#define	IDS_REG_CREATE_FAILED				6209
#define	IDS_REG_SET_FAILED					6210
#define	IDS_WRONG_TYPE						6211
#define	IDS_STATE							6212
#define	IDS_UPDATED							6213
#define	IDS_VALUE							6214
#define	IDS_KEY_STATE						6215
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\setreg\setreg.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       setreg.cpp
//
//  Contents:   Set Registry Key Values
//
//              See Usage() for syntax and list of options.
//
//  Functions:  main
//
//  History:    28-Jul-96   philh   created
//              02-May-97   xiaohs	updated for Localiztion and Consistency
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include <stdarg.h>
#include "wintrust.h"
#include "cryptreg.h"
#include "resource.h"
#include "unicode.h"


typedef struct _FlagNames
{
    int			idsName;
    DWORD       dwMask;
} FlagNames;


static FlagNames SoftPubFlags[] = 
{
    IDS_NAME_TEST_ROOT,				WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
    IDS_NAME_EXPIRATION,			WTPF_IGNOREEXPIRATION,
    IDS_NAME_REVOCATION,			WTPF_IGNOREREVOKATION,
    IDS_NAME_OFFLINE_INDIVIDUAL,	WTPF_OFFLINEOK_IND,
    IDS_NAME_OFFLINE_COMMERCIAL,	WTPF_OFFLINEOK_COM,
    IDS_NAME_JAVA_INDIVIDUAL,		WTPF_OFFLINEOKNBU_IND,
    IDS_NAME_JAVA_COMMERCIAL,		WTPF_OFFLINEOKNBU_COM,
    IDS_NAME_VERSION_ONE,			WTPF_VERIFY_V1_OFF,
    IDS_NAME_REVOCATIONONTS,        WTPF_IGNOREREVOCATIONONTS,
    IDS_NAME_ALLOWONLYPERTRUST,     WTPF_ALLOWONLYPERTRUST
};
#define NSOFTPUBFLAGS (sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]))


//Global Data for loading the string
#define MAX_STRING_RSC_SIZE 512
#define OPTION_SWITCH_SIZE	5


HMODULE	hModule=NULL;

WCHAR	wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	dwBufferSize=sizeof(wszBuffer)/sizeof(wszBuffer[0]); 

WCHAR	wszBuffer2[MAX_STRING_RSC_SIZE];
WCHAR	wszBuffer3[MAX_STRING_RSC_SIZE];

//Global Data for wchar version of the registry path.


//---------------------------------------------------------------------------
// The private version of _wcsicmp
//----------------------------------------------------------------------------
int IDSwcsicmp(WCHAR *pwsz, int idsString)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsicmp(pwsz, wszBuffer);
}

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(int idsString, ...)
{
	va_list	vaPointer;

	va_start(vaPointer, idsString);

	//load the string
	LoadStringU(hModule, idsString, wszBuffer, dwBufferSize);

	vwprintf(wszBuffer,vaPointer);

	return;
}	


void IDS_IDS_DWwprintf(int idString, int idStringTwo, DWORD dw)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	wprintf(wszBuffer,wszBuffer2,dw);

	return;
}



void IDS_IDSwprintf(int idString, int idStringTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	wprintf(wszBuffer,wszBuffer2);

	return;
}

void IDS_DW_IDS_IDSwprintf(int ids1,DWORD dw,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,dw,wszBuffer2,wszBuffer3,dw);

	return;
}

//---------------------------------------------------------------------------
//
// Convert STR to WSTR
//---------------------------------------------------------------------------
BOOL SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;

	assert(pwsz);

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return TRUE;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
		return FALSE;

	//allocate memory
	*pwsz=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(*pwsz==NULL)
		return FALSE;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return TRUE;
	}
	
	free(*pwsz);	 

	return FALSE;
}



//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}


//---------------------------------------------------------------------------
//	Dispaly the usage 
//	 
//---------------------------------------------------------------------------

static void Usage(void)
{
	IDSwprintf(IDS_SYNTAX);
	IDSwprintf(IDS_OPTIONS);
	IDS_IDSwprintf(IDS_OPTION_Q_DESC, IDS_OPTION_Q);
	IDSwprintf(IDS_ENDLN);
	IDSwprintf(IDS_CHOICES);

    for (int i = 0; i < NSOFTPUBFLAGS; i++) 
    {
        IDS_IDS_DWwprintf(IDS_DESC,SoftPubFlags[i].idsName,(i+1)); 
    }

	IDSwprintf(IDS_VALUE);
	IDSwprintf(IDS_ENDLN);
}


//---------------------------------------------------------------------------
//	 Display Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
static void DisplaySoftPubKeys()
{
    DWORD	dwState = 0;
    LONG	lErr;
    HKEY	hKey = NULL;
	DWORD	dwType;
    DWORD	cbData = sizeof(dwState);
   // WCHAR	wszState[10];
	int		i=0;
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
	//	return;


    lErr = RegOpenHKCUKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            KEY_READ,
            &hKey);

    if (ERROR_SUCCESS != lErr) 
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
			IDSwprintf(IDS_NO_VALUE,REGPATH_WINTRUST_POLICY_FLAGS,NULL); 
        else
			IDSwprintf(IDS_REG_OPEN_FAILED,
                REGPATH_WINTRUST_POLICY_FLAGS, L" ", lErr);
		
		return;
    } 


    lErr = RegQueryValueExU(
            hKey,
            wszState,
            NULL,          // lpReserved
            &dwType,
            (BYTE *) &dwState,
            &cbData
            );

    if (ERROR_SUCCESS != lErr) 
	{
         if (lErr == ERROR_FILE_NOT_FOUND)
			 IDSwprintf(IDS_NO_VALUE, REGPATH_WINTRUST_POLICY_FLAGS,NULL);
         else
			 IDSwprintf(IDS_REG_QUERY_FAILED, REGPATH_WINTRUST_POLICY_FLAGS,NULL, lErr);

        goto CLEANUP;

	} 

    //
    //  04-Aug-1997 pberkman:
    //      added check for reg_binary because on WIN95 OSR2 when the machine is changed 
    //      from mutli-user profiles to single user profile, the registry DWORD values 
    //      change to BINARY
    //
	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
	{

		IDSwprintf(IDS_WRONG_TYPE, REGPATH_WINTRUST_POLICY_FLAGS,NULL, dwType);
		goto CLEANUP;

    }

	IDSwprintf(IDS_STATE, dwState);

    for (i=0; i < NSOFTPUBFLAGS; i++) 
	{
        BOOL fOn = (dwState & SoftPubFlags[i].dwMask);

        int		idsValue;

        switch(SoftPubFlags[i].dwMask) 
		{
            case WTPF_IGNOREREVOCATIONONTS:
			case WTPF_IGNOREREVOKATION:
			case WTPF_IGNOREEXPIRATION:
            // Revocation is a double negative so the bit set
            // means revocation is off.
				idsValue= fOn ? IDS_FALSE : IDS_TRUE;
				break;

			default:
				idsValue = fOn ? IDS_TRUE : IDS_FALSE;
        };

        if (i < 9)
        {
		    IDS_DW_IDS_IDSwprintf(IDS_DISPLAY_LT_10, (i + 1), SoftPubFlags[i].idsName, idsValue);
        }
        else
        {
		    IDS_DW_IDS_IDSwprintf(IDS_DISPLAY, (i + 1), SoftPubFlags[i].idsName, idsValue);
        }
    }

CLEANUP:
    if (hKey != NULL)
        RegCloseKey(hKey);
}

//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
static void SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState;
    LONG	lErr;
    HKEY	hKey;
    DWORD	dwDisposition;
    DWORD	dwType;
    DWORD	cbData;
//	WCHAR	wszState[10];
    LPWSTR  wszState=L"State";

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
//		return;

    // Set the State in the registry
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition))) 
	{
		IDSwprintf(IDS_REG_CREATE_FAILED, REGPATH_WINTRUST_POLICY_FLAGS, L" ", lErr);
        return;
    }

    dwState = 0;
    cbData = sizeof(dwState);
    lErr = RegQueryValueExU
	(
        hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        );
    if (ERROR_SUCCESS != lErr) 
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
        {
             dwState = 0;
			 IDSwprintf(IDS_NO_VALUE,REGPATH_WINTRUST_POLICY_FLAGS,NULL);
        }
        else
        {
			 IDSwprintf(IDS_REG_QUERY_FAILED,REGPATH_WINTRUST_POLICY_FLAGS,NULL, lErr);
             goto CLEANUP;
        }

    } 
    else if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
	{
		IDSwprintf(IDS_WRONG_TYPE,REGPATH_WINTRUST_POLICY_FLAGS,NULL, dwType);

        goto CLEANUP;
    }

    switch(dwMask) {
    case WTPF_IGNOREREVOCATIONONTS:
    case WTPF_IGNOREREVOKATION:
    case WTPF_IGNOREEXPIRATION:
        // Revocation and expiration are a double negative so the bit set
        // means revocation and expriation checking is off.
        fOn = !fOn;
        break;
    default:
        break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    lErr = RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );

    if (ERROR_SUCCESS != lErr)
		IDSwprintf(IDS_REG_SET_FAILED, lErr);

CLEANUP:
	if(hKey)
		RegCloseKey(hKey);
}


//---------------------------------------------------------------------------
//	 wmain
//	 
//---------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv) 
{
    int		ReturnStatus = 0;
    LPWSTR	*prgwszKeyName = NULL;
    LPWSTR	*prgwszValue = NULL;
	DWORD	dwIndex=0;
	DWORD	dwCountKey=0;
	DWORD	dwCountValue=0;
    DWORD	dwMask = 0;
    BOOL	fOn=TRUE;
    BOOL	fQuiet = FALSE;
	DWORD	dwEntry=0;
	WCHAR	*pArg=NULL;

	WCHAR	wszSwitch1[OPTION_SWITCH_SIZE];
	WCHAR	wszSwitch2[OPTION_SWITCH_SIZE];


	//get the module handle
	if(!InitModule())
		return -1;

	//load the strings necessary for parsing the parameters
	if( !LoadStringU(hModule, IDS_SWITCH1,	wszSwitch1, OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2,	OPTION_SWITCH_SIZE)
	  )
		return -1;

	//convert the multitype registry path to the wchar version

	prgwszKeyName=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);
	prgwszValue=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);

	if(!prgwszKeyName || !prgwszValue)
	{
		IDSwprintf(IDS_FAILED);
		ReturnStatus = -1;
		goto CommonReturn;

	}

	//memset
	memset(prgwszKeyName, 0, sizeof(LPWSTR)*argc);
	memset(prgwszValue, 0, sizeof(LPWSTR)*argc);

    while (--argc>0)
    {
		pArg=*++wargv;

        if (*pArg == *wszSwitch1 || *pArg == *wszSwitch2)
        {
            if(IDSwcsicmp(&(pArg[1]),IDS_OPTION_Q)==0)
				fQuiet = TRUE;
			else
				goto BadUsage;
        } 
		else 
		{
			if(dwCountKey==dwCountValue)
			{
				prgwszKeyName[dwCountKey]=pArg;
				dwCountKey++;
			}
			else
			{
				if(dwCountKey==(dwCountValue+1))
				{
					prgwszValue[dwCountValue]=pArg;
					dwCountValue++;
				}
				else
				{
					goto BadUsage;
				}
			}
		}

     }

	if(dwCountKey!=dwCountValue)
	{
		IDSwprintf(IDS_MANY_ARG);
		goto BadUsage;
	}

    
	if(dwCountKey==0)
	{
	 	//Display the Software Publisher State Key Values
        DisplaySoftPubKeys();
        goto CommonReturn;
	}


	for(dwIndex=0; dwIndex<dwCountKey; dwIndex++)
	{
		dwEntry = _wtoi(prgwszKeyName[dwIndex]);

		if(dwEntry < 1 || dwEntry > NSOFTPUBFLAGS+1) 
		{
			IDSwprintf(IDS_INVALID_CHOICE);
			goto BadUsage;
		}           
 
		//get the Key mask
		dwMask = SoftPubFlags[dwEntry-1].dwMask;

		if (0 == IDSwcsicmp(prgwszValue[dwIndex], IDS_TRUE))
			fOn = TRUE;
		else if (0 == IDSwcsicmp(prgwszValue[dwIndex], IDS_FALSE))
			fOn = FALSE;
		else 
		{
			IDSwprintf(IDS_BAD_VALUE);
			goto BadUsage;
		}

		SetSoftPubKey(dwMask, fOn);
	}

    if (!fQuiet) 
	{
		IDSwprintf(IDS_UPDATED);
        DisplaySoftPubKeys();
    }

    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
	//free the memory

	if(prgwszKeyName)
		free(prgwszKeyName);

	if(prgwszValue)
		free(prgwszValue);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\updcrl\updcrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       updcrl.cpp
//
//  Contents:   Updates CRL in the "CA" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    30-Aug-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"
#include "wintrust.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    char buf[512];

    sprintf(buf, "%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
    MessageBoxA(
        NULL,           // hWnd
        buf,
        "UpdCrl",
        MB_OK | MB_ICONERROR | MB_TASKMODAL
        );
}

void PrintMsg(LPCSTR pszMsg)
{
    MessageBoxA(
        NULL,           // hWnd
        pszMsg,
        "UpdCrl",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}

static void Usage(void)
{
    MessageBoxA(
        NULL,           // hWnd
        "Usage: UpdCrl [options] <SrcCrlFilename>\n"
        "Options are:\n"
        "-h -\tThis message\n"
        "-r -\tRegister NoCDPCRLRevocationChecking\n"
        "-e -\tEnable revocation checking\n"
        "-d -\tDisable revocation checking\n"
        "-u -\tUser\n"
        "\n",
        "UpdCrl",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}


BOOL
IsLogicalStoreSupported()
{
    HMODULE hModule;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return FALSE;

    if (NULL == GetProcAddress(hModule, "CertEnumPhysicalStore"))
        return FALSE;

    return TRUE;
}


void
UpdateRevocation(
    IN BOOL fEnable
    )
{
    HKEY hKey = NULL;
    DWORD dwState;
    DWORD cbData;
    DWORD dwType;
    DWORD dwDisposition;

    // Open the registry and get to the "State" REG_DWORD value
    if (ERROR_SUCCESS != RegCreateKeyExA(
            HKEY_CURRENT_USER,
            "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ))
        return;

    dwState = 0;
    cbData = sizeof(dwState);
    if (ERROR_SUCCESS != RegQueryValueExA(
            hKey,
            "State",
            NULL,
            &dwType,
            (BYTE *) &dwState,
            &cbData
            ) || sizeof(dwState) != cbData || REG_DWORD != dwType)
        dwState = WTPF_IGNOREREVOCATIONONTS;

    if (fEnable) {
        dwState &= ~WTPF_IGNOREREVOKATION;
        dwState |=
            WTPF_OFFLINEOK_IND |
            WTPF_OFFLINEOK_COM |
            WTPF_OFFLINEOKNBU_IND |
            WTPF_OFFLINEOKNBU_COM
            ;
    } else
        dwState |= WTPF_IGNOREREVOKATION;


    RegSetValueExA(
        hKey,
        "State",
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );

    RegCloseKey(hKey);
}


PCCRL_CONTEXT
OpenCrlFile(
    IN LPSTR pszCrlFilename
    )
{
    PCCRL_CONTEXT pCrl = NULL;
    HANDLE hFile = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD cbRead;
    DWORD dwErr = 0;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
            pszCrlFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL)))
        return NULL;

    cbEncoded = GetFileSize(hFile, NULL);
    if (0 == cbEncoded)
        goto EmptyFileError;

    if (NULL == (pbEncoded = (BYTE *) LocalAlloc(LPTR, cbEncoded)))
        goto OutOfMemory;

    if (!ReadFile(hFile, pbEncoded, cbEncoded, &cbRead, NULL) ||
            (cbRead != cbEncoded))
        goto ReadFileError;

    pCrl = CertCreateCRLContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );

CommonReturn:
    dwErr = GetLastError();
    if (hFile)
        CloseHandle(hFile);
    if (pbEncoded)
        LocalFree(pbEncoded);

    SetLastError(dwErr);
    return pCrl;

ErrorReturn:
    goto CommonReturn;

EmptyFileError:
    SetLastError(ERROR_INVALID_DATA);
    goto ErrorReturn;

OutOfMemory:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto ErrorReturn;

ReadFileError:
    goto ErrorReturn;
}


#if 0
// In W2K, the NOCDP CRL needs to be time valid.
BOOL
IsNoCDPCRLSupported()
{
    HMODULE hModule;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return FALSE;

    // "CryptVerifyCertificateSignatureEx" added in W2K, WinME and CMS
    if (NULL == GetProcAddress(hModule, "CertIsValidCRLForCertificate"))
        return FALSE;

    return TRUE;
}
#endif


BOOL
FIsWinNT5()
{
    BOOL fIsWinNT5 = FALSE;
    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVer)) {
        BOOL fIsWinNT;

        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
        if (!fIsWinNT) {
            return FALSE;
        }

        fIsWinNT5 = ( osVer.dwMajorVersion >= 5 );
    }

    return fIsWinNT5;
}

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_GetFileVersion(
    IN LPCSTR pszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    )
{
    BOOL fResult;
    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (0 == (cbInfo = GetFileVersionInfoSizeA((LPSTR) pszFilename, &dwHandle)))
        goto GetFileVersionInfoSizeError;

    if (NULL == (pvInfo = LocalAlloc(LPTR, cbInfo)))
        goto OutOfMemory;

    if (!GetFileVersionInfoA(
            (LPSTR) pszFilename,
            0,          // dwHandle, ignored
            cbInfo,
            pvInfo
            ))
        goto GetFileVersionInfoError;

    if (!VerQueryValueA(
            pvInfo,
            "\\",       // VS_FIXEDFILEINFO
            (void **) &pFixedFileInfo,
            &ccFixedFileInfo
            ))
        goto VerQueryValueError;

    *pdwFileVersionMS = pFixedFileInfo->dwFileVersionMS;
    *pdwFileVersionLS = pFixedFileInfo->dwFileVersionLS;

    fResult = TRUE;
CommonReturn:
    if (pvInfo)
        LocalFree(pvInfo);
    return fResult;

OutOfMemory:
GetFileVersionInfoSizeError:
GetFileVersionInfoError:
VerQueryValueError:
    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;
    fResult = FALSE;
    goto CommonReturn;
}

void
RegisterNoCDPCRLRevocationChecking()
{
    CHAR szSystemDir[MAX_PATH + 32];
    UINT cch;

    // Just in case, unregister vsrevoke.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"vsrevoke.dll"
            );

    // For W2K and beyond, won't be installing mscrlrev.dll
    if (FIsWinNT5()) {
        // For upgrades, unregister legacy versions

        CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            );

        return;
    }

    // Need to copy mscrlrev.dll to system32
    cch = GetSystemDirectory(szSystemDir, MAX_PATH - 1);
    if (0 == cch || MAX_PATH <= cch) {
        PrintLastError("GetSystemDirectory");
        return;
    }

    strcpy(&szSystemDir[cch], "\\mscrlrev.dll");
    
    // On the first copy, only succeed if the file doesn't already exist
    if (!CopyFileA("mscrlrev.dll", szSystemDir, TRUE)) {
        DWORD dwOldFileVersionMS = 0;
        DWORD dwOldFileVersionLS = 0;
        DWORD dwNewFileVersionMS = 0;
        DWORD dwNewFileVersionLS = 0;

        // Determine if we have a newer mscrlrev.dll to be installed
        I_GetFileVersion(szSystemDir,
            &dwOldFileVersionMS, &dwOldFileVersionLS);
        I_GetFileVersion("mscrlrev.dll",
            &dwNewFileVersionMS, &dwNewFileVersionLS);

        if (dwNewFileVersionMS > dwOldFileVersionMS
                            ||
                (dwNewFileVersionMS == dwOldFileVersionMS &&
                    dwNewFileVersionLS > dwOldFileVersionLS)) {
            // We have a newer version

            SetFileAttributesA(szSystemDir, FILE_ATTRIBUTE_NORMAL);
            // Copy over the existing file
            if (!CopyFileA("mscrlrev.dll", szSystemDir, FALSE)) {
                DWORD dwLastErr;

                dwLastErr = GetLastError();
                if (ERROR_ACCESS_DENIED != dwLastErr)
                    PrintLastError("CopyFile(mscrlrev.dll)");
            }
        }
    }

    // Need to register mscrlrev.dll
    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_FIRST_INDEX,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            PrintLastError("Register mscrlrev.dll");
    }
}

#define MAX_CRL_FILE_CNT    32

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    int ReturnStatus = 0;
    LPSTR rgpszCrlFilename[MAX_CRL_FILE_CNT];   // not allocated
    DWORD cCrlFilename = 0;
    HCERTSTORE hCAStore = NULL;
    BOOL fUser = FALSE;
    BOOL fLogicalStoreSupported = FALSE;
    DWORD i;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'e':
                UpdateRevocation(TRUE);
                break;
            case 'd':
                UpdateRevocation(FALSE);
                break;
            case 'r':
                RegisterNoCDPCRLRevocationChecking();
                break;
            case 'u':
                fUser = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (MAX_CRL_FILE_CNT > cCrlFilename)
                rgpszCrlFilename[cCrlFilename++] = argv[0];
            else {
                PrintMsg("Too many Crl filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (0 == cCrlFilename)
        goto SuccessReturn;

    fLogicalStoreSupported = IsLogicalStoreSupported();
    if (fUser && fLogicalStoreSupported)
        // Already installed in HKLM
        goto SuccessReturn;

    // Attempt to open the destination CA store.
    // For earlier versions not supporting logical stores, its the
    // HKCU "CA" store. Otherwise, its the HKLM "CA" store.
    hCAStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_A,
        0,                              // dwEncodingType
        0,                              // hCryptProv
        fLogicalStoreSupported ?
            CERT_SYSTEM_STORE_LOCAL_MACHINE : CERT_SYSTEM_STORE_CURRENT_USER,
        (const void *) "CA"
        );
    if (NULL == hCAStore) {
        PrintLastError("Open CAStore");
        goto ErrorReturn;
    }

    for (i = 0; i < cCrlFilename; i++) {
        PCCRL_CONTEXT pCrl;

        // Attempt to open the Crl file
        pCrl = OpenCrlFile(rgpszCrlFilename[i]);
        if (NULL == pCrl) {
            PrintLastError("Open CrlFile");
            goto ErrorReturn;
        }

        fResult = CertAddCRLContextToStore(
            hCAStore,
            pCrl,
            CERT_STORE_ADD_NEWER,
            NULL
            );
        if (!fResult && CRYPT_E_EXISTS != GetLastError()) {
            // Note, earlier versions of crypt32.dll didn't support 
            // CERT_STORE_ADD_NEWER

            // Will need to see if the CRL already exists in the store
            // and do our comparison.

            PCCRL_CONTEXT pExistingCrl = NULL;
            DWORD dwGetFlags = 0;

            while (pExistingCrl = CertGetCRLFromStore(
                    hCAStore,
                    NULL,                   // pIssuerContext
                    pExistingCrl,
                    &dwGetFlags
                    )) {
                dwGetFlags = 0;

                // See if it has the same issuer name
                if (pExistingCrl->dwCertEncodingType !=
                        pCrl->dwCertEncodingType
                            ||
                        !CertCompareCertificateName(
                            pCrl->dwCertEncodingType,
                            &pCrl->pCrlInfo->Issuer,
                            &pExistingCrl->pCrlInfo->Issuer
                            ))
                    continue;

                // See if the existing is newer
                // CompareFileTime returns 0 if the same and
                // +1 if first time > second time
                if (0 <= CompareFileTime(
                        &pExistingCrl->pCrlInfo->ThisUpdate,
                        &pCrl->pCrlInfo->ThisUpdate
                        ))
                    break;
            }

            if (pExistingCrl)
                CertFreeCRLContext(pExistingCrl);
            else {
                fResult = CertAddCRLContextToStore(
                    hCAStore,
                    pCrl,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL
                    );

                if (!fResult)
                    PrintLastError("AddCRL");
            }
        }

        CertFreeCRLContext(pCrl);

        if (!fResult)
            goto ErrorReturn;
    }

SuccessReturn:
    ReturnStatus = 0;
CommonReturn:
    if (hCAStore)
        CertCloseStore(hCAStore, 0);
    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\acui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acui.cpp
//
//  Contents:   Entry point for the Authenticode UI Provider
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>
//+---------------------------------------------------------------------------
//
//  Function:   ACUIProviderInvokeUI
//
//  Synopsis:   Authenticode UI invokation entry point (see acui.h)
//
//  Arguments:  [pInvokeInfo] -- ACUI invoke information
//
//  Returns:    S_OK if the subject is trusted
//              TRUST_E_SUBJECT_NOT_TRUSTED if the subject is not trusted
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT WINAPI ACUIProviderInvokeUI (PACUI_INVOKE_INFO pInvokeInfo)
{
    HRESULT hr;
    HWND    hDisplay;

    //
    // Initialize rich edit control DLL
    //
    if ( LoadLibrary(TEXT("riched32.dll")) == NULL )
    {
        return( E_FAIL );
    }

    //
    // Validate the invoke info structure
    //
    if (!(pInvokeInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(ACUI_INVOKE_INFO, pInvokeInfo->cbSize, pPersonalTrustDB)))
    {
        return( E_INVALIDARG );
    }

    //
    // Pull out the display window handle and make sure it's valid
    //

    hDisplay = pInvokeInfo->hDisplay;
    if ( hDisplay == NULL )
    {
        if ( (hDisplay = GetDesktopWindow()) == NULL )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }
    }

    //
    // Instantiate an invoke helper
    //

    CInvokeInfoHelper iih(pInvokeInfo, hr);
    IACUIControl*     pUI = NULL;

    if ( hr != S_OK )
    {
        return( hr );
    }

    //
    // Get the UI control and invoke the UI
    //

    hr = iih.GetUIControl(&pUI);
    if ( hr == S_OK )
    {
        hr = pUI->InvokeUI(hDisplay);
        iih.ReleaseUIControl(pUI);
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\acuictl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acuictl.h
//
//  Contents:   UI Control class definitions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ACUICTL_H__)
#define __ACUICTL_H__

//
// Forward class declaration
//

class CInvokeInfoHelper;

//
// Link subclass definitions
//

typedef struct _TUI_LINK_SUBCLASS_DATA {

    HWND    hwndParent;
    WNDPROC wpPrev;
    DWORD_PTR uToolTipText;
    DWORD   uId;
    HWND    hwndTip;
    LPVOID  pvData;
    BOOL    fMouseCaptured;

} TUI_LINK_SUBCLASS_DATA, *PTUI_LINK_SUBCLASS_DATA;

//
// IACUIControl abstract base class interface.  This is used by the
// invoke UI entry point to put up the appropriate UI.  There are different
// implementations of this interface based on the invoke reason code
//

class IACUIControl
{
public:

    //
    // Constructor
    //

    IACUIControl (CInvokeInfoHelper& riih);

    //
    // Virtual destructor
    //

    virtual ~IACUIControl ();

    //
    // UI Message processing
    //

    virtual BOOL OnUIMessage (
                     HWND   hwnd,
                     UINT   uMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     );

    void LoadActionText(WCHAR **ppszRet, WCHAR *pwszIn, DWORD dwDefId);
    void SetupButtons(HWND hwnd);

    //
    // Pure virtual methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay) = 0;

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam) = 0;

    virtual BOOL OnYes (HWND hwnd) = 0;

    virtual BOOL OnNo (HWND hwnd) = 0;

    virtual BOOL OnMore (HWND hwnd) = 0;

protected:

    //
    // Invoke Info Helper reference
    //

    CInvokeInfoHelper& m_riih;

    //
    // Invoke result
    //

    HRESULT            m_hrInvokeResult;

    WCHAR               *m_pszCopyActionText;
    WCHAR               *m_pszCopyActionTextNoTS;
    WCHAR               *m_pszCopyActionTextNotSigned;
};

//
// CVerifiedTrustUI class is used to invoke authenticode UI where the
// trust hierarchy for the signer has been successfully verified and the
// user has to make an override decision
//

class CVerifiedTrustUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CVerifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CVerifiedTrustUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR             m_pszInstallAndRun;
    LPWSTR             m_pszAuthenticity;
    LPWSTR             m_pszCaution;
    LPWSTR             m_pszPersonalTrust;

    //
    // links
    //

    TUI_LINK_SUBCLASS_DATA m_lsdPublisher;
    TUI_LINK_SUBCLASS_DATA m_lsdOpusInfo;
    TUI_LINK_SUBCLASS_DATA m_lsdCA;
    TUI_LINK_SUBCLASS_DATA m_lsdAdvanced;
};

//
// CUnverifiedTrustUI class is used to invoke authenticode UI where the
// trust hierarchy for the signer has been NOT been successfully verified and
// the user has to make an override decision
//

class CUnverifiedTrustUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CUnverifiedTrustUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR              m_pszNoAuthenticity;
    LPWSTR              m_pszProblemsBelow;
    LPWSTR              m_pszInstallAndRun3;

    //
    // links
    //

    TUI_LINK_SUBCLASS_DATA m_lsdPublisher;
    TUI_LINK_SUBCLASS_DATA m_lsdOpusInfo;
    TUI_LINK_SUBCLASS_DATA m_lsdCA;
    TUI_LINK_SUBCLASS_DATA m_lsdAdvanced;
};

//
// CNoSignatureUI class is used to invoke authenticode UI where the
// there is no signature for the subject and the user has to make an
// override decision
//

class CNoSignatureUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CNoSignatureUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CNoSignatureUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR m_pszInstallAndRun2;
    LPWSTR m_pszNoPublisherFound;
};

//
// ACUIMessageProc, this dialog message procedure is used to dispatch
// dialog messages to the control
//

INT_PTR CALLBACK ACUIMessageProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

//
// Subclassing helper routines and definitions
//

VOID SubclassEditControlForArrowCursor (HWND hwndEdit);

LRESULT CALLBACK ACUISetArrowCursorSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

VOID SubclassEditControlForLink (
                 HWND                       hwndDlg,
                 HWND                       hwndEdit,
                 WNDPROC                    wndproc,
                 PTUI_LINK_SUBCLASS_DATA    plsd
                 );

LRESULT CALLBACK ACUILinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

//
// UI control resizing helper functions
//

VOID RebaseControlVertical (
                  HWND  hwndDlg,
                  HWND  hwnd,
                  HWND  hwndNext,
                  BOOL  fResizeForText,
                  int   deltavpos,
                  int   oline,
                  int   minsep,
                  int*  pdeltaheight
                  );

int CalculateControlVerticalDistanceFromDlgBottom (HWND hwnd, UINT Control);

int CalculateControlVerticalDistance (HWND hwnd, UINT Control1, UINT Control2);

VOID ACUICenterWindow (HWND hWndToCenter);

int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline);

void DrawFocusRectangle (HWND hwnd, HDC hdc);

void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm);

//
// Miscellaneous definitions
//

#define MAX_LOADSTRING_BUFFER 1024

//
// Resource string formatting helper
//

HRESULT FormatACUIResourceString (
                  UINT   StringResourceId,
                  DWORD_PTR* aMessageArgument,
                  LPWSTR* ppszFormatted
                  );

//
// Rendering helper
//

int RenderACUIStringToEditControl (
                  HWND                      hwndDlg,
                  UINT                      ControlId,
                  UINT                      NextControlId,
                  LPCWSTR                   psz,
                  int                       deltavpos,
                  BOOL                      fLink,
                  WNDPROC                   wndproc,
                  PTUI_LINK_SUBCLASS_DATA   plsd,
                  int                       minsep,
                  LPCWSTR                   pszThisTextOnlyInLink
                  );

//
// HTML help viewing helper
//

VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic);

//
// Hotkey helpers
//

int GetHotKeyCharPositionFromString (LPWSTR pwszText);

int GetHotKeyCharPosition (HWND hwnd);

VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   DllMain entry point
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

//
// Module instance
//

HINSTANCE g_hModule = NULL;
//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Windows DLL entry point
//
//  Arguments:  [hInstance]  -- module instance
//              [dwReason]   -- reason code
//              [pvReserved] -- reserved
//
//  Returns:    TRUE if everything ok, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI
TrustUIDllMain (HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        //
        // Keep the module instance handle for resource loading usage
        //

        g_hModule = hInstance;

        //
        // Initialize rich edit control DLL
        //

       /* if ( LoadLibrary(TEXT("riched32.dll")) == NULL )
        {
            return( FALSE );
        }*/

        //
        // Initialize the common controls
        //

        InitCommonControls();
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\tools\updroots\updroots.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       updroots.cpp
//
//  Contents:   Updates LocalMachine roots. Pre-whistler, HKLM "Root" store.
//              Otherwise, HKLM "AuthRoot" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    30-Aug-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SHA1_HASH_LEN               20

//+-------------------------------------------------------------------------
//  crypt32.dll Whistler version numbers
//
//  Doesn't need to be the official Whistler release #. Any build # after
//  the "AuthRoot" store was added.
//--------------------------------------------------------------------------
#define WHISTLER_CRYPT32_DLL_VER_MS          ((    5 << 16) | 131 )
#define WHISTLER_CRYPT32_DLL_VER_LS          (( 2257 << 16) |   1 )


BOOL fLocalMachine = FALSE;

void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    char buf[512];

    sprintf(buf, "%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
    MessageBoxA(
        NULL,           // hWnd
        buf,
        "UpdRoots",
        MB_OK | MB_ICONERROR | MB_TASKMODAL
        );
}

void PrintMsg(LPCSTR pszMsg)
{
    MessageBoxA(
        NULL,           // hWnd
        pszMsg,
        "UpdRoots",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}

static void Usage(void)
{
    MessageBoxA(
        NULL,           // hWnd
        "Usage: UpdRoots [options] <SrcStoreFilename>\n"
        "Options are:\n"
        "-h -\tThis message\n"
        "-d -\tDelete (default is to add)\n"
        "-l -\tLocal Machine (default is Third Party)\n"
        "\n",
        "UpdRoots",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}


PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LEN != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        fResult = CertDeleteCertificateFromStore(pOtherCert);
    else
        fResult = TRUE;
    return fResult;
}

typedef BOOL (WINAPI *PFN_CRYPT_GET_FILE_VERSION)(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

#define NO_LOGICAL_STORE_VERSION    0
#define LOGICAL_STORE_VERSION       1
#define AUTH_STORE_VERSION          2

// Note, I_CryptGetFileVersion and logical stores, not supported in all
// versions of crypt32.dll
//
// Returns one of the above defined version constants
DWORD GetCrypt32Version()
{
    DWORD dwVersion;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    HMODULE hModule;
    PFN_CRYPT_GET_FILE_VERSION pfnCryptGetFileVersion;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return NO_LOGICAL_STORE_VERSION;

    if (NULL == GetProcAddress(hModule, "CertEnumPhysicalStore"))
        return NO_LOGICAL_STORE_VERSION;

    if (fLocalMachine)
        return LOGICAL_STORE_VERSION;

    pfnCryptGetFileVersion = (PFN_CRYPT_GET_FILE_VERSION) GetProcAddress(
        hModule, "I_CryptGetFileVersion");
    if (NULL == pfnCryptGetFileVersion)
        return LOGICAL_STORE_VERSION;

    dwVersion = LOGICAL_STORE_VERSION;
    if (pfnCryptGetFileVersion(
            L"crypt32.dll",
            &dwFileVersionMS,
            &dwFileVersionLS)) {
        if (WHISTLER_CRYPT32_DLL_VER_MS < dwFileVersionMS)
            dwVersion = AUTH_STORE_VERSION;
        else if (WHISTLER_CRYPT32_DLL_VER_MS == dwFileVersionMS &&
                    WHISTLER_CRYPT32_DLL_VER_LS <= dwFileVersionLS)
            dwVersion = AUTH_STORE_VERSION;
    }

    return dwVersion;
}

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    int ReturnStatus = 0;
    LPSTR pszSrcStoreFilename = NULL;       // not allocated
    HANDLE hSrcStore = NULL;
    HANDLE hRootStore = NULL;

    BOOL fDelete = FALSE;
    DWORD dwVersion;
    PCCERT_CONTEXT pSrcCert;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'd':
                fDelete = TRUE;
                break;
            case 'l':
                fLocalMachine = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pszSrcStoreFilename == NULL)
                pszSrcStoreFilename = argv[0];
            else {
                PrintMsg("too many store filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (NULL == pszSrcStoreFilename) {
        PrintMsg("missing store filename\n");
        goto BadUsage;
    }

    // Attempt to open the source store
    hSrcStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME_A,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,                      // hCryptProv
        CERT_STORE_READONLY_FLAG,
        (const void *) pszSrcStoreFilename
        );
    if (NULL == hSrcStore) {
        PrintLastError("Open SrcStore");
        goto ErrorReturn;
    }

    // Attempt to open the destination root store. For Whistler and beyond its
    // the HKLM "AuthRoot" store. Pre-Whistler its the HKLM "Root" store.
    // Also, earlier versions of crypt32 didn't support logical stores.
    // For -l option, force it to be the HKLM "Root" store.

    dwVersion = GetCrypt32Version();

    if (NO_LOGICAL_STORE_VERSION == dwVersion) {
        // Need to open the registry to bypass the add root message boxes
        HKEY hKey = NULL;
        LONG lErr;

        if (ERROR_SUCCESS != (lErr = RegOpenKeyExA(
                HKEY_CURRENT_USER,
                "Software\\Microsoft\\SystemCertificates\\Root",
                0,                      // dwReserved
                KEY_ALL_ACCESS,
                &hKey))) {
            SetLastError(lErr);
            PrintLastError("RegOpenKeyExA(root)\n");
            goto ErrorReturn;
        }

        hRootStore = CertOpenStore(
            CERT_STORE_PROV_REG,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) hKey
            );

        RegCloseKey(hKey);
    } else {
        LPCSTR pszRootStoreName;

        if (AUTH_STORE_VERSION == dwVersion)
            pszRootStoreName = "AuthRoot";
        else
            pszRootStoreName = "Root";

        hRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_A,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) pszRootStoreName
            );
    }

    if (NULL == hRootStore) {
        PrintLastError("Open RootStore");
        goto ErrorReturn;
    }

    // Iterate through all the certificates in the source store. Add or delete
    // from the root store.
    fResult = TRUE;
    pSrcCert = NULL;
    while (pSrcCert = CertEnumCertificatesInStore(hSrcStore, pSrcCert)) {
        if (fDelete) {
            if (!DeleteCertificateFromOtherStore(hRootStore, pSrcCert)) {
                fResult = FALSE;
                PrintLastError("DeleteCert");
            }
        } else {
            // Note, earlier versions of crypt32.dll didn't support 
            // CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
            if (!CertAddCertificateContextToStore(
                    hRootStore,
                    pSrcCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL)) {
                fResult = FALSE;
                PrintLastError("AddCert");
            }
        }
    }

    if (!fResult)
        goto ErrorReturn;

    ReturnStatus = 0;
CommonReturn:
    if (hSrcStore)
        CertCloseStore(hSrcStore, 0);
    if (hRootStore)
        CertCloseStore(hRootStore, 0);
    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\acuictl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acuictl.cpp
//
//  Contents:   Authenticode Default UI controls
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include <richedit.h>

#include "secauth.h"

IACUIControl::IACUIControl(CInvokeInfoHelper& riih) : m_riih( riih ),
                                    m_hrInvokeResult( TRUST_E_SUBJECT_NOT_TRUSTED )
{
    m_hrInvokeResult    = TRUST_E_SUBJECT_NOT_TRUSTED;


    m_pszCopyActionText             = NULL;
    m_pszCopyActionTextNoTS         = NULL;
    m_pszCopyActionTextNotSigned    = NULL;

    if ((riih.ProviderData()) &&
        (riih.ProviderData()->psPfns) &&
        (riih.ProviderData()->psPfns->psUIpfns) &&
        (riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (_ISINSTRUCT(CRYPT_PROVUI_DATA,
                         riih.ProviderData()->psPfns->psUIpfns->psUIData->cbStruct,
                         pCopyActionTextNotSigned))
        {
            this->LoadActionText(&m_pszCopyActionText,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionText, IDS_ACTIONSIGNED);
            this->LoadActionText(&m_pszCopyActionTextNoTS,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS, IDS_ACTIONSIGNED_NODATE);
            this->LoadActionText(&m_pszCopyActionTextNotSigned,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned, IDS_ACTIONNOTSIGNED);
        }
    }

    if (!(m_pszCopyActionText))
    {
        this->LoadActionText(&m_pszCopyActionText, NULL, IDS_ACTIONSIGNED);
    }

    if (!(m_pszCopyActionTextNoTS))
    {
        this->LoadActionText(&m_pszCopyActionTextNoTS, NULL, IDS_ACTIONSIGNED_NODATE);
    }

    if (!(m_pszCopyActionTextNotSigned))
    {
        this->LoadActionText(&m_pszCopyActionTextNotSigned, NULL, IDS_ACTIONNOTSIGNED);
    }
}

void IACUIControl::LoadActionText(WCHAR **ppszRet, WCHAR *pwszIn, DWORD dwDefId)
{
    WCHAR    sz[MAX_PATH];

    *ppszRet    = NULL;
    sz[0]       = NULL;

    if ((pwszIn) && (*pwszIn))
    {
        sz[0] = NULL;
        if (wcslen(pwszIn) < MAX_PATH)
        {
            wcscpy(&sz[0], pwszIn);
        }

        if (sz[0])
        {
            if (*ppszRet = new WCHAR[wcslen(&sz[0]) + 1])
            {
                wcscpy(*ppszRet, &sz[0]);
            }
        }

    }

    if (!(sz[0]))
    {
        sz[0] = NULL;
        LoadStringU(g_hModule, dwDefId, &sz[0], MAX_PATH);

        if (sz[0])
        {
            if (*ppszRet = new WCHAR[wcslen(&sz[0]) + 1])
            {
                wcscpy(*ppszRet, &sz[0]);
            }
        }
    }
}

IACUIControl::~IACUIControl ()
{
    DELETE_OBJECT(m_pszCopyActionText);
    DELETE_OBJECT(m_pszCopyActionTextNoTS);
    DELETE_OBJECT(m_pszCopyActionTextNotSigned);
}

void IACUIControl::SetupButtons(HWND hWnd)
{
    char    sz[MAX_PATH];

    if ((m_riih.ProviderData()) &&
        (m_riih.ProviderData()->psPfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText)
        {
            if (!(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText[0]))
            {
                ShowWindow(GetDlgItem(hWnd, IDYES), SW_HIDE);
            }
            else
            {
                SetWindowTextU(GetDlgItem(hWnd, IDYES), m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText);
            }
        }

        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText)
        {
            if (!(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText[0]))
            {
                ShowWindow(GetDlgItem(hWnd, IDNO), SW_HIDE);
            }
            else
            {
                SetWindowTextU(GetDlgItem(hWnd, IDNO), m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     IACUIControl::OnUIMessage, public
//
//  Synopsis:   responds to UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
IACUIControl::OnUIMessage (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            BOOL fReturn;
            HICON   hIcon;

            fReturn = OnInitDialog(hwnd, wParam, lParam);

            ACUICenterWindow(hwnd);

 //           hIcon = LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), MAKEINTRESOURCE(IDI_LOCK));

 //           dwOrigIcon = SetClassLongPtr(hwnd, GCLP_HICON,
 //                                     (LONG_PTR)LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
 //                                                    MAKEINTRESOURCE(IDI_LOCK)));

            // PostMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            // PostMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

            return( fReturn );
        }
        break;

    case WM_COMMAND:
        {
            WORD wNotifyCode = HIWORD(wParam);
            WORD wId = LOWORD(wParam);
            HWND hwndControl = (HWND)lParam;

            if ( wNotifyCode == BN_CLICKED )
            {
                if ( wId == IDYES )
                {
                    return( OnYes(hwnd) );
                }
                else if ( wId == IDNO )
                {
                    return( OnNo(hwnd) );
                }
                else if ( wId == IDMORE )
                {
                    return( OnMore(hwnd) );
                }
            }

            return( FALSE );
        }
        break;

    case WM_CLOSE:
        return( OnNo(hwnd) );
        break;

    default:
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::CVerifiedTrustUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CVerifiedTrustUI::CVerifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr)
                 : IACUIControl( riih ),
                   m_pszInstallAndRun( NULL ),
                   m_pszAuthenticity( NULL ),
                   m_pszCaution( NULL ),
                   m_pszPersonalTrust( NULL )
{
    DWORD_PTR aMessageArgument[3];

    //
    // Initialize the hot-link subclass data
    //

    m_lsdPublisher.uId          = IDC_PUBLISHER;
    m_lsdPublisher.hwndParent   = NULL;
    m_lsdPublisher.wpPrev       = (WNDPROC)NULL;
    m_lsdPublisher.pvData       = (LPVOID)&riih;
    m_lsdPublisher.uToolTipText = IDS_CLICKHEREFORCERT;

    m_lsdOpusInfo.uId           = IDC_INSTALLANDRUN;
    m_lsdOpusInfo.hwndParent    = NULL;
    m_lsdOpusInfo.wpPrev        = (WNDPROC)NULL;
    m_lsdOpusInfo.pvData        = &riih;
    m_lsdOpusInfo.uToolTipText  = (DWORD_PTR)riih.ControlWebPage();

    m_lsdCA.uId                 = IDC_AUTHENTICITY;
    m_lsdCA.hwndParent          = NULL;
    m_lsdCA.wpPrev              = (WNDPROC)NULL;
    m_lsdCA.pvData              = &riih;
    m_lsdCA.uToolTipText        = (DWORD_PTR)riih.CAWebPage(); // IDS_CLICKHEREFORCAINFO;

    m_lsdAdvanced.uId           = IDC_ADVANCED;
    m_lsdAdvanced.hwndParent    = NULL;
    m_lsdAdvanced.wpPrev        = (WNDPROC)NULL;
    m_lsdAdvanced.pvData        = &riih;
    m_lsdAdvanced.uToolTipText  = IDS_CLICKHEREFORADVANCED;


    //
    // Format the install and run string
    //

    aMessageArgument[2] = NULL;

    if (m_riih.CertTimestamp())
    {
        aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionText;
        aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
        aMessageArgument[2] = (DWORD_PTR)m_riih.CertTimestamp();
    }
    else
    {
        aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNoTS;
        aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
        aMessageArgument[2] = NULL;
    }

    rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun);

    //
    // Format the authenticity string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.PublisherCertIssuer();

        rhr = FormatACUIResourceString(
                        IDS_AUTHENTICITY,
                        aMessageArgument,
                        &m_pszAuthenticity
                        );
    }

    //
    // Get the publisher as a message argument
    //

    aMessageArgument[0] = (DWORD_PTR)m_riih.Publisher();

    //
    // Format the caution string
    //

    if ( rhr == S_OK )
    {
        rhr = FormatACUIResourceString(
                        IDS_CAUTION,
                        aMessageArgument,
                        &m_pszCaution
                        );
    }

    //
    // Format the personal trust string
    //

    if ( rhr == S_OK )
    {
        rhr = FormatACUIResourceString(
                        IDS_PERSONALTRUST,
                        aMessageArgument,
                        &m_pszPersonalTrust
                        );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::~CVerifiedTrustUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CVerifiedTrustUI::~CVerifiedTrustUI ()
{
    DELETE_OBJECT(m_pszInstallAndRun);
    DELETE_OBJECT(m_pszAuthenticity);
    DELETE_OBJECT(m_pszCaution);
    DELETE_OBJECT(m_pszPersonalTrust);
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CVerifiedTrustUI::InvokeUI (HWND hDisplay)
{
    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG1_VERIFIED),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }


    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    WCHAR psz[MAX_LOADSTRING_BUFFER];
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    int  savevpos;
    int  hkcharpos;
    RECT rect;

    //
    // Setup the publisher link subclass data parent window
    //

    m_lsdPublisher.hwndParent   = hwnd;
    m_lsdOpusInfo.hwndParent    = hwnd;
    m_lsdCA.hwndParent          = hwnd;
    m_lsdAdvanced.hwndParent    = hwnd;

    //
    // Render the install and run string
    //


    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN,
                                 IDC_PUBLISHER,
                                 m_pszInstallAndRun,
                                 deltavpos,
                                 (m_riih.ControlWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdOpusInfo,
                                 0,
                                 m_riih.Subject());


    //
    // Render the publisher, give it a "link" look and feel if it is a known
    // publisher
    //

        //
        // if there was a test cert in the chain, add it to the text...
        //
    if (m_riih.TestCertInChain())
    {
        WCHAR    *pszCombine;

        pszCombine = new WCHAR[wcslen(m_riih.Publisher()) + wcslen(m_riih.TestCertInChain()) + 3];

        if (pszCombine != NULL)
        {
            wcscpy(pszCombine, m_riih.Publisher());
            wcscat(pszCombine, L"\r\n");
            wcscat(pszCombine, m_riih.TestCertInChain());

            deltavpos = RenderACUIStringToEditControl(
                                         hwnd,
                                         IDC_PUBLISHER,
                                         IDC_AUTHENTICITY,
                                         pszCombine,
                                         deltavpos,
                                         m_riih.IsKnownPublisher() &&
                                         m_riih.IsCertViewPropertiesAvailable(),
                                         (WNDPROC)ACUILinkSubclass,
                                         &m_lsdPublisher,
                                         0,
                                         NULL
                                         );

            delete[] pszCombine;
        }

        if (LoadStringU(g_hModule, IDS_TESTCERTTITLE, psz, MAX_LOADSTRING_BUFFER) != 0)
        {
            int wtlen;

            wtlen = wcslen(psz) + GetWindowTextLength(hwnd);
            pszCombine = new WCHAR[wtlen + 1];

            if (pszCombine != NULL)
            {
                GetWindowTextU(hwnd, pszCombine, wtlen + 1);
                wcscat(pszCombine, psz);
                SetWindowTextU(hwnd, pszCombine);

                delete[] pszCombine;
            }
        }
    }
    else
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_PUBLISHER,
                                     IDC_AUTHENTICITY,
                                     m_riih.Publisher(),
                                     deltavpos,
                                     m_riih.IsKnownPublisher() &&
                                     m_riih.IsCertViewPropertiesAvailable(),
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdPublisher,
                                     0,
                                     NULL
                                     );
    }

    //
    // Render the authenticity statement
    //
    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_AUTHENTICITY,
                                 IDC_CAUTION,
                                 m_pszAuthenticity,
                                 deltavpos,
                                 (m_riih.CAWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdCA,
                                 0,
                                 m_riih.PublisherCertIssuer());


    //
    // Render the caution statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_CAUTION,
                                 IDC_ADVANCED,
                                 m_pszCaution,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the advanced string
    //
    if ((m_riih.AdvancedLink()) &&
         (m_riih.ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_ADVANCED,
                                     IDC_PERSONALTRUST,
                                     m_riih.AdvancedLink(),
                                     deltavpos,
                                     TRUE,
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdAdvanced,
                                     0,
                                     NULL
                                     );
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_ADVANCED), SW_HIDE);
    }

    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_VERBMP,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Rebase the check box and render the personal trust statement or hide
    // them the publisher is not known
    //

    if ( m_riih.IsKnownPublisher() == TRUE )
    {
        hControl = GetDlgItem(hwnd, IDC_PTCHECK);

        RebaseControlVertical(
                     hwnd,
                     hControl,
                     NULL,
                     FALSE,
                     deltavpos,
                     0,
                     bmptosep,
                     &deltaheight
                     );

        assert( deltaheight == 0 );

        //
        // Find the hotkey character position for the personal trust
        // check box
        //
#if (0) //DSIE: Bug 34325
        hkcharpos = GetHotKeyCharPosition(GetDlgItem(hwnd, IDC_PTCHECK));
#else
        hkcharpos = GetHotKeyCharPositionFromString(m_pszPersonalTrust);
#endif
        deltavpos = RenderACUIStringToEditControl(
                                    hwnd,
                                    IDC_PERSONALTRUST,
                                    IDC_SEPARATORLINE,
                                    m_pszPersonalTrust,
                                    deltavpos,
                                    FALSE,
                                    NULL,
                                    NULL,
                                    bmptosep,
                                    NULL
                                    );

        if ( hkcharpos != 0 )
        {
            FormatHotKeyOnEditControl(
                          GetDlgItem(hwnd, IDC_PERSONALTRUST),
                          hkcharpos
                          );
        }
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_PTCHECK), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_PERSONALTRUST), SW_HIDE);
    }


    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_VERBMP);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_VERBMP,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
           hControl,
           NULL,
           0,
           0,
           rect.right - rect.left,
           (rect.bottom - rect.top) + cyupd,
           SWP_NOZORDER | SWP_NOMOVE
           );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
           hwnd,
           NULL,
           0,
           0,
           rect.right - rect.left,
           (rect.bottom - rect.top) + cyupd,
           SWP_NOZORDER | SWP_NOMOVE
           );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));
    
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnYes (HWND hwnd)
{
    //
    // Set the invoke result
    //

    m_hrInvokeResult = S_OK;

    //
    // Add the publisher to the trust database
    //
    if ( SendDlgItemMessage(
             hwnd,
             IDC_PTCHECK,
             BM_GETCHECK,
             0,
             0
             ) == BST_CHECKED )
    {
        m_riih.AddPublisherToPersonalTrust();
    }

    //
    // End the dialog processing
    //

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_SIGNED);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_signed.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::CUnverifiedTrustUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CUnverifiedTrustUI::CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr)
                 : IACUIControl( riih ),
                   m_pszNoAuthenticity( NULL ),
                   m_pszProblemsBelow( NULL ),
                   m_pszInstallAndRun3( NULL )
{
    DWORD_PTR aMessageArgument[3];

    //
    // Initialize the publisher link subclass data
    //

    m_lsdPublisher.uId          = IDC_PUBLISHER;
    m_lsdPublisher.hwndParent   = NULL;
    m_lsdPublisher.wpPrev       = (WNDPROC)NULL;
    m_lsdPublisher.pvData       = (LPVOID)&riih;
    m_lsdPublisher.uToolTipText = IDS_CLICKHEREFORCERT;

    m_lsdOpusInfo.uId           = IDC_INSTALLANDRUN;
    m_lsdOpusInfo.hwndParent    = NULL;
    m_lsdOpusInfo.wpPrev        = (WNDPROC)NULL;
    m_lsdOpusInfo.pvData        = &riih;
    m_lsdOpusInfo.uToolTipText  = (DWORD_PTR)riih.ControlWebPage(); // IDS_CLICKHEREFOROPUSINFO;

    m_lsdAdvanced.uId           = IDC_ADVANCED;
    m_lsdAdvanced.hwndParent    = NULL;
    m_lsdAdvanced.wpPrev        = (WNDPROC)NULL;
    m_lsdAdvanced.pvData        = &riih;
    m_lsdAdvanced.uToolTipText  = IDS_CLICKHEREFORADVANCED;


    //
    // Format the no authenticity string
    //

    rhr = FormatACUIResourceString(
                    IDS_NOAUTHENTICITY,
                    NULL,
                    &m_pszNoAuthenticity
                    );

    //
    // Format the problems below string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.ErrorStatement();

        rhr = FormatACUIResourceString(
                    IDS_PROBLEMSBELOW,
                    aMessageArgument,
                    &m_pszProblemsBelow
                    );
    }

    //
    // Format the install and run string
    //

    if ( rhr == S_OK )
    {
        if (m_riih.CertTimestamp())
        {
            aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionText;
            aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
            aMessageArgument[2] = (DWORD_PTR)m_riih.CertTimestamp();
        }
        else
        {
            aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNoTS;
            aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
            aMessageArgument[2] = NULL;
        }

        rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun3);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::~CUnverifiedTrustUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CUnverifiedTrustUI::~CUnverifiedTrustUI ()
{
    DELETE_OBJECT(m_pszNoAuthenticity);
    DELETE_OBJECT(m_pszProblemsBelow);
    DELETE_OBJECT(m_pszInstallAndRun3);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CUnverifiedTrustUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG2_UNVERIFIED),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    RECT rect;

    //
    // Setup the publisher link subclass data parent window
    //

    m_lsdPublisher.hwndParent   = hwnd;
    m_lsdOpusInfo.hwndParent    = hwnd;
    m_lsdAdvanced.hwndParent    = hwnd;


    //
    // Render the no authenticity statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_NOAUTHENTICITY,
                                 IDC_PROBLEMSBELOW,
                                 m_pszNoAuthenticity,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the problems below string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_PROBLEMSBELOW,
                                 IDC_INSTALLANDRUN3,
                                 m_pszProblemsBelow,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the install and run string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN3,
                                 IDC_PUBLISHER2,
                                 m_pszInstallAndRun3,
                                 deltavpos,
                                 (m_riih.ControlWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdOpusInfo,
                                 0,
                                 m_riih.Subject());


    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_NOVERBMP2,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Render the publisher, give it a "link" look and feel
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_PUBLISHER2,
                                 IDC_ADVANCED,
                                 m_riih.Publisher(),
                                 deltavpos,
                                 m_riih.IsKnownPublisher() &&
                                 m_riih.IsCertViewPropertiesAvailable(),
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdPublisher,
                                 bmptosep,
                                 NULL
                                 );

    if ((m_riih.AdvancedLink()) &&
         (m_riih.ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_ADVANCED,
                                     IDC_SEPARATORLINE,
                                     m_riih.AdvancedLink(),
                                     deltavpos,
                                     TRUE,
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdAdvanced,
                                     0,
                                     NULL
                                     );
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_ADVANCED), SW_HIDE);
    }

    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_NOVERBMP2);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_NOVERBMP2,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
                 hControl,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
                 hwnd,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnYes (HWND hwnd)
{
    m_hrInvokeResult = S_OK;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_SIGNED_N_INVALID);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_signed_n_invalid.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::CNoSignatureUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper
//              [rhr]  -- result code reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CNoSignatureUI::CNoSignatureUI (CInvokeInfoHelper& riih, HRESULT& rhr)
               : IACUIControl( riih ),
                 m_pszInstallAndRun2( NULL ),
                 m_pszNoPublisherFound( NULL )
{
    DWORD_PTR aMessageArgument[2];

    //
    // Format the install and run string
    //

    aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNotSigned;
    aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();

    rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun2);

    //
    // Format the no publisher found string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.ErrorStatement();

        rhr = FormatACUIResourceString(
                    IDS_NOPUBLISHERFOUND,
                    aMessageArgument,
                    &m_pszNoPublisherFound
                    );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::~CNoSignatureUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CNoSignatureUI::~CNoSignatureUI ()
{
    DELETE_OBJECT(m_pszInstallAndRun2);
    DELETE_OBJECT(m_pszNoPublisherFound);
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CNoSignatureUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG3_NOSIGNATURE),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    RECT rect;

    //
    // Render the install and run string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN2,
                                 IDC_NOPUBLISHERFOUND,
                                 m_pszInstallAndRun2,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_NOVERBMP,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Render the no publisher found statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_NOPUBLISHERFOUND,
                                 IDC_SEPARATORLINE,
                                 m_pszNoPublisherFound,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 bmptosep,
                                 NULL
                                 );

    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_NOVERBMP);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_NOVERBMP,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
                 hControl,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
                 hwnd,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnYes (HWND hwnd)
{
    m_hrInvokeResult = S_OK;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_UNSIGNED);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_unsigned.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMessageProc
//
//  Synopsis:   message proc to process UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK ACUIMessageProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    IACUIControl* pUI = NULL;

    //
    // Get the control
    //

    if (uMsg == WM_INITDIALOG)
    {
        pUI = (IACUIControl *)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
    }
    else
    {
        pUI = (IACUIControl *)GetWindowLongPtr(hwnd, DWLP_USER);
    }

    //
    // If we couldn't find it, we must not have set it yet, so ignore this
    // message
    //

    if ( pUI == NULL )
    {
        return( FALSE );
    }

    //
    // Pass the message on to the control
    //

    return( pUI->OnUIMessage(hwnd, uMsg, wParam, lParam) );
}


int GetRichEditControlLineHeight(HWND  hwnd)
{
    RECT        rect;
    POINT       pointInFirstRow;
    POINT       pointInSecondRow;
    int         secondLineCharIndex;
    int         i;
    RECT        originalRect;

    GetWindowRect(hwnd, &originalRect);

    //
    // HACK ALERT, believe it or not there is no way to get the height of the current
    // font in the edit control, so get the position a character in the first row and the position
    // of a character in the second row, and do the subtraction to get the
    // height of the font
    //
    SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInFirstRow, (LPARAM) 0);

    //
    // HACK ON TOP OF HACK ALERT,
    // since there may not be a second row in the edit box, keep reducing the width
    // by half until the first row falls over into the second row, then get the position
    // of the first char in the second row and finally reset the edit box size back to
    // it's original size
    //
    secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
    if (secondLineCharIndex == -1)
    {
        for (i=0; i<20; i++)
        {
            GetWindowRect(hwnd, &rect);
            SetWindowPos(   hwnd,
                            NULL,
                            0,
                            0,
                            (rect.right-rect.left)/2,
                            rect.bottom-rect.top,
                            SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
            secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
            if (secondLineCharIndex != -1)
            {
                break;
            }
        }

        if (secondLineCharIndex == -1)
        {
            // if we failed after twenty tries just reset the control to its original size
            // and get the heck outa here!!
            SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            return 0;
        }

        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);

        SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
    else
    {
        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);
    }
    
    return (pointInSecondRow.y - pointInFirstRow.y);
}

//+---------------------------------------------------------------------------
//
//  Function:   RebaseControlVertical
//
//  Synopsis:   Take the window control, if it has to be resized for text, do
//              so.  Reposition it adjusted for delta pos and return any
//              height difference for the text resizing
//
//  Arguments:  [hwndDlg]        -- host dialog
//              [hwnd]           -- control
//              [hwndNext]       -- next control
//              [fResizeForText] -- resize for text flag
//              [deltavpos]      -- delta vertical position
//              [oline]          -- original number of lines
//              [minsep]         -- minimum separator
//              [pdeltaheight]   -- delta in control height
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID RebaseControlVertical (
                  HWND  hwndDlg,
                  HWND  hwnd,
                  HWND  hwndNext,
                  BOOL  fResizeForText,
                  int   deltavpos,
                  int   oline,
                  int   minsep,
                  int*  pdeltaheight
                  )
{
    int        x = 0;
    int        y = 0;
    int        odn = 0;
    int         orig_w;
    RECT       rect;
    RECT       rectNext;
    RECT       rectDlg;
    TEXTMETRIC tm;

    //
    // Set the delta height to zero for now.  If we resize the text
    // a new one will be calculated
    //

    *pdeltaheight = 0;

    //
    // Get the control window rectangle
    //

    GetWindowRect(hwnd, &rect);
    GetWindowRect(hwndNext, &rectNext);

    odn     = rectNext.top - rect.bottom;

    orig_w  = rect.right - rect.left;

    MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rect, 2);

    //
    // If we have to resize the control due to text, find out what font
    // is being used and the number of lines of text.  From that we'll
    // calculate what the new height for the control is and set it up
    //

    if ( fResizeForText == TRUE )
    {
        HDC        hdc;
        HFONT      hfont;
        HFONT      hfontOld;
        int        cline;
        int        h;
        int        w;
        int        dh;
        int        lineHeight;
        
        //
        // Get the metrics of the current control font
        //

        hdc = GetDC(hwnd);
        if (hdc == NULL)
        {
            hdc = GetDC(NULL);
            if (hdc == NULL)
            {
                return;
            }
        }

        hfont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
        if ( hfont == NULL )
        {
            hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0);
        }

        hfontOld = (HFONT)SelectObject(hdc, hfont);
        GetTextMetrics(hdc, &tm);

        lineHeight = GetRichEditControlLineHeight(hwnd);
        if (lineHeight == 0)
        {
            lineHeight = tm.tmHeight;
        }
        
        //
        // Set the minimum separation value
        //

        if ( minsep == 0 )
        {
            minsep = lineHeight;
        }

        //
        // Calculate the width and the new height needed
        //

        cline = (int)SendMessage(hwnd, EM_GETLINECOUNT, 0, 0);

        h = cline * lineHeight;

        w = GetEditControlMaxLineWidth(hwnd, hdc, cline);
        w += 3; // a little bump to make sure string will fit

        if (w > orig_w)
        {
            w = orig_w;
        }

        SelectObject(hdc, hfontOld);
        ReleaseDC(hwnd, hdc);

        //
        // Calculate an addition to height by checking how much space was
        // left when there were the original # of lines and making sure that
        // that amount is  still left when we do any adjustments
        //

        h += ( ( rect.bottom - rect.top ) - ( oline * lineHeight ) );
        dh = h - ( rect.bottom - rect.top );

        //
        // If the current height is too small, adjust for it, otherwise
        // leave the current height and just adjust for the width
        //

        if ( dh > 0 )
        {
            SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        }
        else
        {
            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               w,
               ( rect.bottom - rect.top ),
               SWP_NOZORDER | SWP_NOMOVE
               );
        }

        if ( cline < SendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
        {
            AdjustEditControlWidthToLineCount(hwnd, cline, &tm);
        }
    }

    //
    // If we have to use deltavpos then calculate the X and the new Y
    // and set the window position appropriately
    //

    if ( deltavpos != 0 )
    {
        GetWindowRect(hwndDlg, &rectDlg);

        MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rectDlg, 2);

        x = rect.left - rectDlg.left - GetSystemMetrics(SM_CXEDGE);
        y = rect.top - rectDlg.top - GetSystemMetrics(SM_CYCAPTION) + deltavpos;

        SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }

    //
    // Get the window rect for the next control and see what the distance
    // is between the current control and it.  With that we must now
    // adjust our deltaheight, if the distance to the next control is less
    // than a line height then make it a line height, otherwise just let it
    // be
    //

    if ( hwndNext != NULL )
    {
        int dn;

        GetWindowRect(hwnd, &rect);
        GetWindowRect(hwndNext, &rectNext);

        dn = rectNext.top - rect.bottom;

        if ( odn > minsep )
        {
            if ( dn < minsep )
            {
                *pdeltaheight = minsep - dn;
            }
        }
        else
        {
            if ( dn < odn )
            {
                *pdeltaheight = odn - dn;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUISetArrowCursorSubclass
//
//  Synopsis:   subclass routine for setting the arrow cursor.  This can be
//              set on multiline edit routines used in the dialog UIs for
//              the default Authenticode provider
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK ACUISetArrowCursorSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    HDC         hdc;
    WNDPROC     wndproc;
    PAINTSTRUCT ps;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ' )
        {
            break;
        }

    case WM_LBUTTONDOWN:

        if ( hwnd == GetDlgItem(GetParent(hwnd), IDC_PERSONALTRUST) )
        {
            int  check;
            HWND hwndCheck;

            //
            // Toggle the check state of the PTCHECK control if the
            // personal trust statement is clicked on
            //

            hwndCheck = GetDlgItem(GetParent(hwnd), IDC_PTCHECK);
            check = (int)SendMessage(hwndCheck, BM_GETCHECK, 0, 0);

            if ( check == BST_CHECKED )
            {
                check = BST_UNCHECKED;
            }
            else if ( check == BST_UNCHECKED )
            {
                check = BST_CHECKED;
            }
            else
            {
                check = BST_UNCHECKED;
            }

            SendMessage(hwndCheck, BM_SETCHECK, (WPARAM)check, 0);
            SetFocus(hwnd);
            return( TRUE );
        }

        return(TRUE);

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

        break;

    case EM_SETSEL:

        return( TRUE );

        break;

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

        break;

    case WM_SETFOCUS:

        if ( hwnd != GetDlgItem(GetParent(hwnd), IDC_PERSONALTRUST) )
        {
            SetFocus(GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE));
            return( TRUE );
        }
        else
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return( TRUE );
        }

        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        return( TRUE );

    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForArrowCursor
//
//  Synopsis:   subclasses edit control so that the arrow cursor can replace
//              the edit bar
//
//  Arguments:  [hwndEdit] -- edit control
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID SubclassEditControlForArrowCursor (HWND hwndEdit)
{
    LONG_PTR PrevWndProc;

    PrevWndProc = GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)PrevWndProc);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)ACUISetArrowCursorSubclass);
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForLink
//
//  Synopsis:   subclasses the edit control for a link using the link subclass
//              data
//
//  Arguments:  [hwndDlg]  -- dialog
//              [hwndEdit] -- edit control
//              [wndproc]  -- window proc to subclass with
//              [plsd]     -- data to pass on to window proc
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID SubclassEditControlForLink (
                 HWND                       hwndDlg,
                 HWND                       hwndEdit,
                 WNDPROC                    wndproc,
                 PTUI_LINK_SUBCLASS_DATA    plsd
                 )
{
    HWND hwndTip;

    plsd->hwndTip = CreateWindowA(
                          TOOLTIPS_CLASSA,
                          (LPSTR)NULL,
                          WS_POPUP | TTS_ALWAYSTIP,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          hwndDlg,
                          (HMENU)NULL,
                          g_hModule,
                          NULL
                          );

    if ( plsd->hwndTip != NULL )
    {
        TOOLINFOA   tia;
        DWORD       cb;
        LPSTR       psz;

        memset(&tia, 0, sizeof(TOOLINFOA));
        tia.cbSize = sizeof(TOOLINFOA);
        tia.hwnd = hwndEdit;
        tia.uId = 1;
        tia.hinst = g_hModule;
        //GetClientRect(hwndEdit, &tia.rect);
        SendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)&tia.rect);

        //
        // if plsd->uToolTipText is a string then convert it
        //
        if (plsd->uToolTipText &0xffff0000)
        {
            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (psz = new char[cb]))
            {
                return;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        psz, 
                        cb, 
                        NULL, 
                        NULL);
            
            tia.lpszText = psz;
        }
        else
        {
            tia.lpszText = (LPSTR)plsd->uToolTipText;
        }

        SendMessage(plsd->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&tia);

        if (plsd->uToolTipText &0xffff0000)
        {
            delete[] psz;
        }
    }

    plsd->fMouseCaptured = FALSE;
    plsd->wpPrev = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)plsd);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)wndproc);
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUILinkSubclass
//
//  Synopsis:   subclass for the publisher link
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK ACUILinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    PTUI_LINK_SUBCLASS_DATA plsd;
    CInvokeInfoHelper*      piih;

    plsd = (PTUI_LINK_SUBCLASS_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    piih = (CInvokeInfoHelper *)plsd->pvData;

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        if (!plsd->fMouseCaptured)
        {
            SetCapture(hwnd);
            plsd->fMouseCaptured = TRUE;
        }

        SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                            MAKEINTRESOURCE(IDC_TUIHAND)));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ')
        {
            break;
        }

        // fall through to wm_lbuttondown....

    case WM_LBUTTONDOWN:

        SetFocus(hwnd);

        switch(plsd->uId)
        {
            case IDC_PUBLISHER:
                piih->CallCertViewProperties(plsd->hwndParent);
                break;

            case IDC_INSTALLANDRUN:
                piih->CallWebLink(plsd->hwndParent, (WCHAR *)piih->ControlWebPage());
                break;

            case IDC_AUTHENTICITY:
                piih->CallWebLink(plsd->hwndParent, (WCHAR *)piih->CAWebPage());
                break;


            case IDC_ADVANCED:
                piih->CallAdvancedLink(plsd->hwndParent);
                break;
        }

        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_PAINT:

        CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_SETFOCUS:

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_TUIHAND)));
            return( TRUE );
        }
        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        return( TRUE );

    case WM_MOUSEMOVE:

        MSG                 msg;
        DWORD               dwCharLine;
        CHARFORMAT          sCharFmt;
        RECT                rect;
        int                 xPos, yPos;

        memset(&msg, 0, sizeof(MSG));
        msg.hwnd    = hwnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        SendMessage(plsd->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            plsd->fMouseCaptured = FALSE;
        }

        /*
            warning!
                    EM_CHARFROMPOS gets an access violation!

        dwCharLine = SendMessage(hwnd, EM_CHARFROMPOS, 0, lParam);

        if (dwCharLine == (-1))
        {
            return(TRUE);
        }

        SendMessage(hwnd, EM_SETSEL, (WPARAM)LOWORD(dwCharLine), (LPARAM)(LOWORD(dwCharLine) + 1));

        memset(&sCharFmt, 0x00, sizeof(CHARFORMAT));
        sCharFmt.cbSize = sizeof(CHARFORMAT);

        SendMessage(hwnd, EM_GETCHARFORMAT, TRUE, (LPARAM)&sCharFmt);

        if (sCharFmt.dwEffects & CFE_UNDERLINE)
        {
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_TUIHAND)));
        }
        else
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }

  */
        return( TRUE );
    }

    return(CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatACUIResourceString
//
//  Synopsis:   formats a string given a resource id and message arguments
//
//  Arguments:  [StringResourceId] -- resource id
//              [aMessageArgument] -- message arguments
//              [ppszFormatted]    -- formatted string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT FormatACUIResourceString (
                  UINT   StringResourceId,
                  DWORD_PTR* aMessageArgument,
                  LPWSTR* ppszFormatted
                  )
{
    HRESULT hr = S_OK;
    WCHAR   sz[MAX_LOADSTRING_BUFFER];
    LPVOID  pvMsg;

    pvMsg = NULL;
    sz[0] = NULL;

    //
    // Load the string resource and format the message with that string and
    // the message arguments
    //

    if (StringResourceId != 0)
    {
        if ( LoadStringU(g_hModule, StringResourceId, sz, MAX_LOADSTRING_BUFFER) == 0 )
        {
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, sz, 0, 0, (LPWSTR)&pvMsg, 0,
                            (va_list *)aMessageArgument) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        if ( FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, (char *)aMessageArgument[0], 0, 0,
                            (LPWSTR)&pvMsg, 0, (va_list *)&aMessageArgument[1]) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (pvMsg)
    {
        *ppszFormatted = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppszFormatted)
        {
            wcscpy(*ppszFormatted, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   RenderACUIStringToEditControl
//
//  Synopsis:   renders a string to the control given and if requested, gives
//              it a link look and feel, subclassed to the wndproc and plsd
//              given
//
//  Arguments:  [hwndDlg]       -- dialog window handle
//              [ControlId]     -- control id
//              [NextControlId] -- next control id
//              [psz]           -- string
//              [deltavpos]     -- delta vertical position
//              [fLink]         -- a link?
//              [wndproc]       -- optional wndproc, valid if fLink == TRUE
//              [plsd]          -- optional plsd, valid if fLink === TRUE
//              [minsep]        -- minimum separation
//              [pszThisTextOnlyInLink -- only change this text.
//
//  Returns:    delta in height of the control
//
//  Notes:
//
//----------------------------------------------------------------------------
int RenderACUIStringToEditControl (
                  HWND                      hwndDlg,
                  UINT                      ControlId,
                  UINT                      NextControlId,
                  LPCWSTR                   psz,
                  int                       deltavpos,
                  BOOL                      fLink,
                  WNDPROC                   wndproc,
                  PTUI_LINK_SUBCLASS_DATA   plsd,
                  int                       minsep,
                  LPCWSTR                   pszThisTextOnlyInLink
                  )
{
    HWND hControl;
    int  deltaheight = 0;
    int  oline = 0;
    int  hkcharpos;

    //
    // Get the control and set the text on it, make sure the background
    // is right if it is a rich edit control
    //

    hControl = GetDlgItem(hwndDlg, ControlId);
    oline = (int)SendMessage(hControl, EM_GETLINECOUNT, 0, 0);
    CryptUISetRicheditTextW(hwndDlg, ControlId, L"");
    CryptUISetRicheditTextW(hwndDlg, ControlId, psz); //SetWindowTextU(hControl, psz);

    //
    // If there is a '&' in the string, then get rid of it
    //
    hkcharpos = GetHotKeyCharPosition(hControl);
    if (IDC_PERSONALTRUST == ControlId && hkcharpos != 0)
    {
        CHARRANGE  cr;
        CHARFORMAT cf;

        cr.cpMin = hkcharpos - 1;
        cr.cpMax = hkcharpos;

        SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
        SendMessage(hControl, EM_REPLACESEL, FALSE, (LPARAM) "");

        cr.cpMin = -1;
        cr.cpMax = 0;
        SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
    }

    SendMessage(
        hControl,
        EM_SETBKGNDCOLOR,
        0,
        (LPARAM)GetSysColor(COLOR_3DFACE)
        );

    //
    // If we have a link then update for the link look
    //

    if ( fLink == TRUE )
    {
        CHARFORMAT cf;

        memset(&cf, 0, sizeof(CHARFORMAT));
        cf.cbSize = sizeof(CHARFORMAT);
        cf.dwMask = CFM_COLOR | CFM_UNDERLINE;

        cf.crTextColor = RGB(0, 0, 255);
        cf.dwEffects |= CFM_UNDERLINE;

        if (pszThisTextOnlyInLink)
        {
            FINDTEXTEX  ft;
            DWORD       pos;
            char        *pszOnlyThis;
            DWORD       cb;

            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (pszOnlyThis = new char[cb]))
            {
                return 0;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        pszOnlyThis, 
                        cb, 
                        NULL, 
                        NULL);


            memset(&ft, 0x00, sizeof(FINDTEXTEX));
            ft.chrg.cpMin   = 0;
            ft.chrg.cpMax   = (-1);
            ft.lpstrText    = (char *)pszOnlyThis;

            if ((pos = (DWORD)SendMessage(hControl, EM_FINDTEXTEX, 0, (LPARAM)&ft)) != (-1))
            {
                SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
                SendMessage(hControl, EM_SETCHARFORMAT, SCF_WORD | SCF_SELECTION, (LPARAM)&cf);
                ft.chrgText.cpMin   = 0;
                ft.chrgText.cpMax   = 0;
                SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
            }

            delete[] pszOnlyThis;
        }
        else
        {
            SendMessage(hControl, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
        }
    }

    //
    // Rebase the control
    //

    RebaseControlVertical(
                 hwndDlg,
                 hControl,
                 GetDlgItem(hwndDlg, NextControlId),
                 TRUE,
                 deltavpos,
                 oline,
                 minsep,
                 &deltaheight
                 );

    //
    // If we have the link look then we must subclass for the appropriate
    // link feel, otherwise we subclass for a static text control feel
    //

    if ( fLink == TRUE )
    {
        SubclassEditControlForLink(hwndDlg, hControl, wndproc, plsd);
    }
    else
    {
        SubclassEditControlForArrowCursor(hControl);
    }

    return( deltaheight );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistance
//
//  Synopsis:   calculates the vertical distance from the bottom of Control1
//              to the top of Control2
//
//  Arguments:  [hwnd]     -- parent dialog
//              [Control1] -- first control
//              [Control2] -- second control
//
//  Returns:    the distance in pixels
//
//  Notes:      assumes control1 is above control2
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistance (HWND hwnd, UINT Control1, UINT Control2)
{
    RECT rect1;
    RECT rect2;

    GetWindowRect(GetDlgItem(hwnd, Control1), &rect1);
    GetWindowRect(GetDlgItem(hwnd, Control2), &rect2);

    return( rect2.top - rect1.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistanceFromDlgBottom
//
//  Synopsis:   calculates the distance from the bottom of the control to
//              the bottom of the dialog
//
//  Arguments:  [hwnd]    -- dialog
//              [Control] -- control
//
//  Returns:    the distance in pixels
//
//  Notes:
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistanceFromDlgBottom (HWND hwnd, UINT Control)
{
    RECT rect;
    RECT rectControl;

    GetClientRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, Control), &rectControl);

    return( rect.bottom - rectControl.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUICenterWindow
//
//  Synopsis:   centers the given window
//
//  Arguments:  [hWndToCenter] -- window handle
//
//  Returns:    (none)
//
//  Notes:      This code was stolen from ATL and hacked upon madly :-)
//
//----------------------------------------------------------------------------
VOID ACUICenterWindow (HWND hWndToCenter)
{
    HWND  hWndCenter;

	// determine owner window to center against
	DWORD dwStyle = (DWORD)GetWindowLong(hWndToCenter, GWL_STYLE);

  	if(dwStyle & WS_CHILD)
  		hWndCenter = ::GetParent(hWndToCenter);
  	else
  		hWndCenter = ::GetWindow(hWndToCenter, GW_OWNER);

    if (hWndCenter == NULL)
    {
        return;
    }

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(hWndToCenter, &rcDlg);
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle2 = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle2 & WS_VISIBLE) || (dwStyle2 & WS_MINIMIZE))
				hWndCenter = NULL;
		}

		// center within screen coordinates
		::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			::GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(hWndToCenter);

		::GetClientRect(hWndParent, &rcArea);
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	::SetWindowPos(
         hWndToCenter,
         HWND_TOPMOST,
         xLeft,
         yTop,
         -1,
         -1,
         SWP_NOSIZE | SWP_NOACTIVATE
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIViewHTMLHelpTopic
//
//  Synopsis:   html help viewer
//
//  Arguments:  [hwnd]     -- caller window
//              [pszTopic] -- topic
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic)
{
//    HtmlHelpA(
//        hwnd,
//        "%SYSTEMROOT%\\help\\iexplore.chm>large_context",
//        HH_DISPLAY_TOPIC,
//        (DWORD)pszTopic
//        );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetEditControlMaxLineWidth
//
//  Synopsis:   gets the maximum line width of the edit control
//
//----------------------------------------------------------------------------
int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline)
{
    int        index;
    int        line;
    int        charwidth;
    int        maxwidth = 0;
    CHAR       szMaxBuffer[1024];
    WCHAR      wsz[1024];
    TEXTRANGEA tr;
    SIZE       size;

    tr.lpstrText = szMaxBuffer;

    for ( line = 0; line < cline; line++ )
    {
        index = (int)SendMessage(hwndEdit, EM_LINEINDEX, (WPARAM)line, 0);
        charwidth = (int)SendMessage(hwndEdit, EM_LINELENGTH, (WPARAM)index, 0);

        tr.chrg.cpMin = index;
        tr.chrg.cpMax = index + charwidth;
        SendMessage(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&tr);

        wsz[0] = NULL;

        MultiByteToWideChar(0, 0, (const char *)tr.lpstrText, -1, &wsz[0], 1024);

        if (wsz[0])
        {
            GetTextExtentPoint32W(hdc, &wsz[0], charwidth, &size);

            if ( size.cx > maxwidth )
            {
                maxwidth = size.cx;
            }
        }
    }

    return( maxwidth );
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawFocusRectangle
//
//  Synopsis:   draws the focus rectangle for the edit control
//
//----------------------------------------------------------------------------
void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    PAINTSTRUCT ps;
    BOOL        fReleaseDC = FALSE;

    if ( hdc == NULL )
    {
        hdc = GetDC(hwnd);
        if ( hdc == NULL )
        {
            return;
        }
        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPositionFromString
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPositionFromString (LPWSTR pwszText)
{
    LPWSTR psz = pwszText;

    while ( ( psz = wcschr(psz, L'&') ) != NULL )
    {
        psz++;
        if ( *psz != L'&' )
        {
            break;
        }
    }

    if ( psz == NULL )
    {
        return( 0 );
    }

    return (int)(( psz - pwszText ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPosition
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPosition (HWND hwnd)
{
    int   nPos = 0;
    WCHAR szText[MAX_LOADSTRING_BUFFER] = L"";

    if (GetWindowTextU(hwnd, szText, MAX_LOADSTRING_BUFFER))
    {
        nPos = GetHotKeyCharPositionFromString(szText);
    }

    return nPos;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatHotKeyOnEditControl
//
//  Synopsis:   formats the hot key on an edit control by making it underlined
//
//----------------------------------------------------------------------------
VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos)
{
    CHARRANGE  cr;
    CHARFORMAT cf;

    assert( hkcharpos != 0 );

    cr.cpMin = hkcharpos - 1;
    cr.cpMax = hkcharpos;

    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);

    memset(&cf, 0, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_UNDERLINE;
    cf.dwEffects |= CFM_UNDERLINE;

    SendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    cr.cpMin = -1;
    cr.cpMax = 0;
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdjustEditControlWidthToLineCount
//
//  Synopsis:   adjust edit control width to the given line count
//
//----------------------------------------------------------------------------
void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm)
{
    RECT rect;
    int  w;
    int  h;

    GetWindowRect(hwnd, &rect);
    h = rect.bottom - rect.top;
    w = rect.right - rect.left;

    while ( cline < SendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
    {
        w += ptm->tmMaxCharWidth;
        SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        printf(
            "Line count adjusted to = %d\n",
            (DWORD) SendMessage(hwnd, EM_GETLINECOUNT, 0, 0)
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\iih.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       iih.cpp
//
//  Contents:   ACUI Invoke Info Helper class implementation
//
//  History:    10-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include    "malloc.h"
#include    "sgnerror.h"
//
// Personal trust database interface id
//

extern "C" const GUID IID_IPersonalTrustDB = IID_IPersonalTrustDB_Data;
//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::CInvokeInfoHelper, public
//
//  Synopsis:   Constructor, initializes member variables from data found
//              in the invoke info data structure
//
//  Arguments:  [pInvokeInfo] -- invoke info
//              [rhr]         -- result of construction
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::CInvokeInfoHelper (
                          PACUI_INVOKE_INFO pInvokeInfo,
                          HRESULT&          rhr
                          )
                  : m_pInvokeInfo ( pInvokeInfo ),
                    m_pszSubject ( NULL ),
                    m_pszPublisher ( NULL ),
                    m_pszAdvancedLink ( NULL ),
                    m_pszControlWebPage ( NULL ),
                    m_pszCAWebPage ( NULL ),
                    m_pszPublisherCertIssuer ( NULL ),
                    m_pszErrorStatement ( NULL ),
                    m_pszCertTimestamp ( NULL ),
                    m_pszTestCertInChain ( NULL ),
                    m_fKnownPublisher ( FALSE ),
                    m_hModCVPA ( NULL ),
                    m_pfnCVPA ( NULL )
{
    //
    // Initialize the subject
    //

    rhr = InitSubject();

    //
    //  if there's a test cert, format the text!
    //
    InitTestCertInChain();

    //
    // If we actually have a signature then ...
    //

        //
        // If we need an error statement, initialize it
        //

    if ( ( rhr == S_OK ) && ( pInvokeInfo->hrInvokeReason != S_OK ) )
    {
        rhr = InitErrorStatement();
    }

    if ( ( rhr == S_OK ) &&
         ( pInvokeInfo->hrInvokeReason != TRUST_E_NOSIGNATURE ) )
    {
        //
        // Initialize the publisher
        //

        rhr = InitPublisher();

        //
        // If we have a known publisher, then we initialize the publisher
        // cert issuer
        //

        if ( ( rhr == S_OK ) && ( m_fKnownPublisher == TRUE ) )
        {
            rhr = InitPublisherCertIssuer();
        }

        //
        // Initialize the timestamp string
        //

        if ( rhr == S_OK )
        {
            rhr = InitCertTimestamp();
        }

        //
        //  initialize the "advanced link" text
        //
        InitAdvancedLink();

        //
        //  initialize the Control's Web page link
        //
        InitControlWebPage();

        //
        //  initialize the CA's Web page link
        //
        InitCAWebPage();
    }

    //
    // Initialize the CertViewProperties entry point
    //

    if ( rhr == S_OK )
    {
        InitCertViewPropertiesEntryPoint();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::~CInvokeInfoHelper, public
//
//  Synopsis:   Destructor, frees up member variables
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::~CInvokeInfoHelper ()
{
    DELETE_OBJECT(m_pszSubject);
    DELETE_OBJECT(m_pszPublisher);
    DELETE_OBJECT(m_pszPublisherCertIssuer);
    DELETE_OBJECT(m_pszAdvancedLink);
    DELETE_OBJECT(m_pszControlWebPage);
    DELETE_OBJECT(m_pszCAWebPage);
    DELETE_OBJECT(m_pszTestCertInChain);
    DELETE_OBJECT(m_pszCertTimestamp);
    DELETE_OBJECT(m_pszErrorStatement);

    if ( m_hModCVPA != NULL )
    {
        FreeLibrary(m_hModCVPA);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::AddPublisherToPersonalTrust, public
//
//  Synopsis:   adds the current publisher to the personal trust database
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, publisher added to personal trust database
//              hr != S_OK, publisher NOT added to personal trust database
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::AddPublisherToPersonalTrust ()
{
    HRESULT           hr = S_OK;
    IPersonalTrustDB* pTrustDB = NULL;

    //
    // Get the personal trust database interface
    //

    hr = m_pInvokeInfo->pPersonalTrustDB->QueryInterface(
                                               IID_IPersonalTrustDB,
                                               (LPVOID *)&pTrustDB
                                               );

    //
    // Add the publisher cert to the database
    //

    if ( hr == S_OK )
    {
        CRYPT_PROVIDER_SGNR     *pSgnr;
        CRYPT_PROVIDER_CERT     *pCert;

        if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
        {
            if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
            {
                hr = pTrustDB->AddTrustCert(
                                  pCert->pCert,
                                  0,
                                  FALSE
                                  );
            }
        }

        pTrustDB->Release();
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::GetUIControl, public
//
//  Synopsis:   gets the UI control
//
//  Arguments:  [ppUI] -- UI returned here
//
//  Returns:    S_OK for success, any other valid HRESULT otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::GetUIControl (IACUIControl** ppUI)
{
    HRESULT       hr = S_OK;
    IACUIControl* pUI = NULL;

    //
    // Get the right UI control
    //

    switch (m_pInvokeInfo->hrInvokeReason)
    {
        case S_OK:
            pUI = new CVerifiedTrustUI(*this, hr);
            break;

        case CERT_E_EXPIRED:
        case CERT_E_PURPOSE:
        case CERT_E_WRONG_USAGE:
        case CERT_E_CN_NO_MATCH:
        case CERT_E_INVALID_NAME:
        case CERT_E_INVALID_POLICY:
        case CERT_E_REVOCATION_FAILURE:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
            pUI = new CUnverifiedTrustUI(*this, hr);
            break;
#if (0)
        case CRYPT_E_FILE_ERROR:
        case TRUST_E_PROVIDER_UNKNOWN:
        case TRUST_E_SUBJECT_FORM_UNKNOWN:
        case TRUST_E_NOSIGNATURE:
        case CERT_E_CHAINING:
        case CERT_E_UNTRUSTEDROOT:
        case CERT_E_UNTRUSTEDTESTROOT:
#endif
        default:
            pUI = new CNoSignatureUI(*this, hr);
            break;
    }

    //
    // Set the out parameter and return value
    //

    if ( ( pUI != NULL ) && ( hr == S_OK ) )
    {
        *ppUI = pUI;
    }
    else if ( pUI == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        delete pUI;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::ReleaseUIControl, public
//
//  Synopsis:   frees the UI control
//
//  Arguments:  [pUI] -- UI control
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CInvokeInfoHelper::ReleaseUIControl (IACUIControl* pUI)
{
    delete pUI;
}

VOID CInvokeInfoHelper::InitControlWebPage ()
{
    WCHAR   *pwsz;

    if (!(m_pInvokeInfo->pOpusInfo))
    {
        return;
    }
    if (!(m_pInvokeInfo->pOpusInfo->pMoreInfo))
    {
        return;
    }

    pwsz = GetGoLink(m_pInvokeInfo->pOpusInfo->pMoreInfo);

    if (!(pwsz))
    {
        return;
    }

    m_pszControlWebPage = new WCHAR[wcslen(pwsz) + 1];

    if (m_pszControlWebPage != NULL)
    {
        wcscpy(m_pszControlWebPage, pwsz);
    }
}

VOID CInvokeInfoHelper::InitCAWebPage ()
{

    //
    //  until IE submits....  don't do it!
    //

    return;


    WCHAR                   *pwsz;
    DWORD                   cb;

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;
    SPC_SP_AGENCY_INFO      *pAgencyInfo;

    if (!(pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0)))
    {
        return;
    }
    if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 0))) // try the publisher's cert first!
    {
        return;
    }

    cb = 0;
    WTHelperGetAgencyInfo(pCert->pCert, &cb, NULL);

    if (cb < 1)
    {
        if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 1)))  // try the issuer's next
        {
            return;
        }

        cb = 0;
        WTHelperGetAgencyInfo(pCert->pCert, &cb, NULL);

        if (cb < 1)
        {
            return;
        }
    }

    if (!(pAgencyInfo = (SPC_SP_AGENCY_INFO *)new BYTE[cb]))
    {
        return;
    }

    if (!(WTHelperGetAgencyInfo(pCert->pCert, &cb, pAgencyInfo)))
    {
        delete pAgencyInfo;
        return;
    }

    pwsz = GetGoLink(pAgencyInfo->pPolicyInformation);

    m_pszCAWebPage = new WCHAR[wcslen(pwsz) + 1];
   
    if (m_pszCAWebPage != NULL)
    {
        wcscpy(m_pszCAWebPage, pwsz);
    }
    
    delete pAgencyInfo;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitSubject, private
//
//  Synopsis:   Initialize m_pszSubject
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitSubject ()
{
    HRESULT hr = S_OK;
    LPCWSTR pwszSubject = NULL;

    //
    // Find out what we will use as the subject name
    //

    if ( ( m_pInvokeInfo->pOpusInfo != NULL ) &&
         ( m_pInvokeInfo->pOpusInfo->pwszProgramName != NULL ) )
    {
        pwszSubject = m_pInvokeInfo->pOpusInfo->pwszProgramName;
    }
    else
    {
        pwszSubject = m_pInvokeInfo->pwcsAltDisplayName;
    }

    //
    // At this point we must have a valid subject name
    //

    assert( pwszSubject != NULL );

    //
    // Fill in the subject member by converting the one we found from
    // UNICODE to MBS
    //

    m_pszSubject = new WCHAR[wcslen(pwszSubject) + 1];

    if ( m_pszSubject != NULL )
    {
        wcscpy(m_pszSubject, pwszSubject);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return( hr );
}

VOID
CInvokeInfoHelper::InitTestCertInChain ()
{
    WCHAR    szTestCertInChain[MAX_LOADSTRING_BUFFER + 1];

    if (IsTestCertInPublisherChain())
    {
        if ( LoadStringU(
                 g_hModule,
                 IDS_TESTCERTINCHAIN,
                 szTestCertInChain,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return;
        }

        m_pszTestCertInChain = new WCHAR[wcslen(szTestCertInChain) + 1];
        if (m_pszTestCertInChain != NULL)
        {
            wcscpy(m_pszTestCertInChain, szTestCertInChain);
        }
    }
}

VOID
CInvokeInfoHelper::InitAdvancedLink ()
{
    ULONG   cbAL;

    if ((ProviderData()) &&
        (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, ProviderData()->psPfns->cbStruct, psUIpfns)) &&
        (ProviderData()->psPfns->psUIpfns) &&
        (ProviderData()->psPfns->psUIpfns->psUIData) &&
        (ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText))
    {
        m_pszAdvancedLink = new WCHAR[wcslen(ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText) + 1];
        
        if (m_pszAdvancedLink != NULL)
        {
            wcscpy(m_pszAdvancedLink, ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitPublisher, private
//
//  Synopsis:   Initialize m_pszPublisher
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitPublisher ()
{
    HRESULT hr = S_OK;
    ULONG   cchPublisher;
    LPWSTR  pwszPublisher = NULL;
    WCHAR   szPublisher[MAX_LOADSTRING_BUFFER];

    //
    // Load the unknown publisher string
    //

    if ( LoadStringU(
             g_hModule,
             IDS_UNKNOWNPUBLISHER,
             szPublisher,
             MAX_LOADSTRING_BUFFER
             ) == 0 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // Since the publisher is the subject of the signer certificate, we try to
    // find the publisher name in the common name extensions of that cert
    //

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {


            cchPublisher = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);

            if (cchPublisher > 1)
            {
                pwszPublisher = new WCHAR[cchPublisher];
                if ( pwszPublisher == NULL )
                {
                    return (E_OUTOFMEMORY);
                }
                cchPublisher = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL,
                                                 pwszPublisher, cchPublisher);
            }
        }
    }


    //
    // If we still don't have a publisher, use the unknown publisher string
    //

    if ( pwszPublisher == NULL )
    {
        m_fKnownPublisher = FALSE;
        cchPublisher = wcslen(szPublisher) + 1;
    }
    else
    {
        m_fKnownPublisher = TRUE;
        cchPublisher = wcslen(pwszPublisher) + 1;
    }

    //
    // Fill in the publisher member by converting from UNICODE to MBS
    // or by copying the unknown publisher string
    //

    m_pszPublisher = new WCHAR[cchPublisher];

    if ( m_pszPublisher != NULL )
    {
        if ( m_fKnownPublisher == FALSE )
        {
            wcscpy(m_pszPublisher, szPublisher);
        }
        else 
        {
            wcscpy(m_pszPublisher, pwszPublisher);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pwszPublisher != NULL )
    {
        delete[] pwszPublisher;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitPublisherCertIssuer, private
//
//  Synopsis:   Initialize m_pszPublisherCertIssuer
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitPublisherCertIssuer ()
{
    HRESULT hr = S_OK;
    ULONG   cchCertIssuer;
    LPWSTR  pwszCertIssuer = NULL;
    WCHAR   szCertIssuer[MAX_LOADSTRING_BUFFER];
    BOOL    fKnownCertIssuer;

    //
    // Load the unknown cert issuer string
    //

    if ( LoadStringU(
             g_hModule,
             IDS_UNKNOWNPUBLISHERCERTISSUER,
             szCertIssuer,
             MAX_LOADSTRING_BUFFER
             ) == 0 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // Since the publisher cert issuer is the issuer of the signer certificate,
    // we try to find the name in the RDN attributes of the cert issuer
    //

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {
            cchCertIssuer = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL,
                                                NULL, 0);

            if (cchCertIssuer > 1)
            {
                pwszCertIssuer = new WCHAR[cchCertIssuer];
                if ( pwszCertIssuer == NULL)
                {
                    return (E_OUTOFMEMORY);
                }
                cchCertIssuer = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL,
                                                   pwszCertIssuer, cchCertIssuer);
            }
        }
    }

    //
    // If we still don't have a name, we set the unknown issuer string
    //

    if ( pwszCertIssuer == NULL )
    {
        fKnownCertIssuer = FALSE;
        cchCertIssuer = wcslen(szCertIssuer) + 1;
    }
    else
    {
        fKnownCertIssuer = TRUE;
        cchCertIssuer = wcslen(pwszCertIssuer) + 1;
    }

    //
    // Fill in the publisher cert issuer member by converting from UNICODE
    // to MBS or by copying the unknown issuer string
    //

    m_pszPublisherCertIssuer = new WCHAR[cchCertIssuer];

    if ( m_pszPublisherCertIssuer != NULL )
    {
        if ( fKnownCertIssuer == FALSE )
        {
            wcscpy(m_pszPublisherCertIssuer, szCertIssuer);
        }
        else
        {
            wcscpy(m_pszPublisherCertIssuer, pwszCertIssuer);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pwszCertIssuer != NULL )
    {
        delete[] pwszCertIssuer;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitErrorStatement, private
//
//  Synopsis:   Initialize m_pszErrorStatement
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitErrorStatement ()
{
    return( ACUIMapErrorToString(
                        m_pInvokeInfo->hrInvokeReason,
                        &m_pszErrorStatement
                        ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitCertTimestamp, public
//
//  Synopsis:   initialize the certificate timestamp string
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitCertTimestamp ()
{
    HRESULT    hr = S_OK;
    WCHAR      szCertTimestamp[MAX_LOADSTRING_BUFFER];
    FILETIME   ftTimestamp;
    SYSTEMTIME stTimestamp;


    //
    // Get the time stamp
    //

    // TBDTBD: change to a loop!!!! pberkman

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_SGNR     *pTimeSgnr;

    if ((pTimeSgnr =
            WTHelperGetProvSignerFromChain(ProviderData(), 0, TRUE, 0)) &&
        (pTimeSgnr->dwSignerType & SGNR_TYPE_TIMESTAMP) &&
        (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0)))
    {
        // convert UTC to local
        FileTimeToLocalFileTime(&pSgnr->sftVerifyAsOf, &ftTimestamp);

        // make it system format
        FileTimeToSystemTime(&ftTimestamp, &stTimestamp);

        m_pszCertTimestamp = GetFormattedCertTimestamp(&stTimestamp);

        if ( m_pszCertTimestamp == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        m_pszCertTimestamp = NULL;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitCertViewPropertiesEntryPoint, public
//
//  Synopsis:   initialize the cert view properties entry point
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CInvokeInfoHelper::InitCertViewPropertiesEntryPoint ()
{
    m_hModCVPA = LoadLibraryA(CVP_DLL);

    if ( m_hModCVPA != NULL )
    {
        m_pfnCVPA = (pfnCertViewProperties)GetProcAddress(m_hModCVPA, CVP_FUNC_NAME);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::GetFormattedCertTimestamp, public
//
//  Synopsis:   gets the formatted cert timestamp string which will be
//              allocated using the new operator
//
//----------------------------------------------------------------------------
LPWSTR
CInvokeInfoHelper::GetFormattedCertTimestamp (LPSYSTEMTIME pst)
{
    LPWSTR  psz;
    int     cDate;
    int     cTime;

    if ( ( cDate = GetDateFormatU(
                          LOCALE_USER_DEFAULT,
                          DATE_SHORTDATE,
                          pst,
                          NULL,
                          NULL,
                          0
                          ) ) == 0 )
    {
        return( NULL );
    }

    cDate--;

    if ( ( cTime = GetTimeFormatU(
                          LOCALE_USER_DEFAULT,
                          TIME_NOSECONDS,
                          pst,
                          NULL,
                          NULL,
                          0
                          ) ) == 0 )
    {
        return( NULL );
    }

    cTime--;

    psz = new WCHAR [ cDate + cTime + 2 ];
    if ( psz == NULL )
    {
        return( NULL );
    }

    if ( GetDateFormatU(
                LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                pst,
                NULL,
                psz,
                cDate + 1
                ) == 0 )
    {
        delete[] psz;
        return( NULL );
    }

    psz[cDate] = L' ';

    if ( GetTimeFormatU(
                LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                pst,
                NULL,
                &psz[cDate+1],
                cTime + 1
                ) == 0 )
    {
        delete[] psz;
        return( NULL );
    }

    return( psz );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::IsTestCertInChain, public
//
//  Synopsis:   is there a test cert in the publisher's chain
//
//----------------------------------------------------------------------------
BOOL
CInvokeInfoHelper::IsTestCertInPublisherChain ()
{
    ULONG cCount;

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        for (cCount = 0; cCount < pSgnr->csCertChain; cCount++)
        {
            if (pCert = WTHelperGetProvCertFromChain(pSgnr, cCount))
            {
                if (pCert->fTestCert)
                {
                    return(TRUE);
                }
            }
        }
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMapErrorToString
//
//  Synopsis:   maps error to string
//
//  Arguments:  [hr]   -- error
//              [ppsz] -- error string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT ACUIMapErrorToString (HRESULT hr, LPWSTR* ppsz)
{
    UINT  ResourceId = 0;
    WCHAR psz[MAX_LOADSTRING_BUFFER];

    //
    // See if it maps to some non system error code
    //

    switch (hr)
    {

        case TRUST_E_SYSTEM_ERROR:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_INVALID_PARAMETER:
            //
            //  leave the resourceid zero...  these will be mapped to
            //  IDS_SPC_UNKNOWN and the error code displayed.
            //
            break;

        case CRYPT_E_FILE_ERROR:
            ResourceId = IDS_FILE_NOT_FOUND;
            break;

        case TRUST_E_PROVIDER_UNKNOWN:
            ResourceId = IDS_SPC_PROVIDER;
            break;

        case TRUST_E_SUBJECT_FORM_UNKNOWN:
            ResourceId = IDS_SPC_SUBJECT;
            break;

        case TRUST_E_NOSIGNATURE:
            ResourceId = IDS_SPC_NO_SIGNATURE;
            break;

        case CRYPT_E_BAD_MSG:
            ResourceId = IDS_SPC_BAD_SIGNATURE;
            break;

        case TRUST_E_BAD_DIGEST:
            ResourceId = IDS_SPC_BAD_FILE_DIGEST;
            break;

        case CRYPT_E_NO_SIGNER:
            ResourceId = IDS_SPC_NO_VALID_SIGNER;
            break;

        case TRUST_E_NO_SIGNER_CERT:
            ResourceId = IDS_SPC_SIGNER_CERT;
            break;

        case TRUST_E_COUNTER_SIGNER:
            ResourceId = IDS_SPC_VALID_COUNTERSIGNER;
            break;

        case CERT_E_EXPIRED:
            ResourceId = IDS_SPC_CERT_EXPIRED;
            break;

        case TRUST_E_CERT_SIGNATURE:
            ResourceId = IDS_SPC_CERT_SIGNATURE;
            break;

        case CERT_E_CHAINING:
            ResourceId = IDS_SPC_CHAINING;
            break;

        case CERT_E_UNTRUSTEDROOT:
            ResourceId = IDS_SPC_UNTRUSTED_ROOT;
            break;

        case CERT_E_UNTRUSTEDTESTROOT:
            ResourceId = IDS_SPC_UNTRUSTED_TEST_ROOT;
            break;

        case CERT_E_VALIDITYPERIODNESTING:
            ResourceId = IDS_SPC_INVALID_CERT_NESTING;
            break;

        case CERT_E_PURPOSE:
            ResourceId = IDS_SPC_INVALID_PURPOSE;
            break;

        case TRUST_E_BASIC_CONSTRAINTS:
            ResourceId = IDS_SPC_INVALID_BASIC_CONSTRAINTS;
            break;

        case TRUST_E_FINANCIAL_CRITERIA:
            ResourceId = IDS_SPC_INVALID_FINANCIAL;
            break;

        case TRUST_E_TIME_STAMP:
            ResourceId = IDS_SPC_TIMESTAMP;
            break;

        case CERT_E_REVOKED:
            ResourceId = IDS_SPC_CERT_REVOKED;
            break;

        case CERT_E_REVOCATION_FAILURE:
            ResourceId = IDS_SPC_REVOCATION_ERROR;
            break;

        case CRYPT_E_SECURITY_SETTINGS:
            ResourceId = IDS_SPC_SECURITY_SETTINGS;
            break;

        case CERT_E_MALFORMED:
            ResourceId = IDS_SPC_INVALID_EXTENSION;
            break;

        case CERT_E_WRONG_USAGE:
            ResourceId = IDS_WRONG_USAGE;
            break;
    }

    //
    // If it does, load the string out of our resource string tables and
    // return that. Otherwise, try to format the message from the system
    //
    
    DWORD_PTR MessageArgument;
    CHAR  szError[13]; // for good luck
    WCHAR  wszError[13]; // for good luck
    LPVOID  pvMsg;

    pvMsg = NULL;

    if ( ResourceId != 0 )
    {
        if ( LoadStringU(
                 g_hModule,
                 ResourceId,
                 psz,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }

        *ppsz = new WCHAR[wcslen(psz) + 1];

        if ( *ppsz != NULL )
        {
            wcscpy(*ppsz, psz);
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else if ( ( hr >= 0x80093000 ) && ( hr <= 0x80093999 ) )
    {
        if ( LoadStringU(
                 g_hModule,
                 IDS_SPC_OSS_ERROR,
                 psz,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }

        sprintf(szError, "%lx", hr);
        MultiByteToWideChar(0, 0, szError, -1, &wszError[0], 13);
        MessageArgument = (DWORD_PTR)wszError;

        if ( FormatMessageU(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_STRING |
                   FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   psz,
                   0,
                   0,
                   (LPWSTR)&pvMsg,
                   0,
                   (va_list *)&MessageArgument
                   ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }
    }
    else
    {
        if ( FormatMessageU(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   hr,
                   0,
                   (LPWSTR)&pvMsg,
                   0,
                   NULL
                   ) == 0 )
        {
            if ( LoadStringU(
                    g_hModule,
                    IDS_SPC_UNKNOWN,
                    psz,
                    MAX_LOADSTRING_BUFFER
                    ) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }

            sprintf(szError, "%lx", hr);
            MultiByteToWideChar(0, 0, szError, -1, &wszError[0], 13);
            MessageArgument = (DWORD_PTR)wszError;

            if ( FormatMessageU(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    psz,
                    0,
                    0,
                    (LPWSTR)&pvMsg,
                    0,
                    (va_list *)&MessageArgument
                    ) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }
        }
    }

    if (pvMsg)
    {
        *ppsz = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppsz)
        {
            wcscpy(*ppsz, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\iih.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       iih.h
//
//  Contents:   ACUI Invoke Info Helper class definition
//
//  History:    10-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__IIH_H__)
#define __IIH_H__

#include <acui.h>
#include <acuictl.h>

extern HINSTANCE g_hModule;

//
// CInvokeInfoHelper is used to pull various pieces of information out
// of the ACUI_INVOKE_INFO data structure
//

class CInvokeInfoHelper
{
public:

    //
    // Initialization
    //

    CInvokeInfoHelper (
               PACUI_INVOKE_INFO pInvokeInfo,
               HRESULT&          rhr
               );

    ~CInvokeInfoHelper ();

    //
    // Information Retrieval Methods
    //

    LPCWSTR                  Subject()               { return(m_pszSubject); }
    LPCWSTR                  Publisher()             { return(m_pszPublisher); }
    LPCWSTR                  PublisherCertIssuer()   { return(m_pszPublisherCertIssuer); }
    LPCWSTR                  ControlWebPage()        { return(m_pszControlWebPage); }
    LPCWSTR                  CAWebPage()             { return(m_pszCAWebPage); }
    LPCWSTR                  AdvancedLink()          { return(m_pszAdvancedLink); }
    LPCWSTR                  CertTimestamp()         { return(m_pszCertTimestamp); }
    LPCWSTR                  TestCertInChain()       { return(m_pszTestCertInChain); }
    LPCWSTR                  ErrorStatement()        { return(m_pszErrorStatement); }

    PCRYPT_PROVIDER_DATA    ProviderData()          { return(m_pInvokeInfo->pProvData); }

    BOOL                    IsKnownPublisher()      { return(m_fKnownPublisher); }

    BOOL                    IsCertViewPropertiesAvailable() { return(m_pfnCVPA != NULL); }

    //
    // Personal Trust management
    //

    HRESULT AddPublisherToPersonalTrust ();

    //
    // UI control management
    //

    HRESULT GetUIControl (IACUIControl** ppUI);
    VOID ReleaseUIControl (IACUIControl* pUI);

    inline BOOL CallCertViewProperties (HWND hwndParent);
    inline VOID CallAdvancedLink (HWND hwndParent);
    inline VOID CallWebLink(HWND hwndParent, WCHAR *pszLink);

private:

    //
    // Invoke Info holder
    //

    PACUI_INVOKE_INFO      m_pInvokeInfo;

    //
    // Subject, Publisher, Issuer and Error Statement strings
    //

    LPWSTR                  m_pszSubject;
    LPWSTR                  m_pszPublisher;
    LPWSTR                  m_pszPublisherCertIssuer;
    LPWSTR                  m_pszErrorStatement;
    LPWSTR                  m_pszCertTimestamp;
    LPWSTR                  m_pszAdvancedLink;
    LPWSTR                  m_pszTestCertInChain;
    LPWSTR                  m_pszControlWebPage;
    LPWSTR                  m_pszCAWebPage;

    //
    // Known publisher flag
    //

    BOOL                   m_fKnownPublisher;

    //
    // Cert view properties entry point
    //

    HINSTANCE              m_hModCVPA;
    pfnCertViewProperties  m_pfnCVPA;

    //
    // Private methods
    //

    HRESULT InitSubject();
    HRESULT InitPublisher();
    HRESULT InitPublisherCertIssuer();
    HRESULT InitErrorStatement();
    HRESULT InitCertTimestamp();
    VOID    InitCertViewPropertiesEntryPoint();
    LPWSTR  GetFormattedCertTimestamp(LPSYSTEMTIME pst);
    BOOL    IsTestCertInPublisherChain();
    VOID    InitAdvancedLink();
    VOID    InitTestCertInChain();
    VOID    InitControlWebPage();
    VOID    InitCAWebPage();
};

//
// Error mapping helper
//

HRESULT ACUIMapErrorToString (HRESULT hr, LPWSTR* ppsz);

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::CallCertViewProperties, public
//
//  Synopsis:   calls the cert view properties entry point
//
//  Arguments:  [hwndParent] -- parent window handle
//
//  Returns:    Result of CertViewPropertiesW call
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL
CInvokeInfoHelper::CallCertViewProperties (HWND hwndParent)
{
    CRYPT_PROVIDER_SGNR             *pSgnr;
    CRYPT_PROVIDER_CERT             *pCert;

    //
    // Setup the common dialog call structure
    //

    CVP_STRUCTDEF                   cvsa;

    memset(&cvsa, 0, sizeof(CVP_STRUCTDEF));

    cvsa.dwSize                             = sizeof(CVP_STRUCTDEF);
    cvsa.hwndParent                         = hwndParent;

#   if (USE_IEv4CRYPT32)
        cvsa.hInstance                          = g_hModule;
#   else
        cvsa.pCryptProviderData                 = ProviderData();
        cvsa.fpCryptProviderDataTrustedUsage    = (m_pInvokeInfo->hrInvokeReason == ERROR_SUCCESS) ? TRUE : FALSE;
#   endif

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {
            cvsa.pCertContext = pCert->pCert;
        }
    }

    //
    // Bring up the dialog
    //
#   if (USE_IEv4CRYPT32)
        (*m_pfnCVPA)(&cvsa);
#   else
        (*m_pfnCVPA)(&cvsa, NULL);  // TBDTBD: &fRefresh: show dialog
#   endif

    return( TRUE );
}

inline VOID
CInvokeInfoHelper::CallAdvancedLink (HWND hwndParent)
{
    if ((ProviderData()) &&
        (ProviderData()->psPfns->psUIpfns) &&
        (ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        (*ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick)(hwndParent, ProviderData());
    }
}

inline VOID 
CInvokeInfoHelper::CallWebLink(HWND hwndParent, WCHAR *pszLink)
{ 
    TUIGoLink(hwndParent, pszLink); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\pertrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pertrust.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    TCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    TCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
    {
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // Answer whether the indicated certificate is trusted at the 
    // indicated level of the certificate chain.
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    //
    STDMETHOD(IsTrustedCert)(DWORD dwEncoding, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert) PURE;

    //
    // Add the given certificate to the trust data base
    //
    STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Remove the given certificate from the trust data base
    //
    STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPTSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

    };

//
// Creation function for default implementation
//
HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\trustuir.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustuir.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustui.rc
//
#define IDS_ACTIONSIGNED                4000
#define IDS_ACTIONSIGNED_NODATE         4001
#define IDS_ACTIONNOTSIGNED             4002
#define IDS_AUTHENTICITY                4003
#define IDS_CAUTION                     4004
#define IDS_PERSONALTRUST               4005
#define IDS_UNKNOWNPUBLISHER            4006
#define IDS_NOPUBLISHERFOUND            4008
#define IDS_NOAUTHENTICITY              4009
#define IDS_PROBLEMSBELOW               4010
#define IDS_UNKNOWNPUBLISHERCERTISSUER  4011
#define IDS_UNKNOWNDATETIME             4012
#define IDS_TESTCERTINCHAIN             4013
#define IDD_DIALOG1                     4101
#define IDD_DIALOG1_VERIFIED            4101
#define IDB_BITMAP2                     4103
#define IDD_DIALOG2                     4104
#define IDD_DIALOG2_UNVERIFIED          4104
#define IDD_DIALOG3_DOWNLOAD            4105
#define IDD_DIALOG3_NOSIGNATURE         4107
#define IDB_BITMAP1                     4109
#define IDB_BITMAP3                     4111
#define IDC_TUIHAND                     4113
#define IDI_LOCK                        4998
#define IDI_CERT                        4999
#define IDC_CHECK1                      5000
#define IDMORE                          5008
#define IDC_RADIO1                      5009
#define IDC_RADIO2                      5010
#define IDC_INSTALLANDRUN               5011
#define IDC_PUBLISHER                   5012
#define IDC_AUTHENTICITY                5013
#define IDC_CAUTION                     5014
#define IDC_PERSONALTRUST               5015
#define IDC_OPUSINFO                    5016
#define IDC_CAINFO                      5017
#define IDC_PTCHECK                     5020
#define IDC_SEPARATORLINE               5022
#define IDC_VERBMP                      5023
#define IDC_INSTALLANDRUN2              5028
#define IDC_NOPUBLISHERFOUND            5029
#define IDC_NOVERBMP                    5030
#define IDC_ERRORSTATEMENT              5031
#define IDC_PUBLISHER2                  5033
#define IDC_NOAUTHENTICITY              5034
#define IDC_PROBLEMSBELOW               5035
#define IDC_INSTALLANDRUN3              5036
#define IDC_NOVERBMP2                   5037
#define IDC_ADVANCED                    5038
#define IDS_TESTCERTTITLE               5096
#define IDS_SPC_SIGNER_CERT             5097
#define IDS_SPC_TIMESTAMP               5098
#define IDS_SPC_SUBJECT                 5099
#define IDS_SPC_PROVIDER                5100
#define IDS_SPC_VALID_COUNTERSIGNER     5101
#define IDS_SPC_BAD_SIGNATURE           5102
#define IDS_SPC_BAD_FILE_DIGEST         5103
#define IDS_SPC_NO_VALID_SIGNER         5104
#define IDS_SPC_NO_SIGNER_ROOT          5105
#define IDS_SPC_UNTRUSTED_ROOT          5106
#define IDS_SPC_UNTRUSTED_TEST_ROOT     5107
#define IDS_SPC_NO_STATEMENT_TYPE       5108
#define IDS_SPC_NO_COMMERCIAL_TYPE      5109
#define IDS_SPC_INVALID_CERT_NESTING    5110
#define IDS_SPC_INVALID_ISSUER          5111
#define IDS_SPC_INVALID_PURPOSE         5112
#define IDS_SPC_INVALID_BASIC_CONSTRAINTS 5113
#define IDS_SPC_UNSUPPORTED_BASIC_CONSTRAINTS 5114
#define IDS_SPC_INVALID_CERT_TIME       5115
#define IDS_SPC_UNTRUSTED_TIMESTAMP_ROOT 5116
#define IDS_SPC_INVALID_FINANCIAL       5117
#define IDS_SPC_NO_OPUS_INFO            5118
#define IDS_SPC_NO_SIGNATURE            5119
#define IDS_CERT_E_EXPIRED              5120
#define IDS_SPC_CERT_EXPIRED            5121
#define IDS_REVOCATION_OFFLINE          5122
#define IDS_SPC_REVOCATION_OFFLINE      5123
#define IDS_CERT_E_ISSUERCHAINING       5124
#define IDS_CERT_E_REVOKED              5125
#define IDS_SPC_CERT_REVOKED            5126
#define IDS_SPC_OSS_ERROR               5127
#define IDS_SPC_UNKNOWN                 5128
#define IDS_SPC_INVALID_EXTENSION       5129
#define IDS_SPC_UNEXPECTED              5130
#define IDS_CERT_E_CHAINING             5131
#define IDS_SPC_CHAINING                5132
#define IDS_SPC_CERT_SIGNATURE          5133
#define IDS_SPC_REVOCATION_ERROR        5134
#define IDS_SPC_UNTRUSTED               5135
#define IDS_SPC_SAFETY_LEVEL_UNTRUSTED  5136
#define IDS_SPC_UNKNOWN_SIGNER_ROOT     5137
#define IDS_FILE_NOT_FOUND              5138
#define IDS_SPC_SECSET_INVV1            5139
#define IDS_SPC_SECURITY_SETTINGS       5140
#define IDS_WRONG_USAGE                 5143
#define IDS_CLICKHEREFORCERT            5501
#define IDS_CLICKHEREFOROPUSINFO        5502
#define IDS_CLICKHEREFORCAINFO          5503
#define IDS_CLICKHEREFORADVANCED        5504
#define IDS_COPYACTION_DEFAULT          5505
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\stdpch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       stdpch.h
//
//  Contents:   Precompiled Header stuff
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__STDPCH_H__)
#define __STDPCH_H__

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <prsht.h>
#include <richedit.h>
#include <commctrl.h>

#include "wincrypt.h"
#include "wintrust.h"
#include "wintrustp.h"
#include "mssip.h"      // def for spc_link..

#include "gendefs.h"
#include "util.h"
#include "acui.h"
#include "iih.h"
#include "pertrust.h"
#include "acuictl.h"
#include "trustuir.h"
#include "unicode.h"
#include "internal.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       util.h
//
//  Contents:   Utility functions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__UTIL_H__)
#define __UTIL_H__

//
// The following help us retrieve the publisher and publisher cert issuer
// names out of the cert context.  They are stolen from SOFTPUB.  Note
// that the returned strings must be CoTaskMemFree'd
//

extern void TUIGoLink(HWND hParent, WCHAR *pszWhere);
extern WCHAR *GetGoLink(SPC_LINK *psLink);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\ver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ver.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by signed.rc
//
#define VER_OLESELFREGISTER             0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\trustui\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       util.cpp
//
//  Contents:   Miscellaneous utility functions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include <urlmon.h>
#include <hlink.h>

#include    "unicode.h"

//
// The following are stolen from SOFTPUB
//
void TUIGoLink(HWND hwndParent, WCHAR *pszWhere)
{
    HCURSOR hcursPrev;
    HMODULE hURLMon;


    //
    //  since we're a model dialog box, we want to go behind IE once it comes up!!!
    //
    SetWindowPos(hwndParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

    hcursPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hURLMon = (HMODULE)LoadLibraryU(L"urlmon.dll");

    if (!(hURLMon))
    {
        //
        // The hyperlink module is unavailable, go to fallback plan
        //
        //
        // This works in test cases, but causes deadlock problems when used from withing
        // the Internet Explorer itself. The dialog box is up (that is, IE is in a modal
        // dialog loop) and in comes this DDE request...).
        //
        DWORD   cb;
        LPSTR   psz;

        cb = WideCharToMultiByte(
                        0, 
                        0, 
                        pszWhere, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (psz = new char[cb]))
            {
                return;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        pszWhere, 
                        -1,
                        psz, 
                        cb, 
                        NULL, 
                        NULL);

        ShellExecute(hwndParent, "open", psz, NULL, NULL, SW_SHOWNORMAL);

        delete[] psz;
    } 
    else 
    {
        //
        // The hyperlink module is there. Use it
        //
        if (SUCCEEDED(CoInitialize(NULL)))       // Init OLE if no one else has
        {
            //
            //  allow com to fully init...
            //
            MSG     msg;

            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE); // peek but not remove

            typedef void (WINAPI *pfnHlinkSimpleNavigateToString)(LPCWSTR, LPCWSTR, LPCWSTR, IUnknown *,
                                                                  IBindCtx *, IBindStatusCallback *,
                                                                  DWORD, DWORD);

            pfnHlinkSimpleNavigateToString      pProcAddr;

            pProcAddr = (pfnHlinkSimpleNavigateToString)GetProcAddress(hURLMon, TEXT("HlinkSimpleNavigateToString"));

            if (pProcAddr)
            {
                IBindCtx    *pbc;  

                pbc = NULL;

                CreateBindCtx( 0, &pbc ); 

                (*pProcAddr)(pszWhere, NULL, NULL, NULL, pbc, NULL, HLNF_OPENINNEWWINDOW, NULL);

                if (pbc)
                {
                    pbc->Release();
                }
            }
        
            CoUninitialize();
        }

        FreeLibrary(hURLMon);
    }

    SetCursor(hcursPrev);
}

WCHAR *GetGoLink(SPC_LINK *psLink)
{
    if (!(psLink))
    {
        return(NULL);
    }

    switch (psLink->dwLinkChoice)
    {
        case SPC_URL_LINK_CHOICE:       return(psLink->pwszUrl);
        case SPC_FILE_LINK_CHOICE:      return(psLink->pwszFile);
        case SPC_MONIKER_LINK_CHOICE:   return(NULL); // TBDTBD!!!
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\utils\stripqts\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by STRIPQTS.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\utils\prs\prsparse\prsparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       prsparse.cpp
//
//  Contents:   Microsoft Internet Security Internal Utility
//
//  Functions:  main
//
//              *** local functions ***
//              GetLine
//              EOLOut
//              ReformatLine
//              ParseAndReformatLine2
//              AddDefaultsForLine2
//              AddPRSNumber
//
//  History:    20-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h> 

#define MAX_PRS_LINE        1024
#define PRS_LINE1_NUMPARAMS 4
#define PRS_FILE            "PRS.TXT"

DWORD   GetLine(HANDLE hFile, char *pszBuf, DWORD cbMaxRead);
void    EOLOut(char *psz, DWORD ccLen);
void    ReformatLine(char *pszIn, char *pszOut, DWORD cbMax);
void    ParseAndReformatLine2(char *pszIn, char *pszOut, DWORD cbMax);
void    AddDefaultsForLine2(char *pszOut, DWORD cbMax);
void    AddPRSNumber(char *pszOut, DWORD cbMax);

HANDLE  hPRSFile;

extern "C" int __cdecl main(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("\nUsage: %s infile outfile\n", argv[0]);
        return(0);
    }

    HANDLE  hFileIn;
    HANDLE  hFileOut;
    char    szBufIn[MAX_PRS_LINE];
    char    szBufOut[MAX_PRS_LINE];
    char    *psz;
    DWORD   cbWritten;

    if ((hFileIn = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        return(0);
    }

    if ((hFileOut = CreateFile(argv[2], GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFileIn);
        return(0);
    }

    strcpy(&szBufIn[0], argv[1]);

    if (psz = strrchr(&szBufIn[0], '\\'))
    {
        psz++;
    }
    else if (psz = strrchr(&szBufIn[0], ':'))
    {
        psz++;
    }
    else
    {
        psz = &szBufIn[0];
    }

    strcpy(psz, PRS_FILE);

    hPRSFile = CreateFile(&szBufIn[0], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, NULL);

    szBufOut[0] = NULL;

    while (GetLine(hFileIn, &szBufIn[0], MAX_PRS_LINE) > 0)
    {
        EOLOut(&szBufIn[0], strlen(&szBufIn[0]) + 4);

        if ((szBufOut[0]) && (szBufIn[0] == '-'))
        {
            //
            //  line continues...  the second line needs to be parsed...
            //
            ParseAndReformatLine2(&szBufIn[0], &szBufOut[0], MAX_PRS_LINE);
        }
        else if (szBufOut[0])
        {
            AddDefaultsForLine2(&szBufOut[0], MAX_PRS_LINE);
        }

        if (szBufOut[0])
        {
            cbWritten = 0;
            WriteFile(hFileOut, &szBufOut[0], strlen(&szBufOut[0]), &cbWritten, NULL);

            szBufOut[0] = NULL;

            continue;
        }

        if ((szBufIn[0] == ';') || (szBufIn[0] == '#') || !(szBufIn[0]) || (szBufIn[0] == ' '))
        {
            continue;
        }

        ReformatLine(&szBufIn[0], &szBufOut[0], MAX_PRS_LINE);
    }

    CloseHandle(hFileIn);
    CloseHandle(hFileOut);
    
    if (hPRSFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPRSFile);
    }
    
    return(1);
}

void ReformatLine(char *pszIn, char *pszOut, DWORD cbMax)
{
    int idxIn;
    int idxOut;
    int len;
    int params;

    params      = 1;
    idxOut      = 0;
    pszOut[0]   = NULL;

    len = strlen(pszIn);

    if (len > 0)
    {
        pszOut[idxOut++] = '\"';
        pszOut[idxOut]   = NULL;
    }

    for (idxIn = 0; idxIn < len; idxIn++)
    {
        if (pszIn[idxIn] == ',') 
        {
            if (pszIn[idxIn - 1] != '\"')
            {
                pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }
         
            pszOut[idxOut++] = ',';
            pszOut[idxOut]   = NULL;

            if (pszIn[idxIn + 1] != '\"')
            {
               pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }

            params++;
        }
        else
        {
            pszOut[idxOut++] = pszIn[idxIn];
        }
    }

    if (params < PRS_LINE1_NUMPARAMS)
    {
        for (idxIn = params; idxIn < PRS_LINE1_NUMPARAMS; idxIn++)
        {
            pszOut[idxOut++] = ',';
            pszOut[idxOut++] = '\"';
            pszOut[idxOut++] = '\"';
        }
    }

    if (len > 0)
    {
        if (pszOut[idxOut - 1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }
        pszOut[idxOut]   = NULL;
    }
}

void ParseAndReformatLine2(char *pszIn, char *pszOut, DWORD cbMax)
{
    int idxIn;
    int idxOut;
    int len;
    int params;

    params          = PRS_LINE1_NUMPARAMS;
    idxOut          = strlen(pszOut);
    pszOut[idxOut]  = NULL;

    len = strlen(pszIn);

    if (len > 0)
    {
        pszOut[idxOut++] = ',';

        if (pszIn[1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }

        pszOut[idxOut]   = NULL;
    }

    for (idxIn = 1; idxIn < len; idxIn++)   // idxIn = 1: pass over '-'
    {
        if (pszIn[idxIn] == ',') 
        {
            if (pszIn[idxIn - 1] != '\"')
            {
                pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }
         
            pszOut[idxOut++] = ',';
            pszOut[idxOut]   = NULL;

            if (pszIn[idxIn + 1] != '\"')
            {
               pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }

            params++;
        }
        else
        {
            pszOut[idxOut++] = pszIn[idxIn];
        }
    }

    if (len > 0)
    {
        if (pszIn[idxIn - 1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }
        pszOut[idxOut]   = NULL;
    }
    
    AddPRSNumber(pszOut, cbMax);

    strcat(pszOut, "\r\n");
}

void AddDefaultsForLine2(char *pszOut, DWORD cbMax)
{
    strcat(&pszOut[0], ",\"PN:\",\"SET:\",\"VN:\",\"MV:\"");

    AddPRSNumber(pszOut, cbMax);

    strcat(pszOut, "\r\n");
}

void AddPRSNumber(char *pszOut, DWORD cbMax)
{
    if (hPRSFile != INVALID_HANDLE_VALUE)
    {
        char    szRead[MAX_PATH];

        while (GetLine(hPRSFile, &szRead[0], MAX_PATH) > 0)
        {
            EOLOut(&szRead[0], strlen(&szRead[0]) + 4);

            if ((szRead[0] == ';') || (szRead[0] == '#') || !(szRead[0]) || (szRead[0] == ' '))
            {
                continue;
            }

            strcat(pszOut, ",\"JOBNO:");
            strcat(pszOut, &szRead[0]);
            strcat(pszOut, "\"");

            break;
        }
    }
}

DWORD GetLine(HANDLE hFile, char *pszBuf, DWORD cbMaxRead)
{
	DWORD   dwHold;
	DWORD   cbRead;
	DWORD   dw;
    int     iAmt;

    pszBuf[0] = NULL;

    if ((dwHold = SetFilePointer(hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(hFile, pszBuf, cbMaxRead, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            return(0);
        }

        pszBuf[cbRead] = 0x00;

        if (cbRead > 0)
        {
            iAmt = 0;
		    for (dw = 0; dw < (cbRead - 1); dw++)
		    {
		    	if ((pszBuf[dw] == 0x0d) || 
                    (pszBuf[dw] == 0x0a))
		    	{
                    iAmt++;
		    		if (pszBuf[dw + 1] == 0x0a)
		    		{
                        dw++;
                        iAmt++;
		    		}
            
                    SetFilePointer(hFile, dwHold + (dw + 1), NULL, FILE_BEGIN);
            
		    		pszBuf[dw + 1] = 0x00;
            
		    		return(cbRead + 1);
		    	}
		    }
        }
	}
	else
	{
		return(0);
	}

	if (pszBuf[cbRead - 1] == 0x1a)  /* EOF */
	{
		cbRead--;
	}

	return(cbRead);
}

void EOLOut(char *psz, DWORD ccLen)
{
	DWORD   i;

	for (i = 0; i < ccLen; i++)
	{
		if ((psz[i] == 0x0a) || (psz[i] == 0x0d))
		{
			psz[i] = NULL;
			return;
		}
	}
	psz[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\catcache.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catcache.cpp
//
//  Contents:   Implementation of Catalog Cache (see catcache.h for details)
//
//  History:    26-May-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::Initialize, public
//
//  Synopsis:   initialize the cache
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::Initialize ()
{
    LRU_CACHE_CONFIG Config;

    __try
    {
        InitializeCriticalSection( &m_Lock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ( FALSE );
    }
    
    memset( &Config, 0, sizeof( Config ) );

    m_hCache = NULL;
    Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    Config.pfnFree = CatalogCacheFreeEntryData;
    Config.pfnHash = CatalogCacheHashIdentifier;
    Config.cBuckets = DEFAULT_CATALOG_CACHE_BUCKETS;
    Config.MaxEntries = DEFAULT_CATALOG_CACHE_MAX_ENTRIES;

    return( I_CryptCreateLruCache( &Config, &m_hCache ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::Uninitialize, public
//
//  Synopsis:   uninitialize the cache
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::Uninitialize ()
{
    if ( m_hCache != NULL )
    {
        I_CryptFreeLruCache( m_hCache, 0, NULL );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::IsCacheableWintrustCall, public
//
//  Synopsis:   is this a cacheable call
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::IsCacheableWintrustCall (WINTRUST_DATA* pWintrustData)
{
    if ( pWintrustData->dwUnionChoice != WTD_CHOICE_CATALOG )
    {
        return( FALSE );
    }

    if ( _ISINSTRUCT( WINTRUST_DATA, pWintrustData->cbStruct, hWVTStateData ) )
    {
        if ( ( pWintrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE ) ||
             ( pWintrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE_FLUSH ) )
        {
            return( TRUE );
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::AdjustWintrustDataToCachedState, public
//
//  Synopsis:   adjust the wintrust data structure
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::AdjustWintrustDataToCachedState (
                     WINTRUST_DATA* pWintrustData,
                     PCATALOG_CACHED_STATE pCachedState,
                     BOOL fUndoAdjustment
                     )
{
    PCRYPT_PROVIDER_DATA pProvData;

    if ( fUndoAdjustment == FALSE )
    {
        pWintrustData->dwStateAction = WTD_STATEACTION_VERIFY;

        if ( pCachedState != NULL )
        {
            pWintrustData->hWVTStateData = pCachedState->hStateData;

            pProvData = WTHelperProvDataFromStateData( pCachedState->hStateData );
            pProvData->pWintrustData = pWintrustData;
        }
        else
        {
            pWintrustData->hWVTStateData = NULL;
        }
    }
    else
    {
        if ( pCachedState != NULL )
        {
            pProvData = WTHelperProvDataFromStateData( pCachedState->hStateData );
            pProvData->pWintrustData = NULL;
        }

        pWintrustData->dwStateAction = WTD_STATEACTION_AUTO_CACHE;
        pWintrustData->hWVTStateData = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::CreateCachedStateFromWintrustData, public
//
//  Synopsis:   create cached state
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::CreateCachedStateFromWintrustData (
                     WINTRUST_DATA* pWintrustData,
                     PCATALOG_CACHED_STATE* ppCachedState
                     )
{
    BOOL                  fResult;
    PCATALOG_CACHED_STATE pCachedState;
    CRYPT_DATA_BLOB       Identifier;

    PCRYPT_PROVIDER_DATA  pProvData;

    if ( pWintrustData->hWVTStateData == NULL )
    {
        return( FALSE );
    }

    pProvData = WTHelperProvDataFromStateData( pWintrustData->hWVTStateData );

    if ( ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_INITPROV ] != ERROR_SUCCESS ) ||
         ( ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_OBJPROV ] != ERROR_SUCCESS ) &&
           ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_OBJPROV ] != TRUST_E_BAD_DIGEST ) ) ||
         ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_SIGPROV ] != ERROR_SUCCESS ) ||
         ( pProvData->hMsg == NULL ) )
    {
        return( FALSE );
    }

    assert( pProvData->hMsg != NULL );

    pCachedState = new CATALOG_CACHED_STATE;
    if ( pCachedState != NULL )
    {
        pCachedState->hStateData = pWintrustData->hWVTStateData;
        pCachedState->hEntry = NULL;

        Identifier.cbData = wcslen(
                               pWintrustData->pCatalog->pcwszCatalogFilePath
                               );

        Identifier.cbData *= sizeof( WCHAR );

        Identifier.pbData = (LPBYTE)pWintrustData->pCatalog->pcwszCatalogFilePath;

        fResult = I_CryptCreateLruEntry(
                         m_hCache,
                         &Identifier,
                         pCachedState,
                         &pCachedState->hEntry
                         );
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppCachedState = pCachedState;
    }
    else
    {
        delete pCachedState;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::ReleaseCachedState, public
//
//  Synopsis:   release the cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::ReleaseCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    if ( pCachedState == NULL )
    {
        return;
    }

    I_CryptReleaseLruEntry( pCachedState->hEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::AddCachedState, public
//
//  Synopsis:   add cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::AddCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    I_CryptInsertLruEntry( pCachedState->hEntry, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::RemoveCachedState, public
//
//  Synopsis:   remove cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::RemoveCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    I_CryptRemoveLruEntry( pCachedState->hEntry, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::RemoveCachedState, public
//
//  Synopsis:   remove cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::RemoveCachedState (WINTRUST_DATA* pWintrustData)
{
    PCATALOG_CACHED_STATE pCachedState;

    pCachedState = FindCachedState( pWintrustData );

    if ( pCachedState != NULL )
    {
        RemoveCachedState( pCachedState );
        ReleaseCachedState( pCachedState );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::FindCachedState, public
//
//  Synopsis:   find cached state, the state is addref'd via the entry
//
//----------------------------------------------------------------------------
PCATALOG_CACHED_STATE
CCatalogCache::FindCachedState (WINTRUST_DATA* pWintrustData)
{
    PCATALOG_CACHED_STATE pCachedState;
    CRYPT_DATA_BLOB       Identifier;
    HLRUENTRY             hEntry;

    Identifier.cbData = wcslen(
                           pWintrustData->pCatalog->pcwszCatalogFilePath
                           );

    Identifier.cbData *= sizeof( WCHAR );

    Identifier.pbData = (LPBYTE)pWintrustData->pCatalog->pcwszCatalogFilePath;

    pCachedState = (PCATALOG_CACHED_STATE)I_CryptFindLruEntryData(
                                                 m_hCache,
                                                 &Identifier,
                                                 &hEntry
                                                 );

    return( pCachedState );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::FlushCache, public
//
//  Synopsis:   flush the cache
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::FlushCache ()
{
    I_CryptFlushLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   CatalogCacheFreeEntryData
//
//  Synopsis:   free entry data
//
//----------------------------------------------------------------------------
VOID WINAPI
CatalogCacheFreeEntryData (LPVOID pvData)
{
    PCATALOG_CACHED_STATE pCachedState = (PCATALOG_CACHED_STATE)pvData;
    WINTRUST_DATA         WintrustData;
    GUID                  ActionGuid;

    memset( &ActionGuid, 0, sizeof( ActionGuid ) );

    memset( &WintrustData, 0, sizeof( WintrustData ) );
    WintrustData.cbStruct = sizeof( WintrustData );
    WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
    WintrustData.hWVTStateData = pCachedState->hStateData;

    WinVerifyTrust( NULL, &ActionGuid, &WintrustData );

    delete pCachedState;
}

//+---------------------------------------------------------------------------
//
//  Function:   CatalogCacheHashIdentifier
//
//  Synopsis:   hash the name
//
//----------------------------------------------------------------------------
DWORD WINAPI
CatalogCacheHashIdentifier (PCRYPT_DATA_BLOB pIdentifier)
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\utils\stripqts\stripqts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       inf2cdf.cpp
//
//  Contents:   conversion utility
//
//  History:    01-Oct-1997 pberkman    created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL    fVerbose = FALSE;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    WCHAR                   wszTFile[MAX_PATH];
    WCHAR                   *pwszCDFFile;
    WCHAR                   *pwsz;
    HANDLE                  hCDFFile;
    HANDLE                  hTFile;
    int                     iRet;

    hCDFFile        = INVALID_HANDLE_VALUE;
    hTFile          = INVALID_HANDLE_VALUE;
    iRet            = 0;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL, (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (pArgs->GetValue(IDS_PARAM_HELP))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose    = (BOOL)((ULONG_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    pwszCDFFile = pArgs->GetFileName();

    if (!(pwszCDFFile))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    wcscpy(&wszTFile[0], pwszCDFFile);

    pwsz = wcschr(&wszTFile[0], L'.');

    if (pwsz)
    {
        wcscpy(pwsz, L".{1}");
    }
    else
    {
        wcscat(&wszTFile[0], L".{1}");
    }

    hCDFFile    = CreateFileU(pwszCDFFile, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, 0, NULL);
    hTFile = CreateFileU(&wszTFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                NULL, CREATE_ALWAYS, 0, NULL);

    if ((hTFile == INVALID_HANDLE_VALUE) || (hCDFFile == INVALID_HANDLE_VALUE))
    {
        goto FileError;
    }

    DWORD       cbRead;
    DWORD       cbWrite;
    DWORD       dwSrc;
    DWORD       dwDest;
    BYTE        bRead[MAX_PATH];

    while ((ReadFile(hCDFFile, &bRead[0], MAX_PATH, &cbRead, NULL)) && (cbRead > 0))
    {
        dwSrc   = 0;
        dwDest  = 0;

        while (dwSrc < cbRead)
        {
            if (bRead[dwSrc] != '\"')
            {
                bRead[dwDest] = (BYTE)tolower(bRead[dwSrc]);
                dwDest++;
            }
            dwSrc++;
        }

        if (dwDest > 0)
        {
            WriteFile(hTFile, &bRead[0], dwDest, &cbWrite, NULL);
        }
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hCDFFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hCDFFile);
        }

        if (hTFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hTFile);

            CopyFileU(&wszTFile[0], pwszCDFFile, FALSE);

            DeleteFileU(&wszTFile[0]);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, FileError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\certhlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certhlp.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WTHelperCertIsSelfSigned
//              WTHelperCertFindIssuerCertificate
//
//              *** local functions ***
//
//  History:    20-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL WINAPI WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert)
{
    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pCert->Issuer,
                                     &pCert->Subject)))
    {
        return(FALSE);
    }

    return(TRUE);
}

PCCERT_CONTEXT WINAPI WTHelperCertFindIssuerCertificate(PCCERT_CONTEXT pChildContext,
                                                        DWORD chStores,
                                                        HCERTSTORE  *pahStores,
                                                        FILETIME *psftVerifyAsOf,
                                                        DWORD dwEncoding,
                                                        DWORD *pdwConfidence,
                                                        DWORD *pdwError)
{
    return(TrustFindIssuerCertificate(pChildContext, dwEncoding, chStores, pahStores, 
                                      psftVerifyAsOf, pdwConfidence, pdwError, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\catcache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catcache.h
//
//  Contents:   Catalog Cache for performance improvement to verification path
//
//  History:    26-May-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CATCACHE_H__)
#define __CATCACHE_H__

//
// This caches state data for catalog member verification indexed by the file
// path to the catalog.  This relieves the caller from having to user the
// icky WTD_STATEACTION* stuff in order to achieve the same ends.  Someday,
// we will just re-design/re-implement the WVT and Catalog stuff and life
// will be good.
//

#include <lrucache.h>

#define DEFAULT_CATALOG_CACHE_BUCKETS     3
#define DEFAULT_CATALOG_CACHE_MAX_ENTRIES 3

typedef struct _CATALOG_CACHED_STATE {

    HANDLE    hStateData;
    HLRUENTRY hEntry;

} CATALOG_CACHED_STATE, *PCATALOG_CACHED_STATE;

class CCatalogCache
{
public:

    //
    // Construction
    //

    inline CCatalogCache ();
    inline ~CCatalogCache ();

    //
    // Initialization
    //

    BOOL Initialize ();
    VOID Uninitialize ();

    //
    // Cache locking
    //

    inline VOID LockCache ();
    inline VOID UnlockCache ();

    //
    // Cached State management
    //

    BOOL IsCacheableWintrustCall (WINTRUST_DATA* pWintrustData);

    VOID AdjustWintrustDataToCachedState (
               WINTRUST_DATA* pWintrustData,
               PCATALOG_CACHED_STATE pCachedState,
               BOOL fUndoAdjustment
               );

    BOOL CreateCachedStateFromWintrustData (
               WINTRUST_DATA* pWintrustData,
               PCATALOG_CACHED_STATE* ppCachedState
               );

    VOID ReleaseCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID AddCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID RemoveCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID RemoveCachedState (WINTRUST_DATA* pWintrustData);
 
    VOID FlushCache ();

    //
    // Cached State lookup
    //

    PCATALOG_CACHED_STATE FindCachedState (WINTRUST_DATA* pWintrustData);

private:

    //
    // Lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // Cache
    //

    HLRUCACHE        m_hCache;
};

//
// Entry data free function
//

VOID WINAPI
CatalogCacheFreeEntryData (LPVOID pvData);

DWORD WINAPI
CatalogCacheHashIdentifier (PCRYPT_DATA_BLOB pIdentifier);

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::CCatalogCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
inline
CCatalogCache::CCatalogCache ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::~CCatalogCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
inline
CCatalogCache::~CCatalogCache ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::LockCache, public
//
//  Synopsis:   lock the cache
//
//----------------------------------------------------------------------------
inline VOID
CCatalogCache::LockCache ()
{
    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::UnlockCache, public
//
//  Synopsis:   unlock the cache
//
//----------------------------------------------------------------------------
inline VOID
CCatalogCache::UnlockCache ()
{
    LeaveCriticalSection( &m_Lock );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "ossfunc.h"

HANDLE      hMeDLL = NULL;

//
//  provider lists
//
LIST_LOCK       sProvLock;

//
//  store lists
//
LIST_LOCK       sStoreLock;
HANDLE          hStoreEvent;

CCatalogCache g_CatalogCache;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

extern BOOL WINAPI WintrustDllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI SoftpubDllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI mssip32DllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI mscat32DllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HANDLE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );

// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
    WintrustDllMain,
    SoftpubDllMain,
    mssip32DllMain,
    mscat32DllMain,
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

STDAPI WintrustDllRegisterServer(void);
STDAPI WintrustDllUnregisterServer(void);
STDAPI SoftpubDllRegisterServer(void);
STDAPI SoftpubDllUnregisterServer(void);
STDAPI mssip32DllRegisterServer(void);
STDAPI mssip32DllUnregisterServer(void);
STDAPI mscat32DllRegisterServer(void);
STDAPI mscat32DllUnregisterServer(void);

typedef HRESULT (STDAPICALLTYPE *PFN_DLL_REGISTER_SERVER) (void);
const PFN_DLL_REGISTER_SERVER rgpfnDllRegisterServer[] = {
    WintrustDllRegisterServer,
    SoftpubDllRegisterServer,
    mssip32DllRegisterServer,
    mscat32DllRegisterServer,
};
#define DLL_REGISTER_SERVER_COUNT   \
    (sizeof(rgpfnDllRegisterServer) / sizeof(rgpfnDllRegisterServer[0]))

typedef HRESULT (STDAPICALLTYPE *PFN_DLL_UNREGISTER_SERVER) (void);
const PFN_DLL_UNREGISTER_SERVER rgpfnDllUnregisterServer[] = {
    WintrustDllUnregisterServer,
    SoftpubDllUnregisterServer,
    mssip32DllUnregisterServer,
    mscat32DllUnregisterServer,
};
#define DLL_UNREGISTER_SERVER_COUNT   \
    (sizeof(rgpfnDllUnregisterServer) / sizeof(rgpfnDllUnregisterServer[0]))


#if DBG
#include <crtdbg.h>

#ifndef _CRTDBG_LEAK_CHECK_DF
#define _CRTDBG_LEAK_CHECK_DF 0x20
#endif

#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */

static int WINAPI DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv("DEBUG_MASK"))
        iDebugFlags = strtol(pszEnvVar, &p, 16);

    return iDebugFlags;
}
#endif

WINAPI
I_IsProcessDetachFreeLibrary(
    LPVOID lpvReserved      // Third parameter passed to DllMain
    )
{
    if (NULL == lpvReserved)
        return TRUE;

#if DBG
    if (DbgGetDebugFlags() & DEBUG_MASK_LEAK_CHECK)
        return TRUE;
#endif
    return FALSE;
}

BOOL WINAPI DllMain(
                HANDLE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i,j;

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:

            //
            // This is to prevent unloading the dlls at process exit
            //
            if (!I_IsProcessDetachFreeLibrary(lpvReserved))
            {
                return TRUE;
            }

            // fall through if not process exit and unload the dlls
        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
            {
                if (!rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved))
                {
                    //
                    // force the dllmain's which already succeeded to clean up
                    //
                    for (j = i-1; j >= 0; j--)
                    {
                        rgpfnDllMain[j](hInstDLL, DLL_PROCESS_DETACH, lpvReserved);
                    }   
                    fReturn = FALSE;
                    break;
                }
                
            }
            break;
    }

    return(fReturn);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < DLL_REGISTER_SERVER_COUNT; i++) {
        HRESULT hr2;

        hr2 = rgpfnDllRegisterServer[i]();
        if (S_OK == hr)
            hr = hr2;
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < DLL_UNREGISTER_SERVER_COUNT; i++) {
        HRESULT hr2;

        hr2 = rgpfnDllUnregisterServer[i]();
        if (S_OK == hr)
            hr = hr2;
    }

    return hr;
}

BOOL WINAPI WintrustDllMain(HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            //
            //  assign me so that further calls to WVT that would load me will just
            //  use this handle....  otherwise, we would deadlock on detatch!
            //
            hMeDLL = hInstDLL;

            DisableThreadLibraryCalls((HINSTANCE)hInstDLL);

            //
            // Initialize critical section to protect lists.
            //
            if (!(InitializeListLock(&sProvLock, DBG_SS_TRUST)))
            {
                return(FALSE);
            }

            if (!(InitializeListLock(&sStoreLock, DBG_SS_TRUST)))
            {
                LockFree(&sProvLock);
                return(FALSE);
            }

            if (!(InitializeListEvent(&hStoreEvent)))
            {
                LockFree(&sProvLock);
                LockFree(&sStoreLock);
                return(FALSE);
            }

            if ( g_CatalogCache.Initialize() == FALSE )
            {
                LockFree(&sProvLock);
                LockFree(&sStoreLock);
                EventFree(hStoreEvent);
                return( FALSE );
            }

            //
            //  we want to open the stores the first time accessed.
            //
            SetListEvent(hStoreEvent);

            break;

        case DLL_PROCESS_DETACH:
            g_CatalogCache.Uninitialize();
            WintrustUnloadProviderList();
            StoreProviderUnload();
            LockFree(&sProvLock);
            LockFree(&sStoreLock);
            EventFree(hStoreEvent);
            break;
    }

    return(ASNDllMain((HINSTANCE)hInstDLL, fdwReason, lpvReserved));
}

STDAPI WintrustDllRegisterServer(void)
{
    //
    //  register our ASN routines
    //
    return(ASNRegisterServer(W_MY_NAME));
}


STDAPI WintrustDllUnregisterServer(void)
{
    return(ASNUnregisterServer());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\memory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       memory.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WVTNew
//              WVTDelete
//              WVTAddStore
//              WVTAddSigner
//              WVTAddCertContext
//              WVTAddPrivateData
//
//  History:    07-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


// PFN_CPD_MEM_ALLOC
void *WVTNew(DWORD cbSize)
{
    void    *pvRet;

    pvRet = (void *)new char[cbSize];

    if (!(pvRet))
    {
        assert(pvRet);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pvRet);
}

// PFN_CPD_MEM_FREE
void WVTDelete(void *pvMem)
{
    DELETE_OBJECT(pvMem);
}

// PFN_CPD_ADD_STORE
BOOL WVTAddStore(CRYPT_PROVIDER_DATA *pProvData, HCERTSTORE hStore)
{
    HCERTSTORE  hStoreDup;

    hStoreDup = CertDuplicateStore(hStore);

    return(AddToStoreChain(hStoreDup, &pProvData->chStores, &pProvData->pahStores));
}

// PFN_CPD_ADD_SGNR
BOOL WVTAddSigner(CRYPT_PROVIDER_DATA *pProvData, 
                  BOOL fCounterSigner,
                  DWORD idxSigner,
                  CRYPT_PROVIDER_SGNR *pSngr2Add)
{
    if (fCounterSigner)
    {
        if (idxSigner > pProvData->csSigners)
        {
            return(FALSE);
        }

        return(AddToSignerChain(pSngr2Add, 
                            &pProvData->pasSigners[idxSigner].csCounterSigners,
                            &pProvData->pasSigners[idxSigner].pasCounterSigners));
    }

    return(AddToSignerChain(pSngr2Add, &pProvData->csSigners, &pProvData->pasSigners));
}

// PFN_CPD_ADD_CERT 
BOOL WVTAddCertContext(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                       BOOL fCounterSigner, DWORD idxCounterSigner, PCCERT_CONTEXT pCert)
{
    CRYPT_PROVIDER_CERT sCert;

    if (idxSigner > pProvData->csSigners)
    {
        return(FALSE);
    }

    memset(&sCert, 0x00, sizeof(CRYPT_PROVIDER_CERT));
    sCert.cbStruct  = sizeof(CRYPT_PROVIDER_CERT);

    sCert.pCert     = CertDuplicateCertificateContext(pCert);

    if (fCounterSigner)
    {
        if (idxCounterSigner > pProvData->pasSigners[idxSigner].csCounterSigners)
        {
            return(FALSE);
        }
        
        return(AddToCertChain(&sCert, 
                &pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner].csCertChain,
                &pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner].pasCertChain));
    }

    return(AddToCertChain(&sCert, 
                          &pProvData->pasSigners[idxSigner].csCertChain,
                          &pProvData->pasSigners[idxSigner].pasCertChain));
}

// PFN_CPD_ADD_PRIVDATA
BOOL  WVTAddPrivateData(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_PRIVDATA *psPrivData2Add)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_PRIVDATA), psPrivData2Add, 
                            &pProvData->csProvPrivData,
                            (void **)&pProvData->pasProvPrivData,
                            psPrivData2Add->cbStruct));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" 
{
#endif



#define     MY_NAME             "WINTRUST.DLL"
#define     W_MY_NAME           L"WINTRUST.DLL"


//
//  dllmain.cpp
//
extern HANDLE       hMeDLL;

extern LIST_LOCK    sProvLock;
extern LIST_LOCK    sStoreLock;

extern HANDLE       hStoreEvent;



//
//  memory.cpp
//
extern void         *WVTNew(DWORD cbSize);
extern void         WVTDelete(void *pvMem);
extern BOOL         WVTAddStore(CRYPT_PROVIDER_DATA *pProvData, HCERTSTORE hStore);
extern BOOL         WVTAddSigner(CRYPT_PROVIDER_DATA *pProvData, 
                                 BOOL fCounterSigner,
                                 DWORD idxSigner,
                                 CRYPT_PROVIDER_SGNR *pSngr2Add);
extern BOOL         WVTAddCertContext(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                      BOOL fCounterSigner, DWORD idxCounterSigner, 
                                      PCCERT_CONTEXT pCert);
extern BOOL         WVTAddPrivateData(CRYPT_PROVIDER_DATA *pProvData, 
                                      CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//
//  registry.cpp
//
extern BOOL         GetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, 
                                   WCHAR *pwszRetDLLName, char *pszRetFuncName);
extern BOOL         SetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, 
                                   WCHAR *pwszDLLName, WCHAR *pwszFuncName);
extern void         GetRegSecuritySettings(DWORD *pdwState);
extern BOOL         RemoveRegProvider(GUID *pgActionID, WCHAR *pwszRegKey);

//
//  chains.cpp
//
extern BOOL         AddToStoreChain(HCERTSTORE hStore2Add, DWORD *pchStores, 
                                    HCERTSTORE **pphStoreChain);
extern BOOL         AddToCertChain(CRYPT_PROVIDER_CERT *pPCert2Add, DWORD *pcPCerts,
                                   CRYPT_PROVIDER_CERT **ppPCertChain);
extern BOOL         AddToSignerChain(CRYPT_PROVIDER_SGNR *psSgnr2Add, DWORD *pcSgnrs, 
                                     CRYPT_PROVIDER_SGNR **ppSgnrChain);

extern void         DeallocateCertChain(DWORD csPCert, CRYPT_PROVIDER_CERT **pasPCertChain);
extern void         DeallocateStoreChain(DWORD csStore, HCERTSTORE *phStoreChain);

extern BOOL         AllocateNewChain(DWORD cbMember, void *pNewMember, DWORD *pcChain, 
                                     void **ppChain, DWORD cbAssumeSize);
extern BOOL         AllocateNewChainWithErrors(DWORD cbMember, void *pNewMember, DWORD *pcChain, 
                                               void **ppChain, DWORD **ppdwErrors);

//
//  provload.cpp
//
extern LOADED_PROVIDER  *WintrustFindProvider(GUID *pgActionID);

//
//  certtrst.cpp
//
extern HRESULT WINAPI WintrustCertificateTrust(CRYPT_PROVIDER_DATA *pProvData);

//
//  wvtver1.cpp
//
extern LONG         Version1_WinVerifyTrust(HWND hwnd, GUID *ActionID, LPVOID ActionData);


//
//  wthelper.cpp
//
extern void *       WTHelperCertAllocAndDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                                     const BYTE *pbEncoded, DWORD cbEncoded,
                                                     DWORD *pcbStructInfo);



#ifdef __cplusplus
}
#endif

#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\chains.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chains.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  AddToSignerChain
//              AddToCertChain
//              AddToStoreChain
//              AllocateNewChain
//              DeallocateCertChain
//              DeallocateStoreChain
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL AddToSignerChain(CRYPT_PROVIDER_SGNR *psSgnr2Add, DWORD *pcSgnrs, CRYPT_PROVIDER_SGNR **ppSgnrChain)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_SGNR), psSgnr2Add, pcSgnrs, (void **)ppSgnrChain,
                            psSgnr2Add->cbStruct));
}

BOOL AddToCertChain(CRYPT_PROVIDER_CERT *pPCert2Add, DWORD *pcPCerts,
                    CRYPT_PROVIDER_CERT **ppPCertChain)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_CERT), pPCert2Add, pcPCerts, (void **)ppPCertChain,
                            pPCert2Add->cbStruct));
}

BOOL AddToStoreChain(HCERTSTORE hStore2Add, DWORD *pcChain, HCERTSTORE **pphStoreChain)
{
    return(AllocateNewChain(sizeof(HCERTSTORE), (void *)&hStore2Add, pcChain, (void **)pphStoreChain,
                            sizeof(HCERTSTORE)));
}


BOOL AllocateNewChain(DWORD cbMember, void *pNewMember, DWORD *pcChain, void **ppChain, DWORD cbAssumeSize)
{
    void        *pNewChain;
    DWORD       cNew;

    if (cbAssumeSize > cbMember)
    {
        //
        //  the client is using structures more current that we are...
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    cNew = *pcChain + 1;

    if (!(pNewChain = (void *)WVTNew(cbMember * cNew)))
    {
        return(FALSE);
    }

    memset(pNewChain, 0x00, cbMember * cNew);

    for (int i = 0; i < (int)*pcChain; i++)
    {
        memcpy((char *)pNewChain + (i * cbMember), (char *)*ppChain + (i * cbMember), cbMember);
    }

    DELETE_OBJECT(*ppChain);

    memcpy((char *)pNewChain + ((cNew - 1) * cbMember), pNewMember, cbAssumeSize);

    *ppChain                = pNewChain;
    *pcChain                = cNew;

    return(TRUE);
}

void DeallocateCertChain(DWORD csPCert, CRYPT_PROVIDER_CERT **pasPCertChain)
{
    CRYPT_PROVIDER_CERT *pas;

    pas = *pasPCertChain;

    for (int i = 0; i < (int)csPCert; i++)
    {
        if (pas[i].pCert)
        {
            CertFreeCertificateContext(pas[i].pCert);
        }

        if (pas[i].pTrustListContext)
        {
            CertFreeCTLContext(pas[i].pTrustListContext);
        }
    }
}

void DeallocateStoreChain(DWORD csStore, HCERTSTORE *pphStoreChain)
{
    for (int i = 0; i < (int)csStore; i++)
    {
        CertCloseStore(pphStoreChain[i], 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\certtrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certtrst.cpp
//
//  Contents:   Microsoft Internet Security Provider
//
//  Functions:  WintrustCertificateTrust
//
//              *** local functions ***
//              _WalkChain
//              _IsLifetimeSigningCert
//
//  History:    07-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

//
//  support for MS test roots!!!!
//
static BYTE rgbTestRoot[] = 
{
#   include "certs\\mstest1.h"
};

static BYTE rgbTestRootCorrected[] = 
{
#   include "certs\\mstest2.h"
};

static BYTE rgbTestRootBeta1[] = 
{
#   include "certs\\mstestb1.h"
};

#define NTESTROOTS  3
static CERT_PUBLIC_KEY_INFO rgTestRootPublicKeyInfo[NTESTROOTS] = 
{
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot),           rgbTestRoot,            0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootCorrected),  rgbTestRootCorrected,   0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootBeta1),      rgbTestRootBeta1,       0}
};



BOOL _WalkChain(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD idxSigner,
    DWORD *pdwError,
    BOOL fCounterSigner,
    DWORD idxCounterSigner,
    BOOL fTimeStamped,
    BOOL *pfLifetimeSigning     // IN OUT, only accessed for fTimeStamped
    );

BOOL WINAPI _IsLifetimeSigningCert(
    PCCERT_CONTEXT pCertContext
    );



HRESULT WINAPI WintrustCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState == TRUE))
    {
        return(S_OK);
    }

    DWORD                   dwError;

    dwError = S_OK;

    if (pProvData->csSigners < 1)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_NOSIGNATURE;
        return(S_FALSE);
    }


    //
    //  loop through all signers
    //
    for (int i = 0; i < (int)pProvData->csSigners; i++)
    {
        BOOL fTimeStamped = FALSE;
        BOOL fLifetimeSigning = FALSE;

        if (pProvData->pasSigners[i].csCertChain < 1)
        {
            pProvData->pasSigners[i].dwError = TRUST_E_NO_SIGNER_CERT;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_NO_SIGNER_CERT;
            continue;
        }

        // Check if timestamped.
        if (0 < pProvData->pasSigners[i].csCounterSigners &&
                (pProvData->pasSigners[i].pasCounterSigners[0].dwSignerType &
                     SGNR_TYPE_TIMESTAMP))
        {
            fTimeStamped = TRUE;

            // See if LifeTime Signing has been enabled
            if (pProvData->dwProvFlags & WTD_LIFETIME_SIGNING_FLAG)
            {
                fLifetimeSigning = TRUE;
            }
            else
            {
                // Check if the signer certificate has the LIFETIME_SIGNING
                // EKU.
                fLifetimeSigning = _IsLifetimeSigningCert(
                    pProvData->pasSigners[i].pasCertChain[0].pCert);
            }
        }

        _WalkChain(pProvData, i, &dwError, FALSE, 0,
            fTimeStamped, &fLifetimeSigning);

        for (int i2 = 0; i2 < (int)pProvData->pasSigners[i].csCounterSigners; i2++)
        {
            if (pProvData->pasSigners[i].pasCounterSigners[i2].csCertChain < 1)
            {
                pProvData->pasSigners[i].pasCounterSigners[i2].dwError = TRUST_E_NO_SIGNER_CERT;
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_COUNTER_SIGNER;
                dwError = S_FALSE;
                continue;
            }

            // If lifetime signing has been enabled, use current time instead
            // of timestamp time.
            if (fLifetimeSigning)
            {
                memcpy(&pProvData->pasSigners[i].pasCounterSigners[i2].sftVerifyAsOf,
                    &pProvData->sftSystemTime, sizeof(FILETIME));
            }

            _WalkChain(pProvData, i, &dwError, TRUE, i2, FALSE, NULL);
        }
    }

    return(dwError);
}


HCERTCHAINENGINE GetChainEngine(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    CERT_CHAIN_ENGINE_CONFIG Config;
    HCERTSTORE hStore = NULL;
    HCERTCHAINENGINE hChainEngine = NULL;

    if (NULL == pProvData->pWintrustData ||
            pProvData->pWintrustData->dwUnionChoice != WTD_CHOICE_CERT ||
            !_ISINSTRUCT(WINTRUST_CERT_INFO,
                pProvData->pWintrustData->pCert->cbStruct, dwFlags) ||
            0 == (pProvData->pWintrustData->pCert->dwFlags & 
                    (WTCI_DONT_OPEN_STORES | WTCI_OPEN_ONLY_ROOT)))
        return NULL;

    memset(&Config, 0, sizeof(Config));
    Config.cbSize = sizeof(Config);

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        Config.hRestrictedRoot = hStore;
    Config.hRestrictedTrust = hStore;
    Config.hRestrictedOther = hStore;

    if (!CertCreateCertificateChainEngine(
            &Config,
            &hChainEngine
            ))
        goto CreateChainEngineError;

CommonReturn:
    CertCloseStore(hStore, 0);
    return hChainEngine;
ErrorReturn:
    hChainEngine = NULL;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, OpenMemoryStoreError)
TRACE_ERROR_EX(DBG_SS, CreateChainEngineError)
}


HCERTSTORE GetChainAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    HCERTSTORE hStore = NULL;

    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
    } else
        hStore = CertDuplicateStore(pProvData->pahStores[0]);

#if 0
    CertSaveStore(
            hStore,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_FILENAME_A,
            (void *) "C:\\temp\\wintrust.sto",
            0                   // dwFlags
            );
#endif

    return hStore;
}

BOOL UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD idxSigner,
    OUT DWORD *pdwError, 
    IN BOOL fCounterSigner,
    IN DWORD idxCounterSigner,
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    BOOL fTestCert = FALSE;
    DWORD dwSgnrError = 0;
    DWORD i;

    // The chain better have at least the certificate we passed in
    assert(0 < pChainContext->cChain &&
        0 < pChainContext->rgpChain[0]->cElement);

    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
            DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
            DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
            PCRYPT_PROVIDER_CERT pProvCert;

            if (0 != i || 0 != j) {
                if (!(pProvData->psPfns->pfnAddCert2Chain(
                        pProvData, idxSigner, fCounterSigner, 
                        idxCounterSigner, pEle->pCertContext)))
                {
                    pProvData->dwError = GetLastError();
                    dwSgnrError = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                }
            }
            //
            // else
            //  Signer cert has already been added
            pProvCert = &pSgnr->pasCertChain[pSgnr->csCertChain -1];

            //DSIE: 12-Oct-2000 added to get pChainElement.
            pProvCert->pChainElement = pEle;

            pProvCert->fSelfSigned =
                0 != (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) &&
                0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID);

            pProvCert->fTrustedRoot =
                pProvCert->fSelfSigned &&
                i == pChainContext->cChain - 1 &&
                j == pChain->cElement - 1 &&
                0 == (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT);


            if (pProvCert->fSelfSigned) {
                // Check if one of the "test" roots
                DWORD k;

                for (k = 0; k < NTESTROOTS; k++) 
                {
                    if (CertComparePublicKeyInfo(
                            pProvData->dwEncoding,
                            &pProvCert->pCert->pCertInfo->SubjectPublicKeyInfo,
                            &rgTestRootPublicKeyInfo[k]))
                    {
                        pProvCert->fTestCert = TRUE;
                        fTestCert = TRUE;
                        if (pProvData->dwRegPolicySettings & WTPF_TRUSTTEST)
                            pProvCert->fTrustedRoot = TRUE;
                        break;
                    }
                }
            }

            // First Element in all but the first simple chain
            pProvCert->fTrustListSignerCert = (0 < i && 0 == j);

            pProvCert->fIsCyclic = (0 != (dwEleError & CERT_TRUST_IS_CYCLIC));

            // Map to IE4Trust confidence
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_SIG;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

            // On Sep 10, 1998 Trevor/Brian wanted time nesting checks to
            // be disabled
            // if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_NESTED))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIMENEST;

            if (0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_AUTHIDEXT;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
                    0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_HYGIENE;

            if (pEle->pRevocationInfo) {
                pProvCert->dwRevokedReason =
                    pEle->pRevocationInfo->dwRevocationResult;
            }

            // Update any signature or revocations errors
            if (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
                pProvCert->dwError = TRUST_E_CERT_SIGNATURE;
                assert(pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_NOT_SIGNATURE_VALID);
                dwSgnrError = TRUST_E_CERT_SIGNATURE;
            } else if (dwEleError & CERT_TRUST_IS_REVOKED) {
                pProvCert->dwError = CERT_E_REVOKED;
                assert(pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_REVOKED);
                if (0 == dwSgnrError ||
                        CERT_E_REVOCATION_FAILURE == dwSgnrError)
                    dwSgnrError = CERT_E_REVOKED;
            } else if (dwEleError & CERT_TRUST_IS_OFFLINE_REVOCATION) {
                // Ignore NO_CHECK errors

                if (pProvData->pWintrustData->fdwRevocationChecks ==
                        WTD_REVOKE_WHOLECHAIN) {
                    pProvCert->dwError = CERT_E_REVOCATION_FAILURE;
                    assert(pChainContext->TrustStatus.dwErrorStatus &
                        CERT_TRUST_REVOCATION_STATUS_UNKNOWN);
                    if (0 == dwSgnrError)
                        dwSgnrError = CERT_E_REVOCATION_FAILURE;
                }
            }

            // If last element in simple chain, check if it was in a
            // CTL and update CryptProvData if it was.
            if (j == pChain->cElement - 1 && pChain->pTrustListInfo &&
                    pChain->pTrustListInfo->pCtlContext) {
                DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

                // Note, don't need to AddRef since we already hold an
                // AddRef on the ChainContext.
                pProvCert->pCtlContext = pChain->pTrustListInfo->pCtlContext;

                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) {
                    pProvCert->dwCtlError = TRUST_E_CERT_SIGNATURE;
                    dwSgnrError = TRUST_E_CERT_SIGNATURE;
                } else if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
                    if (0 == (pProvData->dwRegPolicySettings &
                            WTPF_IGNOREEXPIRATION))
                    pProvCert->dwCtlError = CERT_E_EXPIRED;
                } else if (dwChainError &
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) {
                    pProvCert->dwCtlError = CERT_E_WRONG_USAGE;
                }
            }


            if (pProvData->psPfns->pfnCertCheckPolicy) {
                if (! (*pProvData->psPfns->pfnCertCheckPolicy)(
                    pProvData, idxSigner, fCounterSigner, idxCounterSigner))
                goto CommonReturn;
            }
        }
    }

CommonReturn:
    if (fTestCert) {
        if (CERT_TRUST_IS_REVOKED == dwSgnrError ||
                CERT_E_REVOCATION_FAILURE == dwSgnrError) {
            // No revocation errors for "test" roots
            dwSgnrError = 0;

            // Loop through certs and remove any revocation error status
            for (i = 0; i < pSgnr->csCertChain; i++) {
                PCRYPT_PROVIDER_CERT pProvCert = &pSgnr->pasCertChain[i];
                pProvCert->dwError = 0;
                pProvCert->dwRevokedReason = 0;
            }
        }
    }

    if (CERT_E_REVOCATION_FAILURE == dwSgnrError &&
            pProvData->pWintrustData->fdwRevocationChecks !=
                WTD_REVOKE_WHOLECHAIN)
        // Will check during Final Policy
        dwSgnrError = 0;

    if (dwSgnrError) {
        pSgnr->dwError = dwSgnrError;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            dwSgnrError;
        *pdwError = S_FALSE;
        return FALSE;
    } else
        return TRUE;
}

BOOL _WalkChain(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD idxSigner,
    DWORD *pdwError, 
    BOOL fCounterSigner,
    DWORD idxCounterSigner,
    BOOL fTimeStamped,
    BOOL *pfLifetimeSigning     // IN OUT, only accessed for fTimeStamped
    )
{
    BOOL fResult;
    DWORD dwCreateChainFlags;
    DWORD dwSgnrError = 0;
    CRYPT_PROVIDER_SGNR *pSgnr;         // not allocated
    PCCERT_CONTEXT pCertContext;        // not allocated

    CERT_CHAIN_PARA ChainPara;
    HCERTCHAINENGINE hChainEngine = NULL;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    LPSTR pszUsage = NULL;

    if (fCounterSigner)
        pSgnr = &pProvData->pasSigners[idxSigner].pasCounterSigners[
            idxCounterSigner];
    else
        pSgnr = &pProvData->pasSigners[idxSigner];
    assert(pSgnr);

    //
    //  at this stage, the last cert in the chain "should be" the signers cert.
    //  eg: there should only be one cert in the chain from the Signature
    //  Provider
    //
    if (1 != pSgnr->csCertChain ||
            (NULL == (pCertContext =
                pSgnr->pasCertChain[pSgnr->csCertChain - 1].pCert))) {
        dwSgnrError = TRUST_E_NO_SIGNER_CERT;
        goto NoSignerCertError;
    }


    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (fCounterSigner && SGNR_TYPE_TIMESTAMP == pSgnr->dwSignerType) {
        pszUsage = szOID_PKIX_KP_TIMESTAMP_SIGNING;
    } else if(NULL != pProvData->pRequestUsage) {
        ChainPara.RequestedUsage = *pProvData->pRequestUsage;
    } else {
        pszUsage = pProvData->pszUsageOID;
    }
    
    if ( (0 == (pProvData->dwProvFlags & WTD_NO_POLICY_USAGE_FLAG)) && pszUsage) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;
    }
    hChainEngine = GetChainEngine(pProvData);
    hAdditionalStore = GetChainAdditionalStore(pProvData);

    dwCreateChainFlags = 0;
    if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_NONE) {
        ;
    } else if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_END_CERT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    } else if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_CHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pProvData->dwProvFlags &
            CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_NONE) {
        ;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_END_CERT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_CHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pProvData->dwProvFlags &
            WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (pProvData->pWintrustData->fdwRevocationChecks ==
            WTD_REVOKE_WHOLECHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (fCounterSigner && SGNR_TYPE_TIMESTAMP == pSgnr->dwSignerType) {
        if (0 == (pProvData->dwRegPolicySettings & WTPF_IGNOREREVOCATIONONTS))
            // On 4-12-01 changed from END_CERT to EXCLUDE_ROOT
            dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (0 == (pProvData->dwRegPolicySettings & WTPF_IGNOREREVOKATION))
        // On 4-12-01 changed from END_CERT to EXCLUDE_ROOT
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;

    if (!(pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CERT ||
            pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_SIGNER))
        // Certificate was obtained from either the message store, or one
        // of our known stores
        dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT;
    // else
    //  Can't implicitly cache a context passed to us


#if 0
    {
        HCERTSTORE hDebugStore;
        if (hDebugStore = CertOpenSystemStoreA(0, "wintrust")) {
            CertAddCertificateContextToStore(
                hDebugStore,
                pCertContext,
                CERT_STORE_ADD_ALWAYS,
                NULL
                );
            CertCloseStore(hDebugStore, 0);
        }
    }
#endif

    FILETIME fileTime;

    memset(&fileTime, 0, sizeof(fileTime));


    if (fTimeStamped && *pfLifetimeSigning)
        dwCreateChainFlags |= CERT_CHAIN_TIMESTAMP_TIME;
    
    if (!CertGetCertificateChain (
            hChainEngine,
            pCertContext,
            (memcmp(&pSgnr->sftVerifyAsOf, &fileTime, sizeof(fileTime)) == 0) ? 
                    NULL : &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    if (fTimeStamped && !*pfLifetimeSigning) {
        // See if resultant application policy has the LIFETIME_SIGNING OID
        PCERT_ENHKEY_USAGE pAppUsage =
            pChainContext->rgpChain[0]->rgpElement[0]->pApplicationUsage;

        if (pAppUsage) {
            DWORD i;

            for (i = 0; i < pAppUsage->cUsageIdentifier; i++) {
                if (0 == strcmp(pAppUsage->rgpszUsageIdentifier[i],
                        szOID_KP_LIFETIME_SIGNING)) {
                    *pfLifetimeSigning = TRUE;
                    break;
                }
            }
        }

        if (*pfLifetimeSigning) {
            CertFreeCertificateChain(pChainContext);
            pChainContext = NULL;
            dwCreateChainFlags |= CERT_CHAIN_TIMESTAMP_TIME;

            if (!CertGetCertificateChain (
                    hChainEngine,
                    pCertContext,
                    (memcmp(&pSgnr->sftVerifyAsOf, &fileTime, sizeof(fileTime)) == 0) ? 
                            NULL : &pSgnr->sftVerifyAsOf,
                    hAdditionalStore,
                    &ChainPara,
                    dwCreateChainFlags,
                    NULL,                       // pvReserved,
                    &pChainContext
                    )) {
                pProvData->dwError = GetLastError();
                dwSgnrError = TRUST_E_SYSTEM_ERROR;
                goto GetChainError;
            }
        }

    }

    pSgnr->pChainContext = pChainContext;
    if (pProvData->dwProvFlags & WTD_NO_IE4_CHAIN_FLAG) {
        pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
        fResult = TRUE;
    } else
        fResult = UpdateCertProvChain(
            pProvData,
            idxSigner,
            pdwError, 
            fCounterSigner,
            idxCounterSigner,
            pSgnr,
            pChainContext
            );
                                        
CommonReturn:
    if (hChainEngine)
        CertFreeCertificateChainEngine(hChainEngine);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    return fResult;
ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    *pdwError = S_FALSE;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, NoSignerCertError)
TRACE_ERROR_EX(DBG_SS, GetChainError)
}

BOOL WINAPI _IsLifetimeSigningCert(
    PCCERT_CONTEXT pCertContext
    )
{
    DWORD               cbSize;
    PCERT_ENHKEY_USAGE  pCertEKU;

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    CertGetEnhancedKeyUsage(pCertContext, 
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize);

    if (cbSize == 0)
    {
        return(FALSE);
    }
                      
    if (!(pCertEKU = (PCERT_ENHKEY_USAGE)new BYTE[cbSize]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
    {
        delete pCertEKU;
        return(FALSE);
    }

    for (int i = 0; i < (int)pCertEKU->cUsageIdentifier; i++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_KP_LIFETIME_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }
    }

    delete pCertEKU;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\ossfunc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ossfunc.h
//
//--------------------------------------------------------------------------

#ifndef _OSS_FUNC_H
#define _OSS_FUNC_H

HRESULT WINAPI
ASNRegisterServer(LPCWSTR dllName);

HRESULT WINAPI
ASNUnregisterServer(void);

BOOL WINAPI
ASNDllMain(HMODULE hInst,
           ULONG  ulReason,
           LPVOID lpReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\ossfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ossfunc.cpp
//
//--------------------------------------------------------------------------


#include "global.hxx"

extern "C"
{
#include "wtasn.h"
}
#include "crypttls.h"
#include "unicode.h"
#include "pkiasn1.h"

#include <dbgdef.h>

#include "locals.h"

#define SpcAsnAlloc         WVTNew
#define SpcAsnFree          WVTDelete


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

static HCRYPTASN1MODULE hAsn1Module;


extern "C"
{
BOOL WINAPI WVTAsn1SpcLinkEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_LINK pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcLinkDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_LINK pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcIndirectDataContentEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcIndirectDataContentDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSpAgencyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSpAgencyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcStatementTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcStatementTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSpOpusInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSpOpusInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcPeImageDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_PE_IMAGE_DATA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcPeImageDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_PE_IMAGE_DATA pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSigInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SIGINFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSigInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SIGINFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1UtcTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT FILETIME * pFileTime,
        IN OUT DWORD *pcbFileTime
        );

BOOL WINAPI WVTAsn1CatNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCAT_NAMEVALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded);

BOOL WINAPI WVTAsn1CatMemberInfoEncode(
        IN DWORD dwEncoding,
        IN LPCSTR lpszStructType,
        IN PCAT_MEMBERINFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded);

BOOL WINAPI WVTAsn1CatNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCAT_NAMEVALUE pInfo,
        IN OUT DWORD *pcbInfo);

BOOL WINAPI WVTAsn1CatMemberInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCAT_MEMBERINFO pInfo,
        IN OUT DWORD *pcbInfo);
};


static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hAsn1Module);
}

//+-------------------------------------------------------------------------
//  SPC ASN allocation and free functions
//--------------------------------------------------------------------------
HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY SpcRegEncodeTable[] =
{
    SPC_PE_IMAGE_DATA_OBJID,            "WVTAsn1SpcPeImageDataEncode",
    SPC_PE_IMAGE_DATA_STRUCT,           "WVTAsn1SpcPeImageDataEncode",

    SPC_CAB_DATA_OBJID,                 "WVTAsn1SpcLinkEncode",
    SPC_CAB_DATA_STRUCT,                "WVTAsn1SpcLinkEncode",

    SPC_JAVA_CLASS_DATA_OBJID,          "WVTAsn1SpcLinkEncode",
    SPC_JAVA_CLASS_DATA_STRUCT,         "WVTAsn1SpcLinkEncode",

    SPC_LINK_OBJID,                     "WVTAsn1SpcLinkEncode",
    SPC_LINK_STRUCT,                    "WVTAsn1SpcLinkEncode",

    SPC_SIGINFO_OBJID,                  "WVTAsn1SpcSigInfoEncode",
    SPC_SIGINFO_STRUCT,                 "WVTAsn1SpcSigInfoEncode",

    SPC_INDIRECT_DATA_OBJID,            "WVTAsn1SpcIndirectDataContentEncode",
    SPC_INDIRECT_DATA_CONTENT_STRUCT,   "WVTAsn1SpcIndirectDataContentEncode",

    SPC_SP_AGENCY_INFO_OBJID,           "WVTAsn1SpcSpAgencyInfoEncode",
    SPC_SP_AGENCY_INFO_STRUCT,          "WVTAsn1SpcSpAgencyInfoEncode",

    SPC_MINIMAL_CRITERIA_OBJID,         "WVTAsn1SpcMinimalCriteriaInfoEncode",
    SPC_MINIMAL_CRITERIA_STRUCT,        "WVTAsn1SpcMinimalCriteriaInfoEncode",

    SPC_FINANCIAL_CRITERIA_OBJID,       "WVTAsn1SpcFinancialCriteriaInfoEncode",
    SPC_FINANCIAL_CRITERIA_STRUCT,      "WVTAsn1SpcFinancialCriteriaInfoEncode",

    SPC_STATEMENT_TYPE_OBJID,           "WVTAsn1SpcStatementTypeEncode",
    SPC_STATEMENT_TYPE_STRUCT,          "WVTAsn1SpcStatementTypeEncode",

    CAT_NAMEVALUE_OBJID,                "WVTAsn1CatNameValueEncode",
    CAT_NAMEVALUE_STRUCT,               "WVTAsn1CatNameValueEncode",

    CAT_MEMBERINFO_OBJID,               "WVTAsn1CatMemberInfoEncode",
    CAT_MEMBERINFO_STRUCT,              "WVTAsn1CatMemberInfoEncode",

    SPC_SP_OPUS_INFO_OBJID,             "WVTAsn1SpcSpOpusInfoEncode",
    SPC_SP_OPUS_INFO_STRUCT,            "WVTAsn1SpcSpOpusInfoEncode"

};
#define SPC_REG_ENCODE_COUNT (sizeof(SpcRegEncodeTable) / sizeof(SpcRegEncodeTable[0]))

static const OID_REG_ENTRY SpcRegDecodeTable[] =
{
    SPC_PE_IMAGE_DATA_OBJID,            "WVTAsn1SpcPeImageDataDecode",
    SPC_PE_IMAGE_DATA_STRUCT,           "WVTAsn1SpcPeImageDataDecode",

    SPC_CAB_DATA_OBJID,                 "WVTAsn1SpcLinkDecode",
    SPC_CAB_DATA_STRUCT,                "WVTAsn1SpcLinkDecode",

    SPC_JAVA_CLASS_DATA_OBJID,          "WVTAsn1SpcLinkDecode",
    SPC_JAVA_CLASS_DATA_STRUCT,         "WVTAsn1SpcLinkDecode",

    SPC_LINK_OBJID,                     "WVTAsn1SpcLinkDecode",
    SPC_LINK_STRUCT,                    "WVTAsn1SpcLinkDecode",

    SPC_SIGINFO_OBJID,                  "WVTAsn1SpcSigInfoDecode",
    SPC_SIGINFO_STRUCT,                 "WVTAsn1SpcSigInfoDecode",

    SPC_INDIRECT_DATA_OBJID,            "WVTAsn1SpcIndirectDataContentDecode",
    SPC_INDIRECT_DATA_CONTENT_STRUCT,   "WVTAsn1SpcIndirectDataContentDecode",

    SPC_SP_AGENCY_INFO_OBJID,           "WVTAsn1SpcSpAgencyInfoDecode",
    SPC_SP_AGENCY_INFO_STRUCT,          "WVTAsn1SpcSpAgencyInfoDecode",

    SPC_MINIMAL_CRITERIA_OBJID,         "WVTAsn1SpcMinimalCriteriaInfoDecode",
    SPC_MINIMAL_CRITERIA_STRUCT,        "WVTAsn1SpcMinimalCriteriaInfoDecode",

    SPC_FINANCIAL_CRITERIA_OBJID,       "WVTAsn1SpcFinancialCriteriaInfoDecode",
    SPC_FINANCIAL_CRITERIA_STRUCT,      "WVTAsn1SpcFinancialCriteriaInfoDecode",

    SPC_STATEMENT_TYPE_OBJID,           "WVTAsn1SpcStatementTypeDecode",
    SPC_STATEMENT_TYPE_STRUCT,          "WVTAsn1SpcStatementTypeDecode",

    CAT_NAMEVALUE_OBJID,                "WVTAsn1CatNameValueDecode",
    CAT_NAMEVALUE_STRUCT,               "WVTAsn1CatNameValueDecode",

    CAT_MEMBERINFO_OBJID,               "WVTAsn1CatMemberInfoDecode",
    CAT_MEMBERINFO_STRUCT,              "WVTAsn1CatMemberInfoDecode",

    SPC_SP_OPUS_INFO_OBJID,             "WVTAsn1SpcSpOpusInfoDecode",
    SPC_SP_OPUS_INFO_STRUCT,            "WVTAsn1SpcSpOpusInfoDecode"

};
#define SPC_REG_DECODE_COUNT (sizeof(SpcRegDecodeTable) / sizeof(SpcRegDecodeTable[0]))

#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX

static const CRYPT_OID_FUNC_ENTRY SpcEncodeFuncTable[] =
{
    ASN1_OID_OFFSET SPC_PE_IMAGE_DATA_STRUCT,           WVTAsn1SpcPeImageDataEncode,
    ASN1_OID_PREFIX SPC_PE_IMAGE_DATA_OBJID,            WVTAsn1SpcPeImageDataEncode,

    ASN1_OID_PREFIX SPC_CAB_DATA_OBJID,                 WVTAsn1SpcLinkEncode,
    ASN1_OID_OFFSET SPC_CAB_DATA_STRUCT,                WVTAsn1SpcLinkEncode,

    ASN1_OID_OFFSET SPC_LINK_STRUCT,                    WVTAsn1SpcLinkEncode,
    ASN1_OID_PREFIX SPC_LINK_OBJID,                     WVTAsn1SpcLinkEncode,

    ASN1_OID_OFFSET SPC_SIGINFO_STRUCT,                 WVTAsn1SpcSigInfoEncode,
    ASN1_OID_PREFIX SPC_SIGINFO_OBJID,                  WVTAsn1SpcSigInfoEncode,

    ASN1_OID_PREFIX SPC_INDIRECT_DATA_OBJID,            WVTAsn1SpcIndirectDataContentEncode,
    ASN1_OID_OFFSET SPC_INDIRECT_DATA_CONTENT_STRUCT,   WVTAsn1SpcIndirectDataContentEncode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoEncode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoEncode,

    ASN1_OID_OFFSET SPC_MINIMAL_CRITERIA_STRUCT,        WVTAsn1SpcMinimalCriteriaInfoEncode,
    ASN1_OID_PREFIX SPC_MINIMAL_CRITERIA_OBJID,         WVTAsn1SpcMinimalCriteriaInfoEncode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoEncode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoEncode,

    ASN1_OID_OFFSET SPC_STATEMENT_TYPE_STRUCT,          WVTAsn1SpcStatementTypeEncode,
    ASN1_OID_PREFIX SPC_STATEMENT_TYPE_OBJID,           WVTAsn1SpcStatementTypeEncode,

    ASN1_OID_PREFIX CAT_NAMEVALUE_OBJID,                WVTAsn1CatNameValueEncode,
    ASN1_OID_OFFSET CAT_NAMEVALUE_STRUCT,               WVTAsn1CatNameValueEncode,

    ASN1_OID_PREFIX CAT_MEMBERINFO_OBJID,               WVTAsn1CatMemberInfoEncode,
    ASN1_OID_OFFSET CAT_MEMBERINFO_STRUCT,              WVTAsn1CatMemberInfoEncode,

    ASN1_OID_OFFSET SPC_SP_OPUS_INFO_STRUCT,            WVTAsn1SpcSpOpusInfoEncode,
    ASN1_OID_PREFIX SPC_SP_OPUS_INFO_OBJID,             WVTAsn1SpcSpOpusInfoEncode
};

#define SPC_ENCODE_FUNC_COUNT (sizeof(SpcEncodeFuncTable) / \
                                    sizeof(SpcEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SpcDecodeFuncTable[] =
{
    ASN1_OID_OFFSET SPC_PE_IMAGE_DATA_STRUCT,           WVTAsn1SpcPeImageDataDecode,
    ASN1_OID_PREFIX SPC_PE_IMAGE_DATA_OBJID,            WVTAsn1SpcPeImageDataDecode,

    ASN1_OID_OFFSET SPC_CAB_DATA_STRUCT,                WVTAsn1SpcLinkDecode,
    ASN1_OID_PREFIX SPC_CAB_DATA_OBJID,                 WVTAsn1SpcLinkDecode,

    ASN1_OID_OFFSET SPC_LINK_STRUCT,                    WVTAsn1SpcLinkDecode,
    ASN1_OID_PREFIX SPC_LINK_OBJID,                     WVTAsn1SpcLinkDecode,

    ASN1_OID_OFFSET SPC_SIGINFO_STRUCT,                 WVTAsn1SpcSigInfoDecode,
    ASN1_OID_PREFIX SPC_SIGINFO_OBJID,                  WVTAsn1SpcSigInfoDecode,

    ASN1_OID_OFFSET PKCS_UTC_TIME,                      WVTAsn1UtcTimeDecode,
    ASN1_OID_PREFIX szOID_RSA_signingTime,              WVTAsn1UtcTimeDecode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoDecode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoDecode,

    ASN1_OID_OFFSET SPC_SP_OPUS_INFO_STRUCT,            WVTAsn1SpcSpOpusInfoDecode,
    ASN1_OID_PREFIX SPC_SP_OPUS_INFO_OBJID,             WVTAsn1SpcSpOpusInfoDecode,

    ASN1_OID_OFFSET SPC_INDIRECT_DATA_CONTENT_STRUCT,   WVTAsn1SpcIndirectDataContentDecode,
    ASN1_OID_PREFIX SPC_INDIRECT_DATA_OBJID,            WVTAsn1SpcIndirectDataContentDecode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoDecode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoDecode,

    ASN1_OID_OFFSET SPC_MINIMAL_CRITERIA_STRUCT,        WVTAsn1SpcMinimalCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_MINIMAL_CRITERIA_OBJID,         WVTAsn1SpcMinimalCriteriaInfoDecode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoDecode,

    ASN1_OID_OFFSET SPC_STATEMENT_TYPE_STRUCT,          WVTAsn1SpcStatementTypeDecode,
    ASN1_OID_PREFIX SPC_STATEMENT_TYPE_OBJID,           WVTAsn1SpcStatementTypeDecode,

    ASN1_OID_OFFSET CAT_NAMEVALUE_STRUCT,               WVTAsn1CatNameValueDecode,
    ASN1_OID_PREFIX CAT_NAMEVALUE_OBJID,                WVTAsn1CatNameValueDecode,

    ASN1_OID_OFFSET CAT_MEMBERINFO_STRUCT,              WVTAsn1CatMemberInfoDecode,
    ASN1_OID_PREFIX CAT_MEMBERINFO_OBJID,               WVTAsn1CatMemberInfoDecode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoDecode
};

#define SPC_DECODE_FUNC_COUNT (sizeof(SpcDecodeFuncTable) / \
                                    sizeof(SpcDecodeFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
HRESULT WINAPI ASNRegisterServer(LPCWSTR dllName)
{
    int i;

    for (i = 0; i < SPC_REG_ENCODE_COUNT; i++)
    {
        if (!(CryptRegisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_ENCODE_OBJECT_FUNC,
                                       SpcRegEncodeTable[i].pszOID, dllName,
                                       SpcRegEncodeTable[i].pszOverrideFuncName)))
        {
            return(HError());
        }
    }

    for (i = 0; i < SPC_REG_DECODE_COUNT; i++)
    {
        if (!(CryptRegisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_DECODE_OBJECT_FUNC,
                                       SpcRegDecodeTable[i].pszOID, dllName,
                                       SpcRegDecodeTable[i].pszOverrideFuncName)))
        {
            return(HError());
        }
    }

    return S_OK;
}


HRESULT WINAPI ASNUnregisterServer()
{
    HRESULT hr = S_OK;
    int     i;

    for (i = 0; i < SPC_REG_ENCODE_COUNT; i++)
    {
        if (!(CryptUnregisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_ENCODE_OBJECT_FUNC,
                                         SpcRegEncodeTable[i].pszOID)))
        {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
            {
                hr = HError();
            }
        }
    }

    for (i = 0; i < SPC_REG_DECODE_COUNT; i++)
    {
        if (!(CryptUnregisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_DECODE_OBJECT_FUNC,
                                         SpcRegDecodeTable[i].pszOID)))
        {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
            {
                hr = HError();
            }
        }
    }
    return(hr);
}



BOOL WINAPI ASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        WTASN_Module_Startup();
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(
                WTASN_Module, 0, NULL)))
        {
            goto CryptInstallAsn1ModuleError;
        }
/*
        if (!(CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                SPC_ENCODE_FUNC_COUNT,
                SpcEncodeFuncTable,
                0)))
        {
            goto CryptInstallOIDFunctionAddressError;
        }

        if (!(CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SPC_DECODE_FUNC_COUNT,
                SpcDecodeFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG)))
        {
            goto CryptInstallOIDFunctionAddressError;
        }
*/
        break;

    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hAsn1Module);
        WTASN_Module_Cleanup();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS,CryptInstallAsn1ModuleError)
//TRACE_ERROR_EX(DBG_SS,CryptInstallOIDFunctionAddressError)
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void WVTAsn1SetAny(IN PCRYPT_OBJID_BLOB pInfo, OUT NOCOPYANY *pOss)
{
    PkiAsn1SetAny(pInfo, pOss);
}

inline void WVTAsn1GetAny(IN NOCOPYANY *pOss, IN DWORD dwFlags, OUT PCRYPT_OBJID_BLOB pInfo,
                                 IN OUT BYTE **ppbExtra, IN OUT LONG *plRemainExtra)
{
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void WVTAsn1SetOctetString(IN PCRYPT_DATA_BLOB pInfo, OUT OCTETSTRING *pOss)
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

inline void WVTAsn1GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

inline void WVTAsn1SetBit(IN PCRYPT_BIT_BLOB pInfo, OUT BITSTRING *pOss)
{
    PkiAsn1SetBitString(pInfo, &pOss->length, &pOss->value);
}

inline void WVTAsn1GetBit(IN BITSTRING *pOss, IN DWORD dwFlags,
                                 OUT PCRYPT_BIT_BLOB pInfo,
                                 IN OUT BYTE **ppbExtra,
                                 IN OUT LONG *plRemainExtra)
{
    PkiAsn1GetBitString(pOss->length, pOss->value, dwFlags,
                        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
inline BOOL WVTAsn1SetUnicodeConvertedToIA5(
        IN LPWSTR pwsz,
        OUT IA5STRING *pOss
        )
{
    return PkiAsn1SetUnicodeConvertedToIA5String(pwsz,
        &pOss->length, &pOss->value);
}
inline void WVTAsn1FreeUnicodeConvertedToIA5(IN IA5STRING *pOss)
{
    PkiAsn1FreeUnicodeConvertedToIA5String(pOss->value);
    pOss->value = NULL;
}
inline void WVTAsn1GetIA5ConvertedToUnicode(
        IN IA5STRING *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5StringConvertedToUnicode(pOss->length, pOss->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get LPWSTR (BMP String)
//--------------------------------------------------------------------------
inline void WVTAsn1SetBMP(
        IN LPWSTR pwsz,
        OUT BMPSTRING *pOss
        )
{
    pOss->value = pwsz;
    pOss->length = wcslen(pwsz);
}
inline void WVTAsn1GetBMP(
        IN BMPSTRING *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBMPString(pOss->length, pOss->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get Spc String
//--------------------------------------------------------------------------
void WVTAsn1SetSpcString(
        IN LPWSTR pwsz,
        OUT SpcString *pOss
        )
{
    pOss->choice = unicode_chosen;
    WVTAsn1SetBMP(pwsz, &pOss->u.unicode);
}

void WVTAsn1GetSpcString(
        IN SpcString *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    switch (pOss->choice) {
    case unicode_chosen:
        WVTAsn1GetBMP(&pOss->u.unicode, dwFlags,
            ppwsz, ppbExtra, plRemainExtra);
        break;
    case ascii_chosen:
        WVTAsn1GetIA5ConvertedToUnicode(&pOss->u.ascii, dwFlags,
            ppwsz, ppbExtra, plRemainExtra);
        break;
    default:
        if (*plRemainExtra >= 0)
            *ppwsz = NULL;
    }
}

//+-------------------------------------------------------------------------
//  Set/Get Spc Link
//--------------------------------------------------------------------------
BOOL WVTAsn1SetSpcLink(
        IN PSPC_LINK pInfo,
        OUT SpcLink *pOss
        )
{
    BOOL fRet = TRUE;

    memset(pOss, 0, sizeof(*pOss));

    // Assumption: OSS choice == dwLinkChoice
    // WVTAsn1GetSpcLink has asserts to verify
    pOss->choice = (unsigned short) pInfo->dwLinkChoice;

    switch (pInfo->dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        fRet = WVTAsn1SetUnicodeConvertedToIA5(pInfo->pwszUrl, &pOss->u.url);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        pOss->u.moniker.classId.length = sizeof(pInfo->Moniker.ClassId);
        pOss->u.moniker.classId.value = pInfo->Moniker.ClassId;
        WVTAsn1SetOctetString(&pInfo->Moniker.SerializedData,
            &pOss->u.moniker.serializedData);
        break;
    case SPC_FILE_LINK_CHOICE:
        WVTAsn1SetSpcString(pInfo->pwszFile, &pOss->u.file);
        break;
    default:
        SetLastError((DWORD) E_INVALIDARG);
        fRet = FALSE;
    }

    return fRet;
}

void WVTAsn1FreeSpcLink(
        IN SpcLink *pOss
        )
{
    if (pOss->choice == url_chosen)
        WVTAsn1FreeUnicodeConvertedToIA5(&pOss->u.url);
}

BOOL WVTAsn1GetSpcLink(
        IN SpcLink *pOss,
        IN DWORD dwFlags,
        OUT PSPC_LINK pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwLinkChoice;

    assert(url_chosen == SPC_URL_LINK_CHOICE);
    assert(moniker_chosen == SPC_MONIKER_LINK_CHOICE);
    assert(file_chosen == SPC_FILE_LINK_CHOICE);

    dwLinkChoice = pOss->choice;

    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(*pInfo));
        pInfo->dwLinkChoice = dwLinkChoice;
    }

    switch (dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        WVTAsn1GetIA5ConvertedToUnicode(&pOss->u.url, dwFlags,
            &pInfo->pwszUrl, ppbExtra, plRemainExtra);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        if (sizeof(pInfo->Moniker.ClassId) != pOss->u.moniker.classId.length) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            return FALSE;
        }

        if (*plRemainExtra >= 0) {
            memcpy(pInfo->Moniker.ClassId, pOss->u.moniker.classId.value,
                sizeof(pInfo->Moniker.ClassId));
        }
        WVTAsn1GetOctetString(&pOss->u.moniker.serializedData, dwFlags,
            &pInfo->Moniker.SerializedData, ppbExtra, plRemainExtra);
        break;
    case SPC_FILE_LINK_CHOICE:
        WVTAsn1GetSpcString(&pOss->u.file, dwFlags,
            &pInfo->pwszFile, ppbExtra, plRemainExtra);
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}

BOOL WVTAsn1GetSpcLinkPointer(
        IN SpcLink *pOss,
        IN DWORD dwFlags,
        OUT PSPC_LINK *pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PSPC_LINK pLink;

    lAlignExtra = INFO_LEN_ALIGN(sizeof(SPC_LINK));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pLink = (PSPC_LINK) *ppbExtra;
        *pInfo = pLink;
        *ppbExtra += lAlignExtra;
    } else
        pLink = NULL;

    return WVTAsn1GetSpcLink(
        pOss,
        dwFlags,
        pLink,
        ppbExtra,
        plRemainExtra
        );
}

BOOL WVTAsn1SetSpcSigInfo(IN PSPC_SIGINFO pInfo, OUT SpcSigInfo *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));

    pOss->dwSIPversion      = pInfo->dwSipVersion;

    pOss->gSIPguid.length   = sizeof(GUID);
    pOss->gSIPguid.value = (BYTE *) &pInfo->gSIPGuid;

    pOss->dwReserved1       = pInfo->dwReserved1;
    pOss->dwReserved2       = pInfo->dwReserved2;
    pOss->dwReserved3       = pInfo->dwReserved3;
    pOss->dwReserved4       = pInfo->dwReserved4;
    pOss->dwReserved5       = pInfo->dwReserved5;

    return(TRUE);
}

BOOL WVTAsn1GetSpcSigInfo(IN SpcSigInfo *pOss, IN DWORD dwFlags,
                              OUT PSPC_SIGINFO pInfo, IN OUT BYTE **ppbExtra,
                              IN OUT LONG *plRemainExtra)
{

    if (!(pInfo))
    {
        return(TRUE);
    }

    pInfo->dwSipVersion     = pOss->dwSIPversion;
    if (sizeof(GUID) != pOss->gSIPguid.length) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
    memcpy(&pInfo->gSIPGuid, pOss->gSIPguid.value, sizeof(GUID));

    pInfo->dwReserved1      = pOss->dwReserved1;
    pInfo->dwReserved2      = pOss->dwReserved2;
    pInfo->dwReserved3      = pOss->dwReserved3;
    pInfo->dwReserved4      = pOss->dwReserved4;
    pInfo->dwReserved5      = pOss->dwReserved5;

    return(TRUE);
}


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
BOOL WVTAsn1SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

void WVTAsn1GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL WVTAsn1SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (pInfo->pszObjId) {
        if (!WVTAsn1SetObjId(pInfo->pszObjId, &pOss->algorithm))
            return FALSE;
        if (pInfo->Parameters.cbData)
            WVTAsn1SetAny(&pInfo->Parameters, &pOss->parameters);
        else
            // Per PKCS #1: default to the ASN.1 type NULL.
            WVTAsn1SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pOss->parameters);
        pOss->bit_mask |= parameters_present;
    }
    return TRUE;
}

void WVTAsn1GetAlgorithm(
        IN AlgorithmIdentifier *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    WVTAsn1GetObjId(&pOss->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pOss->bit_mask & parameters_present)
        WVTAsn1GetAny(&pOss->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the WVTAsn1*Encode() functions.
//--------------------------------------------------------------------------
BOOL WVTAsn1InfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the WVTAsn1*Decode() functions.
//--------------------------------------------------------------------------
BOOL WVTAsn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the WVTAsn1*Decode() functions.
//--------------------------------------------------------------------------
void WVTAsn1InfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcIndirectDataContentEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcIndirectDataContent OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));
    if (!WVTAsn1SetObjId(pInfo->Data.pszObjId, &OssInfo.data.type))
        goto ErrorReturn;

    if (pInfo->Data.Value.cbData) {
        WVTAsn1SetAny(&pInfo->Data.Value, &OssInfo.data.value);
        OssInfo.data.bit_mask |= value_present;
    }

    if (!WVTAsn1SetAlgorithm(&pInfo->DigestAlgorithm,
            &OssInfo.messageDigest.digestAlgorithm))
        goto ErrorReturn;
    WVTAsn1SetOctetString(&pInfo->Digest, &OssInfo.messageDigest.digest);

    fResult = WVTAsn1InfoEncode(
        SpcIndirectDataContent_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcIndirectDataContentDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcIndirectDataContent *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcIndirectDataContent_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_INDIRECT_DATA_CONTENT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_INDIRECT_DATA_CONTENT));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_INDIRECT_DATA_CONTENT);
    }

    WVTAsn1GetObjId(&pOssInfo->data.type, dwFlags, &pInfo->Data.pszObjId,
            &pbExtra, &lRemainExtra);

    if (pOssInfo->data.bit_mask & value_present)
        WVTAsn1GetAny(&pOssInfo->data.value, dwFlags, &pInfo->Data.Value,
            &pbExtra, &lRemainExtra);

    WVTAsn1GetAlgorithm(&pOssInfo->messageDigest.digestAlgorithm, dwFlags,
            &pInfo->DigestAlgorithm, &pbExtra, &lRemainExtra);
    WVTAsn1GetOctetString(&pOssInfo->messageDigest.digest, dwFlags,
                &pInfo->Digest, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcIndirectDataContent_PDU, pOssInfo);
    return fResult;
}


BOOL WINAPI WVTAsn1UtcTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT FILETIME * pFileTime,
        IN OUT DWORD *pcbFileTime
        ) {


    BOOL fResult;
    UtcTime * putcTime = NULL;

    assert(pcbFileTime != NULL);

    if(pFileTime == NULL) {
            *pcbFileTime = sizeof(FILETIME);
            return(TRUE);
    }

    if (*pcbFileTime < sizeof(FILETIME)) {
            *pcbFileTime = sizeof(FILETIME);
            SetLastError((DWORD) ERROR_MORE_DATA);
            return(FALSE);
    }

    *pcbFileTime = sizeof(FILETIME);

    if (!WVTAsn1InfoDecodeAndAlloc(
            UtcTime_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &putcTime))
        goto WVTAsn1InfoDecodeAndAllocError;

    if( !PkiAsn1FromUTCTime(putcTime, pFileTime) )
            goto  PkiAsn1FromUTCTimeError;

    fResult = TRUE;

CommonReturn:
    WVTAsn1InfoFree(UtcTime_PDU, putcTime);
    return fResult;

ErrorReturn:
    *pcbFileTime = 0;
    fResult = FALSE;
        goto CommonReturn;

TRACE_ERROR_EX(DBG_SS,WVTAsn1InfoDecodeAndAllocError);
TRACE_ERROR_EX(DBG_SS,PkiAsn1FromUTCTimeError);
}

//+-------------------------------------------------------------------------
//  SPC SP Agency Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpAgencyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcSpAgencyInformation OssInfo;
    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pPolicyInformation) {
        if (!WVTAsn1SetSpcLink(pInfo->pPolicyInformation,
                &OssInfo.policyInformation))
            goto ErrorReturn;
        OssInfo.bit_mask |= policyInformation_present;
    }

    if (pInfo->pwszPolicyDisplayText) {
        WVTAsn1SetSpcString(pInfo->pwszPolicyDisplayText,
            &OssInfo.policyDisplayText);
        OssInfo.bit_mask |= policyDisplayText_present;
    }

    if (pInfo->pLogoImage) {
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) {
            if (!WVTAsn1SetSpcLink(pImage->pImageLink,
                    &OssInfo.logoImage.imageLink))
                goto ErrorReturn;
            OssInfo.logoImage.bit_mask |= imageLink_present;
        }

        if (pImage->Bitmap.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->Bitmap, &OssInfo.logoImage.bitmap);
            OssInfo.logoImage.bit_mask |= bitmap_present;
        }
        if (pImage->Metafile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->Metafile,
                &OssInfo.logoImage.metafile);
            OssInfo.logoImage.bit_mask |= metafile_present;
        }
        if (pImage->EnhancedMetafile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->EnhancedMetafile,
                &OssInfo.logoImage.enhancedMetafile);
            OssInfo.logoImage.bit_mask |= enhancedMetafile_present;
        }
        if (pImage->GifFile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->GifFile,
                &OssInfo.logoImage.gifFile);
            OssInfo.logoImage.bit_mask |= gifFile_present;
        }

        OssInfo.bit_mask |= logoImage_present;
    }

    if (pInfo->pLogoLink) {
        if (!WVTAsn1SetSpcLink(pInfo->pLogoLink, &OssInfo.logoLink))
            goto ErrorReturn;
        OssInfo.bit_mask |= logoLink_present;
    }

    fResult = WVTAsn1InfoEncode(
        SpcSpAgencyInformation_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.policyInformation);
    WVTAsn1FreeSpcLink(&OssInfo.logoImage.imageLink);
    WVTAsn1FreeSpcLink(&OssInfo.logoLink);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC SP Agency Info Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpAgencyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcSpAgencyInformation *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcSpAgencyInformation_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SP_AGENCY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_SP_AGENCY_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_SP_AGENCY_INFO);
    }

    if (pOssInfo->bit_mask & policyInformation_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->policyInformation, dwFlags,
                &pInfo->pPolicyInformation, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (pOssInfo->bit_mask & policyDisplayText_present) {
        WVTAsn1GetSpcString(&pOssInfo->policyDisplayText, dwFlags,
            &pInfo->pwszPolicyDisplayText, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & logoImage_present) {
        PSPC_IMAGE pImage;
        SpcImage *pOssImage = &pOssInfo->logoImage;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(SPC_IMAGE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pImage = (PSPC_IMAGE) pbExtra;
            memset(pImage, 0, sizeof(SPC_IMAGE));
            pInfo->pLogoImage = pImage;
            pbExtra += lAlignExtra;
        } else
            pImage = NULL;

        if (pOssImage->bit_mask & imageLink_present) {
            if (!WVTAsn1GetSpcLinkPointer(&pOssImage->imageLink, dwFlags,
                    &pImage->pImageLink, &pbExtra, &lRemainExtra))
                goto ErrorReturn;
        }
        if (pOssImage->bit_mask & bitmap_present) {
            WVTAsn1GetOctetString(&pOssImage->bitmap, dwFlags,
                &pImage->Bitmap, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & metafile_present) {
            WVTAsn1GetOctetString(&pOssImage->metafile, dwFlags,
                &pImage->Metafile, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & enhancedMetafile_present) {
            WVTAsn1GetOctetString(&pOssImage->enhancedMetafile, dwFlags,
                &pImage->EnhancedMetafile, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & gifFile_present) {
            WVTAsn1GetOctetString(&pOssImage->gifFile, dwFlags,
                &pImage->GifFile, &pbExtra, &lRemainExtra);
        }

    }

    if (pOssInfo->bit_mask & logoLink_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->logoLink, dwFlags,
                &pInfo->pLogoLink, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcSpAgencyInformation_PDU, pOssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC Minimal Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ossBoolean OssInfo = (ossBoolean) *pInfo;
    return WVTAsn1InfoEncode(
        SpcMinimalCriteria_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SPC Minimal Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    ossBoolean *pOssInfo = NULL;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if ((fResult = WVTAsn1InfoDecodeAndAlloc(
            SpcMinimalCriteria_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))) {
        if (*pcbInfo < sizeof(BOOL)) {
            if (pInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else
            *pInfo = (BOOL) *pOssInfo;
        *pcbInfo = sizeof(BOOL);
    } else {
        if (*pcbInfo >= sizeof(BOOL))
            *pInfo = FALSE;
        *pcbInfo = 0;
    }

    WVTAsn1InfoFree(SpcMinimalCriteria_PDU, pOssInfo);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC Financial Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    SpcFinancialCriteria OssInfo;
    OssInfo.financialInfoAvailable =
        (ossBoolean) pInfo->fFinancialInfoAvailable;
    OssInfo.meetsCriteria = (ossBoolean) pInfo->fMeetsCriteria;

    return WVTAsn1InfoEncode(
        SpcFinancialCriteria_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SPC Financial Criteria Info Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcFinancialCriteria *pOssInfo = NULL;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if ((fResult = WVTAsn1InfoDecodeAndAlloc(
            SpcFinancialCriteria_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))) {
        if (*pcbInfo < sizeof(SPC_FINANCIAL_CRITERIA)) {
            if (pInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else {
            pInfo->fFinancialInfoAvailable =
                (BOOL) pOssInfo->financialInfoAvailable;
            pInfo->fMeetsCriteria = (BOOL) pOssInfo->meetsCriteria;
        }
        *pcbInfo = sizeof(SPC_FINANCIAL_CRITERIA);
    } else
        *pcbInfo = 0;

    WVTAsn1InfoFree(SpcFinancialCriteria_PDU, pOssInfo);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC statement type attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcStatementTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cId;
    LPSTR *ppszId;
    SpcStatementType OssInfo;
    ObjectID *pOssId;

    cId = pInfo->cKeyPurposeId;
    ppszId = pInfo->rgpszKeyPurposeId;
    OssInfo.count = cId;
    OssInfo.value = NULL;

    if (cId > 0) {
        pOssId = (ObjectID *) SpcAsnAlloc(cId * sizeof(ObjectID));
        if (pOssId == NULL)
            goto ErrorReturn;
        memset(pOssId, 0, cId * sizeof(ObjectID));
        OssInfo.value = pOssId;
    }

    // Array of Object Ids
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        if (!WVTAsn1SetObjId(*ppszId, pOssId))
            goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(
        SpcStatementType_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (OssInfo.value)
        SpcAsnFree(OssInfo.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC statement type attribute value Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcStatementTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcStatementType *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    DWORD cId;
    LPSTR *ppszId;
    ObjectID *pOssId;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcStatementType_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_STATEMENT_TYPE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(SPC_STATEMENT_TYPE);

    cId = pOssInfo->count;
    pOssId = pOssInfo->value;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cKeyPurposeId = cId;
        ppszId = (LPSTR *) pbExtra;
        pInfo->rgpszKeyPurposeId = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    // Array of Object Ids
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        WVTAsn1GetObjId(pOssId, dwFlags, ppszId, &pbExtra, &lRemainExtra);
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcStatementType_PDU, pOssInfo);
    return fResult;
}


//+-------------------------------------------------------------------------
//  SPC SP Opus info attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpOpusInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcSpOpusInfo OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pwszProgramName) {
        WVTAsn1SetSpcString((LPWSTR) pInfo->pwszProgramName, &OssInfo.programName);
        OssInfo.bit_mask |= programName_present;
    }

    if (pInfo->pMoreInfo) {
        if (!WVTAsn1SetSpcLink(pInfo->pMoreInfo, &OssInfo.moreInfo))
            goto ErrorReturn;
        OssInfo.bit_mask |= moreInfo_present;
    }
    if (pInfo->pPublisherInfo) {
        if (!WVTAsn1SetSpcLink(pInfo->pPublisherInfo, &OssInfo.publisherInfo))
            goto ErrorReturn;
        OssInfo.bit_mask |= publisherInfo_present;
    }

    fResult = WVTAsn1InfoEncode(
        SpcSpOpusInfo_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.moreInfo);
    WVTAsn1FreeSpcLink(&OssInfo.publisherInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC SP Opus info attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpOpusInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcSpOpusInfo *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcSpOpusInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SP_OPUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_SP_OPUS_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_SP_OPUS_INFO);
    }

    if (pOssInfo->bit_mask & programName_present) {
        WVTAsn1GetSpcString(&pOssInfo->programName, dwFlags,
            (LPWSTR*) &pInfo->pwszProgramName, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & moreInfo_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->moreInfo, dwFlags,
                &pInfo->pMoreInfo, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }
    if (pOssInfo->bit_mask & publisherInfo_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->publisherInfo, dwFlags,
                &pInfo->pPublisherInfo, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcSpOpusInfo_PDU, pOssInfo);
    return fResult;
}

BOOL WINAPI WVTAsn1SpcLinkEncode(   IN DWORD dwCertEncodingType,
                                    IN LPCSTR lpszStructType,
                                    IN PSPC_LINK pInfo,
                                    OUT BYTE *pbEncoded,
                                    IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcLink OssSpcLink;

    if (!(WVTAsn1SetSpcLink(pInfo, &OssSpcLink)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(SpcLink_PDU, &OssSpcLink, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcLinkDecode(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN const BYTE *pbEncoded,
                                 IN DWORD cbEncoded,
                                 IN DWORD dwFlags,
                                 OUT PSPC_LINK pInfo,
                                 IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    SpcLink *pSpcLink = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(SpcLink_PDU, pbEncoded, cbEncoded,
                                (void **)&pSpcLink)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_LINK);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(SPC_LINK);
    }

    if (!(WVTAsn1GetSpcLink(pSpcLink, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcLink_PDU, pSpcLink);
    return fResult;
}


BOOL WINAPI WVTAsn1SpcPeImageDataEncode(IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN PSPC_PE_IMAGE_DATA pInfo,
                                        OUT BYTE *pbEncoded,
                                        IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcPeImageData OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->Flags.cbData)
    {
        // SpcPeImageFlags has its own definition. It has a default
        // bit (includeResources). Therefore, can't use the default BITSTRING.
        // Note: BITSTRING's length is an unsigned int, while SpcPeImageFlags's
        // length is an unsigned short.
        BITSTRING OssBitString;
        WVTAsn1SetBit(&pInfo->Flags, &OssBitString);
        OssInfo.flags.length = (WORD)OssBitString.length;
        OssInfo.flags.value = OssBitString.value;
        OssInfo.bit_mask |= flags_present;
    }

    if (pInfo->pFile)
    {
        if (!WVTAsn1SetSpcLink(pInfo->pFile, &OssInfo.file))
        {
            goto ErrorReturn;
        }

        OssInfo.bit_mask |= file_present;
    }

    fResult = WVTAsn1InfoEncode(SpcPeImageData_PDU, &OssInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.file);
    return(fResult);
}

//+-------------------------------------------------------------------------
//  SPC Portable Executable (PE) Image Attribute Value Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcPeImageDataDecode(IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN const BYTE *pbEncoded,
                                        IN DWORD cbEncoded,
                                        IN DWORD dwFlags,
                                        OUT PSPC_PE_IMAGE_DATA pInfo,
                                        IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    SpcPeImageData *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!WVTAsn1InfoDecodeAndAlloc(SpcPeImageData_PDU, pbEncoded, cbEncoded,
                                (void **)&pOssInfo))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_PE_IMAGE_DATA);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_PE_IMAGE_DATA));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_PE_IMAGE_DATA);
    }

    if (pOssInfo->bit_mask & flags_present)
    {
        // See above encode for why we need to do this extra indirect step
        BITSTRING OssBitString;
        OssBitString.length = pOssInfo->flags.length;
        OssBitString.value = pOssInfo->flags.value;
        WVTAsn1GetBit(&OssBitString, dwFlags,
            &pInfo->Flags, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & file_present)
    {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->file, dwFlags,
                &pInfo->pFile, &pbExtra, &lRemainExtra))
        {
            goto ErrorReturn;
        }
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcPeImageData_PDU, pOssInfo);
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcSigInfoEncode(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                    PSPC_SIGINFO pInfo, BYTE *pbEncoded,
                                    DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcSigInfo OssSpcSigInfo;

    if (!(WVTAsn1SetSpcSigInfo(pInfo, &OssSpcSigInfo)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(SpcSigInfo_PDU, &OssSpcSigInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcSigInfoDecode(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                    const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags,
                                    PSPC_SIGINFO pInfo, OUT DWORD *pcbInfo)
{
    BOOL        fResult;
    SpcSigInfo  *pSpcSigInfo = NULL;
    BYTE        *pbExtra;
    LONG        lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(SpcSigInfo_PDU, pbEncoded, cbEncoded, (void **)&pSpcSigInfo)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SIGINFO);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(SPC_SIGINFO);
    }

    if (!(WVTAsn1GetSpcSigInfo(pSpcSigInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcSigInfo_PDU, pSpcSigInfo);
    return fResult;
}

BOOL WVTAsn1SetCatNameValue(IN PCAT_NAMEVALUE pInfo, OUT NameValue *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));


    //  tag!
    WVTAsn1SetBMP(pInfo->pwszTag, &pOss->refname);

    //  flags
    pOss->typeaction = (int)pInfo->fdwFlags;

    //  value
    WVTAsn1SetOctetString(&pInfo->Value, &pOss->value);

    return(TRUE);
}

BOOL WVTAsn1SetCatMemberInfo(IN PCAT_MEMBERINFO pInfo, OUT MemberInfo *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));


    //  subject guid (wide text)
    WVTAsn1SetBMP(pInfo->pwszSubjGuid, &pOss->subguid);

    // cert version
    pOss->certversion = (int)pInfo->dwCertVersion;


    return(TRUE);
}


BOOL WVTAsn1GetCatNameValue(IN NameValue *pOss, IN DWORD dwFlags,
                                    OUT PCAT_NAMEVALUE pInfo, IN OUT BYTE **ppbExtra,
                                    IN OUT LONG *plRemainExtra)
{
    if (*plRemainExtra >= 0)
    {
        memset(pInfo, 0, sizeof(*pInfo));
    }

    WVTAsn1GetOctetString(&pOss->value, dwFlags,
                          &pInfo->Value, ppbExtra, plRemainExtra);

    if (*plRemainExtra >= 0)
    {
        pInfo->fdwFlags = (DWORD)pOss->typeaction;
    }

    WVTAsn1GetBMP(&pOss->refname, dwFlags, &pInfo->pwszTag, ppbExtra, plRemainExtra);

    return(TRUE);
}

BOOL WVTAsn1GetCatMemberInfo(IN MemberInfo *pOss, IN DWORD dwFlags,
                                    OUT PCAT_MEMBERINFO pInfo, IN OUT BYTE **ppbExtra,
                                    IN OUT LONG *plRemainExtra)
{
    if (*plRemainExtra >= 0)
    {
        memset(pInfo, 0, sizeof(*pInfo));
    }

    WVTAsn1GetBMP(&pOss->subguid, dwFlags, &pInfo->pwszSubjGuid, ppbExtra, plRemainExtra);

    if (*plRemainExtra >= 0)
    {
        pInfo->dwCertVersion = pOss->certversion;
    }


    return(TRUE);
}


BOOL WINAPI WVTAsn1CatNameValueEncode(   IN DWORD dwCertEncodingType,
                                    IN LPCSTR lpszStructType,
                                    IN PCAT_NAMEVALUE pInfo,
                                    OUT BYTE *pbEncoded,
                                    IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    NameValue   OssNameValue;

    if (!(WVTAsn1SetCatNameValue(pInfo, &OssNameValue)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(NameValue_PDU, &OssNameValue, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1CatMemberInfoEncode( IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN PCAT_MEMBERINFO pInfo,
                                        OUT BYTE *pbEncoded,
                                        IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    MemberInfo OssMemberInfo;

    if (!(WVTAsn1SetCatMemberInfo(pInfo, &OssMemberInfo)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(MemberInfo_PDU, &OssMemberInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}


BOOL WINAPI WVTAsn1CatNameValueDecode(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN const BYTE *pbEncoded,
                                 IN DWORD cbEncoded,
                                 IN DWORD dwFlags,
                                 OUT PCAT_NAMEVALUE pInfo,
                                 IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    NameValue   *pNameValue = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(NameValue_PDU, pbEncoded, cbEncoded,
                                (void **)&pNameValue)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CAT_NAMEVALUE);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(CAT_NAMEVALUE);
    }

    if (!(WVTAsn1GetCatNameValue(pNameValue, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(NameValue_PDU, pNameValue);
    return fResult;
}


BOOL WINAPI WVTAsn1CatMemberInfoDecode( IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN const BYTE *pbEncoded,
                                        IN DWORD cbEncoded,
                                        IN DWORD dwFlags,
                                        OUT PCAT_MEMBERINFO pInfo,
                                        IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    MemberInfo   *pMemberInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(MemberInfo_PDU, pbEncoded, cbEncoded,
                                (void **)&pMemberInfo)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CAT_MEMBERINFO);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(CAT_MEMBERINFO);
    }

    if (!(WVTAsn1GetCatMemberInfo(pMemberInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(MemberInfo_PDU, pMemberInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wintrust.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\provload.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       provload.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef PROVLOAD_H
#define PROVLOAD_H

typedef struct _LOADED_PROVIDER 
{

    struct _LOADED_PROVIDER             *pNext;
    struct _LOADED_PROVIDER             *pPrev;
    GUID                                gActionID;

    HINSTANCE                           hInitDLL;
    HINSTANCE                           hObjectDLL;
    HINSTANCE                           hSignatureDLL;
    HINSTANCE                           hCertTrustDLL;
    HINSTANCE                           hFinalPolicyDLL;
    HINSTANCE                           hCertPolicyDLL;
    HINSTANCE                           hTestFinalPolicyDLL;
    HINSTANCE                           hCleanupPolicyDLL;

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy 
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info to the msg
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;

} LOADED_PROVIDER, *PLOADED_PROVIDER;


extern BOOL WintrustUnloadProviderList(void);

#endif // PROVLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\provider.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 19