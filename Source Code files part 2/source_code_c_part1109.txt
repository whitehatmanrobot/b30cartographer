DEVICE_OBJECT deviceObject = NULL;
    
    WmiSampRegistryPath.Length = 0;
    WmiSampRegistryPath.MaximumLength = RegistryPath->Length;
    WmiSampRegistryPath.Buffer = ExAllocatePool(PagedPool, 
                                                RegistryPath->Length+2);
    RtlCopyUnicodeString(&WmiSampRegistryPath, RegistryPath);

    /*
    // Create dispatch points for the various events handled by this
    // driver.  For example, device I/O control calls (e.g., when a Win32
    // application calls the DeviceIoControl function) will be dispatched to
    // routine specified below in the IRP_MJ_DEVICE_CONTROL case.
    //
    // For more information about the IRP_XX_YYYY codes, please consult the
    // Windows NT DDK documentation.
    //
    */
    DriverObject->MajorFunction[IRP_MJ_CREATE] = WmiSampForward;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = WmiSampForward;
    DriverObject->DriverUnload = WmiSampUnload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = WmiSampForward;

    DriverObject->MajorFunction[IRP_MJ_PNP] = WmiSampPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = WmiSampForward;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = WmiSampSystemControl;
    DriverObject->DriverExtension->AddDevice = WmiSampAddDevice;

    return ntStatus;
}

NTSTATUS
WmiSampSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{	
    return(IoWMISystemControl((PWMILIB_INFO)DeviceObject->DeviceExtension,
                               DeviceObject,
                               Irp));
}


NTSTATUS
WmiSampPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PWMILIB_INFO wmilibInfo;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    wmilibInfo = (PWMILIB_INFO)DeviceObject->DeviceExtension;

    switch (irpStack->MinorFunction) 
    {
        case IRP_MN_START_DEVICE:
	{
            IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);
            break; //IRP_MN_START_DEVICE
        }
	
        case IRP_MN_REMOVE_DEVICE:
	{
            IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);
	    
            IoDetachDevice(wmilibInfo->LowerDeviceObject);
            IoDeleteDevice (DeviceObject);
	    
            break; //IRP_MN_REMOVE_DEVICE
        }
    }
    
    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(wmilibInfo->LowerDeviceObject, Irp);
    
    return(status);
}


NTSTATUS
WmiSampForward(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PWMILIB_INFO wmilibInfo;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    wmilibInfo = (PWMILIB_INFO)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    
    status = IoCallDriver(wmilibInfo->LowerDeviceObject, Irp);
    
    return(status);
}


VOID
WmiSampUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.
    TODO: This is a placeholder for driver writer to add code on unload

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    ExFreePool(WmiSampRegistryPath.Buffer);
}



NTSTATUS
WmiSampCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    )
/*++

Routine Description:
    Creates a Functional DeviceObject

Arguments:
    DriverObject - pointer to the driver object for device
    DeviceObject - pointer to DeviceObject pointer to return
                   created device object.
    Instance - instnace of the device create.

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise
--*/
{
    NTSTATUS status;
    WCHAR deviceNameBuffer[]  = L"\\Device\\Sample-0";
    UNICODE_STRING deviceNameUnicodeString;

    deviceNameBuffer[15] = (USHORT) ('0' + Instance);

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);

    status = IoCreateDevice (DriverObject,
                               sizeof(WMILIB_INFO),
                               &deviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               DeviceObject);


    return status;
}


ULONG Instance;

NTSTATUS
WmiSampAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of Sample
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = NULL;
    PWMILIB_INFO            wmilibInfo;

    DbgBreakPoint();
    
    // create our functional device object (FDO)
    status = WmiSampCreateDeviceObject(DriverObject, &deviceObject, Instance++);

    if (NT_SUCCESS(status)) {
        wmilibInfo = deviceObject->DeviceExtension;

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
        // Add more flags here if your driver supports other specific
        // behavior.  For example, if your IRP_MJ_READ and IRP_MJ_WRITE
        // handlers support DIRECT_IO, you would set that flag here.
        //
        // Also, store away the Physical device Object
        */
        wmilibInfo->LowerPDO = PhysicalDeviceObject;

        //
        // Attach to the StackDeviceObject.  This is the device object that what we 
        // use to send Irps and Urbs down the USB software stack
        //
        wmilibInfo->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    	wmilibInfo->GuidCount = 1;
    	wmilibInfo->GuidList = WmiSampGuidList;
		wmilibInfo->QueryWmiRegInfo = WmiSampQueryWmiRegInfo;
		wmilibInfo->QueryWmiDataBlock = WmiSampQueryWmiDataBlock;
		wmilibInfo->SetWmiDataBlock = WmiSampSetWmiDataBlock;
		wmilibInfo->SetWmiDataItem = WmiSampSetWmiDataItem;
		wmilibInfo->ExecuteWmiMethod = WmiSampExecuteWmiMethod;
		wmilibInfo->WmiFunctionControl = WmiSampFunctionControl; 
    }
    return(status);
}


NTSTATUS
WmiSampQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call 
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered 
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case 
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.
            
    InstanceName returns with the instance name for the guids if 
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver
        
Return Value:

    status

--*/
{
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &WmiSampRegistryPath;
    return(STATUS_SUCCESS);
}

NTSTATUS
WmiSampQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    BufferAvail on has the maximum size available to write the data
        block. 
            
    Buffer on return is filled with the returned data block
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG sizeNeeded;
    
    switch (GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferAvail >= sizeNeeded)
            {
                RtlCopyMemory(Buffer, WmiSampDummyData, sizeNeeded);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }
        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
                
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    BufferSize has the size of the data block passed
            
    Buffer has the new values for the data block
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG sizeNeeded;
    
    switch(GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferSize == sizeNeeded)
              {
                RtlCopyMemory(WmiSampDummyData, Buffer, sizeNeeded);
                status = STATUS_SUCCESS;
               } else {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }
            
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
            
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    DataItemId has the id of the data item being set
        
    BufferSize has the size of the data item passed
            
    Buffer has the new values for the data item
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    
    switch(GuidIndex)
    {
        case 0:
        {
            if ((BufferSize == sizeof(ULONG)) &&
                (DataItemId <= 3))
              {
                  WmiSampDummyData[DataItemId] = *((PULONG)Buffer);
                   status = STATUS_SUCCESS;
               } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
               }
            break;
        }
            
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
        
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}


NTSTATUS
WmiSampExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the 
    driver has finished filling the data block it must call 
    ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request
        
    GuidIndex is the index into the list of guids provided when the
        device registered
            
    MethodId has the id of the method being called
            
    InBufferSize has the size of the data block passed in as the input to
        the method.
            
    OutBufferSize on entry has the maximum size available to write the
        returned data block. 
            
    Buffer is filled with the returned data block
            
        
Return Value:

    status

--*/
{
    ULONG sizeNeeded = 4 * sizeof(ULONG);
    NTSTATUS status;
    ULONG tempData[4];
    
    switch(GuidIndex)
    {
        case 0:
        {
            if (MethodId == 1)
            {            
                if (OutBufferSize >= sizeNeeded)
                {
        
                    if (InBufferSize == sizeNeeded)
                    {
                        RtlCopyMemory(tempData, Buffer, sizeNeeded);
                        RtlCopyMemory(Buffer, WmiSampDummyData, sizeNeeded);
                        RtlCopyMemory(WmiSampDummyData, tempData, sizeNeeded);
                
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }        
            break;
        }
        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a 
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    GuidIndex is the index into the list of guids provided when the
        device registered
            
    Function specifies which functionality is being enabled or disabled
            
    Enable is TRUE then the function is being enabled else disabled
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\sources.inc ===
!include $(PROJECT_ROOT)\prerelease.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\animate.h ===
#ifndef _ANIMATE_H_
#define _ANIMATE_H_

extern UINT    g_uiAnimateIndex;
extern UINT    g_uiLastAnimateIndex;

BOOL InitAnimate(HWND hwnd, HDC hdc);
void Animate(HDC hdc);
void AnimateNext();
void TerminateAnimate();

#define LEFT    0
#define CENTER  1

BOOL DisplayString(
    HDC         hdc,
    int         x,
    int         y,
    TEXTMETRIC* lptm,
    int         iLineSpace, 
    RECT*       lprc,
    LPINT       pNumLines,
    LPTSTR      szTextOut,
    WORD wfPlacement
    );

int WrapText(
    IN HDC          hdc,
    IN int          x,
    IN RECT*        lprc,
    IN OUT LPTSTR   szBBResource);

BOOL DrawWrapText(
    IN HDC          hdc,
    IN TEXTMETRIC*  lptm,
    IN int          iLineSpace, 
    IN int          x,
    IN int          y,
    IN RECT*        lprc,
    IN WORD         wfPlacement,
    IN int          iLineCount,
    IN LPTSTR       szLines);

VOID ImproveWrap(
    IN OUT LPTSTR szLines,
    IN OUT PINT   piNumLine,
    IN     LPTSTR szOrigText,
    IN     INT    cchOrigText
    );

#endif _ANIMATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\billbrd.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include <commctrl.h>
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

#ifdef  DBG

void _BB_Assert(LPCTSTR strFile, unsigned uLine)
{
    TCHAR   buf[512];
    
    wsprintf(buf, TEXT("Assertion failed: %s, line %u\n"),
        strFile, uLine);

    OutputDebugString(buf);    
}

#endif

#define     BILLBRD_TEXT_TIMERID        1
#define     WHISTLER_PROGRESS_TIMERID   2


// For how long is the text for the Billboard displayed
// before switching to the next text
#define BB_TEXT_DISPLAY   36000

// For how long is the whistler status move, in millis seconds
#define BB_WHISTLER_MOVE  100

// Name to the INI file which discribes the billboards
TCHAR g_szFileName[MAX_PATH];

// Path where to find the billboard bitmaps.
TCHAR g_szPath[MAX_PATH];

// this application instance
HINSTANCE g_hInstance = NULL;

// charset properties of font used by this application
BYTE g_bCharSet = 0;
BOOL g_bBiDi    = FALSE;


/**********************************************************************************
-----------------------------------------------------------------------------------
(LOGO)                      (banner)
-----------------------------------------------------------------------------------
STEP                         |BILLBRD (GetBBHwd)
                             |
                             |
                             |
-----------------------------|
ESTIMATE (TimeEstimate)      |
-----------------------------|
PROGRESSTEXT (ProgressText)  |
-----------------------------|
GAUGE (ProgressGauge)        |
-----------------------------|
INFOTEXT (InfoText)          |
                             |
-----------------------------------------------------------------------------------
                            (banner)
-----------------------------------------------------------------------------------

INFOBAR = STEP, ESTIMATE, GAUGE, PROGRESSTEXT and INFOTEXT

NOTE:
    Position of setup wizard is dependent on the the size and position of
    BILLBRD.
***********************************************************************************/
UINT g_cyBannerHeight = 0;
UINT g_cxLogo = 0;
UINT g_cyLogo = 0;
UINT g_cxInfoBarWidth  = 0;
UINT g_cyInfoBarHeight = 0;
UINT g_cxSteps         = 0;
UINT g_cySteps         = 0;
UINT g_cxStepsWidth    = 0;
UINT g_cyStepsHeight   = 0;
UINT g_cxProgressText          = 0;
UINT g_cyProgressText          = 0;
UINT g_cxProgressTextWidth     = 0;
UINT g_cyProgressTextHeight    = 0;
UINT g_cxGauge         = 0;
UINT g_cyGauge         = 0;
UINT g_cxGaugeWidth    = 0;
UINT g_cyGaugeHeight   = 0;
UINT g_cxEstimate          = 0;
UINT g_cyEstimate          = 0;
UINT g_cxEstimateWidth     = 0;
UINT g_cyEstimateHeight    = 0;
UINT g_cxInfoText           = 0;
UINT g_cyInfoText           = 0;
UINT g_cxInfoTextWidth      = 0;
UINT g_cyInfoTextHeight     = 0;
UINT g_cxBillBrd           = 0;
UINT g_cyBillBrd           = 0;
UINT g_cxBillBrdWidth      = 0;
UINT g_cyBillBrdHeight     = 0;
UINT g_cxBillBrdHMargin    = 0;
UINT g_cyBillBrdVMargin    = 0;
UINT g_cxBillBrdTitleWidth = 0;
UINT g_cyBillBrdTitleTop   = 0;
UINT g_cxBillBrdBodyWidth  = 0;

HWND g_hwndParent       = NULL;      // Parent of g_hwnd
HWND g_hwnd             = NULL;      // Parent of all the following windows
HWND g_hwndTimeEstimate = NULL;      // 'TIMEESTIMATE'
HWND g_hwndProgressText = NULL;      // 'PROGRESSTEXT'
HWND g_hwndProgressGauge= NULL;      // 'GAUGE'
HWND g_hwndInfoText     = NULL;      // 'INFOTEXT'
HWND g_hwndBB           = NULL;      // 'BILLBRD'
HWND g_hwndSteps        = NULL;      // 'STEP'
HWND g_hwndLogo         = NULL;      // 'LOGO'
HWND g_hwndStatus       = NULL;

UINT g_idbLogo           = 0;
UINT g_numBackground     = 0;
UINT g_idbBackground[3]  = {0, 0, 0};
UINT g_idbSelectedBullet = 0;
UINT g_idbReleasedBullet = 0;
UINT g_idbCurrentBullet  = 0;

const TCHAR g_cszClassName[]        = TEXT("RedCarpetWndClass");
const TCHAR g_szStepsClassName[]    = TEXT("InfoStepsWnd_Class");
const TCHAR g_szBillBoardClassName[]= TEXT("BillBoardWnd_Class");
const TCHAR g_szStatusClassName[]   = TEXT("BB_WhistlerStatus_Class");

LRESULT CALLBACK RedCarpetWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK BillBoardWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK AnimationWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK StatusSubClassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ProgressSubClassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//----------
// BILLBRD
//----------
TCHAR   g_szTFont[32];
int     g_nTFontHeight;
int     g_nTFontWidth;
int     g_nTFontWeight;
BOOL    g_bTitleShadow = TRUE;
TCHAR   g_szBFont[32];
int     g_nBFontHeight;
int     g_nBFontWidth;
int     g_nBFontWeight;
BOOL    g_bTextShadow  = FALSE;
int     g_nBLineSpace;

int     g_nAnimID     = 0;
int     g_iCurPanel   = -1;           // Current billboard to show
int     g_nPanelCount = 0;            // how many billboards are there
int     g_nLogPixelsY = 1;

COLORREF g_colTitle       = 0;
COLORREF g_colTitleShadow = 0;
COLORREF g_colText        = 0;
COLORREF g_colTextShadow  = 0;


BB_TEXT bb_text_Personal[] = {
    {IDS_TITLE1_PER, IDS_TEXT1_PER, IDB_COLL1},
    {IDS_TITLE2_PER, IDS_TEXT2_PER, IDB_COLL2},
    {IDS_TITLE3_PER, IDS_TEXT3_PER, IDB_COLL2},
    {IDS_TITLE4_PER, IDS_TEXT4_PER, IDB_COLL3},
    {IDS_TITLE5_PER, IDS_TEXT5_PER, IDB_COLL3},
    {IDS_TITLE22_PER, IDS_TEXT22_PER, IDB_COLL10},
    {IDS_TITLE6_PER, IDS_TEXT6_PER, IDB_COLL4},
    {IDS_TITLE7_PER, IDS_TEXT7_PER, IDB_COLL4},
    {IDS_TITLE8_PER, IDS_TEXT8_PER, IDB_COLL5},
    {IDS_TITLE9_PER, IDS_TEXT9_PER, IDB_COLL5},
    {IDS_TITLE10_PER, IDS_TEXT10_PER, IDB_COLL6},
    {IDS_TITLE11_PER, IDS_TEXT11_PER, IDB_COLL6},
    {IDS_TITLE12_PER, IDS_TEXT12_PER, IDB_COLL7},
    {IDS_TITLE13_PER, IDS_TEXT13_PER, IDB_COLL7},
    {IDS_TITLE14_PER, IDS_TEXT14_PER, IDB_COLL8},
    {IDS_TITLE15_PER, IDS_TEXT15_PER, IDB_COLL8},
    {IDS_TITLE16_PER, IDS_TEXT16_PER, IDB_COLL9},
    {IDS_TITLE17_PER, IDS_TEXT17_PER, IDB_COLL9},
    {IDS_TITLE18_PER, IDS_TEXT18_PER, IDB_COLL10},
    {IDS_TITLE19_PER, IDS_TEXT19_PER, IDB_COLL10},
    {IDS_TITLE20_PER, IDS_TEXT20_PER, IDB_COLL10},
    {IDS_TITLE21_PER, IDS_TEXT21_PER, IDB_COLL10},
    {0,0,0}
};

BB_TEXT bb_text_Professional[] = {
    {IDS_TITLE1, IDS_TEXT1, IDB_COLL1},
    {IDS_TITLE2, IDS_TEXT2, IDB_COLL2},
    {IDS_TITLE3, IDS_TEXT3, IDB_COLL2},
    {IDS_TITLE4, IDS_TEXT4, IDB_COLL3},
    {IDS_TITLE5, IDS_TEXT5, IDB_COLL3},
    {IDS_TITLE6, IDS_TEXT6, IDB_COLL4},
    {IDS_TITLE7, IDS_TEXT7, IDB_COLL4},
    {IDS_TITLE8, IDS_TEXT8, IDB_COLL5},
    {IDS_TITLE9, IDS_TEXT9, IDB_COLL5},
    {IDS_TITLE18, IDS_TEXT18, IDB_COLL9},
    {IDS_TITLE10, IDS_TEXT10, IDB_COLL6},
    {IDS_TITLE11, IDS_TEXT11, IDB_COLL6},
    {IDS_TITLE12, IDS_TEXT12, IDB_COLL7},
    {IDS_TITLE13, IDS_TEXT13, IDB_COLL7},
    {IDS_TITLE14, IDS_TEXT14, IDB_COLL8},
    {IDS_TITLE15, IDS_TEXT15, IDB_COLL8},
    {IDS_TITLE16, IDS_TEXT16, IDB_COLL9},
    {IDS_TITLE17, IDS_TEXT17, IDB_COLL9},
    {0,0,0}
};

BB_TEXT bb_text_Blade[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {0,0,0}
};

BB_TEXT bb_text_Server[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {0,0,0}
};

BB_TEXT bb_text_AdvancedServer[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {0,0,0}
};

BB_TEXT bb_text_DataCenter[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {0,0,0}
};

BB_TEXT bb_text_Professional_IA64[] = {
    {IDS_TITLE1_64PRO, IDS_TEXT1_64PRO, IDB_COLL1},
    {IDS_TITLE2_64PRO, IDS_TEXT2_64PRO, IDB_COLL2},
    {IDS_TITLE3_64PRO, IDS_TEXT3_64PRO, IDB_COLL2},
    {IDS_TITLE4_64PRO, IDS_TEXT4_64PRO, IDB_COLL3},
    {IDS_TITLE5_64PRO, IDS_TEXT5_64PRO, IDB_COLL3},
    {IDS_TITLE6_64PRO, IDS_TEXT6_64PRO, IDB_COLL4},
    {IDS_TITLE7_64PRO, IDS_TEXT7_64PRO, IDB_COLL4},
    {IDS_TITLE8_64PRO, IDS_TEXT8_64PRO, IDB_COLL5},
    {IDS_TITLE9_64PRO, IDS_TEXT9_64PRO, IDB_COLL5},
    {IDS_TITLE10_64PRO, IDS_TEXT10_64PRO, IDB_COLL6},
    {IDS_TITLE11_64PRO, IDS_TEXT11_64PRO, IDB_COLL6},
    {IDS_TITLE12_64PRO, IDS_TEXT12_64PRO, IDB_COLL7},
    {IDS_TITLE13_64PRO, IDS_TEXT13_64PRO, IDB_COLL7},
    {0,0,0}
};

// 0 - professional,
// 1 - Server, 
// 2 - Advanced Server,
// 3 - Data Center,
// 4 - for personal
// 5 - for Blade
DWORD    dwBBTextType = 0; 

// Be careful with this order. It has to be the same as 
// *_PRODUCTTYPE in winnt32.h
#ifdef _X86_
BB_TEXT* bb_text[] = { bb_text_Professional,
                       bb_text_Server,
                       bb_text_AdvancedServer,
                       bb_text_DataCenter,
                       bb_text_Personal,
                       bb_text_Blade};
#else
BB_TEXT* bb_text[] = { bb_text_Professional_IA64,
                       bb_text_Server,
                       bb_text_AdvancedServer,
                       bb_text_DataCenter,
                       bb_text_Personal };
#endif

HDC     g_hdcBbMem     = NULL;
HBITMAP g_hbmpBbMemOld = NULL;

HDC 
GetBillboardBuffer();

BOOL
BufferBillboard(
    IN  HWND   hwnd,
    IN  HDC    hdc
    );

VOID
DestroyBillboardBuffer();

//---------
// INFOBAR
//---------
COLORREF g_colInfoText        = 0;
COLORREF g_colStepsTxt        = 0;
COLORREF g_colStepsMarkTxt    = 0;
COLORREF g_colStepsCurrentTxt = 0;
COLORREF g_colStepsTitle      = 0;
COLORREF g_colGaugeBg         = 0;
COLORREF g_colGauge           = 0;
COLORREF g_colBulletTrans     = 0;

//-------------
// TIMEESTIMATE
//-------------
// Original position of the progress text window
// Since we want the text adjusted to the bottom of the window
// we resize the window as needed, but should not grow it 
// beyond the original size.
RECT g_rcProgressText;

//-----
// LOGO
//-----
HBITMAP g_hbmWinLogo  = NULL;
COLORREF g_colLogoTransparency = RGB(0, 0, 0);
COLORREF g_colStatusTransperency = RGB(0, 0, 0);

//-----------
// background
//-----------
HDC     g_hdcMem     = NULL;
HBITMAP g_hbmpMemOld = NULL;
INT     g_iStretchMode = STRETCH_ANDSCANS;


BOOL
BufferBackground(
    IN  HWND   hwnd
    );

LRESULT
OnEraseBkgnd(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
DestroyBackgroundBuffer();

HBITMAP
MyLoadImage(
    IN HDC    hdc,
    IN UINT*  idbBackground,
    IN int    iNumImage
    );

void SetFontCharSet(void)
{
    HFONT   hFont = NULL;
    LOGFONT lf;

    //init font charset
    hFont = GetStockObject(SYSTEM_FONT);
    if(hFont)
    {
        if(GetObject(hFont, sizeof(lf), &lf))
            g_bCharSet = lf.lfCharSet;
        DeleteObject(hFont);
    }
}

void SetFontColor(HWND hwnd)
{
    HDC  hdc;
    UINT uiBitsPixel;

    hdc = GetDC(hwnd);
    uiBitsPixel = (UINT) GetDeviceCaps(hdc, BITSPIXEL);

    if (uiBitsPixel > 8)
    {
        g_colTitle = COLOR_TITLE_C16BIT;
        g_colTitleShadow = COLOR_SHADOW_C16BIT;
        g_colText = COLOR_TEXT_C16BIT;
        g_colTextShadow = COLOR_SHADOW_C16BIT;
        g_colInfoText = UI_INFOTEXT_COLOR_C16BIT;
        g_colStepsTxt = UI_STEPSTEXT_COLOR_C16BIT;
        g_colStepsMarkTxt = UI_STEPSTEXT_MARK_COLOR_C16BIT;
        g_colStepsCurrentTxt = UI_STEPSTEXT_CURRENT_COLOR_C16BIT;
        g_colStepsTitle = UI_STEPSTITLE_COLOR_C16BIT;
        g_colGaugeBg = UI_GAUGE_BACKGROUND_COLOR_C16BIT;
        g_colGauge = UI_GAUGE_COLOR_C16BIT;
        g_colStatusTransperency = UI_STATUS_TRANSPARENT_COLOR_C16BIT;
        g_colLogoTransparency = UI_LOGO_TRANSPARENT_COLOR_C16BIT;
        g_colBulletTrans = UI_BULLET_TRANPARENT_COLOR_C16BIT;
    } else {
        g_colTitle = COLOR_TITLE_C4BIT;
        g_colTitleShadow = COLOR_SHADOW_C4BIT;
        g_colText = COLOR_TEXT_C4BIT;
        g_colTextShadow = COLOR_SHADOW_C4BIT;
        g_colInfoText = UI_INFOTEXT_COLOR_C4BIT;
        g_colStepsTxt = UI_STEPSTEXT_COLOR_C4BIT;
        g_colStepsCurrentTxt = UI_STEPSTEXT_CURRENT_COLOR_C4BIT;
        g_colStepsMarkTxt = UI_STEPSTEXT_MARK_COLOR_C4BIT;
        g_colStepsTitle = UI_STEPSTITLE_COLOR_C4BIT;
        g_colGaugeBg = UI_GAUGE_BACKGROUND_COLOR_C4BIT;
        g_colGauge = UI_GAUGE_COLOR_C4BIT;
        g_colStatusTransperency = UI_STATUS_TRANSPARENT_COLOR_C4BIT;
        g_colLogoTransparency = UI_LOGO_TRANSPARENT_COLOR_C4BIT;
        g_colBulletTrans = UI_BULLET_TRANPARENT_COLOR_C4BIT;
    }

    ReleaseDC(hwnd, hdc);
}


typedef struct _RES_FONTSIZES {
    UINT    uiID;
    UINT    uiDefault;
} RES_FONTSIZES;

RES_FONTSIZES res_1024[] = {
    {IDS_TITLEFONTSIZE_1024, 24},
    {IDS_TITLEFONTWIDTH_1024, 0},
    {IDS_TEXTFONTSIZE_1024, 11},
    {IDS_TEXTFONTWIDTH_1024, 0}
};

RES_FONTSIZES res_800[] = {
    {IDS_TITLEFONTSIZE_800, 21},
    {IDS_TITLEFONTWIDTH_800, 0},
    {IDS_TEXTFONTSIZE_800, 10},
    {IDS_TEXTFONTWIDTH_800, 0}
};

RES_FONTSIZES res_640[] = {
    {IDS_TITLEFONTSIZE_640, 18},
    {IDS_TITLEFONTWIDTH_640, 0},
    {IDS_TEXTFONTSIZE_640, 9},
    {IDS_TEXTFONTWIDTH_640, 0}
};

void GetMyFontsFromFile()
{
    RECT          rc;
    int           iSize = 0;
    TCHAR         szBuf[25];
    RES_FONTSIZES *pres_fontsize = NULL;

    iSize = GetSystemMetrics(SM_CXSCREEN);

    if (iSize >= 1024)
    {
        pres_fontsize = res_1024;
    }
    else if (iSize == 800)
    {
        pres_fontsize = res_800;
    }
    else
    {
        pres_fontsize = res_640;
    }

    if (LoadString(g_hInstance, pres_fontsize[0].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontHeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontHeight = pres_fontsize[0].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[1].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontWidth = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontWidth = pres_fontsize[1].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[2].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontHeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontHeight = pres_fontsize[2].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[3].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontWidth = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontWidth = pres_fontsize[3].uiDefault;


    if (!(LoadString(g_hInstance, IDS_TITLEFONTNAME, (LPTSTR)g_szTFont, sizeof(g_szTFont)/sizeof(TCHAR))))
        lstrcpy(g_szTFont, TEXT("Arial"));

    if (LoadString(g_hInstance, IDD_TITLEFONTWEIGHT, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontWeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontWeight = FW_BOLD;

    if (!(LoadString(g_hInstance, IDS_TEXTFONTNAME, (LPTSTR)g_szBFont, sizeof(g_szBFont)/sizeof(TCHAR))))
        lstrcpy(g_szBFont, TEXT("Arial"));

    if (LoadString(g_hInstance, IDD_TEXTFONTWEIGHT, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontWeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontWeight = FW_BOLD;

    if (LoadString(g_hInstance, IDD_BIDI, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_bBiDi = (0 != MyAtoI((const TCHAR*)szBuf));
    else
        g_bBiDi = FALSE;

    if (LoadString(g_hInstance, IDS_TEXTFONT_LINESPACING, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBLineSpace = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBLineSpace = 0;
    
    return;
}

void GetMyImagesFromFile(HWND hwnd)
{
    HDC     hdc;
    UINT    cxScreen;
    UINT    uiBitsPixel;

    cxScreen = (UINT) GetSystemMetrics(SM_CXSCREEN);
    
    hdc = GetDC(hwnd);
    if (hdc != NULL)
    {
        uiBitsPixel = (UINT) GetDeviceCaps(hdc, BITSPIXEL);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        uiBitsPixel = 4;
    }

    if (uiBitsPixel > 8)
    {
        g_idbBackground[0] = IDB_BACKGROUND_C16BIT;
        g_numBackground = 1;       
        g_iStretchMode  = STRETCH_HALFTONE;
        g_idbSelectedBullet = IDB_SELECTEDBULLET_C16BIT;
        g_idbReleasedBullet = IDB_RELEASEDBULLET_C16BIT;
        g_idbCurrentBullet  = IDB_CURRENTBULLET_C16BIT;

        if (cxScreen >= 1024)
            g_idbLogo = IDB_LOGO1024_C16BIT;
        else if (cxScreen >= 800)
            g_idbLogo = IDB_LOGO800_C16BIT;
        else
            g_idbLogo = IDB_LOGO640_C16BIT;
    }
    else
    {
        g_idbBackground[0] = IDB_BACKGROUND_C4BIT;
        g_numBackground = 1;
        g_iStretchMode  = STRETCH_ANDSCANS;    
        g_idbSelectedBullet = IDB_SELECTEDBULLET_C4BIT;
        g_idbReleasedBullet = IDB_RELEASEDBULLET_C4BIT;
        g_idbCurrentBullet  = IDB_CURRENTBULLET_C4BIT;
        
        if (cxScreen >= 1024)
            g_idbLogo = IDB_LOGO1024_C4BIT;
        else if (cxScreen >= 800)
            g_idbLogo = IDB_LOGO800_C4BIT;
        else
            g_idbLogo = IDB_LOGO640_C4BIT;
    }

}

/****************************************************************************
* SetLayoutParams()
*
* Set all the layout parameter for Billboard. All the floating point numbers
* come the design specification. This function uses the values of 
* g_nBFontHeight and g_nTFontHeight.

* NOTE: Call this function again and MoveWindow afterward, in case of 
* resolution changes
*
*****************************************************************************/
void 
SetLayoutParams()
{
    int cxScreen;
    int cyScreen;
    int iCommentLeft;
    int iCommonWidth;
    int iFontHeight;
    RECT rcSteps;
    UINT cySteps;
    
    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);
    iFontHeight = abs(GetInfoBarFontHeight());

    g_cyBannerHeight = cyScreen * 13 / 200;

    g_cxLogo = (UINT) (cxScreen * 0.0195);
    g_cyLogo = (UINT) (cyScreen * 0.0053);

    g_cxInfoBarWidth  = (cxScreen) * 28 / 100;
    g_cyInfoBarHeight = (cyScreen) - g_cyBannerHeight * 2;

    if (cxScreen < 800) 
    {        
        rcSteps.left   = g_cxInfoBarWidth * 3 / 20;
        rcSteps.top    = g_cyBannerHeight * 2;
        rcSteps.right  = g_cxInfoBarWidth - rcSteps.left;
        // Use 1.5 line height and reserve 2 lines for each step text, hence 7 / 2
        rcSteps.bottom = rcSteps.top + (iFontHeight * 7 / 2) * (UI_INFOBAR_NUM_STEPS) + 
                         (UINT) ((0.068) * cyScreen);
        
        iCommentLeft = rcSteps.left;
        iCommonWidth = g_cxInfoBarWidth - 2 * rcSteps.left;
        
    }
    else
    {
        rcSteps.left    = (UINT) (0.039 * cxScreen);
        rcSteps.top     = (UINT) (0.059 * cyScreen) + g_cyBannerHeight + 
                            g_nTFontHeight + g_nBFontHeight;
        rcSteps.right   = rcSteps.left + (UINT) (0.2005 * cxScreen);
        // Use 1.5 line height and reserve 1 line for each step text, hence 5 / 2
        rcSteps.bottom  = rcSteps.top + (iFontHeight * 5 / 2) * (UI_INFOBAR_NUM_STEPS) + 
                              (UINT) ((0.068) * cyScreen);
        
        iCommentLeft  = rcSteps.left;
        iCommonWidth  = (UINT) (0.1705 * cxScreen);
        
    }
       
    if (GetStepsHeight(g_cxInfoBarWidth, cyScreen, rcSteps, &cySteps))
    {
        rcSteps.bottom = cySteps;
    }
    
    g_cxSteps = rcSteps.left;
    g_cySteps = rcSteps.top;
    g_cxStepsWidth = rcSteps.right - rcSteps.left;
    g_cyStepsHeight = rcSteps.bottom - rcSteps.top;

       
    g_cxEstimate        = iCommentLeft;
    if (cxScreen < 800)
    {
        g_cyEstimate    = g_cyStepsHeight + g_cySteps + 3 * iFontHeight / 2;
    }
    else
    {
        g_cyEstimate    = g_cyStepsHeight + g_cySteps + (UINT) (0.063 * cyScreen);
    }
    g_cxEstimateWidth   = iCommonWidth;
    g_cyEstimateHeight  = iFontHeight * 5;

    g_cxProgressText        = iCommentLeft;
    g_cyProgressText        = g_cyEstimateHeight + g_cyEstimate;
    g_cxProgressTextWidth   = iCommonWidth;
    g_cyProgressTextHeight  = iFontHeight * 3;


    g_cxGauge         = iCommentLeft;
    g_cyGauge         = g_cyProgressTextHeight + g_cyProgressText + iFontHeight / 3;
    g_cxGaugeWidth    = iCommonWidth;
    g_cyGaugeHeight   = iFontHeight * 3 / 2;

    g_cxInfoText        = iCommentLeft;
    if (cxScreen < 800)
    {
        g_cyInfoText = g_cyGauge + g_cyGaugeHeight + iFontHeight;
        g_cyInfoTextHeight = cyScreen - g_cyInfoText - g_cyBannerHeight;
    }
    else
    {
        g_cyInfoTextHeight  = (cyScreen - g_cyGaugeHeight - iFontHeight / 3 -
                              g_cyGauge - g_cyBannerHeight) * 2 / 3 + iFontHeight;
        g_cyInfoText        = cyScreen - g_cyBannerHeight - g_cyInfoTextHeight;
    }
    g_cxInfoTextWidth   = iCommonWidth;

    if (g_bBiDi)
    {
        // mirroring along the center of infobar.
        int shiftAmt = g_cxInfoBarWidth - 2 * g_cxEstimate - g_cxEstimateWidth;
        if (shiftAmt < 0)
        {
            shiftAmt = 0;
        }
        g_cxSteps = g_cxInfoBarWidth - g_cxSteps - g_cxStepsWidth - shiftAmt;
        g_cxEstimate = g_cxInfoBarWidth - g_cxEstimate - g_cxEstimateWidth - shiftAmt;
        g_cxProgressText = g_cxInfoBarWidth - g_cxProgressText - g_cxProgressTextWidth - shiftAmt;
        g_cxGauge = g_cxInfoBarWidth - g_cxGauge - g_cxGaugeWidth - shiftAmt;
        g_cxInfoText = g_cxInfoBarWidth - g_cxInfoText - g_cxInfoTextWidth - shiftAmt;
    }

    g_cxBillBrd        = g_cxInfoBarWidth;
    g_cyBillBrd        = g_cyBannerHeight;
    g_cxBillBrdWidth   = cxScreen - g_cxBillBrd;
    g_cyBillBrdHeight  = g_cyInfoBarHeight;
    g_cxBillBrdHMargin = (UINT) (cxScreen * 0.06);
    g_cyBillBrdVMargin = 0;
    
    // Only substract 2*margin for the area for the billboard title
    // otherwise the new text does not fit on 640x480
    g_cxBillBrdTitleWidth = g_cxBillBrdWidth - (2 * g_cxBillBrdHMargin);
    g_cyBillBrdTitleTop   = g_cySteps - g_cyBillBrd;
    
    // Only substract 2*margin for the area for the billboard text
    // otherwise the new text does not fit on 640x480
    g_cxBillBrdBodyWidth  = g_cxBillBrdWidth - (2 * g_cxBillBrdHMargin);
   
}


HDC
GetBackgroundBuffer()
{
    return g_hdcMem;
}

VOID
DestroyBackgroundBuffer()
{
    HBITMAP hbmpMem;

    hbmpMem = SelectObject(g_hdcMem, g_hbmpMemOld);
    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }
    g_hbmpMemOld = NULL;

    DeleteDC(g_hdcMem);
    g_hdcMem = NULL;

}

BOOL 
StretchBitmapAndDisplay(
    HDC hdcDest,
    int nXOriginDest,
    int nYOriginDest,
    int nWidthDest,
    int nHeightDest,
    HDC hdcSrc,
    int nXOriginSrc,
    int nYOriginSrc,
    int nWidthSrc,
    int nHeightSrc,
    DWORD fdwRop
    )

/*++

Routine Description:

    This function takes a bitmap that needs to be displayed and stretches it 
    using GDI. Once the bitmap is stretched to the required dimentions we display
    it using BitBlt. We have to do this decause some buggy video drivers and or
    hardware hang on using StretchBlt.
    Or the StretchBlt would generate a corupted bitmap.

Arguments:

    hdcDest         destination device-context handle    
    nXOriginDest    x-coordinate of origin of destination rectangle    
    nYOriginDest    y-coordinate of origin of destination rectangle    
    nWidthDest      width of destination rectangle    
    nHeightDest     height of destination rectangle    
    hdcSrc          source device-context handle    
    nXOriginSrc     x-coordinate of origin of source rectangle    
    nYOriginSrc     y-coordinate of origin of source rectangle    
    nWidthSrc       width of source rectangle    
    nHeightSrc      height of source rectangle    
    fdwRop          raster operation

Return value:

    TRUE == SUCCESS


Changes:

    10/11/97        hanumany        Created
    04/30/01        chunhoc         Modified
    
--*/

{
    HDC     hdcTemp = NULL;
    BOOL    bRet = FALSE;
    int     iOldStretchMode = 0;
    HBITMAP hBmp = NULL;
    HBITMAP hBmpOld = NULL;
    UINT    uiNumColors = 0;
    
    //Create the temp DC
    hdcTemp = CreateCompatibleDC(hdcDest);

    //Create a bitmap
    hBmp = CreateCompatibleBitmap(hdcSrc, nWidthDest, nHeightDest);

    
    if(hdcTemp && hBmp)
    {
        // Select it into the temp DC
        hBmpOld = SelectObject(hdcTemp, hBmp);

        //set stretch blt mode
        iOldStretchMode = SetStretchBltMode(hdcTemp, g_iStretchMode);

        //StretchBlt
        bRet = StretchBlt(hdcTemp,
                          0,
                          0,
                          nWidthDest,
                          nHeightDest,
                          hdcSrc,
                          nXOriginSrc,
                          nYOriginSrc,
                          nWidthSrc,
                          nHeightSrc,
                          fdwRop);
            
        // restore the old stretch mode
        SetStretchBltMode(hdcTemp, iOldStretchMode);

        if(bRet)
        {
            //We succeeded in stretching the bitmap on the temp DC. Now lets BitBlt it.
            bRet = BitBlt(hdcDest,
                          nXOriginDest,
                          nYOriginDest,
                          nWidthDest,
                          nHeightDest,
                          hdcTemp,
                          0,
                          0,
                          SRCCOPY);                
        }
    }

    
    //CleanUp
    if(hBmpOld)
    {
        SelectObject(hdcTemp, hBmpOld);
    }

    if(hBmp)
    {
        DeleteObject(hBmp);
    }
    
    if(hdcTemp)
    {
        DeleteDC(hdcTemp);
    }
    
    return bRet;
}

BOOL
BufferBackground(
    IN  HWND   hwnd
    )

/*++

Routine Description:

    Create a memory buffer for the stretched bitmap to improve performance.

Arguments:

    hwnd          - Handle to the window on which the background bitmap is drawn
    
Return Value:

    TRUE          - if the buffered background image is created successfully

    FALSE         - otherwise

    g_hdcMem      - The memory DC to receive the buffered bitmap if succeeeds,
                    NULL if fails.

    g_hbmpMemOld  - Save the old memory buffer of g_hdcMem

--*/

{
    BOOL    bRet      = FALSE;
    HDC     hdcMem    = NULL;
    HBITMAP hbmpMemOld= NULL;
    HBITMAP hbmpMem   = NULL; 
    HDC     hdc       = NULL;
    HDC     hdcImgSrc = NULL;
    BITMAP  bm;
    HBITMAP hbmBackground = NULL;
    HBITMAP hBitmapOld = NULL;
    RECT    rcBackground;

    if (!GetClientRect(hwnd, &rcBackground))
    {
        goto cleanup;
    }
    
    hdc = GetDC(hwnd);
    if (!hdc)
    {
        goto cleanup;
    }
    
    hbmpMem = CreateCompatibleBitmap(hdc,
                                     rcBackground.right - rcBackground.left,
                                     rcBackground.bottom - rcBackground.top);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      
    hbmpMemOld = SelectObject(hdcMem, hbmpMem);

    if (g_numBackground > 1)
    {
        hbmBackground = MyLoadImage(hdc, g_idbBackground, g_numBackground);
    }
    else
    {
        hbmBackground = (HBITMAP) LoadImage(g_hInstance,
                                            MAKEINTRESOURCE(g_idbBackground[0]),
                                            IMAGE_BITMAP,
                                            0,
                                            0,
                                            LR_DEFAULTSIZE);
    }
    hdcImgSrc = CreateCompatibleDC(hdc);
    if (!hbmBackground || !hdcImgSrc)
    {
        goto cleanup;
    }
    hBitmapOld = (HBITMAP) SelectObject(hdcImgSrc, hbmBackground);
    
    GetObject(hbmBackground , sizeof(BITMAP), &bm);
    
    bRet = StretchBitmapAndDisplay(hdcMem,
                                   0,
                                   0,
                                   rcBackground.right - rcBackground.left,
                                   rcBackground.bottom - rcBackground.top,
                                   hdcImgSrc,
                                   0,
                                   0,
                                   bm.bmWidth,
                                   bm.bmHeight,
                                   SRCCOPY);

    SelectObject(hdcImgSrc, hBitmapOld);

    if (bRet)
    {
        g_hdcMem = hdcMem;
        g_hbmpMemOld = hbmpMemOld;
        hdcMem = NULL;
        hbmpMemOld = NULL;
        hbmpMem = NULL;
    }

cleanup:
    
    if (hdcImgSrc)
    {
        DeleteDC(hdcImgSrc);
    }

    if (hbmBackground)
    {
        DeleteObject(hbmBackground);
    }

    if (hbmpMemOld != NULL)
    {
        SelectObject(hdcMem, hbmpMemOld);
    }

    if (hbmpMem != NULL)
    {
        DeleteObject(hbmpMem);
    }

    if (hdcMem != NULL)
    {
        DeleteDC(hdcMem);
    }        

    if (hdc)
    {
        ReleaseDC(hwnd, hdc);
    }
    
    return bRet;
}

LRESULT
OnEraseBkgnd(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Handle the WM_ERASEBKGND for the child windows of the main window,
    RedCarpetWndClass

Arguments:

    hwnd   - hwnd to a child window of RedCarpetWndClass

    wParam - same as the wParam pass to WM_ERASEBKGND (see MSDN)

    lParam - same as the lParam pass to WM_ERASEBKGND (see MSDN)

Return Value:

    1 if the background is erased successfully, 0 otherwise. (see MSDN)
    
--*/

{
    LRESULT lRet = 0;
    RECT    rc;
    RECT    rcToParent;

    if (GetClientRect(hwnd, &rc))
    {
        HDC hdc    = (HDC) wParam;
        HDC hdcMem;

        hdcMem = GetBackgroundBuffer();

        GetRectInParent(hwnd, &rc, &rcToParent);

        lRet = (LRESULT) BitBlt(hdc,
                            rc.left,
                            rc.top,
                            rc.right - rc.left,
                            rc.bottom - rc.top,
                            hdcMem,
                            rcToParent.left,
                            rcToParent.top,
                            SRCCOPY);
    }

    return lRet;
}

HDC
GetBillboardBuffer()
{
    return g_hdcBbMem;
}

VOID
DestroyBillboardBuffer()
{
    HBITMAP hbmpMem;

    hbmpMem = SelectObject(g_hdcBbMem, g_hbmpBbMemOld);
    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }
    g_hbmpBbMemOld = NULL;

    DeleteDC(g_hdcBbMem);
    g_hdcBbMem = NULL;

}

HBITMAP
MyLoadImage(
    IN HDC    hdc,
    IN UINT*  idbBackground,
    IN int    iNumImage
    )

/*++

Routine Description:

    OR all the specified bitmaps in the resource file and return the result
    image handle. This is particularly useful when we want to use RLE on a
    16 or 24-bit bitmap, because DIB format only permits RLE of 4bpp or 8bpp
    bitmap. 

Arguments:

    hdc            - a device context

    idbBackground  - list of bitmap resource id's

    iNumImage      - number of id in idbBackground

Return Values:

    the result image handle on success; NULL on failure

Note:

    Assume all the bitmaps have the same dimension.

--*/

{
    HBITMAP hbmBackground[] = {NULL, NULL, NULL};
    HBITMAP hbmpImgSrcOld = NULL;
    HDC     hdcImgSrc = NULL;
    HBITMAP hbmpMem = NULL;
    HBITMAP hbmpMemOld = NULL;
    HDC     hdcMem = NULL;
    HBITMAP hbmpRet = NULL;
    DWORD   dwRop;
    int     i;
    BITMAP  bm;

    for (i = 0; i < iNumImage; i++)
    {
        hbmBackground[i] = (HBITMAP) LoadImage(g_hInstance,
                                               MAKEINTRESOURCE(idbBackground[i]),
                                               IMAGE_BITMAP,
                                               0,
                                               0,
                                               LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
        if (hbmBackground[i] == NULL)
        {
            goto cleanup;
        }
    }

    hdcImgSrc = CreateCompatibleDC(hdc);
    if (hdcImgSrc == NULL)
    {
        goto cleanup;
    }

    if (!GetObject(hbmBackground[0], sizeof(BITMAP), &bm))
    {
        goto cleanup;
    }    

    hbmpMem = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      

    i = 0;
    dwRop = SRCCOPY;
    hbmpMemOld = SelectObject(hdcMem, hbmpMem);
    hbmpImgSrcOld = (HBITMAP) SelectObject(hdcImgSrc, hbmBackground[i]);
    while (TRUE)
    {
        if (!BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcImgSrc, 0, 0, dwRop))
        {
            goto cleanup;
        }
        i++;
        if (i >= iNumImage)
        {
            break;
        }
        dwRop = SRCPAINT;
        SelectObject(hdcImgSrc, hbmBackground[i]);
    }

    hbmpRet = hbmpMem;
    hbmpMem = NULL;

cleanup:
    
    if (hbmpImgSrcOld)
    {
        SelectObject(hdcImgSrc, hbmpImgSrcOld);
    }

    if (hbmpMemOld)
    {
        SelectObject(hdcMem, hbmpMemOld);
    }

    if (hdcMem)
    {
        DeleteDC(hdcMem);
    }

    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }

    if (hdcImgSrc)
    {
        DeleteDC(hdcImgSrc);
    }
    
    for (i = 0; i < iNumImage; i++)
    {
        if (hbmBackground[i])
        {
            DeleteObject(hbmBackground[i]);
        }
    }

    return hbmpRet;
}

BOOL
BufferBillboard(
    IN  HWND   hwnd,
    IN  HDC    hdc
    )

/*++

Routine Description:

    Create a memory buffer for the billboard.

Arguments:

    hwnd          - Handle to the window on which the Billboard bitmap is drawn

    hdc           - Handle to the screen DC of billboard
    
Return Value:

    TRUE          - if the buffered background image is created successfully

    FALSE         - otherwise

    g_hdcBbMem    - The memory DC to receive the buffered bitmap if succeeeds,
                    NULL if fails.

    g_hbmpBbMem   - Save the old memory buffer of g_hdcBbMem
    
--*/

{
    BOOL    bRet      = FALSE;
    HDC     hdcMem    = NULL;
    HBITMAP hbmpMem   = NULL; 
    RECT    rcBillboard;

    if (!GetClientRect(hwnd, &rcBillboard))
    {
        goto cleanup;
    }
        
    hbmpMem = CreateCompatibleBitmap(hdc,
                                     rcBillboard.right - rcBillboard.left,
                                     rcBillboard.bottom - rcBillboard.top);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      
    g_hbmpBbMemOld = SelectObject(hdcMem, hbmpMem);
  
    Animate(hdcMem);
    
    bRet = TRUE;
    g_hdcBbMem = hdcMem;
    hdcMem = NULL;
    hbmpMem = NULL;

cleanup:
    
    if (hbmpMem != NULL)
    {
        SelectObject(hdcMem, g_hbmpBbMemOld);
        DeleteObject(hbmpMem);
        g_hbmpBbMemOld = NULL;
    }

    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }        
    
    return bRet;
}


/*****************************************************************************
*
* GetRectInParent(hwndChild, prcClip, pRect)
*
* This function gets the rect of child window relative to the client
* coordinate of the parent
*
******************************************************************************/
void GetRectInParent(HWND hwndChild, LPRECT prcClip, LPRECT pRect)
{
    RECT       rcChild;
    POINT      ptChild;
    HWND       hwnd;
    
    hwnd = GetParent(hwndChild);

    if (hwnd == NULL)
    {
        hwnd = hwndChild;
    }

    if ( prcClip == NULL ) {
        GetClientRect( hwndChild, &rcChild );
    } else {
        rcChild = *prcClip;
    }

    ptChild.x = rcChild.left;
    ptChild.y = rcChild.top;
    ClientToScreen( hwndChild, &ptChild );
    ScreenToClient( hwnd, &ptChild );
    pRect->left = ptChild.x;
    pRect->top = ptChild.y;

    ptChild.x = rcChild.right;
    ptChild.y = rcChild.bottom;
    ClientToScreen( hwndChild, &ptChild );
    ScreenToClient( hwnd, &ptChild );
    pRect->right = ptChild.x;
    pRect->bottom = ptChild.y;

}

BOOL WINAPI InitRealBillBoard(HWND hwndParent)
{
    WNDCLASS  wc;
    RECT    rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = (WNDPROC)BillBoardWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szBillBoardClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    GetWindowRect(hwndParent, &rc1);
    rc1.left = rc1.left + g_cxBillBrd;
    rc1.top = rc1.top + g_cyBillBrd;
    rc1.bottom = rc1.top + g_cyBillBrdHeight;
    g_hwndBB = CreateWindow(
        g_szBillBoardClassName,
        TEXT(""),
        WS_CHILD,
        rc1.left,
        rc1.top,
        rc1.right - rc1.left,
        rc1.bottom - rc1.top,
        hwndParent, 
        NULL,
        g_hInstance,
        NULL);

    if (g_hwndBB == NULL)
    {
        UnregisterClass(g_szBillBoardClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndBB, SW_HIDE );

    return TRUE;

}

BOOL WINAPI InitStatus(HWND hwndParent)
{
    WNDCLASS wc;
    RECT     rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = (WNDPROC)AnimationWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szStatusClassName;

    if (!RegisterClass (&wc))
    {
        return FALSE;
    }
    
    GetWindowRect(hwndParent, &rc1);
    g_hwndStatus = CreateWindowEx(
        WS_EX_TRANSPARENT,
        g_szStatusClassName,
        TEXT(""),
        WS_CHILD, 
        0,
        0,
        0,
        0,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndStatus == NULL)
    {
        UnregisterClass(g_szStatusClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndStatus, SW_HIDE );

    return TRUE;

}

BOOL WINAPI InitProgressBar(HWND hwndParent)
{
    RECT    rc1;

    GetWindowRect(hwndParent, &rc1);
    
    g_hwndTimeEstimate = CreateWindowEx( 
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX,
        rc1.left + g_cxEstimate,
        rc1.top + g_cyEstimate,
        g_cxEstimateWidth,
        g_cyEstimateHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndTimeEstimate)
    {
        // Set the font for the text in this window
        SendMessage(g_hwndTimeEstimate, WM_SETFONT, (WPARAM)g_hfont ,0L);

        SetWindowLongPtr(g_hwndTimeEstimate, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow(g_hwndTimeEstimate, SW_SHOW);
        UpdateWindow(g_hwndTimeEstimate);
    }

    g_hwndProgressText = CreateWindowEx(
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX,
        rc1.left + g_cxProgressText,
        rc1.top + g_cyProgressText,
        g_cxProgressTextWidth,
        g_cyProgressTextHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndProgressText)
    {
        // Save the original position
        GetWindowRect(g_hwndProgressText , &g_rcProgressText);
        
        SendMessage( g_hwndProgressText, WM_SETFONT, (WPARAM)g_hfont ,0L );

        SetWindowLongPtr(g_hwndProgressText, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow( g_hwndProgressText, SW_SHOW );
        UpdateWindow( g_hwndProgressText );
    }

    g_hwndProgressGauge = CreateWindow(
        PROGRESS_CLASS,
        NULL,
        WS_CHILD | PBS_SMOOTH ,
        rc1.left + g_cxGauge, 
        rc1.top + g_cyGauge,
        g_cxGaugeWidth,
        g_cyGaugeHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndProgressGauge)
    {
        SetWindowLongPtr(g_hwndProgressGauge, GWLP_WNDPROC, (LONG_PTR) ProgressSubClassWndProc);
        SendMessage( g_hwndProgressGauge, PBM_SETBKCOLOR, 0L, (LPARAM) g_colGaugeBg );
        SendMessage( g_hwndProgressGauge, PBM_SETBARCOLOR, 0L, (LPARAM) g_colGauge );
    }

    g_hwndInfoText  = CreateWindowEx(
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX, 
        rc1.left + g_cxInfoText, 
        rc1.top + g_cyInfoText,
        g_cxInfoTextWidth,
        g_cyInfoTextHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL);

    if (g_hwndInfoText)
    {
        // Set the font for the text in this window
        SendMessage(g_hwndInfoText, WM_SETFONT, (WPARAM)g_hfont ,0L);

        SetWindowLongPtr(g_hwndInfoText, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow(g_hwndInfoText, SW_SHOW);
        UpdateWindow(g_hwndInfoText);
    }

    g_hbmWinLogo = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbLogo),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );

    if (g_hbmWinLogo)
    {
        BITMAP bm;

        if (GetObject(g_hbmWinLogo, sizeof(BITMAP), &bm))
        {
            g_hwndLogo = CreateWindow(TEXT("STATIC"),
                                      NULL,
                                      WS_VISIBLE | WS_CHILD | SS_OWNERDRAW,
                                      rc1.left + g_cxLogo,
                                      rc1.top + g_cyLogo,
                                      bm.bmWidth,
                                      bm.bmHeight,
                                      hwndParent,
                                      NULL,
                                      g_hInstance,
                                      NULL);

            if (g_hwndLogo)
            {
                SetWindowLongPtr(g_hwndLogo,
                                 GWLP_WNDPROC,
                                 (LONG_PTR) StatusSubClassWndProc);
            }
        }
    }
        
    return TRUE;

}

LRESULT CALLBACK 
StatusSubClassWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Routine Description:

    Subclass the Static Text control used in Billboard and override the
    WM_ERASEBKGND message, so that the bitmap background can be shown
    behind the text.

Arguments:

    hwnd   - hwnd to a static text window, which must be a child window of
            the main billboard window

    msg    - (see MSDN)

    wParam - (see MSDN)

    lParam - (see MSDN)

Return Value:

    (see MSDN)
    
--*/

{
    LRESULT lRet;

    // don't process any message before the CreateWindow of the
    // main window return and g_hwnd is set.
    if (g_hwnd != NULL && msg == WM_ERASEBKGND)
    {      
        lRet = OnEraseBkgnd(hwnd, wParam, lParam);   
    }
    else
    {
        WNDPROC fpStaticWndProc = (WNDPROC) GetClassLongPtr(hwnd, GCLP_WNDPROC);
        lRet = CallWindowProc(fpStaticWndProc, hwnd, msg, wParam, lParam);
    }

    return lRet;
}

LRESULT CALLBACK 
ProgressSubClassWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Routine Description:

    Subclass the Progress bar control used in Billboard and override the
    WM_NCPAINT message, so as to draw a flat progress bar.

Arguments:

    hwnd   - hwnd to a progress bar window

    msg    - (see MSDN)

    wParam - (see MSDN)

    lParam - (see MSDN)

Return Value:

    (see MSDN)
    
--*/

{
    LRESULT lRet;

    
    if (msg == WM_NCPAINT)
    {
        RECT rc;
        
        if (GetWindowRect(hwnd, &rc))
        {
            HDC hdc    = GetWindowDC(hwnd);
            if (hdc != NULL)
            {
                HBRUSH hbrOld;
                HPEN   hpnOld;

                hbrOld = SelectObject(hdc, GetStockObject(NULL_BRUSH));
                hpnOld = SelectObject(hdc, GetStockObject(BLACK_PEN));

                Rectangle(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top);

                SelectObject(hdc, hpnOld);
                SelectObject(hdc, hbrOld);

                ReleaseDC(hwnd, hdc);
            }
        }

        lRet = 0;
    }
    else
    {
        WNDPROC fpStaticWndProc = (WNDPROC) GetClassLongPtr(hwnd, GCLP_WNDPROC);
        if (fpStaticWndProc)
        {
            lRet = CallWindowProc(fpStaticWndProc, hwnd, msg, wParam, lParam);
        }
    }

    return lRet;
}


//---------------------------------------------------------------------------
//
// RedCarpetWndProc
//
//---------------------------------------------------------------------------
LRESULT CALLBACK RedCarpetWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static  HBRUSH  hbr = NULL;
        
    switch (msg)
    {
        case WM_CREATE:
        {
            HDC hdc;
            
            hbr = (HBRUSH) GetStockObject( HOLLOW_BRUSH );

            // The order of the following function matters, because some
            // required global variables being initialized before it is
            // called
            
            SetFontCharSet();

            SetFontColor(hwnd);

            GetMyFontsFromFile();
          
            CreateInfoBarFonts();
            
            GetMyImagesFromFile(hwnd);
            
            if (BufferBackground(hwnd) == FALSE)
            {
                return -1;
            }
            
            SetLayoutParams();

            if (InitRealBillBoard(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitInfoBar(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitProgressBar(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitStatus(hwnd) == FALSE) {
                return -1;
            }
            
            return 0;
        }
        
        case WM_DISPLAYCHANGE:
            // NOTE: Only top level window can receive this message
            // i.e. Assertion failure can't be caught if g_hwnd is not
            // a top-level window
            BB_ASSERT(FALSE);
            
            break;

        case WM_PAINT:
        {
            HDC             hdc;
            PAINTSTRUCT     ps;
            HDC             hdcMem;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc != NULL)
            {
                hdcMem = GetBackgroundBuffer();

                BitBlt(hdc,
                       ps.rcPaint.left,
                       ps.rcPaint.top,
                       ps.rcPaint.right - ps.rcPaint.left,
                       ps.rcPaint.bottom - ps.rcPaint.top,
                       hdcMem,
                       ps.rcPaint.left,
                       ps.rcPaint.top,
                       SRCCOPY);
                
                EndPaint(hwnd, &ps);
            }
                        
            return(0);
        }

        case WM_CTLCOLORSTATIC:
        {
            HWND    hwndChild;
            HDC     hdcChild;

            hwndChild = (HWND) lParam;
            hdcChild = (HDC) wParam;

            SetTextColor(hdcChild, g_colInfoText);
            SetBkMode( hdcChild, TRANSPARENT );

            if (hwndChild == g_hwndTimeEstimate || hwndChild == g_hwndInfoText) {
                SelectObject(hdcChild, g_hfontBold);
            }
            
            return (LRESULT)(HBRUSH)hbr;

        }

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pDi = (LPDRAWITEMSTRUCT) lParam;
            RECT             rc;

            if (GetClientRect(pDi->hwndItem, &rc))
            {
                DrawTransparentBitmap(pDi->hDC,
                                      g_hbmWinLogo, 
                                      rc.left,
                                      rc.top,
                                      g_colLogoTransparency);
            }
            
            return TRUE;
            
        }

        case WM_DESTROY:

            if (GetBackgroundBuffer() != NULL)
            {
                DestroyBackgroundBuffer();
            }

            if (g_hbmWinLogo)
            {
                DeleteObject(g_hbmWinLogo);
                g_hbmWinLogo = NULL;
            }
            
            hbr = NULL;
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

LRESULT CALLBACK BillBoardWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static BOOL     fTimerOn = FALSE;
    static BOOL     fAnimate = FALSE;
    HDC             hdc;

    switch (msg)
    {
        case WM_CREATE:
        {
            hdc = GetDC(NULL);
            g_nLogPixelsY = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(NULL, hdc);

            break;
        }

        case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc)
            {
                HDC hdcBillboardMem;

                if (fAnimate)
                {
                    if (GetBillboardBuffer())
                    {
                        DestroyBillboardBuffer();
                    }
                    if (InitAnimate(hwnd, hdc))
                    {
                        BufferBillboard(hwnd, hdc);
                    }
                    fAnimate = FALSE;
                }

                hdcBillboardMem = GetBillboardBuffer();
                if (hdcBillboardMem)
                {
                    BitBlt(hdc,
                           ps.rcPaint.left,
                           ps.rcPaint.top,
                           ps.rcPaint.right - ps.rcPaint.left,
                           ps.rcPaint.bottom - ps.rcPaint.top,
                           hdcBillboardMem,
                           ps.rcPaint.left,
                           ps.rcPaint.top,
                           SRCCOPY);
                }
                
            }

            EndPaint(hwnd, &ps);
            return(0);
        }

        case WM_START_TIMER:
        if (!fTimerOn)
        {
            
            if (g_uiLastAnimateIndex == (UINT)-1)
                g_uiAnimateIndex = 0;
            else
                g_uiAnimateIndex = g_uiLastAnimateIndex;
            
            if (SetTimer(hwnd, BILLBRD_TEXT_TIMERID, BB_TEXT_DISPLAY, NULL))
            {
                fTimerOn = TRUE;
                fAnimate = TRUE;
                ShowWindow(hwnd, SW_SHOW);
            }
            
        }
        return fTimerOn;

        case WM_STOP_TIMER:
        if (fTimerOn)
        {
            fTimerOn = FALSE;
            g_uiLastAnimateIndex = g_uiAnimateIndex;
            g_uiAnimateIndex = (UINT)-1;
            KillTimer(hwnd, BILLBRD_TEXT_TIMERID);

            ShowWindow(hwnd, SW_HIDE);

        }
        return fTimerOn == FALSE;

        case WM_TIMER:
        {                         
            AnimateNext();
            fAnimate = TRUE;
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);

        }
        break;

        case WM_DESTROY:
            TerminateAnimate();

            if (fTimerOn)
            {
                fTimerOn = FALSE;
                g_uiLastAnimateIndex = g_uiAnimateIndex;
                g_uiAnimateIndex = (UINT) -1;
                KillTimer(hwnd, BILLBRD_TEXT_TIMERID);
            }

            if (GetBillboardBuffer() != NULL)
            {
                DestroyBillboardBuffer();
            }

            break;

        default:
           return DefWindowProc(hwnd, msg, wParam, lParam);

    }
    return 0;
}


LRESULT CALLBACK
AnimationWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Hardcoded animation properties
    //
    static const DWORD BitmapIds[][4] =
    {
        {
            IDB_INTENSITY1_C16BIT,
            IDB_INTENSITY2_C16BIT,
            IDB_INTENSITY3_C16BIT,
            IDB_INTENSITY4_C16BIT
        },
        {
            IDB_INTENSITY1_C4BIT,
            IDB_INTENSITY2_C4BIT,
            IDB_INTENSITY3_C4BIT,
            IDB_INTENSITY4_C4BIT
        }
    };
    static const int   OriginalBitmapSize = 9;
    
    static BOOL      fTimerOn = FALSE;
    static HBITMAP   Bitmaps[] = {NULL, NULL, NULL, NULL};
    static const int NumBitmaps = sizeof(Bitmaps) / sizeof(HBITMAP);
    static int       BoxToFade = 0;
    static int       BoxBitmapIndex[] = {0, 0, 0, 0, 0};
    static const int NumBoxes = sizeof(BoxBitmapIndex) / sizeof(DWORD);
    static int       BitmapSize = 0;
       

    switch (msg)
    {
        case WM_CREATE:
        {
            int  Set;
            int  i;
            int  Ret = 0;
            HDC  hdc;

            hdc = GetDC(hwnd);
            if (hdc != NULL)
            {
                Set = (GetDeviceCaps(hdc, BITSPIXEL) > 8) ? 0 : 1;
                ReleaseDC(hwnd, hdc);
            }
            else
            {
                Set = 1;
            }

            //
            // The bitmaps are designed for 640 x 480. We want to scale them by
            // 80% of the ratio between the current screen with and 640
            //
            BitmapSize = OriginalBitmapSize * GetSystemMetrics(SM_CXSCREEN) * 8 / 6400;

            for (i = 0; i < NumBitmaps; i++)
            {
                Bitmaps[i] = LoadImage(
                    g_hInstance,
                    MAKEINTRESOURCE(BitmapIds[Set][i]),
                    IMAGE_BITMAP,
                    BitmapSize,
                    BitmapSize,
                    LR_DEFAULTCOLOR);
                if (!Bitmaps[i])
                {
                    Ret = -1;
                    break;
                }
            }

            if (Ret == 0)
            {
                int    Width;
                int    Height;
                
                BoxBitmapIndex[0] = NumBitmaps - 1;             
                for (i = 1; i < NumBoxes; i++)
                {
                    BoxBitmapIndex[i] = 0;
                }
                
                BoxToFade = 0;

                Width = BitmapSize * (NumBoxes * 2 - 1);
                Height = BitmapSize;
                
                MoveWindow(
                    hwnd,
                    GetSystemMetrics(SM_CXSCREEN) - g_cxSteps - Width,
                    g_cyBillBrd + g_cyBillBrdHeight + (g_cyBannerHeight - Height) / 2,
                    Width,
                    Height,
                    FALSE
                    );
                
            }
            else
            {
                int j;
                for (j = 0; j < i; j++)
                {
                    DeleteObject(Bitmaps[j]);
                }
            }
            
            return Ret;
        }

        case WM_ERASEBKGND:
        {
            return OnEraseBkgnd(hwnd, wParam, lParam);
        }

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC         hdc = NULL;
            int         i = 0;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc != NULL)
            {
                for (i = 0; i < NumBoxes; i++)
                {
                    DrawBitmap(
                        hdc,
                        Bitmaps[BoxBitmapIndex[i]],
                        i * (BitmapSize * 2),
                        0
                        );
                }
                
            }

            EndPaint(hwnd, &ps);
            
            return(0);
        }

        case WM_START_TIMER:
        if (!fTimerOn)
        {            
            if (SetTimer(hwnd, WHISTLER_PROGRESS_TIMERID, BB_WHISTLER_MOVE, NULL))
            {
                fTimerOn = TRUE;
                ShowWindow(hwnd, SW_SHOW);
            }
        }
        return fTimerOn;

        case WM_STOP_TIMER:
        if (fTimerOn)
        {
            fTimerOn = FALSE;
            KillTimer(hwnd, WHISTLER_PROGRESS_TIMERID);
            ShowWindow(hwnd, SW_HIDE);
        }
        return fTimerOn == FALSE;

        case WM_TIMER:
        {
            if (BoxBitmapIndex[BoxToFade] == 0)
            {                
                BoxToFade = (BoxToFade + 1) % NumBoxes;
            }
            else
            {
                DWORD BoxToGrow = (BoxToFade + 1) % NumBoxes;
                BoxBitmapIndex[BoxToFade]--;
                BoxBitmapIndex[BoxToGrow]++;
            }

            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
        }
        break;

        case WM_DESTROY:
        {
            int i;
            
            if (fTimerOn)
            {
                fTimerOn = FALSE;
                KillTimer(hwnd, WHISTLER_PROGRESS_TIMERID);
            }

            for (i = 0; i < NumBitmaps; i++)
            {
                if (Bitmaps[i])
                {
                    DeleteObject(Bitmaps[i]);
                }
            }

        }
        break;

        default:
           return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

//---------------------
// DLL export functions
//---------------------

BOOL WINAPI TermBillBoard()
{
    BOOL b = TRUE;
    if (g_hwnd)
    {
        if (!DestroyWindow(g_hwnd)) {
            return FALSE;
        }
        g_hwnd = NULL;

        b = UnregisterClass(g_szStepsClassName, g_hInstance);
        b = b && UnregisterClass(g_szBillBoardClassName, g_hInstance);
        b = b && UnregisterClass(g_cszClassName, g_hInstance);
        b = b && UnregisterClass(g_szStatusClassName, g_hInstance);
    }

    return b;
}


BOOL WINAPI InitBillBoard(HWND hwndParent, LPCTSTR lpszPath, DWORD dwInstallType)
{
    WNDCLASS  wc;
    HWND      hwnd;
    TCHAR Buffer[128];

    if (dwInstallType <= sizeof(bb_text))
    {
        dwBBTextType = dwInstallType;
    }

    if (LoadString(g_hInstance, IDD_PANELCOUNT, (LPTSTR)Buffer, sizeof(Buffer)/sizeof(TCHAR)))
        g_nPanelCount = MyAtoI((const TCHAR*)Buffer);
    else
        g_nPanelCount = 0;
    
    g_nPanelCount++;

    if (LoadString(g_hInstance, IDD_ANIMATION, (LPTSTR)Buffer, sizeof(Buffer)/sizeof(TCHAR)))
        g_nAnimID = MyAtoI((const TCHAR*)Buffer);
    else
        g_nAnimID = 0;


    if ((g_szPath[0] == '\0') && (lpszPath == NULL)) //can't go on without path
        return FALSE;

    if (hwndParent == NULL)
        hwnd = GetDesktopWindow();
    else
        hwnd = hwndParent;


    if(g_szPath[0] == '\0')
    {
        lstrcpy((LPTSTR)g_szPath, (LPCTSTR)lpszPath);
        AddPath(g_szPath, TEXT("BILLBRD"));
        
        lstrcpy(g_szFileName, g_szPath);
        //append .ini filename to path
        AddPath(g_szFileName, TEXT("winntbb.ini"));
    }

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = (WNDPROC)RedCarpetWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_SETUP));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_cszClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    LoadString(g_hInstance,IDS_WINNT_SETUP,(LPTSTR)Buffer,sizeof(Buffer)/sizeof(TCHAR));

    // If we have a parent, be a child window.
    // If not be a main window.
    g_hwnd = CreateWindow(
        g_cszClassName,
        (LPTSTR)Buffer,
        (hwndParent ? WS_CHILD : WS_POPUP) | WS_CLIPCHILDREN,
        0,
        0,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        hwnd,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwnd == NULL)
    {
        UnregisterClass(g_cszClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwnd, SW_SHOW );
    UpdateWindow( g_hwnd );

    g_hwndParent = hwnd;
    
    return TRUE;

}

HWND WINAPI GetBBMainHwnd()
{
    return g_hwnd;
}

HWND WINAPI GetBBHwnd()
{
    return g_hwndBB;
}


BOOL WINAPI ShowPanel(int iPanel)
{
    if (g_iCurPanel == iPanel)
        return FALSE;

    if ((iPanel >= 0) && (iPanel < g_nPanelCount))
    {
        if (g_hwndBB == NULL)
            return(FALSE);

        g_iCurPanel = iPanel;
    }
    else
    {
        if (g_hwnd)
        {
            DestroyWindow(g_hwnd);
            g_hwnd = NULL;
            g_iCurPanel = -1;
        }
    }
    return(TRUE);
}

int WINAPI GetPanelCount()
{
    return(g_nPanelCount);
}

void WINAPI BB_Refresh(void)
{
    if(g_hwnd)
    {
        RedrawWindow(
            g_hwnd,
            NULL,
            NULL,
            RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_INVALIDATE);
    }
}

BOOL WINAPI SetProgress(WORD wProgress)
{

    if (wProgress == 0xffff)
    {
        // Kill the last panel...
        return ShowPanel(wProgress);
    }
    else if (wProgress & 0x8000)
    {
        // Display a specific panel
        return ShowPanel(wProgress & 0x7fff);
    }
    else
    {
        // Normal case of a percentage...
        return ShowPanel((g_nPanelCount * wProgress)/100);
    }
    
}

BOOL WINAPI StartBillBoard()
{
    BOOL    retval = FALSE;
    
    if(g_hwnd && g_hwndBB)
    {

        retval = (BOOL) SendMessage(g_hwndBB, WM_START_TIMER, 0, 0L);
        if (g_hwndStatus) {
            SendMessage(g_hwndStatus, WM_START_TIMER, 0, 0L);
        }
    }
    
    return retval;
}

BOOL WINAPI StopBillBoard()
{
    BOOL    retval = FALSE;
    
    if(g_hwnd && g_hwndBB)
    {
        retval = (BOOL) SendMessage(g_hwndBB, WM_STOP_TIMER, 0, 0L);        
        if (g_hwndStatus) {
            SendMessage(g_hwndStatus, WM_STOP_TIMER, 0, 0L);
        }
    }
    
    return retval;
}

BOOL WINAPI ShowProgressGaugeWindow(UINT uiShow)
{
    BOOL bRet;
    
    if (uiShow == SW_HIDE)
    {
        bRet = ShowWindow(g_hwndProgressGauge, uiShow);
        // If we hide the progress bar, reset the progress position
        // OC manager does a PBM_SETRANGE, but does not call PBM_SETPOS
        SendMessage(g_hwndProgressGauge, PBM_SETPOS, 0, 0);
    }
    else
    {
        bRet = ShowWindow(g_hwndProgressGauge, uiShow);
    }
    
    return bRet;
}

BOOL AdjustProgressTextWindow(HWND hwnd, LPCTSTR szText)
{
    BOOL rc;
    HDC hdc;
    RECT rect;
    RECT rect2;
    LONG height1,height2,delta;
    HFONT       hFontOld = NULL;

    // Use the original position to calc the new position
    rect.top = g_rcProgressText.top;
    rect.bottom = g_rcProgressText.bottom;
    rect.left = g_rcProgressText.left;
    rect.right = g_rcProgressText.right;
    rect2.top = g_rcProgressText.top;
    rect2.bottom = g_rcProgressText.bottom;
    rect2.left = g_rcProgressText.left;
    rect2.right = g_rcProgressText.right;

    hdc = GetDC(hwnd);
    if (hdc == NULL)
    {
        rc = FALSE;
    }
    else
    {
        // Select the font into the DC so that DrawText can calc the size correct.
        hFontOld = SelectObject(hdc, g_hfont);

        DrawText(hdc, szText, -1, &rect2, DT_CALCRECT|DT_EXTERNALLEADING|DT_WORDBREAK);
        if(hFontOld)
        {
            SelectObject(hdc, hFontOld);
        }
        ReleaseDC(hwnd, hdc);

        // Calc the new height for the string
        height2 = rect2.bottom - rect2.top;
        // get the old height
        height1 = rect.bottom - rect.top;
        // See how far we have to change the top of the rect.
        delta = (height1 - height2); 
        rect.top += delta;

        // If we would get above the original position, don't
        if (rect.top < g_rcProgressText.top)
        {
            rect.top = g_rcProgressText.top;
        }
        // Since the privous window position could be different from the original, always move 
        // the window.
        MoveWindow(hwnd, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,TRUE);

        rc = TRUE;
    }

    return rc;
}

BOOL WINAPI SetProgressText(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndProgressText)
    {
        ShowWindow(g_hwndProgressText, SW_HIDE);
        if (szText)
        {
            AdjustProgressTextWindow(g_hwndProgressText, szText);
            SendMessage(g_hwndProgressText, WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndProgressText, WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndProgressText, SW_SHOW);

    }

    return TRUE;
}

LRESULT WINAPI ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    LRESULT lresult = 0;

    if (g_hwndProgressGauge) {
        lresult = (LRESULT) SendMessage(g_hwndProgressGauge, msg, wparam, lparam);
    }
    
    return lresult;
}


BOOL WINAPI SetTimeEstimate(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndTimeEstimate )
    {
        ShowWindow(g_hwndTimeEstimate, SW_HIDE);
        if (szText)
        {
            SendMessage(g_hwndTimeEstimate , WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndTimeEstimate , WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndTimeEstimate, SW_SHOW);

    }
 
    return TRUE;
}

BOOL WINAPI SetStep(int iPanel)
{
    BOOL rc = FALSE;
    
    if (g_hwndSteps) 
    {
        rc = (BOOL) SendMessage(g_hwndSteps, WM_SETSTEP, 0, (LPARAM) iPanel);
    }
    
    return rc;
}

BOOL WINAPI SetInfoText(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndInfoText)
    {
        ShowWindow(g_hwndInfoText, SW_HIDE);
        if (szText)
        {
            SendMessage(g_hwndInfoText, WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndInfoText, WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndInfoText, SW_SHOW);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\billbrd.h ===
#ifndef _BILLBRD_H_
#define _BILLBRD_H_
#include "resource.h"

#ifdef UNICODE
#define MyAtoI(x) _wtoi(x)
#else
#define MyAtoI(x) atoi(x)
#endif

#ifdef DBG

    void _BB_Assert(LPCTSTR, unsigned);

    #define BB_ASSERT(f);       \
       {if (f)                  \
            {}                  \
        else                    \
            _BB_Assert(TEXT(__FILE__), __LINE__);}
#else

    #define BB_ASSERT(f);

#endif

#define RGB_BLACK           RGB(   0,   0,   0 )
#define RGB_RED             RGB( 255,   0,   0 )
#define RGB_GREEN           RGB(   0, 255,   0 )
#define RGB_BLUE            RGB(   0,   0, 255 )
#define RGB_WHITE           RGB( 255, 255, 255 )
#define RGB_GRAY            RGB( 128, 128, 128 )
#define RGB_YELLOW          RGB( 255, 255,   0 )
#define RGB_ORANGE          RGB( 255,  64,   0 )
#define RGB_DARKBLUE        RGB(   0,   0, 128 )

//----------
// billbrd.c
//----------
#define WM_START_TIMER      (WM_USER + 6)
#define WM_STOP_TIMER       (WM_USER + 7)
#define WM_SETSTEP          (WM_USER + 8)

#define MAX_STRING          1024

#define UI_WASH_PATTERN_FILL_COLOR_16BIT    RGB(90,121,198) 
#define UI_WASH_PATTERN_FILL_COLOR_4BIT     RGB_WHITE

extern HINSTANCE g_hInstance;
extern TCHAR     g_szFileName[MAX_PATH];
extern BYTE      g_bCharSet;
extern UINT      g_cxBillBrdHMargin;
extern UINT      g_cyBillBrdVMargin;
extern UINT      g_cxBillBrdWidth;
extern UINT      g_cyBillBrdHeight;
extern UINT      g_cxBillBrdTitleWidth;
extern UINT      g_cyBillBrdTitleTop;
extern UINT      g_cxBillBrdBodyWidth;

HWND WINAPI GetBBMainHwnd();
HWND WINAPI GetBBHwnd();
void WINAPI BB_Refresh(void);

HDC GetBackgroundBuffer();
void GetRectInParent(HWND hwndChild, LPRECT prcChild, LPRECT prcParent);

//-------
// info.c
//-------
#define UI_INFOBAR_NUM_STEPS           5
#define UI_INFOBAR_FONT_SIZE_640       8
#define UI_INFOBAR_FONT_SIZE_800      11
#define UI_INFOBAR_FONT_SIZE_1024     14
#define CY_DIST_LINES                 16

#define UI_STEPSTITLE_COLOR_C16BIT             RGB_WHITE
#define UI_STEPSTEXT_COLOR_C16BIT              RGB_WHITE
#define UI_STEPSTEXT_MARK_COLOR_C16BIT         RGB_WHITE
#define UI_STEPSTEXT_CURRENT_COLOR_C16BIT      RGB(255, 128, 0)
#define UI_INFOTEXT_COLOR_C16BIT               UI_STEPSTEXT_COLOR_C16BIT
#define UI_GAUGE_BACKGROUND_COLOR_C16BIT       RGB_WHITE
#define UI_GAUGE_COLOR_C16BIT                  RGB(7, 158, 5)
#define UI_STATUS_TRANSPARENT_COLOR_C16BIT     RGB(0, 50, 150)
#define UI_LOGO_TRANSPARENT_COLOR_C16BIT       RGB(0, 53, 154)
#define UI_BULLET_TRANPARENT_COLOR_C16BIT      RGB(78, 111, 214)

#define UI_STEPSTITLE_COLOR_C4BIT              RGB_WHITE
#define UI_STEPSTEXT_COLOR_C4BIT               RGB_WHITE
#define UI_STEPSTEXT_MARK_COLOR_C4BIT          RGB_WHITE
#define UI_STEPSTEXT_CURRENT_COLOR_C4BIT       RGB_ORANGE
#define UI_INFOTEXT_COLOR_C4BIT                UI_STEPSTEXT_COLOR_C4BIT
#define UI_GAUGE_BACKGROUND_COLOR_C4BIT        UI_STEPSTEXT_COLOR_C4BIT
#define UI_GAUGE_COLOR_C4BIT                   RGB(0, 128, 0)
#define UI_STATUS_TRANSPARENT_COLOR_C4BIT      RGB_DARKBLUE
#define UI_LOGO_TRANSPARENT_COLOR_C4BIT        RGB(255, 0, 255)
#define UI_BULLET_TRANPARENT_COLOR_C4BIT       RGB_DARKBLUE

extern UINT         g_cxSteps;
extern UINT         g_cySteps;
extern UINT         g_cxStepsWidth;
extern UINT         g_cyStepsHeight;
extern const TCHAR  g_szStepsClassName[];
extern COLORREF     g_colStepsTxt;
extern COLORREF     g_colStepsMarkTxt;
extern COLORREF     g_colStepsCurrentTxt;
extern UINT         g_idbSelectedBullet;
extern UINT         g_idbReleasedBullet;
extern UINT         g_idbCurrentBullet;
extern COLORREF     g_colInfoText;
extern HWND         g_hwndSteps;
extern HFONT        g_hfont;
extern HFONT        g_hfontBold;
extern COLORREF     g_colBulletTrans;

BOOL WINAPI InitInfoBar(HWND hwndParent);

int GetInfoBarFontHeight();

BOOL CreateInfoBarFonts();

BOOL GetStepsHeight(
    IN  UINT  cxScreen,
    IN  UINT  cyScreen,
    IN  RECT  rcSteps,
    OUT UINT* pcyBottom);

//----------
// animate.c
//----------
typedef struct _BB_TEXT { 
    UINT    uiTitle;
    UINT    uiText;
    UINT    uiBitmap;
} BB_TEXT;

#define COLOR_TEXT_C16BIT          RGB_WHITE
#define COLOR_TITLE_C16BIT         RGB_WHITE
#define COLOR_SHADOW_C16BIT        RGB( 0, 37, 109)
#define COLOR_TITLE_C4BIT          RGB_WHITE
#define COLOR_TEXT_C4BIT           RGB_WHITE
#define COLOR_SHADOW_C4BIT         RGB_BLACK

extern DWORD    dwBBTextType;
extern BB_TEXT* bb_text[];
extern COLORREF g_colTitle;
extern COLORREF g_colTitleShadow;
extern TCHAR    g_szTFont[32];
extern BOOL     g_bTitleShadow;
extern int      g_nTFontHeight;
extern int      g_nTFontWidth;
extern int      g_nTFontWeight;
extern COLORREF g_colText;
extern COLORREF g_colTextShadow;
extern BOOL     g_bTextShadow;
extern TCHAR    g_szBFont[32];
extern int      g_nBFontHeight;
extern int      g_nBFontWidth;
extern int      g_nBFontWeight;
extern int      g_nLogPixelsY;
extern int      g_nAnimID;
extern BOOL     g_bBiDi;
extern int      g_nBLineSpace;

//----------
// addpath.c
//----------
VOID AddPath(LPTSTR szPath, LPCTSTR szName );
BOOL GetParentDir( LPTSTR szFolder );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\basewin\basewin.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    basewin.c

Abstract:

    Program to run BaseWinOptions for a given inf file.

Author:

    Ted Miller (tedm) 27-Sep-1995


Revision History:

    Andrew Ritz (AndrewR) 13-Mar-2000  -- retool to call into syssetup export
                                          since basewinoptions is obsolete

--*/

#include <windows.h>
#include <tchar.h>
#include <setupapi.h>
#include <stdio.h>
#include "setuplog.h"
#include "sputils.h"

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    );




VOID
Usage(
    VOID
    )
{
    _tprintf(TEXT("basewin installs the components in the specified inf\n"));
    _tprintf(TEXT("Usage: basewin <inf name> <section name>\n"));
}

VOID
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    PWSTR InfName;
    PWSTR SectionName;
    HINF InfHandle;
    BOOL b;
    SETUPLOG_CONTEXT Context;

    if(argc != 3) {
        Usage();
        goto c0;
    }

    if(!pSetupInitializeUtils()) {
        printf("Initialize failed\n");
        goto c0;
    }
    InitializeSetupLog(&Context);

    InfName = pSetupAnsiToUnicode(argv[1]);
    if(!InfName) {
        printf("Unable to convert %s to unicode\n",argv[1]);
        goto c1;
    }

    SectionName = pSetupAnsiToUnicode(argv[2]);
    if (!SectionName) {
        printf("Unable to convert %s to unicode\n",argv[2]);
        goto c2;
    }

    InfHandle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) {
        printf("Unable to open inf %s\n",argv[1]);
        goto c3;
    }

    b = DoInstallComponentInfs(
                        NULL,
                        NULL,
                        0,
                        InfHandle,
                        SectionName);

    _tprintf(TEXT("DoInstallComponentInfs returns %s\n"),b? TEXT("TRUE") : TEXT("FALSE"));


    TerminateSetupLog(&Context);

    SetupCloseInfFile(InfHandle);

c3:
    pSetupFree(SectionName);
c2:
    pSetupFree(InfName);
c1:
    pSetupUninitializeUtils();
c0:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\addpath.c ===
#include <pch.h>
#include <windows.h>

//***************************************************************************
//*                                                                         *
//* NAME:       AddPath                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID AddPath(LPTSTR szPath, LPCTSTR szName )
{
    LPTSTR szTmp;

    // Find end of the string
    szTmp = szPath + lstrlen(szPath);

    // If no trailing backslash then add one
    if ( szTmp > szPath && *(CharPrev( szPath, szTmp )) != TEXT('\\') )
        *(szTmp++) = TEXT('\\');

    // Add new name to existing path string
    while ( *szName == TEXT(' ') ) szName++;
        lstrcpy( szTmp, szName );
}

// function will upated the given buffer to parent dir
//
BOOL GetParentDir( LPTSTR szFolder )
{
    LPTSTR lpTmp;
    BOOL  bRet = FALSE;

    // remove the trailing '\\'
    lpTmp = CharPrev( szFolder, (szFolder + lstrlen(szFolder)) );
    lpTmp = CharPrev( szFolder, lpTmp );

    while ( (lpTmp > szFolder) && (*lpTmp != TEXT('\\')) )
    {
       lpTmp = CharPrev( szFolder, lpTmp );
    }

    if ( *lpTmp == TEXT('\\') )
    {
        if ( (lpTmp == szFolder) || (*CharPrev(szFolder, lpTmp) == TEXT(':')) )
            lpTmp = CharNext( lpTmp );
        *lpTmp = TEXT('\0');
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\animate.c ===
#include <pch.h>
#include <tchar.h>
#include "resource.h"
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

#define MAX_ANIMSTRING MAX_STRING
#define MyWait(c) {int __nCnt = (c); while(__nCnt) __nCnt--;}
#define GetInvertRGB(rgb) (RGB(255 - GetRValue(rgb), 255 - GetGValue(rgb), 255 - GetBValue(rgb)))

#define CX_MOVE 4
#define CY_MOVE 4
#define CX_SHADOW 4
#define CY_SHADOW 4

#define FONT_TITLE      0
#define FONT_TEXT       1
#define FONT_DELETE     10

// AnimateBlt Index
#define AB_HOR_POS      1
#define AB_HOR_NEG      2
#define AB_VER_POS      3
#define AB_VER_NEG      4

typedef struct _tagANISTRINGFORM { 
    COLORREF    col;
    BOOL        bShadow;
    COLORREF    colShadow;
    RECT        rc;
    UINT        uiLineHeightx2;
    HFONT       hFont;
} ANISTRINGFORM, FAR *LPANISTRINGFORM;



HDC     g_hdcCache = NULL;
HBITMAP g_hbmp = NULL;
HBITMAP g_hbmpOldCache = NULL;
LOGFONT g_lfTemp = {0};
BOOL    g_fBullet = FALSE;

UINT    g_uiAnimateIndex = (UINT)-1;
UINT    g_uiLastAnimateIndex = (UINT)-1;

void RestoreCachedRect()
{
    HWND    hwndBB;
    HDC     hdcBB;
    int     cxBB;
    int     cyBB;
    RECT    rcBB;

    hwndBB = GetBBHwnd();
    
    if (GetClientRect(hwndBB, &rcBB))
    {
    
        cxBB = rcBB.right - rcBB.left;
        cyBB = rcBB.bottom - rcBB.top;

        hdcBB = GetDC(hwndBB);
        if (hdcBB)
        {
            // Init cached bitmap
            BitBlt(hdcBB, 0, 0, cxBB, cyBB, g_hdcCache, 0, 0, SRCCOPY);
            ReleaseDC(hwndBB, hdcBB);
        }

    }

}

void AnimateBlt(HDC hdcDest, int x, int y, int w, int h, HDC hdcSrc, int xSrc, int ySrc, int nPattern)
{
    int i;

    switch (nPattern)
    {
        case AB_HOR_POS:
            for (i = 0; i < w; i++)
            {
                BitBlt(hdcDest, x + i, y, 1, h, 
                       hdcSrc, xSrc + i, ySrc, SRCCOPY);
                MyWait(10000);
            }
            break;

        case AB_VER_POS:
            for (i = 0; i < h; i++)
            {
                BitBlt(hdcDest, x, y + 1, w, 1, 
                       hdcSrc, xSrc + i, ySrc, SRCCOPY);
                MyWait(10000);
            }
            break;
    }

}

void RestoreRect(HDC hdc, LPRECT lprc, int nPat)
{
    int     cx      = lprc->right - lprc->left + 1;
    int     cy      = lprc->bottom - lprc->top + 1;
    
    if (hdc)
    {
        BitBlt(hdc, lprc->left, lprc->top, cx, cy, 
                   g_hdcCache, lprc->left, lprc->top, SRCCOPY);
    }

}

/**********************************************************************
* CheckForBulletAndRemoveMarker()
*
* This function checks if the line of text has a bullet preceding it
* if so it removes the bullet identifier from the string. This function
* also sets the value of piWidth to the width of the bitmap.
*
* Returns:  TRUE    == Bullet needed
*           FALSE   == No bullet
*
**********************************************************************/
BOOL CheckForBulletAndRemoveMarker(LPTSTR lpstr, LPINT lpiWidth)
{
    BOOL bRet = FALSE;
    LPTSTR   p = NULL;
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    p = lpstr;
    *lpiWidth = 0;
    g_fBullet = FALSE;
    
    if(*p)
    {
        while(*p == TEXT(' '))
            p = CharNext(p);
        if(*p == '-')
        {
            lstrcpy(p, CharNext(p));
            bRet = TRUE;
            hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
            GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bm);
            *lpiWidth = bm.bmWidth;
            DeleteObject(hBmp);
            g_fBullet = TRUE;
        }
    }
    return bRet;
}

/**********************************************************************
* CheckForBulletAndReturnWidth()
*
* This function checks if the line of text has a bullet preceding it
* if so figures out the bullet bitmaps width and returns it.
*
* Returns:  TRUE    == Bullet needed
*           FALSE   == No bullet
*
**********************************************************************/
int CheckForBulletAndReturnWidth(LPTSTR lpstr)
{
    int     iWidth = 0;
    LPTSTR   p = NULL;
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    p = lpstr;
    
    if(*p)
    {
        while(*p == TEXT(' '))
            p = CharNext(p);
        if(*p == TEXT('-'))
        {
            hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
            GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bm);
            iWidth = bm.bmWidth;
            DeleteObject(hBmp);
        }
    }
    return iWidth;
}

/**********************************************************************
* PaintBulletIfNeeded()
*
* This function checks if the line of text needs a bullet to be painted
* if so paints the bullet bitmap on the given coords on the given dc.
*
* Returns:  None
*
**********************************************************************/
void PaintBulletIfNeeded(HDC hdc, int x, int y , int iHeight)
{
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    if(g_fBullet)
    {
        hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
        if(hBmp)
        {
            GetObject(hBmp, sizeof(BITMAP), &bm);
            DrawBitmap(hdc, hBmp, x, y + (iHeight - bm.bmHeight)/2);
            DeleteObject(hBmp);
            g_fBullet = FALSE;
        }
    }   
}


void GetPanelSectionName(int nPanel, LPTSTR lpszKey)
{
    wsprintf(lpszKey, TEXT("Panel%d"), nPanel);
}

int GetTextCount(int nPanel)
{
    TCHAR szKey[80];
    GetPanelSectionName(nPanel, szKey);
    return GetPrivateProfileInt(szKey, TEXT("Count"), 0, g_szFileName);
}

int GetTitle(int nPanel, LPTSTR lpStr)
{
    TCHAR szKey[80];
    GetPanelSectionName(nPanel, szKey);
    return GetPrivateProfileString(szKey, TEXT("Title"), TEXT(""), 
                           lpStr, MAX_ANIMSTRING, g_szFileName);
}

int GetPanelText(int nPanel, int nCnt, LPTSTR lpStr)
{
    TCHAR szKey[16];
    TCHAR szSec[16];
    GetPanelSectionName(nPanel, szKey);
    wsprintf(szSec, TEXT("Text%d"), nCnt);
    return GetPrivateProfileString(szKey, szSec, TEXT(""), 
                           lpStr, MAX_ANIMSTRING, g_szFileName);
}

BOOL CALLBACK GetLogFontEnumProc(LPLOGFONT lplf, LPTEXTMETRIC lptm, int wType, LPARAM lpData)
{
    g_lfTemp = *lplf;
    return 0;
}

BOOL GetLogFontFromFaceName(LPLOGFONT lplf, LPTSTR lpszFaceName)
{
    HWND hwndBB = NULL;
    HDC  hdcBB  = NULL;
    FONTENUMPROC lpEnumFontsCallBack = NULL;

    hwndBB = GetBBHwnd();
    hdcBB = GetDC(hwndBB);
    
    lpEnumFontsCallBack = (FONTENUMPROC)MakeProcInstance((FARPROC)GetLogFontEnumProc, g_hInstance);

    EnumFonts((HDC)hdcBB, (LPCTSTR)lpszFaceName, (FONTENUMPROC)lpEnumFontsCallBack, 0L);

    FreeProcInstance((FARPROC)lpEnumFontsCallBack);

    *lplf = g_lfTemp;
    ReleaseDC(hwndBB, hdcBB);

    return TRUE;
}


/**********************************************************************
* GetDeleteFontHandle()
*
* This function checks if the font specified by iFontnum exists already.
* if so returns its handle if not it creates the font and return the 
* handle. returns NULL in error case. if Function is called with 
* iFontNum = FONT_DELETE then the existing fonts are deleted.
*
*   INPUT:      iFontNum
*   Returns:    HFONT
*
*   10/08/97        hanumany        created
**********************************************************************/
HFONT GetDeleteFontHandle(int iFontNum)
{
    static HFONT   hFontTitle = NULL;
    static HFONT   hFontText = NULL;    
    
    switch(iFontNum)
    {
        case FONT_TITLE:
        {
            if(hFontTitle)
            {
                return hFontTitle;
            }
            else
            {
                LOGFONT lf = {0};
            
                GetLogFontFromFaceName(&lf, g_szTFont);
                lf.lfHeight = -MulDiv(g_nTFontHeight, 96, 72);
                lf.lfWidth = g_nTFontWidth;
                lf.lfWeight = g_nTFontWeight;
                lf.lfQuality = ANTIALIASED_QUALITY;
                lf.lfCharSet = g_bCharSet;
                hFontTitle = CreateFontIndirect(&lf); 
                return hFontTitle;
            }
        }

        case FONT_TEXT:
        {
            
            if(hFontText)
            {
                return hFontText;
            }
            else
            {
                LOGFONT lf = {0};

                GetLogFontFromFaceName(&lf, g_szBFont);
                lf.lfHeight = -MulDiv(g_nBFontHeight, 96, 72);
                lf.lfWidth = g_nBFontWidth;
                lf.lfWeight = g_nBFontWeight;
                lf.lfQuality = PROOF_QUALITY;
                lf.lfCharSet = g_bCharSet;
                hFontText = CreateFontIndirect(&lf);  
                return hFontText;
            }    
        }

        case FONT_DELETE:
        {
            if(hFontTitle)
            {
                DeleteObject(hFontTitle);
                hFontTitle = NULL;
            }
            if(hFontText)
            {
                DeleteObject(hFontText);
                hFontText = NULL;
            }
            break;
        }
    }

    return NULL;
}

/************************************************************************
* RemoveLineBreakChar()
*
* This function copies lpszCurr to lpszFixed without the line break char's
*
************************************************************************/
void RemoveLineBreakChar(LPCTSTR lpszCurr, LPTSTR lpszFixed)
{
    while (*lpszCurr != TEXT('\0'))
    {
        if(*lpszCurr != TEXT('|'))
        {
            *lpszFixed = *lpszCurr;
#ifndef UNICODE
            if(IsDBCSLeadByte(*lpszFixed))
            {
                *(lpszFixed+1) = *(lpszCurr+1);
            }
#endif
            lpszFixed = CharNext(lpszFixed);
            lpszCurr = CharNext(lpszCurr);
        }
        else
        {
            lpszCurr = CharNext(lpszCurr);
        }
    }
    *lpszFixed = '\0';

    return;

}

void MergeBlt(LPTSTR lpstr,
              HDC hdcDst, int x0, int y0, int cx0, int cy0, 
              HDC hdcSrc, int x1, int y1, int cx1, int cy1,
              COLORREF rgb, COLORREF rgbShadow, 
              BOOL fShadow, BOOL fStretch,
              TEXTMETRIC* lptm, int iLineSpace, RECT* lprc
             )
{
    int nNumLines = 0;

    if (fShadow)
    {
        SetTextColor(hdcSrc, 0);
        DisplayString(hdcSrc, x1 + CX_SHADOW, y1 + CY_SHADOW, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

        if (fStretch)
        {
            StretchBlt(hdcDst, x0, 0, cx0, cy0, 
                   hdcSrc, x1, y1, cx1, cy1, SRCAND);
        }
        else
        {
            BitBlt(hdcDst, x0, 0, cx0, cy0, 
                   hdcSrc, x1, y1, SRCAND);
        }

        SetTextColor(hdcSrc, GetInvertRGB(rgbShadow));
        DisplayString(hdcSrc, x1 + CX_SHADOW, y1 + CY_SHADOW, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

        if (fStretch)
        {
            StretchBlt(hdcDst, y0, y0, cx0, cy0, 
                   hdcSrc, x1, y1, cx1, cy1, MERGEPAINT);
        }
        else
        {
            BitBlt(hdcDst, y0, y0, cx0, cy0, 
                   hdcSrc, x1, y1, MERGEPAINT);
        }
    }

    SetTextColor(hdcSrc, 0);
    DisplayString(hdcSrc, x1, y1, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

    if (fStretch)
    {
        StretchBlt(hdcDst, x0, 0, cx0, cy0, 
               hdcSrc, x1, y1, cx1, cy1, SRCAND);
    }
    else
    {
        BitBlt(hdcDst, x0, 0, cx0, cy0, 
               hdcSrc, x1, y1, SRCAND);
    }
    SetTextColor(hdcSrc, GetInvertRGB(rgb));
    DisplayString(hdcSrc, x1, y1, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

    if (fStretch)
    {
        StretchBlt(hdcDst, y0, y0, cx0, cy0, 
               hdcSrc, x1, y1, cx1, cy1, MERGEPAINT);
    }
    else
    {
        BitBlt(hdcDst, y0, y0, cx0, cy0, 
               hdcSrc, x1, y1, MERGEPAINT);
    }
}

int AnimateString(
    HDC             hdc,
    LPTSTR          lpstr,
    LPANISTRINGFORM lpani,
    int             iLineSpace,
    int             nPat
    )
{
    HWND    hwndBB  = NULL;
    int     cxBB;
    int     cyBB;
    RECT    rcBB;
    
    HDC     hdcMem = NULL;
    HDC     hdcText = NULL;
    HBITMAP hbmpMem = NULL;
    HBITMAP hbmpText = NULL;
    HBITMAP hbmpOld = NULL;
    HBITMAP hbmpOldText = NULL;
    HFONT   hfont = NULL;
    HFONT   hfontOld = NULL;
    HBRUSH  hbrBlack = NULL;
    HBRUSH  hbrWhite = NULL;
    HBRUSH  hbrOldText = NULL;
    int     cx;
    int     cy;
    int     i,j;
    TEXTMETRIC tm;
    int x0;
    int nLen;
    int nWait;
    int nDelta;
    RECT rc;
    int nNumLines = 0;
    int ibmWidth = 0;
    SIZE    size;

    hwndBB = GetBBHwnd();
    
    if (!GetClientRect(hwndBB, &rcBB))
    {
        goto exit;
    }
    
    cxBB = rcBB.right - rcBB.left;
    cyBB = rcBB.bottom - rcBB.top;

    hbrWhite = GetStockObject(WHITE_BRUSH);
    if (hbrWhite == NULL)
    {
        goto exit;
    }
    
    hbrBlack = GetStockObject(BLACK_BRUSH);
    if (!hbrBlack)
    {
        goto exit;
    }
    
    hdcText = CreateCompatibleDC(hdc);
    if (!hdcText)
    {
        goto exit;
    }

    hbmpText = CreateCompatibleBitmap(hdc, cxBB, cyBB);
    if (!hbmpText)
    {
        goto exit;
    }

    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem)
    {
        goto exit;
    }

    cx = lpani->rc.right - lpani->rc.left + 1;
    cy = lpani->rc.bottom - lpani->rc.top + 1;

    if (lpani->bShadow)
    {
        cx += CX_SHADOW;
        cy += CY_SHADOW;
    }

    hbmpMem = CreateCompatibleBitmap(hdc, cxBB, cyBB);
    if (!hbmpMem)
    {
        goto exit;
    }

    hbmpOld = SelectObject(hdcMem, hbmpMem);
    SetBkMode(hdcMem, TRANSPARENT);

    hfont = lpani->hFont;
    if (!hfont)
    {
       goto exit;
    }

    hfontOld = SelectObject(hdcMem, hfont);
    GetTextMetrics(hdcMem, &tm);

    nLen = lstrlen(lpstr);
    GetTextExtentPoint32(hdcMem, lpstr, nLen, &size);

    ibmWidth = CheckForBulletAndReturnWidth(lpstr);
    
    if (cx  > (int)size.cx + ibmWidth + 10)
    {
        cx = (int)size.cx + ibmWidth + 10;
    }

    if (cy > (int)size.cy)
    {
        cy = (int)size.cy;
    }

    hfontOld = SelectObject(hdcText, hfont);
    hbmpOldText = SelectObject(hdcText, hbmpText);
    hbrOldText = SelectObject(hdcText, hbrWhite);
    rc.left = 0;
    rc.top = 0;
    rc.right = cx;
    rc.bottom = cy;
    FillRect(hdcText, &rc, hbrWhite);

    DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

    if(nNumLines > 1)
    {
        cy = cy + (tm.tmHeight * lpani->uiLineHeightx2 * nNumLines / 2);
        rc.left = 0;
        rc.top = 0;
        rc.right = cx;
        rc.bottom = cy;
        FillRect(hdcText, &rc, hbrWhite);

        DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

    }

    switch (nPat)
    {

        default:
        case 7:
        case 0:
        {
            COLORREF crOld = 0;

            if (g_bBiDi)
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                    g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            }
            else
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                    g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            }

            if (lpani->bShadow)
            {
                CONST int SHADOW_OFFSET = 2;
                RECT  rcShadow;
                
                if (SetRect(&rcShadow,
                            rc.left,
                            rc.top,
                            rc.right + SHADOW_OFFSET,
                            rc.bottom + SHADOW_OFFSET))
                {
                    crOld = SetTextColor(hdcMem, lpani->colShadow);
                
                    DisplayString(hdcMem,
                                  SHADOW_OFFSET,
                                  SHADOW_OFFSET,
                                  &tm,
                                  iLineSpace,
                                  &rcShadow,
                                  &nNumLines,
                                  lpstr, LEFT);
                
                    SetTextColor(hdcMem, crOld);
                }
            }

            crOld = SetTextColor(hdcMem, lpani->col);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            if (g_bBiDi)
            {
                BitBlt(hdc,
                       lpani->rc.right-cx,
                       lpani->rc.top - tm.tmInternalLeading,
                       cx,
                       cy,
                       hdcMem,
                       0,
                       0,
                       SRCCOPY);
            }
            else
            {
                BitBlt(hdc,
                       lpani->rc.left,
                       lpani->rc.top - tm.tmInternalLeading,
                       cx,
                       cy,
                       hdcMem,
                       0,
                       0,
                       SRCCOPY);
            }

            SetTextColor(hdcMem, crOld);
            break;
        }

        case 1:

            if (g_bBiDi)
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            else
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            for (i = 0; i < cy ; i+=4)
            {
                if (g_bBiDi)
                    BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
                else
                    BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

                MergeBlt(lpstr, hdcMem, 0, 0, cx, i, hdcText, 0, 0, cx, cy, 
                        lpani->col, lpani->colShadow, lpani->bShadow, TRUE, &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                if (g_bBiDi)
                    BitBlt(hdc, lpani->rc.right-cx, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);
                else
                    BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);


                MyWait(10000);
            }
            if (g_bBiDi)
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            else
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE, &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            if (g_bBiDi)
                BitBlt(hdc, lpani->rc.right-cx, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);
            else
                BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);

            break;

        case 2:
            DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

            for (i = 0; i < cx ; i+=4)
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
                MergeBlt(lpstr, hdcMem, 0, 0, i, cy, 
                         hdcText, 0, 0, cx, cy, 
                         lpani->col, lpani->colShadow, lpani->bShadow, TRUE,
                         &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                MyWait(10000);
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);

            break;

        case 3:
            nWait = 100;
            
            for (i = cxBB; i > lpani->rc.left; i -= CX_MOVE)
            {
                int xCur = i;


                BitBlt(hdc, xCur + cx, lpani->rc.top, CX_MOVE, cy, 
                           g_hdcCache, xCur + cx, lpani->rc.top, SRCCOPY);

                BitBlt(hdcMem, 0, 0, cxBB - xCur, cy, 
                       g_hdcCache, xCur, lpani->rc.top, SRCCOPY);

                MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                         hdcText, 0, 0, cx, cy, 
                         lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                         &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, xCur, lpani->rc.top, cx, cy, 
                           hdcMem, 0, 0, SRCCOPY);

                MyWait(nWait * nWait);
                nWait++;
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);
            
            break;

        case 4:
            nWait = 100;
            nDelta = (lpani->rc.right - lpani->rc.left) / 10;

            x0 = cxBB;
            while (abs(nDelta) > CX_MOVE)
            {
                for (i = x0; 
                     abs(i - (lpani->rc.left - nDelta)) > CX_MOVE; 
                     i -= (CX_MOVE * (nDelta/ abs(nDelta))))
                {
                    int xCur = i;

                    BitBlt(hdc, xCur + cx, lpani->rc.top, CX_MOVE, cy, 
                               g_hdcCache, xCur + cx, lpani->rc.top, SRCCOPY);

                    BitBlt(hdc, xCur - CX_MOVE, lpani->rc.top, CX_MOVE, cy, 
                               g_hdcCache, xCur - CX_MOVE, lpani->rc.top, SRCCOPY);


                    BitBlt(hdcMem, 0, 0, cxBB - xCur, cy, 
                       g_hdcCache, xCur, lpani->rc.top, SRCCOPY);
                    MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                             hdcText, 0, 0, cx, cy, 
                             lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                             &tm, iLineSpace, &rc);
                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                    BitBlt(hdc, xCur, lpani->rc.top, cx, cy, 
                               hdcMem, 0, 0, SRCCOPY);
                    MyWait(nWait * nWait);
                    nWait++;
                }
                nDelta *= 2;
                nDelta /= 3;
                nDelta = 0 - nDelta;
                x0 = i;
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);

            break;

        case 5:
    
            BitBlt(hdcMem, 0, 0, cxBB - lpani->rc.left, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            for (i = 0; i < nLen; i++)
            {
                int nSize;
                int nNextSize;
                SIZE    size;

                GetTextExtentPoint32(hdcMem, lpstr, i, &size);
                nSize = size.cx;
                GetTextExtentPoint32(hdcMem, lpstr, i+1, &size);
                nNextSize = size.cx - nSize;

                if (nSize + nNextSize > cx)
                    break;
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top, nSize, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                BitBlt(hdc, lpani->rc.left + nSize, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + nSize, lpani->rc.top, SRCCOPY);

                for (j = cxBB; j > lpani->rc.left+nSize ; j-=CX_MOVE)
                {
                    int xCur = j;
                    int xPrev = j + nNextSize;

                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                    BitBlt(hdc, xPrev, lpani->rc.top, CX_MOVE, cy, 
                           g_hdcCache, xPrev, lpani->rc.top, SRCCOPY);
                    BitBlt(hdc, xCur, lpani->rc.top, nNextSize, cy, 
                           hdcMem, nSize, 0, SRCCOPY);

                    MyWait(20000);
                }

            }
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);

            break;

        case 6:

            BitBlt(hdcMem, 0, 0, cxBB - lpani->rc.left, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            for (i = 0; i < nLen; i++)
            {
                int nSize;
                int nNextSize;
                SIZE    size;

                GetTextExtentPoint32(hdcMem, lpstr, i, &size);
                nSize = size.cx;
                GetTextExtentPoint32(hdcMem, lpstr, i+1, &size);
                nNextSize = size.cx - nSize;

                if (nSize + nNextSize > cx)
                    break;
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                BitBlt(hdc, lpani->rc.left, lpani->rc.top, nSize, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top - CY_MOVE, nSize, CY_MOVE, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top - CY_MOVE, SRCCOPY);

                for (j = cyBB; j > lpani->rc.top; j-=CY_MOVE)
                {
                    int yCur = j;
                    int yPrev = j + cy;

                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                   
                    BitBlt(hdc, lpani->rc.left+nSize, yPrev, nNextSize, CY_MOVE, 
                           g_hdcCache, lpani->rc.left+nSize, yPrev, SRCCOPY);

                    BitBlt(hdc, lpani->rc.left+nSize, yCur, nNextSize, cy, 
                           hdcMem, nSize, 0, SRCCOPY);

                    MyWait(20000);
                }

            }
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                   
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top + cy, cx, CY_MOVE, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top + cy, SRCCOPY);
            break;

    }
    SelectObject(hdcMem, hbmpOld);
    SelectObject(hdcText, hbrOldText);
    SelectObject(hdcText, hbmpOldText);
    SelectObject(hdcText, hfontOld);
    SelectObject(hdcMem, hfontOld);

exit:
    if (hbmpText)
        DeleteObject(hbmpText);

    if (hdcText)
        DeleteDC(hdcText);

    if (hbmpMem)
        DeleteObject(hbmpMem);

    if (hdcMem)
        DeleteDC(hdcMem);

    if (hbrWhite)
    {
        DeleteObject(hbrWhite);
    }
    if (hbrBlack)
    {
        DeleteObject(hbrBlack);
    }

    return nNumLines;
}


void AnimateNext()
{
    if (g_uiAnimateIndex != (UINT)-1)
    {
        g_uiAnimateIndex++;
        if (bb_text[dwBBTextType][g_uiAnimateIndex].uiTitle == 0)
            g_uiAnimateIndex = 0;
    }
}

BOOL InitAnimate(HWND hwnd, HDC hdc)
{
    int     cxBB;
    int     cyBB;
    RECT    rcBB;
    HDC     hdcMem;
    RECT    rcBBToParent;
    BOOL    retval = FALSE;

    if (GetClientRect(hwnd, &rcBB))
    {
            
        cxBB = rcBB.right - rcBB.left;
        cyBB = rcBB.bottom - rcBB.top;

        if (g_hbmp)
        {
            SelectObject(g_hdcCache, g_hbmpOldCache);    
            DeleteObject(g_hbmp);
            g_hbmp = NULL;
        }

        if (g_hdcCache)
        {
            DeleteDC(g_hdcCache);
            g_hdcCache = NULL;
        }

        g_hdcCache = CreateCompatibleDC(hdc);
        g_hbmp = CreateCompatibleBitmap(hdc, cxBB, cyBB);
        if (g_hdcCache && g_hbmp)
        {
            g_hbmpOldCache = SelectObject(g_hdcCache, g_hbmp);

            hdcMem = GetBackgroundBuffer();
            
            GetRectInParent(hwnd, &rcBB, &rcBBToParent);
            
            retval = BitBlt(g_hdcCache,
                            0,
                            0,
                            cxBB,
                            cyBB,
                            hdcMem,
                            rcBBToParent.left,
                            rcBBToParent.top,
                            SRCCOPY);
        }                
        
    }

    return retval;
    
}

void TerminateAnimate()
{
    
    RestoreCachedRect();

    if (g_hbmp)
    {
        SelectObject(g_hdcCache, g_hbmpOldCache);    
        DeleteObject(g_hbmp);
        g_hbmp = NULL;
    }

    if (g_hdcCache)
    {
        DeleteDC(g_hdcCache);
        g_hdcCache = NULL;
    }
    
    GetDeleteFontHandle(FONT_DELETE);


}

/*********************************************************************************
*
* Animate()
*
* Main animation function.
*
*********************************************************************************/
void Animate(HDC hdc)
{
    RECT rc;
    ANISTRINGFORM ani;
    int nPadBuffer, nLinePad, nWndHeight, nNumLines = 0;
    TCHAR  sz[MAX_STRING];
    TCHAR  szText[MAX_STRING];
    int iOldMapMode;
    if (g_uiAnimateIndex == (UINT)-1)
        return;

    if (!GetClientRect(GetBBHwnd(), &rc))
    {
        return;
    }

    iOldMapMode = SetMapMode(hdc, MM_TEXT);
    
    if(g_nAnimID != 7)
    {
        RestoreRect(hdc, &rc, AB_HOR_POS);
    }
    
    rc.left = g_cxBillBrdHMargin;
    rc.top = g_cyBillBrdTitleTop;
    rc.right = g_cxBillBrdTitleWidth;
    rc.bottom = g_cyBillBrdHeight;
    
    nWndHeight = GetSystemMetrics(SM_CYSCREEN);
    nPadBuffer = nWndHeight / 80;    // 6 pixels @ 640x480
    nLinePad   = nWndHeight / 80;    // 6 pixels @ 640x480
    
    ani.col = g_colTitle;
    ani.colShadow = g_colTitleShadow;
    ani.bShadow = g_bTitleShadow;
    ani.uiLineHeightx2 = 2;
    ani.rc.top = rc.top;
    ani.rc.bottom = rc.bottom;
    ani.rc.left = rc.left;
    ani.rc.right = rc.right;
    ani.hFont = GetDeleteFontHandle(FONT_TITLE);
    if (LoadString(g_hInstance, bb_text[dwBBTextType][g_uiAnimateIndex].uiTitle, (LPTSTR)sz, sizeof(sz)/sizeof(TCHAR)))
    {
        nNumLines = AnimateString(hdc, sz, &ani, 0, g_nAnimID);
    }

    rc.top += (g_nTFontHeight * 2 + nLinePad) * nNumLines;
    rc.right = g_cxBillBrdBodyWidth;
    
    if (LoadString(g_hInstance, bb_text[dwBBTextType][g_uiAnimateIndex].uiText, (LPTSTR)sz, sizeof(sz)/sizeof(TCHAR)))
    {
        UINT i = 0;
        // Process the string so that we can have paragraphs.
        // /r/n marks end of line
        // 
        while (sz[i] != TEXT('\0'))
        {
            UINT j = 0;
            // see if the author has a hard line break
            // If, just give the line until the line break to display
            // The rest is done hte next time around.
            while ((sz[i] != TEXT('\0')) && (sz[i] != TEXT('\r')) && (sz[i] != TEXT('\n')) )
            {
                szText[j] = sz[i];
                j++;
                i++;
            }
            // if there is a line break character, skip this one.
            if (sz[i] != TEXT('\0'))
                i++;
            szText[j] = TEXT('\0');
            ani.col = g_colText;
            ani.colShadow = g_colTextShadow;
            ani.bShadow = g_bTextShadow;
            ani.uiLineHeightx2 = 3;
            ani.rc.top = rc.top;
            ani.rc.bottom = rc.bottom;
            ani.rc.left = rc.left;
            ani.rc.right = rc.right;
            ani.hFont = GetDeleteFontHandle(FONT_TEXT);
            nNumLines = AnimateString(hdc, szText, &ani, g_nBLineSpace, g_nAnimID);
            if (*szText)
            {
                rc.top += (g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nLinePad) * nNumLines;
                rc.bottom += (g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nLinePad) * nNumLines;
            }
            else
            {
                rc.top += g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nPadBuffer;
                rc.bottom += g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nPadBuffer;
            }
            // assume that there are allways \r\n for one line break. Skip the other one
            if ((sz[i] != TEXT('\0')) && ((sz[i] == TEXT('\r')) || (sz[i] == TEXT('\n')) ) )
                i++;
        }
    }

    SetMapMode(hdc, iOldMapMode);
    
}

/*****************************************************************************************
* This function displays a text string on the given coordinates. It figures
* out word wraping and distance between lines based on the font. the pNumLines
* param is set to indicate the num of lines output after wrapping text(NULL if failed).
* Returns The result from TextOut.
*****************************************************************************************/ 
BOOL DisplayString(
    HDC hdc,
    int x,
    int y,
    TEXTMETRIC* lptm,
    int iLineSpace,
    RECT* lprc,
    LPINT pNumLines,
    LPTSTR szTextOut,
    WORD wfPlacement)
{
    LPTSTR  szWorkBuffer = NULL;
    BOOL    ret = FALSE;
    int     newX = 0;

    // The multiplication factor 2 handle the worst case scenario, in which
    // every character can have a line break followed by it, but no '|'
    // character is specified in the string.
    szWorkBuffer = (LPTSTR)HeapAlloc(
        GetProcessHeap(),
        0,
        (lstrlen(szTextOut) + 1) * sizeof(TCHAR) * 2);
    
    if (szWorkBuffer)
    {       
        lstrcpy(szWorkBuffer, szTextOut);
        if(CheckForBulletAndRemoveMarker(szWorkBuffer, &newX))
        {
            newX += (x + 10); //leave space for the bullet bitmap
        }
        else
        {
            newX = x;
        }
        *pNumLines = WrapText(hdc, newX, lprc, szWorkBuffer);
        ret = DrawWrapText(hdc, lptm, iLineSpace, newX, y, lprc, wfPlacement, *pNumLines, szWorkBuffer);

        HeapFree(GetProcessHeap(), 0, szWorkBuffer);
    }

    return ret;
        
}

int WrapText(
    IN HDC          hdc,
    IN int          x,
    IN RECT*        lprc,
    IN OUT LPTSTR   szBBResource)
{
    BOOL    bDoneText = FALSE;
    int     iNumLines = 0;
    LPTSTR  pBBResource = szBBResource;
    LPTSTR  szRemainedWords = NULL;
    TCHAR   szCurrentLine[MAX_STRING];
    TCHAR   szCurrentLineWords[MAX_STRING];
    LPTSTR  pRemainedWords = NULL;
    LPTSTR  pCurrentLineWords = NULL;
    LPTSTR  pCurrentLine = NULL;
    SIZE    sz;
    LONG    uiRCWidth;

    szRemainedWords = (LPTSTR)HeapAlloc(
        GetProcessHeap(),
        0,
        (lstrlen(szBBResource) + 1) * sizeof(TCHAR));

    if(szRemainedWords)
    {
        lstrcpy(szRemainedWords, szBBResource);
    }
    else
    {
        return 0;
    }

    uiRCWidth = lprc->right - lprc->left - x;
    
    while(!bDoneText)
    {
        *szCurrentLine = TEXT('\0');
        
        pCurrentLineWords = szCurrentLineWords;
        pRemainedWords = szRemainedWords;
        pCurrentLine = szCurrentLine;
        
        RemoveLineBreakChar(pRemainedWords, pCurrentLine);
        GetTextExtentPoint32(hdc, pCurrentLine, lstrlen(pCurrentLine), &sz);

        ZeroMemory( szCurrentLine , sizeof(szCurrentLine));
        ZeroMemory( szCurrentLineWords , sizeof(szCurrentLineWords));

        if(uiRCWidth >= sz.cx)
        {
            RemoveLineBreakChar(pRemainedWords, pCurrentLine);
            bDoneText = TRUE;
        }
        else 
        {
            // break up string into displayable segment
            
            BOOL bDoneLine = FALSE;
        
            while(!bDoneLine)
            {
                BOOL bDoneWord = FALSE;
                
                while(!bDoneWord) 
                {
                    *pCurrentLineWords = TEXT('\0'); //null terminate for GetTextExtent

                    GetTextExtentPoint32(hdc, szCurrentLineWords, lstrlen(szCurrentLineWords), &sz);
                    
                    if(*pRemainedWords == TEXT('|')) //Line break char (potential line break)
                    {
                        pRemainedWords = CharNext(pRemainedWords);
                        bDoneWord = TRUE;
                    }
                    else if( *pRemainedWords == TEXT('\0')) //end of string
                    {
                        bDoneWord = TRUE;
                        bDoneLine = TRUE;
                    }
                    else if((sz.cx + 2 >= uiRCWidth ) && (lstrcmp(szCurrentLine, TEXT("") ) == 0))
                    //if the word is too big to fit on one line then break out. Code outside this
                    //loop will add a space in word and this will cause a line break.
                    {
                        bDoneWord = TRUE;
                    }
                    else
                    {
                        *pCurrentLineWords = *pRemainedWords;

#ifndef UNICODE
                        if(IsDBCSLeadByte(*pCurrentLineWords))
                        {
                            *(pCurrentLineWords+1) = *(pRemainedWords+1);
                        }
#endif
                        pCurrentLineWords = CharNext(pCurrentLineWords);
                        pRemainedWords = CharNext(pRemainedWords);
                    }
                }

                //Check if the current buffers extent is more than the width
                GetTextExtentPoint32(hdc, szCurrentLineWords, lstrlen(szCurrentLineWords), &sz);
            
                if((sz.cx >= uiRCWidth ) && (lstrcmp(szCurrentLine, TEXT("") ) != 0)) 
                {
                    //string is too big && saved str is not empty(use previously saved str)
                    bDoneLine = TRUE;
                }
                else
                {
                    *pCurrentLineWords = TEXT('\0');        //dont inc because we want to overwrite later
                    lstrcpy(szCurrentLine, szCurrentLineWords);    //append next word to string
                    lstrcpy(szRemainedWords, pRemainedWords);
                    pRemainedWords = szRemainedWords;
                }
            }
        }
        
        lstrcpy(pBBResource, szCurrentLine);
        pBBResource = &(pBBResource[lstrlen(szCurrentLine)+1]);
        iNumLines++;
        
    }

    HeapFree(GetProcessHeap(), 0, szRemainedWords);
    
    return iNumLines;

}

BOOL DrawWrapText(
    IN HDC          hdc,
    IN TEXTMETRIC*  lptm,
    IN int          iLineSpace,
    IN int          x,
    IN int          y,
    IN RECT*        lprc,
    IN WORD         wfPlacement,
    IN int          iLineCount,
    IN LPTSTR       szLines)
{
    UINT        uiTxtAlign = 0;
    BOOL        bRet = TRUE;
    SIZE        sz;
    int         Ly = 0;
    int         Lx = 0;
    LPTSTR      szText = szLines;
    int         i = 0;

    if (g_bBiDi)
    {
        uiTxtAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, uiTxtAlign|TA_RIGHT|TA_RTLREADING);
    }

    while (TRUE)
    {
        if(wfPlacement == CENTER)
        {
            //Get the dimensions of current string

            GetTextExtentPoint32(hdc, szText, lstrlen(szText), &sz);

            //x co-ord for TextOut 
            if (g_bBiDi)
                Lx = lprc->right - (((lprc->right - lprc->left) - sz.cx)/2);
            else
                Lx = lprc->left + (((lprc->right - lprc->left) - sz.cx)/2);
        }
        else
        {
            //x co-ord for TextOut 
            if (g_bBiDi)
                Lx = lprc->right - x;
            else
                Lx = lprc->left + x;
        }
        
        //calculate (y co-ord) for TextOut
        Ly = y + lptm->tmHeight * i + lptm->tmHeight * i * iLineSpace / 100;

        if (g_bBiDi)
        {
            bRet = ExtTextOut(hdc, Lx, Ly, ETO_RTLREADING, NULL, szText, lstrlen(szText), NULL);
        }
        else
        {
            bRet = TextOut(hdc, Lx, Ly, szText, lstrlen(szText));
        }

        if (!bRet) break;

        if (++i >= iLineCount) break;

        szText = &(szText[lstrlen(szText)+1]);

    }

    if (g_bBiDi)
    {
        SetTextAlign(hdc, uiTxtAlign);
    }

    return bRet;
}

LPTSTR
StringReverseChar(
    LPTSTR psz,
    TCHAR ch)
{
    PTCHAR pch;

    pch = psz + lstrlen(psz);
    while (pch != psz && *pch != ch)
    {
        pch = CharPrev(psz, pch);
    }

    if (*pch != ch)
    {
        pch = NULL;
    }

    return pch;
}

VOID ImproveWrap(
    IN OUT LPTSTR szLines,
    IN OUT PINT   piNumLine,
    IN     LPTSTR szOrigText,
    IN     INT    cchOrigText
    )

/*++

Routine Description:

    Force to wrap the last 'wrappable' part of the last line, if the last line
    contains more than one 'wrappable' parts.

Arguments:

    szLines     - The result of WrapText, contains lines delimited by '\0'

    iNumLine    - Number of line in szLines

    szOrigText  - The original text that produces szLines, null-terminated

    cchOrigText - Number of characters in szOrigText

Return Values:

    szLines     - if the last line contains more than one 'wrappable' parts,
                  szLines is modified.

--*/

{
#define NEAT_WRAPPING_RATIO  0.75

    PTCHAR pLastLineStart;
    int    cchLastLine;
    PTCHAR pLastWrapPartStart;
    int    cchLastWrapPart;
    int    iLineRemain;

    pLastLineStart = szLines;
    iLineRemain = *piNumLine;
    while (iLineRemain > 1)
    {
        pLastLineStart += lstrlen(pLastLineStart) + 1;
        iLineRemain--;
    }
    cchLastLine = lstrlen(pLastLineStart);

    pLastWrapPartStart = StringReverseChar(szOrigText, (TCHAR)'|');
    
    if (pLastWrapPartStart != NULL)
    {
        pLastWrapPartStart = CharNext(pLastWrapPartStart);
        cchLastWrapPart = lstrlen(pLastWrapPartStart);
        if ((cchLastLine * NEAT_WRAPPING_RATIO) > (double)cchLastWrapPart)
        {
            LPTSTR szTmp = pLastLineStart + (cchLastLine - cchLastWrapPart);

            MoveMemory(szTmp + 1, szTmp, (cchLastWrapPart + 1) * sizeof(TCHAR));
            szTmp[0] = (TCHAR)'\0';
            (*piNumLine)++;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\dibutil.h ===
#ifndef _DIBUTIL_H_
#define _DIBUTIL_H_

/* DIB constants */
#define PALVERSION   0x300

/* DIB macros */
#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))

/* Handle to a DIB */
#define HDIB HANDLE

UINT GetDeviceNumColors(HDC hdc);
HANDLE LoadDIB(LPTSTR lpFileName);
HPALETTE CreateDIBPalette(HDIB hDIB);
HBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal);
WORD DestroyDIB(HDIB hDib);
HPALETTE BuildPalette(HDC hdc);

void DrawBitmap (HDC hdc, HBITMAP hBitmap, int xStart, int yStart);
void DrawTransparentBitmap(
     HDC hdc,           // The destination DC.
     HBITMAP hBitmap,   // The bitmap to be drawn.
     int xPos,          // X coordinate.
     int yPos,          // Y coordinate.
     COLORREF col);     // The color for transparent



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\dllinit.c ===
#include <pch.h>
#include "billbrd.h"    


//DLLInit(
DllMain(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
#ifdef UNICODE
    INITCOMMONCONTROLSEX ControlInit;
#endif


    ReservedAndUnused;
    

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        g_hInstance = (HINSTANCE)DLLHandle;
        


#ifdef UNICODE
        
        // Need to initialize common controls in the comctl32 v6 case
        // in GUI mode setup. 

        ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
        ControlInit.dwICC = ICC_PROGRESS_CLASS;
        InitCommonControlsEx( &ControlInit );
#endif



        break;

    case DLL_PROCESS_DETACH:
        break ;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\dibutil.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include "dibutil.h"

HANDLE ReadDIBFile(HANDLE hfile);

/*************************************************************************
*
* GetDeviceNumColors()
*
* Purpose:  Determines how many colors the video device supports
*
* Returns:  (int) Number of colors supported
*
* History:   Date      Author       Reason
*            2/28/97   hanumany     Created
*
*
*
*************************************************************************/
UINT GetDeviceNumColors(HDC hdc)
{
    static UINT iNumColors = 0;
    
    if(!iNumColors)
        iNumColors = GetDeviceCaps(hdc, NUMCOLORS);
        
    return iNumColors;    
}


HANDLE LoadDIB(LPTSTR lpFileName)
{
   HANDLE hDIB = NULL;
   HANDLE hFile;

   /*
    * Set the cursor to a hourglass, in case the loading operation
    * takes more than a sec, the user will know what's going on.
    */

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        hDIB = ReadDIBFile(hFile);
        CloseHandle(hFile);
    }
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return hDIB;
}



/*
 * Dib Header Marker - used in writing DIBs to files
 */
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

HANDLE ReadDIBFile(HANDLE hFile)
{
    BITMAPFILEHEADER bmfHeader;
    DWORD dwBitsSize;
    DWORD dwRead;
    HANDLE hDIB;

    /*
    * get length of DIB in bytes for use when reading
    */
    
    dwBitsSize = GetFileSize(hFile, NULL);
    
    /*
    * Go read the DIB file header and check if it's valid.
    */
    if ((ReadFile(hFile, (LPVOID)&bmfHeader, sizeof(bmfHeader), &dwRead, NULL) == 0) ||
        (sizeof (bmfHeader) != dwRead))
    {
        return NULL;
    }
    
    if (bmfHeader.bfType != DIB_HEADER_MARKER)
    {
        return NULL;
    }
    
    /*
    * Allocate memory for DIB
    */
    hDIB = (HANDLE) HeapAlloc(GetProcessHeap(), 0, dwBitsSize);
    if (hDIB == NULL)
    {
        return NULL;
    }
    
    /*
    * Go read the bits.
    */
    if ((ReadFile(hFile, (LPVOID)hDIB, dwBitsSize - sizeof(BITMAPFILEHEADER), &dwRead, NULL) == 0) ||
        (dwBitsSize - sizeof(BITMAPFILEHEADER)!= dwRead))
    {
        HeapFree(GetProcessHeap(), 0, hDIB);
        return NULL;
    }
    return hDIB;
}

/*************************************************************************
 *
 * DIBNumColors()
 *
 * Parameter:
 *
 * LPBYTE lpDIB      - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * WORD             - number of colors in the color table
 *
 * Description:
 *
 * This function calculates the number of colors in the DIB's color table
 * by finding the bits per pixel for the DIB (whether Win3.0 or OS/2-style
 * DIB). If bits per pixel is 1: colors=2, if 4: colors=16, if 8: colors=256,
 * if 24, no colors in color table.
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *
 ************************************************************************/
WORD DIBNumColors(LPBYTE lpDIB)
{
   WORD wBitCount;  // DIB bit count

   /*  If this is a Windows-style DIB, the number of colors in the
    *  color table can be less than the number of bits per pixel
    *  allows for (i.e. lpbi->biClrUsed can be set to some value).
    *  If this is the case, return the appropriate value.
    */

   if (IS_WIN30_DIB(lpDIB))
   {
      DWORD dwClrUsed;

      dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
      if (dwClrUsed)
      {
         return (WORD)dwClrUsed;
      }
   }

   /*  Calculate the number of colors in the color table based on
    *  the number of bits per pixel for the DIB.
    */
   if (IS_WIN30_DIB(lpDIB))
      wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
   else
      wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;

   /* return number of colors based on bits per pixel */
   switch (wBitCount)
   {
       case 1:
          return 2;

       case 4:
          return 16;

       case 8:
          return 256;

       default:
          return 0;
   }
}

//-------------------------------------------------------------------------
//      B U I L D  P A L E T T E
//
//  Creates an HPALETTE from a bitmap in a DC
//-------------------------------------------------------------------------
HPALETTE BuildPalette(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    if (n == 0)
        return CreateHalftonePalette(hdc);

    for (i=1; i<=n; i++)
    {
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));
    }
    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE)&adw[0]);
}

/*************************************************************************
 *
 * CreateDIBPalette()
 *
 * Parameter:
 *
 * HDIB hDIB        - specifies the DIB
 *
 * Return Value:
 *
 * HPALETTE         - specifies the palette
 *
 * Description:
 *
 * This function creates a palette from a DIB by allocating memory for the
 * logical palette, reading and storing the colors from the DIB's color table
 * into the logical palette, creating a palette from this logical palette,
 * and then returning the palette's handle. This allows the DIB to be
 * displayed using the best possible colors (important for DIBs with 256 or
 * more colors).
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *            10/08/97  hanumany             check GlobalLock return code
 *
 ************************************************************************/
HPALETTE CreateDIBPalette(HDIB hDIB)
{
    LPLOGPALETTE lpPal = NULL;      // pointer to a logical palette
    HANDLE hLogPal = NULL;          // handle to a logical palette
    HPALETTE hPal = NULL;           // handle to a palette
    int i = 0, wNumColors = 0;      // loop index, number of colors in color table
    LPBYTE lpbi = NULL;              // pointer to packed-DIB
    LPBITMAPINFO lpbmi = NULL;      // pointer to BITMAPINFO structure (Win3.0)
    LPBITMAPCOREINFO lpbmc = NULL;  // pointer to BITMAPCOREINFO structure (OS/2)
    BOOL bWinStyleDIB;              // flag which signifies whether this is a Win3.0 DIB
    
    /* if handle to DIB is invalid, return NULL */
    
    if (!hDIB)
        return NULL;
    
    /* get pointer to BITMAPINFO (Win 3.0) */
    lpbmi = (LPBITMAPINFO)hDIB;
    
    /* get pointer to BITMAPCOREINFO (OS/2 1.x) */
    lpbmc = (LPBITMAPCOREINFO)hDIB;
    
    /* get the number of colors in the DIB */
    wNumColors = DIBNumColors(hDIB);
    
    /* is this a Win 3.0 DIB? */
    bWinStyleDIB = IS_WIN30_DIB(hDIB);
    if (wNumColors)
    {
        /* allocate memory block for logical palette */
        lpPal = (HANDLE) HeapAlloc(GetProcessHeap(), 0, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) *  wNumColors);
        
        /* if not enough memory, clean up and return NULL */
        if (!lpPal)
        {
            return NULL;
        }
        
        /* set version and number of palette entries */
        lpPal->palVersion = PALVERSION;
        lpPal->palNumEntries = (WORD)wNumColors;
        
        /*  store RGB triples (if Win 3.0 DIB) or RGB quads (if OS/2 DIB)
        *  into palette
        */
        for (i = 0; i < wNumColors; i++)
        {
            if (bWinStyleDIB)
            {
                lpPal->palPalEntry[i].peRed = lpbmi->bmiColors[i].rgbRed;
                lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
                lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
            else
            {
                lpPal->palPalEntry[i].peRed = lpbmc->bmciColors[i].rgbtRed;
                lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;
                lpPal->palPalEntry[i].peBlue = lpbmc->bmciColors[i].rgbtBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
        }
        
        /* create the palette and get handle to it */
        hPal = CreatePalette(lpPal);
    }
    
    /* clean up */
    HeapFree(GetProcessHeap(), 0, lpPal);
    
    /* return handle to DIB's palette */
    return hPal;
}


WORD PaletteSize(LPBYTE lpDIB)
{
   /* calculate the size required by the palette */
   if (IS_WIN30_DIB (lpDIB))
      return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
   else
      return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}
/*************************************************************************
 *
 * FindDIBBits()
 *
 * Parameter:
 *
 * LPBYTE lpDIB      - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * LPBYTE            - pointer to the DIB bits
 *
 * Description:
 *
 * This function calculates the address of the DIB's bits and returns a
 * pointer to the DIB bits.
 *
 * History:   Date      Author              Reason
 *            6/01/91   Garrett McAuliffe   Created
 *            9/15/91   Patrick Schreiber   Added header and comments
 *
 ************************************************************************/
LPBYTE FindDIBBits(LPBYTE lpDIB)
{
   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));
}
/*************************************************************************
 *
 * DIBToBitmap()
 *
 * Parameters:
 *
 * HDIB hDIB        - specifies the DIB to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HBITMAP          - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a bitmap from a DIB using the specified palette.
 * If no palette is specified, default is used.
 *
 * NOTE:
 *
 * The bitmap returned from this funciton is always a bitmap compatible
 * with the screen (e.g. same bits/pixel and color planes) rather than
 * a bitmap with the same attributes as the DIB.  This behavior is by
 * design, and occurs because this function calls CreateDIBitmap to
 * do its work, and CreateDIBitmap always creates a bitmap compatible
 * with the hDC parameter passed in (because it in turn calls
 * CreateCompatibleBitmap).
 *
 * So for instance, if your DIB is a monochrome DIB and you call this
 * function, you will not get back a monochrome HBITMAP -- you will
 * get an HBITMAP compatible with the screen DC, but with only 2
 * colors used in the bitmap.
 *
 * If your application requires a monochrome HBITMAP returned for a
 * monochrome DIB, use the function SetDIBits().
 *
 * Also, the DIBpassed in to the function is not destroyed on exit. This
 * must be done later, once it is no longer needed.
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *            3/27/92   Mark Bader           Added comments about resulting
 *                                           bitmap format
 *            10/08/97  hanumany             check GlobalLock return code.
 *
 ************************************************************************/
HBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal)
{
   LPBYTE lpDIBHdr, lpDIBBits;  // pointer to DIB header, pointer to DIB bits
   HBITMAP hBitmap;            // handle to device-dependent bitmap
   HDC hDC;                    // handle to DC
   HPALETTE hOldPal = NULL;    // handle to a palette

   /* if invalid handle, return NULL */

   if (!hDIB)
      return NULL;

   /* get a pointer to the DIB bits */
   lpDIBBits = FindDIBBits(hDIB);

   /* get a DC */
   hDC = GetDC(NULL);
   if (!hDC)
   {
      return NULL;
   }

   /* select and realize palette */
   if (hPal)
      hOldPal = SelectPalette(hDC, hPal, FALSE);
   RealizePalette(hDC);

   /* create bitmap from DIB info. and bits */
   hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)hDIB, CBM_INIT,
                (LPCVOID)lpDIBBits, (LPBITMAPINFO)hDIB, DIB_RGB_COLORS);

   /* restore previous palette */
   if (hOldPal)
      SelectPalette(hDC, hOldPal, FALSE);

   /* clean up */
   ReleaseDC(NULL, hDC);

   /* return handle to the bitmap */
   return hBitmap;
}

WORD DestroyDIB(HDIB hDib)
{
    HeapFree(GetProcessHeap(), 0, hDib);
    return 0;
}

/******************************************************************
 *
 * DrawBitmap()
 *
 * This function paints the given bitmap at the given coordinates.
 *
 ******************************************************************/
void  DrawBitmap (HDC hdc, HBITMAP hBitmap, int xStart, int yStart)
{
    BITMAP  bm;
    HDC     hdcMem;
    POINT   ptSize, ptOrg;
    HBITMAP hBitmapOld = NULL;

    if (hBitmap == NULL) {
        return;
    }

    hdcMem = CreateCompatibleDC (hdc);
    if (hdcMem == NULL)
    {
        return;
    }
    SetBkMode(hdcMem, TRANSPARENT);
    hBitmapOld = SelectObject(hdcMem, hBitmap);
    SetMapMode(hdcMem, GetMapMode(hdc));


    GetObject(hBitmap, sizeof(BITMAP), (LPVOID)&bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP(hdc, &ptSize, 1);

    ptOrg.x = 0;
    ptOrg.y = 0;
    DPtoLP(hdcMem, &ptOrg, 1);

    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y, SRCCOPY);

    SelectObject(hdcMem, hBitmapOld);
    DeleteDC(hdcMem);
}

/******************************************************************
 *
 * DrawTransparentBitmap()
 *
 * This function paints the given bitmap at the given coordinates.
 * and allow for one transparent color
 *
 ******************************************************************/
void DrawTransparentBitmap(
    HDC hdc,
    HBITMAP hBitmap,
    int xStart,
    int yStart,
    COLORREF cTransparentColor )
{
    BITMAP     bm;
    COLORREF   cColor;
    HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
    HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
    HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT      ptSize;
    
    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, hBitmap);
    
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP(hdcTemp, &ptSize, 1);
    
    hdcBack   = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem    = CreateCompatibleDC(hdc);
    hdcSave   = CreateCompatibleDC(hdc);
    
    bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
    
    bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
    
    bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    
    bmBackOld   = SelectObject(hdcBack, bmAndBack);
    bmObjectOld = SelectObject(hdcObject, bmAndObject);
    bmMemOld    = SelectObject(hdcMem, bmAndMem);
    bmSaveOld   = SelectObject(hdcSave, bmSave);
    
    SetMapMode(hdcTemp, GetMapMode(hdc));
    
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);
    
    cColor = SetBkColor(hdcTemp, cTransparentColor);
    
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0,
        SRCCOPY);
    
    SetBkColor(hdcTemp, cColor);
    
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0,
        NOTSRCCOPY);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,
        SRCCOPY);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);
    
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);
    
    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0,
        SRCCOPY);
    
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);
    
    DeleteObject(SelectObject(hdcBack, bmBackOld));
    DeleteObject(SelectObject(hdcObject, bmObjectOld));
    DeleteObject(SelectObject(hdcMem, bmMemOld));
    DeleteObject(SelectObject(hdcSave, bmSaveOld));
    
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winntbb.rc
//
#define IDS_INFOFONTSIZE_1024           1
#define IDS_INFOFONTSIZE_800            2
#define IDS_INFOFONTSIZE_640            3
#define IDS_INFOFONTNAME                4
#define IDS_TITLEFONTNAME               5
#define IDS_TITLEFONTSIZE_1024          6
#define IDS_TITLEFONTWIDTH_1024         7
#define IDS_TEXTFONTSIZE_1024           8
#define IDS_TEXTFONTWIDTH_1024          9
#define IDS_TITLEFONTSIZE_800           10
#define IDS_TITLEFONTWIDTH_800          11
#define IDS_TEXTFONTSIZE_800            12
#define IDS_TEXTFONTWIDTH_800           13
#define IDS_TITLEFONTSIZE_640           14
#define IDS_TITLEFONTWIDTH_640          15
#define IDS_TEXTFONTSIZE_640            16
#define IDS_TEXTFONTWIDTH_640           17
#define IDD_TITLEFONTWEIGHT             18
#define IDS_TEXTFONTNAME                19
#define IDD_TEXTFONTWEIGHT              20
#define IDD_PANELCOUNT                  21
#define IDD_ANIMATION                   22
#define IDS_STEP1                       23
#define IDS_STEP2                       24
#define IDS_STEP3                       25
#define IDS_WINNT_SETUP                 26
#define IDS_TITLE1                      27
#define IDS_TEXT1                       28
#define IDS_TITLE2                      29
#define IDS_TEXT2                       30
#define IDS_TITLE3                      31
#define IDS_TEXT3                       32
#define IDS_TITLE4                      33
#define IDS_TEXT4                       34
#define IDS_TITLE5                      35
#define IDS_TEXT5                       36
#define IDS_TITLE6                      37
#define IDS_TEXT6                       38
#define IDS_TITLE7                      39
#define IDS_TEXT7                       40
#define IDS_TITLE8                      41
#define IDS_TEXT8                       42
#define IDS_TITLE9                      43
#define IDS_TEXT9                       44
#define IDS_TITLE10                     45
#define IDS_TEXT10                      46
#define IDS_TITLE11                     47
#define IDS_TEXT11                      48
#define IDS_TITLE12                     49
#define IDS_TEXT12                      50
#define IDS_TITLE13                     51
#define IDS_TEXT13                      52
#define IDS_TITLE14                     53
#define IDS_TEXT14                      54
#define IDS_TITLE15                     55
#define IDS_TEXT15                      56
#define IDS_TITLE16                     57
#define IDS_TEXT16                      58
#define IDS_TITLE17                     59
#define IDS_TEXT17                      60
#define IDS_TITLE18                     61
#define IDS_TEXT18                      62
#define IDS_STEP4                       63
#define IDS_STEP5                       64
#define IDS_TEXTFONT_LINESPACING        65

#define IDI_SETUP                       81

#define IDB_LOGO640_C16BIT              100
#define IDB_LOGO800_C16BIT              101  
#define IDB_LOGO1024_C16BIT             102  
#define IDB_BACKGROUND_C16BIT           103
#define IDB_SELECTEDBULLET_C16BIT       104
#define IDB_RELEASEDBULLET_C16BIT       105
#define IDB_CURRENTBULLET_C16BIT        109

#define IDB_LOGO1024_C8BIT              125

#define IDB_LOGO640_C4BIT               150
#define IDB_LOGO800_C4BIT               151
#define IDB_LOGO1024_C4BIT              152
#define IDB_BACKGROUND_C4BIT            153
#define IDB_SELECTEDBULLET_C4BIT        154
#define IDB_RELEASEDBULLET_C4BIT        155
#define IDB_CURRENTBULLET_C4BIT         156

#define IDB_COLL1                       171
#define IDB_COLL2                       172
#define IDB_COLL3                       173
#define IDB_COLL4                       174
#define IDB_COLL5                       175
#define IDB_COLL6                       176
#define IDB_COLL7                       177
#define IDB_COLL8                       178
#define IDB_COLL9                       179
#define IDB_COLL10                      180

#define IDB_BULLET_1                    181

#define IDB_INTENSITY1_C16BIT           185
#define IDB_INTENSITY2_C16BIT           186
#define IDB_INTENSITY3_C16BIT           187
#define IDB_INTENSITY4_C16BIT           188
#define IDB_INTENSITY1_C4BIT            189
#define IDB_INTENSITY2_C4BIT            190
#define IDB_INTENSITY3_C4BIT            191
#define IDB_INTENSITY4_C4BIT            192

#define IDS_TITLE1_S                    200
#define IDS_TEXT1_S                     201
#define IDS_TITLE2_S                    202
#define IDS_TEXT2_S                     203
#define IDS_TITLE3_S                    204
#define IDS_TEXT3_S                     205
#define IDS_TITLE4_S                    206
#define IDS_TEXT4_S                     207
#define IDS_TITLE5_S                    208
#define IDS_TEXT5_S                     209
#define IDS_TITLE6_S                    210
#define IDS_TEXT6_S                     211
#define IDS_TITLE7_S                    212
#define IDS_TEXT7_S                     213
#define IDS_TITLE8_S                    214
#define IDS_TEXT8_S                     215
#define IDS_TITLE9_S                    216
#define IDS_TEXT9_S                     217

#define IDS_TITLE1_PER                  300
#define IDS_TEXT1_PER                   301
#define IDS_TITLE2_PER                  302
#define IDS_TEXT2_PER                   303
#define IDS_TITLE3_PER                  304
#define IDS_TEXT3_PER                   305
#define IDS_TITLE4_PER                  306
#define IDS_TEXT4_PER                   307
#define IDS_TITLE5_PER                  308
#define IDS_TEXT5_PER                   309
#define IDS_TITLE6_PER                  310
#define IDS_TEXT6_PER                   311
#define IDS_TITLE7_PER                  312
#define IDS_TEXT7_PER                   313
#define IDS_TITLE8_PER                  314
#define IDS_TEXT8_PER                   315
#define IDS_TITLE9_PER                  316
#define IDS_TEXT9_PER                   317
#define IDS_TITLE10_PER                 318
#define IDS_TEXT10_PER                  319
#define IDS_TITLE11_PER                 320
#define IDS_TEXT11_PER                  321
#define IDS_TITLE12_PER                 322
#define IDS_TEXT12_PER                  323
#define IDS_TITLE13_PER                 324
#define IDS_TEXT13_PER                  325
#define IDS_TITLE14_PER                 326
#define IDS_TEXT14_PER                  327
#define IDS_TITLE15_PER                 328
#define IDS_TEXT15_PER                  329
#define IDS_TITLE16_PER                 330
#define IDS_TEXT16_PER                  331
#define IDS_TITLE17_PER                 332
#define IDS_TEXT17_PER                  333
#define IDS_TITLE18_PER                 334
#define IDS_TEXT18_PER                  335
#define IDS_TITLE19_PER                 336
#define IDS_TEXT19_PER                  337
#define IDS_TITLE20_PER                 338
#define IDS_TEXT20_PER                  339
#define IDS_TITLE21_PER                 340
#define IDS_TEXT21_PER                  341
#define IDS_TITLE22_PER                 342
#define IDS_TEXT22_PER                  343

#define IDS_TITLE1_64PRO                400
#define IDS_TEXT1_64PRO                 401
#define IDS_TITLE2_64PRO                402
#define IDS_TEXT2_64PRO                 403
#define IDS_TITLE3_64PRO                404
#define IDS_TEXT3_64PRO                 405
#define IDS_TITLE4_64PRO                406
#define IDS_TEXT4_64PRO                 407
#define IDS_TITLE5_64PRO                408
#define IDS_TEXT5_64PRO                 409
#define IDS_TITLE6_64PRO                410
#define IDS_TEXT6_64PRO                 411
#define IDS_TITLE7_64PRO                412
#define IDS_TEXT7_64PRO                 413
#define IDS_TITLE8_64PRO                414
#define IDS_TEXT8_64PRO                 415
#define IDS_TITLE9_64PRO                416
#define IDS_TEXT9_64PRO                 417
#define IDS_TITLE10_64PRO               418
#define IDS_TEXT10_64PRO                419
#define IDS_TITLE11_64PRO               420
#define IDS_TEXT11_64PRO                421
#define IDS_TITLE12_64PRO               422
#define IDS_TEXT12_64PRO                423
#define IDS_TITLE13_64PRO               424
#define IDS_TEXT13_64PRO                425
#define IDS_TITLE14_64PRO               426
#define IDS_TEXT14_64PRO                427
#define IDS_TITLE15_64PRO               428
#define IDS_TEXT15_64PRO                429

#define IDD_BIDI                        1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\sources.inc ===
MAJORCOMP=setup

TARGETPATH=..\obj
TARGETTYPE=DYNLINK

DLLDEF=..\winntbb.def
DLLENTRY=_DllMainCRTStartup

NO_NTDLL=1
USE_LIBCMT=1
SUBSYSTEM_VERSION=4.00
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET

!include $(PROJECT_ROOT)\ntsetup\sources.inc

INCLUDES=\
    ..\..;                 \
    ..\..\..\inc;          \
    $(DS_INC_PATH);     \
    $(SHELL_INC_PATH);  \
    $(BASE_INC_PATH);   \
    $(WINDOWS_INC_PATH); \
    $(ENDUSER_INC_PATH); \
    $(NET_INC_PATH)

!ifdef USE_FAST_ALLOC
!if $(USE_FAST_ALLOC) == 0
C_DEFINES=$(C_DEFINES) -DUSE_FAST_ALLOC=0
!else
C_DEFINES=$(C_DEFINES) -DUSE_FAST_ALLOC=1
!endif
!endif

!ifdef _WIN32_IE
!undef _WIN32_IE
!endif

C_DEFINES=$(C_DEFINES) -DDBGHEAP_CHECK -D_WIN32_IE=0x0400

SOURCES= \
        dllinit.c \
        info.c    \
        addpath.c \
        billbrd.c \
        dibutil.c \
        animate.c \
        winntbb.rc

TARGETLIBS = \
              $(SDK_LIB_PATH)\user32.lib      \
              $(SDK_LIB_PATH)\gdi32.lib      \
              $(SDK_LIB_PATH)\advapi32.lib    \
              $(SDK_LIB_PATH)\kernel32.lib 
#              $(SDK_LIB_PATH)\ole32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\winntbb.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#include <windows.h>

//---------------------------------------------------------------------------
// Global to the app.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\info.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

const UINT  uiIDSteps[] = {
    IDS_STEP1,
    IDS_STEP2,
    IDS_STEP3,
    IDS_STEP4,
    IDS_STEP5 };
int     g_iCurrentStep  = 1;
HFONT   g_hfont         = NULL;
HFONT   g_hfontBold     = NULL;

TCHAR   g_szBuffer[MAX_STRING];

int GetStepText(int nStep, LPTSTR lpStr);

int PaintStepsText(HDC hdc, RECT rc);

BOOL GetStepsHeight(
    IN  UINT  cxScreen,
    IN  UINT  cyScreen,
    IN  RECT  rcSteps,
    OUT UINT* pcyBottom)
{
    HDC     hdcMem = NULL;
    HDC     hdcScreen = NULL;
    HBITMAP hbmpMem = NULL;
    BOOL    bRet = FALSE;

    hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        hdcMem = CreateCompatibleDC(hdcScreen);
        hbmpMem = CreateCompatibleBitmap(hdcScreen,
                                         cxScreen,
                                         cyScreen);

        if (hdcMem && hbmpMem)
        {           
            SelectObject(hdcMem, hbmpMem);
            *pcyBottom = (UINT) PaintStepsText(hdcMem, rcSteps);
            bRet = TRUE;
        }

        if (hbmpMem)
        {
            DeleteObject(hbmpMem);
        }

        if (hdcMem)
        {
            DeleteDC(hdcMem);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    return bRet;

}
/*****************************************************************************
* GetInfoBarFontHeight
*
* Export this function to facilities size estimation of g_hwndSteps.
*
******************************************************************************/
int GetInfoBarFontHeight()
{
    int iInfobarRegularFontSize = 0;
    int idsInfobarFontSize;
    int iScreenSize;
    TCHAR szBuf[25];

    BB_ASSERT(g_hInstance != NULL);

    iScreenSize = GetSystemMetrics(SM_CXSCREEN);
    if(iScreenSize >= 1024)
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_1024;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_1024;
    }
    else if(iScreenSize == 800) 
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_800;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_800;
    }
    else
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_640;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_640;
    }

    if (LoadString(g_hInstance,
                    idsInfobarFontSize,
                    szBuf,
                    sizeof(szBuf)/sizeof(TCHAR)) != 0)
    {
        iInfobarRegularFontSize = MyAtoI((const TCHAR *)szBuf);
    }

    return -MulDiv(iInfobarRegularFontSize, 96, 72);

}

/******************************************************************
*
* CreateInfoBarFonts
*
* This function creates two fonts for the infobar based on the 
* screen resolution. The fonts are the same size, one is bold
* and the other is normal. These fonts are used throughout infobar.
*
*******************************************************************/
BOOL CreateInfoBarFonts()
{
    LOGFONT lf = {0};
    TCHAR szSetupFontName[MAX_PATH];
    int ifHeight = 0;
    
    ifHeight = GetInfoBarFontHeight();

    if (!(LoadString(g_hInstance, IDS_INFOFONTNAME, (LPTSTR)szSetupFontName, MAX_PATH)))
    {
        lstrcpy(szSetupFontName, TEXT("system"));
    }

    //Create a font that will be used in the Infobar ui
    /*keep font size constant, even with large fonts*/
    lf.lfHeight = ifHeight;
    lstrcpy(lf.lfFaceName, (LPTSTR)szSetupFontName);
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfWeight = FW_NORMAL;
    lf.lfQuality = PROOF_QUALITY;
#ifdef WINDOWS_THAI
    lf.lfCharSet = ANSI_CHARSET; //Thai Textout problem for Infobar font
#else
    lf.lfCharSet = g_bCharSet;
#endif
    g_hfont = CreateFontIndirect(&lf);

    //Create a Bold font 
    /*keep font size constant, even with large fonts*/
    lf.lfHeight = ifHeight;
    lstrcpy(lf.lfFaceName, (LPTSTR)szSetupFontName);
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfWeight = FW_SEMIBOLD;
    lf.lfQuality = PROOF_QUALITY;
#ifdef WINDOWS_THAI
    lf.lfCharSet = ANSI_CHARSET; //Thai Textout problem for Infobar font
#else
    lf.lfCharSet = g_bCharSet;
#endif
    g_hfontBold = CreateFontIndirect(&lf);

        
    if(g_hfont && g_hfontBold)
        return TRUE;
    else 
        return FALSE;
}

/******************************************************************
*
* DeleteInfoBarFonts()
*
* This function deletes the two global fonts for the infobar.
*
*******************************************************************/
void DeleteInfoBarFonts(void)
{
    if(g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }
    if(g_hfontBold)
    {
        DeleteObject(g_hfontBold);
        g_hfontBold = NULL;
    }
}


/**********************************************************************
* PaintStepsText()
*
* Paint the setup steps in the steps window. Highlites the current step.
*
**********************************************************************/
int PaintStepsText(HDC hdc, RECT rc)
{
    static TCHAR szSteps[UI_INFOBAR_NUM_STEPS][MAX_STRING];
    static int   iNumLines[UI_INFOBAR_NUM_STEPS];
    static int   iMaxNumLines = 1;
    static RECT  rcSteps = {0, 0, 0, 0};

    COLORREF    crOld = 0;
    int         cxStepText;
    int         cxStepBullet;
    int         cyStep;
    RECT        rcStepText;    
    HFONT       hfontOld = NULL;
    TEXTMETRIC  tm;
    BITMAP      bm;
    HBITMAP     hbitmapOn = NULL;
    HBITMAP     hbitmapOff = NULL;
    HBITMAP     hbitmapHalf = NULL;
    HBITMAP     hbitmap = NULL;
    
    int         iCurrentStep = 0;
    
    //do gdi stuff
    SaveDC(hdc);
    SetMapMode(hdc, MM_TEXT);
    SetBkMode( hdc, TRANSPARENT );
   
    hbitmapOn = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbSelectedBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );
    hbitmapOff = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbReleasedBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );
    hbitmapHalf = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbCurrentBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );

    // select either one to get the width of the bullets
    // assume both type of bullet have same width    
    hbitmap = (hbitmapOn) ? hbitmapOn : hbitmapOff;
    if (hbitmap)
    {
        GetObject( hbitmap, sizeof(BITMAP), &bm );
    }
    else
    {
        bm.bmWidth = 0;
    }

    crOld = SetTextColor(hdc, g_colStepsTxt);
    SelectObject(hdc, g_hfontBold);
    GetTextMetrics(hdc, &tm);
    
    if (g_bBiDi)
    {
        cxStepBullet = rc.right - bm.bmWidth;
        cxStepText = 0;
        
        rcStepText.left = rc.left;
        rcStepText.right = rc.right - 3 * bm.bmWidth / 2;
        rcStepText.top = rc.top;
        rcStepText.bottom = rc.bottom;
    }
    else
    {
        cxStepBullet = rc.left;
        cxStepText = 3 * bm.bmWidth / 2;
        
        rcStepText.left = rc.left;
        rcStepText.right = rc.right;
        rcStepText.top = rc.top;
        rcStepText.bottom = rc.bottom;
    }        

    if (!EqualRect(&rcSteps, &rc))
    {        
        iMaxNumLines = 1;
        for (iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
        {
            if (!LoadString(g_hInstance, uiIDSteps[iCurrentStep-1],
                (LPTSTR)szSteps[iCurrentStep-1], MAX_STRING))
            {
                szSteps[iCurrentStep-1][0] = TEXT('\0');
            }
            
            iNumLines[iCurrentStep-1] = 
                WrapText(hdc, cxStepText, &rcStepText, szSteps[iCurrentStep-1]);
            
            if (iNumLines[iCurrentStep-1] > iMaxNumLines)
            {
                iMaxNumLines = iNumLines[iCurrentStep-1];
            }
        }
        
        for (iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
        {
            if (iNumLines[iCurrentStep-1] < iMaxNumLines)
            {
                TCHAR szStep[MAX_STRING];
                INT   cchStep;

                // ImproveWrap may add a null character to the string.
                cchStep = LoadString(g_hInstance, uiIDSteps[iCurrentStep-1],
                    (LPTSTR)szStep, MAX_STRING - 1);

                if (cchStep != 0)
                {
                    ImproveWrap(szSteps[iCurrentStep-1],
                                &iNumLines[iCurrentStep-1],
                                szStep,
                                cchStep);
                }
            }
        }
        
        CopyRect(&rcSteps, &rc);
    }

    cyStep = rc.top;
    
    for(iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
    {        
        if(iCurrentStep < g_iCurrentStep)
        {
            SetTextColor(hdc, g_colStepsMarkTxt);
            SelectObject(hdc, g_hfontBold);
            hbitmap = hbitmapOn;
        }
        else if (iCurrentStep == g_iCurrentStep)
        {
            SetTextColor(hdc, g_colStepsCurrentTxt);
            SelectObject(hdc, g_hfontBold);
            hbitmap = hbitmapHalf;
        }
        else
        {
            SetTextColor(hdc, g_colStepsTxt);
            SelectObject(hdc, g_hfont);
            hbitmap = hbitmapOff;
        }

        if(!hbitmap)
        {
            OutputDebugString(TEXT("Billboard: PaintStepsText failed to load bitmap\r\n"));
        }    
        else
        {
            DrawTransparentBitmap(
                hdc,
                hbitmap,
                cxStepBullet,
                cyStep,
                g_colBulletTrans);
        }

        DrawWrapText(
            hdc,
            &tm,
            0,
            cxStepText,
            cyStep,
            &rcStepText,
            LEFT,
            iNumLines[iCurrentStep-1],
            szSteps[iCurrentStep-1]);

        
        if (iCurrentStep != UI_INFOBAR_NUM_STEPS)
        {
            cyStep += tm.tmHeight * (iMaxNumLines + 1);
        }
        else
        {
            int inc = tm.tmHeight * iMaxNumLines;
            if (inc  < bm.bmHeight)
            {
                cyStep += bm.bmHeight;
            }
            else
            {
                cyStep += inc;
            }
        }
            
    }

    if (hbitmapOn)
    {
        DeleteObject(hbitmapOn);
        hbitmapOn = NULL;
    }

    if (hbitmapOff)
    {
        DeleteObject(hbitmapOff);
        hbitmapOff = NULL;
    }

    hbitmap = NULL;

    RestoreDC(hdc, -1);
    SelectObject(hdc, hfontOld);  // select the original font back into the DC
    SetTextColor(hdc, crOld);
    
    return cyStep;
}


LRESULT CALLBACK InfoBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    switch (msg)
    {

        case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            RECT            rc;
            HDC             hdc;
            RECT    rcToParent;
            HWND    hwndParent;
            HDC     hdcBG;
            HDC     hdcMem;
            HBITMAP hbmpMem;

            // try to draw steps without flickle
            
            hdc = BeginPaint(hwnd, &ps);

            GetClientRect(hwnd, &rc);
            GetRectInParent(hwnd, &rc, &rcToParent);
            
            hdcBG = GetBackgroundBuffer();
            
            hdcMem = CreateCompatibleDC(hdc);
            hbmpMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);                        
            if (hdcMem && hbmpMem)
            {
                RECT    rcLP;
                                          
                SelectObject(hdcMem, hbmpMem);

                BitBlt(hdcMem,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       rc.bottom - rc.top,
                       hdcBG,
                       rcToParent.left,
                       rcToParent.top,
                       SRCCOPY);
                
                CopyRect(&rcLP, &rc);
                DPtoLP(hdcMem, (LPPOINT) &rcLP, 2);
                PaintStepsText(hdcMem, rcLP);
                
                BitBlt(hdc,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       rc.bottom - rc.top,
                       hdcMem,
                       rc.left,
                       rc.top,
                       SRCCOPY);
                
            }

            if (hbmpMem != NULL)
            {
                DeleteObject(hbmpMem);
                hbmpMem = NULL;
            }

            if (hdcMem != NULL) {
                DeleteDC(hdcMem);
                hdcMem = NULL;
            }

            EndPaint(hwnd, &ps);
            
            return(0);

        }

        case WM_SETSTEP:
        {
            int     iPanel;
            int     ret;
 
            iPanel = (int) lParam;
            if (iPanel <= UI_INFOBAR_NUM_STEPS)
            {                
                g_iCurrentStep = iPanel;
                ret = 1;
                InvalidateRect(hwnd, NULL, FALSE);
                UpdateWindow(hwnd);
            }
            else
            {
                ret = 0;
            }
    
            return ret;
        }
        
        case WM_DESTROY:
        {
            DeleteInfoBarFonts();

            return (DefWindowProc(hwnd, msg, wParam, lParam));
        }

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}


BOOL WINAPI InitInfoBar(HWND hwndParent)
{
    WNDCLASS  wc;
    RECT    rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = (WNDPROC)InfoBarWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szStepsClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    GetWindowRect(hwndParent, &rc1);
    g_hwndSteps = CreateWindow(
        g_szStepsClassName,
        TEXT(""),
        WS_CHILD, 
        rc1.left + g_cxSteps,
        rc1.top + g_cySteps,
        g_cxStepsWidth,
        g_cyStepsHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndSteps == NULL)
    {
        UnregisterClass(g_szStepsClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndSteps, SW_SHOW );
    UpdateWindow( g_hwndSteps );

    return TRUE;

}


int GetStepText(int nStep, LPTSTR lpStr)
{
    TCHAR szStep[16];
    wsprintf(szStep, TEXT("Step%d"), nStep);
    return GetPrivateProfileString(TEXT("Steps"), szStep, TEXT(""), 
                           lpStr, MAX_PATH, g_szFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\ansi\pch.h ===
#include <windows.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\billbrd\unicode\pch.h ===
#include <windows.h>
#include <stdlib.h>
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\acllist\acllist.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;
char* product;

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== ACLLIST =============\n")
    PRINT2("Input BOM: %s\n",argv[2]);
    PRINT2("Output path: %s\n",argv[3]);
    PRINT2("Product: %s\n",argv[4]);
    PRINT2("Platform: %s\n",argv[5]);
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("==================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Create ACLLIST.INF for the specified product.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM for which ACLLIST.INF is to be made.\n");
    printf("[Output path] - Path of the ACL list to create.\n");
    printf("[Product] - Product to make ACLLIST.INF for - NTFLOP, LMFLOP, NTCD, LMCD.\n");
    printf("[Platform] - X86, ALPHA, or MIPS\n");
}

int __cdecl ACLPathCompare(const void *,const void *);

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry *e;
    int records,i,j,lanmanProduct;
    char *buf;
    FILE *f;
    char path[MAX_PATH];
    char *acl;

    if (argc!=6) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
	printf("ERROR Couldn't open log file %s\n",argv[1]);
	return(1);
    }
    Header(argv);

    LoadFile(argv[2],&buf,&e,&records,argv[4]);

    if (MyOpenFile(&f,argv[3],"w")) exit(1);

    for (i=0;i<records;i++)
	if (e[i].medianame[0])
	    e[i].name=e[i].medianame;

    qsort(e,records,sizeof(Entry),ACLPathCompare);

    for (j=0,i=0;i<records;i++)
	if (!_stricmp(e[i].platform,argv[5]) && ((j==0) || _stricmp(e[i].name,e[j-1].name) || _stricmp(e[i].aclpath,e[j-1].aclpath)))
	{
	    e[j].name=e[i].name;
	    e[j].aclpath=e[i].aclpath;
	    e[j].lmacl=e[i].lmacl;
	    e[j].ntacl=e[i].ntacl;
	    e[j].platform=e[i].platform;
	    j++;
	}
    records=j;

    lanmanProduct=(!_stricmp(argv[4],"LMCD") || !_stricmp(argv[4],"LMFLOP"));

    for (i=0;i<records;i++)
    {
	if (!e[i].aclpath[0])
	    PRINT2("WARNING Not including %s in winperms.txt.  No ACL path specified.\n",e[i].name)
	else if (lanmanProduct && !e[i].lmacl[0])
	    PRINT2("WARNING Not including %s in winperms.txt.  No LM ACL specified.\n",e[i].name)
	else if (!lanmanProduct && !e[i].ntacl[0])
	    PRINT2("WARNING Not including %s in winperms.txt.  No NT ACL specified.\n",e[i].name)
	else
	{
	    acl=(lanmanProduct ? e[i].lmacl : e[i].ntacl);
	    j=0; while (acl[j]) if (acl[j++]=='*') acl[j-1]=',';
	    strcpy(path,e[i].aclpath);
	    if (path[strlen(path)-1]=='\\')
		path[strlen(path)-1]='\0';
	    strcat(path,"\\");
	    strcat(path,e[i].name);
	    fprintf(f,"%s %s\n",path,acl);
	}
    }

    if (f!=NULL) fclose(f);
    fclose(logFile);
    free(e);
    return(0);
}

int __cdecl ACLPathCompare(const void *v1, const void *v2)
{
    int result;
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    if (result=_stricmp(e1->platform,e2->platform)) return(result);
    if (result=_stricmp(e1->aclpath,e2->aclpath)) return(result);
    return (_stricmp(e1->name,e2->name));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\autorun\autorun.c ===
/*
    03.13.96    Joe Holman (joehol)     Ported from Win95 to NT.
    09.23.96    Joe Holman (joehol)     Added the code to check for new version message
                                        and old version message.
    12.05.96    Joe Holman (joehol)     Added code to have only one copy running at time.
                                        Win95 and NT now calls winnt32.exe.
    08.20.97    Joe Holman (joehol)     Backport the Japanese code for NEC's PC-98 machine
                                        so that we launch autorun from i386, but then turn
                                        around and launch winnt32.exe from NEC98.

Issues:


    - for Win95, we want to show:

        - WINNT32 Setup
        - Explore the CD

    - for WinNT, we want to show:

        - WINNT32.EXE Setup
        - Explore the CD
        - Add Remove Programs


    - The following value is used in WinMain to help not display the applet
      when some NT Setup thing is asking for the OS CD.  Currently, we do not
      have any windows with this object for NT.  Perhaps maybe we will for 5.0.
    
        static const char c_szAutoRunPrevention[] = "__WinNTSetupDiskQuery";


*/

/*
    10.05.96    Shunichi Kajisa (shunk)     Support NEC PC-98

    1. Determine if autorun is running on PC-98 or regular PC/AT by:

	    bNEC98 = (HIBYTE(LOWORD(GetKeyboardType(1))) == 0x0D)? TRUE : FALSE;

        Following description is from KB Q130054, and this can be applied on NT and Win95:

	    If an application uses the GetKeyboardType API, it can get OEM ID by
	    specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
	    is listed here:
	     
	       OEM Windows       OEM ID
	       ------------------------------
	       Microsoft         00H (DOS/V)
	       ....
	       NEC               0DH

 
    2. If autorun is running on PC-98, replace every "I386" resource with "PC98" at runtime,
       regardless that autorun is running on NT or Win95.


    Notes:
    - NEC PC-98 is available only in Japan.
    - NEC PC-98 uses x86 processor, but the underlaying hardware architecture is different.
      The PC98 files is stored under CD:\pc98 directory instead of CD:\i386.
    - There was an idea that we should detect PC-98 in SHELL32.DLL, and treat PC98 as a different
      platform, like having [AutoRun.Pc98] section in NT CD's autorun.inf. We don't do this, since
      Win95 doesn't support this, and we don't want to introduce the apps incompatibility.
      In any case, if app has any dependency on the hardware and needs to do any special things,
      the app should detect the hardware and OS. This is separate issue from Autorun.exe.
    
*/




//---------------------------------------------------------------------------
// AutoRun applet. 
//---------------------------------------------------------------------------
#include "autorun.h"
#include "resource.h"
#include <mmsystem.h>
#include <regstr.h>
#include <string.h>
#include <ntverp.h>

#define ARRAYSIZE(a)  (sizeof(a)/sizeof(a[0]))

//---------------------------------------------------------------------------
// define this to force 4bit mode in debug builds
//#define FORCE_4BIT

//---------------------------------------------------------------------------
// appwide globals
HINSTANCE g_hinst = NULL;
BOOL g_f4BitForColor = FALSE;
BOOL g_fNeedPalette = FALSE;
BOOL g_fMouseAvailable = FALSE;

//---------------------------------------------------------------------------
// file globals
BOOL g_fAppDisabled = TRUE;
HHOOK g_hMouseHook = NULL;
HWND g_hMainWindow = NULL;      // less of a pain for our mouse hook to see
int g_iActiveButton = -2;       // less of a pain for our mouse hook to see

const RGBQUAD g_rgbBlack = {0};
const RGBQUAD g_rgbWhite = {0xFF, 0xFF, 0xFF, 0};

#pragma data_seg(".text")
static const char c_szAutoRunPrevention[] = "__WinNTSetupDiskQuery";
static const char c_szAutoRunClass[] = "AutoRunMain";
static const char c_szNULL[] = "";
static const char c_szArial[] = "Arial";
static const char c_szButtonClass[] = "Button";
static const char c_szSetupKey[] = REGSTR_PATH_SETUP "\\SETUP";
static const char c_szExpoSwitch[] = "Expostrt";
#pragma data_seg()

char szAppTitle[MAX_PATH];

CHAR    dbgStr[2*MAX_PATH];

BOOL    bDebug = FALSE;

//---------------------------------------------------------------------------
// private messages
#define ARM_MOUSEOVER       (WM_APP)

//---------------------------------------------------------------------------
// states for tracking mouse over buttons
#define BTNST_DEAD          (0)
#define BTNST_UP            (1)
#define BTNST_DOWN          (2)
#define BTNST_UNDOWN        (3)

//---------------------------------------------------------------------------
// how to root a relative path (if at all)
#define NOROOT      (0x00000000)
#define ONACD       (0x00000001)
#define INWIN       (0x00000002)
#define INSYS       (0x00000003)
#define ALLROOTS  (0x00000003)

#define ROOTED(app,parms,dir) \
                            ((((DWORD)app)<<6)|(((DWORD)parms)<<3)|(DWORD)dir)

#define CMD_ROOT(item)      ((((DWORD)item)>>6)&ALLROOTS)
#define PARAMS_ROOT(item)   ((((DWORD)item)>>3)&ALLROOTS)
#define DEFDIR_ROOT(item)    (((DWORD)item)&ALLROOTS)

#define BUTTON_IMAGE_X_SIZE         (59)
#define BUTTON_IMAGE_Y_SIZE         (59)

#define NORMAL_IMAGE_X_OFFSET       (0)
#define FOCUS_IMAGE_X_OFFSET        (BUTTON_IMAGE_X_SIZE)
#define SELECTED_IMAGE_X_OFFSET     (2 * BUTTON_IMAGE_X_SIZE)
#define DISABLED_IMAGE_X_OFFSET     (3 * BUTTON_IMAGE_X_SIZE)

#define BUTTON_DEFAULT_CX           (BUTTON_IMAGE_X_SIZE)
#define BUTTON_DEFAULT_CY           (BUTTON_IMAGE_Y_SIZE)

#define BUTTON_LABEL_RECT           { -160, 17, -20, 66 }

#define DEF_BUTTON_LABEL_HEIGHT         (19)

#define AUTORUN_DESCRIPTION_LEFT    (36)
#define AUTORUN_DESCRIPTION_TOP     (313)
#define AUTORUN_DESCRIPTION_RIGHT   (360)

#define AUTORUN_4BIT_TEXTCOLOR             RGB(192,192,192)
#define AUTORUN_4BIT_HIGHLIGHT             RGB(255,255,255)
#define AUTORUN_4BIT_DISABLED              RGB(127,127,127)
#define AUTORUN_4BIT_DESCRIPTION           RGB(192,192,192)

//#define AUTORUN_8BIT_TEXTCOLOR      PALETTERGB( 75, 90,129)
//#define AUTORUN_8BIT_HIGHLIGHT             RGB(000,000,000)
//#define AUTORUN_8BIT_DISABLED       PALETTERGB(107,136,185)
//#define AUTORUN_8BIT_DESCRIPTION           RGB(000,000,000)
#define AUTORUN_8BIT_TEXTCOLOR      PALETTERGB(125,125,125)
#define AUTORUN_8BIT_HIGHLIGHT             RGB(175,175,175)
#define AUTORUN_8BIT_DISABLED       PALETTERGB(107,136,185)
#define AUTORUN_8BIT_DESCRIPTION           RGB(220,220,220)

#define BUTTON_X_PLACEMENT          (519)
#define BUTTON_Y_MARGIN             (9)

#define SHADOW_FACTOR               (930)

#define LABEL_VERIFY_TIMER          (0)

//---------------------------------------------------------------------------
typedef struct
{
    int res;            // base for all resources this button owns

    DWORD rooting;      // packed info on how to root paths for the command

    int xpos, ypos;     // location of button in window
    RECT face;          // client coordinates of actual button image on video
    RECT textrect;      // parent coordinates of accompanying label text

    BOOL abdicated;     // did we just release the capture?
    int state;          // what are we doing?

    HWND window;        // handle of button control
    WNDPROC oldproc;    // original window procedure
    BOOL isdorky;       // is this a strange icon button?

    char text[64];          // the label for the button
    char description[256];  // the description of the button's function

} AUTORUNBTN;

//---------------------------------------------------------------------------
AUTORUNBTN g_ButtonInfo[] =
{

//    { WINTOUR,   ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
//    { MSEXPO,    ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
//    { HOVER,     ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
//    { VIDEOS,    ROOTED(NOROOT, ONACD,  ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },

	{ NTSETUP,   ROOTED(NOROOT,  NOROOT, ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
    { EXPLORECD, ROOTED(NOROOT, ONACD,  ONACD), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
	{ OCSETUP,   ROOTED(NOROOT, NOROOT, INSYS), 0, 0, 0, 0, 49, 49, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
    

};

//#define IDAB_WINTOUR    0
//#define IDAB_MSEXPO     1
//#define IDAB_HOVER      2
//#define IDAB_VIDEOS     3
//#define IDAB_EXPLORECD  4
//#define IDAB_OCSETUP    5
#define IDAB_NTSETUP		0
#define IDAB_EXLPORECD		1
#define IDAB_OCSETUP		2
#define AUTORUN_NUM_BUTTONS (sizeof(g_ButtonInfo)/sizeof(g_ButtonInfo[0]))

//---------------------------------------------------------------------------
typedef struct
{
    HWND window;        // main app window

    HDC image;          // source dc with our cool backdrop
    HBITMAP oldbmp;     // the default bitmap from the dc above
    HDC btnimage;       // source dc with our cool buttons
    HBITMAP oldbtnbmp;  // the default bitmap from the dc above
    HPALETTE palette;   // our app's palette (if any)

    HFONT textfont;     // font for labels
    RECT descrect;      // client coordinates of description text
    int wndheight;      // height of client area

    COLORREF clrnormal;      // normal text color
    COLORREF clrhigh;        // highlighted text color
    COLORREF clrdisable;     // disabled text color
    COLORREF clrdescription; // disabled text color

    BOOL keyboard;      // whether the app is under keyboard control

} AUTORUNDATA;

BOOL	bNEC98 = FALSE;

BOOL    PathAppend( char * prefix, const char * spec) {

    //wsprintf ( dbgStr, "myPathAppend:  prefix = %s, spec = %s", prefix, spec );
    //MessageBox ( NULL, dbgStr, "", MB_ICONASTERISK );

    strcat ( prefix, spec ); 

    return TRUE;

}

BOOL    PathFileExists ( LPCSTR FileName ) {

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/


    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL b;
    UINT OldMode;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        FindClose(FindHandle);
        
        b = TRUE;
    }

    SetErrorMode(OldMode);

    return(b);
}


/////////////////////////////////////////////////////////////////////////////
// randomness
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI AnotherStrToLong(LPCSTR sz)
{
    long l=0;
    BOOL fNeg = (*sz == '-');

    if (fNeg)
        sz++;

    while (*sz >= '0' && *sz <= '9')
        l = l*10 + (*sz++ - '0');

    if (fNeg)
        l *= -1L;

    return l;
}

/////////////////////////////////////////////////////////////////////////////
// 
/////////////////////////////////////////////////////////////////////////////

/*** this stuff uses the bitmap array - we won't use it.

BOOL AssembleButtonImagesReal(AUTORUNDATA *data, HDC cellimage, HDC srcimage,
    SIZE size)
{
    RGBQUAD rgbSrc[256], rgbCell[256], rgbMask[256] = {0};
    HBITMAP dstbmp = CreateCompatibleBitmap(data->image, size.cx, size.cy);
    UINT uColors, uSrcColors, u;
    int iButton;

    //
    // set up the destination dc
    //
    if (!dstbmp)
        return FALSE;

    if ((data->btnimage = CreateCompatibleDC(data->image)) == NULL)
    {
        DeleteBitmap(dstbmp);
        return FALSE;
    }

    data->oldbtnbmp = SelectBitmap(data->btnimage, dstbmp);

    //
    // build a tile of the cell backgrounds based on button positions
    //
    for (iButton = 0; iButton < AUTORUN_NUM_BUTTONS; iButton++)
    {
        AUTORUNBTN *pButton = g_ButtonInfo + iButton;

        if (pButton->res != -1)
        {
			BOOL	b;
            int xsrc = pButton->xpos;
            int ysrc = pButton->ypos;
            int xdst, ydst = iButton * BUTTON_IMAGE_Y_SIZE;

            for (xdst = 0; xdst < size.cx; xdst += BUTTON_IMAGE_X_SIZE)
            {
                b = BitBlt(cellimage, xdst, ydst, BUTTON_IMAGE_X_SIZE,
                    BUTTON_IMAGE_Y_SIZE, data->image, xsrc, ysrc,
                    SRCCOPY);
            }
        }
    }

    //
    // copy the entire cell backgrounds to the destination image
    //
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCCOPY);

    //
    // save the color table of the source image for posterity
    //
    uSrcColors = GetDIBColorTable(srcimage, 0, 256, rgbSrc);

    //
    // mask out holes on the destination for the buttons and shadows
    //
    rgbMask[0] = g_rgbWhite;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);

    //
    // dim the background cells to produce the shadow image
    //
    u = uColors = GetDIBColorTable(cellimage, 0, 256, rgbCell);
    while (u--)
    {
        rgbCell[u].rgbBlue =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbBlue / 1000);
        rgbCell[u].rgbGreen =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbGreen / 1000);
        rgbCell[u].rgbRed =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbRed / 1000);
    }
    SetDIBColorTable(cellimage, 0, uColors, rgbCell);

    //
    // mask out the shadows and add them to the destination image
    //
    rgbMask[0] = g_rgbBlack;
    rgbMask[1] = g_rgbWhite;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(cellimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCPAINT);

    //
    // mask out the button faces and add them to the destination image
    //
    rgbSrc[0] = rgbSrc[1] = g_rgbBlack;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbSrc);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCPAINT);

    // all done
    return TRUE;
}

//---------------------------------------------------------------------------

BOOL AssembleButtonImages(AUTORUNDATA *data)
{
    BOOL result = FALSE;
    HBITMAP hbmSrc = LoadImage(HINST_THISAPP,
        MAKEINTRESOURCE(IDB_8BPP_BUTTONS), IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION);

    if (hbmSrc)
    {
        HDC hdcSrc = CreateCompatibleDC(data->image);
        BITMAP bm;

        GetObject(hbmSrc, sizeof(bm), &bm);

        if (hdcSrc)
        {
            HBITMAP hbmSrcOld = SelectBitmap(hdcSrc, hbmSrc);
            SIZE size = {bm.bmWidth, bm.bmHeight};
            HBITMAP hbmTmp =
                CreateCompatibleBitmap(data->image, size.cx, size.cy);

            if (hbmTmp)
            {
                HDC hdcTmp = CreateCompatibleDC(data->image);

                if (hdcTmp)
                {
                    HBITMAP hbmTmpOld = SelectBitmap(hdcTmp, hbmTmp);

                    result = AssembleButtonImagesReal(data, hdcTmp, hdcSrc,
                        size);

                    SelectBitmap(hdcTmp, hbmTmpOld);
                    DeleteDC(hdcTmp);
                }

                DeleteBitmap(hbmTmp);
            }

            SelectBitmap(hdcSrc, hbmSrcOld);
            DeleteDC(hdcSrc);
        }

        DeleteBitmap(hbmSrc);
    }

    return result;
}

*/

//---------------------------------------------------------------------------
LRESULT CALLBACK
AutoRunButtonSubclassProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    int index = (int)GetWindowLong(window, GWL_ID);

    if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
    {
        if (msg == WM_KEYDOWN)
            PostMessage(GetParent(window), msg, wp, lp);

        return CallWindowProc((g_ButtonInfo + index)->oldproc,
            window, msg, wp, lp);
    }

    return 0L;
}

//---------------------------------------------------------------------------
#define DORKYBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_ICON | BS_CENTER | BS_VCENTER)

HWND AutoRunCreateDorkyButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
    HICON icon = LoadIcon(HINST_THISAPP, IDI_ICON(button->res));
    HWND child = NULL;

    if (icon) {
    
        child = CreateWindow(c_szButtonClass, c_szNULL, DORKYBUTTONSTYLE,
            0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);

        if (child) {
        
            button->isdorky = TRUE;
            SendMessage(child, BM_SETIMAGE, MAKEWPARAM(IMAGE_ICON,0),(LPARAM)icon);
        }
		// remove this debugging later
		else {
			//wsprintf ( dbgStr, "CreateWindow FAILed. gle = %ld, res = %ld", GetLastError(), button->res );
			//MessageBox ( NULL, dbgStr, szAppName, MB_ICONASTERISK );

		}
    }
	// remove this debugging later
	else {

		//wsprintf ( dbgStr, "LoadIcon FAILed. gle = %ld, res = %ld", GetLastError(), button->res );
		//MessageBox ( NULL, dbgStr, szAppName, MB_ICONASTERISK );
	}

    return child;
}

//---------------------------------------------------------------------------
#define COOLBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_OWNERDRAW)

HWND AutoRunCreateCoolButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
	HWND	h;
    h = CreateWindow(c_szButtonClass, c_szNULL, COOLBUTTONSTYLE,
        0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);
	return ( h );
}

//---------------------------------------------------------------------------
void AutoRunCreateButtons(AUTORUNDATA *data)
{
    RECT labelbase = BUTTON_LABEL_RECT;
    int i;

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        AUTORUNBTN *button = g_ButtonInfo + i;
        HWND child = NULL;

        if (button->res != -1)
        {

			
			child = AutoRunCreateDorkyButton(data, button);

/***    Don't call this code because we don't use the bitmap array.

            if (!g_f4BitForColor) {

				child = AutoRunCreateCoolButton(data, button);

				
			}

            if (!child) {
                child = AutoRunCreateDorkyButton(data, button);
			}
***/
        }

        if (child)
        {
			BOOL	b;
            int cx = BUTTON_DEFAULT_CX;
            int cy = BUTTON_DEFAULT_CY;

            button->window = child;
            SetWindowLong(child, GWL_ID, i);
            button->oldproc = SubclassWindow(child,
                (WNDPROC)AutoRunButtonSubclassProc);

            if (button->isdorky)
            {
                cx = button->face.right - button->face.left;
                cy = button->face.bottom - button->face.top;
            }

            b = SetWindowPos(child, NULL, button->xpos, button->ypos, cx, cy,
                SWP_NOZORDER | SWP_NOACTIVATE);
			

            LoadString(HINST_THISAPP, IDS_TITLE(button->res),
                button->text, ARRAYSIZE(button->text));

            LoadString(HINST_THISAPP, IDS_INFO(button->res),
                button->description, ARRAYSIZE(button->description));

            button->textrect = labelbase;
            b = OffsetRect(&button->textrect, button->xpos, button->ypos);
			
            b = InvalidateRect(data->window, &button->textrect, FALSE);
			
        }
    }
}

//---------------------------------------------------------------------------
void CleanupAutoRunWindow(AUTORUNDATA *data)
{
    //
    // Deactivate any button so its timer will get killed
    //
    if (g_iActiveButton >= 0)
    {
        data->keyboard = FALSE;
        SendMessage(data->window, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    }

    if (data->image)
    {
        if (data->oldbmp)
        {
            SelectBitmap(data->image, data->oldbmp);
            // real backdrop image is deleted in WinMain
            data->oldbmp = NULL;
        }

        DeleteDC(data->image);
        data->image = NULL;
    }

    if (data->btnimage)
    {
        if (data->oldbtnbmp)
        {
            DeleteBitmap(SelectBitmap(data->btnimage, data->oldbtnbmp));
            data->oldbtnbmp = NULL;
        }

        DeleteDC(data->btnimage);
        data->btnimage = NULL;
    }

    if (data->palette)
    {
        DeleteObject(data->palette);
        data->palette = NULL;
    }

    if (data->textfont)
    {
        DeleteObject(data->textfont);
        data->textfont = NULL;
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunBuildPath(char *spec, int resid, DWORD rooting)
{
    char prefix[MAX_PATH];

    //
    // get the relative path of the spec
    //
    if (resid == -1) {

        //
        // empty string hack for callers
        //
        *spec = 0;
    }
    else {

        char * p;
    
        //
        //  Normal case, where we load the resource from the block of resource ids. 
        //
        if (!LoadString(HINST_THISAPP, resid, spec, MAX_PATH)) {
            return FALSE;
        }

        //  Since we will be initiating setup from one of the platforms,
        //  we need to specify the correct platform directory.
        //  Do the following:
        //      - see if we are going to attempt to run setup, ie. winnt32.exe.
        //      - if so, figure out from which platform
        //      - and, load the appropriate string.

        if ( strstr ( spec, "winnt32" ) != NULL ) {

            char launchLocation[MAX_PATH];

            //  Get complete path of where autorun.exe is running from.
            //  It will contain the platform because autorun.inf specified it.
            //
            GetModuleFileName(HINST_THISAPP, launchLocation, ARRAYSIZE(prefix));

            _strupr ( launchLocation );

            //  At this point, should be, for example:   C:\I386\AUTORUN.EXE
            //

            if ( bNEC98 ) {

                //  On a Nec98 machine, the autorun will be launched from
                //  the i386 directory.  So, we can be smart at what we are 
                //  looking for and launch the appropriate winnt32.exe.

                p = strstr ( launchLocation, "I386" );    

                strcpy ( p, "NEC98\\winnt32.exe" );


            }
            else {
		
                p = strstr ( launchLocation, "AUTORUN.EXE" );

                strcpy ( p, "winnt32.exe" );

            }

            strcpy ( spec, launchLocation );


        }

    }

    //
    // our "empty" strings contain a single space so we know they succeeded
    //
    if ((*spec == ' ') && !spec[1])
        *spec = 0;

    //
    // figure out what the prefix should be
    //
    *prefix = 0;
    switch (rooting)
    {
        case ONACD:
            //
            // assume the cd is the root of wherever we were launched from
            //
            GetModuleFileName(HINST_THISAPP, prefix, ARRAYSIZE(prefix));
            _PathStripToRoot(prefix);
            break;

        case INWIN:
            GetRealWindowsDirectory(prefix, ARRAYSIZE(prefix));
            break;

        case INSYS:
            GetSystemDirectory(prefix, ARRAYSIZE(prefix));
            break;
    }

    //
    // if we have a prefix then prepend it
    //
    if (*prefix)
    {
        if (*spec)
        {

            PathAppend(prefix, spec);
        }

        //
        // copy the whole mess out to the original buffer
        //
        lstrcpy(spec, prefix);

	
    }

    return TRUE;
}

BOOL
IsNec98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}

//---------------------------------------------------------------------------
BOOL InitAutoRunWindow(HWND window, AUTORUNDATA *data, LPCREATESTRUCT cs)
{
    //char command[MAX_PATH];
    AUTORUNBTN *button;
	OSVERSIONINFO osVersionInfo;
	BOOL b;

    data->window = window;

    if ((data->image = CreateCompatibleDC(NULL)) == NULL)
        goto im_doug;

    if ((data->oldbmp = SelectBitmap(data->image,
        (HBITMAP)cs->lpCreateParams)) == NULL)
    {
        goto im_doug;
    }

    if (g_fNeedPalette)
    {
        if ((data->palette = PaletteFromDS(data->image)) == NULL)
            goto im_doug;
    }
/***    NT doesn't do the Expo Button.
    // should we show the expo button?
    button = g_ButtonInfo + IDAB_MSEXPO;

    if (!AutoRunBuildPath(command, IDS_CMD(button->res),
        CMD_ROOT(button->rooting)) || !PathFileExists(command))
    {
        button->res = -1;
    }
***/

	//	Should we show the Add/Remove program button ?
	//	Yes, if running on NT.
	//	No, if running on anything else.
	button = g_ButtonInfo + IDAB_OCSETUP;
	
	osVersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO );
	b = GetVersionEx ( &osVersionInfo );
	if ( !b || !(osVersionInfo.dwPlatformId & VER_PLATFORM_WIN32_NT) ) {
		button->res = -1;
	}

    // artifical scoping oh boy!
    {
        BITMAP bm;
        int i, ivis = 0;
        int range = 0;
        int origin, extent;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
                range++;
        }


#if defined(_X86_)
        bNEC98 = IsNec98();
#endif

        GetObject((HBITMAP)cs->lpCreateParams, sizeof(bm), &bm);
        origin = BUTTON_Y_MARGIN * ((1 + AUTORUN_NUM_BUTTONS) - range);
        extent = bm.bmHeight - ((2 * origin) + BUTTON_IMAGE_Y_SIZE);

        if (--range < 1)
            range = 1;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
            {
                button->xpos = BUTTON_X_PLACEMENT;
                button->ypos = ivis * extent / range + origin;
                ivis++;
            }
        }
    }

    // more artifical scoping!
    {
        HDC screen = GetDC(NULL);
        LOGFONT lf = { DEF_BUTTON_LABEL_HEIGHT, 0, 0, 0, FW_BOLD, FALSE,
            FALSE, FALSE, (screen? GetTextCharset(screen) : DEFAULT_CHARSET),
            OUT_STROKE_PRECIS, CLIP_DEFAULT_PRECIS,
            PROOF_QUALITY | NONANTIALIASED_QUALITY,
            VARIABLE_PITCH | FF_DONTCARE, 0 };
        char buf[32];

        if (screen)
            ReleaseDC(NULL, screen);

        if (!LoadString(HINST_THISAPP, IDS_LABELFONT, lf.lfFaceName,
            ARRAYSIZE(lf.lfFaceName)))
        {
            lstrcpy(lf.lfFaceName, c_szArial);
        }

        if (LoadString(HINST_THISAPP, IDS_LABELHEIGHT, buf, ARRAYSIZE(buf)))
            lf.lfHeight = AnotherStrToLong(buf);

        if ((data->textfont = CreateFontIndirect(&lf)) == NULL)
            goto im_doug;
    }

 

    //
    // see if we need to do 8bit+ work...
    //
    if (g_f4BitForColor)
    {
        data->clrnormal      = AUTORUN_4BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_4BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_4BIT_DISABLED;
        data->clrdescription = AUTORUN_4BIT_DESCRIPTION;
    }
    else
    {
        data->clrnormal      = AUTORUN_8BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_8BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_8BIT_DISABLED;
        data->clrdescription = AUTORUN_8BIT_DESCRIPTION;

		/***
        if (!AssembleButtonImages(data))
            goto im_doug;
		***/
    }

    PostMessage(g_hMainWindow, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    return TRUE;

im_doug:
    CleanupAutoRunWindow(data);
    return FALSE;
}

//---------------------------------------------------------------------------
void AutoRunSized(AUTORUNDATA *data)
{
    GetClientRect(data->window, &data->descrect);
    data->wndheight = data->descrect.bottom - data->descrect.top;
    data->descrect.left = AUTORUN_DESCRIPTION_LEFT;
    data->descrect.top = AUTORUN_DESCRIPTION_TOP;
    data->descrect.right = AUTORUN_DESCRIPTION_RIGHT;
}

//---------------------------------------------------------------------------
void AutoRunRealize(HWND window, AUTORUNDATA *data, HDC theirdc)
{
    if (data->palette)
    {
        HDC dc = theirdc? theirdc : GetDC(window);

        if (dc)
        {
            BOOL repaint = FALSE;

            SelectPalette(dc, data->palette, FALSE);
            repaint = (RealizePalette(dc) > 0);

            if (!theirdc)
                ReleaseDC(window, dc);

            if (repaint)
            {
                RedrawWindow(window, NULL, NULL, RDW_INVALIDATE |
                    RDW_ERASE | RDW_ALLCHILDREN);
            }
        }
    }
}

//---------------------------------------------------------------------------
void AutoRunErase(AUTORUNDATA *data, HDC dc)
{
    RECT rc;
    GetClientRect(data->window, &rc);

    AutoRunRealize(data->window, data, dc);
    BitBlt(dc, 0, 0, rc.right, rc.bottom, data->image, 0, 0, SRCCOPY);
}

//---------------------------------------------------------------------------
void AutoRunPaint(AUTORUNDATA *data)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(data->window, &ps);
    AUTORUNBTN *button;
    COLORREF curtextcolor = GetTextColor(dc);
    COLORREF color;
    HFONT hfold = NULL;
    int i;

    AutoRunRealize(data->window, data, dc);
    SetBkMode(dc, TRANSPARENT);

    //
    // paint all the button labels
    //
    if (data->textfont)
        hfold = SelectFont(dc, data->textfont);

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        button = g_ButtonInfo + i;

        if (button->window)
        {
            color = (i == g_iActiveButton)? data->clrhigh :
                (IsWindowEnabled(button->window)? data->clrnormal :
                data->clrdisable);

            if (color != curtextcolor)
            {
                SetTextColor(dc, color);
                curtextcolor = color;
            }

            DrawText(dc, button->text, -1, &button->textrect,
                DT_WORDBREAK | DT_RIGHT | DT_TOP);
        }
    }

    //
    // paint the description for the current button
    //
    if (g_iActiveButton >= 0)
    {
        button = g_ButtonInfo + g_iActiveButton;

        color = data->clrdescription;
        if (color != curtextcolor)
        {
            SetTextColor(dc, color);
            curtextcolor = color;
        }

        DrawText(dc, button->description, -1, &data->descrect,
            DT_WORDBREAK | DT_LEFT | DT_TOP);
    }

    if (hfold)
        SelectFont(dc, hfold);

    EndPaint(data->window, &ps);
}

//---------------------------------------------------------------------------
void AutoRunDrawItem(AUTORUNDATA *data, DRAWITEMSTRUCT *dis)
{
    POINT loc = { dis->rcItem.left, dis->rcItem.top };
    SIZE size = { dis->rcItem.right - loc.x, dis->rcItem.bottom - loc.y };

    loc.y += dis->CtlID * BUTTON_IMAGE_Y_SIZE;

    if (dis->itemState & ODS_DISABLED)
    {
        loc.x += DISABLED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_SELECTED)
    {
        loc.x += SELECTED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_FOCUS)
    {
        loc.x += FOCUS_IMAGE_X_OFFSET;
    }

    AutoRunRealize(dis->hwndItem, data, dis->hDC);
    BitBlt(dis->hDC, dis->rcItem.left, dis->rcItem.top, size.cx, size.cy,
        data->btnimage, loc.x, loc.y, SRCCOPY);
}

//---------------------------------------------------------------------------
void AutoRunActivateItem(AUTORUNDATA *data, int index)
{
    if (index >= 0)
    {
        //
        // prevent disabled buttons from getting focus...
        //
        AUTORUNBTN *button = g_ButtonInfo + index;
        if (!button->window || !IsWindowEnabled(button->window))
            index = -1;
    }

    if (g_iActiveButton != index)
    {
        AUTORUNBTN *newbtn = (index >= 0)? (g_ButtonInfo + index) : NULL;
        AUTORUNBTN *oldbtn = (g_iActiveButton >= 0)?
            (g_ButtonInfo + g_iActiveButton) : NULL;

        //
        // if there was an previous button, repaint its label highlight
        //
        if (oldbtn)
            InvalidateRect(data->window, &oldbtn->textrect, FALSE);

        g_iActiveButton = index;

        if (newbtn)
        {
            InvalidateRect(data->window, &newbtn->textrect, FALSE);
            SetFocus(newbtn->window);

            //
            // if activating via mouse, track it (trust me...)
            //
            if (g_fMouseAvailable && !data->keyboard)
                SetTimer(data->window, LABEL_VERIFY_TIMER, 333, NULL);
        }
        else
        {
            SetFocus(data->window);

            if (g_fMouseAvailable)
                KillTimer(data->window, LABEL_VERIFY_TIMER);
        }

        //
        // go ahead and paint any label changes now before we erase
        //
        UpdateWindow(data->window);
        InvalidateRect(data->window, &data->descrect, TRUE);
    }
}

//---------------------------------------------------------------------------
void AutoRunMouseOver(AUTORUNDATA *data, int index, BOOL fForce)
{
    if ((index >= 0) || !data->keyboard || fForce)
    {
        data->keyboard = !g_fMouseAvailable;
        AutoRunActivateItem(data, index);
    }
}

//---------------------------------------------------------------------------
int AutoRunProcessPotentialHit(HWND candidate, const POINT *loc)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0)
        return g_iActiveButton;

    if (candidate && IsWindowEnabled(candidate) &&
        (GetParent(candidate) == g_hMainWindow))
    {
        int index;

        index = (int)GetWindowLong(candidate, GWL_ID);
        if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
        {
            AUTORUNBTN *button = g_ButtonInfo + index;
            POINT cli = *loc;

            ScreenToClient(candidate, &cli);
            if (PtInRect(&button->face, cli))
                return index;
        }
    }

    return -1;
}

//---------------------------------------------------------------------------
void AutoRunVerifyActiveItem(AUTORUNDATA *data)
{
    if (!data->keyboard)
    {
        int index = -1;

        if (!g_fAppDisabled)
        {
            POINT loc;
            HWND candidate;

            GetCursorPos(&loc);

            if ((candidate = WindowFromPoint(loc)) != NULL)
                index = AutoRunProcessPotentialHit(candidate, &loc);
        }

        if (index != g_iActiveButton)
            AutoRunMouseOver(data, index, FALSE);
    }
}

//---------------------------------------------------------------------------
void AutorunEnableButton(AUTORUNDATA *data, int id, BOOL f)
{
    if ((id >= 0) && (id < AUTORUN_NUM_BUTTONS))
    {
        AUTORUNBTN *button = g_ButtonInfo + id;
        HWND window = button->window;

        if (button->window && IsWindow(button->window))
        {
            EnableWindow(button->window, f);
            InvalidateRect(data->window, &button->textrect, FALSE);
            AutoRunVerifyActiveItem(data);
        }
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunCDIsInDrive(HWND hwndOwner)
{
    char me[MAX_PATH];
    GetModuleFileName(HINST_THISAPP, me, ARRAYSIZE(me));

    //MessageBox ( NULL, "Entering AutoRunCDIsInDrive...", "", MB_ICONASTERISK );

    while (!PathFileExists(me))
    {
		char szNeed[MAX_PATH];
		char szName[MAX_PATH];
		LoadString(HINST_THISAPP, IDS_NEEDCDROM, szNeed, MAX_PATH); 
        LoadString(HINST_THISAPP, IDS_APPTITLE,  szName, MAX_PATH); 
        
        //////if (ShellMessageBox(HINST_THISAPP, hwndOwner,
        if ( MessageBox (	NULL, 
							szNeed, 
							szName,
							MB_OKCANCEL | MB_ICONSTOP)		== IDCANCEL ) {
        
            //MessageBox ( NULL, "AutoRunCDIsInDrive FALSE", "", MB_ICONASTERISK );
            return FALSE;
        }
    }

    //MessageBox ( NULL, "AutoRunCDIsInDrive TRUE", "", MB_ICONASTERISK );
    return TRUE;
}

//---------------------------------------------------------------------------
void AutoRunClick(AUTORUNDATA *data, int nCmd)
{
    char command[MAX_PATH], dir[MAX_PATH], params[MAX_PATH];
    AUTORUNBTN *button;
    ULONG_PTR   uRC;

    if ((nCmd < 0) || (nCmd >= AUTORUN_NUM_BUTTONS))
        return;

    button = g_ButtonInfo + nCmd;

    //
    // meep at the user (meep meep!) so they know something is happening...
    //
    PlaySound(MAKEINTRESOURCE(IDW_BLIP), HINST_THISAPP,
        SND_RESOURCE | SND_ASYNC | SND_NODEFAULT);

    //
    // verify that the app disk is still visible and prompt if not...
    //
    if (!AutoRunCDIsInDrive(data->window)) {
        return;
    }

    //
    // calculate the paths for the command
    //
    if (!AutoRunBuildPath(command, IDS_CMD(button->res),    CMD_ROOT(button->rooting))    ||
        !AutoRunBuildPath(params,  IDS_PARAMS(button->res), PARAMS_ROOT(button->rooting)) ||
        !AutoRunBuildPath(dir,     IDS_DIR(button->res),    DEFDIR_ROOT(button->rooting))) {

        // BUGBUG an error message would be nice
    }

    //wsprintf ( dbgStr, "ShellExecute :  command = %s, params = %s, dir = %s", command, params, dir );
    //MessageBox ( NULL, dbgStr, "", MB_ICONASTERISK );

    uRC = (ULONG_PTR) ShellExecute(data->window, NULL, command, params, dir, SW_SHOWNORMAL);

    if ( uRC >= 0 && uRC <= 32 ) {

        char cmdString[MAX_PATH];

		LoadString(HINST_THISAPP, IDS_SHELLEXECUTE_ERROR, cmdString, MAX_PATH); 
        wsprintf ( dbgStr, "%s lpFiles = %s, lpParameters = %s, lpDirectory = %s", cmdString, command, params, dir );
        MessageBox ( NULL, dbgStr, szAppTitle, MB_ICONASTERISK );
    }
}

//---------------------------------------------------------------------------
void AutoRunHandleKeystroke(AUTORUNDATA *data, TCHAR key, LPARAM lp)
{
    int move = 0;
    int where = g_iActiveButton;

    //
    // see if we care about this keystroke
    //
    switch (key)
    {
    case VK_RETURN:
        if (where >= 0)
            AutoRunClick(data, where);
        //fallthru
    case VK_ESCAPE:
        where = -1;
        break;

    case VK_TAB:
        move = (GetKeyState(VK_SHIFT) < 0)? -1 : 1;
        break;

    case VK_END:
        where = AUTORUN_NUM_BUTTONS;
        //fallthru
    case VK_UP:
    case VK_LEFT:
        move = -1;
        break;

    case VK_HOME:
        where = -1;
        //fallthru
    case VK_DOWN:
    case VK_RIGHT:
        move = 1;
        break;

    default:
        return;
    }

    //
    // we should only get down here if the active button is going to change
    //
    if (move)
    {
        int scanned;

        for (scanned = 0; scanned <= AUTORUN_NUM_BUTTONS; scanned++)
        {
            where += move;

            if (where >= (int)AUTORUN_NUM_BUTTONS)
            {
                where = -1;
            }
            else if (where < 0)
            {
                where = AUTORUN_NUM_BUTTONS;
            }
            else
            {
                HWND child = (g_ButtonInfo + where)->window;
                if (child && IsWindowEnabled(child))
                    break;
            }
        }

    }

    if (where >= 0)
    {
        SetCursor(NULL);
        data->keyboard = TRUE;
    }
    else
        data->keyboard = !g_fMouseAvailable;

    AutoRunActivateItem(data, where);
}

//---------------------------------------------------------------------------
void LaunchSetup(HWND window)
{
    LONG_PTR   uRC;
    char command[MAX_PATH], params[MAX_PATH], dir[MAX_PATH];

    //
    // calculate the paths for the command
    //
    if (!AutoRunBuildPath(command,  IDS_CMD(NTSETUP),   NOROOT) ||
        !AutoRunBuildPath(params,   IDS_PARAMS(NTSETUP),NOROOT) ||
        !AutoRunBuildPath(dir,      IDS_DIR(NTSETUP),   ONACD))
    {
        MessageBox ( NULL, "Could not build launch path.", szAppTitle, MB_ICONASTERISK );
    }

    uRC = (LONG_PTR) ShellExecute(window, NULL, command, params, dir, SW_SHOWNORMAL);
    if ( uRC >= 0 && uRC <= 32 ) {

        char cmdString[MAX_PATH];

		LoadString(HINST_THISAPP, IDS_SHELLEXECUTE_ERROR, cmdString, MAX_PATH); 
        wsprintf ( dbgStr, "%s lpFiles = %s, lpParameters = %s, lpDirectory = %s", cmdString, command, params, dir );
        MessageBox ( NULL, dbgStr, szAppTitle, MB_ICONASTERISK );
    }
}

//---------------------------------------------------------------------------
#define CD_PLATFORM_ID      (VER_PLATFORM_WIN32_WINDOWS)
#define CD_MAJOR_VERSION    (5)                             // hardcoded unfortunately
#define CD_MINOR_VERSION    (1)                             // hardcoded unfortunately
#define CD_BUILD_NUMBER     (VER_PRODUCTBUILD)

//  Return of FALSE, means quit the applet.
//  Return of TRUE, means continue.
//

BOOL CheckVersionConsistency(AUTORUNDATA *data)
{
    OSVERSIONINFO ovi = { sizeof(ovi), 0, 0, 0, 0, 0 };
    UINT msgtype = 0;
    BOOL result = FALSE;
    BOOL fDisableSetupStuff = FALSE;
    CHAR szMessage[MAX_PATH];

    if (!GetVersionEx(&ovi))
    {
		LoadString(HINST_THISAPP, IDS_CANTGETVERSION, szMessage, MAX_PATH); 
        msgtype = MB_OK | MB_ICONSTOP;
        goto deal;
    }

    if ( bDebug ) {
        wsprintf ( dbgStr, "ovi.dwMajorVersion = %ld, ovi.dwMinorVersion = %ld, ovi.dwBuildNumber = %ld, CD_MAJOR_VERSION = %ld, CD_MINOR_VERSION = %ld, CD_BUILD_NUMBER = %ld",
                    ovi.dwMajorVersion,
                    ovi.dwMinorVersion,
                    ovi.dwBuildNumber,
                    CD_MAJOR_VERSION,
                    CD_MINOR_VERSION,
                    CD_BUILD_NUMBER );
        MessageBox ( NULL, dbgStr, szAppTitle, MB_ICONASTERISK );
    }

    //
    //  Is this CD a version of the same os platform?
    //      ie. we don't run on Win32s, but we do run on Win95 (VER_PLATFORM_WIN32_WINDOWS)
    //      and NT (VER_PLATFORM_WIN32_NT).
    //
    if (ovi.dwPlatformId == VER_PLATFORM_WIN32s ) {

        //  The system running is Win32s on Windows.
        //  In this case, we won't offer setup.
        //

        fDisableSetupStuff = TRUE;
    }
    else if ( ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) {

        //  The system running is Win95.
        //  In this case, we always offer to upgrade the system.
        //
		LoadString(HINST_THISAPP, IDS_CRUSTYINSTALLATION, szMessage, MAX_PATH); 
        msgtype = MB_YESNO | MB_ICONQUESTION;
        

    } else {

        //  The system is running NT.  
        //  In this case, let's see if the build running is older(offer upgrade) or
        //  newer(don't offer upgrade). 
        //

        BOOL offersetup = FALSE;

        //
        //  Find out if this this CD is an older build on the same major release
        //  than that is running;
        //  if so, tell the user to get a newer CD.
        //
        if ((ovi.dwMajorVersion == CD_MAJOR_VERSION) &&
            (ovi.dwMinorVersion == CD_MINOR_VERSION) &&
            (ovi.dwBuildNumber > CD_BUILD_NUMBER)       ) {

            //
            //  Tell them to go find a newer CD.
            //
		    LoadString(HINST_THISAPP, IDS_CRUSTYCDROM, szMessage, MAX_PATH); 
            msgtype = MB_OK | MB_ICONEXCLAMATION;
            fDisableSetupStuff = TRUE;
            result = TRUE;
            goto deal;
        }

        //  Find out if the major version of the os is greater than of the CD.
        //  If so, tell user to get newer CD.
        //
        if ((ovi.dwMajorVersion > CD_MAJOR_VERSION) ) { 

            //
            //  Tell them to go find a newer CD.
            //
		    LoadString(HINST_THISAPP, IDS_CRUSTYCDROM, szMessage, MAX_PATH); 
            msgtype = MB_OK | MB_ICONEXCLAMATION;
            fDisableSetupStuff = TRUE;
            result = TRUE;
            goto deal;
        }

        //  Check if the versions are way different, or not.
        //
        if (ovi.dwMajorVersion < CD_MAJOR_VERSION) {

            //  The CD is much newer than the os running, ie. new version release.
            //

            offersetup = TRUE;
        }
        else if (ovi.dwMajorVersion == CD_MAJOR_VERSION) {

            //  Deal with same major release.
            //

            if (ovi.dwMinorVersion < CD_MINOR_VERSION) {

                //  Same major release and CD is newer minor release.
                //

                offersetup = TRUE;
            }
            else if ((ovi.dwMinorVersion <= CD_MINOR_VERSION) &&
                     (ovi.dwBuildNumber  <  CD_BUILD_NUMBER )    ) {

                //  Same major release, same minor release, running build is less than CD,
                //  so setup.
                //

                offersetup = TRUE;
            }
        }

        //
        // look at the result of that hulking mess above
        //
        if (offersetup) {
         
            //
            // offer to upgrade them to this version
            //
		    LoadString(HINST_THISAPP, IDS_CRUSTYINSTALLATION, szMessage, MAX_PATH); 
            msgtype = MB_YESNO | MB_ICONQUESTION;
            goto deal;
        }
    }

deal:
    if (fDisableSetupStuff) {
    
        AutorunEnableButton ( data, IDAB_NTSETUP, FALSE );
        AutorunEnableButton ( data, IDAB_OCSETUP, FALSE );
    }

    if (msgtype) {

        int imbResult;
     
        ShowWindow(data->window, SW_SHOWNORMAL);

        imbResult = MessageBox(data->window, szMessage, szAppTitle, msgtype);

        if ( imbResult == IDYES ) {

            LaunchSetup(data->window);
        }
        else if ( imbResult == IDNO ) {

            //  User choose NO, but we will leave the applet around for them to play.
            //
            result = TRUE;

        }

        //  We will end the applet shortly here since the launched setup is threaded out,
        //  and result remains FALSE.

    }
    else {
        result = TRUE;
    }

    return result;
}


//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunMouseHook(int code, WPARAM wp, LPARAM lp)
{
    if (code >= 0)
    {
        #define hook ((MOUSEHOOKSTRUCT *)lp)
        int id = g_fAppDisabled? -1 :
            AutoRunProcessPotentialHit(hook->hwnd, &hook->pt);

        if (id != g_iActiveButton)
            PostMessage(g_hMainWindow, ARM_MOUSEOVER, FALSE, (LPARAM)id);

        #undef hook
    }

    return CallNextHookEx(g_hMouseHook, code, wp, lp);
}

//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunWndProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    AUTORUNDATA *data = (AUTORUNDATA *)GetWindowLongPtr(window, GWLP_USERDATA);

    switch (msg)
    {
    case WM_NCCREATE:
        data = (AUTORUNDATA *)LocalAlloc(LPTR, sizeof(AUTORUNDATA));
        if (data && !InitAutoRunWindow(window, data, (LPCREATESTRUCT)lp))
        {
            LocalFree((HANDLE)data);
            data = NULL;
        }
        SetWindowLongPtr(window, GWLP_USERDATA, (LONG_PTR)data);
        if (!data)
            return FALSE;
        g_hMainWindow = window;
        goto DoDefault;

    case WM_CREATE:
        PlaySound(MAKEINTRESOURCE(IDW_STARTAPP), HINST_THISAPP,
            SND_RESOURCE | SND_ASYNC | SND_NODEFAULT);

        AutoRunCreateButtons(data);
        ShowWindow(window, SW_SHOWNORMAL);

        if (!CheckVersionConsistency(data)) {
            PostQuitMessage(0); 
            break;
            //return -1;
        }

        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_NCDESTROY:
        if (data)
        {
            CleanupAutoRunWindow(data);
            LocalFree((HANDLE)data);
        }
        g_hMainWindow = NULL;
        goto DoDefault;

    case WM_SIZE:
        AutoRunSized(data);
        break;

    case WM_DRAWITEM:
        AutoRunDrawItem(data, (DRAWITEMSTRUCT *)lp);
        break;

    case ARM_MOUSEOVER:
        AutoRunMouseOver(data, (int)lp, (BOOL)wp);
        break;

    case WM_ACTIVATE:
        g_fAppDisabled = ((LOWORD(wp) == WA_INACTIVE) || HIWORD(wp));
        AutoRunVerifyActiveItem(data);
        goto DoDefault;

    case WM_TIMER:
        AutoRunVerifyActiveItem(data);
        break;

    case WM_KEYDOWN:
        AutoRunHandleKeystroke(data, (TCHAR)wp, lp);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wp, lp) == BN_CLICKED)
            AutoRunClick(data, GET_WM_COMMAND_ID(wp, lp));
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wp == window)
            break;
        //fallthru
    case WM_QUERYNEWPALETTE:
        AutoRunRealize(window, data, NULL);
        break;

    case WM_ERASEBKGND:
        AutoRunErase(data, (HDC)wp);
        break;

    case WM_PAINT:
        AutoRunPaint(data);
        break;

    default:
    DoDefault:
        return DefWindowProc(window, msg, wp, lp);
    }

    return 1;
}

//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    
    WNDCLASS wc;
    HBITMAP hbm = NULL;
    BITMAP bm;
    DWORD style;
    HWND window;
    RECT r;
    HDC screen;
    int retval = -1;
    HANDLE  mutex = NULL;

    g_hinst = hInstance; 

    if ( strstr ( lpCmdLine, "testit" ) ) {
        
        bDebug = TRUE;
    }

    //  Only run one copy of NT's autorun.exe program at a time.
    //
    mutex = CreateMutex ( NULL, FALSE, "NT AutoRun Is Running" );
    if ( mutex == NULL ) {

        //  An error occurred, like running out of memory, bail now...
        //
        ExitProcess ( 0 );
    }

    //  Make sure we are the only process with our named mutex.
    //
    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        CloseHandle (mutex);
        ExitProcess ( 0 );
    }
   

    //
    //  The below code is here in order to prevent this application from
    //  displaying any windows, etc., in the case where NT Setup is asking the user to 
    //  insert the system CD, for example, when the user is installing a new driver. 
    //  Otherwise, we'll get this app each time the CD is put in the drive for NT 4.0 and
    //  beyond.
    //
    window = FindWindow(c_szAutoRunPrevention, c_szAutoRunPrevention);
    if (window)
    {
        // do nothing
        // setup is probably trying to copy a driver or something...
        retval = 0;
        goto im_doug;
    }

    //
    //  Stop if we can't load the app title in for this application.
    //
    if (!LoadString(HINST_THISAPP, IDS_APPTITLE, szAppTitle,
        sizeof(szAppTitle)))
    {
        goto im_doug;
    }

    //
    //  Stop if we can't find our window ?
    //
    window = FindWindow(c_szAutoRunClass, szAppTitle);
    if (window)
    {
        retval = 0;
        SetForegroundWindow(window);
        goto im_doug;
    }

    //
    // yet more mundane platform-centric details
    //
    if (!GetClassInfo(HINST_THISAPP, c_szAutoRunClass, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = AutoRunWndProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szAutoRunClass;

        if (!RegisterClass(&wc))
            goto im_doug;
    }

    //
    // get a few tidbits about the display we're running on
    //
    screen = GetDC(NULL);

#if defined (DEBUG) && defined (FORCE_4BIT)
    g_f4BitForColor = TRUE;
#else
    g_f4BitForColor = (GetDeviceCaps(screen, PLANES) *
        GetDeviceCaps(screen, BITSPIXEL)) < 8;
	//g_f4BitForColor = TRUE;  // testing...
#endif

    g_fNeedPalette = (!g_f4BitForColor &&
        (GetDeviceCaps(screen, RASTERCAPS) & RC_PALETTE));

    ReleaseDC(NULL, screen);

    //
    // load the window backdrop image
    //
 
    hbm = LoadImage(HINST_THISAPP, MAKEINTRESOURCE(g_f4BitForColor?
        IDB_4BPP_BACKDROP : IDB_8BPP_BACKDROP), IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION);

    if (!hbm)
        goto im_doug;


    //
    //
    //  See if there is a mouse on the system.
    //
    if ((g_fMouseAvailable = (GetSystemMetrics(SM_MOUSEPRESENT) != 0)) != 0)
    {
        //
        //  Set-up a mouse hook for our thread, but
        //  don't worry if it fails, the app will still work.
        //
        g_hMouseHook = SetWindowsHookEx(WH_MOUSE, AutoRunMouseHook,
            HINST_THISAPP, GetCurrentThreadId());
    }

    //
    // create the window based on the backdrop image
    //
    GetObject(hbm, sizeof(bm), &bm);
    r.left = (GetSystemMetrics(SM_CXSCREEN) - bm.bmWidth) / 2;
    r.top = (GetSystemMetrics(SM_CYSCREEN) - bm.bmHeight) / 3; // intended
    r.right = r.left + bm.bmWidth;
    r.bottom = r.top + bm.bmHeight;

    style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    AdjustWindowRect(&r, style, FALSE);

    g_hMainWindow = CreateWindow(c_szAutoRunClass, szAppTitle, style,
        r.left, r.top, r.right - r.left, r.bottom - r.top, NULL, NULL,
        HINST_THISAPP, hbm);

    //
    // if we got here it's probably safe to show ourselves and pump messages
    //
    if (g_hMainWindow)
    {
        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        retval = (int)msg.wParam;
    }

im_doug:

    //
    // random cleanup
    //
    if (g_hMouseHook)
    {
        UnhookWindowsHookEx(g_hMouseHook);
        g_hMouseHook = NULL;
    }

    if (hbm)
        DeleteObject(hbm);

    CloseHandle ( mutex );

    return retval;
}


//---------------------------------------------------------------------------
/**** NT doesn't use this, currently.
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {

         // Scan, and skip over, subsequent characters until
         // another double-quote or a null is encountered.
         //
        while ( *++pszCmdLine && (*pszCmdLine
            != '\"') );
        
         // If we stopped on a double-quote (usual case), skip
         // over it.
         
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    
     //Skip past any white space preceeding the second token.
     //
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
****/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\boot\boot.c ===
/*
 *  10.23.97    Joe Holman      Make our 3 boot disks for a product.
 *                              This program needs to do the following:
 *                              
 *                              1.   calculate if the boot files value
 *                                   is adequate
 *                              2.   create a list of files that can be used
 *                                   to make the boot floppies. 
 *
 *  11.02.98    Joe Holman      Modified per new key names.
 *  11.19.98    Elliott Munger  Made changes to suport 4 bootdisks
 */
#include <stdlib.h>
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <time.h>
#include <setupapi.h>


int  __cdecl main( int, char ** );

FILE    * logFile;

HANDLE  hDosnetInf;
CHAR    returnBuffer[MAX_PATH];
CHAR    returnBuffer2[MAX_PATH];
CHAR    szWrite[MAX_PATH];
CHAR    szFloppyDump[MAX_PATH];
CHAR    szLog[MAX_PATH];
CHAR    szReleaseShare[MAX_PATH];
DWORD   dwRequiredSize;
CHAR    szDosnetPath[MAX_PATH];
CHAR    szLayoutPath[MAX_PATH];
CHAR    szRenamedFile[MAX_PATH];
CHAR    szBootSector[MAX_PATH];

BOOL    bHasRenamedFile = FALSE;
BOOL    bMakeNECBoot = FALSE;

//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))

#define _hK 512
#define _1K 1*1024
#define _2K 2*1024
#define _4K 4*1024
#define _8K 8*1024
#define _16K 16*1024
#define _32K 32*1024
#define _64K 64*1024
#define _128K 128*1024
#define _256K 256*1024

//  System parition values per cluster size for 
//  files that go in the ~BT directory.
//
DWORD   dw_hK = 0;
DWORD   dw_1K = 0;
DWORD   dw_2K = 0;
DWORD   dw_4K = 0;
DWORD   dw_8K = 0;
DWORD   dw_16K = 0;
DWORD   dw_32K = 0;
DWORD   dw_64K = 0;
DWORD   dw_128K = 0;
DWORD   dw_256K = 0;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Usage( void ) {

    printf ( "Usage: boot logFile dosnet.inf-path output-file-for-dmf flat-uncompressed-share path-for-floppy-files x86orNECbootdisk" );
    exit (1);
}

void Header(argv)
    char* argv[];
{
    time_t t;

    Msg ("\n=========== BOOT.EXE =============\n");
    Msg ("LogFile                : %s\n",argv[1]);
    Msg ("DosNet.INF path        : %s\n",argv[2]);
    Msg ("Output file path       : %s\n",argv[3]);
    Msg ("Flat uncompressed share: %s\n", argv[4] );
    Msg ("Path to put floppy files:%s\n", argv[5] );
    Msg ("X86 or NEC Boot sector : %s\n", argv[6] );
    time(&t);
    Msg ("Time                   : %s",ctime(&t));
    Msg ("================================\n\n");
}

void    WriteToFile ( char * fileName, char flopNum ) {

    FILE *  fHandle;
    CHAR    Line[MAX_PATH];
    CHAR    szPath[MAX_PATH];

    sprintf ( szPath, "%s\\b%c.txt", szFloppyDump, flopNum );

    fHandle = fopen ( szPath, "a" );

    if ( fHandle == NULL ) {

        Msg ( "ERROR Couldn't open file with fopen:  %s\n", szPath );
    }
    else {

        //  This denotes that it is the first floppy,
        //  which needs to have the boot sector put on it.
        //
        if ( strstr ( fileName, "disk1" ) && flopNum == '0' ) {

            if ( bMakeNECBoot ) {
                strcpy ( Line, "-bnt35nec98setup\n" );
            }
            else {
                strcpy ( Line, "-bnt35setup\n" ); 
            }
            fwrite ( Line, 1, strlen(Line), fHandle );

            Msg ( "\nWritingToFile:  %s\n%s\n\n", szPath, Line );

        }

        if ( bHasRenamedFile ) {
            
            sprintf ( Line, "%s=%s\n", fileName, returnBuffer2 ); 
        }
        else {
            sprintf ( Line, "%s\n"   , fileName );
        }

        fwrite ( Line, 1, strlen(Line), fHandle );

        Msg ( "\nWritingToFile:  %s\n%s\n\n", szPath, Line );

        fclose ( fHandle );
    }

}


VOID    MakeCompName ( const char * inFile, char * outFile ) {

    unsigned i;
    unsigned period;

    strcpy( outFile, inFile );
    for ( period=(unsigned)(-1), i = 0 ; i < strlen(inFile); i++ ) {

        if ( inFile[i] == '.' ) { 
            period = i;
        }
    }
    if ( period == (strlen(inFile)-4) ) {

        outFile[strlen(outFile)-1] = '_';
    }
    else if ( period == (unsigned)(-1)) {

        strcat ( outFile, "._");
    }
    else {

        strcat ( outFile, "_");
    }

}

void    ChangeFileNameToCompressNameIfNeeded ( char * fileName ) {

    HANDLE  hLayoutInf;

    //  See if the file is going to come over as compressed or not.
    //  If so, change it's name so we can process it.
    //
    
    //  Special case for files not stored in the INF.
    //
    if ( strstr ( fileName, "disk1" ) ||
         strstr ( fileName, "setupldr.bin" ) ||
         strstr ( fileName, "usetup.exe" )   ) {

        goto no_processing;
    }

    //  Open layout.inf to find out if the file is to be compressed or not.
    //
    hLayoutInf = SetupOpenInfFile ( szLayoutPath, NULL, INF_STYLE_WIN4, NULL );  
    if ( hLayoutInf == INVALID_HANDLE_VALUE ) {

        Msg ( "ERROR: ChangeFileNameToCompressNameIfNeeded could not open INF:  %s\n", szLayoutPath );

    }
    else {

        BOOL    b;
        DWORD   requiredSize;
        INFCONTEXT  ic;
        CHAR    returnBuffer[MAX_PATH];

        b = SetupFindFirstLine (    hLayoutInf,
                                    (LPSTR) "SourceDisksFiles",
                                    (LPSTR) fileName,
                                    &ic ); 

        if ( !b ) {

            //  If we get an error, perhaps the file is in the .x86 section.
            //
            b = SetupFindFirstLine (hLayoutInf,
                                    (LPSTR) "SourceDisksFiles.x86",
                                    (LPSTR) fileName,
                                    &ic ); 
            if ( !b ) {

               Msg ( "ERROR:  CopyTheFile SetupFindFirstLine couldn't find file in section: gle = %x, >>>%s<<<\n", 
                    GetLastError(), fileName );
            }
            else {

                goto continue_here;
            }
        }
        else {

continue_here:;

            //  Look at the 7th field.
            //
            b = SetupGetStringField ( &ic,
                                        7,
                                        (LPSTR) returnBuffer,
                                        sizeof ( returnBuffer ),
                                        &dwRequiredSize );            
            
            if ( !b ) {

                Msg ( "ERROR: CopyTheFile SetupGetStringField gle = %ld\n", GetLastError());
            }
            else { 

                char * p;

                Msg ( "++++ returnBuffer = %s\n", returnBuffer );

                //  Get to the character that determines if we compress or not.
                //
                p = returnBuffer;
                if ( *p != '_' ) {

                    CHAR    commandBuffer[MAX_PATH];
                    CHAR    szTmp[MAX_PATH];

                    //  Since we are going to be using a compressed filename,
                    //  turn the uncompressed filename into a compressed filename.
                    //
                    MakeCompName ( fileName, szTmp );
                    strcpy ( fileName, szTmp );
                    

                    Msg ( "using compressed filename, so now it is:  %s\n", fileName );

                }
                else {

                    Msg ( "leaving filename alone, still:  %s\n", fileName );
                }
            }
        }

        SetupCloseInfFile ( hLayoutInf );
    }
no_processing:;
}

void    AddInSize ( char * fileName ) {

    CHAR    szPath[MAX_PATH];
    HANDLE  h;
    WIN32_FIND_DATA wfd;

    sprintf ( szPath, "%s\\%s", szReleaseShare, fileName );
    Msg ( "\n+++  AddInSize for:  %s   +++\n", szPath );

    h = FindFirstFile ( szPath, &wfd );
    if ( h == INVALID_HANDLE_VALUE ) {
        Msg ( "ERROR: FindFirstFile on %s, gle = %ld\n", szPath, GetLastError() );
    }
    else {
        dw_hK   += ROUNDUP2 ( wfd.nFileSizeLow, 512 );
        dw_1K   += ROUNDUP2 ( wfd.nFileSizeLow, _1K );
        dw_2K   += ROUNDUP2 ( wfd.nFileSizeLow, _2K );
        dw_4K   += ROUNDUP2 ( wfd.nFileSizeLow, _4K );
        dw_8K   += ROUNDUP2 ( wfd.nFileSizeLow, _8K );
        dw_16K  += ROUNDUP2 ( wfd.nFileSizeLow, _16K );
        dw_32K  += ROUNDUP2 ( wfd.nFileSizeLow, _32K );
        dw_64K  += ROUNDUP2 ( wfd.nFileSizeLow, _64K );
        dw_128K += ROUNDUP2 ( wfd.nFileSizeLow, _128K );
        dw_256K += ROUNDUP2 ( wfd.nFileSizeLow, _256K );
/*
        Msg ( "dw_hK   = %ld\n", dw_hK );
        Msg ( "dw_1K   = %ld\n", dw_1K );
        Msg ( "dw_2K   = %ld\n", dw_2K );
        Msg ( "dw_4K   = %ld\n", dw_4K );
        Msg ( "dw_8K   = %ld\n", dw_8K );
        Msg ( "dw_16K  = %ld\n", dw_16K );
        Msg ( "dw_32K  = %ld\n", dw_32K );
        Msg ( "dw_64K  = %ld\n", dw_64K );
        Msg ( "dw_128K = %ld\n", dw_128K );
        Msg ( "dw_256K = %ld\n", dw_256K );
*/

        FindClose ( h );
    }

}



void    CopyTheFile ( CHAR * fileName, CHAR flopNum ) {

    CHAR    szPath1[MAX_PATH];
    CHAR    szPath2[MAX_PATH];
    BOOL    b;

    Msg ( "CopyTheFile:  %s\n", fileName );

    //  Copy the file.
    //
    sprintf ( szPath1, "%s\\%s", szReleaseShare, fileName );
    sprintf ( szPath2, "%s\\%s", szFloppyDump, fileName );
    b = CopyFile ( szPath1, szPath2, FALSE );
                
    if ( !b ) {

       Msg ( "ERROR: CopyFile failed, gle = %ld, >>>%s<<< >>>%s<<<\n", 
                                GetLastError(), szPath1, szPath2 );

    }
    else {
       Msg ( "CopyFile: %s %s [ok]\n", szPath1, szPath2 );
       SetFileAttributes ( szPath2, FILE_ATTRIBUTE_NORMAL );
    }

    //  Write the name of the file to B?.txt file in the specified directory.
    //
    WriteToFile ( fileName, flopNum );

}

void    GetFloppy ( char Floppy ) {

        BOOL        b;
        INFCONTEXT  ic;

        char szSection[MAX_PATH];

        sprintf ( szSection, "%s%c", "FloppyFiles.", Floppy );

        Msg ( "\nGetting for section:  %s\n\n", szSection );

        //  Get the first line in the section, ie FloppyFiles.N.
        //  Note:  Be sure to look for files that maybe renamed:
        //
        //          d1,disk1,disk101
        //          disk1=disk101       for the output file. 
        //
        b = SetupFindFirstLine (    hDosnetInf,
                                    szSection,
                                    NULL,
                                    &ic ); 


        if ( !b ) {

           Msg ( "ERROR: SetupFindFirstLine not found in %s\n", szSection );
        }
        else {

            //  Get the 2nd field's filename, such as in d1,disk1,disk101
            //  would be disk1.
            //
            b = SetupGetStringField ( &ic,
                                        2,
                                        (LPSTR) &returnBuffer,
                                        sizeof ( returnBuffer ),
                                        &dwRequiredSize );            
            
            if ( !b ) {

                Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
            }

            //  See if we need to compress this file and
            //  add in the size for the ~bt directory.
            //
            ChangeFileNameToCompressNameIfNeeded ( returnBuffer );
            AddInSize ( returnBuffer );
            
            //  Get the 3rd field's filename, such as in d1,disk1,disk101
            //  would be disk101.
            //  This is the case where we need to stick disk1=disk101 for
            //  the output file for disk imaging.
            //
            //  Note:   we don't check for errors here because 3rd field
            //          because this renamed file is optional. 
            //
            b = SetupGetStringField ( &ic,
                                        3,
                                        (LPSTR) &returnBuffer2,
                                        sizeof ( returnBuffer2 ),
                                        &dwRequiredSize );            
            
            //  Note - not checking for errors here.            
            //
            if ( b ) {
                bHasRenamedFile = TRUE;
            }
            else {
                bHasRenamedFile = FALSE;
            } 



            //  Copy the file to the specified directory.
            //
            CopyTheFile ( returnBuffer, Floppy );

            while ( 1 ) {

                //  Get the next line in the section.
                //
                b = SetupFindNextLine (    &ic,
                                           &ic ); 


                if ( !b ) {

                    //  Denotes that there is NOT another line.
                    //
                    Msg ( "\n" );
                    break;
                }
                else {

                    //  Get the 2nd field's filename, 
                    //  such as in d1,disk1,disk101
                    //  would be disk1.
                    //
                    b = SetupGetStringField (   &ic,
                                                2,
                                                (LPSTR) &returnBuffer,
                                                sizeof ( returnBuffer ),
                                                &dwRequiredSize );            
            
                    if ( !b ) {

                        Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
                        break;
                    }
            
                    //Msg ( "returnBuffer = %s\n", returnBuffer );

                    ChangeFileNameToCompressNameIfNeeded ( returnBuffer );
                    AddInSize ( returnBuffer );


                    //  Get the 3rd field's filename, such as in 
                    //  d1,disk1,disk101
                    //  would be disk101.
                    //  This is the case where we need to stick 
                    //  disk1=disk101 for
                    //  the output file for disk imaging.
                    //
                    //  Note:   we don't check for errors here because 3rd field
                    //          because this renamed file is optional. 
                    //
                    b = SetupGetStringField ( &ic,
                                        3,
                                        (LPSTR) &returnBuffer2,
                                        sizeof ( returnBuffer2 ),
                                        &dwRequiredSize );            
            
                    //  Note - not checking for errors here.            
                    //
                    if ( b ) {
                        bHasRenamedFile = TRUE;
                    }
                    else {
                        bHasRenamedFile = FALSE;
                    } 


                    //  Copy the file to the specified directory.
                    //
                    CopyTheFile ( returnBuffer, Floppy );

                }
            }
        }

}

DWORD Get2ndSize ( char * key ) {

    CHAR    returnedString[MAX_PATH];
    #define OHPROBLEM   "OH OH"
    DWORD   dwSize = 666;
    char * p;

    GetPrivateProfileString (   "DiskSpaceRequirements", 
                                key, 
                                OHPROBLEM, 
                                returnedString, 
                                MAX_PATH, 
                                szDosnetPath );

    if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
        Msg ( "ERROR:  section >>>%s<<< not found.\n", key );
    }

    //Msg ( ">>> %s\n", returnedString );

    //  Find the ',' which denotes the ~BT data.
    //
    p = strstr ( returnedString, "," );
    if ( !p ) {

        Msg ( "ERROR: returnedString has no ',' in it: %s\n", returnedString );
        dwSize = 0;
    }
    else {

        ++p;    // point to the number, not the ','
        dwSize = atoi ( p );
        //Msg ( ">+BT dwSize = %ld, p = %s\n", dwSize, p );
    }

    return (dwSize);

}

DWORD   GetBT ( DWORD ClusterSize ) {

    switch ( ClusterSize ) {

        case _hK :
            return Get2ndSize ( "TempDirSpace512" );
            break;
        case _1K :
            return Get2ndSize ( "TempDirSpace1K" );
            break;
        case _2K :
            return Get2ndSize ( "TempDirSpace2K" );
            break;
        case _4K :
            return Get2ndSize ( "TempDirSpace4K" );
            break;
        case _8K :
            return Get2ndSize ( "TempDirSpace8K" );
            break;
        case _16K :
            return Get2ndSize ( "TempDirSpace16K" );
            break;
        case _32K :
            return Get2ndSize ( "TempDirSpace32K" );
            break;
        case _64K :
            return Get2ndSize ( "TempDirSpace64K" );
            break;
        case _128K :
            return Get2ndSize ( "TempDirSpace128K" );
            break;
        case _256K :
            return Get2ndSize ( "TempDirSpace256K" );
            break;

        default :
            Msg ( "ERROR:  ClusterSize not known:  %ld\n", ClusterSize );
            break;



    }

    return 0;
}

void VerifyTotalSizeIsAdaquate ( void ) {

    //  Make sure that the total size we need is specified in dosnet.inf.
    //

    Msg ( "\n\nVerifyTotalSizeIsAdaquate...\n" );

    //  Dosnet.inf's [SpaceRequirements] cluster fields should look like:
    //
    //      512 = xxxxxx, yyyyyy    where x is for the ~LS files and
    //                              where y is for the ~BT files.
    //

    #define FUDGE 1*1024*1024      // to make sure we have enough for dir entries in FAT.

    if ( dw_hK > GetBT ( _hK ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 512 ~BT too small, %ld, use:  %ld\n", GetBT ( _hK ), dw_hK+FUDGE );
    }
    if ( dw_1K > GetBT ( _1K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 1K ~BT too small, %ld, use:  %ld\n", GetBT ( _1K ), dw_1K+FUDGE );
    }
    if ( dw_2K > GetBT ( _2K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 2K ~BT too small, %ld, use:  %ld\n", GetBT ( _2K ), dw_2K+FUDGE );
    }
    if ( dw_4K > GetBT ( _4K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 4K ~BT too small, %ld, use:  %ld\n", GetBT ( _4K ), dw_4K+FUDGE );
    }
    if ( dw_8K > GetBT ( _8K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 8K ~BT too small, %ld, use:  %ld\n", GetBT ( _8K ), dw_8K+FUDGE );
    }
    if ( dw_16K > GetBT ( _16K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 16K ~BT too small, %ld, use:  %ld\n", GetBT ( _16K ), dw_16K+FUDGE );
    }
    if ( dw_32K > GetBT ( _32K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 32K ~BT too small, %ld, use:  %ld\n", GetBT ( _32K ), dw_32K+FUDGE );
    }
    if ( dw_64K > GetBT ( _64K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 64K ~BT too small, %ld, use:  %ld\n", GetBT ( _64K ), dw_64K+FUDGE );
    }
    if ( dw_128K > GetBT ( _128K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 128K ~BT too small, %ld, use:  %ld\n", GetBT ( _128K ), dw_128K+FUDGE );
    }
    if ( dw_256K > GetBT ( _256K ) ) {
        Msg ( "matth ERROR:  Dosnet.inf's [DiskSpaceRequirements]'s 256K ~BT too small, %ld, use:  %ld\n", GetBT ( _256K ), dw_256K+FUDGE );
    }


}


void    MyDeleteFile ( char Num ) {

    BOOL    b;
    CHAR    szPath[MAX_PATH];

    sprintf ( szPath, "%s\\b%c.txt", szFloppyDump, Num ); 
    Msg ( "Deleting:  %s\n", szPath );
    b = DeleteFile ( szPath );
    if ( !b ) {
        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            Msg ( "ERROR:  DeleteFile, gle = %ld, %s\n", GetLastError(), szPath );
        }
    }

}

__cdecl main ( int argc, char * argv[] ) {

    if ( argc != 7) {
        Usage();
        exit(1);
    }
    if ((logFile=fopen(argv[1],"a"))==NULL) {

        printf("ERROR Couldn't open logFile:  %s\n",argv[1]);
        return(1);
    }
    Header(argv);

    Msg ( "%s %s %s %s %s %s %s\n", argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6] );

    //  Copy paths into appropriate string variables.
    //
    strcpy ( szLog, argv[1] );
    Msg ( "szLog = %s\n", szLog );

    strcpy ( szDosnetPath, argv[2] );
    Msg ( "szDosnetPath = %s\n", szDosnetPath );

    strcpy ( szReleaseShare, argv[4] );
    Msg ( "szReleaseShare = %s\n", szReleaseShare );

    sprintf ( szLayoutPath, "%s\\%s", argv[4], "layout.inf" );
    Msg ( "szLayoutPath = %s\n", szLayoutPath );

    strcpy ( szFloppyDump, argv[5] ); 
    Msg ( "szFloppyDump = %s\n", szFloppyDump );
    
    strcpy ( szBootSector, argv[6] );
    Msg ( "szBootSector = %s\n", szBootSector );
    if ( strstr ( szBootSector, "NEC" ) ) {

        bMakeNECBoot = TRUE;
        Msg ( "Making this boot floppy #1 NEC98 bootable...\n" );
    }

    //
    //
    hDosnetInf = SetupOpenInfFile ( szDosnetPath, NULL, INF_STYLE_WIN4, NULL );  

    if ( hDosnetInf == INVALID_HANDLE_VALUE ) {

        Msg ( "ERROR: boot.exe - could not open INF:  %s\n", szDosnetPath );

    }
    else {

        CHAR szPath[MAX_PATH];
        BOOL    b;

        //  Delete the files that hold the file list.
        //
        MyDeleteFile ( '0' );
        MyDeleteFile ( '1' );
        MyDeleteFile ( '2' );
        MyDeleteFile ( '3' );
    
        GetFloppy ( '0' );
        GetFloppy ( '1' );
        GetFloppy ( '2' );
        GetFloppy ( '3' );

        SetupCloseInfFile ( hDosnetInf );

        VerifyTotalSizeIsAdaquate ();
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\cats\cats.c ===
/*

Modifications:  

    12.12.94    Joe Holman      Changed SourceCompare definitions so warning
                                no longer occurs at compile time.

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;
char* product;

void Header(argv)
char* argv[];
{
    PRINT1("\n=========== CATEGORIES ==============\n")
    PRINT2("Input BOM: %s\n",argv[2]);
    PRINT2("Product: %s\n",argv[3]);
    PRINT1("======================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Displays a list of sourceids for the specified product.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM to operate with.\n");
    printf("[Product] - Product to display categories for.\n");
    printf("            ALL = All products specified in the BOM.\n");
    printf("            NTFLOP = Windows NT on floppy\n");
    printf("            LMFLOP = Lan Manager on floppy\n");
    printf("            NTCD = Windows NT on CD\n");
    printf("            LMCD = Lan Manager on CD\n");
    printf("            SDK = Software Development Kit\n");
}

int __cdecl SourceCompare(const void *, const void *);

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry *e;
    int records,i;
    char *buf;
    char oldSource[MAX_PATH];

    if (argc!=4) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
	printf("ERROR: Couldn't open log file %s\n",argv[1]);
	return(1);
    }
    Header(argv);
    LoadFile(argv[2],&buf,&e,&records,argv[3]);

    qsort(e,records,sizeof(Entry),SourceCompare);
    strcpy(oldSource,"bogus");
    for (i=0;i<records;i++)
	if ((i==0) || _stricmp(e[i].source,oldSource))
	{
	    PRINT2("INFO: Source: %s\n",e[i].source);
	    strcpy(oldSource,e[i].source);
	}

    fflush(logFile);
    fclose(logFile);
    free(e);
    free(buf);
    return(0);
}

int __cdecl SourceCompare(const void *v1, const void *v2) {

    Entry *e1 = (Entry *) v1;
    Entry *e2 = (Entry *) v2;
    return(_stricmp(e1->source,e2->source));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\dcomp\dcomp.c ===
/*

    xx.xx.94    TedM        Created.
    10.31.94    JoeHol      Added -b switch to help notify of files that
                            have had bug fixes back-out, eg. since media
                            build group uses -d switch, we need to know
                            if a file is now "older" than before so we can
                            also take the "bad newer" file out of the media.

                            Also, verifies src and dst by DOS date and time.

    11.01.94    JoeHol      -l logs to chk.log, not compress.log.
	12.14.94	JoeHol		Make -l work with name of log file, use dcomp.log
							if not specified.
    02.07.95    JoeHol      -b for bom file.  If this is specified we will
                            check that the files are listed in the bom.
                            If a file isn't in the bom, we won't add the file
                            to the list of files to compress.
    06.20.95    JoeHol      Since we are changing the location of the files,
                            lets just compressed all, ie. disable real use of the -b switch
                            for awhile.
    08.03.95    JoeHol      If a file isn't found to compress in a directory, we don't stop, but
                            continue gracefully displaying an error message.


*/



#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setupapi.h>
#include <process.h>


typedef struct _SOURCEFILE {
    struct _SOURCEFILE *Next;
    WIN32_FIND_DATA FileData;
} SOURCEFILE, *PSOURCEFILE;

PSOURCEFILE SourceFileList;
DWORD SourceFileCount;

PSTR SourceSpec,TargetDirectory;

HANDLE NulHandle;

CRITICAL_SECTION SourceListCritSect;
CRITICAL_SECTION ConsoleCritSect;

#define MFL	256
FILE    * logFile;
FILE    * bomFile;
char	logFileName[MFL];
char    bomFileName[MFL];
char    infFilePath[MFL];

#define MAX_NUMBER_OF_FILES 5000    // let's assume we only have 5000 files max in the product.
#define NAME_SIZE           25      // assume no filename is greater than 25 chars long.

char    szFiles[MAX_NUMBER_OF_FILES][NAME_SIZE];

BOOL    bVerbose = FALSE;
BOOL    bBomChecking = FALSE;

int     wRecords=0;

DWORD ThreadCount;

#define MAX_EXCLUDE_EXTENSION 100
PSTR ExcludeExtension[MAX_EXCLUDE_EXTENSION];
unsigned ExcludeExtensionCount;

#define MAX_EXCLUDE_FILEFILTER 100
char ExcludeFileFilter[MAX_EXCLUDE_FILEFILTER][MAX_PATH];
unsigned ExcludeFileFilterCount;
HINF ExcludeFilterHandle[MAX_EXCLUDE_FILEFILTER];


PVOID
MALLOC(
    IN DWORD Size
    )
{
    return((PVOID)LocalAlloc(LMEM_FIXED,Size));
}

VOID
FREE(
    IN PVOID Block
    )
{
    LocalFree((HLOCAL)Block);
}


BOOL
AddExtensionToExclude(
    IN PSTR Extension
    )
{
    //
    // Make sure it starts with a dot.
    //
    if((*Extension != '.') || (lstrlen(Extension) < 2)) {
        return(FALSE);
    }

    if(ExcludeExtensionCount < MAX_EXCLUDE_EXTENSION) {
        ExcludeExtension[ExcludeExtensionCount++] = Extension;
    } else {
        printf("Warning: exclude extension %s ignored (%u max).\n",Extension,MAX_EXCLUDE_EXTENSION);
    }

    return(TRUE);
}

BOOL
AddFilterToExclude(
    IN PSTR FilterName
    )
{
    DWORD error;

    if(!FilterName) {
        return(FALSE);
    }

    if(ExcludeFileFilterCount < MAX_EXCLUDE_EXTENSION) {
        ExcludeFilterHandle[ExcludeFileFilterCount] = SetupOpenInfFile(
                                                             FilterName,
                                                             NULL,
                                                             INF_STYLE_WIN4,
                                                             &error );
        if (ExcludeFilterHandle[ExcludeFileFilterCount] == INVALID_HANDLE_VALUE) {
            printf("Warning: couldn't open exclude file filter %s (%d).\n", FilterName , error);
            return(FALSE);
        }
        strcpy( ExcludeFileFilter[ExcludeFileFilterCount], FilterName );
        ExcludeFileFilterCount += 1;
        return(TRUE);

    } else {
        printf("Warning: exclude file filter %s ignored (%u max).\n",FilterName,MAX_EXCLUDE_EXTENSION);
    }

    return(TRUE);
}



BOOL
ParseArguments(
    IN int  argc,
    IN PSTR *argv
    )
{
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    while(argc--) {

        if((**argv == '-') || (**argv == '/')) {

            switch((*argv)[1]) {

            case 'b':
            case 'B':
                strcpy ( infFilePath, &(*argv)[2] );
				printf ( "infFilePath: >>>%s<<<\n", &(*argv)[2] );
                bBomChecking = TRUE;

                break;

			case 'l':
			case 'L':
				strcpy ( logFileName, &(*argv)[2] );
				//printf ( ">>>%s<<<\n", &(*argv)[2] );
				break;

            case 'm':
            case 'M':
                if(ThreadCount) {
                    return(FALSE);
                }
                ThreadCount = (DWORD)atoi((*argv)+2);
                if(!ThreadCount) {
                    return(FALSE);
                }
                break;

            case 'v':
            case 'V':
                bVerbose = TRUE;
                break;

            case 'x':
            case 'X':
                if((argc-- < 1) || !AddExtensionToExclude(*(++argv))) {
                    return(FALSE);
                }
                break;
	        case 'f':
            case 'F':
		        if((argc-- < 1) || !AddFilterToExclude(*(++argv))) {
                    return(FALSE);
                }
                break;
            default:
                return(FALSE);
            }

        } else {

            if(SourceSpec) {
                if(TargetDirectory) {
                    return(FALSE);
                } else {
                    TargetDirectory = *argv;
                }
            } else {
                SourceSpec = *argv;
            }
        }

        argv++;
    }

    if(!TargetDirectory || !SourceSpec) {
        return(FALSE);
    }

    //
    // Make sure target is a directory.
    //
    FindHandle = FindFirstFile(TargetDirectory,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }
    FindClose(FindHandle);
    if(!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return(FALSE);
    }

    return(TRUE);
}


VOID
Usage(
    VOID
    )
{
    printf("DCOMP -llog [-x .ext ...] [-m#] [-d] [-bbom] Source Dest\n\n");
    printf("  -x .ext        Exclude files with extension .ext.\n");
    printf("  -m             Force use of # threads.\n");
    printf("  -v             Verbose.\n" );
    printf("  -llog          Log filename, dcomp.log default.\n");
    printf("  -binfPath      your setup\\inf\\win4\\inf path.\n" );
    printf("  -f infname     Excludes files listed in inf.\n");
    printf("  Source         Source file specification.  Wildcards may be used.\n");
    printf("  Destination    Specifies directory where renamed compressed files\n");
    printf("                 will be placed.\n");
}


VOID
DnpGenerateCompressedName(
    IN  PSTR Filename,
    OUT PSTR CompressedName
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

        Look backwards for a dot.  If there is no dot, append "._" to the name.
        If there is a dot followed by 0, 1, or 2 charcaters, append "_".
        Otherwise assume there is a 3-character extension and replace the
        third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - receives compressed file name.

Return Value:

    None.


--*/

{
    PSTR p,q;

    strcpy(CompressedName,Filename);

    p = strrchr(CompressedName,'.');
    q = strrchr(CompressedName,'\\');
    if(q < p) {

        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore.  p points to the dot so include that in the length.
        //
        if(lstrlen(p) < 4) {
            lstrcat(CompressedName,"_");
        } else {

            //
            // Assume there are 3 characters in the extension.  So replace
            // the final one with an underscore.
            //

            p[3] = '_';
        }

    } else {

        //
        // No dot, just add ._.
        //

        lstrcat(CompressedName,"._");
    }
}


BOOL
GetSetTimeStamp(
    IN  PSTR      FileName,
    OUT PFILETIME CreateTime,
    OUT PFILETIME AccessTime,
    OUT PFILETIME WriteTime,
    IN  BOOL      Set
    )
{
    HANDLE h;
    BOOL b;

    //
    // Open the file.
    //
    h = CreateFile(
            FileName,
            Set ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = Set
      ? SetFileTime(h,CreateTime,AccessTime,WriteTime)
      : GetFileTime(h,CreateTime,AccessTime,WriteTime);

    CloseHandle(h);

    return(b);
}


VOID
mprintf(
    IN DWORD ThreadSerialNumber,
    IN PSTR  FormatString,
    ...
    )
{
    CHAR msg[2048];
    va_list arglist;

    va_start(arglist,FormatString);

    vsprintf(msg,FormatString,arglist);
    vfprintf(logFile,FormatString,arglist); // print to log file

    va_end(arglist);

    //EnterCriticalSection(&ConsoleCritSect);

    if(ThreadCount == 1) {
        printf(msg);
    } else {
        printf("%u: %s",ThreadSerialNumber,msg);
    }

    //LeaveCriticalSection(&ConsoleCritSect);
}

VOID
logprintf(
    IN PSTR  FormatString,
    ...
    )
{
    CHAR msg[2048];
    va_list arglist;

    va_start(arglist,FormatString);

    vsprintf(msg,FormatString,arglist);
    vfprintf(logFile,FormatString,arglist); // print to log file

    va_end(arglist);

}

//  SameDosDateTime returns:    TRUE if date/times are same; FALSE otherwise.
//
BOOL
SameDosDateTime(
    IN  DWORD   ThreadSerialNumber,
    IN  PSTR    SourceFileName,
    IN  PSTR    DestFileName,
    IN  BOOL    bDstMustExistNow
    )
{
    HANDLE h;
    FILETIME ftSourceWriteTime;
    FILETIME dftDestWriteTime;
    FILETIME CreateTime, AccessTime;
    FILETIME dCreateTime, dAccessTime;

    WORD    srcDate, dstDate, srcTime, dstTime; // DOS versions.

    //
    // Open the source file.
    //
    h = CreateFile(
            SourceFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        mprintf ( ThreadSerialNumber, "ERROR CreateFile: %s, gle = %ld\n",
                                        SourceFileName, GetLastError() );
        return(FALSE);
    }

    GetFileTime(h,&CreateTime,&AccessTime,&ftSourceWriteTime);

    CloseHandle(h);

    FileTimeToDosDateTime ( &ftSourceWriteTime, &srcDate, &srcTime );


    //
    // Open the destination file.
    //
    h = CreateFile(
            DestFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {

        if ( bDstMustExistNow ) {
            //  In case we get something like, FILE_NOT_FOUND
            //
            mprintf ( ThreadSerialNumber,
                  "ERROR CreateFile: dst %s, gle = %ld\n",
                   DestFileName,GetLastError());
        }
        return(FALSE);
    }

    GetFileTime(h,&dCreateTime,&dAccessTime,&dftDestWriteTime);

    CloseHandle(h);

    FileTimeToDosDateTime ( &dftDestWriteTime, &dstDate, &dstTime );


    //  Compare that the DOS date and times are the same.
    //
    if ( (srcDate != dstDate) || (srcTime != dstTime) ) {

        if ( 1 /*bVerbose*/ ) {
            mprintf ( ThreadSerialNumber,
                    "Warning, times different:  %s = %x-%x, %s = %x-%x\n",
                    SourceFileName,
                    srcDate, srcTime,
                    DestFileName,
                    dstDate, dstTime );
        }
        return (FALSE);

    }

    return (TRUE);      // DOS dates and times are the same.

}

DWORD
WorkerThread(
    IN PVOID ThreadParameter
    )
{
    PSOURCEFILE SourceFile;
    DWORD ThreadSerialNumber;
    CHAR FullSourceName[2*MAX_PATH];
    CHAR FullTargetName[2*MAX_PATH];
    CHAR CompressedName[2*MAX_PATH];
    CHAR CmdLine[5*MAX_PATH];
    PCHAR p;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL b;
    DWORD d;
    int i;

    ThreadSerialNumber = PtrToUlong(ThreadParameter);

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(STARTUPINFO);

    while(1) {

        //
        // Pluck the next source file off the list.
        // If there is no next source file, we're done.
        //
        EnterCriticalSection(&SourceListCritSect);

        SourceFile = SourceFileList;
        if(!SourceFile) {
            LeaveCriticalSection(&SourceListCritSect);
            return(TRUE);
        }
        SourceFileList = SourceFile->Next;

        LeaveCriticalSection(&SourceListCritSect);

        //
        // Form the source file name.
        //
        lstrcpy(FullSourceName,SourceSpec);

        if(p = strrchr(FullSourceName,'\\')) {
            p++;
        } else {
            p = FullSourceName;
        }

        lstrcpy(p,SourceFile->FileData.cFileName);

        //
        // Form full target name.
        //
        lstrcpy(FullTargetName,TargetDirectory);
        i = lstrlen(FullTargetName);
        if(FullTargetName[i-1] != '\\') {
            FullTargetName[i] = '\\';
            FullTargetName[i+1] = 0;
        }

        lstrcat(FullTargetName,SourceFile->FileData.cFileName);

        DnpGenerateCompressedName(FullTargetName,CompressedName);

        //
        // If the update flag is set, check timestamps.
        // If this fails, assume the target file does not exist.
        //
        if ( !SameDosDateTime ( ThreadSerialNumber,
                                FullSourceName,
                                CompressedName, FALSE ) ) {


            //
            // Form the command line for the child process.
            //
            sprintf(CmdLine,"diamond /D CompressionType=LZX /D CompressionMemory=21 %s %s",FullSourceName,CompressedName);

            if ( 1 /*bVerbose*/ ) {
                mprintf(ThreadSerialNumber,
                    "Start %s ==> %s\n",FullSourceName,CompressedName);
            }

            //
            // Invoke the child process.
            //
            b = CreateProcess(
                    NULL,
                    CmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    DETACHED_PROCESS,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo
                    );

            if(b) {

                CloseHandle(ProcessInfo.hThread);

                //
                // Wait for the child process to terminate and get its
                // return code.
                //
                WaitForSingleObject(ProcessInfo.hProcess,INFINITE);
                b = GetExitCodeProcess(ProcessInfo.hProcess,&d);
                CloseHandle(ProcessInfo.hProcess);

                if(b) {

                    //
                    // 'd' value of 0 means success, we've compressed the
                    // file. Now, set the time stamp on the target file.
                    //
                    if(d) {

                        //  'd' not 0, error occurred.
                        //
                        mprintf(ThreadSerialNumber,"ERROR compressing %s to %s.\n",FullSourceName,CompressedName);
                    } else {



                        //  'd' is 0, we compressed the file, now time stamp.
                        //

                        //  First get the source time's stamp.
                        //
                        GetSetTimeStamp(
                                FullSourceName,
                                &SourceFile->FileData.ftCreationTime,
                                &SourceFile->FileData.ftLastAccessTime,
                                &SourceFile->FileData.ftLastWriteTime,
                                FALSE
                                );

                        //  Now, set the destination time's stamp.
                        //
                        GetSetTimeStamp(
                                CompressedName,
                                &SourceFile->FileData.ftCreationTime,
                                &SourceFile->FileData.ftLastAccessTime,
                                &SourceFile->FileData.ftLastWriteTime,
                                TRUE
                                );

                        //  Double check it is really set.
                        //
                        if ( SameDosDateTime ( ThreadSerialNumber,
                                               FullSourceName,
                                               CompressedName,
                                               TRUE ) ) {
                                if ( bVerbose ) {
                                mprintf(ThreadSerialNumber,"Compressed %s to %s.\n",FullSourceName,CompressedName);
                                }
                        } else {

                                mprintf(ThreadSerialNumber,"ERROR Compressed %s to %s - time stamps don't match.\n",FullSourceName,CompressedName);

                        }
                    }
                } else {
                    mprintf(ThreadSerialNumber,"ERROR Unable to get process \"%s\" termination code.\n",CmdLine);
                }
            } else {
                mprintf(ThreadSerialNumber,"ERROR Unable to invoke \"%s\".\n",CmdLine);
            }
        } else {

            if ( bVerbose ) {
                mprintf(ThreadSerialNumber,
                        "%s is up to date.\n",CompressedName);
            }
        }
    }
}

//  FileInBom
//      Returns TRUE if fileName is located in the BOM; FALSE otherwise.
//
BOOL    FileInBom ( char * fileName ) {

    int i;

    for ( i = 0; i < wRecords; ++i ) {

        if ( _stricmp(fileName, szFiles[i] ) == 0 ) {

            return(TRUE);
        }

    }

    return(FALSE);

}

//  AddSourceFile
//  returns FALSE if an error.
//  returns TRUE if no error occrred, but not necesarrily meaning a file
//  was added.
BOOL
AddSourceFile(
    IN PWIN32_FIND_DATA FindData
    )
{
    static PSOURCEFILE LastFile = NULL;
    PSOURCEFILE SourceFile;
    unsigned i;
    DWORD ExtensionLength;
    DWORD FileNameLength;
    INFCONTEXT InfContext;

    //  If we are doing BOM checking, make sure that this file is
    //  listed in the BOM.  If it is, continue on to the next checking.
    //  If it is NOT, just return.
    //
    if ( bBomChecking && !FileInBom(FindData->cFileName) ) {
        return(TRUE);
    }

    //
    // Make sure this file is not of a type that is
    // supposed to be excluded from the list of files
    // we care about.
    //
    FileNameLength = lstrlen(FindData->cFileName);
    for(i=0; i<ExcludeExtensionCount; i++) {

        ExtensionLength = lstrlen(ExcludeExtension[i]);

        if((FileNameLength > ExtensionLength)
        && !lstrcmpi(ExcludeExtension[i],FindData->cFileName+FileNameLength-ExtensionLength)) {
            return(TRUE);
        }
    }

    for(i=0; i<ExcludeFileFilterCount; i++) {
    	if ( SetupFindFirstLine(ExcludeFilterHandle[i],
                                "Files",
                                FindData->cFileName,
                                &InfContext )) {
            return(TRUE);
        }
    }

    SourceFile = MALLOC(sizeof(SOURCEFILE));
    if(!SourceFile) {
        printf("ERROR Insufficient memory.\n");
        return(FALSE);
    }

    SourceFile->FileData = *FindData;
    SourceFile->Next = NULL;

    if(LastFile) {
        LastFile->Next = SourceFile;
    } else {
        SourceFileList = SourceFile;
    }

    LastFile = SourceFile;

    SourceFileCount++;

    return(TRUE);
}



BOOL
FindSourceFiles(
    VOID
    )
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    printf("Building list of source files...\n");

    //
    // Build a list of source files.
    //
    FindHandle = FindFirstFile(SourceSpec,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        if(!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            if(!AddSourceFile(&FindData)) {
                FindClose(FindHandle);
                return(FALSE);
            }
        }

        while(FindNextFile(FindHandle,&FindData)) {

            if(!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                if(!AddSourceFile(&FindData)) {
                    FindClose(FindHandle);
                    return(FALSE);
                }
            }
        }

        FindClose(FindHandle);
    }

    if(!SourceFileCount) {
        printf("Warning:  No files found in:  %s.\n",SourceSpec);
    }

    return(SourceFileCount != 0);
}



VOID
DoIt(
    VOID
    )
{
    SYSTEM_INFO SystemInfo;
    PHANDLE ThreadHandles;
    DWORD i;
    DWORD ThreadId;

    //
    // Determine number of threads to use.
    // This is based on the number of processors.
    //
    if(!ThreadCount) {
        GetSystemInfo(&SystemInfo);
        ThreadCount = SystemInfo.dwNumberOfProcessors;
    }

    ThreadHandles = MALLOC(ThreadCount * sizeof(HANDLE));
    if(!ThreadHandles) {
        printf("ERROR Insufficient memory.\n");
        exit(1);
    }

    if ( bVerbose ) {
        if(ThreadCount == 1) {
            printf("Compressing %u files...\n",SourceFileCount);
        } else {
            printf("Compressing %u files (%u threads)...\n",SourceFileCount,ThreadCount);
        }
    }

    //
    // Initialize the source file list critical section.
    //
    InitializeCriticalSection(&SourceListCritSect);

    //
    // Create threads.
    //
    for(i=0; i<ThreadCount; i++) {

        ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)UlongToPtr(i),
                                0,
                                &ThreadId
                                );
    }

    //
    // Wait for the threads to terminate.
    //
    WaitForMultipleObjects(ThreadCount,ThreadHandles,TRUE,INFINITE);

    //
    // Clean up and exit.
    //
    for(i=0; i<ThreadCount; i++) {
        CloseHandle(ThreadHandles[i]);
    }

    FREE(ThreadHandles);
}

#define idALL   0
#define idX86   1
#define idMIPS  2
#define idALPHA 3
#define idPPC   4
#define FILE_SECTION_ALL   "[SourceDisksFiles]"
#define FILE_SECTION_X86   "[SourceDisksFiles.x86]"
#define FILE_SECTION_MIPS  "[SourceDisksFiles.mips]"
#define FILE_SECTION_ALPHA "[SourceDisksFiles.alpha]"
#define FILE_SECTION_PPC   "[SourceDisksFiles.ppc]"
#define FILE_SECTION_NOT_USED 0xFFFF

DWORD   dwInsideSection = FILE_SECTION_NOT_USED;

DWORD   FigureSection ( char * Line ) {

    logprintf ( "FigureSection on:  %s\n", Line );

    if ( strstr ( Line, FILE_SECTION_ALL )  ) {

        dwInsideSection = idALL;

    }
    else
    if ( strstr ( Line, FILE_SECTION_X86 ) ) {

        dwInsideSection = idX86;

    }
    else
    if ( strstr ( Line, FILE_SECTION_MIPS ) ) {

        dwInsideSection = idMIPS;

    }
    else
    if ( strstr ( Line, FILE_SECTION_ALPHA ) ) {

        dwInsideSection = idALPHA;

    }
    else
    if ( strstr ( Line, FILE_SECTION_PPC ) ) {

        dwInsideSection = idPPC;

    }
    else {

        dwInsideSection = FILE_SECTION_NOT_USED;
    }

    logprintf ( "dwInsideSection = %x\n", dwInsideSection );
    return(dwInsideSection);

}
char * SuckName ( const char * Line ) {

    static char   szSuckedName[MFL];

    DWORD   dwIndex = 0;


    //  The line is in the form:    @@:file = 1,2,3,4,5,6,7,8
    //

    //  Skip the first @.
    //
    if ( *Line == '@' ) {

        ++Line;
    }

    //  Skip the 2nd @, w, or s.
    //
    if ( *Line == '@' || *Line == 'w' || *Line == 's' ) {

        ++Line;
    }

    //  Skp the :.
    //
    if ( *Line == ':' ) {

        ++Line;
    }

    //  Copy the file name until a space is encountered.
    //
    while ( *Line != ' ' ) {

        szSuckedName[dwIndex] = *Line;
        szSuckedName[dwIndex+1] = '\0';

        ++Line;
        ++dwIndex;
    }

    return szSuckedName;
}

void LoadFiles ( const char * infFilePath, const char * infFile ) {

    FILE *  fHandle;
    char    Line[MFL];
    int     i;

    sprintf ( bomFileName, "%s%s", infFilePath, infFile );

    logprintf ( "bomFileName = %s\n", bomFileName );

    fHandle = fopen ( bomFileName, "rt" );

    if ( fHandle ) {

        dwInsideSection = FILE_SECTION_NOT_USED;

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            if ( Line[0] == '[' ) {

                //  We have a new section.
                //
                dwInsideSection = FigureSection ( Line );

                continue;
            }


            //  Reasons to ignore this line from further processing.
            //
            //

            //  File section not one we process.
            //
            if ( dwInsideSection == FILE_SECTION_NOT_USED ) {

                continue;
            }

            //  Line just contains a non-usefull short string.
            //
            i = strlen ( Line );
            if ( i < 4 ) {

                continue;
            }

            //  Line contains just a comment.
            //
            if ( Line[0] == ';' ) {

                continue;
            }


            switch ( dwInsideSection ) {

                case idALL   :
                case idX86   :
                case idMIPS  :
                case idALPHA :
                case idPPC   :

                        sprintf ( szFiles[wRecords], "%s", SuckName ( Line ) );

                        logprintf ( "file = %s\n", szFiles[wRecords] );

                        ++wRecords;

                        break;

                default :

                        //  Not inside any section we need files for compressing.
                        //
                        break;
            }

        }

        if ( ferror(fHandle) ) {

            mprintf ( 0, "FATAL ERROR: reading from:   %s\n", bomFileName );

        }

        fclose ( fHandle );
    }
    else {

        mprintf ( 0, "FATAL ERROR:  Can't fopen(%s)\n", bomFileName );

        bBomChecking = FALSE;

    }

}


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    //
    // Skip argv[0]
    //
    argc--;
    argv++;

    NulHandle = CreateFile(
                    "nul",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(NulHandle == INVALID_HANDLE_VALUE) {
        printf("ERROR Unable to open \\dev\\nul.\n");
        return(1);
    }

    InitializeCriticalSection(&ConsoleCritSect);

	strcpy ( logFileName, "dcomp.log" );	// default log filename.
    strcpy ( bomFileName, "bom.txt"   );    // default bom filename.

    if(ParseArguments(argc,argv)) {

        logFile = fopen ( logFileName, "a" );
        if ( logFile == NULL ) {
            printf ( "ERROR Couldn't open logFile.\n" );
            exit(1);
        }

        if ( bBomChecking ) {

            //  Load Layout.inx and cairo\Layout.cai, _media.inx doesn't contains files we
            //  need compressed, as of today.
            //

            LoadFiles ( infFilePath, "\\Layout.inx" );

            mprintf ( 0, "bom loaded records: %d\n", wRecords );
        }

        if(FindSourceFiles()) {
            DoIt();
        }
    } else {
        Usage();
    }

    CloseHandle(NulHandle);

    if ( logFile ) {
        fclose ( logFile );
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\checkhiv\checkhiv.c ===
/*

    5/06/99    AndrewR        Created.

*/

#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>

#if DBG

VOID
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else

#define ASSERT( exp )

#endif // DBG

void PrintUsage(void) {
    printf("retrieves information about a hive\n");
    printf("\n");
    printf("Usage: checkhiv -h HiveName -t TimeBomb -s Suite -p ProcCount -u Upgrade only\n");
    return;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}


BOOL
GetHiveData(
    IN  PCTSTR OriginalHiveName,
    OUT PDWORD SuiteMask,
    OUT PDWORD TimeBomb,
    OUT PDWORD ProcCount,
    OUT PBOOL  StepUp
    )
{

    TCHAR HiveTarget[MAX_PATH];
    TCHAR HiveName[MAX_PATH] = TEXT("xSETREG");
    TCHAR lpszSetupReg[MAX_PATH] = TEXT("xSETREG\\ControlSet001\\Services\\setupdd");
    TCHAR TargetPath[MAX_PATH];

    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    DWORD tmp,i;

    BOOL RetVal = FALSE;
    TCHAR Dbg[1000];

    ASSERT(OriginalHiveName && SuiteMask && TimeBomb && ProcCount && StepUp);
    *SuiteMask = 0;
    *TimeBomb = 0;
    *ProcCount = 0;
    *StepUp = FALSE;

    //
    // copy the hive locally since you can only have one open on a hive at a time
    //
    GetTempPath(MAX_PATH,TargetPath);
    GetTempFileName(TargetPath,TEXT("set"),0,HiveTarget);

    CopyFile(OriginalHiveName,HiveTarget,FALSE);
    SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    AdjustPrivilege((PWSTR)SE_RESTORE_NAME);


    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HiveName, HiveTarget );
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        wsprintf( Dbg, TEXT("Couldn't RegLoadKey, ec = %d\n"), rslt );
        OutputDebugString(Dbg);
#endif

        goto e1;
    }

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegOpenKey\n"));
#endif

        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegQueryValueEx\n"));
#endif

        goto e3;
    }

    *TimeBomb  = Buffer[0];
    *StepUp    = (BOOL)Buffer[1];
    *ProcCount = Buffer[2];
    *SuiteMask = Buffer[3];

    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

e1:
    if (GetFileAttributes(HiveTarget) != 0xFFFFFFFF) {
        SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(HiveTarget);
    }

    return(RetVal);

}




int _cdecl
main(
    int argc,
    char *argvA[]
    )
{
    PTSTR *argv;
    PTSTR HiveName = NULL;
    PTSTR TimeBombString = NULL;
    PTSTR SuiteString = NULL;
    PTSTR ProcCountString = NULL;
    PTSTR UpgradeOnlyString = NULL;

    TCHAR TempFile[MAX_PATH];
    PTSTR p;

    DWORD SuiteMask;
    DWORD TimeBomb;
    DWORD ProcCount;
    BOOL  Upgrade;

    DWORD Result = 0;

    DWORD ActualSuiteMask, ActualTimeBomb, ActualProcCount;
    BOOL ActualStepUp;

    // do commandline stuff
#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    //
    // parse args
    //
    while (--argc) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {

                case TEXT('h'):
                case TEXT('H'):
                    HiveName = argv[1];
                    goto Next;
                    break;
                case TEXT('p'):
                case TEXT('P'):
                    ProcCountString = argv[1];
                    goto Next;
                    break;
                case TEXT('s'):
                case TEXT('S'):
                    SuiteString = argv[1];
                    goto Next;
                    break;
                case TEXT('t'):
                case TEXT('T'):
                    TimeBombString = argv[1];
                    goto Next;
                    break;
                case TEXT('u'):
                case TEXT('U'):
                    UpgradeOnlyString = argv[1];
                    goto Next;
                    break;
                default:
                    PrintUsage();
                    return ERROR_INVALID_PARAMETER;
            }

        }

Next:
    ;
    }

    //
    // Validate parameters
    //
    if (!HiveName || (!ProcCountString && !SuiteString && !TimeBombString && !UpgradeOnlyString)) {
        printf("Invalid usage\n" );
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    GetFullPathName(HiveName,sizeof(TempFile)/sizeof(TCHAR),TempFile,&p);

    if (!FileExists(TempFile,NULL)) {
        printf("Could not find hive file %S\n", TempFile );
        PrintUsage();
        return ERROR_FILE_NOT_FOUND;
    }

    HiveName = TempFile;


    //
    // retrieve hive information
    //
    if (!GetHiveData(HiveName,
                     &ActualSuiteMask,
                     &ActualTimeBomb,
                     &ActualProcCount,
                     &ActualStepUp
                     )) {
        printf("Could not retrive information from hive\n" );
        return ERROR_INVALID_DATA;
    }

    //marrq result was init to 1, changed to 0
    Result = 0;

    if (UpgradeOnlyString) {
        Upgrade = !lstrcmpi(UpgradeOnlyString,L"TRUE");
        if (Upgrade != ActualStepUp) {
            printf("Upgrade only inconsistent --> hive says Upgrade = %s\n", ActualStepUp ? "TRUE" : "FALSE");
            Result = ERROR_INVALID_DATA;
        }
    }

    if (ProcCountString) {
        ProcCount = _ttoi(ProcCountString);
        if (ProcCount != ActualProcCount) {
            printf("Proc count inconsistent --> hive says Proc count = %d\n", ActualProcCount);
            Result = ERROR_INVALID_DATA;
        }
    }

    if (SuiteString) {
        SuiteMask = _ttoi(SuiteString);
        if (SuiteMask != ActualSuiteMask) {
            printf("Suite mask inconsistent --> hive says suite mask = %d\n", ActualSuiteMask);
            Result = ERROR_INVALID_DATA;
        }
    }

    if (TimeBombString) {
        TimeBomb = _ttoi(TimeBombString);
        //
        // convert to minutes
        //
        TimeBomb = TimeBomb * 60 * 24;
        if (TimeBomb != ActualTimeBomb) {
            printf("Time bomb inconsistent --> hive says Time bomb = %d days\n", (ActualTimeBomb / (60*24)));
            Result = ERROR_INVALID_DATA;
        }

    }

    //marrq this was checking for 1, changed to 0
    if (Result == 0) {
        printf("Hive is valid.\n");
    } else {
        printf("One or more inconsistencies detected in hive.\n");
    }

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\files\bak.c ===
//
//  06.05.95    Joe Holman      Created to copy the system files for
//                              the new shell and cairo releases.
//                              Currently, it only copies uncompressed system files.
//  06.16.95    Joe Holman      Allow debugging tools to be copied. Uses _media.inx
//  06.19.95    Joe Holman      Copy compressed version of file if specified in _layout.inx.
//  06.22.95    Joe Holman      Added bCairoSuckNameHack to pick up files from 
//                              the inf\cairo\_layout.cai file.
//  06.22.95    Joe Holman      Added the SRV_INF fix so that we will pick up the compressed
//                              Server Infs in a different location than the Workstation compressed
//  06.22.95    Joe Holman      For now, we won't use compressed Cairo files.  Will change in July.
//                              INFs (due to the collision of names and difference with cdrom.w|s).
//  06.28.95    Joe Holman      Won't make CHECKED Server.
//  07.07.95    Joe Holman      For Cairo, we need to also look at the _layout.cai and 
//                              _media.cai files 
//                              for additional files (superset) that goes into Cairo.
//  08.03.95    Joe Holman      Allow Cairo to have compressed files -> note, build team needs to 
//                              private 2 locations, one for Shell release and one for Cairo release,
//                              ie, \\x86fre\cdcomp$.
//  08.14.95    Joe Holman      Figure out if we copy the .dbg file for a particular file.
//  08.14.95    Joe Holman      Allow DBG files for Cairo.
//  08.23.95    Joe Holman      Add code to make tallying work with compressed/noncomp files and
//                              winn32 local source space needed.
//  10.13.95    Joe Holman      Get MAPISVC.INF and MDM*.INF from Workstation location.
//  10.25.95    Joe Holman      Put code in to use SetupDecompressOrCopyFile.
//  10.30.95    Joe Holman      Don't give errors for vmmreg32.dbg - this is a file given
//                              by Win95 guys.
//  11.02.95    Joe Holman      Allow multi-threaded support when SetupDecompressOrCopyFile 
//                              is fixed.
//                              Pickup all for PPC on Cairo.
//  11.17.95    Joe Holman      Check for upgrade size.
//  11.30.95    Joe Holman      compare current dosnet.inf and txtsetup.sif values and error
//                              if we go over.  Search for //code here.
//  12.04.95    Joe Holman      Use Layout.inx instead of _layout.inx.
//  03.11.96    Joe Holman      Don't give errors on MFC*.dbg if missing, since no .dbgs 
//                              provided.
//  04.05.96    Joe Holman      Add values for INETSRV and DRVLIB.NIC directories. Both of
//                              these get copied as local source.  Inetsrv is NEVER installed
//                              automatically (unless via an unattend file) and one card is
//                              small.  Thus, we will only add INETSRV and DRVLIB.NIC sizes
//                              to local source code below. 
//                              and one or two of drvlib.nic MAY get installed.
//  04.19.96    Joe Holman      Add code to NOT count *.ppd files in order to reduce
//                              minimum disk space required.
//  09.10.96    Joe Holman      Add code that supports setup's new disk space calculation.
//                              Basically, we just need to provide values for each cluster
//                              size stored in dosnet.inf.
//  10.17.96    Joe Holman      Comment out MIPS code, but leave in for P7.
//  12.06.96    Joe Holman      Backported MSKK's DBCS changes.
//  01.20.97    Joe Holman      Take out PPC.
//  05.15.97    Joe Holman      Grovels layout.inf on release shares rather than file chked-in.
//  xx.xx.xx    Joe Holman      Allow files not to worry about .dbgs for to be in a file.
//  xx.xx.xx    Joe Holman      Add code to check for 0 file size in layout.inf files.
//  xx.xx.xx    Joe Holman      Provide switch that flush bits to disk after copy, then does a DIFF.
//


#include <windows.h>

#include <setupapi.h>

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <ctype.h>

#define     MFL     256

CRITICAL_SECTION CriticalSection;

#define MAX_NUMBER_OF_FILES_IN_PRODUCT  3500        // # greater than # of files in product.
#define EIGHT_DOT_THREE                 8+1+3+1

struct  _tag {
    WORD    wNumFiles;
    BOOL    bCopyDbg    [MAX_NUMBER_OF_FILES_IN_PRODUCT];
    BOOL    bCopyComp   [MAX_NUMBER_OF_FILES_IN_PRODUCT];
    char    wcFilesArray[MAX_NUMBER_OF_FILES_IN_PRODUCT][EIGHT_DOT_THREE];
    char    wcSubPath   [MAX_NUMBER_OF_FILES_IN_PRODUCT][EIGHT_DOT_THREE]; // used for debugging files
    BOOL    bCountBytes [MAX_NUMBER_OF_FILES_IN_PRODUCT];

};

BOOL    bFourPtO = FALSE;
BOOL    bChecked = FALSE;

BOOL    bVerifyBits = FALSE;
BOOL    bGetSizeLater = TRUE;

struct _tag i386Workstation;
struct _tag AlphaWorkstation;
struct _tag i386Server;
struct _tag AlphaServer;

struct _tag X86Dbg;
struct _tag AlphaDbg;


BOOL    fX86Wrk, fX86Srv; 
BOOL    fAlphaWrk, fAlphaSrv;

#define WORKSTATION 0
#define SERVER      1

//
// Following are masks that correspond to the particular data in a DOS date
//

#define DOS_DATE_MASK_DAY    (WORD) 0x001f  // low  5 bits (1-31)
#define DOS_DATE_MASK_MONTH  (WORD) 0x01e0  // mid  4 bits (1-12)
#define DOS_DATE_MASK_YEAR   (WORD) 0xfe00  // high 7 bits (0-119)

//
// Following are masks that correspond to the particular data in a DOS time
//

#define DOS_TIME_MASK_SECONDS (WORD) 0x001f   // low  5 bits (0-29)
#define DOS_TIME_MASK_MINUTES (WORD) 0x07e0   // mid  6 bits (0-59)
#define DOS_TIME_MASK_HOURS   (WORD) 0xf800   // high 5 bits (0-23)

//
// Shift constants used for building/getting DOS dates and times
//

#define DOS_DATE_SHIFT_DAY   0
#define DOS_DATE_SHIFT_MONTH 5
#define DOS_DATE_SHIFT_YEAR  9

#define DOS_TIME_SHIFT_SECONDS  0
#define DOS_TIME_SHIFT_MINUTES  5
#define DOS_TIME_SHIFT_HOURS   11

//
// Macros to extract the data out of DOS dates and times.
//
// Note: Dos years are offsets from 1980.  Dos seconds have 2 second
//       granularity
//

#define GET_DOS_DATE_YEAR(wDate)     ( ( (wDate & DOS_DATE_MASK_YEAR) >>  \
                                               DOS_DATE_SHIFT_YEAR ) + \
                                       (WORD) 1980 )

#define GET_DOS_DATE_MONTH(wDate)    ( (wDate & DOS_DATE_MASK_MONTH) >> \
                                                DOS_DATE_SHIFT_MONTH )

#define GET_DOS_DATE_DAY(wDate)      ( wDate & DOS_DATE_MASK_DAY )

#define GET_DOS_TIME_HOURS(wTime)    ( (wTime & DOS_TIME_MASK_HOURS) >> \
                                                DOS_TIME_SHIFT_HOURS )

#define GET_DOS_TIME_MINUTES(wTime)  ( (wTime & DOS_TIME_MASK_MINUTES) >> \
                                                DOS_TIME_SHIFT_MINUTES )

#define GET_DOS_TIME_SECONDS(wTime)  ( (wTime & DOS_TIME_MASK_SECONDS) << 1 )

//  Paths loaded in from the command line.
//
char	szLogFile[MFL];
char	szWrkX86Src[MFL];
char	szWrkAlphaSrc[MFL];
char	szSrvX86Src[MFL];
char	szSrvAlphaSrc[MFL];
char	szCompX86Src[MFL];
char	szCompAlphaSrc[MFL];
char	szEnlistDrv[MFL];
char    szWorkDstDrv[MFL];
char    szServDstDrv[MFL];
char    szX86Dbg[MFL];
char    szAlphaDbg[MFL];
char    szX86DbgSource[MFL];
char    szAlphaDbgSource[MFL];

#define I386_DIR     "\\i386\\SYSTEM32"
#define ALPHA_DIR    "\\ALPHA\\SYSTEM32"
#define I386_DBG     "\\support\\debug\\i386\\symbols"
#define ALPHA_DBG    "\\support\\debug\\alpha\\symbols"
#define NETMON       "\\netmon"
#define I386_DIR_RAW "\\i386"
#define ALPHA_DIR_RAW "\\ALPHA"

#define I386_SRV_WINNT  "\\clients\\srvtools\\winnt\\i386"
#define ALPHA_SRV_WINNT "\\clients\\srvtools\\winnt\\alpha"

#define NUM_EXTS 8
char * cExtra[] = { "acm", "com", "cpl", "dll", "drv", "exe", "scr", "sys" };

#define idBase  0
#define idX86   1
#define idALPHA 3
#define idBaseDbg 5
#define idX86Dbg 6


//	Tally up the # of bytes required for the system from the files included.
//

struct _ClusterSizes {

	DWORD	Kh1;
	DWORD	K1;
	DWORD	K2;
	DWORD	K4;
	DWORD	K8;
	DWORD	K16;
	DWORD	K32;
	DWORD	K64;
	DWORD	K128;
    DWORD   K256;

};
struct _ClusterSizes  lX86Work;
struct _ClusterSizes  lX86Serv;
struct _ClusterSizes  lAlphaWork;
struct _ClusterSizes  lAlphaServ;

DWORD   bytesX86Work, bytesX86Serv; 
DWORD   bytesAlphaWork, bytesAlphaServ;


//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


#define LAYOUT_INX  "\\nt\\private\\windows\\setup\\inf\\win4\\inf\\layout.inx"
#define MEDIA_INX   "\\nt\\private\\windows\\setup\\inf\\win4\\inf\\_media.inx" 


FILE* logFile;

void	GiveThreadId ( const CHAR * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void	Msg ( const CHAR * szFormat, ... ) {

	va_list vaArgs;

    EnterCriticalSection ( &CriticalSection );
    GiveThreadId ( "%ld:  ", GetCurrentThreadId () );
	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
    LeaveCriticalSection ( &CriticalSection );
}


void Header(argv,argc)
char * argv[];
int argc;
{
    time_t t;
    char tmpTime[100];
    CHAR wtmpTime[200];

    Msg ( "\n=========== FILES ====================\n" );
	Msg ( "Log file                      : %s\n",    szLogFile );
    Msg ( "x86 work Uncompressed files   : %s\n",    szWrkX86Src);
    Msg ( "alpha work Uncompressed files : %s\n",    szWrkAlphaSrc);
    Msg ( "x86 Serv Uncompressed files   : %s\n",    szSrvX86Src);
    Msg ( "alpha Serv Uncompressed files : %s\n",    szSrvAlphaSrc);
    Msg ( "x86 Compressed files          : %s\n",    szCompX86Src);
    Msg ( "alpha Compressed files        : %s\n",    szCompAlphaSrc);
    Msg ( "x86 dbg files                 : %s\n",    szX86Dbg);
    Msg ( "alpha dbg files               : %s\n",    szAlphaDbg);
    Msg ( "x86 dbg source                : %s\n",    szX86DbgSource);
    Msg ( "alpha dbg source              : %s\n",    szAlphaDbgSource);
    Msg ( "enlisted drive                : %s\n",    szEnlistDrv );
    Msg ( "drive to put workstation files: %s\n",    szWorkDstDrv ); 
    Msg ( "drive to put server files     : %s\n",    szServDstDrv );

    time(&t); 
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "========================================\n\n");
}

void Usage()
{
    printf( "PURPOSE: Copies the system files that compose the product.\n");
    printf( "\n");
    printf( "PARAMETERS:\n");
    printf( "\n");
    printf( "[LogFile] - Path to append a log of actions and errors.\n");
	printf( "[files share] - location of work x86 uncompressed files.\n" );
	printf( "[files share] - location of work alpha uncompressed files.\n" );
	printf( "[files share] - location of serv x86 uncompressed files.\n" );
	printf( "[files share] - location of serv alpha uncompressed files.\n" );
	printf( "[files share] - location of x86 Compressed files.\n" );
	printf( "[files share] - location of alpha Compressed files.\n" );
	printf( "[files share] - location of x86 dbg files.\n" );
	printf( "[files share] - location of alpha dbg files.\n" );
	printf( "[files share] - location of x86 dbg source files.\n" );
	printf( "[files share] - location of alpha dbg source files.\n" );
    printf( "[enlisted drive]- drive that is enlisted\n" );
    printf( "[dest path workstation]   - drive to put files\n" );
    printf( "[dest path server]   - drive to put files\n" );
    printf( "\n"  );
}

char   dbgStr1[30];
char   dbgStr2[30];

BOOL    IsFileInSpecialWinnt32Directory ( char * szFileName ) {

    char szUpCasedName[MFL];
    int i;

    char * foo[] = {
            "WINNT32.EXE",
            "WINNT32A.DLL",
            "WINNT32U.DLL",
            "WINNT32.HLP",
            (char *) 0 
            };

    strcpy ( szUpCasedName, szFileName );
    _strupr ( szUpCasedName );

    for ( i=0; foo[i] != 0; i++ ) {

        Msg ( "Comparing:  %s vs. %s\n", szUpCasedName, foo[i] );

        if ( strstr ( szUpCasedName, foo[i] ) ) {
            return TRUE;       // file should be in this directory 
        }

    }

    return FALSE;           // no, file doesn't go in the winnt32 directory 
}

BOOL    IsDebugFileToNotWorryAbout ( char * szFileName ) {

    char szUpCasedName[MFL];

    int i;
    char * foo[] = {
            "WEX",
            "CABINET.DBG",
            "IEDKCS32.DBG",
            "INETCFG.DBG",
            "INETWIZ.DBG",
            "CLASSR.DBG",
            "ICFGNT.DBG",
            "MSENCODE.DBG",
            "MSCONV97.DBG",
            "MSAWT",
            "JVIEW", 
            "JDBGMGR",
            "JAVA",
            "ISIGN",
            "MSAPS",
            "ICW",
            "JAVA",
            "HLINK",
            "JSCRIPT.DBG",
            "MSAD",
            "MSDA",
            "VBSCRIPT.DBG",
            "VSREVOKE.DBG",
            "WSOCK32N.DBG",
            "DIGIINST.DBG",
            "ICCVID.DBG",
            "IR32_32.DBG",
            "VMHELPER.DBG",
            "MSJAVA",
            "VMMREG32.DBG",
            "SCRRUN.DBG",
            "MFC",
            "OLEPRO32.DBG",
            "MSJT3032.DBG",
            "ODBCJT32.DBG",
            "MSVCIRT.DBG",
            "MSVCRT40.dbg",
            "MSVCRT20.dbg", 
            "JIT.DBG",
            "MSVC",         
            (char *) 0 
            };

    strcpy ( szUpCasedName, szFileName );
    _strupr ( szUpCasedName );

    for ( i=0; foo[i] != 0; i++ ) {

        Msg ( "IsDebug Comparing:  %s vs. %s\n", szUpCasedName, foo[i] );

        if ( strstr ( szUpCasedName, foo[i] ) ) {
            return TRUE;        // don't worry if this file is missing
        }

    }

    return FALSE;           // worry about this one, we need it!
}

void  ShowMeDosDateTime ( CHAR * srcPath, WORD wDateSrc, WORD wTimeSrc, 
                          CHAR * dstPath, WORD wDateDst, WORD wTimeDst ) {

    Msg ( "%s %02d.%02d.%02d %02d:%02d.%02d\n", 
                srcPath,
                GET_DOS_DATE_MONTH(wDateSrc),
                GET_DOS_DATE_DAY(wDateSrc),
                GET_DOS_DATE_YEAR(wDateSrc),
                GET_DOS_TIME_HOURS(wTimeSrc),
                GET_DOS_TIME_MINUTES(wTimeSrc),
                GET_DOS_TIME_SECONDS(wTimeSrc)  );

    Msg ( "%s %02d.%02d.%02d %02d:%02d.%02d\n", 
                dstPath,
                GET_DOS_DATE_MONTH(wDateDst),
                GET_DOS_DATE_DAY(wDateDst),
                GET_DOS_DATE_YEAR(wDateDst),
                GET_DOS_TIME_HOURS(wTimeDst),
                GET_DOS_TIME_MINUTES(wTimeDst),
                GET_DOS_TIME_SECONDS(wTimeSrc)  );
}


void Replay ( char * srcBuf, char * dstBuf, DWORD srcBytesRead, DWORD startIndex ) {

    DWORD i;

    for ( i = startIndex; (i < startIndex+5) && (i <= srcBytesRead); ++i ) {

        Msg ( "srcBuf[%ld] = %x, dstBuf[%ld] = %x\n", i, srcBuf[i], i, dstBuf[i] );
    }

}

BOOL    IsDstCompressed ( char * szPath ) {

    // Msg ( ">>> char %s: %c\n", szPath, szPath[strlen(szPath)-1] );

    if ( szPath[strlen(szPath)-1] == '_' ) {

        return(TRUE);
    }

    return (FALSE);

}


#define V_WRK_I386  "C:\\wrk\\i386"
#define V_WRK_ALPHA "C:\\wrk\\alpha"
#define V_SRV_I386  "C:\\srv\\i386"
#define V_SRV_ALPHA "C:\\srv\\alpha"

BOOL    MyCopyFile ( char * fileSrcPath, char * fileDstPath ) {

    HANDLE          hSrc,   hDst;
    WIN32_FIND_DATA wfdSrc, wfdDst;
    BOOL            bDoCopy = FALSE;
    #define     NUM_BYTES_TO_READ 2048
    unsigned char srcBuf[NUM_BYTES_TO_READ];
    unsigned char dstBuf[NUM_BYTES_TO_READ];
    WORD srcDate, srcTime, dstDate, dstTime;

    char szTmpFile[MFL] = { '\0' };
    UINT uiRetSize = 299;
    char szJustFileName[MFL];
    char szJustDirectoryName[MFL];

    //  Find the source file.
    //
    hSrc = FindFirstFile ( fileSrcPath, &wfdSrc );

    if ( hSrc == INVALID_HANDLE_VALUE ) {

        //  HACK:   Since the release shares put WINNT32.EXE in the WINNT32 directory
        //          instead of leaving it in the flat root, verify that if the fileSrcPath
        //          contains WINNT32.EXE we look in the WINNT32 dir also before error'ing out.
        //
        if ( IsFileInSpecialWinnt32Directory ( fileSrcPath ) ) {

             char    tmpSrcPath[MFL];

             strcpy ( tmpSrcPath, fileSrcPath );

             if ( strstr ( fileSrcPath, ".HLP" ) ||
                  strstr ( fileSrcPath, ".hlp" )    ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
             }
            else if ( strstr ( fileSrcPath, "a.dll" ) ||
                      strstr ( fileSrcPath, "A.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
            }
            else if ( strstr ( fileSrcPath, "u.dll" ) ||
                      strstr ( fileSrcPath, "U.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
            }
             else {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
             }

            hSrc = FindFirstFile ( tmpSrcPath, &wfdSrc );

            if ( hSrc == INVALID_HANDLE_VALUE ) {

                Msg ( "ERROR on fileSrcPath(tmpSrcPath) = %s, gle = %ld\n", tmpSrcPath, GetLastError() );
                return (FALSE);

            }
            else {

                strcpy ( fileSrcPath, tmpSrcPath );
            }

        }
        else if ( IsDebugFileToNotWorryAbout ( fileSrcPath ) ) {

            //  The following files do NOT have dbg files
            //  available for them because they are provided by 3rd parties or other group.
            //  So, don't report an error when we can't find them.
            //

            Msg ( "Warning:  %s not copied over.\n", fileSrcPath );
            return (FALSE);

        }
        else {

            Msg ( "ERROR on fileSrcPath = %s, gle = %ld\n", fileSrcPath, GetLastError() );
            return (FALSE);
        }
    }

    //  Find the destination file.
    //
    hDst = FindFirstFile ( fileDstPath, &wfdDst );

    if ( hDst == INVALID_HANDLE_VALUE ) {

        DWORD   gle;

        gle = GetLastError();
        
        if ( gle == ERROR_FILE_NOT_FOUND ) {

            //  The file doesn't exist on the destination.  Do the copy.
            //
            bDoCopy = TRUE;
        }
        else {

            //  Got another kind of error, report this problem.
            //
            Msg ( "ERROR FindFirstFile fileDstPath = %s, gle = %ld\n", fileDstPath, gle );
            FindClose ( hSrc );
            return ( FALSE );
        } 
    }
    else {

        BOOL    b;


        //  Both the src and dst exist.
        //  Let's see if the src is NEWER than the dst, if so, copy.
        //
        //
        b = FileTimeToDosDateTime ( &wfdSrc.ftLastWriteTime, &srcDate, &srcTime );

        b = FileTimeToDosDateTime ( &wfdDst.ftLastWriteTime, &dstDate, &dstTime );

        if ( (srcDate != dstDate) || (srcTime != dstTime) ) {

            ShowMeDosDateTime ( fileSrcPath, srcDate, srcTime, fileDstPath, dstDate, dstTime );

            bDoCopy = TRUE; 
        }
    } 

    //  Additional check, verify the file sizes are the same.
    //
    if ( wfdSrc.nFileSizeLow != wfdSrc.nFileSizeLow ) {
        bDoCopy = TRUE;
    }
    if ( wfdSrc.nFileSizeHigh != wfdDst.nFileSizeHigh ) {
        bDoCopy = TRUE;
    }
    

    if ( bDoCopy ) {

        BOOL    b;
        DWORD   gle;
        DWORD   dwAttributes = GetFileAttributes ( fileDstPath );


        //  Check the attributes of the file.
        //
        if ( dwAttributes == 0xFFFFFFFF ) {

            //  Ignore file not found on non-existant destination, but error on
            //  anything else.
            //
            gle = GetLastError();
            if ( gle != ERROR_FILE_NOT_FOUND ) {

                Msg ( "ERROR:  GetFileAttributes:  gle = %ld, %s\n", gle, fileDstPath);
            }
        }
        else { 

            //  No error for GetFileAttributes.
            //  Check the attribute for R-only, and change if set.
            //
            if ( dwAttributes & FILE_ATTRIBUTE_READONLY || 
                 dwAttributes & FILE_ATTRIBUTE_HIDDEN       ) {

                b = SetFileAttributes ( fileDstPath, FILE_ATTRIBUTE_NORMAL );

                if ( !b ) {

                    Msg ( "ERROR: SetFileAttributes: gle = %ld, %s\n", GetLastError(), fileDstPath);
                }
            } 
        }
             
            
        

        b = CopyFile ( fileSrcPath, fileDstPath, FALSE );

        if ( b ) {

            Msg ( "Copy:  %s >>> %s  [OK]\n", fileSrcPath, fileDstPath );
        }
        else {
            Msg ( "ERROR Copy:  %s >>> %s, gle = %ld\n", fileSrcPath, fileDstPath, GetLastError() );
        }

        
    }
    else {
        Msg ( "%s %d %d %ld %ld +++ %s %d %d %ld %ld [SAME]\n", fileSrcPath, srcDate, srcTime, wfdSrc.nFileSizeLow, wfdSrc.nFileSizeHigh, fileDstPath , dstDate, dstTime, wfdDst.nFileSizeLow, wfdDst.nFileSizeHigh );
    }

    FindClose ( hSrc );
    FindClose ( hDst );



    //  Do bit verification here on all files coming into MyCopyFile.
    //
    if ( bVerifyBits ) {

        BOOL    bNoError = TRUE;
        HANDLE  SrcFileHandle, DstFileHandle;
        BOOL    b;
        BY_HANDLE_FILE_INFORMATION  srcFileInformation;
        BY_HANDLE_FILE_INFORMATION  dstFileInformation;
        DWORD   srcBytesRead;
        DWORD   dstBytesRead;
        DWORD   i;
        DWORD   totalBytesRead = 0;
#define OFFSET_FILENAME 0x3C    // address of file name in diamond header. 
                                // >>> use struct later instead of this hack.
#define OFFSET_PAST_FILENAME  8 + 1 + 3 + 2     // we only use 8.3 filenames.
        char    unCompressedFileName[OFFSET_PAST_FILENAME];

        BOOL    bIsDstCompressed = FALSE;
        DWORD   dw;
        char    szExpandToDir[MFL];
        char    target[MFL];
        int     iRc;
        unsigned short unicodeFileLocation[MFL];
        unsigned short unicodeTargetLocation[MFL];

        bIsDstCompressed = IsDstCompressed ( fileDstPath );

        if ( bIsDstCompressed ) {

            FILE * fHandle;
            char    szEndingFileName[MFL];

            //  Figure out where source should be from.
            //  Ie., we need to figure out the uncompressed path from the compressed path.
            //

            if ( fileDstPath[0] == szWorkDstDrv[0]  ) {

                //  We are working with Workstation binaries.
                // 

                if ( strstr ( fileSrcPath, szCompX86Src ) ) {

                    strcpy ( fileSrcPath, szWrkX86Src );  
                    strcpy ( szExpandToDir, V_WRK_I386 );
                
                } 
                else if ( strstr ( fileSrcPath, szCompAlphaSrc ) ) {

                    strcpy ( fileSrcPath, szWrkAlphaSrc );
                    strcpy ( szExpandToDir, V_WRK_ALPHA );
                }
                else {

                    Msg ( "ERROR:  couldn't determined location for:  %s\n", fileSrcPath );
                    bNoError = FALSE;
                }

            }
            else if ( fileDstPath[0] == szServDstDrv[0]  ) {

                //  We are working with Workstation binaries.
                // 

                if ( strstr ( fileSrcPath, szCompX86Src ) ) {

                    strcpy ( fileSrcPath, szSrvX86Src );  
                    strcpy ( szExpandToDir, V_SRV_I386 );
                
                } 
                else if ( strstr ( fileSrcPath, szCompAlphaSrc ) ) {

                    strcpy ( fileSrcPath, szSrvAlphaSrc );
                    strcpy ( szExpandToDir, V_SRV_ALPHA );
                }
                else {

                    Msg ( "ERROR:  couldn't determined Server location for:  %s\n", fileSrcPath );
                    bNoError = FALSE;
                    goto cleanup0;
                }

            }
            else {
                Msg ( "ERROR:  couldn't determined wks/srv drive for:  %s\n", fileDstPath );
                    bNoError = FALSE;
                    goto cleanup0;
            }
            

            //  NOTE:   At this point, fileSrcPath ONLY has a path, it now has NO filename !
            //


            // Find the expanded file name from the compressed file.
            //

            fHandle = fopen ( fileDstPath, "rb" );
            if ( fHandle == NULL) {
		        Msg ( "ERROR Couldn't open file with fopen to find expanded name: %s\n", fileDstPath );
                bNoError = FALSE;
                goto cleanup0;
            }
            else {

                size_t bytesRead;
                int     location;

                location = fseek ( fHandle, OFFSET_FILENAME, SEEK_SET );

                if ( location != 0 ) {

                    Msg ( "fseek ERROR\n" );
                    bNoError = FALSE;
                    fclose ( fHandle );
                    goto cleanup0;
                }

                bytesRead = fread ( unCompressedFileName, 1, OFFSET_PAST_FILENAME, fHandle ); 

/***
for ( i = 0; i < bytesRead; ++i ) {
    printf ( "%X(%c) ", buffer[i], buffer[i] );
}
printf ( "\n" );
***/

                if ( bytesRead != OFFSET_PAST_FILENAME ) {

                    Msg ( "ERROR: bytesRead = %x not %x\n", bytesRead, OFFSET_PAST_FILENAME );  
                    bNoError = FALSE;
                    fclose ( fHandle );
                    goto cleanup0;
                }

                fclose ( fHandle );

            }

            //  Expand the file.
            //

            sprintf ( target, "%s\\%s", szExpandToDir, unCompressedFileName );

            iRc = MultiByteToWideChar (   CP_ACP,
                                    MB_PRECOMPOSED,
                                    fileDstPath,
                                    strlen ( fileDstPath )+1,
                                    unicodeFileLocation,
                                    MFL/2 ); 

            if ( !iRc ) {

                Msg ( "MultiByteToWideChar: ERROR, gle = %ld, %s\n", GetLastError(), fileDstPath );
            }

            iRc = MultiByteToWideChar (   CP_ACP,
                                    MB_PRECOMPOSED,
                                    target,
                                    strlen ( target )+1,
                                    unicodeTargetLocation,
                                    MFL/2 ); 
            if ( !iRc ) {

                Msg ( "MultiByteToWideChar: ERROR, gle = %ld, %s\n", GetLastError(), target );
            }

            dw = SetupDecompressOrCopyFileW (   
                                    unicodeFileLocation,
                                    unicodeTargetLocation,
                                    NULL );

            if ( dw ) {

                Msg ( "ERROR SetupDecompressOrCopyFile, dw = %d, fileDstPath=%s, target=%s\n", 
                        dw, fileDstPath, target );
                bNoError = FALSE;
                goto cleanup0;
            }
            else {
                Msg ( "SetupDecompressOrCopyFile:  %s >> %s  [OK]\n", fileDstPath, target );
            }


            //  Put the Source and Destination paths and filenames back together
            //  now so we can do the file compare.
            //

            strcat ( fileSrcPath, "\\" );
            strcat ( fileSrcPath, unCompressedFileName );

            sprintf ( fileDstPath, "%s\\%s", szExpandToDir, unCompressedFileName );


        }

        SrcFileHandle = CreateFile ( fileSrcPath,
                        GENERIC_READ /*| FILE_EXECUTE*/,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,  
                        NULL);

        if ( SrcFileHandle == INVALID_HANDLE_VALUE) {

            Msg ( "ERROR verify:  Couldn't open source:  %s, gle = %ld\n", fileSrcPath, GetLastError() );
            bNoError = FALSE;
            goto cleanup0;
        }

        DstFileHandle = CreateFile ( fileDstPath,
                        GENERIC_READ /*| FILE_EXECUTE*/,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,  
                        NULL);

        if ( DstFileHandle == INVALID_HANDLE_VALUE) {

            Msg ( "ERROR verify:  Couldn't open destination:  %s, gle = %ld\n", fileDstPath, GetLastError() );
            bNoError = FALSE;
            CloseHandle ( SrcFileHandle );
            goto cleanup0;
        }

        //GetDiskFreeSpace();  // get sector size.  // need to use this sector size in reads due to above NO_BUFFERING flag.



        b = GetFileInformationByHandle ( SrcFileHandle, &srcFileInformation ); 

        if ( !b ) {

            Msg ( "ERROR:  GetFileInformationByHandle on src, gle = %ld\n", GetLastError() );
            bNoError = FALSE;
            srcFileInformation.nFileSizeLow = 0;
            goto cleanup1;
        }


        b = GetFileInformationByHandle ( DstFileHandle, &dstFileInformation ); 

        if ( !b ) {

            Msg ( "ERROR:  GetFileInformationByHandle on dst, gle = %ld\n", GetLastError() );
            bNoError = FALSE;
            dstFileInformation.nFileSizeLow = 0;
            goto cleanup1;
        }


        //  Make sure the files are the same size.
        //

        if ( srcFileInformation.nFileSizeLow != dstFileInformation.nFileSizeLow ) {

            Msg ( "ERROR:  file size different:  %s %ld  %s %ld\n", fileSrcPath, srcFileInformation.nFileSizeLow, fileDstPath, dstFileInformation.nFileSizeLow ); 
            bNoError = FALSE;
            goto cleanup1;
        }

        //  Compare the bits.
        //

        totalBytesRead = 0;            
        while ( 1 ) {

            b = ReadFile ( SrcFileHandle, &srcBuf, NUM_BYTES_TO_READ, &srcBytesRead, NULL );

            if ( !b ) {

                Msg ( "ERROR:  ReadFile src, gle = %ld\n", GetLastError() ); 
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            b = ReadFile ( DstFileHandle, &dstBuf, NUM_BYTES_TO_READ, &dstBytesRead, NULL );

            if ( !b ) {

                Msg ( "ERROR:  ReadFile dst, gle = %ld\n", GetLastError() ); 
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            //  Read # of bytes need to be the same.
            //
            if ( srcBytesRead != dstBytesRead ) {

                Msg ( "ERROR:  file read sizes different:  %ld vs. %ld\n", srcBytesRead, dstBytesRead ); 
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            //  Successfully read to end of file, we can break out now.
            //
            if ( srcBytesRead == 0 || dstBytesRead == 0 ) {

                if ( totalBytesRead != srcFileInformation.nFileSizeLow ) {

                    Msg ( "ERROR:   totalBytesRead = %ld notequal srcFileInformation.nFileSizeLow = %ld\n",
                                    totalBytesRead, srcFileInformation.nFileSizeLow );
                    bNoError = FALSE;
                    goto cleanup1;
                }

                break;
            }

            totalBytesRead += srcBytesRead;

            for ( i = 0; i < srcBytesRead; ++i ) {

                if ( srcBuf[i] != dstBuf[i] ) {

                    Msg ( "ERROR:  srcBuf %d != dstBuf %d, i = %ld  srcBytesRead = %ld   totalBytesRead = %ld  %s %s \n", srcBuf[i], dstBuf[i], i, srcBytesRead, totalBytesRead, fileSrcPath, fileDstPath );
                    bNoError = FALSE;
                    Replay ( srcBuf, dstBuf, srcBytesRead, i );
                    goto cleanup1;
                }

            }

            //Msg ( "%s %ld of %ld examined...\n", fileSrcPath, totalBytesRead, srcFileInformation.nFileSizeLow );

        }


        //  Close the file handles.
        //

cleanup1:;
        CloseHandle ( SrcFileHandle );
        CloseHandle ( DstFileHandle );

        Msg ( "Verify:  %s >>> %s [OK]\n", fileSrcPath, fileDstPath );

cleanup0:;

        //  If the file is compressed, ie. expanded, and the there wasn't an error 
        //  comparing, get rid of the expanded file so it doesn't take up any space.
        //  But, if there was an error, leave it around for examination purposes.
        //
        if ( bIsDstCompressed && bNoError ) {

            char szDeleteFile[MFL];
            BOOL    b;

            sprintf ( szDeleteFile, "%s\\%s", szExpandToDir, unCompressedFileName ); 
            b = DeleteFile ( szDeleteFile );

            if ( !b ) {
                Msg ( "ERROR:  DeleteFile FAILED %s, gle = %ld\n", szDeleteFile, GetLastError() );
            }

        }

    }


    return (TRUE);
}



#define FILE_SECTION_BASE  "[SourceDisksFiles]"
#define FILE_SECTION_X86   "[SourceDisksFiles.x86]"
#define FILE_SECTION_ALPHA "[SourceDisksFiles.alpha]"

#define FILE_SECTION_DBG_BASE "[DbgFiles]"
#define FILE_SECTION_DBG_X86  "[DbgFiles.x86]"


BOOL    CreateDir ( char * wcPath, BOOL bMakeDbgDirs ) {

    BOOL    b;
    char    cPath[MFL];
    char    cPath2[MFL];
    int     iIndex = 0;
    char * ptr=wcPath;

    // Msg ( "CreateDir:  wcPath = %s, bMakeDbgDirs = %d\n", wcPath, bMakeDbgDirs );

    do { 

        cPath[iIndex]   = *wcPath;
        cPath[iIndex+1] = '\0';

        //Msg ( "cPath = %s\n", cPath );

        if ( cPath[iIndex] == '\\' || cPath[iIndex] == '\0' ) {

            if ( iIndex <= 2 ) {
                //Msg ( "skpdrv:  iIndex = %d\n", iIndex );
                goto skipdrv;
            }

            strcpy ( cPath2, cPath );
            cPath2[iIndex] = '\0';

            //Msg ( "Create with: >>>%s<<<\n", cPath2 );

            b = CreateDirectory ( cPath, NULL );

            if ( !b ) {

                DWORD dwGle;

                dwGle = GetLastError();

                if ( dwGle != ERROR_ALREADY_EXISTS ) { 
                    Msg ( "ERROR CreateDirectory gle = %ld, wcPath = %s\n", dwGle, ptr ); 
                    return(FALSE);
                }
            }
            else {

                Msg ( "Made dir:  %s\n", cPath );
            }

            if ( cPath[iIndex] == '\0' ) {
                break;
            }
        }

skipdrv:;
        ++iIndex;
        ++wcPath;
        

    } while ( 1 );

    if ( bMakeDbgDirs ) {

        int i;
        
        for ( i = 0; i < NUM_EXTS; ++i ) {

            sprintf ( cPath2, "%s\\%s", cPath, cExtra[i] );
            // Msg ( "bMakeDbgDirs to:  %s\n", cPath2 );

            b = CreateDirectory ( cPath2, NULL );

            if ( !b ) {

                DWORD dwGle;

                dwGle = GetLastError();

                if ( dwGle != ERROR_ALREADY_EXISTS ) { 
                    Msg ( "ERROR CreateDirectory gle = %ld, cPath = %s\n", dwGle, cPath ); 
                    return(FALSE);
                }
            }
            else {

                Msg ( "Made dir:  %s\n", cPath );
            }

        }
    }

    return(TRUE);

}

BOOL    CreateDestinationDirs ( void ) {


    CHAR   dstDirectory[MFL];


    //  Create the directories to compare the bits, used later in MyCopyFile().
    //
    CreateDir ( V_WRK_I386, FALSE );
    CreateDir ( V_WRK_ALPHA, FALSE );
    CreateDir ( V_SRV_I386, FALSE );
    CreateDir ( V_SRV_ALPHA, FALSE );
     
    
    //  Create the Workstation %platform%\system32 directories.
    //
    sprintf ( dstDirectory, "%s%s", szWorkDstDrv, I386_DIR );    CreateDir ( dstDirectory,FALSE );
    sprintf ( dstDirectory, "%s%s", szWorkDstDrv, ALPHA_DIR );   CreateDir ( dstDirectory,FALSE );

    //  Create the Workstation \support\debug\%platform%\symbols\%ext% directories. 
    //
    sprintf ( dstDirectory, "%s%s", szWorkDstDrv, I386_DBG );    CreateDir ( dstDirectory,TRUE );
    sprintf ( dstDirectory, "%s%s", szWorkDstDrv, ALPHA_DBG );   CreateDir ( dstDirectory,TRUE );

    //  Create the Server %platform% directories.
    //
    sprintf ( dstDirectory, "%s%s", szServDstDrv, I386_DIR );    CreateDir ( dstDirectory,FALSE );
    sprintf ( dstDirectory, "%s%s", szServDstDrv, ALPHA_DIR );   CreateDir ( dstDirectory,FALSE );

    //  Create the Server \support\debug\%platform%\symbols\%ext% directories. 
    //
    sprintf ( dstDirectory, "%s%s", szServDstDrv, I386_DBG );    CreateDir ( dstDirectory,TRUE );
    sprintf ( dstDirectory, "%s%s", szServDstDrv, ALPHA_DBG );   CreateDir ( dstDirectory,TRUE );

    //  Create the Server %platform%\netmon directories - this is ONLY required on Server.
    //
    sprintf ( dstDirectory, "%s%s%s", szServDstDrv, I386_DIR_RAW, NETMON );    CreateDir ( dstDirectory,FALSE );
    sprintf ( dstDirectory, "%s%s%s", szServDstDrv, ALPHA_DIR_RAW, NETMON );   CreateDir ( dstDirectory,FALSE );

    //  Create the Server \clients\srvtools\winnt\%platform% directories.
    //
    sprintf ( dstDirectory, "%s%s", szServDstDrv, I386_SRV_WINNT );    CreateDir ( dstDirectory,FALSE );
    sprintf ( dstDirectory, "%s%s", szServDstDrv, ALPHA_SRV_WINNT );   CreateDir ( dstDirectory,FALSE );

    return(TRUE);

}

DWORD   CopyDbgFiles ( void ) {

    char    fileSrcPath[MFL];
    char    fileDstPath[MFL];
    DWORD   i;

    for ( i = 0; i < X86Dbg.wNumFiles; ++i ) {

        sprintf ( fileSrcPath, "%s\\%s\\%s",                    szX86Dbg,     
                                                                X86Dbg.wcSubPath[i],
                                                                X86Dbg.wcFilesArray[i] );
        sprintf ( fileDstPath, "%s\\support\\debug\\i386\\%s",  szWorkDstDrv, 
                                                                X86Dbg.wcFilesArray[i] );

        MyCopyFile ( fileSrcPath, fileDstPath );

        if ( bChecked ) {
            //  Don't make a Serv checked build.
            continue;
        }
        sprintf ( fileDstPath, "%s\\support\\debug\\i386\\%s",  szServDstDrv, 
                                                                X86Dbg.wcFilesArray[i] );

        MyCopyFile ( fileSrcPath, fileDstPath );

    }

    for ( i = 0; i < AlphaDbg.wNumFiles; ++i ) {

        sprintf ( fileSrcPath, "%s\\%s\\%s",                    szAlphaDbg,     
                                                                AlphaDbg.wcSubPath[i],
                                                                AlphaDbg.wcFilesArray[i] );
        sprintf ( fileDstPath, "%s\\support\\debug\\Alpha\\%s",  szWorkDstDrv, 
                                                                AlphaDbg.wcFilesArray[i] );

        MyCopyFile ( fileSrcPath, fileDstPath );

        if ( bChecked ) {
            //  Don't make a Serv checked build.
            continue;
        }

        sprintf ( fileDstPath, "%s\\support\\debug\\Alpha\\%s",  szServDstDrv, 
                                                                AlphaDbg.wcFilesArray[i] );

        MyCopyFile ( fileSrcPath, fileDstPath );

    }


    return(TRUE);
}

VOID    MakeCompName ( const char * inFile, char * outFile ) {

    unsigned i;
    unsigned period;

    strcpy( outFile, inFile );
    for ( period=(unsigned)(-1), i = 0 ; i < strlen(inFile); i++ ) {

        if ( inFile[i] == '.' ) { 
            period = i;
        }
    }
    if ( period == (strlen(inFile)-4) ) {

        outFile[strlen(outFile)-1] = '_';
    }
    else if ( period == (unsigned)(-1)) {

        strcat ( outFile, "._");
    }
    else {

        strcat ( outFile, "_");
    }

}


VOID    MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName ) {

    //
    //  Converts "filename.ext" into "ext\filename.dbg".
    //

    const char *p = strchr( pszSourceName, '.' );

    if ( p != NULL ) {
        strcpy( pszTargetName, p + 1 );                 // old extension
        strcat( pszTargetName, "\\" );                  // path separator
        strcat( pszTargetName, pszSourceName );         // base name
        strcpy( strchr( pszTargetName, '.' ), ".dbg" ); // new extension
    }
    else {
        strcpy( pszTargetName, pszSourceName );
    }

}


DWORD CopyX86Workstation (  void ) {

    char    fileSrcPath[256];
    char    fileDstPath[256];
    DWORD   i;

    fX86Wrk = FALSE;

    for ( i = 0; i < i386Workstation.wNumFiles; ++i ) {

        //  Copy the system file.
        //

        if ( i386Workstation.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( i386Workstation.wcFilesArray[i], szCompressedName );
            sprintf ( fileSrcPath, "%s\\%s",       szCompX86Src, szCompressedName );
            sprintf ( fileDstPath, "%s\\i386\\%s", szWorkDstDrv, szCompressedName );

            Msg ( "compressed source Path = %s\n", fileSrcPath );
        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",       szWrkX86Src, i386Workstation.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\i386\\%s", szWorkDstDrv, i386Workstation.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );


        //  Copy the dbg file, if needed.
        //
        if ( i386Workstation.bCopyDbg[i] ) {

            char    szDbgName[256];

            MakeDbgName ( i386Workstation.wcFilesArray[i], szDbgName );

            sprintf ( fileSrcPath, "%s\\%s",        szX86DbgSource,  szDbgName );
            sprintf ( fileDstPath, "%s\\support\\debug\\i386\\symbols\\%s",  szWorkDstDrv, szDbgName );

            MyCopyFile ( fileSrcPath, fileDstPath );
            
    
        }

    }

    fX86Wrk = TRUE;
    
    return (TRUE);

}

DWORD CopyAlphaWorkstation (  void ) {

    CHAR    fileSrcPath[256];
    CHAR    fileDstPath[256];
    DWORD   i;

    fAlphaWrk = FALSE; 

    for ( i = 0; i < AlphaWorkstation.wNumFiles; ++i ) {

        //  Copy the system file.
        //
        if ( AlphaWorkstation.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( AlphaWorkstation.wcFilesArray[i], szCompressedName );

            sprintf ( fileSrcPath, "%s\\%s",       szCompAlphaSrc, szCompressedName );
            sprintf ( fileDstPath, "%s\\alpha\\%s",  szWorkDstDrv, szCompressedName );

        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",       szWrkAlphaSrc, AlphaWorkstation.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\alpha\\%s", szWorkDstDrv, AlphaWorkstation.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );

        //  Copy the dbg file, if needed.
        //
        if ( AlphaWorkstation.bCopyDbg[i] ) {

            char    szDbgName[256];

            MakeDbgName ( AlphaWorkstation.wcFilesArray[i], szDbgName );

            sprintf ( fileSrcPath, "%s\\%s",        szAlphaDbgSource,  szDbgName );
            sprintf ( fileDstPath, "%s\\support\\debug\\alpha\\symbols\\%s",  szWorkDstDrv, szDbgName );

            MyCopyFile ( fileSrcPath, fileDstPath );
            
    
        }

    }
    
    fAlphaWrk = TRUE;    

    return (TRUE);

}


#define INF_SUFFIX ".inf"
#define SRV_INF    "srv_inf"

BOOL    SrvInfTest ( char * file ) {

    if ( strstr  ( file, INF_SUFFIX    ) != NULL && 
         _stricmp ( file, "MODEM.INF"   ) != 0    &&       //  these N Inf files are not built in 
         _stricmp ( file, "PAD.INF"     ) != 0    &&       //  setup\inf\...
         _stricmp ( file, "SETUP16.INF" ) != 0    &&        // and won't be found in the Server INF location 
         _stricmp ( file, "XPORTS.INF"  ) != 0    &&    
         _stricmp ( file, "SWITCH.INF"  ) != 0    && 
         _stricmp ( file, "MAPISVC.INF" ) != 0    &&
         _stricmp ( file, "IE.INF" ) != 0    &&
         _stricmp ( file, "INETFIND.INF" ) != 0    &&

         _stricmp ( file, "MONITOR1.INF" ) != 0    &&
         _stricmp ( file, "MONITOR2.INF" ) != 0    &&
         _stricmp ( file, "MONITOR3.INF" ) != 0    &&
         _stricmp ( file, "MONITOR4.INF" ) != 0    &&
         _stricmp ( file, "MONITOR6.INF" ) != 0    &&

         _stricmp ( file, "MSTASK.INF" ) != 0    &&
         _stricmp ( file, "SBPNP.INF" ) != 0    &&
         _stricmp ( file, "AMOVIE.INF" ) != 0    &&
         _stricmp ( file, "ICWNT5.INF" ) != 0    &&
         _stricmp ( file, "HMMNT5.INF" ) != 0    &&
         _stricmp ( file, "NT5JAVA.INF" ) != 0    &&
         _stricmp ( file, "ROUTING.INF" ) != 0    &&
         _strnicmp ( file, "MDM", 3     ) != 0               // for all those MDM*.INF modem inf files
                                                        ) {

        return (TRUE);      // use SERVER INF dump location path.
    }
    else {
        return (FALSE);     // use WORKSTATION INF dump location path,
                            // such as for INFs that don't have a distinction
                            // between Workstation and Server.
    }

}

DWORD CopyX86Server (  void ) {

    CHAR    fileSrcPath[256];
    CHAR    fileDstPath[256];
    DWORD   i;

    fX86Srv = FALSE;

    for ( i = 0; i < i386Server.wNumFiles; ++i ) {

        //  Copy the system file.
        //
        if ( i386Server.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( i386Server.wcFilesArray[i], szCompressedName );

            sprintf ( fileSrcPath, "%s\\%s",       szCompX86Src, szCompressedName );
            sprintf ( fileDstPath, "%s\\i386\\%s",  szServDstDrv, szCompressedName );

            if ( SrvInfTest ( i386Server.wcFilesArray[i] ) ) {

                sprintf ( fileSrcPath, "%s\\%s\\%s",  szCompX86Src, SRV_INF, szCompressedName );
                Msg ( "Server INF special src path:  %s\n", fileSrcPath ); 
            }

        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",       szSrvX86Src, i386Server.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\i386\\%s", szServDstDrv, i386Server.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );


        //  Copy the dbg file, if needed.
        //
        if ( i386Server.bCopyDbg[i] ) {

            char    szDbgName[256];

            MakeDbgName ( i386Server.wcFilesArray[i], szDbgName );

            sprintf ( fileSrcPath, "%s\\%s",        szX86DbgSource,  szDbgName );
            sprintf ( fileDstPath, "%s\\support\\debug\\i386\\symbols\\%s",  szServDstDrv, szDbgName );

            MyCopyFile ( fileSrcPath, fileDstPath );
            
    
        }
    }
    
    fX86Srv = TRUE;

    return (TRUE);

}

DWORD CopyAlphaServer (  void ) {

    CHAR    fileSrcPath[256];
    CHAR    fileDstPath[256];
    DWORD   i;

    fAlphaSrv = FALSE;

    for ( i = 0; i < AlphaServer.wNumFiles; ++i ) {

        //  Copy the system file.
        //
        if ( AlphaServer.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( AlphaServer.wcFilesArray[i], szCompressedName );

            sprintf ( fileSrcPath, "%s\\%s",       szCompAlphaSrc, szCompressedName );
            sprintf ( fileDstPath, "%s\\alpha\\%s",  szServDstDrv, szCompressedName );

            if ( SrvInfTest ( AlphaServer.wcFilesArray[i] ) ) {

                sprintf ( fileSrcPath, "%s\\%s\\%s",  szCompAlphaSrc, SRV_INF, szCompressedName );
                Msg ( "Server INF special src path:  %s\n", fileSrcPath ); 
            }

        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",        szSrvAlphaSrc, AlphaServer.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\alpha\\%s", szServDstDrv, AlphaServer.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );


        //  Copy the dbg file, if needed.
        //
        if ( AlphaServer.bCopyDbg[i] ) {

            char    szDbgName[256];

            MakeDbgName ( AlphaServer.wcFilesArray[i], szDbgName );

            sprintf ( fileSrcPath, "%s\\%s",        szAlphaDbgSource,  szDbgName );
            sprintf ( fileDstPath, "%s\\support\\debug\\alpha\\symbols\\%s",  szServDstDrv, szDbgName );

            MyCopyFile ( fileSrcPath, fileDstPath );
            
    
        }
    }
    
    fAlphaSrv = TRUE;

    return (TRUE);

}


BOOL    CopyTheFiles ( void ) {

    DWORD tId;
    HANDLE hThread;

/***
    if ( bVerifyBits ) { 

        //  Don't multithread.
        //
        CopyX86Workstation ();
        CopyX86Server ();
        CopyAlphaWorkstation ();
        CopyAlphaServer ();
	return (TRUE);
    }
***/

    hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyX86Workstation, NULL, 0, &tId );
    if ( hThread == NULL ) {
        Msg ( "x86w CreateThread ERROR gle = %ld\n", GetLastError() );
    }

    hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyX86Server,         NULL, 0, &tId );
    if ( hThread == NULL ) {
        Msg ( "x86s CreateThread ERROR gle = %ld\n", GetLastError() );
    }

    hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyAlphaWorkstation,  NULL, 0, &tId );
    if ( hThread == NULL ) {
        Msg ( "alphaw CreateThread ERROR gle = %ld\n", GetLastError() );
    }

    hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyAlphaServer,       NULL, 0, &tId );
    if ( hThread == NULL ) {
        Msg ( "alphas CreateThread ERROR gle = %ld\n", GetLastError() );
    }

    //  Copy the debugger files in the current thread.
    //
    CopyDbgFiles ();

    while ( fX86Wrk     == FALSE ||
            fX86Srv     == FALSE ||
            fAlphaWrk   == FALSE ||
            fAlphaSrv   == FALSE     ) {

        Sleep ( 1000 );

    }

    return(TRUE);
}

#define FILE_SECTION_NOT_USED 0xFFFF

DWORD   dwInsideSection = FILE_SECTION_NOT_USED;

DWORD   FigureSection ( char * Line ) {

    Msg ( "FigureSection on:  %s\n", Line );

    if ( strstr ( Line, FILE_SECTION_BASE )  ) {

        dwInsideSection = idBase; 

    } 
    else
    if ( strstr ( Line, FILE_SECTION_X86 ) ) {

        dwInsideSection = idX86; 

    } 
    else
    if ( strstr ( Line, FILE_SECTION_ALPHA ) ) {

        dwInsideSection = idALPHA; 

    } 
    else
    if ( strstr ( Line, FILE_SECTION_DBG_BASE ) ) {

        dwInsideSection = idBaseDbg; 

    } 
    else
    if ( strstr ( Line, FILE_SECTION_DBG_X86 ) ) {

        dwInsideSection = idX86Dbg; 

    } 
    else {

        dwInsideSection = FILE_SECTION_NOT_USED;
    }
    
    Msg ( "dwInsideSection = %x\n", dwInsideSection );
    return(dwInsideSection);

}
char * SuckName ( const char * Line ) {

    static char   szSuckedName[MFL];

    DWORD   dwIndex = 0;

    //  Copy the file name until a space is encountered.
    //
    while ( *Line != ' ' ) {

        szSuckedName[dwIndex] = *Line; 
        szSuckedName[dwIndex+1] = '\0';

        ++Line;
        ++dwIndex;
    }

    return szSuckedName;
} 

char * SuckSubName ( const char * Line ) {

    static char   szSub[150];
    DWORD       i = 0;

    char    * sPtr;
    char    * ePtr;

    Msg ( "SuckSubName Line = %s\n", Line );

    //  Find the = sign in the line.
    //
    sPtr = strchr ( Line, '=' );
    if ( sPtr == NULL ) {

        Msg ( "SuckSubName ERROR, couldn't find '=' character in string:  %s\n", Line );
        strcpy ( szSub, "" );
        return (szSub);
    }

    //  Go past the '=' and 'space' character.
    //
    ++sPtr;  
    ++sPtr;

    //Msg ( "sPtr = >>>%s<<<\n", sPtr );

    //  Find the , character, this is the end of the string.
    //
    ePtr = strchr ( Line, ',' );
    if ( ePtr == NULL ) {

        Msg ( "SuckSubName ERROR, couldn't find ',' character in string:  %s\n", Line );
        strcpy ( szSub, "" );
        return (szSub);
    }

    //  Copy the string.

    do {

        szSub[i] = *sPtr;

        ++i; 
        ++sPtr;

    } while ( sPtr < ePtr );

    szSub[i] = '\0';

    //Msg ( "szSub = >>>%s<<<\n\n", szSub );
    return szSub;

} 

void    ShowX86Work ( void ) {

    int i;

    for ( i = 0; i < i386Workstation.wNumFiles; ++i ) {

        Msg ( "%d  %s  Comp=%d Dbg=%d\n", 
                i,
                i386Workstation.wcFilesArray[i],
                i386Workstation.bCopyComp[i],
                i386Workstation.bCopyDbg[i] );

    }

}

void    AddFileToX86Work ( const char * Line, BOOL bCopyComp, BOOL bCopyDbg ) {

    i386Workstation.bCopyComp[i386Workstation.wNumFiles] = bCopyComp;
    i386Workstation.bCopyDbg[i386Workstation.wNumFiles] = bCopyDbg;
    i386Workstation.bCountBytes[i386Workstation.wNumFiles] = bGetSizeLater;

    strcpy ( i386Workstation.wcFilesArray[i386Workstation.wNumFiles], SuckName (Line) ); 

    ++i386Workstation.wNumFiles;
}

void    AddFileToX86Serv ( const char * Line, BOOL bCopyComp, BOOL bCopyDbg ) {

    if ( bChecked ) {
        //  Don't make a Serv checked build.
        return;
    }

    i386Server.bCopyComp[i386Server.wNumFiles] = bCopyComp;
    i386Server.bCopyDbg[i386Server.wNumFiles] = bCopyDbg;
    i386Server.bCountBytes[i386Server.wNumFiles] = bGetSizeLater;

    strcpy ( i386Server.wcFilesArray[i386Server.wNumFiles], SuckName (Line) );

    ++i386Server.wNumFiles;
}

void    AddFileToAlphaWork ( const char * Line, BOOL bCopyComp, BOOL bCopyDbg ) {

    AlphaWorkstation.bCopyComp[AlphaWorkstation.wNumFiles] = bCopyComp;
    AlphaWorkstation.bCopyDbg[AlphaWorkstation.wNumFiles] = bCopyDbg;
    AlphaWorkstation.bCountBytes[AlphaWorkstation.wNumFiles] = bGetSizeLater;

    strcpy ( AlphaWorkstation.wcFilesArray[AlphaWorkstation.wNumFiles], SuckName (Line) ); 

    ++AlphaWorkstation.wNumFiles;
}

void    AddFileToAlphaServ ( const char * Line, BOOL bCopyComp, BOOL bCopyDbg ) {

    if ( bChecked ) {
        //  Don't make a Serv checked build.
        return;
    }
    AlphaServer.bCopyComp[AlphaServer.wNumFiles] = bCopyComp;
    AlphaServer.bCopyDbg[AlphaServer.wNumFiles] = bCopyDbg;
    AlphaServer.bCountBytes[AlphaServer.wNumFiles] = bGetSizeLater;


    strcpy ( AlphaServer.wcFilesArray[AlphaServer.wNumFiles], SuckName (Line) ); 

    ++AlphaServer.wNumFiles;
}


void    AddFileToX86Dbg ( const char * Line ) {

        strcpy ( X86Dbg.wcFilesArray   [X86Dbg.wNumFiles], SuckName    (Line) );
        strcpy ( X86Dbg.wcSubPath      [X86Dbg.wNumFiles], SuckSubName (Line) );
        ++X86Dbg.wNumFiles;

}
void    AddFileToAlphaDbg ( const char * Line ) {

        strcpy ( AlphaDbg.wcFilesArray  [AlphaDbg.wNumFiles], SuckName    (Line) );
        strcpy ( AlphaDbg.wcSubPath     [AlphaDbg.wNumFiles], SuckSubName (Line) );
        ++AlphaDbg.wNumFiles;
}

BOOL    CopyCompressedFile ( const char * Line ) {

    const char    * Ptr = Line;
    DWORD   i = 0;

    #define COMP_FIELD 6

    while ( *Line != '\0' ) {

        //  If we are at the correct field,
        //  then stop counting fields.
        //
        if ( i == COMP_FIELD ) {
            break;
        }

        //  Found another field, increment our counter.
        //
        if ( *Line == ',' ) {

            ++i;
        }

        //  Look at next char.
        //
        ++Line;
    }

    //  If we are at the correct # of fields and the 
    //  next char isn't a ',', we should keep this file
    //  uncompressed.
    //
    if ( i == COMP_FIELD && *Line != ',' ) {

        Msg ( "don't compress this file =%c, %s", *Line, Ptr );
    
        return ( FALSE );
    }

    //Msg ( "CopyCompressedFile TRUE=%s\n", Ptr );
    return ( TRUE );

}


BOOL
ImageChk(
    CHAR * ImageName )
{

    HANDLE File;
    HANDLE MemMap;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    //NTSTATUS Status;
    BY_HANDLE_FILE_INFORMATION FileInfo;

    ULONG NumberOfPtes;
    ULONG SectionVirtualSize;
    ULONG i;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG SectorOffset;
    ULONG NumberOfSubsections;
    PCHAR ExtendedHeader = NULL;
    ULONG PreferredImageBase;
    ULONG NextVa;
    ULONG ImageFileSize;
    ULONG OffsetToSectionTable;
    ULONG ImageAlignment;
    ULONG PtesInSubsection;
    ULONG StartingSector;
    ULONG EndingSector;
    //LPSTR ImageName;
    BOOL ImageOk;

    Msg ( "ImageName = %s\n", ImageName );

    DosHeader = NULL;
    ImageOk = TRUE;
    File = CreateFile (ImageName,
                        GENERIC_READ | FILE_EXECUTE,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (File == INVALID_HANDLE_VALUE) {

        //  HACK:   Since the release shares put WINNT32.EXE and WINNT32.HLP in the 
        //          WINNT32 directory
        //          instead of leaving it in the flat root, verify that if the ImageName
        //          contains WINNT32, so we look in the WINNT32 dir also before error'ing out.
        //

        if ( strstr ( ImageName, "WINNT32.EXE" ) ||
             strstr ( ImageName, "winnt32a.dll" ) ||
             strstr ( ImageName, "winnt32u.dll" ) ||
             strstr ( ImageName, "WINNT32A.DLL" ) ||
             strstr ( ImageName, "WINNT32U.DLL" ) ||
             strstr ( ImageName, "winnt32.exe" ) ) { 

            char    tmpSrcPath[MFL];

            strcpy ( tmpSrcPath, ImageName );

            //Msg ( "ImageName = %s, tmpSrcPath = %s\n", ImageName, tmpSrcPath );

            if ( strstr ( tmpSrcPath, "a.dll" ) ||
                 strstr ( tmpSrcPath, "A.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
            }
            else if ( strstr ( tmpSrcPath, "u.dll" ) ||
                      strstr ( tmpSrcPath, "U.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
            }
             else {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
             }

            File = CreateFile (tmpSrcPath,
                        GENERIC_READ | FILE_EXECUTE,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if (File == INVALID_HANDLE_VALUE) {

                Msg ( "ERROR on ImageName(tmpSrcPath) = %s, gle = %ld\n", tmpSrcPath, GetLastError() );
                return (FALSE);

            }
        }
        else {

            Msg ( "ERROR, CreateFile(%s) gle = %ld\n", ImageName, GetLastError());
            return (FALSE);
        }
    }

    MemMap = CreateFileMapping (File,
                        NULL,           // default security.
                        PAGE_READONLY,  // file protection.
                        0,              // high-order file size.
                        0,
                        NULL);

    if (!GetFileInformationByHandle(File, &FileInfo)) {
        Msg ("ERROR, GetFileInfo() %d, %s\n", GetLastError(), ImageName );
        CloseHandle(File);
        return (FALSE);
    }

    DosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile(MemMap,
                              FILE_MAP_READ,
                              0,  // high
                              0,  // low
                              0   // whole file
                              );

    CloseHandle(MemMap);
    if (!DosHeader) {
        Msg ("ERROR, MapViewOfFile() %d\n", GetLastError());
        ImageOk = FALSE;
        goto NextImage;
    }

    try {

        //
        // Check to determine if this is an NT image (PE format) or
        // a DOS image, Win-16 image, or OS/2 image.  If the image is
        // not NT format, return an error indicating which image it
        // appears to be.
        //

        if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

            Msg ( "Warning:  MZ header not found, %s\n", ImageName );
            ImageOk = FALSE;
            goto NeImage;
        }


        NtHeader = (PIMAGE_NT_HEADERS)((ULONG)DosHeader + (ULONG)DosHeader->e_lfanew);

        if (NtHeader->Signature != IMAGE_NT_SIGNATURE) { //if not PE image

            Msg ("Warning: Non 32-bit image, %s\n", ImageName);
            ImageOk = FALSE;
            goto NeImage;
        }

/*****
    //
    // Check to see if this is an NT image or a DOS or OS/2 image.
    //

    Status = MiVerifyImageHeader (NtHeader, DosHeader, 50000);
    if (Status != STATUS_SUCCESS) {
        ImageOk = FALSE;            //continue checking the image but don't print "OK"
    }
*****/

        //
        // Verify machine type.
        //

        if (!((NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) ||
            (NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_R3000) ||
            (NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_R4000) ||
            (NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_R10000) ||
            (NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA))) {
            Msg ( "ERROR Unrecognized machine type x%lx\n",
            NtHeader->FileHeader.Machine);
            ImageOk = FALSE;
        }

    } 
    except ( EXCEPTION_EXECUTE_HANDLER ) {

        Msg ( "Warning, try/except handler, %s\n", ImageName );
        ImageOk = FALSE;
    }

NextImage:
NeImage:

    if ( File != INVALID_HANDLE_VALUE ) {
        CloseHandle(File);
    }
    if ( DosHeader ) {
        UnmapViewOfFile(DosHeader);
    }

    return (ImageOk);
}

BOOL    CopyDbgFile ( const char * Line, DWORD dwInsideSection ) {

    char    szPath[MFL];
    char    szFile[20];
    BOOL    b;
    LONG    lType;

    //  Verify that this file name contains one of the extensions
    //  that we need files for debugging.
    //
        
    sprintf ( szFile, "%s", SuckName ( Line ) ); 

    if ( strstr ( szFile, ".acm" ) == NULL &&
         strstr ( szFile, ".com" ) == NULL &&
         strstr ( szFile, ".cpl" ) == NULL &&
         strstr ( szFile, ".dll" ) == NULL &&
         strstr ( szFile, ".drv" ) == NULL &&
         strstr ( szFile, ".exe" ) == NULL &&
         strstr ( szFile, ".scr" ) == NULL &&
         strstr ( szFile, ".sys" ) == NULL  ) {

        return (FALSE);
    }

    //  Determine which release share to look at.
    //
    switch ( dwInsideSection ) {

        case idBase  :
        case idX86   :

            sprintf ( szPath, "%s\\%s", szWrkX86Src, szFile );
    
            break;

        case idALPHA :

            sprintf ( szPath, "%s\\%s", szWrkAlphaSrc, szFile );

            break;

        case idBaseDbg :
        case idX86Dbg :

            return (FALSE);

        default :

            Msg ( "ERROR:  CopyDbgFile, unknown switch value = %ld\n", dwInsideSection );
            return (FALSE);
            break;

    }

    //  Since we are loading in each INF now, let's optimize this code, ie. if we have
    //  deemed the file to get it's debug file, don't do another ImageChk since it is
    //  unneccessary.
    {
        int i;

        for ( i = 0; i < i386Workstation.wNumFiles; ++i ) {

            if ( _stricmp ( i386Workstation.wcFilesArray[i], szFile ) == 0 ) {

                //Msg ( ">>>  files have same name for .dbg :  %s %s\n", 
                //            i386Workstation.wcFilesArray[i], szFile );
                return TRUE;
            }
        }

    }

    //  Look at the binary type. If it is a Win32 binary, pick it up.
    //
    b = ImageChk ( szPath );

    return ( b );

}

#define X86_WRK     0
#define X86_SRV     1
#define ALPHA_WRK   2
#define ALPHA_SRV   3
#define DBGS_AND_NON_INSTALLED    4

BOOL    GetTheFiles ( char * LayoutInfPath, char * layoutFile, int AddToList ) {

    CHAR       infFilePath[MFL];
    DWORD       dwErrorLine;
    BOOL        b;
    char       dstDirectory[MFL];
    FILE        * fHandle;
    char        Line[MFL];


    //  Open the inx file for processing.
    //
    sprintf ( infFilePath, "%s\\%s", LayoutInfPath, layoutFile );

    Msg ( "infFilePath = %s\n", infFilePath );

    fHandle = fopen ( infFilePath, "rt" );

    if ( fHandle ) {


        Msg ( "dwInsideSection = %x\n", dwInsideSection );

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            int     i;

            BOOL    bCopyComp = FALSE;  // flag to tell if file shall be copied in its compressed format.
            BOOL    bCopyDbg = FALSE;   // flag to tell if copying the file's .dbg file.

        //    Msg ( "Line: %s\n", Line );

            if ( Line[0] == '[' ) {

                //  We may have a new section.
                //
                dwInsideSection = FigureSection ( Line ); 

                continue;
            }


            //  Reasons to ignore this line from further processing.
            //
            //

            //  File section not one we process.
            //
            if ( dwInsideSection == FILE_SECTION_NOT_USED ) {

                continue;
            }

            //  Line just contains a non-usefull short string.
            //
            i = strlen ( Line );
            if ( i < 4 ) {

                continue;
            } 

            //  Line contains just a comment.
            //
            if ( Line[0] == ';' ) {

                continue;
            }
            
            //  Determine if we should copy the compressed
            //  version of the file and if we should copy the .dbg file.
            //
            bCopyComp = CopyCompressedFile ( Line );

            bCopyDbg  = CopyDbgFile        ( Line, dwInsideSection );

            //Msg ( "file == %s\n", SuckName ( Line ) );

            switch ( AddToList ) {

                case X86_WRK :

                    if ( dwInsideSection == idBase || dwInsideSection == idX86 ) {

                       AddFileToX86Work ( Line, bCopyComp, bCopyDbg ); 

                    }

                    break;

                case X86_SRV :

                    if ( dwInsideSection == idBase || dwInsideSection == idX86 ) {

                       AddFileToX86Serv ( Line, bCopyComp, bCopyDbg ); 

                    }

                    break;

                case ALPHA_WRK :

                    if ( dwInsideSection == idBase || dwInsideSection == idALPHA ) {

                       AddFileToAlphaWork ( Line, bCopyComp, bCopyDbg ); 

                    }

                    break;

                case ALPHA_SRV :

                    if ( dwInsideSection == idBase || dwInsideSection == idALPHA ) {

                       AddFileToAlphaServ ( Line, bCopyComp, bCopyDbg ); 

                    }

                    break;

                case DBGS_AND_NON_INSTALLED :

                    if ( dwInsideSection == idBase ) {
                        AddFileToX86Work ( Line, bCopyComp, bCopyDbg ); 
                        AddFileToX86Serv ( Line, bCopyComp, bCopyDbg ); 
                        AddFileToAlphaWork ( Line, bCopyComp, bCopyDbg ); 
                        AddFileToAlphaServ ( Line, bCopyComp, bCopyDbg ); 
                        break;
                    }
                    if ( dwInsideSection == idX86 ) {
                        AddFileToX86Work ( Line, bCopyComp, bCopyDbg ); 
                        AddFileToX86Serv ( Line, bCopyComp, bCopyDbg ); 
                        break;
                    }
                    if ( dwInsideSection == idALPHA ) {
                        AddFileToAlphaWork ( Line, bCopyComp, bCopyDbg ); 
                        AddFileToAlphaServ ( Line, bCopyComp, bCopyDbg ); 
                        break;
                    }

                    if ( dwInsideSection == idBaseDbg ) {
                        AddFileToX86Dbg ( Line );
                        AddFileToAlphaDbg ( Line );
                        break;
                    }

                    if ( dwInsideSection == idX86Dbg ) {
                        AddFileToX86Dbg ( Line );
                        break;
                    }

                    break;

                default :

                    Msg ( "ERROR: AddToList = %d\n", AddToList );
            }
        
        }
        if ( ferror(fHandle) ) {

            Msg ( "ERROR fgets reading from file...\n" );
        }

    }
    else {

        Msg ( "fopen ERROR %s\n", infFilePath );
        return (FALSE);
    }

    fclose ( fHandle );

    return (TRUE);
}

void TallyInstalled ( char * szUncompPath, char * szCompPath, 
                        struct _tag * tagStruct, 
                        DWORD * numBytes, 
                        struct _ClusterSizes * localSrcBytes ) {

    int i;
    char szCompressedName[MFL];
    char szPath[MFL];

    *numBytes = 0;
    localSrcBytes->Kh1 = 0;
    localSrcBytes->K1 = 0;
    localSrcBytes->K2 = 0;
    localSrcBytes->K4 = 0;
    localSrcBytes->K8 = 0;
    localSrcBytes->K16 = 0;
    localSrcBytes->K32 = 0;
    localSrcBytes->K64 = 0;
    localSrcBytes->K128 = 0;
    localSrcBytes->K256 = 0;
    

    for ( i = 0; i < tagStruct->wNumFiles; ++i ) {

        WIN32_FIND_DATA wfd;
        HANDLE          hFind;


        //  Don't add in space requirements for files in media.inx, since
        //  these files are NEVER installed.
        //
        if ( !tagStruct->bCountBytes[i] ) {

            Msg ( "Warning:  not going to count bytes for:  %s\n", tagStruct->wcFilesArray[i] );
            continue;
        }

        //  Calculate the minimum installed system space required.
        //
        //

        sprintf ( szPath, "%s\\%s", szUncompPath, tagStruct->wcFilesArray[i] );

        hFind = FindFirstFile ( szPath, &wfd );

        if ( hFind == INVALID_HANDLE_VALUE ) {

            if ( strstr ( szPath, "desktop.ini" ) ||
                 strstr ( szPath, "DESKTOP.INI" )    ) {

                //  Build lab sometimes doesn't put the uncompressed
                //  file on the release shares, say the file is 512 bytes.
                //

#define MAX_SETUP_CLUSTER_SIZE 16*1024
                *numBytes += ROUNDUP2 ( 512, MAX_SETUP_CLUSTER_SIZE );
            }
            else
            if ( strstr ( szPath, "WINNT32.EXE" ) ||
                strstr ( szPath, "winnt32.exe" ) ||
                strstr ( szPath, "winnt32a.dll" ) ||
                strstr ( szPath, "winnt32u.dll" ) ||
                strstr ( szPath, "WINNT32A.DLL" ) ||
                strstr ( szPath, "WINNT32U.DLL" ) ||
                strstr ( szPath, "WINNT32.HLP" ) ||
                strstr ( szPath, "winnt32.hlp" )    ) { 

                char    tmpSrcPath[MFL];

                strcpy ( tmpSrcPath, szPath );

                if ( strstr ( tmpSrcPath, ".HLP" ) ||
                    strstr ( tmpSrcPath, ".hlp" )    ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
                }
                else if ( strstr ( tmpSrcPath, "a.dll" ) ||
                    strstr ( tmpSrcPath, "A.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
                }
                else if ( strstr ( tmpSrcPath, "u.dll" ) ||
                          strstr ( tmpSrcPath, "U.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
                }
                else {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
                }

                hFind = FindFirstFile ( tmpSrcPath, &wfd );

                if ( hFind == INVALID_HANDLE_VALUE ) {

                    Msg ( "ERROR Tally:  FindFirstFile %s(%s), gle = %ld\n", szPath, tmpSrcPath, GetLastError() );

                }
            }
            else {

                Msg ( "ERROR Tally:  FindFirstFile %s, gle = %ld\n", szPath, GetLastError() );
            }

        }
        else {


            *numBytes += ROUNDUP2 ( wfd.nFileSizeLow, MAX_SETUP_CLUSTER_SIZE );

            FindClose ( hFind );

            //Msg ( "%s = %ld\n", szPath, *numBytes );
        }





        //  Calculate the local space required.
        //
        //

        if ( tagStruct->bCopyComp[i] ) {

            char    szCompressedName[MFL];

            MakeCompName ( tagStruct->wcFilesArray[i], szCompressedName );
            sprintf ( szPath, "%s\\%s", szCompPath, szCompressedName );
            
        } 
        else {

            sprintf ( szPath, "%s\\%s", szUncompPath, tagStruct->wcFilesArray[i] );
        }

        hFind = FindFirstFile ( szPath, &wfd );

        if ( hFind == INVALID_HANDLE_VALUE ) {

            if ( strstr ( szPath, "WINNT32.EXE" ) ||
                 strstr ( szPath, "winnt32.exe" ) ||
                strstr ( szPath, "winnt32a.dll" ) ||
                strstr ( szPath, "winnt32u.dll" ) ||
                strstr ( szPath, "WINNT32A.DLL" ) ||
                strstr ( szPath, "WINNT32U.DLL" ) ||
                 strstr ( szPath, "WINNT32.HLP" ) ||
                 strstr ( szPath, "winnt32.hlp" )    ) { 

                char    tmpSrcPath[MFL];

                strcpy ( tmpSrcPath, szPath );

                if ( strstr ( tmpSrcPath, ".HLP" ) ||
                    strstr ( tmpSrcPath, ".hlp" )    ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
                }
                else if ( strstr ( tmpSrcPath, "a.dll" ) ||
                    strstr ( tmpSrcPath, "A.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
                }
                else if ( strstr ( tmpSrcPath, "u.dll" ) ||
                    strstr ( tmpSrcPath, "U.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
                }
                else {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
                }

                hFind = FindFirstFile ( tmpSrcPath, &wfd );

                if ( hFind == INVALID_HANDLE_VALUE ) {

                    Msg ( "ERROR Tally:  FindFirstFile %s(%s), gle = %ld\n", szPath, tmpSrcPath, GetLastError() );

                }
            }
            else {

                Msg ( "ERROR Tally:  FindFirstFile %s, gle = %ld\n", szPath, GetLastError() );
            }

        }
        else {

#define _h1K	512
#define _1K	    1*1024
#define _2K	    2*1024
#define _4K	    4*1024
#define _8K	    8*1024
#define _16K	16*1024
#define _32K	32*1024
#define _64K	64*1024
#define _128K	128*1024
#define _256K   256*1024

            localSrcBytes->Kh1 += ROUNDUP2 ( wfd.nFileSizeLow, _h1K  );
            localSrcBytes->K1  += ROUNDUP2 ( wfd.nFileSizeLow, _1K   );
            localSrcBytes->K2  += ROUNDUP2 ( wfd.nFileSizeLow, _2K   );
            localSrcBytes->K4  += ROUNDUP2 ( wfd.nFileSizeLow, _4K   );
            localSrcBytes->K8  += ROUNDUP2 ( wfd.nFileSizeLow, _8K   );
            localSrcBytes->K16 += ROUNDUP2 ( wfd.nFileSizeLow, _16K  );
            localSrcBytes->K32 += ROUNDUP2 ( wfd.nFileSizeLow, _32K  ); 
            localSrcBytes->K64 += ROUNDUP2 ( wfd.nFileSizeLow, _64K  ); 
            localSrcBytes->K128+= ROUNDUP2 ( wfd.nFileSizeLow, _128K );
            localSrcBytes->K256+= ROUNDUP2 ( wfd.nFileSizeLow, _256K );

            FindClose ( hFind );

            //Msg ( "%s = %ld\n", szPath, *localSrcBytes );
        }
        
    } 

}

DWORD   GetTheSize ( const char * szPath, const char * szKey ) {

    FILE *  fHandle;
    char    Line[MFL];

    Msg ( "GetTheSize:  szPath = %s\n", szPath );

    fHandle = fopen ( szPath, "rt" );

    if ( fHandle ) {

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            if ( strncmp ( Line, szKey, strlen(szKey)-1 ) == 0 ) {

                char * LinePtr = Line;

                Msg ( "key Line = %s\n", Line );

                //  Find the first character that is a number.
                //
                while ( isdigit(*LinePtr) == 0 ) {

                    ++LinePtr;
                }

                Msg ( "# = %s\n", LinePtr );

                fclose ( fHandle );
                return ( atoi ( LinePtr ) );
            }

        }
        Msg ( "GetTheSize:  Couldn't find key:  %s\n", szKey );
        fclose ( fHandle );
    }
    else {

        Msg ( "GetTheSize:  Couldn't fopen (%s)\n", szPath );
    }

    return 0;
}

DWORD   ThreeMegFudge ( void ) {

    //  The following value incorporates:
    //
    //      - boot files on hard drive, ie. the files that would go on the floppies
    //      - dir ents for all files on hard drive
    //      the first is about 4.8M, the latter about 1M.
    //      - plus, just a few 100K for fudge.

    return ( 6*1024*1024 );
}

void ShowCheckLocalSpace ( struct _ClusterSizes * Section, char * String, char * netServer ) {

    DWORD   dwSize = 0;
    #define OHPROBLEM "problem"
    char    returnedString[MFL];
    #define SP "SpaceRequirements"
    char    dosnetFile[MFL];

    if ( bFourPtO ) {
        //  For 4.0 just do the following section.
        //
		GetPrivateProfileString ( SP, "NtDrive", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  NtDrive section not found\n" );
        }
        Msg ( "returnedString = >>%s<<\n", returnedString );
        dwSize = atoi ( returnedString );
		if ( Section->K16+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's NtDrive value is %ld   Use: %ld\n", String, dwSize, Section->K16 + ThreeMegFudge ( ) );
		}

        //  End of 4.0 section.
    }
    else {
        //  Begin of 5.0 stuff.
        //

        sprintf ( dosnetFile, "%s\\dosnet.inf", netServer );
        Msg ( "Dosnet.Inf location:  %s\n", dosnetFile );

		Msg ( "%s  512 size = %ld\n", String, Section->Kh1 );
		Msg ( "%s  1K  size = %ld\n", String, Section->K1 );
		Msg ( "%s  2K  size = %ld\n", String, Section->K2 );
		Msg ( "%s  4K  size = %ld\n", String, Section->K4 );
		Msg ( "%s  8K  size = %ld\n", String, Section->K8 );
		Msg ( "%s  16K size = %ld\n", String, Section->K16 );
		Msg ( "%s  32K size = %ld\n", String, Section->K32 );
		Msg ( "%s  64K size = %ld\n", String, Section->K64 ) ;
		Msg ( "%s  128K size = %ld\n", String, Section->K128 );
		Msg ( "%s  256K size = %ld\n", String, Section->K256 );



		GetPrivateProfileString ( SP, "512", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  512 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->Kh1+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 512 value is %ld   Use: %ld\n", String, dwSize, Section->Kh1 + ThreeMegFudge ( ) );
		}

		GetPrivateProfileString ( SP, "1K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  1024 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K1+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 1K value is %ld    Use: %ld\n", String, dwSize, Section->K1 + ThreeMegFudge ( ));
		}

		GetPrivateProfileString ( SP, "2K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  2048 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K2+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 2K value is %ld    Use: %ld\n", String, dwSize, Section->K2 + ThreeMegFudge ( ));
		}

		GetPrivateProfileString ( SP, "4K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  4096 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K4+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 4K value is %ld    Use: %ld\n", String, dwSize, Section->K4 + ThreeMegFudge () );
		}

		GetPrivateProfileString ( SP, "8K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  8192 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K8+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 8K value is %ld    Use: %ld\n", String, dwSize, Section->K8 + ThreeMegFudge() );
		}

		GetPrivateProfileString ( SP, "16K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  16384 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K16+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 16K value is %ld   Use: %ld\n", String, dwSize, Section->K16 + ThreeMegFudge () );
		}

		GetPrivateProfileString ( SP, "32K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  32768 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K32+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 32K value is %ld   Use: %ld\n", String, dwSize, Section->K32 + ThreeMegFudge () );
		}

		GetPrivateProfileString ( SP, "64K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  65536 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K64+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 64K value is %ld   Use: %ld\n", String, dwSize, Section->K64 + ThreeMegFudge () );
		}

		GetPrivateProfileString ( SP, "128K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  131072 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K128+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 128K value is %ld   Use: %ld\n", String, dwSize, Section->K128 + ThreeMegFudge () );
		}

		GetPrivateProfileString ( SP, "256K", OHPROBLEM, returnedString, MFL, dosnetFile );
        if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
            Msg ( "ERROR:  262144 section not found\n" );
        }
        dwSize = atoi ( returnedString );
		if ( Section->K256+ThreeMegFudge() > dwSize ) {
			Msg ( "ERROR:  %s dosnet.inf's 256K value is %ld   Use: %ld\n", String, dwSize, Section->K256 + ThreeMegFudge () );
		}

        // End of 5.0 stuff.
    }

}



int __cdecl main(argc,argv)
int argc;
char * argv[];
{
    HANDLE h;
    int records, i;
    WIN32_FIND_DATA fd;
    time_t t;
    DWORD   dwSize;
    char    szFileName[MFL];
	DWORD upgX86Work   ;
	DWORD upgX86Serv   ;
	DWORD upgAlphaWork ;
	DWORD upgAlphaServ ;
	
    if ( argc != 15 ) {  
        printf ( "You specified %d arguments - you need 15.\n\n", argc );

        for ( i = 0; i < argc; ++i ) {

            printf ( "Argument #%d >>>%s<<<\n", i, argv[i] );
        }
        printf ( "\n\n" );
        Usage();  
        return(1); 
	}

    //  Initialize the critical section object.
    //
    InitializeCriticalSection ( &CriticalSection );

    //  Retail %platform% files.
    //
    i386Workstation.wNumFiles       = 0;
    AlphaWorkstation.wNumFiles      = 0;
    i386Server.wNumFiles            = 0;
    AlphaServer.wNumFiles           = 0;

    //  Debugger files.
    //
    X86Dbg.wNumFiles    = 0;
    AlphaDbg.wNumFiles  = 0;

    
    strcpy ( szLogFile,     argv[1] );
    strcpy ( szWrkX86Src,   argv[2] );
    strcpy ( szWrkAlphaSrc, argv[3] );
    strcpy ( szSrvX86Src,   argv[4] );
    strcpy ( szSrvAlphaSrc, argv[5] );
    strcpy ( szCompX86Src,   argv[6] );
    strcpy ( szCompAlphaSrc, argv[7] );
    strcpy ( szX86Dbg,      argv[8] );
    strcpy ( szAlphaDbg,    argv[9] );
    strcpy ( szX86DbgSource,  argv[10] );
    strcpy ( szAlphaDbgSource,argv[11] );
    strcpy ( szEnlistDrv,   argv[12] );
    strcpy ( szWorkDstDrv,  argv[13] );
    strcpy ( szServDstDrv,  argv[14] );

    logFile = fopen ( argv[1], "a" ); 

    if ( logFile == NULL ) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }

#define FOUR_POINT_O_MEDIA "FOUR_POINT_O_MEDIA"
    //  Determine if we are doing a build of NT 4.0 to do special NtDrive calculation.
    //
    if ( getenv ( FOUR_POINT_O_MEDIA ) != NULL ) { 

        bFourPtO = TRUE;
        Msg ( "Performing a NT 4.0 build...\n" );
    }

#define CHECKED_MEDIA "CHECKED_MEDIA"
    //  Determine if we are doing the CHECKED binaries.
    //
    if ( getenv ( CHECKED_MEDIA ) != NULL ) { 

        bChecked = TRUE;
        Msg ( "Performing a CHECKED build...\n" );
    }

    //  Do bit comparison to release shares on all copies ?
    //
#define VERIFY_COPIES   "VERIFY"

    if ( getenv ( VERIFY_COPIES ) != NULL ) {
        bVerifyBits = TRUE;
        Msg ( "Will verify copies...\n" );
    }

    Header(argv,argc);


    CreateDestinationDirs ();

    //  Get files that product installs.
    //
    bGetSizeLater = TRUE;
    GetTheFiles ( szWrkX86Src,  "layout.inf", X86_WRK );
    GetTheFiles ( szSrvX86Src,  "layout.inf", X86_SRV );
    GetTheFiles ( szWrkAlphaSrc,"layout.inf", ALPHA_WRK );
    GetTheFiles ( szSrvAlphaSrc,"layout.inf", ALPHA_SRV );

    bGetSizeLater = FALSE;
    GetTheFiles ( "C:\\nt\\private\\windows\\setup\\bom"/*szWrkX86Src*/,  "_media.inx", DBGS_AND_NON_INSTALLED );


    //ShowX86Work();


    //  Make some threads and copy all the files.
    //
    CopyTheFiles();

    Msg ( "# files  i386  Workstation = %ld\n", i386Workstation.wNumFiles );
    Msg ( "# files  i386  Server      = %ld\n", i386Server.wNumFiles );
    Msg ( "# files  Alpha Workstation = %ld\n", AlphaWorkstation.wNumFiles );
    Msg ( "# files  Alpha Server      = %ld\n", AlphaServer.wNumFiles );

    if ( i386Workstation.wNumFiles > MAX_NUMBER_OF_FILES_IN_PRODUCT  ||
         i386Server.wNumFiles      > MAX_NUMBER_OF_FILES_IN_PRODUCT  ||
         AlphaWorkstation.wNumFiles> MAX_NUMBER_OF_FILES_IN_PRODUCT  ||
         AlphaServer.wNumFiles     > MAX_NUMBER_OF_FILES_IN_PRODUCT     ) {


        Msg ( "ERROR:   Increase MAX_NUM in Files.C\n" );
    }

    //
    //
    //

    Msg ( "========= Minimum setup install bytes required (all files uncompressed): ==========\n" );

    //
    //
    TallyInstalled ( szWrkX86Src, szCompX86Src, &i386Workstation, &bytesX86Work, &lX86Work );
    TallyInstalled ( szSrvX86Src, szCompX86Src, &i386Server,      &bytesX86Serv, &lX86Serv );
    TallyInstalled ( szWrkAlphaSrc, szCompAlphaSrc, &AlphaWorkstation,&bytesAlphaWork, &lAlphaWork );
    TallyInstalled ( szSrvAlphaSrc, szCompAlphaSrc, &AlphaServer,     &bytesAlphaServ, &lAlphaServ );
    
	//	Give tally counts.
	//
	Msg ( "bytesX86Work  = %ld\n", bytesX86Work );
	Msg ( "bytesX86Serv  = %ld\n", bytesX86Serv );
	Msg ( "bytesAlphaWork= %ld\n", bytesAlphaWork );
	Msg ( "bytesAlphaServ= %ld\n", bytesAlphaServ );
	
#define FUDGE_PLUS  4*1024*1024  // ie, grow by 4 M for future growth.

    //  Print out an error if the above sizes are greater than the hardcode sizes in:
    //      
    //      txtsetup.sif's FreeDiskSpace = <value>
    //
    Msg ( "ERROR:  do new thing for 5.0 FreeDiskSpace...\n" );
#define FREEDISKSPACE "FreeDiskSpace"

    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szWrkX86Src );
    dwSize = 1024 * GetTheSize ( szFileName, FREEDISKSPACE );
    if ( dwSize < bytesX86Work ) {
        Msg ( "ERROR:  x86 Work txtsetup.sif's FreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, bytesX86Work, (FUDGE_PLUS+bytesX86Work)/1024 );
    }
    else {
        Msg ( "Box size -- X86 Workstation:  %ld M\n", dwSize/1024/1024 );
    }

    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szSrvX86Src );
    dwSize = 1024 * GetTheSize ( szFileName, FREEDISKSPACE );
    if ( dwSize < bytesX86Serv ) {
        Msg ( "ERROR:  x86 Serv txtsetup.sif's FreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, bytesX86Serv, (FUDGE_PLUS+bytesX86Serv)/1024 );
    }
    else {
        Msg ( "Box size -- X86 Server:  %ld M\n", dwSize/1024/1024 );
    }

    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szWrkAlphaSrc );
    dwSize = 1024 * GetTheSize ( szFileName, FREEDISKSPACE );
    if ( dwSize < bytesAlphaWork ) {
        Msg ( "ERROR:  Alpha Work txtsetup.sif's FreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, bytesAlphaWork, (FUDGE_PLUS+bytesAlphaWork)/1024 );
    }
    else {
        Msg ( "Box size -- Alpha Workstation:  %ld M\n", dwSize/1024/1024 );
    }

    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szSrvAlphaSrc );
    dwSize = 1024 * GetTheSize ( szFileName, FREEDISKSPACE );
    if ( dwSize < bytesAlphaServ ) {
        Msg ( "ERROR:  Alpha Serv txtsetup.sif's FreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, bytesAlphaServ, (FUDGE_PLUS+bytesAlphaServ)/1024 );
    }
    else {
        Msg ( "Box size -- Alpha Server:  %ld M\n", dwSize/1024/1024 );
    }


    Msg ( "========= Maximum setup local-source bytes required (some files compressed) : =====\n" );

    Msg ( "Note:  setup automagically adds in the inetsrv and drvlib.nic sizes, not in below...\n" );

	ShowCheckLocalSpace ( &lX86Work, "lX86Work",    szWrkX86Src );
	ShowCheckLocalSpace ( &lX86Serv, "lX86Serv",    szSrvX86Src );
	ShowCheckLocalSpace ( &lAlphaWork, "lAlphaWork",szWrkAlphaSrc );
	ShowCheckLocalSpace ( &lAlphaServ, "lAlphaServ",szSrvAlphaSrc );



    Msg ( "========= Specify at least this much for Upgrade using the NT build with the least amount of footprint: =====\n" );

    //  We'll start off with 1057 as our smallest footprint build.
    //  This data will have to be checked each time we ship for the next to be release build.
    //

    //  1057 3.51   All files in product expanded at 16K cluster size. 
    #define X86WKS   87572480 
    #define X86SRV   92798976 
    #define ALPWKS  107757568 
    #define ALPSRV  114900992 

	upgX86Work   = bytesX86Work   - X86WKS;
	upgX86Serv   = bytesX86Serv   - X86SRV;
	upgAlphaWork = bytesAlphaWork - ALPWKS;
	upgAlphaServ = bytesAlphaServ - ALPSRV;

	Msg ( "X86Work  = %ld\n", upgX86Work   );
	Msg ( "X86Serv  = %ld\n", upgX86Serv   );
	Msg ( "AlphaWork= %ld\n", upgAlphaWork );
	Msg ( "AlphaServ= %ld\n", upgAlphaServ );


	//////
	//////
	//////	Hopefully for NT 5.0, setup won't require UpgradeFreeDiskSpace.
	//////	Ask TedM/JaimeS.
	//////

    Msg ( "ERROR:  do new thing for 5.0 UpgradeFreeDiskSpace...\n" );

    //  Print out an error if the above sizes are greater than the hardcode sizes in:
    //      
    //      txtsetup.sif's UpgradeFreeDiskSpace = <value>
    //
#define UPGRADEFREEDISKSPACE "UpgradeFreeDiskSpace"

    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szWrkX86Src );
    dwSize = 1024 * GetTheSize ( szFileName, UPGRADEFREEDISKSPACE );
    if ( dwSize < upgX86Work ) {
        Msg ( "ERROR:  x86 Work txtsetup.sif's UpgradeFreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, upgX86Work, (FUDGE_PLUS+upgX86Work)/1024 );
    }
    else {
        Msg ( "Box size upgrade Wrk x86 = %ld M\n", dwSize/1024/1024 );
    }


    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szSrvX86Src );
    dwSize = 1024 * GetTheSize ( szFileName, UPGRADEFREEDISKSPACE );
    if ( dwSize < upgX86Serv ) {
        Msg ( "ERROR:  x86 Serv txtsetup.sif's UpgradeFreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, upgX86Serv, (FUDGE_PLUS+upgX86Serv)/1024 );
    }
    else {
        Msg ( "Box size upgrade Srv x86 = %ld M\n", dwSize/1024/1204 );
    }


    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szWrkAlphaSrc );
    dwSize = 1024 * GetTheSize ( szFileName, UPGRADEFREEDISKSPACE );
    if ( dwSize < upgAlphaWork ) {
        Msg ( "ERROR:  Alpha Work txtsetup.sif's UpgradeFreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, upgAlphaWork, (FUDGE_PLUS+upgAlphaWork)/1024 );
    }
    else {
        Msg ( "Box size upgrade Wrk Alpha = %ld M\n", dwSize/1024/1204 );
    }


    sprintf ( szFileName, "%s\\TXTSETUP.SIF", szSrvAlphaSrc );
    dwSize = 1024 * GetTheSize ( szFileName, UPGRADEFREEDISKSPACE );
    if ( dwSize < upgAlphaServ ) {
        Msg ( "ERROR:  Alpha Serv txtsetup.sif's UpgradeFreeDiskSpace %ld < %ld  Fix with value: %ld\n", dwSize, upgAlphaServ, (FUDGE_PLUS+upgAlphaServ)/1024 );
    }
    else {
        Msg ( "Box size upgrade Srv Alpha = %ld M\n", dwSize/1024/1204 );
    }


    Msg ( "==============================\n");
    time(&t); 
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "==============================\n\n");

    fclose(logFile);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\files\files.c ===
//
//  06.05.95    Joe Holman      Created to copy the system files for
//                              the new shell and cairo releases.
//                              Currently, it only copies uncompressed system files.
//  06.16.95    Joe Holman      Allow debugging tools to be copied. Uses _media.inx
//  06.19.95    Joe Holman      Copy compressed version of file if specified in _layout.inx.
//  06.22.95    Joe Holman      Added bCairoSuckNameHack to pick up files from
//                              the inf\cairo\_layout.cai file.
//  06.22.95    Joe Holman      Added the SRV_INF fix so that we will pick up the compressed
//                              Server Infs in a different location than the Workstation compressed
//  06.22.95    Joe Holman      For now, we won't use compressed Cairo files.  Will change in July.
//                              INFs (due to the collision of names and difference with cdrom.w|s).
//  06.28.95    Joe Holman      Won't make CHECKED Server.
//  07.07.95    Joe Holman      For Cairo, we need to also look at the _layout.cai and
//                              _media.cai files
//                              for additional files (superset) that goes into Cairo.
//  08.03.95    Joe Holman      Allow Cairo to have compressed files -> note, build team needs to
//                              private 2 locations, one for Shell release and one for Cairo release,
//                              ie, \\x86fre\cdcomp$.
//  08.14.95    Joe Holman      Figure out if we copy the .dbg file for a particular file.
//  08.14.95    Joe Holman      Allow DBG files for Cairo.
//  08.23.95    Joe Holman      Add code to make tallying work with compressed/noncomp files and
//                              winn32 local source space needed.
//  10.13.95    Joe Holman      Get MAPISVC.INF and MDM*.INF from Workstation location.
//  10.25.95    Joe Holman      Put code in to use SetupDecompressOrCopyFile.
//  10.30.95    Joe Holman      Don't give errors for vmmreg32.dbg - this is a file given
//                              by Win95 guys.
//  11.02.95    Joe Holman      Allow multi-threaded support when SetupDecompressOrCopyFile
//                              is fixed.
//                              Pickup all for PPC on Cairo.
//  11.17.95    Joe Holman      Check for upgrade size.
//  11.30.95    Joe Holman      compare current dosnet.inf and txtsetup.sif values and error
//                              if we go over.  Search for //code here.
//  12.04.95    Joe Holman      Use Layout.inx instead of _layout.inx.
//  03.11.96    Joe Holman      Don't give errors on MFC*.dbg if missing, since no .dbgs
//                              provided.
//  04.05.96    Joe Holman      Add values for INETSRV and DRVLIB.NIC directories. Both of
//                              these get copied as local source.  Inetsrv is NEVER installed
//                              automatically (unless via an unattend file) and one card is
//                              small.  Thus, we will only add INETSRV and DRVLIB.NIC sizes
//                              to local source code below.
//                              and one or two of drvlib.nic MAY get installed.
//  04.19.96    Joe Holman      Add code to NOT count *.ppd files in order to reduce
//                              minimum disk space required.
//  09.10.96    Joe Holman      Add code that supports setup's new disk space calculation.
//                              Basically, we just need to provide values for each cluster
//                              size stored in dosnet.inf.
//  10.17.96    Joe Holman      Comment out MIPS code, but leave in for P7.
//  12.06.96    Joe Holman      Backported MSKK's DBCS changes.
//  01.20.97    Joe Holman      Take out PPC.
//  05.15.97    Joe Holman      Grovels layout.inf on release shares rather than file chked-in.
//  xx.xx.xx    Joe Holman      Allow files not to worry about .dbgs for to be in a file.
//  08.01.97    Joe Holman      Add code to check for 0 file size in layout.inf files.
//  08.26.97    Joe Holman      Add code to pick-up files for NEC PC-98 machine for JA.
//  10.16.97    Joe Holman      Added space calculation for .PNF files made
//                              during gui-mode setup.
//  11.07.97    Joe Holman      Add code to verify that a filename is 8.3.
//  01.26.98    Joe Holman      Since we are going to ship Enterprise Edition
//                              in addition to Workstation and Server,
//                              generalize the code to call files.exe 3 times
//                              in the script for each type of product.
//  07.06.98    Joe Holman      Change default cluster size to 32, instead of 16.
//  11.02.98    Joe Holman      Use new keys for local source and fresh install
//                              space requirements.
//  11.05.98    Joe Holman      Added check to look for 0 byte length files
//                              after copy.
//  12.04.98    Joe Holman      Added code for 4th floppy.
//  02.26.99    Joe Holman      Add code that turns dbg file copying off/on.
//  03.15.99    Joe Holman      Check that files in the drvindex.inf are not also in
//                              dosnet.inf, except for files on the bootfloppies.
//  05.13.99    Joe Holman      Change dbg/pdb copying to use INF provided on release
//                              shares.
//  08.20.99    Joe Holman      Remove Alpha.
//  xx.xx.xx    Joe Holman      Provide switch that flush bits to disk after copy, then does a DIFF.
//
//  Need to get space for:
//          - inside cab and zip files ++ 20M
//          - lang directory [ or maybe not, if we aren't going to install another lang] ++ 90M
//          - uniproc directory ++ 2M
//          - win9xmig ++2M
//          - win9xupg ++3M
//          - winntupg ++2M
//
//


#include <windows.h>

#include <setupapi.h>

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <ctype.h>

#define     MFL     256

CRITICAL_SECTION CriticalSection;

#define MAX_NUMBER_OF_FILES_IN_PRODUCT  14500        // # greater than # of files in product.
#define EIGHT_DOT_THREE                 8+1+3+1

struct  _tag {
    WORD    wNumFiles;
    BOOL    bCopyComp   [MAX_NUMBER_OF_FILES_IN_PRODUCT];
    char    wcFilesArray[MAX_NUMBER_OF_FILES_IN_PRODUCT][EIGHT_DOT_THREE];
    char    wcSubPath   [MAX_NUMBER_OF_FILES_IN_PRODUCT][EIGHT_DOT_THREE]; // used for debugging files
    BOOL    bCountBytes [MAX_NUMBER_OF_FILES_IN_PRODUCT];
    BOOL    bTextMode   [MAX_NUMBER_OF_FILES_IN_PRODUCT];
    BOOL    bCopyItToCD [MAX_NUMBER_OF_FILES_IN_PRODUCT];

};

BOOL    bNec98 = FALSE;
BOOL    bNec98LikeX86 = FALSE;

BOOL    bChecked = FALSE;

BOOL    bVerifyBits = FALSE;
BOOL    bGetSizeLater = TRUE;

struct _tag ix386;
struct _tag Nec98;

DWORD x86From351 = 0;
DWORD x86From400 = 0;
DWORD x86From500 = 0;


BOOL    hack;


BOOL    fX86, fNec98;


BOOL    bCopyCompX86 = FALSE;  // flag to tell if file shall be copied in its compressed format.
BOOL    bCopyCompNec98 = FALSE;

//
// Following are masks that correspond to the particular data in a DOS date
//

#define DOS_DATE_MASK_DAY    (WORD) 0x001f  // low  5 bits (1-31)
#define DOS_DATE_MASK_MONTH  (WORD) 0x01e0  // mid  4 bits (1-12)
#define DOS_DATE_MASK_YEAR   (WORD) 0xfe00  // high 7 bits (0-119)

//
// Following are masks that correspond to the particular data in a DOS time
//

#define DOS_TIME_MASK_SECONDS (WORD) 0x001f   // low  5 bits (0-29)
#define DOS_TIME_MASK_MINUTES (WORD) 0x07e0   // mid  6 bits (0-59)
#define DOS_TIME_MASK_HOURS   (WORD) 0xf800   // high 5 bits (0-23)

//
// Shift constants used for building/getting DOS dates and times
//

#define DOS_DATE_SHIFT_DAY   0
#define DOS_DATE_SHIFT_MONTH 5
#define DOS_DATE_SHIFT_YEAR  9

#define DOS_TIME_SHIFT_SECONDS  0
#define DOS_TIME_SHIFT_MINUTES  5
#define DOS_TIME_SHIFT_HOURS   11

//
// Macros to extract the data out of DOS dates and times.
//
// Note: Dos years are offsets from 1980.  Dos seconds have 2 second
//       granularity
//

#define GET_DOS_DATE_YEAR(wDate)     ( ( (wDate & DOS_DATE_MASK_YEAR) >>  \
                                               DOS_DATE_SHIFT_YEAR ) + \
                                       (WORD) 1980 )

#define GET_DOS_DATE_MONTH(wDate)    ( (wDate & DOS_DATE_MASK_MONTH) >> \
                                                DOS_DATE_SHIFT_MONTH )

#define GET_DOS_DATE_DAY(wDate)      ( wDate & DOS_DATE_MASK_DAY )

#define GET_DOS_TIME_HOURS(wTime)    ( (wTime & DOS_TIME_MASK_HOURS) >> \
                                                DOS_TIME_SHIFT_HOURS )

#define GET_DOS_TIME_MINUTES(wTime)  ( (wTime & DOS_TIME_MASK_MINUTES) >> \
                                                DOS_TIME_SHIFT_MINUTES )

#define GET_DOS_TIME_SECONDS(wTime)  ( (wTime & DOS_TIME_MASK_SECONDS) << 1 )

//  Paths loaded in from the command line.
//
char	szLogFile[MFL];
char    szProductName[MFL];

char	szX86Src[MFL];
char	szEnlistDrv[MFL];
char    szX86DstDrv[MFL];
char    szUnCompX86[MFL];
char    szUnCompNec98[MFL];
char    szNec98Src[MFL];

#define I386_DIR     "\\i386\\SYSTEM32"
#define NEC98_DIR    "\\NEC98\\SYSTEM32"
#define NETMON       "\\netmon"
#define I386_DIR_RAW "\\i386"
#define NEC98_DIR_RAW "\\NEC98"


#define idBase  0
#define idX86   1

HANDLE  hInfDosnet = NULL;
HANDLE  hInfLayout = NULL;
HANDLE  hInfDrvIndex = NULL;


#define NUM_EXTS 14
char * cExtra[] = { "acm", "ax", "cfm", "com", "cpl", "dll", "drv", "ds", "exe", "io", "ocx", "scr", "sys", "tsp" };


//	Tally up the # of bytes required for the system from the files included.
//

struct _ClusterSizes {

	DWORD	Kh1;
	DWORD	K1;
	DWORD	K2;
	DWORD	K4;
	DWORD	K8;
	DWORD	K16;
	DWORD	K32;
	DWORD	K64;
	DWORD	K128;
    DWORD   K256;

};

//  Cluster sizes for local source, ie. the ~ls directory.
//
struct _ClusterSizes  lX86;
struct _ClusterSizes  lNec98;

//  Cluster sizes for fresh install space.
//
struct _ClusterSizes  freshX86;
struct _ClusterSizes  freshNec98;

//  Cluster sizes for textmode savings.
//
struct _ClusterSizes  tX86;
struct _ClusterSizes  tNec98;



//DWORD   bytesX86;
//DWORD   bytesNec98;


//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;

void	GiveThreadId ( const CHAR * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void	Msg ( const CHAR * szFormat, ... ) {

	va_list vaArgs;

    EnterCriticalSection ( &CriticalSection );
    GiveThreadId ( "%s %ld:  ", szProductName, GetCurrentThreadId () );
	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
    LeaveCriticalSection ( &CriticalSection );
}


void Header(argv,argc)
char * argv[];
int argc;
{
    time_t t;
    char tmpTime[100];
    CHAR wtmpTime[200];

    Msg ( "\n=========== FILES ====================\n" );
	Msg ( "Log file                      : %s\n",    szLogFile );
    Msg ( "Product Name                  : %s\n",    szProductName );
    Msg ( "enlisted drive                : %s\n",    szEnlistDrv );
    Msg ( "x86 files                     : %s\n",    szX86Src);
    Msg ( "drive to put x86              : %s\n",    szX86DstDrv );
    Msg ( "uncompressed x86 files        : %s\n",    szUnCompX86 );
    if ( bNec98 ) {
        Msg ( "nec98 files                     : %s\n",    szNec98Src);
        Msg ( "uncompressed nec98 files        : %s\n",    szUnCompNec98 );
    }



    time(&t);
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "========================================\n\n");
}

void Usage( void ) {

    printf( "PURPOSE: Copies the system files that compose the product.\n");
    printf( "\n");
    printf( "PARAMETERS:\n");
    printf( "\n");
    printf( "[LogFile] - Path to append a log of actions and errors.\n");
    printf( "[ProductName] - product name\n" );
    printf( "[enlisted drive]- drive that is enlisted\n" );
	printf( "[files share] - location of x86 files.\n" );
    printf( "[dest path x86]   - drive to put files\n" );
    printf( "[uncompressed x86]   - drive to put files\n" );
    if ( bNec98 ) {
        printf( "[files share]- location of nec98 files\n" );
        printf( "[uncomp nec98]- location to get sizes from\n" );
    }
    printf( "\n"  );
}

char   dbgStr1[30];
char   dbgStr2[30];

BOOL    IsFileInSpecialWinnt32Directory ( char * szFileName ) {

    char szUpCasedName[MFL];
    int i;

    char * foo[] = {
            "WINNT32.EXE",
            "WINNT32A.DLL",
            "WINNT32U.DLL",
            "WINNT32.HLP",
            (char *) 0
            };

    strcpy ( szUpCasedName, szFileName );
    _strupr ( szUpCasedName );

    for ( i=0; foo[i] != 0; i++ ) {

        //Msg ( "Comparing:  %s vs. %s\n", szUpCasedName, foo[i] );

        if ( strstr ( szUpCasedName, foo[i] ) ) {
            return TRUE;       // file should be in this directory
        }

    }

    return FALSE;           // no, file doesn't go in the winnt32 directory
}

void  ShowMeDosDateTime ( CHAR * srcPath, WORD wDateSrc, WORD wTimeSrc,
                          CHAR * dstPath, WORD wDateDst, WORD wTimeDst ) {

    Msg ( "%s %02d.%02d.%02d %02d:%02d.%02d\n",
                srcPath,
                GET_DOS_DATE_MONTH(wDateSrc),
                GET_DOS_DATE_DAY(wDateSrc),
                GET_DOS_DATE_YEAR(wDateSrc),
                GET_DOS_TIME_HOURS(wTimeSrc),
                GET_DOS_TIME_MINUTES(wTimeSrc),
                GET_DOS_TIME_SECONDS(wTimeSrc)  );

    Msg ( "%s %02d.%02d.%02d %02d:%02d.%02d\n",
                dstPath,
                GET_DOS_DATE_MONTH(wDateDst),
                GET_DOS_DATE_DAY(wDateDst),
                GET_DOS_DATE_YEAR(wDateDst),
                GET_DOS_TIME_HOURS(wTimeDst),
                GET_DOS_TIME_MINUTES(wTimeDst),
                GET_DOS_TIME_SECONDS(wTimeSrc)  );
}


void Replay ( char * srcBuf, char * dstBuf, DWORD srcBytesRead, DWORD startIndex ) {

    DWORD i;

    for ( i = startIndex; (i < startIndex+5) && (i <= srcBytesRead); ++i ) {

        Msg ( "srcBuf[%ld] = %x, dstBuf[%ld] = %x\n", i, srcBuf[i], i, dstBuf[i] );
    }

}

BOOL    IsDstCompressed ( char * szPath ) {

    // Msg ( ">>> char %s: %c\n", szPath, szPath[strlen(szPath)-1] );

    if ( szPath[strlen(szPath)-1] == '_' ) {

        return(TRUE);
    }

    return (FALSE);

}


#define V_I386  "C:\\testi386"
#define V_NEC98 "C:\\testnec98"

BOOL    MyCopyFile ( char * fileSrcPath, char * fileDstPath ) {

    HANDLE          hSrc,   hDst;
    WIN32_FIND_DATA wfdSrc, wfdDst;
    BOOL            bDoCopy = FALSE;
    #define     NUM_BYTES_TO_READ 2048
    unsigned char srcBuf[NUM_BYTES_TO_READ];
    unsigned char dstBuf[NUM_BYTES_TO_READ];
    WORD srcDate, srcTime, dstDate, dstTime;
    DWORD   dwAttributes;

    char szTmpFile[MFL] = { '\0' };
    UINT uiRetSize = 299;
    char szJustFileName[MFL];
    char szJustDirectoryName[MFL];
    BOOL    b;

    //  Find the source file.
    //
    hSrc = FindFirstFile ( fileSrcPath, &wfdSrc );

    if ( hSrc == INVALID_HANDLE_VALUE ) {

        //  HACK:   Since the release shares put WINNT32.EXE in the WINNT32 directory
        //          instead of leaving it in the flat root, verify that if the fileSrcPath
        //          contains WINNT32.EXE we look in the WINNT32 dir also before error'ing out.
        //
        if ( IsFileInSpecialWinnt32Directory ( fileSrcPath ) ) {

             char    tmpSrcPath[MFL];

             strcpy ( tmpSrcPath, fileSrcPath );

             if ( strstr ( fileSrcPath, ".HLP" ) ||
                  strstr ( fileSrcPath, ".hlp" )    ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
             }
            else if ( strstr ( fileSrcPath, ".MSI" ) ||
                  strstr ( fileSrcPath, ".msi" )    ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.MSI" );
             }
            else if ( strstr ( fileSrcPath, "a.dll" ) ||
                      strstr ( fileSrcPath, "A.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
            }
            else if ( strstr ( fileSrcPath, "u.dll" ) ||
                      strstr ( fileSrcPath, "U.DLL" )   ) {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
            }
             else {
                 strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
             }

            hSrc = FindFirstFile ( tmpSrcPath, &wfdSrc );

            if ( hSrc == INVALID_HANDLE_VALUE ) {

                Msg ( "ERROR on fileSrcPath(tmpSrcPath) = %s, gle = %ld\n", tmpSrcPath, GetLastError() );
                return (FALSE);

            }
            else {

                strcpy ( fileSrcPath, tmpSrcPath );
            }

        }
        else {

            Msg ( "ERROR on fileSrcPath = %s, gle = %ld\n", fileSrcPath, GetLastError() );
            return (FALSE);
        }
    }

    //  Find the destination file.
    //
    hDst = FindFirstFile ( fileDstPath, &wfdDst );

    if ( hDst == INVALID_HANDLE_VALUE ) {

        DWORD   gle;

        gle = GetLastError();

        if ( gle == ERROR_FILE_NOT_FOUND ) {

            //  The file doesn't exist on the destination.  Do the copy.
            //
            bDoCopy = TRUE;
        }
        else {

            //  Got another kind of error, report this problem.
            //
            Msg ( "ERROR FindFirstFile fileDstPath = %s, gle = %ld\n", fileDstPath, gle );
            FindClose ( hSrc );
            return ( FALSE );
        }
    }
    else {

        //  Both the src and dst exist.
        //  Let's see if the src is NEWER than the dst, if so, copy.
        //
        //
        b = FileTimeToDosDateTime ( &wfdSrc.ftLastWriteTime, &srcDate, &srcTime );

        b = FileTimeToDosDateTime ( &wfdDst.ftLastWriteTime, &dstDate, &dstTime );

        if ( (srcDate != dstDate) || (srcTime != dstTime) ) {

            ShowMeDosDateTime ( fileSrcPath, srcDate, srcTime, fileDstPath, dstDate, dstTime );

            bDoCopy = TRUE;
        }
    }

    //  Additional check, verify the file sizes are the same.
    //
    if ( wfdSrc.nFileSizeLow != wfdSrc.nFileSizeLow ) {
        bDoCopy = TRUE;
    }
    if ( wfdSrc.nFileSizeHigh != wfdDst.nFileSizeHigh ) {
        bDoCopy = TRUE;
    }


    if ( bDoCopy ) {

        BOOL    b;
        DWORD   gle;

        //  Make sure our destination is never READ-ONLY.
        //
        b = SetFileAttributes ( fileDstPath, FILE_ATTRIBUTE_NORMAL );

        if ( !b ) {

            //  Don't error if the file doesn't exist yet.
            //

            if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {

                Msg ( "ERROR: SetFileAttributes: gle = %ld, %s\n", GetLastError(), fileDstPath);
            }
        }

        b = CopyFile ( fileSrcPath, fileDstPath, FALSE );

        if ( b ) {

            Msg ( "Copy:  %s >>> %s  [OK]\n", fileSrcPath, fileDstPath );
        }
        else {
            Msg ( "ERROR Copy:  %s >>> %s, gle = %ld\n", fileSrcPath, fileDstPath, GetLastError() );
        }

    }
    else {
        Msg ( "%s %d %d %ld %ld +++ %s %d %d %ld %ld [SAME]\n", fileSrcPath, srcDate, srcTime, wfdSrc.nFileSizeLow, wfdSrc.nFileSizeHigh, fileDstPath , dstDate, dstTime, wfdDst.nFileSizeLow, wfdDst.nFileSizeHigh );
    }

    FindClose ( hSrc );
    FindClose ( hDst );


    //  Make sure our destination is never READ-ONLY.
    //
    b = SetFileAttributes ( fileDstPath, FILE_ATTRIBUTE_NORMAL );

    if ( !b ) {

       Msg ( "ERROR: SetFileAttributes: gle = %ld, %s\n", GetLastError(), fileDstPath);
    }

    //  Let's make sure that the file is not 0 bytes in length, due to some
    //  network problem.
    //
    hDst = FindFirstFile ( fileDstPath, &wfdDst );

    if ( hDst == INVALID_HANDLE_VALUE ) {

        Msg ( "ERROR: Can't get size of %s, gle=%ld\n", fileDstPath, GetLastError() );
    }
    else {

        if ( wfdDst.nFileSizeLow == 0 && wfdDst.nFileSizeHigh == 0 ) {

            Msg ( "ERROR:  Warning:  %s is 0 bytes in length !\n", fileDstPath );
        }

        FindClose ( hDst );
    }


    //  Do bit verification here on all files coming into MyCopyFile.
    //
    if ( bVerifyBits ) {

        BOOL    bNoError = TRUE;
        HANDLE  SrcFileHandle, DstFileHandle;
        BOOL    b;
        BY_HANDLE_FILE_INFORMATION  srcFileInformation;
        BY_HANDLE_FILE_INFORMATION  dstFileInformation;
        DWORD   srcBytesRead;
        DWORD   dstBytesRead;
        DWORD   i;
        DWORD   totalBytesRead = 0;
#define OFFSET_FILENAME 0x3C    // address of file name in diamond header.
                                // >>> use struct later instead of this hack.
#define OFFSET_PAST_FILENAME  8 + 1 + 3 + 2     // we only use 8.3 filenames.
        char    unCompressedFileName[OFFSET_PAST_FILENAME];

        BOOL    bIsDstCompressed = FALSE;
        DWORD   dw;
        char    szExpandToDir[MFL];
        char    target[MFL];
        int     iRc;
        unsigned short unicodeFileLocation[MFL];
        unsigned short unicodeTargetLocation[MFL];

        bIsDstCompressed = IsDstCompressed ( fileDstPath );

        if ( bIsDstCompressed ) {

            FILE * fHandle;
            char    szEndingFileName[MFL];

            //  Figure out where source should be from.
            //  Ie., we need to figure out the uncompressed path from the compressed path.
            //

            if ( fileDstPath[0] == szX86DstDrv[0]  ) {

                //  We are working with Workstation binaries.
                //

                if ( strstr ( fileSrcPath, szX86Src ) ) {

                    strcpy ( fileSrcPath, szX86Src );
                    strcpy ( szExpandToDir, V_I386 );

                }
                else {

                    Msg ( "ERROR:  couldn't determined location for:  %s\n", fileSrcPath );
                    bNoError = FALSE;
                    goto cleanup0;
                }

            }

            else {
                Msg ( "ERROR:  couldn't determined drive for:  %s\n", fileDstPath );
                    bNoError = FALSE;
                    goto cleanup0;
            }


            //  NOTE:   At this point, fileSrcPath ONLY has a path, it now has NO filename !
            //


            // Find the expanded file name from the compressed file.
            //

            fHandle = fopen ( fileDstPath, "rb" );
            if ( fHandle == NULL) {
		        Msg ( "ERROR Couldn't open file with fopen to find expanded name: %s\n", fileDstPath );
                bNoError = FALSE;
                goto cleanup0;
            }
            else {

                size_t bytesRead;
                int     location;

                location = fseek ( fHandle, OFFSET_FILENAME, SEEK_SET );

                if ( location != 0 ) {

                    Msg ( "fseek ERROR\n" );
                    bNoError = FALSE;
                    fclose ( fHandle );
                    goto cleanup0;
                }

                bytesRead = fread ( unCompressedFileName, 1, OFFSET_PAST_FILENAME, fHandle );

/***
for ( i = 0; i < bytesRead; ++i ) {
    printf ( "%X(%c) ", buffer[i], buffer[i] );
}
printf ( "\n" );
***/

                if ( bytesRead != OFFSET_PAST_FILENAME ) {

                    Msg ( "ERROR: bytesRead = %x not %x\n", bytesRead, OFFSET_PAST_FILENAME );
                    bNoError = FALSE;
                    fclose ( fHandle );
                    goto cleanup0;
                }

                fclose ( fHandle );

            }

            //  Expand the file.
            //

            sprintf ( target, "%s\\%s", szExpandToDir, unCompressedFileName );

            iRc = MultiByteToWideChar (   CP_ACP,
                                    MB_PRECOMPOSED,
                                    fileDstPath,
                                    strlen ( fileDstPath )+1,
                                    unicodeFileLocation,
                                    MFL/2 );

            if ( !iRc ) {

                Msg ( "MultiByteToWideChar: ERROR, gle = %ld, %s\n", GetLastError(), fileDstPath );
            }

            iRc = MultiByteToWideChar (   CP_ACP,
                                    MB_PRECOMPOSED,
                                    target,
                                    strlen ( target )+1,
                                    unicodeTargetLocation,
                                    MFL/2 );
            if ( !iRc ) {

                Msg ( "MultiByteToWideChar: ERROR, gle = %ld, %s\n", GetLastError(), target );
            }

            dw = SetupDecompressOrCopyFileW (
                                    unicodeFileLocation,
                                    unicodeTargetLocation,
                                    NULL );

            if ( dw ) {

                Msg ( "ERROR SetupDecompressOrCopyFile, dw = %d, fileDstPath=%s, target=%s\n",
                        dw, fileDstPath, target );
                bNoError = FALSE;
                goto cleanup0;
            }
            else {
                Msg ( "SetupDecompressOrCopyFile:  %s >> %s  [OK]\n", fileDstPath, target );
            }


            //  Put the Source and Destination paths and filenames back together
            //  now so we can do the file compare.
            //

            strcat ( fileSrcPath, "\\" );
            strcat ( fileSrcPath, unCompressedFileName );

            sprintf ( fileDstPath, "%s\\%s", szExpandToDir, unCompressedFileName );


        }

        SrcFileHandle = CreateFile ( fileSrcPath,
                        GENERIC_READ /*| FILE_EXECUTE*/,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                        NULL);

        if ( SrcFileHandle == INVALID_HANDLE_VALUE) {

            Msg ( "ERROR verify:  Couldn't open source:  %s, gle = %ld\n", fileSrcPath, GetLastError() );
            bNoError = FALSE;
            goto cleanup0;
        }

        DstFileHandle = CreateFile ( fileDstPath,
                        GENERIC_READ /*| FILE_EXECUTE*/,
                        FILE_SHARE_READ /*| FILE_SHARE_DELETE*/,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                        NULL);

        if ( DstFileHandle == INVALID_HANDLE_VALUE) {

            Msg ( "ERROR verify:  Couldn't open destination:  %s, gle = %ld\n", fileDstPath, GetLastError() );
            bNoError = FALSE;
            CloseHandle ( SrcFileHandle );
            goto cleanup0;
        }

        //GetDiskFreeSpace();  // get sector size.  // need to use this sector size in reads due to above NO_BUFFERING flag.



        b = GetFileInformationByHandle ( SrcFileHandle, &srcFileInformation );

        if ( !b ) {

            Msg ( "ERROR:  GetFileInformationByHandle on src, gle = %ld\n", GetLastError() );
            bNoError = FALSE;
            srcFileInformation.nFileSizeLow = 0;
            goto cleanup1;
        }


        b = GetFileInformationByHandle ( DstFileHandle, &dstFileInformation );

        if ( !b ) {

            Msg ( "ERROR:  GetFileInformationByHandle on dst, gle = %ld\n", GetLastError() );
            bNoError = FALSE;
            dstFileInformation.nFileSizeLow = 0;
            goto cleanup1;
        }


        //  Make sure the files are the same size.
        //

        if ( srcFileInformation.nFileSizeLow != dstFileInformation.nFileSizeLow ) {

            Msg ( "ERROR:  file size different:  %s %ld  %s %ld\n", fileSrcPath, srcFileInformation.nFileSizeLow, fileDstPath, dstFileInformation.nFileSizeLow );
            bNoError = FALSE;
            goto cleanup1;
        }

        //  Compare the bits.
        //

        totalBytesRead = 0;
        while ( 1 ) {

            b = ReadFile ( SrcFileHandle, &srcBuf, NUM_BYTES_TO_READ, &srcBytesRead, NULL );

            if ( !b ) {

                Msg ( "ERROR:  ReadFile src, gle = %ld\n", GetLastError() );
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            b = ReadFile ( DstFileHandle, &dstBuf, NUM_BYTES_TO_READ, &dstBytesRead, NULL );

            if ( !b ) {

                Msg ( "ERROR:  ReadFile dst, gle = %ld\n", GetLastError() );
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            //  Read # of bytes need to be the same.
            //
            if ( srcBytesRead != dstBytesRead ) {

                Msg ( "ERROR:  file read sizes different:  %ld vs. %ld\n", srcBytesRead, dstBytesRead );
                bNoError = FALSE;
                goto cleanup1;
                break;
            }

            //  Successfully read to end of file, we can break out now.
            //
            if ( srcBytesRead == 0 || dstBytesRead == 0 ) {

                if ( totalBytesRead != srcFileInformation.nFileSizeLow ) {

                    Msg ( "ERROR:   totalBytesRead = %ld notequal srcFileInformation.nFileSizeLow = %ld\n",
                                    totalBytesRead, srcFileInformation.nFileSizeLow );
                    bNoError = FALSE;
                    goto cleanup1;
                }

                break;
            }

            totalBytesRead += srcBytesRead;

            for ( i = 0; i < srcBytesRead; ++i ) {

                if ( srcBuf[i] != dstBuf[i] ) {

                    Msg ( "ERROR:  srcBuf %d != dstBuf %d, i = %ld  srcBytesRead = %ld   totalBytesRead = %ld  %s %s \n", srcBuf[i], dstBuf[i], i, srcBytesRead, totalBytesRead, fileSrcPath, fileDstPath );
                    bNoError = FALSE;
                    Replay ( srcBuf, dstBuf, srcBytesRead, i );
                    goto cleanup1;
                }

            }

            //Msg ( "%s %ld of %ld examined...\n", fileSrcPath, totalBytesRead, srcFileInformation.nFileSizeLow );

        }


        //  Close the file handles.
        //

cleanup1:;
        CloseHandle ( SrcFileHandle );
        CloseHandle ( DstFileHandle );

        Msg ( "Verify:  %s >>> %s [OK]\n", fileSrcPath, fileDstPath );

cleanup0:;

        //  If the file is compressed, ie. expanded, and the there wasn't an error
        //  comparing, get rid of the expanded file so it doesn't take up any space.
        //  But, if there was an error, leave it around for examination purposes.
        //
        if ( bIsDstCompressed && bNoError ) {

            char szDeleteFile[MFL];
            BOOL    b;

            sprintf ( szDeleteFile, "%s\\%s", szExpandToDir, unCompressedFileName );
            b = DeleteFile ( szDeleteFile );

            if ( !b ) {
                Msg ( "ERROR:  DeleteFile FAILED %s, gle = %ld\n", szDeleteFile, GetLastError() );
            }

        }

    }


    return (TRUE);
}



#define FILE_SECTION_BASE  "[SourceDisksFiles]"
#define FILE_SECTION_X86   "[SourceDisksFiles.x86]"


BOOL    CreateDir ( char * wcPath ) {

    BOOL    b;
    char    cPath[MFL];
    char    cPath2[MFL];
    int     iIndex = 0;
    char * ptr=wcPath;

    // Msg ( "CreateDir:  wcPath = %s\n", wcPath );

    do {

        cPath[iIndex]   = *wcPath;
        cPath[iIndex+1] = '\0';

        //Msg ( "cPath = %s\n", cPath );

        if ( cPath[iIndex] == '\\' || cPath[iIndex] == '\0' ) {

            if ( iIndex <= 2 ) {
                //Msg ( "skpdrv:  iIndex = %d\n", iIndex );
                goto skipdrv;
            }

            strcpy ( cPath2, cPath );
            cPath2[iIndex] = '\0';

            //Msg ( "Create with: >>>%s<<<\n", cPath2 );

            b = CreateDirectory ( cPath, NULL );

            if ( !b ) {

                DWORD dwGle;

                dwGle = GetLastError();

                if ( dwGle != ERROR_ALREADY_EXISTS ) {
                    Msg ( "ERROR CreateDirectory gle = %ld, wcPath = %s\n", dwGle, ptr );
                    return(FALSE);
                }
            }
            else {

                Msg ( "Made dir:  %s\n", cPath );
            }

            if ( cPath[iIndex] == '\0' ) {
                break;
            }
        }

skipdrv:;
        ++iIndex;
        ++wcPath;


    } while ( 1 );

    return(TRUE);

}

BOOL    CreateDestinationDirs ( void ) {


    CHAR   dstDirectory[MFL];


    //  Create the directories to compare the bits, used later in MyCopyFile().
    //
    CreateDir ( V_I386 );

    if ( bNec98 ) {

        CreateDir ( V_NEC98 );

    }


    //  Create the %platform%\system32 directories.
    //
    sprintf ( dstDirectory, "%s%s", szX86DstDrv, I386_DIR );    CreateDir ( dstDirectory );
    if ( bNec98 ) {
        sprintf ( dstDirectory, "%s%s", szX86DstDrv, NEC98_DIR );   CreateDir ( dstDirectory );
    }

    return(TRUE);

}

VOID    MakeCompName ( const char * inFile, char * outFile ) {

    unsigned i;
    unsigned period;

    strcpy( outFile, inFile );
    for ( period=(unsigned)(-1), i = 0 ; i < strlen(inFile); i++ ) {

        if ( inFile[i] == '.' ) {
            period = i;
        }
    }
    if ( period == (strlen(inFile)-4) ) {

        outFile[strlen(outFile)-1] = '_';
    }
    else if ( period == (unsigned)(-1)) {

        strcat ( outFile, "._");
    }
    else {

        strcat ( outFile, "_");
    }

}


DWORD CopyX86 ( void ) {

    char    fileSrcPath[256];
    char    fileDstPath[256];
    DWORD   i;

    fX86 = FALSE;

    Msg ( "CopyX86...\n" );

    for ( i = 0; i < ix386.wNumFiles; ++i ) {


        //Msg ( "0.working on %ld of %ld files: %s\n", i, ix386.wNumFiles, ix386.wcFilesArray[i] );

        //  Copy the system file.
        //
        if ( !ix386.bCopyItToCD[i] ) {

            Msg ( "Not going to copy inner cab file to CD:  %s\n", ix386.wcFilesArray[i] );
            goto JustX86;
        }

        if ( ix386.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( ix386.wcFilesArray[i], szCompressedName );
            sprintf ( fileSrcPath, "%s\\%s",       szX86Src, szCompressedName );
            sprintf ( fileDstPath, "%s\\i386\\%s", szX86DstDrv, szCompressedName );

            Msg ( "compressed source Path = %s\n", fileSrcPath );
        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",       szX86Src, ix386.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\i386\\%s", szX86DstDrv, ix386.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );

JustX86:;

    }

    fX86 = TRUE;

    return (TRUE);

}

DWORD CopyNec98 (  void ) {

    char    fileSrcPath[256];
    char    fileDstPath[256];
    DWORD   i;

    fNec98 = FALSE;

    Msg ( "CopyNec98...\n" );

    for ( i = 0; i < Nec98.wNumFiles; ++i ) {

        //  Copy the system file.
        //

        if ( !Nec98.bCopyItToCD[i] ) {

            Msg ( "Not going to copy inner cab file to CD:  %s\n", Nec98.wcFilesArray[i] );
            goto JustNec98;
        }

        if ( Nec98.bCopyComp[i] ) {

            char    szCompressedName[256];

            MakeCompName ( Nec98.wcFilesArray[i], szCompressedName );
            sprintf ( fileSrcPath, "%s\\%s",       szNec98Src, szCompressedName );
            sprintf ( fileDstPath, "%s\\Nec98\\%s", szX86DstDrv, szCompressedName );

            Msg ( "compressed source Path = %s\n", fileSrcPath );
        }
        else {

            sprintf ( fileSrcPath, "%s\\%s",       szNec98Src, Nec98.wcFilesArray[i] );
            sprintf ( fileDstPath, "%s\\Nec98\\%s", szX86DstDrv, Nec98.wcFilesArray[i] );
        }

        MyCopyFile ( fileSrcPath, fileDstPath );

JustNec98:;

    }

    fNec98 = TRUE;

    return (TRUE);

}

BOOL    CopyTheFiles ( void ) {

    DWORD tId;
    HANDLE hThread;

    hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyX86, NULL, 0, &tId );
    if ( hThread == NULL ) {
        Msg ( "x86 CreateThread ERROR gle = %ld\n", GetLastError() );
    }

    //  Assume TRUE here so if we don't copy Nec98 files, our while loop won't
    //  be dependant on this variable.
    //
    fNec98 = TRUE;
    if ( bNec98 ) {

        hThread = CreateThread ( NULL, 0, (LPTHREAD_START_ROUTINE) CopyNec98, NULL, 0, &tId );
        if ( hThread == NULL ) {
            Msg ( "Nec98 CreateThread ERROR gle = %ld\n", GetLastError() );
        }

    }

    while ( fX86     == FALSE ||
            fNec98   == FALSE       ) {

        Sleep ( 1000 );

    }

    return(TRUE);
}

#define FILE_SECTION_NOT_USED 0xFFFF

DWORD   dwInsideSection = FILE_SECTION_NOT_USED;

DWORD   FigureSection ( char * Line ) {

    Msg ( "FigureSection on:  %s\n", Line );

    if ( strstr ( Line, FILE_SECTION_BASE )  ) {

        dwInsideSection = idBase;

    }
    else
    if ( strstr ( Line, FILE_SECTION_X86 ) ) {

        dwInsideSection = idX86;

    }
    else {

        dwInsideSection = FILE_SECTION_NOT_USED;
    }

    Msg ( "dwInsideSection = %x\n", dwInsideSection );
    return(dwInsideSection);

}
char * SuckName ( const char * Line ) {

    static char   szSuckedName[MFL];

    DWORD   dwIndex = 0;

    //  Copy the file name until a space is encountered.
    //
    while ( *Line != ' ' ) {

        szSuckedName[dwIndex] = *Line;
        szSuckedName[dwIndex+1] = '\0';

        ++Line;
        ++dwIndex;
    }

    return szSuckedName;
}

char * SuckSubName ( const char * Line ) {

    static char   szSub[150];
    DWORD       i = 0;

    char    * sPtr;
    char    * ePtr;

    Msg ( "SuckSubName Line = %s\n", Line );

    //  Find the = sign in the line.
    //
    sPtr = strchr ( Line, '=' );
    if ( sPtr == NULL ) {

        Msg ( "SuckSubName ERROR, couldn't find '=' character in string:  %s\n", Line );
        strcpy ( szSub, "" );
        return (szSub);
    }

    //  Go past the '=' and 'space' character.
    //
    ++sPtr;
    ++sPtr;

    //Msg ( "sPtr = >>>%s<<<\n", sPtr );

    //  Find the , character, this is the end of the string.
    //
    ePtr = strchr ( Line, ',' );
    if ( ePtr == NULL ) {

        Msg ( "SuckSubName ERROR, couldn't find ',' character in string:  %s\n", Line );
        strcpy ( szSub, "" );
        return (szSub);
    }

    //  Copy the string.

    do {

        szSub[i] = *sPtr;

        ++i;
        ++sPtr;

    } while ( sPtr < ePtr );

    szSub[i] = '\0';

    //Msg ( "szSub = >>>%s<<<\n\n", szSub );
    return szSub;

}

void    ShowX86 ( void ) {

    int i;

    for ( i = 0; i < ix386.wNumFiles; ++i ) {

        Msg ( "%d  %s  Comp=%d CopyItToCD=%d\n",
                i,
                ix386.wcFilesArray[i],
                ix386.bCopyComp[i],
                ix386.bCopyItToCD[i] );

    }

}
void    ShowNec98 ( void ) {

    int i;

    for ( i = 0; i < Nec98.wNumFiles; ++i ) {

        Msg ( "%d  %s  Comp=%d\n",
                i,
                Nec98.wcFilesArray[i],
                Nec98.bCopyComp[i] );

    }

}
void    AddFileToX86 ( const char * fileName, BOOL bCopyComp, BOOL bTextMode, BOOL bCopyItToCD ) {

    ix386.bCopyComp[ix386.wNumFiles] = bCopyComp;
    ix386.bCountBytes[ix386.wNumFiles] = bGetSizeLater;
    ix386.bTextMode[ix386.wNumFiles] = bTextMode;
    ix386.bCopyItToCD[ix386.wNumFiles] = bCopyItToCD;



    strcpy ( ix386.wcFilesArray[ix386.wNumFiles], fileName );

    ++ix386.wNumFiles;

    if ( ix386.wNumFiles > MAX_NUMBER_OF_FILES_IN_PRODUCT ) {

        Msg ( "FATAL ERROR:   Increase MAX_NUM in Files.C\n" );
        exit ( 1 );
    }
}

void    AddFileToNec98 ( const char * fileName, BOOL bCopyComp, BOOL bTextMode, BOOL bCopyItToCD ) {

    Nec98.bCopyComp[Nec98.wNumFiles] = bCopyComp;
    Nec98.bCountBytes[Nec98.wNumFiles] = bGetSizeLater;
    Nec98.bTextMode[Nec98.wNumFiles] = bTextMode;
    Nec98.bCopyItToCD[Nec98.wNumFiles] = bCopyItToCD;

    strcpy ( Nec98.wcFilesArray[Nec98.wNumFiles], fileName );

    ++Nec98.wNumFiles;

    if ( Nec98.wNumFiles > MAX_NUMBER_OF_FILES_IN_PRODUCT ) {

        Msg ( "FATAL ERROR:   Increase MAX_NUM in Files.C\n" );
        exit ( 1 );
    }
}

void CopyCompressedFile ( const char * Line ) {

    const char    * Ptr = Line;
    DWORD   i = 0;

    #define COMP_FIELD 6


    //  Let's assume that we will compress the files and have to prove that we don't.
    //
    bCopyCompX86 = TRUE;
    bCopyCompNec98 = TRUE;

    while ( *Line != '\0' ) {

        //  If we are at the correct field,
        //  then stop counting fields.
        //
        if ( i == COMP_FIELD ) {
            break;
        }

        //  Found another field, increment our counter.
        //
        if ( *Line == ',' ) {

            ++i;
        }

        //  Look at next char.
        //
        ++Line;
    }

    if ( i != COMP_FIELD ) {

        Msg ( "CopyCompressedFile ERROR:  we are out of while loop, but didn't find the field >>> %s\n", Ptr );
    }

    //  Determine if we should keep the file compressed or not.
    //
    switch ( *Line ) {

        case '_' :

            //  Indicator that we do NOT want this file compressed.
            //

            bCopyCompX86   = FALSE;
            bCopyCompNec98 = FALSE;
            break;

        case 'x' :
        case 'X' :
        case '1' :
        case '2' :
        case '3' :
        case '4' :

            //  do nothing...

            break;

        case ',' :

            //  do nothing, there is nothing in the field, meaning get compressed files.
            //

            break;

        default :

            Msg ( "CopyCompressedFile ERROR: *Line default char >>%c<<\n", *Line );
    }

}


#define X86_F     0
#define NEC98_F   4
#define DBGS_AND_NON_INSTALLED    6


//  Verify that the files line in layout.inf has a file space
//  associated with it, so if it ever used in optional components it
//  will be added up.
//
void    CheckSpace ( char * Line, char * Location, char * fileName ) {

    char    tLine[MFL];
    int     i, val;

    char * sPtr = Line;

    int     numCommas = 0;

    //Msg ( "CheckSpace:  Line = %s", Line );

    while ( 1 ) {

        if ( *sPtr == ',' ) {
            ++numCommas;
        }

        if ( numCommas == 2 ) {

            break;
        }

        ++sPtr;

    }

    //  At this point, we are pointing to the 2nd comma.
    //  So, let's go one char further.
    //
    ++sPtr;

    //  Copy the string until we get to the next comma.
    //
    strcpy ( tLine, sPtr );
    sPtr = tLine;

    while ( 1 ) {

        if ( *sPtr == ',' ) {

            *sPtr = '\0';
            break;
        }
        else {
            ++sPtr;
        }
    }


    val = atoi ( tLine );

    if ( val > 0 ) {

        //Msg ( "val = %d >>> Line = %s", val, Line );
    }
    else {

        if ( !strstr ( Line, "desktop.ini" ) ) {
            Msg ( "CheckSpace ERROR - Tell build lab to run INFSIZE.EXE:  location=%s, val = %d, Line = >>>%s<<<, fileName = %s\n", Location, val, Line, fileName );
        }
    }


}

void    CheckLength ( char * Line ) {


    if ( strlen ( Line ) > 12 ) {

            Msg ( "ERROR CheckLength - file name is NOT an 8.3 DOS filename - tell the owner of this file to shorten it's filename length:  %s\n", Line );

    }

    //  Check for the optional . part.
    //
    //  tbd

    //  Check for the optional 3 part.
    //
    //  tbd

}

BOOL    TextMode ( const char * fileName ) {

    //  Determine if this file has a 0 in the xth column which denotes
    //  it will be moved during textmode on a single partition scenario.
    //  If it has a 0, return TRUE to denote it gets moved on a fresh
    //  installed where ~ls is on the same partition that the %windir%
    //  will be on.
    //

    //const char    * Ptr = Line;
    DWORD         i = 0;
    BOOL            b;
    INFCONTEXT  ic;
    CHAR        returnBuffer[MFL];
    DWORD       dwRequiredSize;

    #define SDF     "SourceDisksFiles"
    #define SDF_X86 "SourceDisksFiles.x86"

    #define TEXTMODE_FIELD 9

    b = SetupFindFirstLine (    hInfLayout,
                                SDF,
                                fileName,
                                &ic );


    if ( !b ) {
        b = SetupFindFirstLine (    hInfLayout,
                                SDF_X86,
                                fileName,
                                &ic );

        if ( !b ) {

           if ( !strstr ( fileName, "usetup.exe" ) ) {

                    Msg ( "ERROR: TextMode: SetupFindFirstLine >>%s<< not found in SourceDiskFiles[.x86]\n", fileName, SDF );
                    return (FALSE);
           }

        }

    }
    else {

       //  Get the 9th field
       //
       b = SetupGetStringField ( &ic,
                                 TEXTMODE_FIELD,
                                 (LPSTR) &returnBuffer,
                                 sizeof ( returnBuffer ),
                                 &dwRequiredSize );

       if ( !b ) {

          Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
       }
       else {

          if ( returnBuffer[0] == '0' ) {


                Msg ( "file is copied during textmode:  %s\n", fileName );
                return (TRUE);

            }
            else {

                Msg ( "file is NOT copied during textmode:  %s\n", fileName );
                return (FALSE);

            }

       }
    }

    return (FALSE);

// herehere
/****

    Msg ( "4.1.hInfLayout = %ld\n", hInfLayout );
    Msg ( "the Line:%s\n", Line );
    while ( *Line != '\0' ) {

        //  If we are at the correct field,
        //  then stop counting fields.
        //
        if ( i == TEXTMODE_FIELD ) {
            //++Line;
            Msg ( "we are at the correct field, stop counting...\n" );
            break;
        }

        //  Found another field, increment our counter.
        //
        if ( *Line == ',' ) {

            Msg ( "found another field, increment our counter...\n" );
            ++i;
        }

        //  Look at next char.
        //
        ++Line;
        Msg ( "now pointing at:%s\n", Line );
    }

    Msg ( "we're at:%s\n", Line );
    Msg ( "4.2hInfLayout = %ld\n", hInfLayout );

    if ( i == TEXTMODE_FIELD ) {

        if ( *Line == '0' ) {

            Msg ( "TextMode:  This file is copied during textmode:  %s\n", Ptr );
            return (TRUE);
        }
        else {
            Msg ( "TextMode (*Line = %c):  This file is NOT copied during textmode:  %s\n", *Line, Ptr );
        }
    }
    else {
        Msg ( "TextMode Warning:  we are out of while loop, but didn't find the field >>> %s\n", Ptr );
    }
    Msg ( "4.3hInfLayout = %ld\n", hInfLayout );

    return (FALSE);

***/
}

void    CheckSpaceAndLength ( char * Line, char * Location, char * fileName ) {

    CheckSpace ( Line, Location, fileName );
    //CheckLength ( Line );

}



void AddFiles ( char * fileName, DWORD dwPlatform, BOOL bCopyItToCD ) {

    CHAR    Line[MFL];
    BOOL    bTextMode = FALSE;
    BOOL    b;
    DWORD   dwRequiredSize;
    INFCONTEXT  ic;

    bCopyCompX86   = FALSE;
    bCopyCompNec98 = FALSE;

    switch ( dwPlatform ) {

    case X86_F :

        Msg ( "AddToX86Files:  %s\n", fileName );

        //  Get the entire string.
        //

        b = SetupGetLineText ( NULL,
                               hInfLayout,
                               SDF,
                               fileName,
                               (LPSTR) &Line,
                               sizeof ( Line ),
                               &dwRequiredSize );


        if ( !b ) {

            b = SetupGetLineText ( NULL,
                               hInfLayout,
                               SDF_X86,
                               fileName,
                               (LPSTR) &Line,
                               sizeof ( Line ),
                               &dwRequiredSize );

            if ( !b ) {

                if ( strstr ( fileName, "driver.cab" ) ||
                     strstr ( fileName, "drvindex.inf" )  ) {

                    goto AddX86;
                }

                Msg ( "ERROR: 1.SetupGetLineText not found in %s for %s, gle=%ld, dwRequiredSize = %ld\n", "SourceDisksFiles[.x86]", fileName, GetLastError(), dwRequiredSize );
                break;
            }
        }

        Msg ( "Line:>>%s<<\n", Line );

        CheckSpaceAndLength  ( Line, "x86", fileName );

        CopyCompressedFile ( Line );

        bTextMode = TextMode ( fileName );

AddX86:
        CheckLength ( fileName );
        AddFileToX86 ( fileName, bCopyCompX86, bTextMode, bCopyItToCD );

        break;

    case NEC98_F :

        Msg ( "AddToNecFiles:  %s\n", fileName );

            //  Get the entire string.
            //

            b = SetupGetLineText ( NULL,
                                   hInfLayout,
                                   SDF,
                                   fileName,
                                   (LPSTR) &Line,
                                   sizeof ( Line ),
                                   &dwRequiredSize );


            if ( !b ) {

                b = SetupGetLineText ( NULL,
                                   hInfLayout,
                                   SDF_X86,
                                   fileName,
                                   (LPSTR) &Line,
                                   sizeof ( Line ),
                                   &dwRequiredSize );

                if ( !b ) {

                    if ( strstr ( fileName, "driver.cab" ) ||
                         strstr ( fileName, "drvindex.inf" )  ) {

                        goto AddNec98;
                    }

                    Msg ( "ERROR: 3.SetupGetLineText not found in %s for %s, gle=%ld, dwRequiredSize = %ld\n", "SourceDisksFiles[.x86]", fileName, GetLastError(), dwRequiredSize );

                    break;
                }
            }



        Msg ( "Line:>>%s<<\n", Line );

        CheckSpaceAndLength  ( Line, "nec", fileName );

        CopyCompressedFile ( Line );

        bTextMode = TextMode ( fileName );

AddNec98:;
        CheckLength ( fileName );
        AddFileToNec98 ( fileName, bCopyCompNec98, bTextMode, bCopyItToCD );

        break;

    default :

        Msg ( "ERROR:  AddFiles - uknown platform %ld\n", dwPlatform );
    }

}


BOOL    PlatformFilesToCopy ( char * szInfPath, DWORD dwPlatform ) {

    CHAR    infFilePath[MFL];
    BOOL    b;
    DWORD   dwRequiredSize;
    INFCONTEXT  ic;
    CHAR    returnBuffer[MAX_PATH];
    #define FILES_SECTION "Files"
    #define FILES_SECTION_DRIVER "driver"

    Msg ( "\n\n\n" );

    Msg ( "PlatformFilesToCopy:  szInfPath = %s, dwPlatform = %ld\n", szInfPath, dwPlatform );

    //  Open up a handle to dosnet.inf
    //
    sprintf ( infFilePath, "%s\\%s", szInfPath, "dosnet.inf" );
    Msg ( "infFilePath = %s\n", infFilePath );

    hInfDosnet = SetupOpenInfFile ( infFilePath, NULL, INF_STYLE_WIN4, NULL );

    if ( hInfDosnet == INVALID_HANDLE_VALUE ) {

        Msg ( "FATAL ERROR: could not open INF:  %s, gle = %ld\n", infFilePath, GetLastError() );
        exit ( GetLastError() );
    }

    Msg ( "hInfDosnet = %ld\n", hInfDosnet );


    //  Open up a handle to layout.inf
    //
    sprintf ( infFilePath, "%s\\%s", szInfPath, "layout.inf" );

    Msg ( "infFilePath = %s\n", infFilePath );

    hInfLayout = SetupOpenInfFile ( infFilePath, NULL, INF_STYLE_WIN4, NULL );

    if ( hInfLayout == INVALID_HANDLE_VALUE ) {

        Msg ( "FATAL ERROR: could not open INF:  %s, gle = %ld\n", infFilePath, GetLastError() );
        exit ( GetLastError() );
    }

    Msg ( "hInfLayout = %ld\n", hInfLayout );


    //  Open up a handle to drvindex.inf
    //
    sprintf ( infFilePath, "%s\\%s", szInfPath, "drvindex.inf" );

    Msg ( "infFilePath = %s\n", infFilePath );

    hInfDrvIndex = SetupOpenInfFile ( infFilePath, NULL, INF_STYLE_WIN4, NULL );

    if ( hInfDrvIndex == INVALID_HANDLE_VALUE ) {

        Msg ( "FATAL ERROR: could not open INF:  %s, gle = %ld\n", infFilePath, GetLastError() );
        exit ( GetLastError () );
    }

    Msg ( "hInfDrvIndex = %ld\n", hInfDrvIndex );



    //  Get the files listed in dosnet.inf to copy to the CD.
    //  Denote them to be copied to the CD by specifying TRUE to AddFiles().
    //
    b = SetupFindFirstLine (    hInfDosnet,
                                FILES_SECTION,
                                NULL,
                                &ic );


    if ( !b ) {

       Msg ( "ERROR: SetupFindFirstLine not found in %s\n", FILES_SECTION );
    }
    else {

       //  Get the 2nd field, ie. the filename, such as in d1,ntkrnlmp.exe
       //
       b = SetupGetStringField ( &ic,
                                 2,
                                 (LPSTR) &returnBuffer,
                                 sizeof ( returnBuffer ),
                                 &dwRequiredSize );

       if ( !b ) {

          Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
       }
       else {

          AddFiles ( returnBuffer, dwPlatform, TRUE );

       }

       while ( 1 ) {

          //  Get the next line in the section.
          //
          b = SetupFindNextLine (    &ic,
                                     &ic );


          if ( !b ) {

             //  Denotes that there is NOT another line.
             //
             Msg ( "no more files in section...\n" );
             break;
          }
          else {

             //  Get the 2nd field's filename,
             //  such as in d1,ntoskrnl.exe.
             //
             b = SetupGetStringField (   &ic,
                                         2,
                                         (LPSTR) &returnBuffer,
                                         sizeof ( returnBuffer ),
                                         &dwRequiredSize );

             if ( !b ) {

                Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
             }
             else {

                AddFiles ( returnBuffer, dwPlatform, TRUE );

             }

          }
       }
    }

    //  Get the files listed in drvindex.inf to later calculate disk space.
    //  Denote them NOT to be copied to the CD by specifying FALSE to AddFiles().
    //
    b = SetupFindFirstLine (    hInfDrvIndex,
                                FILES_SECTION_DRIVER,
                                NULL,
                                &ic );


    if ( !b ) {

       Msg ( "ERROR: SetupFindFirstLine not found in %s\n", FILES_SECTION_DRIVER );
    }
    else {

       //  Get the 1st field, ie. the filename, such as changer.sys.
       //
       b = SetupGetStringField ( &ic,
                                 1,
                                 (LPSTR) &returnBuffer,
                                 sizeof ( returnBuffer ),
                                 &dwRequiredSize );

       if ( !b ) {

          Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
       }
       else {

          Msg ( "found -> %s\n", returnBuffer );
          AddFiles ( returnBuffer, dwPlatform, FALSE );

       }

       while ( 1 ) {

          //  Get the next line in the section.
          //
          b = SetupFindNextLine (    &ic,
                                     &ic );


          if ( !b ) {

             //  Denotes that there is NOT another line.
             //
             Msg ( "no more files in section...\n" );
             break;
          }
          else {

             //  Get the 1st field's filename,
             //  such as in changer.sys.
             //
             b = SetupGetStringField (   &ic,
                                         1,
                                         (LPSTR) &returnBuffer,
                                         sizeof ( returnBuffer ),
                                         &dwRequiredSize );

             if ( !b ) {

                Msg ( "ERROR: SetupGetStringField gle = %ld\n", GetLastError());
             }
             else {

                Msg ( "found -> %s\n", returnBuffer );
                AddFiles ( returnBuffer, dwPlatform, FALSE );

             }

          }
       }
    }



    //  Close all the inf handles.
    //
    SetupCloseInfFile ( hInfDosnet );
    SetupCloseInfFile ( hInfLayout );
    SetupCloseInfFile ( hInfDrvIndex );

    return (TRUE);
}


BOOL    GetTheFiles ( char * DosnetInfPath, char * dosnetFile, int AddToList ) {

    CHAR       infFilePath[MFL];
    DWORD       dwErrorLine;
    BOOL        b;
    char       dstDirectory[MFL];
    FILE        * fHandle;
    char        Line[MFL];

    HANDLE  hDosnetInf;


    //  Open the inx file for processing.
    //
    sprintf ( infFilePath, "%s\\%s", DosnetInfPath, dosnetFile );

    Msg ( "infFilePath = %s\n", infFilePath );

    fHandle = fopen ( infFilePath, "rt" );

    if ( fHandle ) {


        Msg ( "dwInsideSection = %x\n", dwInsideSection );

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            int     i;
            char *  p = Line;
            int     iCommas;

            BOOL    bTextMode = FALSE;

            Msg ( "Line: %s\n", Line );

            if ( Line[0] == '[' ) {

                //  We may have a new section.
                //
                dwInsideSection = FigureSection ( Line );

                continue;
            }


            //  Reasons to ignore this line from further processing.
            //
            //

            //  File section not one we process.
            //
            if ( dwInsideSection == FILE_SECTION_NOT_USED ) {

                continue;
            }

            //  Line just contains a non-usefull short string.
            //
            i = strlen ( Line );
            if ( i < 4 ) {

                continue;
            }

            //  Line contains just a comment.
            //
            if ( Line[0] == ';' ) {

                continue;
            }


            //  There are not enough commas in the line.
            //
            iCommas = 0;

            while ( 1 ) {

                if ( *p == '\0' ) {

                    break;
                }
                if ( *p == ',' ) {
                    ++iCommas;
                }

                ++p;
            }

            if ( iCommas < 5 ) {
               Msg ( "ERROR - there are not enough commas in the line:  %s\n", Line );
               continue;
            }


            switch ( AddToList ) {

                case DBGS_AND_NON_INSTALLED :

                    CheckLength ( SuckName(Line) );

                    bCopyCompX86 = FALSE;
                    bCopyCompNec98 = FALSE;
                    bTextMode = FALSE;

                    if ( dwInsideSection == idBase ) {

                        CopyCompressedFile ( Line );
                        AddFileToX86 ( SuckName(Line), bCopyCompX86, bTextMode, TRUE );

                        if ( bNec98 ) {

                            AddFileToNec98 ( SuckName(Line), bCopyCompNec98, bTextMode, TRUE );

                        }
                        break;
                    }
                    if ( dwInsideSection == idX86 ) {
                        CopyCompressedFile ( Line );
                        AddFileToX86 ( SuckName(Line), bCopyCompX86, bTextMode, TRUE );
                        if ( bNec98 ) {

                            AddFileToNec98 ( SuckName(Line), bCopyCompNec98, bTextMode, TRUE );
                        }
                        break;
                    }

                    break;

                default :

                    Msg ( "ERROR: AddToList = %d\n", AddToList );
            }

        }
        if ( ferror(fHandle) ) {

            Msg ( "ERROR fgets reading from file...\n" );
        }

    }
    else {

        Msg ( "fopen ERROR %s\n", infFilePath );
        return (FALSE);
    }

    fclose ( fHandle );

    return (TRUE);
}

void ShowFreshLocalSpace ( char * fileName, DWORD dwFresh, DWORD dwLocal ) {

    Msg ( "processing:  %s  freshBytes->K32 = %ld, localSrcBytes->K32 = %ld\n",

                fileName, dwFresh, dwLocal );

}

//
//  textModeBytes is used to subtract out the bytes not really
//  needed to be counted by setup for a 1 partition move of the files.
//
void TallyInstalled ( char * szUncompPath, char * szCompPath,
                        struct _tag * tagStruct,
//                        DWORD * numBytes,
                        struct _ClusterSizes * freshBytes,
                        struct _ClusterSizes * localSrcBytes,
                        struct _ClusterSizes * textModeBytes ) {

    int i;
    char szCompressedName[MFL];
    char szPath[MFL];

    //*numBytes = 0;

#define _h1K	512
#define _1K	    1*1024
#define _2K	    2*1024
#define _4K	    4*1024
#define _8K	    8*1024
#define _16K	16*1024
#define _32K	32*1024
#define _64K	64*1024
#define _128K	128*1024
#define _256K   256*1024

    freshBytes->Kh1 = 0;
    freshBytes->K1 = 0;
    freshBytes->K2 = 0;
    freshBytes->K4 = 0;
    freshBytes->K8 = 0;
    freshBytes->K16 = 0;
    freshBytes->K32 = 0;
    freshBytes->K64 = 0;
    freshBytes->K128 = 0;
    freshBytes->K256 = 0;

    localSrcBytes->Kh1 = 0;
    localSrcBytes->K1 = 0;
    localSrcBytes->K2 = 0;
    localSrcBytes->K4 = 0;
    localSrcBytes->K8 = 0;
    localSrcBytes->K16 = 0;
    localSrcBytes->K32 = 0;
    localSrcBytes->K64 = 0;
    localSrcBytes->K128 = 0;
    localSrcBytes->K256 = 0;

    textModeBytes->Kh1 = 0;
    textModeBytes->K1 = 0;
    textModeBytes->K2 = 0;
    textModeBytes->K4 = 0;
    textModeBytes->K8 = 0;
    textModeBytes->K16 = 0;
    textModeBytes->K32 = 0;
    textModeBytes->K64 = 0;
    textModeBytes->K128 = 0;
    textModeBytes->K256 = 0;


    for ( i = 0; i < tagStruct->wNumFiles; ++i ) {

        WIN32_FIND_DATA wfd;
        HANDLE          hFind;


        //  Don't add in space requirements for files in media.inx, since
        //  these files are NEVER installed.
        //
        if ( !tagStruct->bCountBytes[i] ) {

            Msg ( "Warning:  not going to count bytes for:  %s\n", tagStruct->wcFilesArray[i] );
            continue;
        }


        sprintf ( szPath, "%s\\%s", szUncompPath, tagStruct->wcFilesArray[i] );

        //  Need to find out space for .cab files contents.
        //
        if ( strstr ( szPath, ".cab" ) ||
             strstr ( szPath, ".CAB" )    ) {

            Msg ( "JOEHOL >>> get .cab contents filesizes for:  %s\n", szPath );
        }

        //  Calculate the installed system space required.
        //  This is the stuff installed into the %SYSTEMDIR% and all the other stuff
        //  uncompressed on the harddrive.
        //  This value will include the driver.cab, plus all the other files, since we
        //  assume worst case scenario.
        //

        hFind = FindFirstFile ( szPath, &wfd );

        if ( hFind == INVALID_HANDLE_VALUE ) {

            if ( strstr ( szPath, "desktop.ini" ) ||
                 strstr ( szPath, "DESKTOP.INI" )    ) {

                //  Build lab sometimes doesn't put the uncompressed
                //  file on the release shares, say the file is 512 bytes.
                //

#define MAX_SETUP_CLUSTER_SIZE 32*1024
                //*numBytes += ROUNDUP2 ( 512, MAX_SETUP_CLUSTER_SIZE );
                freshBytes->Kh1 += ROUNDUP2 ( 512, _h1K  );
                freshBytes->K1  += ROUNDUP2 ( 512, _1K   );
                freshBytes->K2  += ROUNDUP2 ( 512, _2K   );
                freshBytes->K4  += ROUNDUP2 ( 512, _4K   );
                freshBytes->K8  += ROUNDUP2 ( 512, _8K   );
                freshBytes->K16 += ROUNDUP2 ( 512, _16K  );
                freshBytes->K32 += ROUNDUP2 ( 512, _32K  );
                freshBytes->K64 += ROUNDUP2 ( 512, _64K  );
                freshBytes->K128+= ROUNDUP2 ( 512, _128K );
                freshBytes->K256+= ROUNDUP2 ( 512, _256K );
            }
            else
            if ( strstr ( szPath, "WINNT32.EXE" ) ||
                strstr ( szPath, "winnt32.exe" ) ||
                strstr ( szPath, "winnt32a.dll" ) ||
                strstr ( szPath, "winnt32u.dll" ) ||
                strstr ( szPath, "WINNT32A.DLL" ) ||
                strstr ( szPath, "WINNT32U.DLL" ) ||
                strstr ( szPath, "WINNT32.HLP" ) ||
                strstr ( szPath, "winnt32.hlp" )    ) {

                char    tmpSrcPath[MFL];

                strcpy ( tmpSrcPath, szPath );

                if ( strstr ( tmpSrcPath, ".HLP" ) ||
                    strstr ( tmpSrcPath, ".hlp" )    ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
                }
                else if ( strstr ( tmpSrcPath, "a.dll" ) ||
                    strstr ( tmpSrcPath, "A.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
                }
                else if ( strstr ( tmpSrcPath, "u.dll" ) ||
                          strstr ( tmpSrcPath, "U.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
                }
                else {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
                }

                hFind = FindFirstFile ( tmpSrcPath, &wfd );

                if ( hFind == INVALID_HANDLE_VALUE ) {

                    Msg ( "ERROR Tally:  FindFirstFile %s(%s), gle = %ld\n", szPath, tmpSrcPath, GetLastError() );

                }
            }
            else {

                Msg ( "ERROR Tally:  FindFirstFile %s, gle = %ld\n", szPath, GetLastError() );
            }

        }
        else {

            //  NOTE:   .PNF files are made by the PNP system
            //          during Gui-mode setup, and are NOT listed anywhere.
            //          These files are compiled inf files.
            //          They are generally 2-3 times
            //          bigger than their associated .INF file.
            //          So, if we see and .INF file, increase it's size by
            //          3 times.  We need to do this, because in a low disk
            //          space situation, a .PNF file could be made and take
            //          up all the space.
            //
            if ( strstr ( szPath, ".INF" ) ||
                 strstr ( szPath, ".inf" )    ) {

                wfd.nFileSizeLow *= 3;
                Msg ( "Warning .PNF - %d\n  %s\n", wfd.nFileSizeLow, szPath );
            }


            //*numBytes += ROUNDUP2 ( wfd.nFileSizeLow, MAX_SETUP_CLUSTER_SIZE );
            freshBytes->Kh1 += ROUNDUP2 ( wfd.nFileSizeLow, _h1K  );
            freshBytes->K1  += ROUNDUP2 ( wfd.nFileSizeLow, _1K   );
            freshBytes->K2  += ROUNDUP2 ( wfd.nFileSizeLow, _2K   );
            freshBytes->K4  += ROUNDUP2 ( wfd.nFileSizeLow, _4K   );
            freshBytes->K8  += ROUNDUP2 ( wfd.nFileSizeLow, _8K   );
            freshBytes->K16 += ROUNDUP2 ( wfd.nFileSizeLow, _16K  );
            freshBytes->K32 += ROUNDUP2 ( wfd.nFileSizeLow, _32K  );
            freshBytes->K64 += ROUNDUP2 ( wfd.nFileSizeLow, _64K  );
            freshBytes->K128+= ROUNDUP2 ( wfd.nFileSizeLow, _128K );
            freshBytes->K256+= ROUNDUP2 ( wfd.nFileSizeLow, _256K );

            FindClose ( hFind );

            //Msg ( "%s = %ld\n", szPath, *numBytes );
        }





        //  Calculate the local space required.
        //
        //

        //  NOTE:  If we don't copy this file to the CD, ie. it is in the driver.cab
        //          file, then we don't need to add it's space into the values here,
        //          since once counted for the driver.cab file itself is OK.
        //
        if ( !tagStruct->bCopyItToCD[i] ) {

            Msg ( "Already in CAB file, won't add in space for local source: %s\n",
                            tagStruct->wcFilesArray[i] );
            continue;
        }

        if ( tagStruct->bCopyComp[i] ) {

            char    szCompressedName[MFL];

            MakeCompName ( tagStruct->wcFilesArray[i], szCompressedName );
            sprintf ( szPath, "%s\\%s", szCompPath, szCompressedName );

        }
        else {

            sprintf ( szPath, "%s\\%s", szUncompPath, tagStruct->wcFilesArray[i] );
        }

        hFind = FindFirstFile ( szPath, &wfd );

        if ( hFind == INVALID_HANDLE_VALUE ) {

            if ( strstr ( szPath, "WINNT32.EXE" ) ||
                 strstr ( szPath, "winnt32.exe" ) ||
                strstr ( szPath, "winnt32a.dll" ) ||
                strstr ( szPath, "winnt32u.dll" ) ||
                strstr ( szPath, "WINNT32A.DLL" ) ||
                strstr ( szPath, "WINNT32U.DLL" ) ||
                 strstr ( szPath, "WINNT32.HLP" ) ||
                 strstr ( szPath, "winnt32.hlp" )    ) {

                char    tmpSrcPath[MFL];

                strcpy ( tmpSrcPath, szPath );

                if ( strstr ( tmpSrcPath, ".HLP" ) ||
                    strstr ( tmpSrcPath, ".hlp" )    ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.HLP" );
                }
                else if ( strstr ( tmpSrcPath, "a.dll" ) ||
                    strstr ( tmpSrcPath, "A.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32a.dll" );
                }
                else if ( strstr ( tmpSrcPath, "u.dll" ) ||
                    strstr ( tmpSrcPath, "U.DLL" )   ) {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 5 ], "\\WINNT32u.dll" );
                }
                else {
                    strcpy ( &tmpSrcPath[ strlen(tmpSrcPath) - 4 ], "\\WINNT32.EXE" );
                }

                hFind = FindFirstFile ( tmpSrcPath, &wfd );

                if ( hFind == INVALID_HANDLE_VALUE ) {

                    Msg ( "ERROR Tally:  FindFirstFile %s(%s), gle = %ld\n", szPath, tmpSrcPath, GetLastError() );

                }
            }
            else {

                Msg ( "ERROR Tally:  FindFirstFile %s, gle = %ld\n", szPath, GetLastError() );
            }

        }
        else {

            //  For each cluster size, add in the files bytes
            //  used in the ~ls directory.
            //
            localSrcBytes->Kh1 += ROUNDUP2 ( wfd.nFileSizeLow, _h1K  );
            localSrcBytes->K1  += ROUNDUP2 ( wfd.nFileSizeLow, _1K   );
            localSrcBytes->K2  += ROUNDUP2 ( wfd.nFileSizeLow, _2K   );
            localSrcBytes->K4  += ROUNDUP2 ( wfd.nFileSizeLow, _4K   );
            localSrcBytes->K8  += ROUNDUP2 ( wfd.nFileSizeLow, _8K   );
            localSrcBytes->K16 += ROUNDUP2 ( wfd.nFileSizeLow, _16K  );
            localSrcBytes->K32 += ROUNDUP2 ( wfd.nFileSizeLow, _32K  );
            localSrcBytes->K64 += ROUNDUP2 ( wfd.nFileSizeLow, _64K  );
            localSrcBytes->K128+= ROUNDUP2 ( wfd.nFileSizeLow, _128K );
            localSrcBytes->K256+= ROUNDUP2 ( wfd.nFileSizeLow, _256K );

            //Msg ( "localSrc32:  %s, size=%ld, roundupsize=%ld, total32K=%ld\n", szPath, wfd.nFileSizeLow, ROUNDUP2(wfd.nFileSizeLow,_32K),localSrcBytes->K32 );

/***
            if (hack){

                char buf[MFL];
                sprintf ( buf, "copy %s d:\\myLS", szPath );
                Msg ( "thecopy:  %s\n", buf );
                system ( buf );
            }
***/

            FindClose ( hFind );

            //  For the special marketing calculation number, if a
            //  file for a single partition installation using the ~ls
            //  directory, add in the file's bytes that will actually
            //  turn into free disk space.
            //
            if ( tagStruct->bTextMode[i] ) {

                textModeBytes->Kh1 += ROUNDUP2 ( wfd.nFileSizeLow, _h1K  );
                textModeBytes->K1  += ROUNDUP2 ( wfd.nFileSizeLow, _1K   );
                textModeBytes->K2  += ROUNDUP2 ( wfd.nFileSizeLow, _2K   );
                textModeBytes->K4  += ROUNDUP2 ( wfd.nFileSizeLow, _4K   );
                textModeBytes->K8  += ROUNDUP2 ( wfd.nFileSizeLow, _8K   );
                textModeBytes->K16 += ROUNDUP2 ( wfd.nFileSizeLow, _16K  );
                textModeBytes->K32 += ROUNDUP2 ( wfd.nFileSizeLow, _32K  );
                textModeBytes->K64 += ROUNDUP2 ( wfd.nFileSizeLow, _64K  );
                textModeBytes->K128+= ROUNDUP2 ( wfd.nFileSizeLow, _128K );
                textModeBytes->K256+= ROUNDUP2 ( wfd.nFileSizeLow, _256K );

                //Msg ( "tagStruct->bTextMode TRUE for: %s, %ld\n", tagStruct->wcFilesArray[i], textModeBytes->K32 );
            }
            else {

                //Msg ( "tagStruct->bTextMode FALSE for: %s\n", tagStruct->wcFilesArray[i]);
            }

        }

        // ShowFreshLocalSpace ( tagStruct->wcFilesArray[i], freshBytes->K32, localSrcBytes->K32 );

    }


}

DWORD   GetTheSize ( const char * szPath, const char * szKey ) {

    FILE *  fHandle;
    char    Line[MFL];

    Msg ( "GetTheSize:  szPath = %s\n", szPath );

    fHandle = fopen ( szPath, "rt" );

    if ( fHandle ) {

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            if ( strncmp ( Line, szKey, strlen(szKey)-1 ) == 0 ) {

                char * LinePtr = Line;

                Msg ( "key Line:  %s\n", Line );

                //  First, find the equal sign.
                //
                LinePtr = strstr ( Line, "=" );

                //  Now, find the first character that is a number.
                //
                while ( isdigit(*LinePtr) == 0 ) {

                    ++LinePtr;
                }

                Msg ( "# = %s\n", LinePtr );

                fclose ( fHandle );
                return ( atoi ( LinePtr ) );
            }

        }
        Msg ( "GetTheSize:  Couldn't find key:  %s\n", szKey );
        fclose ( fHandle );
    }
    else {

        Msg ( "GetTheSize:  Couldn't fopen (%s)\n", szPath );
    }

    return 0;
}

void ShowCheckFreshSpace ( struct _ClusterSizes * Section, char * String, char * netServer ) {

    DWORD   dwSize = 0;
    #define OHPROBLEM "problem"
    char    returnedString[MFL];
    #define SD "DiskSpaceRequirements"

    char    sifFile[MFL];
    char    rS512[MFL];
    char    rS1[MFL];
    char    rS2[MFL];
    char    rS4[MFL];
    char    rS8[MFL];
    char    rS16[MFL];
    char    rS32[MFL];
    char    rS64[MFL];
    char    rS128[MFL];
    char    rS256[MFL];

    ULONG    dwSize512;
    ULONG    dwSize1;
    ULONG    dwSize2;
    ULONG    dwSize4;
    ULONG    dwSize8;
    ULONG    dwSize16;
    ULONG    dwSize32;
    ULONG    dwSize64;
    ULONG    dwSize128;
    ULONG    dwSize256;



    sprintf ( sifFile, "%s\\txtsetup.sif", netServer );
    Msg ( "TxtSetup.Sif location:  %s\n", sifFile );

    Msg ( "Clyde:      SPACE REQUIRED TO DO A FRESH INSTALL.\n" );
    Msg ( "Clyde:\n" );
	Msg ( "Clyde:      %s  512  Cluster = %ld\n", String,  Section->Kh1 );
	Msg ( "Clyde:      %s  1K   Cluster = %ld\n", String,  Section->K1 );
	Msg ( "Clyde:      %s  2K   Cluster = %ld\n", String,  Section->K2 );
	Msg ( "Clyde:      %s  4K   Cluster = %ld\n", String,  Section->K4 );
	Msg ( "Clyde:      %s  8K   Cluster = %ld\n", String,  Section->K8 );
	Msg ( "Clyde:      %s  16K  Cluster = %ld\n", String,  Section->K16 );
	Msg ( "Clyde:      %s  32K  Cluster = %ld\n", String,  Section->K32 );
	Msg ( "Clyde:      %s  64K  Cluster = %ld\n", String,  Section->K64 );
	Msg ( "Clyde:      %s  128K Cluster = %ld\n", String,  Section->K128 );
	Msg ( "Clyde:      %s  256K Cluster = %ld\n", String,  Section->K256 );
    Msg ( "Clyde:\n" );


    #define FUDGE_PLUS  4*1024*1024  // ie, grow by 4 M for future growth.

	GetPrivateProfileString ( SD, "WinDirSpace512", "0", rS512, MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace1K",  "0", rS1,   MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace2K",  "0", rS2,   MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace4K",  "0", rS4,   MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace8K",  "0", rS8,   MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace16K", "0", rS16,  MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace32K", "0", rS32,  MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace64K", "0", rS64,  MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace128K","0", rS128, MFL, sifFile );
	GetPrivateProfileString ( SD, "WinDirSpace256K","0", rS256, MFL, sifFile );



    dwSize512 = atoi ( rS512 ) * 1024;
    dwSize1   = atoi ( rS1  ) * 1024;
    dwSize2   = atoi ( rS2  ) * 1024;
    dwSize4   = atoi ( rS4  ) * 1024;
    dwSize8   = atoi ( rS8  ) * 1024;
    dwSize16  = atoi ( rS16 ) * 1024;
    dwSize32  = atoi ( rS32 ) * 1024;
    dwSize64  = atoi ( rS64 ) * 1024;
    dwSize128 = atoi ( rS128) * 1024;
    dwSize256 = atoi ( rS256) * 1024;

    if ( Section->Kh1 > dwSize512 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace512 value is %ld   Use: %ld\n", String, dwSize512, (Section->Kh1 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K1 > dwSize1 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace1K value is %ld   Use: %ld\n", String, dwSize1, (Section->K1 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K2 > dwSize2 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace2K value is %ld   Use: %ld\n", String, dwSize2, (Section->K2 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K4 > dwSize4 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace4K value is %ld   Use: %ld\n", String, dwSize4, (Section->K4 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K8 > dwSize8 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace8K value is %ld   Use: %ld\n", String, dwSize8, (Section->K8 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K16 > dwSize16 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace16K value is %ld   Use: %ld\n", String, dwSize16, (Section->K16 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K32 > dwSize32 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace32K value is %ld   Use: %ld\n", String, dwSize32, (Section->K32 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K64 > dwSize64 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace64K value is %ld   Use: %ld\n", String, dwSize64, (Section->K64 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K128 > dwSize128 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace128K value is %ld   Use: %ld\n", String, dwSize128, (Section->K128 + FUDGE_PLUS) / 1024  );
	}
    if ( Section->K256 > dwSize256 ) {
			Msg ( "matth ERROR:  %s txtsetup.sif's WinDirSpace256K value is %ld   Use: %ld\n", String, dwSize256, (Section->K256 + FUDGE_PLUS) / 1024  );
	}


}

void EnoughTempDirSpace ( char * Key, DWORD dwSpaceNeeded, char * String, char * dosnetFile ) {

    DWORD   dwSize = 0;
    #define OHPROBLEM "problem"
    #define SP "DiskSpaceRequirements"
    char    returnedString[MFL];


    GetPrivateProfileString ( SP, Key, OHPROBLEM, returnedString, MFL, dosnetFile );
    if ( strncmp ( returnedString, OHPROBLEM, sizeof ( OHPROBLEM ) ) == 0 ) {
       Msg ( "ERROR:  %d section not found\n", Key );
    }
    dwSize = atoi ( returnedString );
	if ( dwSpaceNeeded > dwSize ) {
		Msg ( "matth ERROR:  %s dosnet.inf's %s value is %ld   Use: %ld\n", String, Key, dwSize, dwSpaceNeeded + FUDGE_PLUS  );
	}
	if ( dwSpaceNeeded+FUDGE_PLUS < dwSize ) {
		Msg ( "matth ERROR - let's optimize(reduce)!:  %s dosnet.inf's %s value is %ld   Use: %ld\n", String, Key, dwSize, dwSpaceNeeded + FUDGE_PLUS  );
	}

}

void ShowCheckLocalSpace ( struct _ClusterSizes * Section, char * String, char * netServer ) {

    char dosnetFile[MFL];

    sprintf ( dosnetFile, "%s\\dosnet.inf", netServer );
    Msg ( "Dosnet.Inf location:  %s\n", dosnetFile );

        Msg ( "Clyde:      SPACE REQUIRED TO COPY FILES TO LOCAL DRIVE FROM CD.\n" );
        Msg ( "Clyde:\n" );
		Msg ( "Clyde:      %s  512  Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  1K   Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  2K   Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  4K   Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  8K   Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  16K  Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  32K  Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  64K  Cluster = %ld\n", String, (8*1024*1024) ) ;
		Msg ( "Clyde:      %s  128K Cluster = %ld\n", String, (8*1024*1024) );
		Msg ( "Clyde:      %s  256K Cluster = %ld\n", String, (8*1024*1024) );
        Msg ( "Clyde:\n" );


        Msg ( "Clyde:      SPACE REQUIRED TO COPY FILES TO LOCAL DRIVE FROM NETWORK.\n" );
        Msg ( "Clyde:\n" );

        //  Note: this 8*1024*1024 is the ~bt space - 8M is average today.
        //  But, to be more accurate we could get the value from the inf.
        //
		Msg ( "Clyde:      %s  512  Cluster = %ld\n", String, Section->Kh1+(8*1024*1024) );
		Msg ( "Clyde:      %s  1K   Cluster = %ld\n", String, Section->K1+(8*1024*1024) );
		Msg ( "Clyde:      %s  2K   Cluster = %ld\n", String, Section->K2+(8*1024*1024) );
		Msg ( "Clyde:      %s  4K   Cluster = %ld\n", String, Section->K4+(8*1024*1024) );
		Msg ( "Clyde:      %s  8K   Cluster = %ld\n", String, Section->K8+(8*1024*1024) );
		Msg ( "Clyde:      %s  16K  Cluster = %ld\n", String, Section->K16+(8*1024*1024) );
		Msg ( "Clyde:      %s  32K  Cluster = %ld\n", String, Section->K32+(8*1024*1024) );
		Msg ( "Clyde:      %s  64K  Cluster = %ld\n", String, Section->K64+(8*1024*1024) ) ;
		Msg ( "Clyde:      %s  128K Cluster = %ld\n", String, Section->K128+(8*1024*1024) );
		Msg ( "Clyde:      %s  256K Cluster = %ld\n", String, Section->K256+(8*1024*1024) );
        Msg ( "Clyde:\n" );


        EnoughTempDirSpace ( "TempDirSpace512", Section->Kh1, String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace1K",  Section->K1,  String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace2K",  Section->K2,  String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace4K",  Section->K4,  String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace8K",  Section->K8,  String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace16K", Section->K16, String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace32K", Section->K32, String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace64K", Section->K64, String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace128K",Section->K128,String, dosnetFile );
        EnoughTempDirSpace ( "TempDirSpace256K",Section->K256,String, dosnetFile );


}

void ClydeR ( char * String, char * desString, DWORD dwFresh, DWORD dwLocal, DWORD dwTextMode ) {

    DWORD dwPageFile = 0;
    DWORD dwLocalSource = 0;
    DWORD dwFreshInstall = 0;
    DWORD dwTextModeSavings = 0;
    DWORD dwTotal = 0;
    DWORD dwLocalBoot = 0;
    #define LOCAL_BOOT 8*1024*1024
    DWORD dwMigrationDlls = 0;
    DWORD MigrationDllsK32 = 24*1024*1024;  // as of 12.11.98
    DWORD dwOsSizeDiff = 0;
    DWORD dwCacheDelete = 0;

    Msg ( "Clyde:  %s Scenario 1 - Fresh install using CD (CD-boot or with floppies) on a blank machine on a 1 partition %s cluster drive.\n", String, desString );

    dwPageFile        = (64+11) * 1024 * 1024;
    dwFreshInstall    = dwFresh;
    dwTotal           = dwPageFile + dwFreshInstall;


    Msg ( "Clyde:  Pagefile for 64M RAM = %ld\n", dwPageFile );
    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );


    Msg ( "Clyde:  %s Scenario 2 - Fresh Install Using Winnt32 (on Win9x or NT) and a CD on a 1 partition %s cluster drive.\n", String, desString );

    dwPageFile        = (64+11) * 1024 * 1024;
    dwFreshInstall    = dwFresh;
    dwLocalBoot       = LOCAL_BOOT;
    dwTotal           = dwPageFile + dwFreshInstall + dwLocalBoot;

    Msg ( "Clyde:  Pagefile for 64M RAM = %ld\n", dwPageFile );
    Msg ( "Clyde:  Local boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );


    Msg ( "Clyde:  %s Scenario 3 - Fresh Install Using Winnt32 (on Win9x or NT) over the network on a 1 partition %s cluster drive.\n", String, desString );

    dwPageFile        = (64+11) * 1024 * 1024;
    dwLocalSource     = dwLocal;
    dwFreshInstall    = dwFresh;
    dwTextModeSavings = dwTextMode;
    dwLocalBoot       = LOCAL_BOOT;
    dwTotal           = dwPageFile + dwLocalSource + dwFreshInstall + dwLocalBoot - dwTextModeSavings;

    Msg ( "Clyde:  Pagefile for 64M RAM = %ld\n", dwPageFile );
    Msg ( "Clyde:  Local source         = %ld\n", dwLocalSource );
    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  TextMode savings     = %ld\n", dwTextModeSavings );
    Msg ( "Clyde:  Local boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );


    Msg ( "Clyde:  %s Scenario 4 - Upgrade using Winnt32 (on NT 4.0 Workstation) and a CD on a 1 partition %s cluster drive.\n", String, desString );

    dwFreshInstall    = dwFresh;
    dwOsSizeDiff      = x86From400;
    dwLocalBoot       = LOCAL_BOOT;
    dwCacheDelete     = 0;
    dwTotal           = dwFreshInstall - dwOsSizeDiff + dwLocalBoot - dwCacheDelete;

    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  OsSizeDiff           = %ld\n", dwOsSizeDiff );
    Msg ( "Clyde:  Local Boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  Cache Delete         = %ld\n", dwCacheDelete );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );


    Msg ( "Clyde:  %s Scenario 5 - Upgrade using Winnt32 (on NT 4.0 Workstation) over the network on a 1 partition %s cluster drive.\n", String, desString );

    dwFreshInstall    = dwFresh;
    dwOsSizeDiff      = x86From400;
    dwLocalBoot       = LOCAL_BOOT;
    dwLocalSource     = dwLocal;
    dwCacheDelete     = 0;
    dwTotal           = dwFreshInstall - dwOsSizeDiff + dwLocalBoot + dwLocalSource - dwCacheDelete;

    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  OsSizeDiff           = %ld\n", dwOsSizeDiff );
    Msg ( "Clyde:  Local Boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  Local Source         = %ld\n", dwLocalSource );
    Msg ( "Clyde:  Cache Delete         = %ld\n", dwCacheDelete );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );


    Msg ( "Clyde:  %s Scenario 6 - Upgrade using Winnt32 (on Win9x) and a CD on a 1 partition %s cluster drive.\n", String, desString );

    dwPageFile        = (64+11) * 1024 * 1024;
    dwFreshInstall    = dwFresh;
    dwLocalBoot       = LOCAL_BOOT;
    dwMigrationDlls   = MigrationDllsK32;
    dwCacheDelete     = 0;
    dwTotal           = dwPageFile + dwFreshInstall + dwLocalBoot + dwMigrationDlls - dwCacheDelete;

    Msg ( "Clyde:  Pagefile for 64M RAM = %ld\n", dwPageFile );
    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  Local Boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  Migration DLLs       = %ld\n", dwMigrationDlls );
    Msg ( "Clyde:  Cache Delete         = %ld\n", dwCacheDelete );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );

    Msg ( "Clyde:  %s Scenario 7 - Upgrade using Winnt32 (on Win9x) over the network on a 1 partition %s cluster drive.\n", String, desString );

    dwPageFile        = (64+11) * 1024 * 1024;
    dwFreshInstall    = dwFresh;
    dwLocalBoot       = LOCAL_BOOT;
    dwMigrationDlls   = MigrationDllsK32;
    dwLocalSource     = dwLocal;
    dwCacheDelete     = 0;
    dwTotal           = dwPageFile + dwFreshInstall + dwLocalBoot + dwMigrationDlls + dwLocalSource - dwCacheDelete;

    Msg ( "Clyde:  Pagefile for 64M RAM = %ld\n", dwPageFile );
    Msg ( "Clyde:  Fresh install        = %ld\n", dwFreshInstall );
    Msg ( "Clyde:  Local Boot           = %ld\n", dwLocalBoot );
    Msg ( "Clyde:  Migration DLLs       = %ld\n", dwMigrationDlls );
    Msg ( "Clyde:  Local Source         = %ld\n", dwLocalSource );
    Msg ( "Clyde:  Cache Delete         = %ld\n", dwCacheDelete );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  TOTAL Space Required = %ld\n", dwTotal );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );

}

void ShowTextModeSpace ( struct _ClusterSizes * FreshInstall,
                         struct _ClusterSizes * LocalSource,
                         struct _ClusterSizes * TextModeSavings,
                         char * String ) {



    Msg ( "Clyde:      TEXTMODE SPACE.\n" );
    Msg ( "Clyde:\n" );
    Msg ( "Clyde:      %s  512  Cluster = %ld\n", String, TextModeSavings->Kh1 );
	Msg ( "Clyde:      %s  1K   Cluster = %ld\n", String, TextModeSavings->K1 );
	Msg ( "Clyde:      %s  2K   Cluster = %ld\n", String, TextModeSavings->K2 );
	Msg ( "Clyde:      %s  4K   Cluster = %ld\n", String, TextModeSavings->K4 );
	Msg ( "Clyde:      %s  8K   Cluster = %ld\n", String, TextModeSavings->K8 );
	Msg ( "Clyde:      %s  16K  Cluster = %ld\n", String, TextModeSavings->K16);
	Msg ( "Clyde:      %s  32K  Cluster = %ld\n", String, TextModeSavings->K32);
	Msg ( "Clyde:      %s  64K  Cluster = %ld\n", String, TextModeSavings->K64);
	Msg ( "Clyde:      %s  128K Cluster = %ld\n", String, TextModeSavings->K128);
	Msg ( "Clyde:      %s  256K Cluster = %ld\n", String, TextModeSavings->K256);
    Msg ( "Clyde:\n" );


    Msg ( "Clyde:  SCENARIOS VALUES FOLLOW\n" );
    Msg ( "Clyde:  \n" );
    Msg ( "Clyde:  \n" );

    ClydeR ( String, "512 byte", FreshInstall->Kh1,  LocalSource->Kh1, TextModeSavings->Kh1 );
    ClydeR ( String, "4K  byte", FreshInstall->K4 ,  LocalSource->K4,  TextModeSavings->K4 );
    ClydeR ( String, "32K byte", FreshInstall->K32 , LocalSource->K32, TextModeSavings->K32 );

}


int __cdecl main(argc,argv)
int argc;
char * argv[];
{
    HANDLE h;
    int records, i;
    WIN32_FIND_DATA fd;
    time_t t;
    DWORD   dwSize;
    char    szFileName[MFL];

    #define MAKE_NEC98  "MAKE_NEC98"
    #define SKIP_AS     "SKIP_AS"
    #define SKIP_SRV    "SKIP_SRV"
    #define SKIP_DC     "SKIP_DC"

    if ( getenv ( MAKE_NEC98 ) != NULL ) {

        bNec98 = TRUE;
        if ( argc != 9 ) {
            printf ( "NEC98 special...\n" );
            printf ( "You specified %d arguments - you need 9.\n\n", argc );

            for ( i = 0; i < argc; ++i ) {

                printf ( "Argument #%d >>>%s<<<\n", i, argv[i] );
            }
            printf ( "\n\n" );
            Usage();
            return(1);
	    }
    }
    else {	
        if ( argc != 7 ) {
            printf ( "You specified %d arguments - you need 7.\n\n", argc );

            for ( i = 0; i < argc; ++i ) {

                printf ( "Argument #%d >>>%s<<<\n", i, argv[i] );
            }
            printf ( "\n\n" );
            Usage();
            return(1);
	    }
    }

    //  Initialize the critical section object.
    //
    InitializeCriticalSection ( &CriticalSection );

    //  Retail %platform% files.
    //
    ix386.wNumFiles       = 0;

    Nec98.wNumFiles      = 0;

    strcpy ( szLogFile,     argv[1] );
    strcpy ( szProductName, argv[2] );
    strcpy ( szEnlistDrv,   argv[3] );
    strcpy ( szX86Src,      argv[4] );
    strcpy ( szX86DstDrv,   argv[5] );
    strcpy ( szUnCompX86,   argv[6] );

    if ( bNec98 ) {

        strcpy ( szNec98Src,       argv[7] );
        strcpy ( szUnCompNec98,    argv[8] );
    }

    logFile = fopen ( argv[1], "a" );

    if ( logFile == NULL ) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }

    //  Do bit comparison to release shares on all copies ?
    //
#define VERIFY_COPIES   "VERIFY"

    if ( getenv ( VERIFY_COPIES ) != NULL ) {
        bVerifyBits = TRUE;
        Msg ( "Will verify copies...\n" );
    }

    if ( getenv ( SKIP_SRV ) && strstr ( szProductName, "Server" ) ) {

        Msg ( "Warning:  skipping making Server product.\n" );
        exit ( 0 );
    }

    if ( getenv ( SKIP_AS ) &&  strstr ( szProductName, "AdvancedServer" ) ) {

        Msg ( "Warning:  skipping making Advanced Server product.\n" );
        exit ( 0 );
    }

    if ( getenv ( SKIP_DC ) &&  strstr ( szProductName, "DataCenter" ) ) {

        Msg ( "Warning:  skipping making Data Center product.\n" );
        exit ( 0 );
    }


    if ( strstr ( szX86Src, "chk." ) ||
         strstr ( szX86Src, "CHK." )    ) {

        Msg ( "Warning:  We believe this is a checked build script, thus, we'll put put .dbgs in CHECKED directory...\n" );
        bChecked = TRUE;
    }
    else {
        Msg ( "Warning:  We believe this is a free build script, thus, we'll put put .dbgs in FREE directory...\n" );
        bChecked = FALSE;
    }


    Header(argv,argc);

    CreateDestinationDirs ();

    //  Get files that product installs.
    //
    bGetSizeLater = TRUE;

    PlatformFilesToCopy ( szX86Src, X86_F );

    if ( bNec98 ) {
        bNec98LikeX86 = TRUE;
        PlatformFilesToCopy ( szNec98Src, NEC98_F );
    }

    bGetSizeLater = FALSE;

    //  Get the files from _media.inx in
    //  C:\nt\private\windows\setup\bom directory.
    //

    GetTheFiles ( "C:\\nt\\private\\windows\\setup\\bom",
                  "_media.inx",
                  DBGS_AND_NON_INSTALLED );


    //ShowX86();
    //ShowNec98 ();


    Msg ( "# files  i386  = %ld\n", ix386.wNumFiles );

    if ( bNec98 ) {
        Msg ( "# files  Nec98 = %ld\n", Nec98.wNumFiles );
    }

    //  Make some threads and copy all the files.
    //
    CopyTheFiles();

    //
    //  Don't tally anything for checked builds since the INF sizes are off, ie. retail.
    //
    if ( bChecked ) {

        Msg ( "Warning:  We have a checked build here and will not tally file space...\n" );
        goto END_MAIN;
    }

    Msg ( "========= Minimum setup install bytes required (all files uncompressed): ==========\n" );

    TallyInstalled ( szUnCompX86,   szX86Src, &ix386, &freshX86, &lX86, &tX86 );

    if ( bNec98 ) {
        TallyInstalled ( szUnCompNec98, szNec98Src, &Nec98, &freshNec98, &lNec98, &tNec98 );
    }



	//	Give tally counts.
	//

	ShowCheckFreshSpace ( &freshX86,   "freshX86",    szX86Src );
    if ( bNec98 ) {
	    ShowCheckFreshSpace ( &freshNec98, "freshNec98",    szNec98Src );
    }
	

    Msg ( "Clyde:  FreshInstall->K32    = %ld\n", freshX86.K32 );
    Msg ( "Clyde:  TextModeSavings->K32 = %ld\n", tX86.K32 );
    Msg ( "Clyde:  Local->K32           = %ld\n", lX86.K32 );

    Msg ( "========= Maximum setup local-source bytes required (some files compressed) : =====\n" );

	ShowCheckLocalSpace ( &lX86,   "lX86",   szX86Src );

    if ( bNec98 ) {
	    ShowCheckLocalSpace ( &lNec98, "lNec98",    szNec98Src );
    }


    Msg ( "========= Special TextMode files space =====\n" );

	ShowTextModeSpace ( &freshX86,   &lX86,   &tX86,   "X86" );

    if ( bNec98 ) {
	    ShowTextModeSpace ( &freshNec98, &lNec98, &tNec98, "Nec98" );
    }


END_MAIN:;

    Msg ( "==============================\n");
    time(&t);
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "==============================\n\n");

    fclose(logFile);

    return(777);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\filter\filter.c ===
//
//	05.10.94	Joe Holman	Used to Filter N*LAN lines, where you specify the
//							the language you want to keep.
//							The BOM.TXT must have the N*LAN entries in it.
//



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}


void Header(argv,argc)
char* argv[];
int argc;
{
    time_t t;

    Msg ("\n=========== FILTER =============\n");
	Msg ("Logfile  : %s\n",argv[1]);
    Msg ("BOM      : %s\n",argv[2]);
    Msg ("Language : %s\n",argv[3]);

    time(&t); 
	Msg("Time: %s",ctime(&t));
    Msg ("==============================\n\n");
}

void Usage()
{
    printf("PURPOSE: Keeps particular language files, noted by N*LAN in bom.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM which lists files whose sizes are to be updated.\n");
	printf("[Language] - Specify the <LAN> as in N*<LAN> to KEEP.\n");
    printf("\n\n");
}

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *tempFile;
    Entry* e;
    char tempName[MAX_PATH];
    int records, i, result;
    char* buf;

    srand((unsigned)time(NULL));

    if (argc!=4 ) { 
		Usage(); 
		return(1); 
	}

    if ((logFile=fopen(argv[1],"a"))==NULL) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }
    Header(argv,argc);

    tempName[0]='\0';
    sprintf(tempName,"%d.000",rand());

    if (MyOpenFile(&tempFile,tempName,"wb")) {
 		return(1);
	}

	LoadFile(argv[2],&buf,&e,&records,"ALL");


	//	Show the records just loaded in.
	//
	Msg ( "# records just loaded = %d\n", records );
	
	//	Go to beginning of file.
	//
	result = fseek ( tempFile, SEEK_SET, 0 );	// goto beginning of file.
    if (result) {
        printf("ERROR Unable to seek beginning of file: %s\n", tempName);
        return(1);
    }

	//	Print out the column header description to the file.
	//	(EXPECTED by the tools LoadFile() tool.)
	//
    i=0; while ((fputc(buf[i++],tempFile))!='\n');

	//	Filter out files that are only for a particular language
	//	while we are printing out the data.
	//
    for ( i = 0; i < records; ++i ) {

		//	Look for the given key in the grouping column in the
		//	BOM in the format:   N*LAN
		//
		//	If we find it, we DON'T keep it.
		//
		if ( e[i].flopmedia[1] == '*') {

				Msg ( "%s, language specified:  %s >>> ", 
								e[i].name, e[i].flopmedia );

				if ( _stricmp ( &e[i].flopmedia[2], argv[3] ) ) {

					Msg ( "FILTERED\n" ); 
				}
				else {

                    Msg ( "KEPT\n" );
	    			EntryPrint(&e[i],tempFile);
				
				}
		}
		else {
		
				//	No special language specified, print out the data.
				//	
	    		EntryPrint(&e[i],tempFile);
/**
				Msg ( "EntryPrint'd:  %s, %d\n", 
							e[i].name, i );
**/
		}
		
    }

    fclose(logFile);
    fclose(tempFile);

    if (!CopyFile(tempName,argv[2],FALSE)) {
		Msg ("ERROR Couldn't copy %s to %s\n",tempName,argv[2]);
		Msg ( "CopyFile GLE=%ld leaving temp file for investigation...\n", 
					GetLastError() );
    }
	else {
    	DeleteFile(tempName);
	}

    free(buf);
    free(e);
	return ( 0 );

	exit(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\general\general.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "general.h"

extern FILE* logFile;


#define PLATFORM_COUNT  2
#define X86_PLATFORM    1   // index #2 into PSTR's below.

PSTR GenericSubstitutions[PLATFORM_COUNT] = { "alpha","i386" };
PSTR PlatformSubstitutions[PLATFORM_COUNT] = { "alpha", "x86" };
PSTR AclpathSubstitutions[PLATFORM_COUNT] = { "w32alpha","w32x86" };

typedef struct _TRACKED_STRING {
    struct _TRACKED_STRING *Next;
    PSTR String;
} TRACKED_STRING, *PTRACKED_STRING;

PTRACKED_STRING SourceFieldStrings;
PTRACKED_STRING PathFieldStrings;
PTRACKED_STRING PlatformFieldStrings;
PTRACKED_STRING CdPathFieldStrings;
PTRACKED_STRING InfFileFieldStrings;
PTRACKED_STRING InfSectionFieldStrings;
PTRACKED_STRING AclPathFieldStrings;



VOID
ExpandField(
    IN OUT PSTR            *Field,
    IN     PSTR             SubstituteText,
    IN OUT PTRACKED_STRING *StringList
    )
{
    unsigned c;
    PSTR p;
    CHAR buf[1000];
    PTRACKED_STRING s;

    if(p = strchr(*Field,'@')) {

        c = (unsigned)(p - (*Field));

        //
        // Create the platform-specific string.
        //
        strncpy(buf,*Field,c);
        buf[c] = 0;
        strcat(buf,SubstituteText);
        strcat(buf,(*Field) + c + 1);

    } else {

        //
        // No @, field doesn't need to change.
        //
        return;
    }

    //
    // See whether we already have this string.
    //
    s = *StringList;
    while(s) {
        if(!_stricmp(buf,s->String)) {
            *Field = s->String;
            return;
        }
        s = s->Next;
    }

    //
    // We don't already have it.  Create it.
    //
    s = malloc(sizeof(TRACKED_STRING));
    if(!s) {
        PRINT1("ERROR Couldn't allocate enough memory.\n")
        exit(1);
    }

    s->String = _strdup(buf);
    if(!s->String) {
        PRINT1("ERROR Couldn't allocate enough memory.\n")
        exit(1);
    }

    *Field = s->String;

    s->Next = *StringList;
    *StringList = s;
}


VOID
ExpandPlatformIndependentEntry(
    IN OUT Entry *e,
    IN     int    FirstRecord
    )
{
    int i,j;
    Entry t;

    t = *(e+FirstRecord);

    for(i=0,j=FirstRecord; i<PLATFORM_COUNT; i++,j++) {

        *(e+j) = t;

        //
        // expand the source field.
        //
        ExpandField(&e[j].source,PlatformSubstitutions[i],&SourceFieldStrings);

        //
        // expand the path field.
        //
        ExpandField(&e[j].path,GenericSubstitutions[i],&PathFieldStrings);

        //
        // expand the platform field.
        //
        ExpandField(&e[j].platform,PlatformSubstitutions[i],&PlatformFieldStrings);

        //
        // expand the cdpath field.
        //
        ExpandField(&e[j].cdpath,GenericSubstitutions[i],&CdPathFieldStrings);

        //
        // expand the inf file field.
        //
        ExpandField(&e[j].inf,GenericSubstitutions[i],&InfFileFieldStrings);

        //
        // expand the inf section field.
        //
        ExpandField(&e[j].section,GenericSubstitutions[i],&InfSectionFieldStrings);

        //
        // expand the aclpath section field.
        //
        ExpandField(&e[j].aclpath,AclpathSubstitutions[i],&AclPathFieldStrings);
    }
}

VOID
ExpandPlatformEntryX86Only(
    IN OUT Entry *e,
    IN     int    FirstRecord
    )
{
    int i,j;
    Entry t;

    t = *(e+FirstRecord);

    i = X86_PLATFORM;
    j = FirstRecord;

    *(e+j) = t;

    //
    // expand the source field.
    //
    ExpandField(&e[j].source,PlatformSubstitutions[i],&SourceFieldStrings);

    //
    // expand the path field.
    //
    ExpandField(&e[j].path,GenericSubstitutions[i],&PathFieldStrings);

    //
    // expand the platform field.
    //
    ExpandField(&e[j].platform,PlatformSubstitutions[i],&PlatformFieldStrings);

    //
    // expand the cdpath field.
    //
    ExpandField(&e[j].cdpath,GenericSubstitutions[i],&CdPathFieldStrings);

    //
    // expand the inf file field.
    //
    ExpandField(&e[j].inf,GenericSubstitutions[i],&InfFileFieldStrings);

    //
    // expand the inf section field.
    //
    ExpandField(&e[j].section,GenericSubstitutions[i],&InfSectionFieldStrings);

    //
    // expand the aclpath section field.
    //
    ExpandField(&e[j].aclpath,AclpathSubstitutions[i],&AclPathFieldStrings);
}

void LoadFile(name,buf,e,records,product)
char* name;
char** buf;
Entry** e;
int* records;
char* product;
{
    int match,i;
    HANDLE h;
    DWORD size,sizeRead,x;
    BOOL result;
    char* j;

    (*records)=0;
    h=CreateFile(name,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    size=GetFileSize(h,NULL);
    if ((h==INVALID_HANDLE_VALUE) || (size==-1))
    {
    PRINT2("ERROR Couldn't open %s for reading.\n",name)
    exit(1);
    }
    if (((*buf)=malloc(size))==NULL)
    {
    PRINT1("ERROR Couldn't allocate enough memory to read file.\n")
    exit(1);
    }
    result=ReadFile(h,*buf,size,&sizeRead,NULL);
    if ((sizeRead!=size) || (result==FALSE))
    {
    PRINT2("ERROR Couldn't read all of %s.\n",name)
    exit(1);
    }

    x=0; while((*buf)[x++]!='\n');
    while(x<size) {
        if ((*buf)[x]=='\t') (*buf)[x]='\0';
        if ((*buf)[x]=='\n') (*records)++;
        x++;
    }

    CloseHandle(h);

    //
    // Allocate maximum possible number of entries required.
    //
    if (((*e)=malloc(PLATFORM_COUNT*sizeof(Entry)*(*records)))==NULL) {
        PRINT1("ERROR Couldn't allocate enough space for database entries.\n")
        exit(1);
    }

    j=(*buf);
    while (*j++!='\n');
    match=0;

    for (i=0;i<(*records);i++) {

        (*e)[match].name=j; while ((*j!='\n') && (*j++));
        (*e)[match].source=j; while ((*j!='\n') && (*j++));
        (*e)[match].path=j; while ((*j!='\n') && (*j++));
        (*e)[match].flopmedia=j; while ((*j!='\n') && (*j++));
        (*e)[match].comment=j; while ((*j!='\n') && (*j++));
        (*e)[match].product=j; while ((*j!='\n') && (*j++));
        (*e)[match].sdk=j; while ((*j!='\n') && (*j++));
        (*e)[match].platform=j; while ((*j!='\n') && (*j++));
        (*e)[match].cdpath=j; while ((*j!='\n') && (*j++));
        (*e)[match].inf=j; while ((*j!='\n') && (*j++));
        (*e)[match].section=j; while ((*j!='\n') && (*j++));
        (*e)[match].infline=j; while ((*j!='\n') && (*j++));
        (*e)[match].size=atoi(j); while((*j!='\n') && (*j++));
        (*e)[match].csize=atoi(j); while((*j!='\n') && (*j++));
        (*e)[match].nocompress=j; while ((*j!='\n') && (*j++));
        (*e)[match].priority=atoi(j); while ((*j!='\n') && (*j++));
        (*e)[match].lmacl=j; while ((*j!='\n') && (*j++));
        (*e)[match].ntacl=j; while ((*j!='\n') && (*j++));
        (*e)[match].aclpath=j; while ((*j!='\n') && (*j++));
        (*e)[match].medianame=j; while ((*j!='\n') && (*j++));
        (*e)[match].disk=atoi(j); while ((*j!='\n') && (*j++));
        j++;

        (*e)[match].name=_strupr((*e)[match].name);
        (*e)[match].medianame=_strupr((*e)[match].medianame);

        if (EntryMatchProduct(&((*e)[match]),product)) {

            //
            // If this is a platform-independent entry,
            // expand it into one entry per platform.
            //
            if(((*e)[match].platform[0] == '@')
            || ((*e)[match].source[0] == '@')
            || ((*e)[match].cdpath[1] == '@'))
            {

                //  If we are working with x86 floppies,
                //  just expand for x86, no need for overhead with
                //  other platforms.
                //
                if ( !_stricmp(product,"LMFLOP") ||
                     !_stricmp(product,"NTFLOP") ) {
                    PRINT2( "%s:  Expanding ONLY for X86 flops...\n", (*e)[match].name );
                    ExpandPlatformEntryX86Only( *e, match );
                    ++match;
                }
                else {
                    ExpandPlatformIndependentEntry(*e,match);
                    match += PLATFORM_COUNT;
                }

            } else {

                //  The data is ok as is here.
                match++;
            }
        }
    }

    //
    // Skip first line (column headings).
    //
    j=*buf;
    while (*j++!='\n');

    //
    // Change newlines into line terminators,
    // so the final field on each line will be terminated properly.
    //
    while(*records) {
        if((*j)=='\n') {
            *j='\0';
            (*records)--;
        }
        j++;
    }

    //
    // Shrink the array of records to its actual size.
    //
    *e = realloc(*e,match*sizeof(Entry));
    (*records)=match;
}

void EntryPrint(entry,f)
Entry* entry;
FILE *f;
{
    fprintf(f,"%s\t",entry->name);
    fprintf(f,"%s\t",entry->source);
    fprintf(f,"%s\t",entry->path);
    fprintf(f,"%s\t",entry->flopmedia);
    fprintf(f,"%s\t",entry->comment);

    fprintf(f,"%s\t",entry->product);

    fprintf(f,"%s\t",entry->sdk);

    fprintf(f,"%s\t",entry->platform);

    fprintf(f,"%s\t",entry->cdpath);

    fprintf(f,"%s\t",entry->inf);
    fprintf(f,"%s\t",entry->section);
    fprintf(f,"%s\t",entry->infline);

    fprintf(f,"%d\t",entry->size);
    fprintf(f,"%d\t",entry->csize);
    fprintf(f,"%s\t",entry->nocompress);
    fprintf(f,"%d\t",entry->priority);

    fprintf(f,"%s\t",entry->lmacl);
    fprintf(f,"%s\t",entry->ntacl);
    fprintf(f,"%s\t",entry->aclpath);

    fprintf(f,"%s\t",entry->medianame);

    fprintf(f,"%d\r\n",entry->disk);
}

int EntryMatchProduct(entry,product)
Entry* entry;
char* product;
{
    if (!_stricmp(product,"ALL"))
    return(1);

    return

        //
        // Laying out NT floppies AND entry is not for AS-only
        // AND entry specifies that this file goes on floppy
        //
        (!_stricmp(product,"NTFLOP")                 // include X86 floppy files
          && _stricmp(entry->product,"as")           // exclude AS only files
          && (entry->priority < 1000)               // include prioty < 1000
          && _stricmp(entry->source,"alphabins")     // exclude alphabins files
          && _stricmp(entry->path,"\\alpha")         // exclude alpha path files
          && _stricmp(entry->source,"alphadbg")      // exclude alphadbg files
          && _stricmp(entry->source,"x86dbg")        // exclude x86dbg files
        )

        //
        // Laying out AS floppies AND entry is not for NT-only
        // AND entry specified that this file goes on floppy
        //
     || (!_stricmp(product,"LMFLOP")
          && _stricmp(entry->product,"nt")           // exclude NT only files
          && (entry->priority < 1000)
          && _stricmp(entry->source,"alphabins")
          && _stricmp(entry->path,"\\alpha")
          && _stricmp(entry->source,"alphadbg")
          && _stricmp(entry->source,"x86dbg")
        )

        //
        // Laying out nt cd-rom and entry is not for as only
        //
     || (!_stricmp(product,"NTCD") && _stricmp(entry->product,"as"))

        //
        // Laying out as cd-rom and entry is not for nt only
        //
     || (!_stricmp(product,"LMCD") && _stricmp(entry->product,"nt"))

        //
        // Laying out sdk
        //
     || (!_stricmp(product,"SDK") && !_stricmp(entry->sdk,"x"));
}

int MyOpenFile(f,fileName,mode)
FILE** f;
char* fileName;
char* mode;
{
    if ((*f=fopen(fileName,mode))==NULL)
    {
    PRINT3("ERROR Couldn't open %s for %s\n",fileName,mode)
    return(1);
    }
    return(0);
}

void convertName(oldName,newName)
char* oldName;
char* newName;
{
    unsigned i;
    unsigned period;

    strcpy(newName,oldName);
    for (period=(unsigned)(-1),i=0;i<strlen(oldName);i++) if (oldName[i]=='.') period=i;
    if (period==(strlen(oldName)-4))
    newName[strlen(newName)-1]='_';
    else if (period==(unsigned)(-1))
    strcat(newName,"._");
    else
    strcat(newName,"_");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\layout\layout.c ===
/*

Modifications:

01.10.94    Joe Holman  Added DISK_TO_START_NUMBERING_AT because
                we now have 2 bootdisks, thus we to start
                making floppies on disk # 3.
01.11.94    Joe Holman  Change value back to 2.
05.05.94	Joe Holman	Change # to 1.
06.14.94    Joe Holman  Change # to 2 for German Media.


*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;
char* product;
int useCdPath;

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== LAYOUT =============\n")
    PRINT2("Input BOM: %s\n",argv[2])
    PRINT2("Output Layout: %s\n",argv[3])
    PRINT2("Product: %s\n",argv[4])
    PRINT2("Floppy Size: %s\n",argv[5])
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Assigns files to disks and generates a layout file.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM for which a layout is to be made.\n");
    printf("[OutLayout] - Path of new layout.\n");
    printf("[Product] - Product to lay out.\n");
    printf("            NTFLOP = Windows NT on floppy\n");
    printf("            LMFLOP = Lan Manager on floppy\n");
    printf("            NTCD = Windows NT on CD\n");
    printf("            LMCD = Lan Manager on CD\n");
    printf("            SDK = Software Development Kit\n");
    printf("[FloppySize] - Size in bytes of the second disk.\n\n");
}

int __cdecl PrioritySizeNameCompare(const void*,const void*);

int Same(e1,e2)
Entry* e1;
Entry* e2;
{
    char *p1, *p2;

    if (useCdPath)
    {
    p1=e1->cdpath;
    p2=e2->cdpath;
    }
    else
    {
    p1="x";
    p2=p1;
    }

    return( (!_stricmp(e1->name,e2->name)) &&
        (!_stricmp(e1->path,e2->path)) &&
        (!_stricmp(e1->source,e2->source)) &&
        (!_stricmp(p1,p2)));
}

void LayoutAssignDisks(e,diskSize,records)
Entry* e;
int diskSize;
int records;
{
    int disk;
    int freeSpace, i, itemSize, totalUnassigned;
    int lastUnassignedPriority;

    //
    // For the CD-ROM case, all files go on disk 1.
    //
    if(useCdPath) {

        for(i=0; i<records; i++) {
            e[i].disk = 1;
        }

        return;
    }

    //
    // Start out with all files not assigned to any disk.
    //
    totalUnassigned = records;

    for(i=0; i<records; i++) {

        //
        // Note files that are hard-coded to a particular disk.
        //
        if(e[i].disk > 0) {
            totalUnassigned--;
        }
    }

    //
    // The way the infs and [Source Media Descriptions] sections
    // are written, there MUST be a disk 1.  So start with disk 1.
    // Disk 1 will actually be disk 4 because of the boot floppies,
    // but that's not important here.
    //
    disk = 1;

    do {

        //
        // Disk is initially empty.
        //
        freeSpace = diskSize;

        //
        // Look for files that are hardcoded to the current disk.
        // Reduce the amount of free space available on the current disk
        // accordingly.
        //
        for(i=0; i<records; i++) {

            if((e[i].disk == disk) && (!i || !Same(&e[i],&e[i-1]))) {
                freeSpace -= _stricmp(e[i].nocompress,"x") ? e[i].csize : e[i].size;
            }
        }

        lastUnassignedPriority = 1000;

        for(i=0; i<records; i++) {

            //
            // If the current file is unassigned, attempt to assign it
            // to a disk.
            //
            if(e[i].disk == 0) {

                //
                // If this is the same file as the preceeding entry,
                // we're done with this file.
                //
                if(i && Same(&e[i],&e[i-1])) {

                    e[i].disk = e[i-1].disk;

                } else {

                    itemSize = _stricmp(e[i].nocompress,"x") ? e[i].csize : e[i].size;

                    //
                    // If there is enough space on the current disk for this file,
                    // assign the file to the current disk and adjust the amount of
                    // free space remaining accordingly.
                    //
                    if(freeSpace >= itemSize) {

                        if((e[i].priority <= lastUnassignedPriority)
                        || ((e[i].priority == 999) && (lastUnassignedPriority>9)))
                        {
                            e[i].disk = disk;
                            freeSpace -= itemSize;
                        }
                    } else if(itemSize >= diskSize) {

                        PRINT2("ERROR File %s is too big for any disk.  Assigned to disk 999.\n",e[i].name)
                        e[i].disk = 999;

                    } else if(lastUnassignedPriority == 1000) {
                        lastUnassignedPriority = e[i].priority;
                    }
                }

                //
                // If we successfully assigned this file to a disk,
                // note that fact here.
                //
                if(e[i].disk) {
                    totalUnassigned--;
                }
            }
        }

        PRINT3("INFO Disk: %2.d Free Space: %7.d\n",disk,freeSpace)

        //
        // Move to next disk.
        //
        disk++;

    } while(totalUnassigned);
}

__cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *outLayout;
    Entry *e;
    int records,i;
    char *buf;

    if (argc!=6) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
    printf("ERROR Couldn't open log file %s\n",argv[1]);
    return(1);
    }
    Header(argv);
    LoadFile(argv[2],&buf,&e,&records,argv[4]);

    if (MyOpenFile(&outLayout,argv[3],"wb")) return(1);

    if (!_stricmp(argv[4],"ntflop") || !_stricmp(argv[4],"lmflop"))
    useCdPath=0;
    else
    useCdPath=1;

    //
    // munge the compress flag depending on the product type.
    // if we are laying out floppies, then files are always
    // compressed unless a special flag is set in the bom.
    //
    if(!useCdPath) {
        for (i=0;i<records;i++) {
            if(_strnicmp(e[i].nocompress,"xfloppy",7)) {
                //
                // not xfloppy; not uncompressed.
                //
                e[i].nocompress = "";
            } else {
                e[i].nocompress = "x";
            }
        }
    }

    qsort(e,records,sizeof(Entry),PrioritySizeNameCompare);

    LayoutAssignDisks(e,atoi(argv[5]),records);

    i=0; while ((fputc(buf[i++],outLayout))!='\n');
    for (i=0;i<records;i++)
    EntryPrint(&e[i],outLayout);

    fclose(outLayout);
    fclose(logFile);
    free(e);
    return(0);
}

int __cdecl PrioritySizeNameCompare(const void *v1, const void *v2)
{
    int result;
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    if (e1->priority!=e2->priority)
    return(e1->priority-e2->priority);
    if (e1->size!=e2->size)
    return(e2->size-e1->size);
    if (result=_stricmp(e1->name,e2->name))
    return(result);
    if (useCdPath)
    return(_stricmp(e1->cdpath,e2->cdpath));
    else
    return(0);  // always the same for floppies
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\layout\newlay.c ===
/*

Modifications:

01.10.94    Joe Holman  Added DISK_TO_START_NUMBERING_AT because
                we now have 2 bootdisks, thus we to start
                making floppies on disk # 3.
01.11.94    Joe Holman  Change value back to 2.
04.04.94    Joe Holman      Add debugging to LayoutDisks.

*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;
char* product;
int useCdPath;

BOOL    bAssigned[15000];   // should put this in Entry struct after Beta.

struct _list {

    char name[15];   // name of file
    int size;
    int csize;
    int disk;
    int priority;
    char nocompress[15];

};
struct _list fileList[15000];
int numFiles;
int    totalCompressed=0;
int    totalUnCompressed=0;

void    Msg ( const char * szFormat, ... ) {

    va_list vaArgs;

    va_start ( vaArgs, szFormat );
    vprintf  ( szFormat, vaArgs );
    vfprintf ( logFile, szFormat, vaArgs );
    va_end   ( vaArgs );
}


void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== LAYOUT =============\n")
    PRINT2("Input BOM: %s\n",argv[2])
    PRINT2("Output Layout: %s\n",argv[3])
    PRINT2("Product: %s\n",argv[4])
    PRINT2("Floppy Size: %s\n",argv[5])
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Assigns files to disks and generates a layout file.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM for which a layout is to be made.\n");
    printf("[OutLayout] - Path of new layout.\n");
    printf("[Product] - Product to lay out.\n");
    printf("            NTFLOP = Windows NT on floppy\n");
    printf("            LMFLOP = Lan Manager on floppy\n");
    printf("            NTCD = Windows NT on CD\n");
    printf("            LMCD = Lan Manager on CD\n");
    printf("            SDK = Software Development Kit\n");
    printf("[FloppySize] - Size in bytes of the second disk.\n\n");
}

int __cdecl PrioritySizeNameCompare(const void*,const void*);

int Same(Entry * e1, Entry * e2) {

    char *p1, *p2;
    BOOL    bSame;

    if (useCdPath) {

        p1=e1->cdpath;
        p2=e2->cdpath;
    }
    else {

        p1="x";
        p2=p1;
    }

    bSame = (!_stricmp(e1->name,e2->name)) &&
            (!_stricmp(e1->path,e2->path)) &&
            (!_stricmp(e1->source,e2->source)) &&
            (!_stricmp(p1,p2));

    if ( !bSame ) {

        Msg ( "\n>>>>>>>\n" );
        Msg ( "e1->name = %s\n", e1->name );
        Msg ( "e2->name = %s\n", e2->name );
        Msg ( "e1->path = %s\n", e1->path );
        Msg ( "e2->path = %s\n", e2->path );
        Msg ( "e1->source = %s\n", e1->source );
        Msg ( "e2->source = %s\n", e2->source );
        Msg ( "p1 = %s\n", p1 );
        Msg ( "p2 = %s\n", p2 );
    }

    return ( bSame );
}

BOOL    FindFile ( char * name ) {

    int i;

    for ( i = 0; i < numFiles; ++i ) {

        if ( _stricmp ( name, fileList[i].name ) == 0 ) {

            return TRUE;    // found the file in the file list
        }

    }

    return FALSE;   // did NOT find the file in the file list.

}

void    AddFileToList ( char * name,
                        int size,
                        int csize,
                        int disk,
                        int priority,
                        char * nocompress ) {

    sprintf ( fileList[numFiles].name, "%s", name );
    fileList[numFiles].size  = size;
    fileList[numFiles].csize = csize;
    fileList[numFiles].disk  = disk;
    fileList[numFiles].priority = priority;
    sprintf ( fileList[numFiles].nocompress, "%s", nocompress );

    totalUnCompressed += fileList[numFiles].size;
    totalCompressed   += fileList[numFiles].csize;

    Msg ( "totalUncomp = %d, size = %d,totalComp = %d, csize = %d\n", totalUnCompressed, fileList[numFiles].size, totalCompressed, fileList[numFiles].csize );

    if ( fileList[numFiles].size < fileList[numFiles].csize ) {

        Msg ( "ER: %s compressed bigger than uncomp\n", fileList[numFiles].name );
    }

    ++numFiles;


}

void    MakeEntries ( Entry * e, int records ) {


    int i;
    BOOL    bInList;

    int numFiles = 0;

    for ( i = 0; i < records; i++ ) {

        bInList = FindFile ( e[i].name );

        if ( !bInList ) {

            AddFileToList ( e[i].name,
                            e[i].size,
                            e[i].csize,
                            e[i].disk,
                            e[i].priority,
                            e[i].nocompress );
        }
    }

}

void    ShowEntries ( void ) {

    int i;

    totalCompressed=0;
    totalUnCompressed=0;

    for ( i = 0; i < numFiles; ++i ) {

        Msg ( "#%d\t%s,nocomp=%d,comp=%d,priority=%d,disk=%d,%s\n",
                                    i,
                                    fileList[i].name,
                                    fileList[i].size,
                                    fileList[i].csize,
                                    fileList[i].priority,
                                    fileList[i].disk,
                                    fileList[i].nocompress );

        totalCompressed+=fileList[i].csize;
        totalUnCompressed+=fileList[i].size;
    }

    Msg ( "totalCompressed = %d, totalUnCompressed = %d\n\n\n",
        totalCompressed, totalUnCompressed );

}

//
//  Returns TRUE if a file hasn't been assigned a disk #, ie. 0.
//  Returns FALSE if all have been assigned.
//
BOOL    FileUnAssigned ( void ) {

    int i;

    for ( i = 0; i < numFiles; ++i ) {

        if ( fileList[i].disk == 0 ) {

            return TRUE;
        }

    }

    return FALSE;

}

void    StuffDiskNumIntoRecords ( void ) {


}

void LayoutAssignDisks(e,diskSize,records)
Entry* e;
int diskSize;
int records;
{

#define DISK_TO_START_NUMBERING_AT 1    // must start on disk #1 for all files.


    //
    //
    //  Do we REALLY need to use disk # assignment in BOM ?????
    //  With proper Priority, we shouldn't really need this...
    //
    //
    //
    //

    int disk=DISK_TO_START_NUMBERING_AT;
    int freeSpace;
    int i, itemSize, totalUnassigned;
    int lastUnassignedPriority;
    int workingPriority;


    //
    //  Make unique entries for each file for the product.
    //
    MakeEntries ( e, records );
    ShowEntries ( );


    //  Priority values can be from 1-1000;
    //

    do {

        //  Free space left to begin with is the disk size.
        //
        freeSpace=diskSize - 512;  // add in safety fudge factor...

        Msg ( "\n\n\n\n\nInitial Disk #%d freeSpace = %d\n", disk, freeSpace );

        //  First, find all the files that
        //  are HARDCODED to go on this disk.
        //
        //
        Msg ( "\n\n\nAnalyze HARDCODED disk #s...\n\n" );
        for ( i=0; i < numFiles; i++) {

            if ( fileList[i].disk == disk) {

                if ( fileList[i].nocompress[1] == 'x' ||
                     fileList[i].nocompress[1] == 'X'    ) {

                    freeSpace -= fileList[i].size;

                    Msg ( "freeSpace(nocomp) = %d, %d, %s, disk #%d, prio = %d\n",
                                freeSpace,
                                fileList[i].size,
                                fileList[i].name, disk, fileList[i].priority );

                }
                else {

                    freeSpace -= fileList[i].csize;

                    Msg ( "freeSpace(comp) = %d, %d, %s, disk #%d, prio = %d\n",
                                freeSpace,
                                fileList[i].csize, fileList[i].name, disk, fileList[i].priority );
                }
            }
        }

        //  We have a big problem if our freespace is less than 0.
        //  I.E, too many disks have HARDCODED disk # for this disk.
        //
        if ( freeSpace < 0 ) {

            Msg ( "FATAL ER:  disk #%d freeSpace = %d\n", disk, freeSpace );
            Msg ( ">>>> Too many files with HARDCODED disk #%d\n", disk);
        }

#define NOT_ASSIGNED_YET 0
#define MAX_GROUPING_NUM 1000

        //  Now let's deal with the PRIORITY.
        //
        Msg ( "\n\n\nAnalyze GROUPINGS...\n\n" );
        workingPriority = 1;
        do {

            for ( i = 0; i < numFiles; ++i ) {

                int fileSize;

                if ( fileList[i].disk == NOT_ASSIGNED_YET ) {


                    if ( fileList[i].nocompress[1] == 'x' ||
                         fileList[i].nocompress[1] == 'X'    ) {

                        fileSize = fileList[i].size;
                    }
                    else {
                        fileSize = fileList[i].csize;
                    }

                    if ( fileList[i].priority <= workingPriority &&

                         freeSpace-fileSize > 0 )  {

                        freeSpace -= fileSize;
                        fileList[i].disk = disk;

                        Msg ( "freespace(%s) = %d, %s, disk #%d, priority = %d, csize=%d,size=%d\n",
                                (_stricmp(fileList[i].nocompress,"x")) ? "comp" : "nocomp",
                                freeSpace,
                                fileList[i].name, disk, workingPriority,
                                fileList[i].csize, fileList[i].size );
                    }

                }

            }

            ++workingPriority;

            if ( workingPriority > MAX_GROUPING_NUM ) {

                break;
            }

            //Msg ( "workingPriority = %d, freeSpace = %d, disk = %d\n",
            //        workingPriority, freeSpace, disk );

        } while ( freeSpace > 0 && FileUnAssigned() );

        Msg ( "Disk %d Excess Space:  %d\n", disk, freeSpace );

        ++disk;

    } while ( FileUnAssigned() );

    ShowEntries ( );
    StuffDiskNumIntoRecords ();

exit(0);

    //  # of unassigned files.
    //
    totalUnassigned = records;

    //
    //
    //  After BETA, rewrite the following algorithms to:
    //
    //      o not use totalUnassigned.
    //      o to be better written algorithm below for laying out.
    //
    //
    //  Calculate the # of unassigned files, and initiate the disk #
    //  for each to be layed-out from.
    //
    for (i=0;i<records;i++) {

        //  If this file has specific disk # to be on, reduce the
        //  # of files to be assigned by 1.
        //
        if(e[i].disk>0) {
            totalUnassigned--;
        }

        //  Is this code ever executed ????
        //
        // this stuff is bs -- if this is the cd, we should detect that earlier
        // and have a simple loop for that case.  All files on the cd must be
        // on disk 1.
        //
        // if(diskSize > CD_SIZE) {
        //     for(i=0; i<records; i++) {
        //         e[i].disk = 1;
        //     }
        // }
        //
        if( (e[i].disk>=DISK_TO_START_NUMBERING_AT) && (diskSize>CD_SIZE))
        {

            e[i].disk=DISK_TO_START_NUMBERING_AT;
            bAssigned[i] = TRUE;

            Msg ( "ever-executed?:  %s, %d, %d\n",
                            e[i].source, e[i].disk, diskSize );
        }
    }

    //
    //
    do {

        //  Free space left to begin with is the disk size.
        //
        freeSpace=diskSize - 512;  // add in safety fudge factor...

        Msg ( "freeSpace(init) = %d, %d\n", freeSpace, diskSize );

        //  First, find all the files that
        //  are HARDCODED to go on this disk.
        //
        //
        for ( i=0; i<records; i++) {

            //
            //  Rules:  specific disk # assignment, next available i==0,
            //          or !Same (due to multiple entries in the bom
            //          for the same file, but used for different inf lines.
            //    >>> If we remove multiple entries in bom for same files
            //       this test can be removed.
            //

            // SAME() JUST WONT WORK IF E entries ARE NOT IN ALPHABETICALL ORDER.
            //  AND, that is just the CASE, some of them are not in ORDER,
            //  that's why we are getting some negative values for disk size.
            //

            if ( (e[i].disk==disk) &&
                 ((i==0) || !Same(&e[i],&e[i-1]))) {

                if (!_stricmp(e[i].nocompress,"x")) {
                    freeSpace-=e[i].size;
                    Msg ( "freeSpace(nocomp) = %d, %d, %s, disk #%d, i = %d\n",
                                    freeSpace, e[i].size, e[i].name, disk, i );
                }
                else {
                    freeSpace-=e[i].csize;
                    Msg ( "freeSpace(comp) = %d, %d, %s, disk #%d, i = %d\n",
                                    freeSpace, e[i].csize, e[i].name, disk, i );
                }
            }
        }

        //  We have a big problem if our freespace is less than 0.
        //  I.E, too many disks have HARDCODED disk # for this disk.
        //
        if ( freeSpace < 0 ) {

            Msg ( "FATAL ER:  disk #%d freeSpace = %d\n", disk, freeSpace );
            Msg ( ">>>> Too many files with HARDCODED disk #%d\n", disk);
        }

        //  Now, fill the floppies with files working with the Highest Priority.
        //
        lastUnassignedPriority=1000;

        for ( i=0; i<records; i++) {

            //
            //  If the file hasn't been assigned yet, ie. 0, figure the disk
            //  for it to live on.
            //
            if (e[i].disk==0) {

                //
                //  WHEN WE GET RID OF MULTIPLE ENTRIES IN THE BOM FOR
                //  THE SAME FILE, WE CAN GET RID OF THE 'SAME' FUNCTION
                //  BECAUSE THIS LOOKS TO SEE THAT THE LAST FILE PROCESSED
                //  HAD THE SAME NAME (DUE TO INF MULTIPLE INSTANCES).
                //
                if ((i!=0) && Same(&e[i],&e[i-1])) {

                    // If we aren't on the 1st e entry AND
                    //  we have the same filename, then just
                    //  give the same disk # as PREVIOUSLY assigned.
                    //
                    e[i].disk=e[i-1].disk;
                    bAssigned[i] = TRUE;
                    Msg ( "Assign(same-as-last)  %s: %d\n",
                                                e[i].name, e[i].disk );
                }
                else {

                    //  Get the size of the file in compressed or non-comp
                    //  format.
                    //
                    itemSize =
                    (!_stricmp(e[i].nocompress,"x")) ? e[i].size : e[i].csize;


                    //  If the file can fit on the floppy,
                    //  see if we can assign it to the disk #.
                    //
                    if ( freeSpace >= itemSize ) {

                        if ((e[i].priority<=lastUnassignedPriority) ||
                         ((e[i].priority==999) && (lastUnassignedPriority>9))) {


                            if ( e[i].priority <= lastUnassignedPriority) {
                                Msg ( ">>> priority %d <= lastUnassignedPriority %d\n", e[i].priority, lastUnassignedPriority );
                            }


                            if ( (e[i].priority==999) &&
                                 (lastUnassignedPriority>9) ) {
                                Msg ( ">>> priority==999 && lastUnassignedPriority %d > 9\n", lastUnassignedPriority );
                            }

                            //  Assign the disk #.
                            //
                            e[i].disk=disk;
                            bAssigned[i] = TRUE;
                            Msg ( "Assign(1)  %s: %d\n", e[i].name, e[i].disk );

                            //  Free space remaining...
                            //
                            freeSpace-=itemSize;
                            Msg ( "freeSpace(3) = %d, %d\n", freeSpace, itemSize );
                        }
                    }
                    else if (lastUnassignedPriority==1000) {

                        //  ???????
                        //
                        lastUnassignedPriority=e[i].priority;

                        Msg ( "?????ever get executed(2) - lastUnassignedPriority = %d\n", e[i].priority );
                    }

                    //  Look for files that are TOO big to fit on media.
                    //
                    if ( itemSize >= diskSize) {

                        Msg ("FATAL ERROR: %s too big, %d bytes\n",
                                                     e[i].name, itemSize );

                        //  Assign the disk #, although invalid.
                        //
                        e[i].disk=999;
                        bAssigned[i] = TRUE;
                        Msg ( "Assign  %s: %d\n", e[i].name, e[i].disk );
                    }
                }

                //  If the disk# is no longer 0, then file has been assigned.
                //
                if (e[i].disk) {
                    totalUnassigned--;
                }

                if ( freeSpace < 0 ) {

                    Msg ( "FATAL ER:   freeSpace %d < 0\n", freeSpace );

                }
            }
        }

        //  Tell the amount of space left on the disk.
        //
        //PRINT3("INFO Disk: %2.d Free Space: %7.d\n",disk,freeSpace)
        Msg ( "Disk %d Free Space:  %d\n", disk, freeSpace );
        disk++;

    } while (totalUnassigned>0);    // continue until all files assigned.

    //
    // the above 'totalUnassigned' method is bad, what if the # gets
    // off by some reason.  better thing to do is have flag for
    // each file saying bAssigned yet or not.
    //

    //  Reduce the last disk # by 1.
    //
    disk--;

}

__cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *outLayout;
    Entry *e;
    int records,i;
    char *buf;

    if (argc!=6) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
        printf("ERROR Couldn't open log file %s\n",argv[1]);
        return(1);
    }
    Header(argv);
    LoadFile(argv[2],&buf,&e,&records,argv[4]);

    if (MyOpenFile(&outLayout,argv[3],"wb")) return(1);

    if (!_stricmp(argv[4],"ntflop") || !_stricmp(argv[4],"lmflop")) {
        useCdPath=0;
    }
    else {
        useCdPath=1;
    }

    //
    // munge the compress flag depending on the product type.
    // if we are laying out floppies, then files are always
    // compressed unless a special flag is set in the bom.
    //
    if(!useCdPath) {
        for (i=0;i<records;i++) {
            if(_strnicmp(e[i].nocompress,"xfloppy",7)) {
                //
                // not xfloppy; not uncompressed.
                //
                e[i].nocompress = "";
            } else {
                e[i].nocompress = "x";
            }
        }
    }

#ifdef JOE
#else
    qsort(e,records,sizeof(Entry),PrioritySizeNameCompare);

    LayoutAssignDisks(e,atoi(argv[5]),records);
#endif

    i=0;
    while ((fputc(buf[i++],outLayout))!='\n');
    for (i=0;i<records;i++) {
        EntryPrint(&e[i],outLayout);
    }

    fclose(outLayout);
    fclose(logFile);
    free(e);
    return(0);
}

int __cdecl PrioritySizeNameCompare(const void *v1, const void *v2)
{
    int result;
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    if (e1->priority!=e2->priority)
    return(e1->priority-e2->priority);
    if (e1->size!=e2->size)
    return(e2->size-e1->size);
    if (result=_stricmp(e1->name,e2->name))
    return(result);
    if (useCdPath)
    return(_stricmp(e1->cdpath,e2->cdpath));
    else
    return(0);  // always the same for floppies.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\general\general.h ===
#define ALLOCATION_UNIT 512
#define DMF_ALLOCATION_UNIT 1024 
#define CD_SIZE 300000000

#define PRINT1(X)     { printf(X);     fprintf(logFile,X); }
#define PRINT2(X,Y)   { printf(X,Y);   fprintf(logFile,X,Y); }
#define PRINT3(X,Y,Z) { printf(X,Y,Z); fprintf(logFile,X,Y,Z); }
#define PRINT4(X,Y,Z,Q) { printf(X,Y,Z,Q); fprintf(logFile,X,Y,Z,Q); }

typedef struct _Entry
{
    char *name;
    char *source;
    char *path;
    char *flopmedia;
    char *comment;

    char *product;

    char *sdk;

    char *platform;

    char *cdpath;

    char *inf;
    char *section;
    char *infline;

    int size;
    int csize;
    char *nocompress;
    int priority;

    char *lmacl;
    char *ntacl;
    char *aclpath;

    char *medianame;

    int disk;
} Entry;

void EntryPrint(Entry* entry,
        FILE* readFile);

void EntryRead(Entry* entry,
           char* bomLine);

int EntryMatchProduct(Entry* entry,
              char* product);

int MyOpenFile(FILE** f,
           char* fileName,
           char* mode);

void LoadFile(char* name,
          char** buf,
          Entry** e,
          int* records,
          char* product);

void convertName(char *oldName,
         char *newName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\general\genppc.c ===
//
//  08.08.94    Joe Holman      Added code for PPC.
//


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "general.h"

extern FILE* logFile;

#define PLATFORM_COUNT  4
#define X86_PLATFORM	2   // index #2 into PSTR's below.

PSTR GenericSubstitutions[PLATFORM_COUNT] = { "alpha","mips","i386", "ppc" };
PSTR PlatformSubstitutions[PLATFORM_COUNT] = { "alpha","mips","x86", "ppc" };
PSTR AclpathSubstitutions[PLATFORM_COUNT] = { "w32alpha","w32mips","w32x86", "w32ppc" };

typedef struct _TRACKED_STRING {
    struct _TRACKED_STRING *Next;
    PSTR String;
} TRACKED_STRING, *PTRACKED_STRING;

PTRACKED_STRING SourceFieldStrings;
PTRACKED_STRING PathFieldStrings;
PTRACKED_STRING PlatformFieldStrings;
PTRACKED_STRING CdPathFieldStrings;
PTRACKED_STRING InfFileFieldStrings;
PTRACKED_STRING InfSectionFieldStrings;
PTRACKED_STRING AclPathFieldStrings;



VOID
ExpandField(
    IN OUT PSTR            *Field,
    IN     PSTR             SubstituteText,
    IN OUT PTRACKED_STRING *StringList
    )
{
    unsigned c;
    PSTR p;
    CHAR buf[1000];
    PTRACKED_STRING s;

    if(p = strchr(*Field,'@')) {

        c = p - (*Field);

        //
        // Create the platform-specific string.
        //
        strncpy(buf,*Field,c);
        buf[c] = 0;
        strcat(buf,SubstituteText);
        strcat(buf,(*Field) + c + 1);

    } else {

        //
        // No @, field doesn't need to change.
        //
        return;
    }

    //
    // See whether we already have this string.
    //
    s = *StringList;
    while(s) {
        if(!_stricmp(buf,s->String)) {
            *Field = s->String;
            return;
        }
        s = s->Next;
    }

    //
    // We don't already have it.  Create it.
    //
    s = malloc(sizeof(TRACKED_STRING));
    if(!s) {
        PRINT1("ERROR Couldn't allocate enough memory.\n")
        exit(1);
    }

    s->String = _strdup(buf);
    if(!s->String) {
        PRINT1("ERROR Couldn't allocate enough memory.\n")
        exit(1);
    }

    *Field = s->String;

    s->Next = *StringList;
    *StringList = s;
}


VOID
ExpandPlatformIndependentEntry(
    IN OUT Entry *e,
    IN     int    FirstRecord
    )
{
    int i,j;
    Entry t;

    t = *(e+FirstRecord);

    for(i=0,j=FirstRecord; i<PLATFORM_COUNT; i++,j++) {

        *(e+j) = t;

        //
        // expand the source field.
        //
        ExpandField(&e[j].source,PlatformSubstitutions[i],&SourceFieldStrings);

        //
        // expand the path field.
        //
        ExpandField(&e[j].path,GenericSubstitutions[i],&PathFieldStrings);

        //
        // expand the platform field.
        //
        ExpandField(&e[j].platform,PlatformSubstitutions[i],&PlatformFieldStrings);

        //
        // expand the cdpath field.
        //
        ExpandField(&e[j].cdpath,GenericSubstitutions[i],&CdPathFieldStrings);

        //
        // expand the inf file field.
        //
        ExpandField(&e[j].inf,GenericSubstitutions[i],&InfFileFieldStrings);

        //
        // expand the inf section field.
        //
        ExpandField(&e[j].section,GenericSubstitutions[i],&InfSectionFieldStrings);

        //
        // expand the aclpath section field.
        //
        ExpandField(&e[j].aclpath,AclpathSubstitutions[i],&AclPathFieldStrings);
    }
}

VOID
ExpandPlatformEntryX86Only(
    IN OUT Entry *e,
    IN     int    FirstRecord
    )
{
    int i,j;
    Entry t;

    t = *(e+FirstRecord);

    i = X86_PLATFORM; 
    j = FirstRecord;

    *(e+j) = t;

    //
    // expand the source field.
    //
    ExpandField(&e[j].source,PlatformSubstitutions[i],&SourceFieldStrings);

    //
    // expand the path field.
    //
    ExpandField(&e[j].path,GenericSubstitutions[i],&PathFieldStrings);

    //
    // expand the platform field.
    //
    ExpandField(&e[j].platform,PlatformSubstitutions[i],&PlatformFieldStrings);

    //
    // expand the cdpath field.
    //
    ExpandField(&e[j].cdpath,GenericSubstitutions[i],&CdPathFieldStrings);

    //
    // expand the inf file field.
    //
    ExpandField(&e[j].inf,GenericSubstitutions[i],&InfFileFieldStrings);

    //
    // expand the inf section field.
    //
    ExpandField(&e[j].section,GenericSubstitutions[i],&InfSectionFieldStrings);

    //
    // expand the aclpath section field.
    //
    ExpandField(&e[j].aclpath,AclpathSubstitutions[i],&AclPathFieldStrings);
}

void LoadFile(name,buf,e,records,product)
char* name;
char** buf;
Entry** e;
int* records;
char* product;
{
    int match,i;
    HANDLE h;
    DWORD size,sizeRead,x;
    BOOL result;
    char* j;

    (*records)=0;
    h=CreateFile(name,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    size=GetFileSize(h,NULL);
    if ((h==INVALID_HANDLE_VALUE) || (size==-1))
    {
    PRINT2("ERROR Couldn't open %s for reading.\n",name)
    exit(1);
    }
    if (((*buf)=malloc(size))==NULL)
    {
    PRINT1("ERROR Couldn't allocate enough memory to read file.\n")
    exit(1);
    }
    result=ReadFile(h,*buf,size,&sizeRead,NULL);
    if ((sizeRead!=size) || (result==FALSE))
    {
    PRINT2("ERROR Couldn't read all of %s.\n",name)
    exit(1);
    }

    x=0; while((*buf)[x++]!='\n');
    while(x<size) {
        if ((*buf)[x]=='\t') (*buf)[x]='\0';
        if ((*buf)[x]=='\n') (*records)++;
        x++;
    }

    CloseHandle(h);

    //
    // Allocate maximum possible number of entries required.
    //
    if (((*e)=malloc(PLATFORM_COUNT*sizeof(Entry)*(*records)))==NULL) {
        PRINT1("ERROR Couldn't allocate enough space for database entries.\n")
        exit(1);
    }

    j=(*buf);
    while (*j++!='\n');
    match=0;

    for (i=0;i<(*records);i++) {

        (*e)[match].name=j; while ((*j!='\n') && (*j++));
        (*e)[match].source=j; while ((*j!='\n') && (*j++));
        (*e)[match].path=j; while ((*j!='\n') && (*j++));
        (*e)[match].flopmedia=j; while ((*j!='\n') && (*j++));
        (*e)[match].comment=j; while ((*j!='\n') && (*j++));
        (*e)[match].product=j; while ((*j!='\n') && (*j++));
        (*e)[match].sdk=j; while ((*j!='\n') && (*j++));
        (*e)[match].platform=j; while ((*j!='\n') && (*j++));
        (*e)[match].cdpath=j; while ((*j!='\n') && (*j++));
        (*e)[match].inf=j; while ((*j!='\n') && (*j++));
        (*e)[match].section=j; while ((*j!='\n') && (*j++));
        (*e)[match].infline=j; while ((*j!='\n') && (*j++));
        (*e)[match].size=atoi(j); while((*j!='\n') && (*j++));
        (*e)[match].csize=atoi(j); while((*j!='\n') && (*j++));
        (*e)[match].nocompress=j; while ((*j!='\n') && (*j++));
        (*e)[match].priority=atoi(j); while ((*j!='\n') && (*j++));
        (*e)[match].lmacl=j; while ((*j!='\n') && (*j++));
        (*e)[match].ntacl=j; while ((*j!='\n') && (*j++));
        (*e)[match].aclpath=j; while ((*j!='\n') && (*j++));
        (*e)[match].medianame=j; while ((*j!='\n') && (*j++));
        (*e)[match].disk=atoi(j); while ((*j!='\n') && (*j++));
        j++;

        (*e)[match].name=_strupr((*e)[match].name);
        (*e)[match].medianame=_strupr((*e)[match].medianame);

        if (EntryMatchProduct(&((*e)[match]),product)) {

            //
            // If this is a platform-independent entry,
            // expand it into one entry per platform.
            //
            if(((*e)[match].platform[0] == '@')
            || ((*e)[match].source[0] == '@')
            || ((*e)[match].cdpath[1] == '@'))
            {

				//	If we are working with x86 floppies,
				//	just expand for x86, no need for overhead with
				//	other platforms.
				//
				if ( !_stricmp(product,"LMFLOP") || 
					 !_stricmp(product,"NTFLOP") ) {
					PRINT2( "%s:  Expanding ONLY for X86 flops...\n", (*e)[match].name );
					ExpandPlatformEntryX86Only( *e, match );
					++match;
				}
				else {
               		ExpandPlatformIndependentEntry(*e,match);
               		match += PLATFORM_COUNT;
				}

            } else {

				//	The data is ok as is here.
                match++;
            }
        }
    }

    //
    // Skip first line (column headings).
    //
    j=*buf;
    while (*j++!='\n');

    //
    // Change newlines into line terminators,
    // so the final field on each line will be terminated properly.
    //
    while(*records) {
        if((*j)=='\n') {
            *j='\0';
            (*records)--;
        }
        j++;
    }

    //
    // Shrink the array of records to its actual size.
    //
    *e = realloc(*e,match*sizeof(Entry));
    (*records)=match;
}

void EntryPrint(entry,f)
Entry* entry;
FILE *f;
{
    fprintf(f,"%s\t",entry->name);
    fprintf(f,"%s\t",entry->source);
    fprintf(f,"%s\t",entry->path);
    fprintf(f,"%s\t",entry->flopmedia);
    fprintf(f,"%s\t",entry->comment);

    fprintf(f,"%s\t",entry->product);

    fprintf(f,"%s\t",entry->sdk);

    fprintf(f,"%s\t",entry->platform);

    fprintf(f,"%s\t",entry->cdpath);

    fprintf(f,"%s\t",entry->inf);
    fprintf(f,"%s\t",entry->section);
    fprintf(f,"%s\t",entry->infline);

    fprintf(f,"%d\t",entry->size);
    fprintf(f,"%d\t",entry->csize);
    fprintf(f,"%s\t",entry->nocompress);
    fprintf(f,"%d\t",entry->priority);

    fprintf(f,"%s\t",entry->lmacl);
    fprintf(f,"%s\t",entry->ntacl);
    fprintf(f,"%s\t",entry->aclpath);

    fprintf(f,"%s\t",entry->medianame);

    fprintf(f,"%d\r\n",entry->disk);
}

int EntryMatchProduct(entry,product)
Entry* entry;
char* product;
{
    if (!_stricmp(product,"ALL"))
    return(1);

    return

        //
        // Laying out NT floppies AND entry is not for AS-only
        // AND entry specifies that this file goes on floppy
        //
        (!_stricmp(product,"NTFLOP") 				// include X86 floppy files
		  && _stricmp(entry->product,"as")			// exclude AS only files 
		  && (entry->priority < 1000)				// include prioty < 1000 
		  && _stricmp(entry->source,"alphabins") 	// exclude alphabins files
		  && _stricmp(entry->source,"mipsbins")  	// exclude mipsbins files 
          && _stricmp(entry->source,"ppcbins")   // exclude ppcbins files
		  && _stricmp(entry->path,"\\mips")			// exclude mips path files
		  && _stricmp(entry->path,"\\alpha")			// exclude alpha path files
          && _stricmp(entry->path,"\\ppc")       // exclude ppc path files 
		  && _stricmp(entry->source,"alphadbg")		// exclude alphadbg files
		  && _stricmp(entry->source,"mipsdbg")		// exclude mipsdbg files
          && _stricmp(entry->source,"ppcdbg" )   // exclude ppcdbg files
		  && _stricmp(entry->source,"x86dbg")		// exclude x86dbg files
	    )

        //
        // Laying out AS floppies AND entry is not for NT-only
        // AND entry specified that this file goes on floppy
        //
     || (!_stricmp(product,"LMFLOP") 
		  && _stricmp(entry->product,"nt")			// exclude NT only files 
		  && (entry->priority < 1000)				 
		  && _stricmp(entry->source,"alphabins") 
		  && _stricmp(entry->source,"mipsbins")  
          && _stricmp(entry->source,"ppcbins")   // exclude ppcbins files
		  && _stricmp(entry->path,"\\mips")			
		  && _stricmp(entry->path,"\\alpha")		
          && _stricmp(entry->path,"\\ppc")       // exclude ppc path files 
		  && _stricmp(entry->source,"alphadbg")
		  && _stricmp(entry->source,"mipsdbg")
          && _stricmp(entry->source,"ppcdbg" )   // exclude ppcdbg files
		  && _stricmp(entry->source,"x86dbg")
		)

        //
        // Laying out nt cd-rom and entry is not for as only
        //
     || (!_stricmp(product,"NTCD") && _stricmp(entry->product,"as"))

        //
        // Laying out as cd-rom and entry is not for nt only
        //
     || (!_stricmp(product,"LMCD") && _stricmp(entry->product,"nt"))

        //
        // Laying out sdk
        //
     || (!_stricmp(product,"SDK") && !_stricmp(entry->sdk,"x"));
}

int MyOpenFile(f,fileName,mode)
FILE** f;
char* fileName;
char* mode;
{
    if ((*f=fopen(fileName,mode))==NULL)
    {
    PRINT3("ERROR Couldn't open %s for %s\n",fileName,mode)
    return(1);
    }
    return(0);
}

void convertName(oldName,newName)
char* oldName;
char* newName;
{
    unsigned i;
    unsigned period;

    strcpy(newName,oldName);
    for (period=(unsigned)(-1),i=0;i<strlen(oldName);i++) if (oldName[i]=='.') period=i;
    if (period==(strlen(oldName)-4))
    newName[strlen(newName)-1]='_';
    else if (period==(unsigned)(-1))
    strcat(newName,"._");
    else
    strcat(newName,"_");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\infs\infs.c ===
//
//	05.10.94	Joe Holman		Add better messaging and commented out some
//								debugging code for media generation.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== INFS ===============\n");
    PRINT2("Input Layout: %s\n",argv[2]);
    PRINT2("Target directory for file lists: %s\n",argv[3]);
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Creates INF file lists.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InLayout] - Path of Layout file from which INFs are generated.\n");
    printf("[Target Dir] - Directory where i386, mips, and alpha dirs are for lists.\n\n");
}

int Same(a,b)
char* a;
char* b;
{
    int i;
    int j;
    char tempa[100];
    char tempb[100];

    strcpy(tempa,a);
    strcpy(tempb,b);

    i=j=0;
    while (tempa[j]=tempa[i++])
    if (tempa[j]!=' ')
        j++;

    i=j=0;
    while (tempb[j]=tempb[i++])
    if (tempb[j]!=' ')
        j++;

    return(_stricmp(tempa,tempb));
}

void CreateInfs(e,path,records,cdProduct)
Entry* e;
char* path;
int records;
int cdProduct;
{
    int i,j,t,quotes;
    char inf[MAX_PATH];
    char infPath[MAX_PATH];
    char section[MAX_PATH];
    char line[MAX_PATH];
    FILE *f=NULL;
    inf[0]='\0';
    section[0]='\0';

    for (i=0;i<records;i++) {

		//Msg ( "inf = %s, i=%d\n", e[i].inf,i );

    	if (e[i].inf[0]) {

        	if (_stricmp(e[i].inf,inf)) {

        		if (f!=NULL) {
            		fprintf(f,"\r\n");
            		fclose(f);
        		}
        		strcpy(inf,e[i].inf);
        		strcpy(infPath,path);
        		if (path[strlen(path)-1]!='\\') {
            		strcat(infPath,"\\");
				}
        		strcat(infPath,inf);

        		if (MyOpenFile(&f,infPath,"wb")) {
					Msg ( "ERROR:  Must fix this problem, since all inf filelist's did not get created...\n" );
	 				exit(1);
				}
				//Msg ( "opening file:  %s\n", infPath );
        		PRINT2("INFO Making file list: %s\n",infPath)
        	}

			if (_stricmp(e[i].section,section) ||
				(!i) ||
				_stricmp(e[i].inf,e[i-1].inf)) {

				strcpy(section,e[i].section);
				//Msg ("section=%s\n", section );
        		fprintf(f,"\r\n%s\r\n",section);
        	}

        	if ((i==0) || (!((!_stricmp(e[i].name,e[i-1].name)) &&
				(!Same(e[i].inf,e[i-1].inf)) &&
				(!Same(e[i].infline,e[i-1].infline)) &&
				(!_stricmp(e[i].section,e[i-1].section))))) {

        		quotes=t=j=0;
        		line[0]='\0';
        		while (e[i].infline[j]) {

            		if (e[i].infline[j]=='\"')
            			quotes++;

            		if ((e[i].infline[j]!='\"') || ((quotes>2) && (quotes%2))){

						switch(e[i].infline[j])
            			{
                			case '[':
                			j++;
                			switch (e[i].infline[j])
                			{
                    			case 's': case 'S':
                    			sprintf(&line[t],"%d\0",e[i].size);
                    			break;
                    			case 'd': case 'D':
                    			sprintf(&line[t],"%d\0",e[i].disk);
                    			break;
                    			case 'n': case 'N':
                    			sprintf(&line[t],"%s\0",strlen(e[i].medianame) ? e[i].medianame : e[i].name);
                    			break;
                    			break;
                			}
                			while(e[i].infline[j++]!=']');
                			j--;
                			break;
                			default:
                			line[t++]=e[i].infline[j];
                			line[t]='\0';
                			break;
            			}
            			while(line[t++]);
            			t--;
            			}
            			j++;
        			}
        			line[t]='\0';
        			fprintf(f,"%s\r\n",line);
					//Msg ( "line=%s\n", line );
        		if (!e[i].infline[0]) {
            		PRINT2("WARNING - No INF line specified for %s\n",e[i].name)
				}
        	}
    	}
    	else {
        	PRINT2("WARNING - No INF file specified for %s\n",e[i].name)
		}
    }
    fclose(f);
}

int __cdecl InfCompare(const void*,const void*);

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry *e;
    char* buf;
    int records,i;
    int cdProduct;

    if (argc!=4) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
    printf("ERROR Couldn't open %s.\n",argv[1]);
    return(1);
    }
    Header(argv);

    LoadFile(argv[2],&buf,&e,&records,"ALL");
	//Msg ( "loaded records = %d\n", records );
    qsort(e,records,sizeof(Entry),InfCompare);

    //
    // If this is a cd-rom layout, all files will be on disk 1.
    // If floppy layout, some files will be on other disks.
    //
    for(cdProduct=1,i=0; i<records; i++) {
        if(e[i].disk > 1) {
            cdProduct=0;
            break;
        }
    }

    CreateInfs(e,argv[3],records,cdProduct);

    fclose(logFile);
    free(e);
    free(buf);
    return(0);
}

int __cdecl InfCompare(const void *v1, const void *v2)
{
    int result;
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    if (result=_stricmp(e1->inf,e2->inf)) return(result);
    if (result=_stricmp(e1->section,e2->section)) return(result);
    if (result=_stricmp(e1->infline,e2->infline)) return(result);
    return(_stricmp(e1->name,e2->name));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\infsize\infsize.c ===
//
//  10.25.95    Joe Holman      Created to calculate file sizes on the release shares
//                              and stick the size into _layout.inf.
//  12.04.95    Joe Holman      _Layout.inf is now Layout.inf.
//  10.16.96    Joe Holman      Comment out MIPS code, but leave there for P7 in a few 
//                              years. 
//  10.28.96    Joe Holman      Use actual file size, don't bump up for any cluster size.
//  01.20.97    Joe Holman      Comment out PPC.
//  07.31.97    Joe Holman      Changes for the build team since the release shares have
//                              compressed files now.
//  09.28.99    Joe Holman      Take out Alpha.
//

#include <windows.h>

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <ctype.h>

#define     MFL     256

BOOL    b;

char    LocalInfPath[MFL];
char	LocalFlatShare[MFL];
char	i386FlatShare[MFL];
//char	AlphaFlatShare[MFL];

#define idLOCAL 0
#define idX86   1
//#define idALPHA 3


// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;

void	Msg ( const CHAR * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}


void Header(argv,argc)
char * argv[];
int argc;
{
    time_t t;
    char tmpTime[100];
    CHAR wtmpTime[200];

    Msg ( "\n=========== INFSIZE ====================\n" );
	Msg ( "Log file                      : %s\n",    argv[1] );
    Msg ( "Local location of Layout.inf  : %s\n",    argv[2] );
    Msg ( "Local Flat directory location : %s\n",    argv[3] );
    Msg ( "x86   Flat directory location : %s\n",    argv[4] );
    //Msg ( "ALPHA Flat directory location : %s\n",    argv[5] );

    time(&t); 
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "==========================================\n\n");
}

void Usage()
{
    printf( "PURPOSE: Finds product file sizes for LAYOUT.INF\n");
    printf( "\n");
    printf( "PARAMETERS:\n");
    printf( "\n");
    printf( "[LogFile]   - Path to append a log of actions and errors.\n");
	printf( "[LocalInf]  - Local location of the layout.inf.\n" );
	printf( "[LocalPath] - Local flat directory containing product files.\n" );
	printf( "[x86Path]   - x86 flat directory containing product files.\n" );
	//printf( "[AlphaPath] - Alpha flat directory containing product files.\n" );

    printf( "\n"  );
}

char   dbgStr1[30];
char   dbgStr2[30];


#define FILE_SECTION_LOCAL "[SourceDisksFiles]"
#define FILE_SECTION_X86   "[SourceDisksFiles.x86]"
//#define FILE_SECTION_ALPHA "[SourceDisksFiles.alpha]"

#define FILE_SECTION_NOT_USED 0xFFFF

DWORD   dwInsideSection = FILE_SECTION_NOT_USED;

DWORD   FigureSection ( char * Line ) {

    //Msg ( "FigureSection on:  %s\n", Line );

    if ( strstr ( Line, FILE_SECTION_LOCAL )  ) {

        dwInsideSection = idLOCAL; 

    } 
    else
    if ( strstr ( Line, FILE_SECTION_X86 ) ) {

        dwInsideSection = idX86; 

    } 
    //else
    //if ( strstr ( Line, FILE_SECTION_ALPHA ) ) {
    //
    //    dwInsideSection = idALPHA; 
    //
    //} 
    else {

        dwInsideSection = FILE_SECTION_NOT_USED;
    }
    
    //Msg ( "dwInsideSection = %x\n", dwInsideSection );
    return(dwInsideSection);

}
char * SuckName ( const char * Line ) {

    static char   szSuckedName[MFL];

    DWORD   dwIndex = 0;

    //  Copy the file name until a space is encountered.
    //
    while ( *Line != ' ' ) {

        szSuckedName[dwIndex] = *Line; 
        szSuckedName[dwIndex+1] = '\0';

        ++Line;
        ++dwIndex;
    }

    //Msg ( "szSuckedName = %s\n", szSuckedName );
    return szSuckedName;
} 



BOOL    GetTheSizes ( void ) {

    CHAR        infFilePath[MFL];
    CHAR        infTmpPath[MFL];
    DWORD       dwErrorLine;
    BOOL        b;
    char        dstDirectory[MFL];
    FILE        * fHandle;
    FILE        * fhTmpLayout;
    char        Line[MFL];
    WIN32_FIND_DATA wfd;



    //  Open the temporary inf file for writing.
    //

    sprintf ( infTmpPath, "%s\\%s", LocalInfPath, "LAYOUT.TMP" );

    Msg ( "infTmpPath = %s\n", infTmpPath );

    fhTmpLayout = fopen ( infTmpPath, "wt" );

    if ( fhTmpLayout == NULL ) {

        Msg ( "FATAL ERROR fopen (%s)\n", infTmpPath );  
        return (FALSE);        
    }


    //  Open the real LAYOUT.INF for reading.
    //

    sprintf ( infFilePath, "%s\\%s", LocalInfPath, "LAYOUT.INF" );

    Msg ( "infFilePath = %s\n", infFilePath );

    fHandle = fopen ( infFilePath, "rt" );

    if ( fHandle ) {

        char    szFile[MFL];
        char    szPath[MFL];
        char    newLine[MFL];

        while ( fgets ( Line, sizeof(Line), fHandle ) ) {

            int     i;
            HANDLE  hFF;

          //Msg ( "Line: %s\n", Line );

            if ( Line[0] == '[' ) {

                //  We may have a new section.
                //
                dwInsideSection = FigureSection ( Line ); 

                fwrite ( Line, 1, strlen(Line), fhTmpLayout ); 
                continue;
            }


            //  Reasons to ignore this line from further processing.
            //
            //

            //  File section not one we process.
            //
            if ( dwInsideSection == FILE_SECTION_NOT_USED ) {

                fwrite ( Line, 1, strlen(Line), fhTmpLayout ); 
                continue;
            }

            //  Line just contains a non-usefull data.
            //
            i = strlen ( Line );
            if ( i < 4 ) {

                fwrite ( Line, 1, strlen(Line), fhTmpLayout ); 
                continue;
            } 

            //  Line contains a comment.
            //
            if ( Line[0] == ';' ) {

                fwrite ( Line, 1, strlen(Line), fhTmpLayout ); 
                continue;
            }
            

            //  At this point, we must be a i386, MIPS, ALPHA, or PPC section AND
            //  the line contains a filename and setup data.
            //

            //Msg ( "file == %s\n", SuckName ( Line ) );

            strcpy ( szFile, SuckName ( Line ) );

            //  Determine where to look for the file size.
            //

            switch ( dwInsideSection ) {

            case idLOCAL   :

                sprintf ( szPath, "%s\\%s", LocalFlatShare, szFile );

                break;

            case idX86   :

                sprintf ( szPath, "%s\\%s", i386FlatShare, szFile );
    
                break;

            //case idALPHA :
            //
            //    sprintf ( szPath, "%s\\%s", "fakealphapath", szFile );
            //
            //    break;

            default :

                Msg ( "FATAL ERROR:  unknown section switch value = %ld\n", dwInsideSection );
                return (FALSE);
                break;

            }

            //  Get the size of the file.
            //
            hFF = FindFirstFile ( szPath, &wfd );

            if ( hFF == INVALID_HANDLE_VALUE ) {


                Msg ( "FATAL ERROR:  FindFirst (%s), gle = %ld\n", szPath, GetLastError() );
                wfd.nFileSizeLow = 0;
            }

            //  Modify the string, inserting the size.
            //
            {

                int i = 0;
                int numCommas = 0;
                char * LinePtr = Line;

                while ( 1 ) {

                    //  If we have seen 2 commas, it is time to put the filesize
                    //  in the line and write-out the remaining part of the string.
                    //

                    if ( numCommas == 2 ) {

                        //  Now, since the build team may have
                        //  run propagation more than once, 
                        //  let's just make sure there is another
                        //  comma write after the 2nd one, because if there isn't 
                        //  we probably have filesize inserted from the last time.
                        //  If that is the case, crawl up to the next comma and put
                        //  the size in and then the rest.
                        //

                        if ( *LinePtr != ',' ) {    // check out the next character

                            //  There is NOT a comma, but rather a file size then a comma.
                            //  Let's crawl up to the next comma.
                            //

                            while ( *LinePtr != ',' ) { // end when we see the next comma.

                                ++LinePtr;
                            } 

                        }

                        sprintf ( &newLine[i], "%d%s", wfd.nFileSizeLow, LinePtr ); 
                        break;

                    }

                    newLine[i] = *LinePtr; 

                    if ( newLine[i] == ',' ) {

                        ++numCommas;
                    } 

                    ++LinePtr;
                    ++i;

                } 

            }
            
            //  Write out the newly modified line !
            //
            //Msg ( "Line    = >>>%s<<<\n", Line );
            //Msg ( "newLine = >>>%s<<<\n", newLine );

            fwrite ( newLine, 1, strlen ( newLine ), fhTmpLayout );

            FindClose ( hFF );
        }
        if ( ferror(fHandle) ) {

            Msg ( "FATAL ERROR fgets reading from file...\n" );
        }

    }
    else {

        Msg ( "FATAL ERROR fopen (%s)\n", infFilePath );
        fclose ( fhTmpLayout ); 
        return (FALSE);
    }

    fclose ( fHandle );
    fclose ( fhTmpLayout );


    //  Copy the temporary inf file to the real one.
    //

    b = CopyFile ( infTmpPath, infFilePath, FALSE );

    if ( b ) {

        Msg ( "Copy:  %s >>> %s  [OK]\n", infTmpPath, infFilePath );
    }
    else {

        Msg ( "FATAL ERROR Copy:  %s >>> %s, gle = %ld\n", 
                            infTmpPath, infFilePath, GetLastError() );
        return ( FALSE );
    }

    return (TRUE);
}

int __cdecl main(argc,argv)
int argc;
char * argv[];
{
    HANDLE h;
    int records, i;
    WIN32_FIND_DATA fd;
    time_t t;

    printf ( "argc = %d\n", argc );

    if ( argc != 5 ) { 
		Usage(); 
		return(1); 
	}

    logFile = fopen ( argv[1], "a" ); 

    if ( logFile == NULL ) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }

    Header(argv,argc);

    strcpy ( LocalInfPath,   argv[2] );
    strcpy ( LocalFlatShare, argv[3] );
    strcpy ( i386FlatShare,  argv[4] );
    //strcpy ( AlphaFlatShare, argv[5] );
    

    //  Get files that product installs.
    //
    GetTheSizes ( );
    
    Msg ( "==============================\n");
    time(&t); 
	Msg ( "Time: %s", ctime(&t) );
    Msg ( "==============================\n\n");

    fclose(logFile);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

SOURCES_USED=..\sources.inc

!IF $(386)
NTTARGETFILE1=$(O)\makeboot.exe
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\br\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Disco de inicializaao da instalaao do Windows XP SP1",
"Disco de instalaao n2 do Windows XP SP1",
"Disco de instalaao n3 do Windows XP SP1",
"Disco de instalaao n4 do Windows XP SP1",

"Nao  possvel encontrar o arquivo %s\n",
"Nao h espao na memria para concluir o pedido\n",
"%s nao  um formato de arquivo executvel\n",
"****************************************************",

"Este programa cria discos de inicializaao da instalaao",
"para Microsoft %s.",
"Para cri-los, voc precisa fornecer 6 discos vazios,",
"formatados, de alta densidade.",

"Insira um desses discos na unidade %c:.  Esse disco",
"ser o disco %s.",

"Insira outro disco na unidade %c:.  Esse disco",
"ser o disco %s.",

"Pressione qualquer tecla quando voc estiver pronto.",

"Os discos de inicializaao da instalaao foram criados com xito.",
"concludo",

"Erro desconhecido ao se tentar executar %s.",
"Especifique a unidade de disquete para onde copiar as imagens: ",
"Letra da unidade invlida\n",
"A unidade %c: nao  uma unidade de disquete\n",

"Deseja tentar criar este disquete novamente?",
"Pressione Enter para tentar novamente ou Esc para sair.",

"Erro: disco protegido contra gravaao\n",
"Erro: unidade de disco desconhecida\n",
"Erro: a unidade nao est pronta\n",
"Erro: comando desconhecido\n",
"Erro: erro de dados (CRC incorreto)\n",
"Erro: comprimento da estrutura do pedido incorreto\n",
"Erro: erro de busca\n",
"Erro: tipo de mdia nao encontrado\n",
"Erro: setor nao encontrado\n",
"Erro: falha na gravaao\n",
"Erro: falha geral\n",
"Erro: pedido invlido ou comando incorreto\n",
"Erro: marca de endereo nao encontrada\n",
"Erro: falha na gravaao do disco\n",
"Erro: perda de acesso direto  memria (DMA)\n",
"Erro: erro na leitura de dados (CRC ou ECC)\n",
"Erro: falha do controlador\n",
"Erro: tempo limite do disco expirado ou falha para responder\n",

" Disco de instalaao n5 do Windows XP SP1",
" Disco de instalaao n6 do Windows XP SP1" 
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\makefile.inc ===
# Use specific 16-bit compiler/linker/masm
PATH=$(PATH_TOOLS16);$(PATH)

!IFNDEF DEBUG
DEBUG=0
!ENDIF

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF $(DEBUG)
C_DBG_FLAGS= -Zi -Od -DDBG=1
LINK_DBG_FLAGS= /codeview
!ELSE
C_DBG_FLAGS=-DDBG=0
LINK_DBG_FLAGS=
!ENDIF

CC= cl16
CFCOMMON= -W3 -Zel -G2 -AC $(C_DBG_FLAGS)
CINC=-X -I.. -I..\..\..\..\textmode\winnt\c6\inc -I$(O) -I..\..\..\..\inc
CFLAGS= $(CFCOMMON) $(CFOPT)

{..}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<


LIBS = ..\..\..\..\textmode\winnt\c6\lib\clibce
OBJS = $(O)\makeboot.obj $(O)\strings.obj

$(O)\makeboot.exe: $(OBJS) makefile.inc $(PATH_TOOLS16)\$(CC).exe
    link @<<
$(OBJS) /NOI /STACK:0xE000 $(LINK_DBG_FLAGS)
$(O)\makeboot.exe
nul
$(LIBS)

<<
    -binplace -O $(ALT_PROJECT_TARGET) $@

$(O)\makeboot.obj: ..\makeboot.c       ..\makeboot.h
$(O)\strings.obj:  strings.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\makeboot.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makeboot.h
//
// Description:
//      Local include file for DOS based MAKEBOOT program.
//
//      Contains all of the indexes into the string table array.
//
//----------------------------------------------------------------------------

#define NT_VERSION_NAME                 0
#define DISK_LABEL_1                    1
#define DISK_LABEL_2                    2
#define DISK_LABEL_3                    3
#define DISK_LABEL_4                    4

#define CANNOT_FIND_FILE                5
#define NOT_ENOUGH_MEMORY               6
#define NOT_EXEC_FORMAT                 7
#define STARS                           8

#define EXPLANATION_LINE_1              9
#define EXPLANATION_LINE_2              10
#define EXPLANATION_LINE_3              11
#define EXPLANATION_LINE_4              12

#define INSERT_FIRST_DISK_LINE_1        13
#define INSERT_FIRST_DISK_LINE_2        14

#define INSERT_ANOTHER_DISK_LINE_1      15
#define INSERT_ANOTHER_DISK_LINE_2      16

#define PRESS_ANY_KEY_TO_CONTINUE       17

#define COMPLETED_SUCCESSFULLY          18
#define COMPLETE                        19

#define UNKNOWN_SPAWN_ERROR             20
#define SPECIFY_DRIVE                   21
#define INVALID_DRIVE_LETTER            22
#define NOT_A_FLOPPY                    23

#define ATTEMPT_TO_CREATE_FLOPPY_AGAIN  24
#define PRESS_ENTER_OR_ESC              25

#define ERROR_DISK_WRITE_PROTECTED      26
#define ERROR_UNKNOWN_DISK_UNIT         27
#define ERROR_DRIVE_NOT_READY           28
#define ERROR_UNKNOWN_COMMAND           29
#define ERROR_DATA_ERROR                30
#define ERROR_BAD_REQUEST               31
#define ERROR_SEEK_ERROR                32
#define ERROR_MEDIA_TYPE_NOT_FOUND      33
#define ERROR_SECTOR_NOT_FOUND          34
#define ERROR_WRITE_FAULT               35
#define ERROR_GENERAL_FAILURE           36
#define ERROR_INVALID_REQUEST           37
#define ERROR_ADDRESS_MARK_NOT_FOUND    38
#define ERROR_DISK_WRITE_FAULT          39
#define ERROR_DMA_OVERRUN               40
#define ERROR_CRC_ERROR                 41
#define ERROR_CONTROLLER_FAILURE        42
#define ERROR_DISK_TIMED_OUT            43

#define DISK_LABEL_5                    44
#define DISK_LABEL_6                    45
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\makeboot.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makeboot.c
//
// Description:
//      This program copies the images of the 4 Windows NT setup disks to
//      floppy disk so the user can boot their system with them.
//
//  Assumptions:
//      The sector size is 512 and the sectors per track is 18
//
//      The floppy disk images are in the current dir and named CDBOOT1.IMG,
//      CDBOOT2.IMG, CDBOOT3.IMG and CDBOOT4.IMG.
//
//      The txtsetup.sif resides in ..\i386 or ..\alpha from where the
//      program is being run.
//     
//----------------------------------------------------------------------------

#include <bios.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <process.h>
#include <errno.h>
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "makeboot.h"

//
//  Constants
//

//
//  To support disks other than 1.44 MB High-Density floppies, then these
//  numbers will have to be changed or determined at run-time.
//
#define SECTORS_PER_TRACK          18
#define SECTOR_SIZE                512
#define TRACK_SIZE                 SECTORS_PER_TRACK * SECTOR_SIZE
#define NUMBER_OF_TRACKS           80
#define SECTORS_TO_COPY_AT_A_TIME  18

//  we multiply by 2 because the disk is double-sided
#define NUMBER_OF_SECTORS_ON_DISK   NUMBER_OF_TRACKS * SECTORS_PER_TRACK * 2

#define NT_NAME_OF_MAKEBOOT  "makebt32.exe"

#define NT_IMAGE_1_NAME      "CDBOOT1.IMG"
#define NT_IMAGE_2_NAME      "CDBOOT2.IMG"
#define NT_IMAGE_3_NAME      "CDBOOT3.IMG"
#define NT_IMAGE_4_NAME      "CDBOOT4.IMG"
#define NT_IMAGE_5_NAME      "CDBOOT5.IMG"
#define NT_IMAGE_6_NAME      "CDBOOT6.IMG"

#define MAX_INILINE_LENGTH    1023

#define ENTER_KEY             13
#define ESC_KEY               27

#define NUMBER_OF_ASCII_WHEEL_SYMBOLS  4

const char rgAsciiWheel[NUMBER_OF_ASCII_WHEEL_SYMBOLS] = { '|', '/', '-', '\\' };

//
//  Function prototypes
//
int WriteImageToFloppy( char *szFileName, int drive );
int DoesUserWantToTryCopyAgain( void );
void ReportBiosError( unsigned int iBiosErrorCode );
int  DoImageFilesExist( void );
unsigned int IsFloppyDrive( int DriveLetter );
void PressAnyKeyToContinue( void );
unsigned int AbsoluteDiskWrite( unsigned int *iErrorCode,
                                unsigned int iDrive, 
                                unsigned int iStartingSector,
                                unsigned int iNumberOfSectorsToWrite,
                                void far *Buffer_to_be_written );

unsigned DnGetCodepage(void);

//
//  Variables that are allocated in strings.c that are used to determine what
//  string table to use.
//

extern unsigned int CODEPAGE;

extern const char *EngStrings[];

extern const char *LocStrings[];

//
//  This var holds a pointer to the array of strings to be used
//
const char **StringTable;

//----------------------------------------------------------------------------
//
// Function: main
//
// Purpose: Instructs user to insert floppy disks to be copied and performs
//          the copy.
//
// Arguments: int argc - standard program argument, count of the command line args
//            char *argv[] - standard program argument, the 2nd argument is the
//                           floppy drive to copy the images to.
// Returns: int - zero on success, non-zero on error
//
//----------------------------------------------------------------------------
int 
main( int argc, char *argv[] )
{     

    char *szOsName;
    char Drive;
    char DriveLetter;
    int  bTryAgain;

    //
    //  Set the string table to the appropriate language depending on
    //  the code page.
    //
    if( *LocStrings[0] == '\0' )
    {
        StringTable = EngStrings;
    } 
    else {

        if( DnGetCodepage() != CODEPAGE )
        {
            StringTable = EngStrings;
        }
        else
        {
            StringTable = LocStrings;
        }

    }

    szOsName = getenv( "OS" );

    //
    //  See if we are on NT.  If we are, call the NT version and exit.
    //  If we aren't then just continue executing this program.
    //
    if( szOsName && ( stricmp( szOsName, "Windows_NT" ) == 0 ) )
    {

        int iRetVal;

        iRetVal = spawnl( P_WAIT, NT_NAME_OF_MAKEBOOT, NT_NAME_OF_MAKEBOOT, argv[1], NULL );

        if( iRetVal == -1 )
        {
            if( errno == ENOENT )
            {
                printf( StringTable[ CANNOT_FIND_FILE ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
            else if( errno == ENOMEM )
            {
                printf( StringTable[ NOT_ENOUGH_MEMORY ] );

                exit( 1 );
            }
            else if( errno == ENOEXEC )
            {
                printf( StringTable[ NOT_EXEC_FORMAT ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
            else
            {
                printf( StringTable[ UNKNOWN_SPAWN_ERROR ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
        }

        // successful completion
        exit( 0 );

    }

    printf( "\n%s\n", StringTable[ STARS ]   );
    printf( "%s\n", StringTable[ EXPLANATION_LINE_1 ] );
    printf( StringTable[ EXPLANATION_LINE_2 ], StringTable[ NT_VERSION_NAME ] );
    printf( "\n\n" );

    printf( "%s\n", StringTable[ EXPLANATION_LINE_3 ] );
    printf( "%s\n\n", StringTable[ EXPLANATION_LINE_4 ] );

    //
    //  If they didn't specified the floppy drive on the command line then
    //  prompt them for it.
    //
    if( argc == 1 )
    {

        printf( StringTable[ SPECIFY_DRIVE ] );

        DriveLetter = (char) getche();

        printf( "\n\n" );

    }
    else
    {

        DriveLetter = argv[1][0];

    }

    //
    //  Make sure the character they entered is a possible drive letter
    //
    if( ! isalpha( DriveLetter ) )
    {

        printf( StringTable[ INVALID_DRIVE_LETTER ] );

        exit( 1 );

    }

    //
    //  Make sure the drive specified is actually a floppy drive
    //

    if( ! IsFloppyDrive( DriveLetter ) )
    {

        printf( StringTable[ NOT_A_FLOPPY ], DriveLetter );

        exit( 1 );

    }

    //
    //  map the drive letter a or A to 0, b or B to 1, etc.
    //
    Drive = (char) ( toupper( DriveLetter ) - (int)'A' );

    //
    //  Make sure all the images files exist in the current directory
    //
    if( ! DoImageFilesExist() ) 
    {
        exit( 1 );
    }

    printf( StringTable[ INSERT_FIRST_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );

    printf( StringTable[ INSERT_FIRST_DISK_LINE_2 ], StringTable[ DISK_LABEL_1 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_1_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_2 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_2_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_3 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_3_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_4 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_4_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_5 ] );
    printf( "\n\n" );
    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_5_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_6 ] );
    printf( "\n\n" );
    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_6_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n\n%s\n\n", StringTable[ COMPLETED_SUCCESSFULLY ] );

    printf( "%s\n", StringTable[ STARS ] );

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: WriteImageToFloppy
//
// Purpose:  Writes an image file to a floppy disk.  Handles all error
//           reporting to the user.
//
// Arguments: char *szFileName - filename to write to the floppy
//            int   drive - drive letter of the floppy to write to
//
// Returns: int - non-zero on success
//              - zero on error
//
//----------------------------------------------------------------------------
int
WriteImageToFloppy( char *szFileName, int drive )
{

    char         *pTrack;
    int          hImageFile;
    unsigned int iSuccess;
    unsigned int iErrorCode;
    unsigned int iBytesRead;
    unsigned int iTotalSectorsWritten;
    unsigned int iPercentComplete;
    unsigned int iWheelPosition;
    char         TrackBuffer[ TRACK_SIZE ];
    
    _fmode = O_BINARY; 

    //
    //  Open the image file
    //
    hImageFile = open( szFileName, O_RDONLY );

    if( hImageFile == -1 )
    {
        perror( szFileName );

        return( 0 );
    }

    iWheelPosition        = 0;
    iTotalSectorsWritten  = 0;

    //
    //  Loop reading a track and then writing SECTORS_TO_COPY_AT_A_TIME sectors
    //  out at a time until we reach the end of the file
    //
    while( ( iBytesRead = read( hImageFile, TrackBuffer, TRACK_SIZE ) ) > 0 )
    {

        pTrack = TrackBuffer;

        for( ;
             iBytesRead > 0;
             iTotalSectorsWritten += SECTORS_TO_COPY_AT_A_TIME )
        {

            iSuccess = AbsoluteDiskWrite( &iErrorCode,
                                          drive,
                                          iTotalSectorsWritten,
                                          SECTORS_TO_COPY_AT_A_TIME,
                                          (void far *) pTrack );

            if( ! iSuccess )
            {
                ReportBiosError( iErrorCode );

                close( hImageFile );

                return( 0 );
            }

            iBytesRead = iBytesRead - ( SECTOR_SIZE * SECTORS_TO_COPY_AT_A_TIME );

            pTrack = pTrack + ( SECTOR_SIZE * SECTORS_TO_COPY_AT_A_TIME );

        }

        iPercentComplete = (int) ( ( (double) (iTotalSectorsWritten) / (double) (NUMBER_OF_SECTORS_ON_DISK) ) * 100.0 );

        printf( "%c %3d%% %s\r",
                rgAsciiWheel[iWheelPosition], 
                iPercentComplete,
                StringTable[ COMPLETE ] );
                
        //
        //  Advance the ASCII wheel
        //

        iWheelPosition++;

        if( iWheelPosition >= NUMBER_OF_ASCII_WHEEL_SYMBOLS )
        {
            iWheelPosition = 0;                
        }

    }

    //
    //  We are done copying the disk so force it to read 100% and get rid of
    //  the ascii wheel symbol.
    //
    printf( " 100%% %s          \n", StringTable[ COMPLETE ] );

    close( hImageFile );

    return( 1 );

}

//----------------------------------------------------------------------------
//
//  Function: DoesUserWantToTryCopyAgain
//
//  Purpose:  Ask the user if they want to retry to copy the image to floppy.
//            Get the user input and return whether to copy again or not.
//
//  Arguments: void
//
//  Returns:  int - non-zero  if user wants to attempt to copy again
//                - zero if user does not want to attempt to copy again
//
//----------------------------------------------------------------------------
int
DoesUserWantToTryCopyAgain( void )
{

    int ch;

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( kbhit() )
    {
        getch();
    }
    
    do
    {
        printf( "%s\n", StringTable[ ATTEMPT_TO_CREATE_FLOPPY_AGAIN ] );
        printf( "%s\n", StringTable[ PRESS_ENTER_OR_ESC ] );

        ch = getch();

    } while( ch != ENTER_KEY && ch != ESC_KEY  );

    if( ch == ENTER_KEY )
    {
        return( 1 );
    }
    else
    {
        return( 0 );
    }

}

//----------------------------------------------------------------------------
//
//  Function: PressAnyKeyToContinue
//
//  Purpose:  Print the "Press any key when ready" message and wait until the
//  user presses a key.
//
//  Arguments: void
//
//  Returns:  void
//
//----------------------------------------------------------------------------
void
PressAnyKeyToContinue( void )
{

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( kbhit() )
    {
        getch();
    }

    printf( "%s\n", StringTable[ PRESS_ANY_KEY_TO_CONTINUE ] );

    //
    //  Spin until the keyboard is pressed
    //
    while( ! kbhit() )
    {
        ;
    }

}

//----------------------------------------------------------------------------
//
// Function: DoImageFilesExist
//
// Purpose:  Determines if all the image files are in the current directory or
//           not.  If an image file is missing, an error message is printed
//           to the user.
//
//           Note: it detemines if a file exists by seeing if it can open it
//           for reading.
//
// Arguments: void
//
// Returns: int -- non-zero on success, all images files exist in current dir
//                 zero on failure, 1 or more image files do not exist
//
//----------------------------------------------------------------------------
int
DoImageFilesExist( void ) 
{

    FILE *FileStream;
    int  iSuccess = 1;  // assume success
    
    if( ( FileStream = fopen( NT_IMAGE_1_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_1_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_2_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_2_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_3_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_3_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_4_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_4_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_5_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_5_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_6_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_6_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    return( iSuccess );

}

//----------------------------------------------------------------------------
//
// Function: IsFloppyDrive
//
// Purpose:  To determine if a particular drive is a floppy drive.
//
// Arguments:  int DriveLetter - the drive letter to test whether it is a
//                               floppy or not
//
// Returns: unsigned int -- non-zero if the specified drive is a floppy drive
//                          zero if the specified drive is not a floppy drive
//
//----------------------------------------------------------------------------
unsigned int
IsFloppyDrive( int DriveLetter )
{

    unsigned int drive;
    unsigned int iIsFloppy;
    
    //
    //  Convert the drive letter to a number.  1 = A, 2 = B, 3 = C, ...
    //
    drive = ( toupper( DriveLetter ) - (int)'A' ) + 1;

    //
    //  Assume it is not a floppy
    //
    iIsFloppy = 0;

    _asm {
        push    ds
        push    es
        push    bp

        mov     ah, 1Ch                 // going to call function 1Ch
        mov     dl, BYTE PTR [drive]

        int     21h                     // call Int 21h function 1Ch

        cmp     BYTE PTR ds:[bx], 0F8h  // test for fixed drive

        je      done

        mov     iIsFloppy, 1            // it is a floppy

done:

        pop     bp
        pop     es
        pop     ds
    }

    return( iIsFloppy );

}

//----------------------------------------------------------------------------
//
// Function: ReportBiosError
//
// Purpose:  To convert a BIOS error code to a error message and print it out
//           for the user to see.
//
// Arguments: unsigned int iBiosErrorCode - the BIOS error code to be looked up
//
// Returns: void
//
//----------------------------------------------------------------------------
void
ReportBiosError( unsigned int iBiosErrorCode )
{
    // 
    //  Print out the error code for the lower byte
    //
    switch( iBiosErrorCode & 0x00FF )
    {

        case 0x0000:    printf( StringTable[ ERROR_DISK_WRITE_PROTECTED ] );  break;
        case 0x0001:    printf( StringTable[ ERROR_UNKNOWN_DISK_UNIT    ] );  break;
        case 0x0002:    printf( StringTable[ ERROR_DRIVE_NOT_READY      ] );  break;
        case 0x0003:    printf( StringTable[ ERROR_UNKNOWN_COMMAND      ] );  break;
        case 0x0004:    printf( StringTable[ ERROR_DATA_ERROR           ] );  break;
        case 0x0005:    printf( StringTable[ ERROR_BAD_REQUEST          ] );  break;
        case 0x0006:    printf( StringTable[ ERROR_SEEK_ERROR           ] );  break;
        case 0x0007:    printf( StringTable[ ERROR_MEDIA_TYPE_NOT_FOUND ] );  break;
        case 0x0008:    printf( StringTable[ ERROR_SECTOR_NOT_FOUND     ] );  break;
        case 0x000A:    printf( StringTable[ ERROR_WRITE_FAULT          ] );  break;
        case 0x000C:    printf( StringTable[ ERROR_GENERAL_FAILURE      ] );  break;
    }

    // 
    //  Print out the error code for the upper byte
    //
    switch( iBiosErrorCode & 0xFF00 )
    {
        case 0x0100:    printf( StringTable[ ERROR_INVALID_REQUEST        ] );  break;
        case 0x0200:    printf( StringTable[ ERROR_ADDRESS_MARK_NOT_FOUND ] );  break;
        case 0x0300:    printf( StringTable[ ERROR_DISK_WRITE_FAULT       ] );  break;
        case 0x0400:    printf( StringTable[ ERROR_SECTOR_NOT_FOUND       ] );  break;
        case 0x0800:    printf( StringTable[ ERROR_DMA_OVERRUN            ] );  break;
        case 0x1000:    printf( StringTable[ ERROR_CRC_ERROR              ] );  break;
        case 0x2000:    printf( StringTable[ ERROR_CONTROLLER_FAILURE     ] );  break;
        case 0x4000:    printf( StringTable[ ERROR_SEEK_ERROR             ] );  break;
        case 0x8000:    printf( StringTable[ ERROR_DISK_TIMED_OUT         ] );  break;
    }

}

//----------------------------------------------------------------------------
//
// Function: AbsoluteDiskWrite
//
// Purpose:  To write a buffer in memory to a specific portion of a disk.
//
// Arguments:  unsigned int *iErrorCode - if an error occurs, the error code
//                   is returned in this OUT variable
//             unsigned int iDrive - drive to write the buffer to
//             unsigned int iStartingSector - sector where the write is to begin
//             unsigned int iNumberOfSectorsToWrite - the number of sectors
//                   to write
//
// Returns:  returns 1 on success, 0 on failure
//           If it fails, then the error code is returned in the argument
//           iErrorCode.
//           If it succeeds, iErrorCode is undefined.
//
//----------------------------------------------------------------------------
unsigned int
AbsoluteDiskWrite( unsigned int *iErrorCode,
                   unsigned int iDrive, 
                   unsigned int iStartingSector,
                   unsigned int iNumberOfSectorsToWrite,
                   void far *Buffer_to_be_written )
{
    //
    //  used to temporarily store the error code
    //
    unsigned int iTempErrorCode;

    unsigned int iRetVal;

    _asm
    {
        push    ds
        push    es
        push    bp

        mov     ax, WORD PTR [Buffer_to_be_written + 2]
        mov     ds, ax
        mov     bx, WORD PTR [Buffer_to_be_written]
        mov     dx, iStartingSector
        mov     cx, iNumberOfSectorsToWrite
        mov     al, BYTE PTR [iDrive]

        int     26h   // do the absolute disk write

        lahf
        popf
        sahf

        pop     bp
        pop     es
        pop     ds

        mov     iRetVal, 1   // assume success
        jnc     done         // see if an error occured
        mov     iRetVal, 0
        mov     iTempErrorCode, ax
done:
    }

    *iErrorCode = iTempErrorCode;

    return( iRetVal );

}

unsigned
DnGetCodepage(void)

/*++

Routine Description:

    Determine the currently active codepage.

Arguments:

    None.

Return Value:

    Currently active codepage. 0 if we can't determine it.

--*/

{

    unsigned int iRetVal;

    _asm {
        mov ax,06601h
        int 21h
        jnc ok
        xor bx,bx
    ok: mov iRetVal,bx
    }

    return( iRetVal );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\gb\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\el\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 737;

const char *EngStrings[] = {

"Windows XP SP1",
"    Windows XP SP1",
"  #2  Windows XP SP1",
"  #3  Windows XP SP1",
"  #4  Windows XP SP1",

"       %s\n",
"         \n",
" %s      \n",
"****************************************************",

"        ",
"  Microsoft %s.",
"     ,    6 ,",
",   .",

"        %c:.    ",
"   %s.",

"      %c:.    ",
"   %s.",

"    .",

"      .",
"",

"        %s.",
"        : ",
"   \n",
"  %c:    \n",

"        ;",
" Enter      Esc  .",

":     \n",
":   \n",
":     \n",
":  \n",
":   ( CRC)\n",
": Bad request structure length\n",
":  \n",
":      \n",
":   \n",
":  \n",
":  \n",
":      \n",
":    \n",
":   \n",
":    (DMA)\n",
":   (CRC  ECC)\n",
":  \n",
":          \n",

"  #5  Windows XP SP1",
"  #6  Windows XP SP1"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\da\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Startdiskette",
"Windows XP SP1 Installationsdiskette nr. 2",
"Windows XP SP1 Installationsdiskette nr. 3",
"Windows XP SP1 Installationsdiskette nr. 4",

"Filen %s blev ikke fundet\n",
"Der er ikke nok hukommelse til at fuldfre anmodningen\n",
"%s er ikke en eksekverbar fil\n",
"****************************************************",

"Dette program opretter installationsdisketterne",
"til Microsoft %s.",
"For at oprette disse, skal du bruge 6 tomme,",
"formaterede, high-density disketter.",

"Indst en af de tomme disketter i drev %c:.  Denne diskette",
"bliver %s.",

"Indst en anden diskette i drev %c:.  Denne diskette bliver",
"%s.",

"Tryk p en vilkrlig tast, nr du er klar.",

"Installationsdisketterne er nu blevet oprettet.",
"Fuldfrt",

"Der opstod en ukendt fejl under forsget p at kre %s.",
"Angiv diskettedrevet, som afbildningerne skal kopieres til: ",
"Ugyldigt drevbogstav\n",
"Drev %c: er ikke et diskettedrev\n",

"Vil du forsge at oprette denne diskette igen?",
"Tryk p Enter for at forsge igen, eller p Esc for at afslutte.",

"Fejl: Disketten er skrivebeskyttet\n",
"Fejl: Ukendt diskenhed\n",
"Fejl: Drevet er ikke klar\n",
"Fejl: Ukendt kommando\n",
"Fejl: Datafejl (fejl i CRC)\n",
"Fejl: Ugyldig lngde p anmodningsstruktur\n",
"Fejl: Sgefejl\n",
"Fejl: Medietypen blev ikke fundet\n",
"Fejl: Sektoren blev ikke fundet\n",
"Fejl: Skrivefejl\n",
"Fejl: Generel fejl\n",
"Fejl: Ugyldig anmodning eller kommando\n",
"Fejl: Adressemrke blev ikke fundet\n",
"Fejl: Diskskrivningsfejl\n",
"Fejl: DAM-overlb (Direct Memory Access)\n",
"Fejl: Datalsningsfejl (CRC eller ECC)\n",
"Fejl: Controllerfejl\n",
"Fejl: Disken svarede ikke, eller timeout opstod\n",

"Windows XP SP1 Installationsdiskette nr. 5",
"Windows XP SP1 Installationsdiskette nr. 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\fi\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 -asennuksen kynnistyslevyke",
"Windows XP SP1 -asennuslevyke 2",
"Windows XP SP1 -asennuslevyke 3",
"Windows XP SP1 -asennuslevyke 4",

"Tiedostoa %s ei lydy\n",
"Muisti ei riit tehtvn suorittamiseen\n",
"%s ei ole ohjelmatiedosto\n",
"****************************************************",

"Tm ohjelma luo asennuksen kynnistyslevykkeet",
"sovellukselle Microsoft %s.",
"Tarvitaan 6 tyhj, alustettua",
"1,44 megatavun levykett.",

"Aseta ensimminen levyke asemaan %c:.  Tst levyst",
"tehdn %s.",

"Aseta seuraava levyke asemaan %c:.  Tst levyst",
"tehdn %s.",

"Kun olet valmis, paina vlilynti.",

"Asennuksen kynnistyslevykkeet on luotu.",
"valmis",

"Tuntematon virhe suoritettaessa komentoa %s.",
"Mrit levykeasema, johon tallennetaan: ",
"Asematunnus ei kelpaa\n",
"Asema %c: ei ole levykeasema\n",

"Yritetnk levykkeen luomista uudelleen",
"Yrit uudelleen painamalla ENTER tai lopeta painamalla ESC",

"Virhe: Levy on kirjoitussuojattu\n",
"Virhe: Tuntematon levy-yksikk\n",
"Virhe: Asema ei ole valmiina\n",
"Virhe: Tuntematon komento\n",
"Virhe: Virheellinen CRC-data\n",
"Virhe: Virheellinen pyynnn rakenteen pituus\n",
"Virhe: Hakuvirhe\n",
"Virhe: Tietovlineen tyyppi ei lydy\n",
"Virhe: Sektoria ei lydy\n",
"Virhe: Kirjoitusvirhe\n",
"Virhe: Yleinen virhe\n",
"Virhe: Virheellinen komento tai pyynt\n",
"Virhe: Osoitekohtaa ei lydy\n",
"Virhe: Virhe kirjoitettaessa levylle\n",
"Virhe: DMA-ylivuoto\n",
"Virhe: CRC- tai ECC-lukuvirhe\n",
"Virhe: Sovitinvirhe\n",
"Virhe: Levykkeen aikakatkaisu tai ei vastausta\n",

"Windows XP SP1 -asennuslevyke 5",
"Windows XP SP1 -asennuslevyke 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\cs\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP SP1",
"Spoutc instalan disketa systmu Windows XP SP1",
"Instalan disketa . 2 systmu Windows XP SP1",
"Instalan disketa . 3 systmu Windows XP SP1",
"Instalan disketa . 4 systmu Windows XP SP1",

"Nepodailo se nalzt soubor %s.\n",
"Pro dokonen poadavku nen dostatek pamti.\n",
"%s nen spustiteln soubor.\n",
"****************************************************",

"Tento program vytvo spoutc instalan diskety",
"pro systm Microsoft %s.",
"K vytvoen tchto disket budete potebovat est przdnch,",
"naformtovanch disket s vysokou hustotou zznamu.",

"Vlote jednu z disket do jednotky %c:. Pojmenujte disketu",
"%s.",

"Vlote dal disketu do jednotky %c:. Pojmenujte disketu",
"%s.",

"Pot stisknte libovolnou klvesu.",

"Spoutc instalan diskety byly spn vytvoeny.",
"Dokoneno",

"Pi pokusu spustit %s dolo k neznm chyb.",
"Zadejte clovou disketovou jednotku pro zkoprovn bitovch kopi: ",
"Psmeno jednotky je neplatn.\n",
"Jednotka %c: nen disketov jednotka.\n",

"Chcete se pokusit vytvoit disketu znovu?",
"Pokraujte stisknutm klvesy Enter, nebo klvesou Esc program ukonete.",

"Chyba: Disk je chrnn proti zpisu.\n",
"Chyba: Neznm diskov jednotka.\n",
"Chyba: Jednotka nen pipravena.\n",
"Chyba: Neznm pkaz.\n",
"Chyba: Chyba dat (chybn kontroln souet CRC).\n",
"Chyba: Chybn dlka dosti.\n",
"Chyba: Chyba vystaven.\n",
"Chyba: Typ mdia nebyl nalezen.\n",
"Chyba: Sektor nebyl nalezen.\n",
"Chyba: Chyba zpisu.\n",
"Chyba: Obecn chyba.\n",
"Chyba: Neplatn dost nebo chybn pkaz.\n",
"Chyba: Adresn znaka nebyla nalezena.\n",
"Chyba: Chyba zpisu na disk.\n",
"Chyba: Dolo k pebhu DMA (Direct Memory Access).\n",
"Chyba: Chyba ten dat (chybn CRC nebo ECC).\n",
"Chyba: Chyba adie.\n",
"Chyba: asov limit diskov operace vyprel nebo disk neodpovdl.\n",
"Instalan disketa . 5 systmu Windows XP SP1",
"Instalan disketa . 6 systmu Windows XP SP1"

};
const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\fr\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Disquette de dmarrage de l'installation de Windows XP SP1",
"Disquette d'installation de Windows XP SP1 n2",
"Disquette d'installation de Windows XP SP1 n3",
"Disquette d'installation de Windows XP SP1 n4",

"Impossible de trouver le fichier %s\n",
"Mmoire libre insuffisante pour effectuer la requte\n",
"%s n'a pas un format de fichier excutable\n",
"****************************************************",

"Ce programme cre les disquettes de dmarrage d'installation",
"pour Microsoft %s.",
"Pour crer ces disquettes, vous devez fournir 6 disquettes",
"haute densit, vierges, formates.",

"Insrez l'une de ces disquettes dans le lecteur %c:. Cette disquette",
"deviendra la %s.",

"Insrez une autre disquette dans le lecteur %c:. Cette disquette",
"deviendra la %s.",

"Pressez une touche ds que vous tes prt.",

"Les disquettes de dmarrage d'installation ont t cres.",
"termin",

"Une erreur inconnue s'est produite lors de la tentative d'excuter %s.",
"Spcifiez le lecteur de disquettes vers lequel copier les images : ",
"Lettre de lecteur non valide\n",
"Le lecteur %c: n'est pas un lecteur de disquettes\n",

"Voulez-vous ressayer de crer cette disquette ?",
"Appuyez sur Entre pour ressayer ou sur Annuler pour quitter.",

"Erreur : disquette protge en criture\n",
"Erreur : unit de disquettes inconnue\n",
"Erreur : lecteur non prt\n",
"Erreur : commande inconnue\n",
"Erreur : erreur de donnes (CRC erron)\n",
"Erreur : longueur de structure de requte errone\n",
"Erreur : erreur de recherche\n",
"Erreur : type de mdia introuvable\n",
"Erreur : secteur introuvable\n",
"Erreur : erreur en criture\n",
"Erreur : dfaillance gnrale\n",
"Erreur : requte non valide ou commande errone\n",
"Erreur : marque d'adresse introuvable\n",
"Erreur : erreur en criture sur la disquette\n",
"Erreur : saturation DMA (Direct Memory Access)\n",
"Erreur : erreur de lecture de donnes (CRC ou ECC)\n",
"Erreur : dfaillance du contrleur\n",
"Erreur : le disque met trop de temps  rpondre ou ne rpond pas\n",

"Disquette d'installation de Windows XP SP1 n5",
"Disquette d'installation de Windows XP SP1 n6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\es\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Disco de inicio de instalacin de Windows XP SP1",
"Disco de instalacin #2 de Windows XP SP1",
"Disco de instalacin #3 de Windows XP SP1",
"Disco de instalacin #4 de Windows XP SP1",

"No se encuentra el archivo %s\n",
"Memoria insuficiente para satisfacer la solicitud\n",
"%s no est en un formato de archivo ejecutable\n",
"****************************************************",

"Este programa crea los discos de inicio de la instalacin",
"para Microsoft %s.",
"Para crearlos, necesita tener 6 discos",
"de alta densidad formateados.",

"Inserte uno de los discos en la unidad %c:.  Este disco",
"se convertir en el %s.",

"Inserte otro disco en la unidad %c:.  Este disco se",
"convertir en el %s.",

"Presione cualquier tecla cuando est listo.",

"Los discos de inicio de la instalacin se han creado correctamente.",
"completo",

"Error al intentar ejecutar %s.",
"Especifique la unidad de disquete donde copiar las imgenes: ",
"Letra de unidad no vlida\n",
"La unidad %c: no es una unidad de disquete\n",

"Desea volver a intentar crear este disco?",
"Presione Entrar para volver a intentarlo o Esc para salir.",

"Error: Disco protegido contra escritura\n",
"Error: Unidad de disco desconocida\n",
"Error: Unidad no preparada\n",
"Error: Comando desconocido\n",
"Error: Error de datos (CRC errneo)\n",
"Error: Longitud de estructura de solicitud errnea\n",
"Error: Error de bsqueda\n",
"Error: No se encuentra el tipo de medio\n",
"Error: No se encuentra el sector\n",
"Error: Error de escritura\n",
"Error: Error general\n",
"Error: Solicitud no vlida o comando errneo\n",
"Error: No se encuentra la marca de direccin\n",
"Error: Error de escritura en el disco\n",
"Error: Desbordamiento de Direct Memory Access (DMA)\n",
"Error: Error de lectura de datos (CRC o ECC)\n",
"Error: Error de la controladora\n",
"Error: Tiempo de espera de disco agotado o no hay respuesta\n",

"Disco 5 de instalacin de Windows XP SP1",
"Disco 6 de isntalacin de Windows XP SP1"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\ger\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Setup-Startdiskette",
"Windows XP SP1 Setup-Diskette 2",
"Windows XP SP1 Setup-Diskette 3",
"Windows XP SP1 Setup-Diskette 4",

"Datei wurde nicht gefunden: %s\n",
"Nicht gengend Arbeitsspeicher\n",
"%s ist keine ausfhrbare Datei.\n",
"****************************************************",

"Mit diesem Programm werden Setup-Startdisketten",
"fr Microsoft %s erstellt.",
"Sie bentigen 6 leere, formatierte HD-Disketten,",
"um die Disketten zu erstellen.",

"Legen Sie eine Diskette in das Laufwerk %c: ein.",
"Diese Diskette wird die %s.",

"Legen Sie eine andere Diskette in das Laufwerk %c: ein.",
"Diese Diskette wird die %s.",

"Drcken Sie eine beliebige Taste, um den Vorgang fortzusetzen.",

"Die Setup-Startdisketten wurden ordnungsgem erstellt.",
"abgeschlossen",

"Bei dem Versuch, %s auszufhren, ist ein unbekannter Fehler aufgetreten.",
"Geben Sie das Diskettenlaufwerk an, auf dem\ndie Startdisketten erstellt werden sollen: ",
"Ungltiger Laufwerkbuchstabe\n",
"Das angegebene Laufwerk %c ist kein Diskettenlaufwerk.\n",

"Mchten Sie nochmals versuchen, diese Diskette zu erstellen?",
"Drcken Sie die Eingabetaste, um den Vorgang zu wiederholen,\noder die ESC-Taste, um den Vorgang abzubrechen.",

"Fehler: Schreibgeschtzte Diskette\n",
"Fehler: Unbekanntes Laufwerk\n",
"Fehler: Laufwerk nicht bereit\n",
"Fehler: Unbekannter Befehl\n",
"Fehler: Datenfehler (Ungltiger CRC-Wert)\n",
"Fehler: Ungltige Lnge der Anfragestruktur\n",
"Fehler: Suchfehler\n",
"Fehler: Medientyp nicht gefunden\n",
"Fehler: Sektor nicht gefunden\n",
"Fehler: Schreibfehler\n",
"Fehler: Allgemeiner Fehler\n",
"Fehler: Ungltige Anforderung oder ungltiger Befehl\n",
"Fehler: Adressmarke nicht gefunden\n",
"Fehler: Diskettenschreibfehler\n",
"Fehler: DMA-berlauf\n",
"Fehler: Datenlesefehler (CRC- oder ECC-Wert)\n",
"Fehler: Controllerfehler\n",
"Fehler: Laufwerk nicht bereit, oder keine Antwort von Laufwerk\n",

"Windows XP SP1 Setup-Diskette 5",
"Windows XP SP1 Setup-Diskette 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\hu\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 teleptsi indtlemez",
"Windows XP SP1 2. sz. teleptsi lemez",
"Windows XP SP1 3. sz. teleptsi lemez",
"Windows XP SP1 4. sz. teleptsi lemez",

"Nem tallhat a kvetkez fjl: %s\n",
"Nincs elg memria a krelem befejezshez\n",
"%s nem vgrehajthat formtum\n",
"****************************************************",

"Ez a program hozza ltre a teleptsi indtlemezeket a",
"kvetkezhz: Microsoft %s.",
"A lemezek ltrehozshoz hat res, formzott, nagykapacits",
"lemezre lesz szksg.",

"Helyezze be a lemezek egyikt a kvetkez meghajtba: %c:. Ez a",
"lemez lesz a %s.",

"Helyezzen be egy msik lemezt a kvetkez meghajtba: %c:. Ez a",
"lemez lesz a %s.",

"Ha elkszlt, nyomjon le egy billentyt.",

"A teleptsi indtlemezek ltrehozsa sikeren megtrtnt.",
"ksz",

"Ismeretlen hiba trtnt %s vgrehajtsa kzben.",
"Adja meg, mely hajlkonylemezre szeretn msolni a programkdot: ",
"rvnytelen meghajtbetjel\n",
"%c: meghajt nem hajlkonylemezmeghajt\n",

"Megprblja jra ltrehozni a hajlkonylemezt?",
"Az jraprblkozshoz nyomja le az Enter, a kilpshez az Esc billentyt.",

"Hiba: A lemez rsvdett\n",
"Hiba: Ismeretlen lemezegysg\n",
"Hiba: A meghajt nem ll kszen\n",
"Hiba: Ismeretlen parancs\n",
"Hiba: Adathiba (rossz CRC)\n",
"Hiba: Rossz a krelemstruktra hossza\n",
"Hiba: Pozicionlsi hiba\n",
"Hiba: A mdiatpus nem tallhat\n",
"Hiba: A szektor nem tallhat\n",
"Hiba: rsi hiba\n",
"Hiba: ltalnos hiba\n",
"Hiba: rvnytelen krelem, vagy rossz hiba\n",
"Hiba: A cmjel nem tallhat\n",
"Hiba: Lemezrsi hiba\n",
"Hiba: Kzvetlen memriahozzfrs (DMA) tlfutsa\n",
"Hiba: Adathiba (CRC vagy ECC)\n",
"Hiba: Vezrlhiba\n",
"Hiba: A lemez ideje lejrt, vagy nem vlaszolt\n",

"Windows XP SP1 5. sz. teleptsi lemez",
"Windows XP SP1 6. sz. teleptsi lemez"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\it\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Disco di avvio dell'installazione di Windows XP SP1",
"Disco 2 - Installazione di Windows XP SP1",
"Disco 3 - Installazione di Windows XP SP1",
"Disco 4 - Installazione di Windows XP SP1",

"Impossibile trovare file %s\n",
"Memoria insufficiente per completare la richiesta\n",
"%s: formato file non eseguibile\n",
"****************************************************",

"Questo programma crea dischi di installazione",
"per Microsoft %s.",
"Per creare questi dischi sono necessari 6 dischi floppy,",
"ad alta densit, formattati e vuoti.",

"Inserire un disco nell'unit %c:.  Questo disco",
"diverr il %s.",

"Inserire un altro disco nell'unit %c:.  Questo disco",
"diverr il %s.",

"Premere un tasto per continuare.",

"I dischi di avvio dell'installazione sono stati creati",
"completato",

"Errore sconosciuto durante l'esecuzione di %s.",
"Specificare l'unit floppy su cui copiare l'immagine: ",
"Lettera di unit non valida\n",
"L'unit %c: non  un'unit floppy\n",

"Creare di nuovo questo floppy?",
"Premere INVIO per riprovare o ESC per uscire.",

"Errore: disco protetto da scrittura\n",
"Errore: unit disco sconosciuta\n",
"Errore: unit non pronta\n",
"Errore: comando sconosciuto\n",
"Errore: errore di dati (CRC errato)\n",
"Errore: lunghezza struttura richiesta errata\n",
"Errore: errore ricerca\n",
"Errore: tipo supporto non trovato\n",
"Errore: settore non trovato\n",
"Errore: errore scrittura\n",
"Errore: errore generale\n",
"Errore: richiesta non valida o comando errato\n",
"Errore: segno indirizzo non trovato\n",
"Errore: errore scrittura disco\n",
"Errore: sovraccarico Direct Memory Access (DMA)\n",
"Errore: errore lettura dati (CRC o ECC)\n",
"Errore: errore controller\n",
"Errore: timeout o mancata risposta del disco\n",

"Disco 5 - Installazione di Windows XP SP1",
"Disco 6 - Installazione di Windows XP SP1"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\nl\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Setup-opstartdiskette",
"Windows XP SP1 Setup-diskette 2",
"Windows XP SP1 Setup-diskette 3",
"Windows XP SP1 Setup-diskette 4",

"Kan het bestand %s niet vinden\n",
"Onvoldoende geheugen om de aanvraag te voltooien\n",
"%s heeft geen indeling als uitvoerbaar bestand\n",
"****************************************************",

"Dit programma maakt de Setup-diskettes",
"voor Microsoft %s.",
"U hebt 6 lege, geformatteerde diskettes met een hoge",
"dichtheid nodig om de Setup-diskettes te kunnen maken.",

"Plaats een van de diskettes in station %c:.",
"Deze diskette wordt: %s.",

"Plaats een andere diskette in station %c:.",
"Deze diskette wordt: %s.",

"Druk op een toets als u de diskette nu wilt maken.",

"De Setup-diskettes zijn gemaakt.",
"voltooid",

"Er is een onbekende fout opgetreden tijdens het\nuitvoeren van %s.",
"Geef op naar welke diskette de installatiekopie\nmoet worden gekopieerd: ",
"Ongeldige stationsletter\n",
"Station %c: is geen diskettestation\n",

"Wilt u opnieuw proberen deze diskette te maken?",
"Druk op Enter als u het opnieuw wilt proberen of\nop Esc als u dit niet wilt.",

"Fout: de diskette is tegen schrijven beveiligd\n",
"Fout: onbekende indelingseenheid op de diskette\n",
"Fout: het station is niet gereed\n",
"Fout: onbekende opdracht\n",
"Fout: gegevensfout (ongeldige CRC)\n",
"Fout: ongeldige structuurlengte van de aanvraag\n",
"Fout: zoekfout\n",
"Fout: mediumtype niet gevonden\n",
"Fout: sector niet gevonden\n",
"Fout: schrijffout\n",
"Fout: algemene fout\n",
"Fout: ongeldige aanvraag of opdracht\n",
"Fout: kan adresmarkering niet vinden\n",
"Fout: fout bij het schrijven\n",
"Fout: DMA-overloop (Direct Memory Access)\n",
"Fout: fout bij het lezen van gegevens (CRC of ECC)\n",
"Fout: storing bij de controller\n",
"Fout: time-out van de diskette of kan niet reageren\n",

"Windows XP SP1 Setup-diskette 5",
"Windows XP SP1 Setup-diskette 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\no\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Oppstartsdiskett for Windows XP SP1",
"Installasjonsdiskett 2 for Windows XP SP1",
"Installasjonsdiskett 3 for Windows XP SP1",
"Installasjonsdiskett 4 for Windows XP SP1",

"Finner ikke filen %s\n",
"Ikke nok minne til  fullfre foresprselen\n",
"%s er ikke i et kjrbart filformat\n",
"****************************************************",

"Dette programmet lager installasjonsdiskene",
"for Microsoft %s.",
"For  lage disse diskettene, trenger du 6 tomme og",
"formaterte disketter med hy tetthet.",

"Sett inn en av disse diskettene i stasjon %c:. Denne",
"disketten vil bli %s.",

"Sett inn en annen diskett i stasjon %c:. Denne",
"disketten vil bli %s.",

"Trykk en tast nr du er klar.",

"Installasjonsdiskettene er opprettet.",
"fullfrt",

"Det har oppsttt en ukjent feil ved forsk p  kjre %s.",
"Angi diskettstasjonen avbildingene skal kopieres til: ",
"Ugyldig stasjonsbokstav\n",
"Stasjon %c: er ikke en diskettstasjon\n",

"Vil du prve  lage denne disketten p nytt?",
"Trykk Enter for  prve igjen eller ESC for  avslutte.",

"Feil: Disken er skrivebeskyttet\n",
"Feil: Ukjent diskenhet\n",
"Feil: Stasjonen er ikke klar\n",
"Feil: Ukjent kommando\n",
"Feil: Datafeil (Feil CRC)\n",
"Feil: Ugyldig lengde p foresprselsstruktur\n",
"Feil: Skefeil\n",
"Feil: Finner ikke medietypen\n",
"Feil: Finner ikke sektor\n",
"Feil: Skrivefeil\n",
"Feil: Generell feil\n",
"Feil: Ugyldig foresprsel eller kommando\n",
"Feil: Finner ikke adressemerke\n",
"Feil: Diskskrivefeil\n",
"Feil: DMA-overkjring (Direct Memory Access)\n",
"Feil: Datalesefeil (CRC eller ECC)\n",
"Feil: Kontrollerfeil\n",
"Feil: Disken ble tidsavbrutt eller svarte ikke\n",

"Installasjonsdiskett 5 for Windows XP SP1",
"Installasjonsdiskett 6 for Windows XP SP1"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\pl\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP SP1",
"Dysk rozruchowy Instalatora dodatku SP1 systemu Windows XP",
"Dodatek SP1 systemu Windows XP - dysk instalacyjny nr 2",
"Dodatek SP1 systemu Windows XP - dysk instalacyjny nr 3",
"Dodatek SP1 systemu Windows XP - dysk instalacyjny nr 4",

"Nie mona znale pliku %s\n",
"Za mao wolnej pamici do wykonania dania\n",
"%s nie ma formatu pliku wykonywalnego\n",
"****************************************************",

"Ten program tworzy dyskietki rozruchowe Instalatora",
"dla systemu Microsoft %s.",
"Aby utworzy te dyskietki, potrzebnych jest 6 pustych,",
"sformatowanych dyskietek duej gstoci.",

"W jedn z tych dyskietek do stacji dyskw %c:. Bdzie to",
"%s.",

"W kolejn dyskietk do stacji dyskw %c:. Bdzie to",
"%s.",

"Nacinij dowolny klawisz, gdy zechcesz kontynuowa.",

"Dyskietki rozruchowe Instalatora zostay utworzone pomylnie.",
"zakoczono",

"Podczas prby wykonania %s wystpi nieznany bd.",
"Okrel stacj dyskietek, do ktrej maj by skopiowane obrazy: ",
"Nieprawidowa litera stacji dyskw\n",
"Stacja dyskw %c: nie jest stacj dyskietek\n",

"Czy chcesz ponownie sprbowa utworzy t dyskietk?",
"Nacinij klawisz Enter, aby ponowi prb, lub klawisz Esc, aby zakoczy.",

"Bd: dysk jest zabezpieczony przed zapisem\n",
"Bd: nieznana jednostka dyskowa\n",
"Bd: stacja dyskw nie jest gotowa\n",
"Bd: nieznane polecenie\n",
"Bd: bd danych (za suma kontrolna CRC)\n",
"Bd: za dugo struktury dania\n",
"Bd: bd wyszukiwania\n",
"Bd: nie znaleziono typu nonika\n",
"Bd: nie znaleziono sektora\n",
"Bd: niepowodzenie zapisu\n",
"Bd: bd oglny\n",
"Bd: nieprawidowe danie lub ze polecenie\n",
"Bd: nie znaleziono znacznika adresu\n",
"Bd: niepowodzenie zapisu na dysku\n",
"Bd: przepenienie podczas bezporedniego dostpu do pamici (DMA)\n",
"Bd: bd odczytu danych (suma kontrolna CRC lub ECC)\n",
"Bd: bd kontrolera\n",
"Bd: upyn limit czasu dysku lub dysk nie odpowiada\n",

"Dodatek SP1 systemu Windows XP - dysk instalacyjny nr 5",
"Dodatek SP1 systemu Windows XP - dysk instalacyjny nr 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\jpn\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 932;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Setup Boot Disk",
"Windows XP SP1 Setup Disk #2",
"Windows XP SP1 Setup Disk #3",
"Windows XP SP1 Setup Disk #4",

"Cannot find file %s\n",
"Not enough free memory to complete request\n",
"%s is not in an executable file format\n",
"****************************************************",

"This program creates the Setup boot disks",
"for Microsoft %s.",
"To create these disks, you need to provide 6 blank,",
"formatted, high-density disks.",

"Insert one of these disks into drive %c:.  This disk",
"will become the %s.",

"Insert another disk into drive %c:.  This disk will",
"become the %s.",

"Press any key when you are ready.",

"The setup boot disks have been created successfully.",
"complete",

"An unknown error has occurred trying to execute %s.",
"Please specify the floppy drive to copy the images to: ",
"Invalid drive letter\n",
"Drive %c: is not a floppy drive\n",

"Do you want to attempt to create this floppy again?",
"Press Enter to try again or Esc to exit.",

"Error: Disk write protected\n",
"Error: Unknown disk unit\n",
"Error: Drive not ready\n",
"Error: Unknown command\n",
"Error: Data error (Bad CRC)\n",
"Error: Bad request structure length\n",
"Error: Seek error\n",
"Error: Media type not found\n",
"Error: Sector not found\n",
"Error: Write fault\n",
"Error: General failure\n",
"Error: Invalid request or bad command\n",
"Error: Address mark not found\n",
"Error: Disk write fault\n",
"Error: Direct Memory Access (DMA) overrun\n",
"Error: Data read (CRC or ECC) error\n",
"Error: Controller failure\n",
"Error: Disk timed out or failed to respond\n",

"Windows XP SP1 Setup Disk #5"
"Windows XP SP1 Setup Disk #6"
};

const char *LocStrings[] = {
"Windows XP SP1",
"Windows XP SP1 Setup Boot Disk",
"Windows XP SP1 Setup Disk #2",
"Windows XP SP1 Setup Disk #3",
"Windows XP SP1 Setup Disk #4",

"t@C %s \n",
"sv\n",
"%s st@C`\n",
"****************************************************",

"vOZbgAbv u[g fBXN",
"Microsoft %s pB",
"fBXNAtH[}bg",
"x (HD) fBXN 6 KvB",

"fBXN 1 hCu %c: }B",                              
"fBXN %s B",

"fBXNhCu %c: }B",
"fBXN %s B",

"L[B",

"ZbgAbv u[g fBXNB",
"",

"%s ssG[B",
"Rs[tbs[ hCuw: ",
"hCu\n",
"hCu %c: tbs[ hCu\n",

"tbs[x?",
"s = [Enter]  I = [ESC]",

"G[: fBXN~\n",
"G[: fBXN jbgs\n",
"G[: hCu\n",
"G[: R}hs\n",
"G[: f[^ G[ (CRC )\n",
"G[: v\\\n",
"G[: V[N G[\n",
"G[: fBA\n",
"G[: ZN^\n",
"G[: tHg\n",
"G[: G[\n",
"G[: vAR}h\n",
"G[: AhX }[N\n",
"G[: fBXNtHg\n",
"G[: DMA (Direct Memory Access) \n",
"G[: f[^ (CRC  ECC) G[\n",
"G[: Rg[G[\n",
"G[: fBXN^CAEgA\n",

"Windows XP SP1 Setup Disk #5"
"Windows XP SP1 Setup Disk #6"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\_cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\_br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\pt\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Disquete de arranque da configuraao do Windows XP SP1",
"Disquete de arranque da configuraao do Windows XP SP1 n. 2",
"Disquete de arranque da configuraao do Windows XP SP1 n. 3",
"Disquete de arranque da configuraao do Windows XP SP1 n. 4",

"Nao  possvel encontrar o ficheiro %s\n",
"Ano existe memria livre disponvel para concluir o pedido\n",
"%s nao est num formato de ficheiro executvel\n",
"****************************************************",

"Este programa cria as disquetes de arranque da configuraao",
"para o Microsoft %s.",
"Para criar estas disquetes, necessita de fornecer seis",
"disquetes de alta densidade limpas e formatadas.",

"Insira uma dessas disquetes na unidade %c:. Esta disquete",
"ser a %s.",

"Insira outra disquete na unidade %c:. Esta disquete",
"ser a %s.",

"Prima uma tecla quando estiver preparado.",

"As disquetes de arranque da configuraao foram criadas com xito.",
"concludo",

"Ocorreu um erro desconhecido ao tentar executar %s.",
"Especifique a unidade de disquetes para copiar as imagens: ",
"Letra de unidade invlida\n",
"A unidade %c: nao  uma unidade de disquetes\n",

"Deseja tentar novamente a criaao desta disquete?",
"Prima Enter para tentar novamente ou Esc para sair.",

"Erro: A disquete est protegida contra a escrita\n",
"Erro: Unidade de disquete desconhecida\n",
"Erro: A unidade nao est  pronta\n",
"Erro: Comando desconhecido\n",
"Erro: Erro de dados (CRC invlido)\n",
"Erro: O comprimento da estrutura do pedido  invlido\n",
"Erro: Erro de procura\n",
"Erro: Nao foi encontrado o tipo de suporte de dados\n",
"Erro: Nao foi encontrado o sector\n",
"Erro: Falha na escrita\n",
"Erro: Falha geral\n",
"Erro: Pedido ou comando invlido\n",
"Erro: Nao foi encontrada a marca de endereo\n",
"Erro: Falha na escrita de disco\n",
"Erro: Transbordo na 'Memria de acesso directo' (DMA)\n",
"Erro: Erro na leitura de dados (CRC ou ECC)\n",
"Erro: Falha do controlador\n",
"Erro: A disquete ultrapassou o tempo limite ou nao respondeu\n",

"Disquete de arranque da configuraao do Windows XP SP1 n. 5",
"Disquete de arranque da configuraao do Windows XP SP1 n. 6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\sv\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP SP1",
"Startdiskett fr installationsprogrammet fr Windows XP SP1",
"Installationsdiskett nr 2 fr Windows XP SP1",
"Installationsdiskett nr 3 fr Windows XP SP1",
"Installationsdiskett nr 4 fr Windows XP SP1",

"Fljande fil kan inte hittas: %s\n",
"Det saknas ledigt minne fr att utfra tgrden\n",
"%s r inte en krbar fil\n",
"****************************************************",

"Det hr programmet skapar startdisketter fr",
"installationsprogrammet fr Microsoft %s.",
"Om du vill skapa de hr disketterna behver du 6 tomma,",
"formaterade hgdensitetsdisketter.",

"Stt in en av disketterna i enhet %c:. Den hr disketten",
"kommer att bli %s.",

"Stt in en annan diskett i enhet %c:. Den hr disketten",
"kommer att bli %s.",

"Tryck ned valfri tangent nr du r redo.",

"Startdisketterna har nu skapats.",
"frdig",

"Ett oknt fel uppstod nr %s skulle kras.",
"Ange vilken enhet som avbildningen ska kopieras till: ",
"Felaktig enhetsbeteckning\n",
"Enhet %c: r inte en diskettenhet\n",

"Vill du frska skapa disketten igen?",
"Tryck ned Retur om du vill frska igen eller Esc om du vill avsluta.",

"Fel: Disketten r skrivskyddad\n",
"Fel: Oknd diskenhet\n",
"Fel: Enheten r inte redo\n",
"Fel: Oknt kommando\n",
"Fel: Data fel (felaktig CRC)\n",
"Fel: Begrandestrukturen har felaktig lngd\n",
"Fel: Skningsfel\n",
"Fel: Medietypen kan inte hittas\n",
"Fel: En sektor kan inte hittas\n",
"Fel: Skrivfel\n",
"Fel: Allmnt fel\n",
"Fel: Ogiltig begran eller felaktigt kommando\n",
"Fel: Adressmrke hittades inte\n",
"Fel: Diskskrivningsfel\n",
"Fel: DMA-verskridning (Direct Memory Access)\n",
"Fel: Datalsningsfel (CRC eller ECC)\n",
"Fel: Styrenhetsfel\n",
"Fel: Disken orsakade timeout eller svarade inte\n",

"Installationsdiskett nr 5 fr Windows XP SP1",
"Installationsdiskett nr 6 fr Windows XP SP1"  
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\tr\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 857;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Kurulum nykleme Disketi",
"Windows XP SP1 Kurulum Disketi #2",
"Windows XP SP1 Kurulum Disketi #3",
"Windows XP SP1 Kurulum Disketi #4",

"%s dosyas bulunamyor\n",
"stei tamamlamak iin yeterli bellek yok\n",
"%s altrlabilir dosya biiminde deil\n",
"****************************************************",

"Bu program, unun iin Kurulum nykleme disketleri oluturur:",
"Microsoft %s.",
"Bu disketleri oluturmak iin biimlendirilmi, yksek younlukta",
"6 bo disket gerekir.",

"Bu disketlerden birini %c: srcsne yerletirin.  Bu",
"disket %s olur.",

"%c: srcsne baka bir disket yerletirin.  Bu",
"disket %s olur.",

"Hazr olduunuzda bir tua basn.",

"Kur nykleme disketleri baaryla oluturuldu.",
"tamamland",

"%s altrlmas denenirken bilinmeyen bir hata olutu.",
"Yansmalarn kopyalanaca disket srcsn belirtin: ",
"Geersiz src harfi\n",
"%c: bir disket srcs deildir\n",

"Bu disketi yeniden oluturmay denemek istiyor musunuz?",
"Yeniden denemek iin Enter'e, kmak iin Esc'ye basn.",

"Hata: Disket yazma korumal\n",
"Hata: Bilinmeyen disket birimi\n",
"Hata: Src hazr deil\n",
"Hata: Bilinmeyen komut\n",
"Hata: Veri hatas (Hatal CRC)\n",
"Hata: Hatal istek yaps uzunluu\n",
"Hata: Arama hatas\n",
"Hata: Ortam tr bulunamad\n",
"Hata: Kesim bulunamad\n",
"Hata: Yazma hatas\n",
"Hata: Genel hata\n",
"Hata: Geersiz istek ya da hatal komut\n",
"Hata: Adres iareti bulunamad\n",
"Hata: Disk yazma hatas\n",
"Hata: Dorudan Bellek Eriimi (DMA) tamas\n",
"Hata: Veri okuma (CRC ya da ECC) hatas\n",
"Hata: Denetleyici hatas\n",
"Hata: Disk zaman amna urad ya da yantlayamad\n",

"Windows XP SP1 Kurulum Disketi #5",
"Windows XP SP1 Kurulum Disketi #6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\ru\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 866;

const char *EngStrings[] = {

"Windows XP",
"  1 Windows XP SP1",
"  2 Windows XP SP1",
"  3 Windows XP SP1",
"  4 Windows XP SP1",

"   %s\n",
"    \n",
"%s    \n",
"****************************************************",

"     ",
" Microsoft %s.",
"   ,  6 ",
"   .",

"      %c:.   ",
"  %s.",

"     %c:.   ",
"  %s.",

"    .",

"    .",
"",

"     %s.",
" ,     : ",
"  \n",
" %c:     \n",

"     ?",
" <>    <Esc>    .",

":    \n",
":   \n",
":   \n",
":  \n",
":    ( CRC)\n",
":    \n",
":  \n",
":    \n",
":   \n",
":  \n",
":  \n",
":    \n",
":    \n",
":    \n",
":  DMA\n",
":    (CRC  ECC)\n",
":  \n",
":        \n",

"  5 Windows XP SP1",
"  6 Windows XP SP1"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\usa\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 437;

const char *EngStrings[] = {

"Windows XP SP1",
"Windows XP SP1 Setup Boot Disk",
"Windows XP SP1 Setup Disk #2",
"Windows XP SP1 Setup Disk #3",
"Windows XP SP1 Setup Disk #4",

"Cannot find file %s\n",
"Not enough free memory to complete request\n",
"%s is not in an executable file format\n",
"****************************************************",

"This program creates the Setup boot disks",
"for Microsoft %s.",
"To create these disks, you need to provide 6 blank,",
"formatted, high-density disks.",

"Insert one of these disks into drive %c:.  This disk",
"will become the %s.",

"Insert another disk into drive %c:.  This disk will",
"become the %s.",

"Press any key when you are ready.",

"The setup boot disks have been created successfully.",
"complete",

"An unknown error has occurred trying to execute %s.",
"Please specify the floppy drive to copy the images to: ",
"Invalid drive letter\n",
"Drive %c: is not a floppy drive\n",

"Do you want to attempt to create this floppy again?",
"Press Enter to try again or Esc to exit.",

"Error: Disk write protected\n",
"Error: Unknown disk unit\n",
"Error: Drive not ready\n",
"Error: Unknown command\n",
"Error: Data error (Bad CRC)\n",
"Error: Bad request structure length\n",
"Error: Seek error\n",
"Error: Media type not found\n",
"Error: Sector not found\n",
"Error: Write fault\n",
"Error: General failure\n",
"Error: Invalid request or bad command\n",
"Error: Address mark not found\n",
"Error: Disk write fault\n",
"Error: Direct Memory Access (DMA) overrun\n",
"Error: Data read (CRC or ECC) error\n",
"Error: Controller failure\n",
"Error: Disk timed out or failed to respond\n",

"Windows XP SP1 Setup Disk #5",
"Windows XP SP1 Setup Disk #6"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\eulas\sources.inc ===
!IF 0
Bootfloppy eulas.
!ENDIF

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=

MISCFILES =             \
    bflics.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\32bit\resource.h ===
//---------------------------------------------------------------------------
//
// File: resource.h
//
// Description:
//      This file contatins all of the string constant IDs that go with
//      makebt32.rc
//
//---------------------------------------------------------------------------

#define IDS_OUT_OF_MEMORY                     101
#define IDS_144_NOT_SUPPORTED                 105
#define IDS_NO_ROOT_DIR                       107
#define IDS_DRIVE_NOT_FL0PPY                  108
#define IDS_CANNOT_FIND_FILE                  109
#define IDS_NT_VERSION_NAME_DEFAULT           110
#define IDS_DISK_LABEL_1_DEFAULT              111
#define IDS_DISK_LABEL_2_DEFAULT              112
#define IDS_DISK_LABEL_3_DEFAULT              113
#define IDS_DISK_LABEL_4_DEFAULT              114
#define IDS_STARS                             115
#define IDS_PROGRAM_EXPLANATION_LINE_1        116
#define IDS_PROGRAM_EXPLANATION_LINE_2        117
#define IDS_PROGRAM_EXPLANATION_LINE_3        118
#define IDS_PROGRAM_EXPLANATION_LINE_4        119

#define IDS_INSERT_FIRST_DISK_LINE_1          120
#define IDS_INSERT_FIRST_DISK_LINE_2          122

#define IDS_INSERT_ANOTHER_DISK_LINE_1        123
#define IDS_INSERT_ANOTHER_DISK_LINE_2        125

#define IDS_PRESS_ANY_KEY_WHEN_READY          126

#define IDS_COMPLETED_SUCCESSFULLY            127
#define IDS_COMPLETE                          128

#define IDS_SPECIFY_FLOPPY_DRIVE              129
#define IDS_INVALID_DRIVE_LETTER              130

#define IDS_ATTEMPT_TO_CREATE_FLOPPY_AGAIN    131
#define IDS_PRESS_ENTER_OR_ESC                132
#define IDS_DISK_LABEL_5_DEFAULT              133
#define IDS_DISK_LABEL_6_DEFAULT              134
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\32bit\makebt32.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makebt32.c
//
// Description:
//      This program copies the images of the 4 Windows NT setup disks to
//      floppy disk so the user can boot their system with them.
//
//      All characters and strings are wide (UNICODE).  This file needs to be
//      compiled with UNICODE and _UNICODE defined.
//
// Assumptions:
//      This program will only run on NT 3.51 or later.  This is a result of
//      the CreateFile function call.  It is not available on DOS, Windows 3.1
//      or Windows 9x.
//
//      The floppy disk images are in the current dir and named CDBOOT1.IMG,
//      CDBOOT2.IMG, CDBOOT3.IMG and CDBOOT4.IMG.
//
//      Please note that there are a lot of places where I call exit() without
//      freeing memory for strings I have allocated.  This version of the
//      program only runs on NT so when the process exits it frees all its
//      memory so it is not a concern that I may not call free() on some memory.
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <setupapi.h>
#include <winioctl.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

//
//  Constants
//
#define MAKEBOOT_MAX_STRING_LEN  1024
#define BYTES_PER_SECTOR         512
#define SECTORS_PER_TRACK        18
#define TRACK_SIZE               SECTORS_PER_TRACK * BYTES_PER_SECTOR
#define TRACKS_ON_DISK           80 * 2  // * 2 because it is double-sided

#define MAX_DISK_LABEL_LENGTH    256
#define MAX_INILINE_LENGTH       1023

#define ENTER_KEY                13
#define ESC_KEY                  27

#define NT_IMAGE_1_NAME               L"CDBOOT1.IMG"
#define NT_IMAGE_2_NAME               L"CDBOOT2.IMG"
#define NT_IMAGE_3_NAME               L"CDBOOT3.IMG"
#define NT_IMAGE_4_NAME               L"CDBOOT4.IMG"
#define NT_IMAGE_5_NAME               L"CDBOOT5.IMG"
#define NT_IMAGE_6_NAME               L"CDBOOT6.IMG"

#define NUMBER_OF_ASCII_WHEEL_SYMBOLS  4

const WCHAR rgAsciiWheel[NUMBER_OF_ASCII_WHEEL_SYMBOLS] = { '|', '/', '-', '\\' };

//
//  Function prototypes
//
BOOL   WriteImageToFloppy( WCHAR *szFileName, WCHAR *DrivePath );
VOID   PrintErrorMessage( VOID );
VOID   PrintErrorWrongDriveType( UINT iDriveType );
BOOL   IsDriveLargeEnough( WCHAR *DrivePath );
VOID   FreeStrings( VOID );
VOID   LoadStrings( VOID );
INT    DoImageFilesExist( VOID ) ;
VOID   CleanUp( HANDLE *hFloppyDrive, HANDLE *hFloppyImage );
BOOL   DoesUserWantToTryCopyAgain( VOID );
LPWSTR MyLoadString( UINT StringId );
VOID   print( WCHAR *szFirstString, ... );
BOOL   DoesFileExist( LPWSTR lpFileName );
VOID   PressAnyKeyToContinue( VOID );
void SetFarEastThread();
void ConsolePrint( WCHAR *szFirstString, ... );
//
//  Global Strings
//
WCHAR *StrOutOfMemory    = NULL;
WCHAR *StrComplete       = NULL;
WCHAR *StrNtVersionName  = NULL;
WCHAR *StrCanNotFindFile = NULL;
WCHAR *StrDiskLabel1     = NULL;
WCHAR *StrDiskLabel2     = NULL;
WCHAR *StrDiskLabel3     = NULL;
WCHAR *StrDiskLabel4     = NULL;
WCHAR *StrDiskLabel5     = NULL;
WCHAR *StrDiskLabel6     = NULL;

WCHAR *StrStars                         = NULL;
WCHAR *StrExplanationLine1              = NULL;
WCHAR *StrExplanationLine2              = NULL;
WCHAR *StrExplanationLine3              = NULL;
WCHAR *StrExplanationLine4              = NULL;
WCHAR *StrInsertFirstDiskLine1          = NULL;
WCHAR *StrInsertFirstDiskLine2          = NULL;
WCHAR *StrInsertAnotherDiskLine1        = NULL;
WCHAR *StrInsertAnotherDiskLine2        = NULL;
WCHAR *StrPressAnyKeyWhenReady          = NULL;
WCHAR *StrCompletedSuccessfully         = NULL;

//----------------------------------------------------------------------------
//
// Function: wmain
//
// Purpose: Instructs user to insert floppy disks to be copied and performs
//          the copy.
//
// Arguments: int argc - standard program argument, count of the command line args
//            char *argv[] - standard program argument, the 2nd argument is the
//                           floppy drive to copy the images to.
//
// Returns: INT - zero on successful program completion
//              - non-zero on unsuccessful program completion, program
//                terminated because of an error
//
//----------------------------------------------------------------------------
INT __cdecl
wmain( INT argc, WCHAR *argv[] )
{

    WCHAR *szOsName;
    WCHAR DriveLetter;
    WCHAR Drive[10];
    WCHAR DrivePath[10];
    UINT  iDriveType;
    BOOL  bTryAgain;

    szOsName = _wgetenv( L"OS" );

    //
    //  Make sure we are on NT.
    //
    if( ( szOsName == NULL ) || ( _wcsicmp( szOsName, L"Windows_NT" ) != 0 ) )
    {

        //  ******
        //  This string cannot be localized because if we are not on NT then
        //  we don't have wide chars.
        //
        printf( "This program only runs on Windows NT, Windows 2000 and Windows XP.\n" );

        exit( 1 );

    }

    SetFarEastThread();

    //
    //  Load all of the strings from the resource file
    //
    LoadStrings();

    //
    //  Don't allow the system to do any pop-ups.  We will handle all
    //  error messages
    //
    SetErrorMode( SEM_FAILCRITICALERRORS );

    print( L"" );

    print( StrStars );

    print( StrExplanationLine1 );

    print( StrExplanationLine2, StrNtVersionName );

    print( StrExplanationLine3 );
    print( StrExplanationLine4 );

    print( L"" );

    //
    //  If they didn't specified the floppy drive on the command line then
    //  prompt them for it.
    //
    if( argc == 1 )
    {

        WCHAR *StrSpecifyFloppyDrive = MyLoadString( IDS_SPECIFY_FLOPPY_DRIVE );

        ConsolePrint( L"%s", StrSpecifyFloppyDrive );

        DriveLetter = (WCHAR)_getche();

        ConsolePrint( L"\n\n" );

        free( StrSpecifyFloppyDrive );

    }
    else
    {

        DriveLetter = argv[1][0];

    }

    //
    //  Make sure the character they entered is a possible drive letter
    //
    if( ! isalpha( DriveLetter ) )
    {

        WCHAR *StrInvalidDriveLetter = MyLoadString( IDS_INVALID_DRIVE_LETTER );

        ConsolePrint( L"%s\n", StrInvalidDriveLetter );

        free( StrInvalidDriveLetter );

        exit( 1 );

    }

    //
    //  Make sure all the image files are in the current directory.
    //
    if( ! DoImageFilesExist() )
    {

        exit( 1 );

    }

    //
    //  Make the char DriveLetter into a string
    //
    Drive[0] = DriveLetter;
    Drive[1] = L'\0';

    //
    //  Build the drive path. For example the a: drive looks like \\.\a:
    //
    swprintf( DrivePath, L"\\\\.\\%c:", DriveLetter );

    //
    //  Make sure the drive is a floppy drive
    //
    iDriveType = GetDriveType( wcscat( Drive, L":\\" ) );

    if( iDriveType != DRIVE_REMOVABLE )
    {

        PrintErrorWrongDriveType( iDriveType );

        exit( 1 );

    }

    //
    //  Make sure the drive can hold at least 1.44 MB
    //
    if( ! IsDriveLargeEnough( DrivePath ) )
    {

        WCHAR *Str144NotSupported = MyLoadString( IDS_144_NOT_SUPPORTED );

        ConsolePrint( L"%s\n", Str144NotSupported );

        free( Str144NotSupported );

        exit( 1 );

    }

    print( StrInsertFirstDiskLine1, DriveLetter   );
    print( StrInsertFirstDiskLine2, StrDiskLabel1 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_1_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel2 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_2_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel3 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_3_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel4 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_4_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel5 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_5_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel6 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_6_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrCompletedSuccessfully );

    print( StrStars );

    FreeStrings();

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: WriteImageToFloppy
//
// Purpose:  Writes an image file to a floppy disk.  Handles all error
//           reporting to the user.
//
// Arguments: char *szFileName - filename to write to the floppy
//            char *DrivePath - drive path of the floppy to write to, it is of
//    the form \\.\x where x is the drive letter
//
// Returns: BOOL - TRUE  if image written to floppy properly
//                 FALSE if there were errors
//
//----------------------------------------------------------------------------
BOOL
WriteImageToFloppy( WCHAR *szFileName, WCHAR *DrivePath )
{

    INT    iCurrentTrack;
    INT    cBytesRead       = 0;
    INT    cBytesWritten    = 0;
    INT    iPercentComplete = 0;
    INT    iWheelPosition   = 0;
    HANDLE hFloppyImage     = NULL;
    HANDLE hFloppyDrive     = NULL;
    char   TrackBuffer[TRACK_SIZE];

    hFloppyImage = CreateFile( szFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if( hFloppyImage == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        return( FALSE );

    }

    hFloppyDrive = CreateFile( DrivePath,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if( hFloppyDrive == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        CleanUp( &hFloppyDrive, &hFloppyImage );

        return( FALSE );

    }

    for( iCurrentTrack = 0; iCurrentTrack < TRACKS_ON_DISK; iCurrentTrack++ )
    {
        if( ! ReadFile( hFloppyImage, TrackBuffer, TRACK_SIZE, &cBytesRead, NULL ) )
        {

            PrintErrorMessage();

            CleanUp( &hFloppyDrive, &hFloppyImage );

            return( FALSE );

        }

        if( ! WriteFile( hFloppyDrive, TrackBuffer, TRACK_SIZE, &cBytesWritten, NULL ) )
        {

            PrintErrorMessage();

            CleanUp( &hFloppyDrive, &hFloppyImage );

            return( FALSE );

        }

        iPercentComplete = (int) ( ( (double) (iCurrentTrack) / (double) (TRACKS_ON_DISK) ) * 100.0 );

        ConsolePrint( L"%c %3d%% %s.\r",
                 rgAsciiWheel[iWheelPosition],
                 iPercentComplete,
                 StrComplete );

        //
        //  Advance the ASCII wheel
        //

        iWheelPosition++;

        if( iWheelPosition >= NUMBER_OF_ASCII_WHEEL_SYMBOLS )
        {
            iWheelPosition = 0;
        }

    }

    //
    //  We are done copying the disk so force it to read 100% and get rid of
    //  the ascii wheel symbol.
    //
    ConsolePrint( L"  100%% %s.        \n", StrComplete );

    //
    //  Free allocated resources
    //
    CleanUp( &hFloppyDrive, &hFloppyImage );

    return TRUE;

}

//----------------------------------------------------------------------------
//
// Function: PrintErrorMessage
//
// Purpose:  To get the last system error, look up what it is and print it out
//           to the user.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
PrintErrorMessage( VOID )
{

    LPVOID lpMsgBuf = NULL;

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       GetLastError(),
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR) &lpMsgBuf,
                       0,
                       NULL )) {
        // Great.  Not enough memory to format an error message.
        ConsolePrint( L"\nNot enough memory to format error message.\n" );
        if( lpMsgBuf )
	    LocalFree( lpMsgBuf );
    }
    else {

        ConsolePrint( L"\n%s\n", (LPCWSTR)lpMsgBuf );

        LocalFree( lpMsgBuf );
    }

}

//----------------------------------------------------------------------------
//
// Function: PrintErrorWrongDriveType
//
// Purpose:  To translate a drive type error code into a message and print it
//
// Arguments: UINT iDriveType - drive type error code to look-up
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
PrintErrorWrongDriveType( UINT iDriveType )
{

    if( iDriveType == DRIVE_NO_ROOT_DIR )
    {
        WCHAR *StrNoRootDir = MyLoadString( IDS_NO_ROOT_DIR );

        ConsolePrint( L"\n%s\n", StrNoRootDir );

        free( StrNoRootDir );
    }
    else
    {
        WCHAR *StrDriveNotFloppy = MyLoadString( IDS_DRIVE_NOT_FL0PPY );

        ConsolePrint( L"\n%s\n", StrDriveNotFloppy );

        free( StrDriveNotFloppy );
    }

}

//----------------------------------------------------------------------------
//
// Function: IsDriveLargeEnough
//
// Purpose:  To determine if the floppy drive supports 1.44 MB or larger disks
//
// Arguments: char* DrivePath - drive path of the floppy to write to, it is of
//    the form \\.\x where x is the drive letter
//
// Returns: BOOL - TRUE if the drive supports 1.44 MB or greater, FALSE if not
//
//----------------------------------------------------------------------------
BOOL
IsDriveLargeEnough( WCHAR *DrivePath )
{

    UINT i;
    HANDLE hFloppyDrive;
    DISK_GEOMETRY SupportedGeometry[20];
    DWORD SupportedGeometryCount;
    DWORD ReturnedByteCount;

    hFloppyDrive = CreateFile( DrivePath,
                               0,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               0,
                               NULL );

    if( hFloppyDrive == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        exit( 1 );

    }

    if( DeviceIoControl( hFloppyDrive,
                         IOCTL_DISK_GET_MEDIA_TYPES,
                         NULL,
                         0,
                         SupportedGeometry,
                         sizeof( SupportedGeometry ),
                         &ReturnedByteCount,
                         NULL ) )
    {

        SupportedGeometryCount = ( ReturnedByteCount / sizeof( DISK_GEOMETRY ) );

    }
    else
    {
        SupportedGeometryCount = 0;
    }

    CloseHandle( hFloppyDrive );

    for( i = 0; i < SupportedGeometryCount; i++ )
    {

        if( SupportedGeometry[i].MediaType == F3_1Pt44_512 )
        {

            //
            // This drive supports 3.5,  1.44MB, 512 bytes/sector.
            //
            return( TRUE );

        }

    }

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: DoImageFilesExist
//
// Purpose:  Determines if all the image files are in the current directory or
//           not.  If an image file is missing, an error message is printed
//           to the user.
//
//           Note: it detemines if a file exists by seeing if it can open it
//           for reading.
//
// Arguments: VOID
//
// Returns: INT -- non-zero on success, all images files exist in current dir
//                 zero on failure, 1 or more image files do not exist
//
//----------------------------------------------------------------------------
INT
DoImageFilesExist( VOID )
{

    BOOL  bAllFilesExist = TRUE;

    if( ! DoesFileExist( NT_IMAGE_1_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_1_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_2_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_2_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_3_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_3_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_4_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_4_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_5_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_5_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_6_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_6_NAME );
        bAllFilesExist = FALSE;
    }

    if( bAllFilesExist )
    {
        return( 1 );
    }
    else
    {
        return( 0 );
    }

}

//----------------------------------------------------------------------------
//
// Function: CleanUp
//
// Purpose:  Closes open handles.  This function should be called just before
//           exiting the program.
//
// Arguments:  HANDLE *hFloppyDrive - the floppy disk handle to be closed
//             HANDLE *hFloppyImage - the floppy image file handle to be closed
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
CleanUp( HANDLE *hFloppyDrive, HANDLE *hFloppyImage )
{

    if( *hFloppyDrive )
    {
        CloseHandle( *hFloppyDrive );
        *hFloppyDrive = NULL;
    }

    if( *hFloppyImage )
    {
        CloseHandle( *hFloppyImage );
        *hFloppyImage = NULL;
    }

}

//----------------------------------------------------------------------------
//
//  Function: FreeStrings
//
//  Purpose:  Deallocate the memory for all the strings.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
FreeStrings( VOID )
{

    free( StrNtVersionName );
    free( StrDiskLabel1 );
    free( StrDiskLabel2 );
    free( StrDiskLabel3 );
    free( StrDiskLabel4 );
    free( StrDiskLabel5 );
    free( StrDiskLabel6 );

    free( StrStars );
    free( StrExplanationLine1 );
    free( StrExplanationLine2 );
    free( StrExplanationLine3 );
    free( StrExplanationLine4 );
    free( StrInsertFirstDiskLine1 );
    free( StrInsertFirstDiskLine2 );
    free( StrInsertAnotherDiskLine1 );
    free( StrInsertAnotherDiskLine2 );
    free( StrPressAnyKeyWhenReady );
    free( StrCompletedSuccessfully );
    free( StrComplete );

    free( StrCanNotFindFile );

    free( StrOutOfMemory );

}

//----------------------------------------------------------------------------
//
//  Function: LoadStrings
//
//  Purpose:  Load the string constants from the string table.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
LoadStrings( VOID )
{

    INT Length;

    //
    //  Loading the Out of Memory string is a little tricky because of the
    //  error that can occur while loading it.
    //
    //  For the other strings, just call the MyLoadString function to do
    //  the work
    //
    StrOutOfMemory = (WCHAR *) malloc( MAKEBOOT_MAX_STRING_LEN * sizeof(WCHAR) + 1 );

    if( StrOutOfMemory == NULL )
    {
        //
        //  Can't localize this string
        //
        ConsolePrint( L"\nOut of memory.  Please free more memory and run this program again.\n" );

        exit( 1 );
    }

    Length = LoadString( NULL,
                         IDS_OUT_OF_MEMORY,
                         StrOutOfMemory,
                         MAKEBOOT_MAX_STRING_LEN );

    if( ! Length )
    {
        //
        //  Can't localize this string
        //
        ConsolePrint( L"Unable to load resources.\n" );

        exit( 1 ) ;
    }

    StrStars                   = MyLoadString( IDS_STARS );
    StrExplanationLine1        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_1 );
    StrExplanationLine2        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_2 );
    StrExplanationLine3        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_3 );
    StrExplanationLine4        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_4 );

    StrInsertFirstDiskLine1    = MyLoadString( IDS_INSERT_FIRST_DISK_LINE_1 );
    StrInsertFirstDiskLine2    = MyLoadString( IDS_INSERT_FIRST_DISK_LINE_2 );

    StrInsertAnotherDiskLine1  = MyLoadString( IDS_INSERT_ANOTHER_DISK_LINE_1 );
    StrInsertAnotherDiskLine2  = MyLoadString( IDS_INSERT_ANOTHER_DISK_LINE_2 );

    StrPressAnyKeyWhenReady    = MyLoadString( IDS_PRESS_ANY_KEY_WHEN_READY );

    StrCompletedSuccessfully   = MyLoadString( IDS_COMPLETED_SUCCESSFULLY );
    StrComplete                = MyLoadString( IDS_COMPLETE );

    StrCanNotFindFile          = MyLoadString( IDS_CANNOT_FIND_FILE );

    StrNtVersionName           = MyLoadString( IDS_NT_VERSION_NAME_DEFAULT );
    StrDiskLabel1              = MyLoadString( IDS_DISK_LABEL_1_DEFAULT );
    StrDiskLabel2              = MyLoadString( IDS_DISK_LABEL_2_DEFAULT );
    StrDiskLabel3              = MyLoadString( IDS_DISK_LABEL_3_DEFAULT );
    StrDiskLabel4              = MyLoadString( IDS_DISK_LABEL_4_DEFAULT );
    StrDiskLabel5              = MyLoadString( IDS_DISK_LABEL_5_DEFAULT );
    StrDiskLabel6              = MyLoadString( IDS_DISK_LABEL_6_DEFAULT );

}

//----------------------------------------------------------------------------
//
//  Function: DoesUserWantToTryCopyAgain
//
//  Purpose:  Ask the user if they want to retry to copy the image to floppy.
//            Get the user input and return whether to copy again or not.
//
//  Arguments: VOID
//
//  Returns:  BOOL - TRUE  if user wants to attempt to copy again
//                 - FALSE if user does not want to attempt to copy again
//
//----------------------------------------------------------------------------
BOOL
DoesUserWantToTryCopyAgain( VOID )
{

    INT ch;

    WCHAR *StrAttemptToCreateFloppyAgain = MyLoadString( IDS_ATTEMPT_TO_CREATE_FLOPPY_AGAIN );
    WCHAR *StrPressEnterOrEsc = MyLoadString( IDS_PRESS_ENTER_OR_ESC );

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( _kbhit() )
    {
        _getch();
    }

    do
    {
        ConsolePrint( L"%s\n", StrAttemptToCreateFloppyAgain );
        ConsolePrint( L"%s\n", StrPressEnterOrEsc );

        ch = _getch();

    } while( ch != ENTER_KEY && ch != ESC_KEY  );

    if( ch == ENTER_KEY )
    {
        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

    free( StrAttemptToCreateFloppyAgain );
    free( StrPressEnterOrEsc );

}

//----------------------------------------------------------------------------
//
//  Function: PressAnyKeyToContinue
//
//  Purpose:  Print the "Press any key when ready" message and wait until the
//  user presses a key.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
PressAnyKeyToContinue( VOID )
{

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( _kbhit() )
    {
        _getch();
    }

    print( StrPressAnyKeyWhenReady );

    //
    //  Spin until the keyboard is pressed
    //
    while( ! _kbhit() )
    {
        ;
    }

}

//----------------------------------------------------------------------------
//
//  Function: MyLoadString
//
//  Purpose: Loads a string resource given it's IDS_* and returns
//           a malloc'ed buffer with its contents.
//
//           The malloc()'ed buffer must be freed with free()
//
//           This function will either return the string or exit.  It will
//           never return NULL or a bad pointer.
//
//  Arguments: UINT StringId - the string ID to load
//
//  Returns:
//      Pointer to buffer.  An empty string is returned if the StringId
//      does not exist.  Null is returned if out of memory.
//
//----------------------------------------------------------------------------
LPWSTR
MyLoadString( UINT StringId )
{

    WCHAR Buffer[ MAKEBOOT_MAX_STRING_LEN ];
    WCHAR *String = NULL;
    UINT  Length;

    Length = LoadString( NULL,
                         StringId,
                         Buffer,
                         MAKEBOOT_MAX_STRING_LEN );

    if( Length )
    {

        String = (WCHAR *) malloc( Length * sizeof(WCHAR) + 1 );

        if( String == NULL )
        {

            ConsolePrint( L"%s\n", StrOutOfMemory );

            exit( 1 );

        }
        else
        {

            wcscpy( String, Buffer );
            String[Length] = L'\0';

            return( String );

        }

    }
    else
    {

        //
        //  Can't load the string so exit
        //  NOTE: this string will not be localized
        //
        ConsolePrint( L"Unable to load resources.\n" );

        exit( 1 );

    }

}

//----------------------------------------------------------------------------
//
//  Function: print
//
//  Purpose:  To print out strings to the user.  Useful when there is
//            embedded formatting characters in a string that was loaded from
//            a string table.
//
//  Arguments: szFirstString - the string that contains the embedded formatting
//                             characters (such as %s, %c, etc.)
//             ... - variable number of arguments that correspond to each
//                   formatting character
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
print( WCHAR *szFirstString, ... )
{

    WCHAR OutputBuffer[MAKEBOOT_MAX_STRING_LEN];
    va_list arglist;

    va_start( arglist, szFirstString );

    wvsprintf( OutputBuffer, szFirstString, arglist );

    ConsolePrint( L"%s\n", OutputBuffer );

    va_end( arglist );

}

//----------------------------------------------------------------------------
//
//  Function: DoesFileExist
//
//  Purpose:  To determine whether a file exists or not
//
//  Arguments: LPWSTR lpFileName - filename to see if it exists or not
//
//  Returns:  BOOL - TRUE  if the file exists
//                 - FALSE if the file does not exist
//
//----------------------------------------------------------------------------
BOOL
DoesFileExist( LPWSTR lpFileName )
{
    DWORD dwAttribs = GetFileAttributes( lpFileName );

    if( dwAttribs == (DWORD) -1 )
    {
        return( FALSE );
    }

    if( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
    {
        return( FALSE );
    }

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: IsDBCSConsole
//
//  Purpose:  To determine whether a DBC console or not
//
//  Arguments: None
//
//  Returns:  BOOL - TRUE  if FE console codepage
//                 - FALSE if not FE console codepage
//
//----------------------------------------------------------------------------
BOOL
IsDBCSCodePage(UINT CodePage)
{
    switch(CodePage) {
        case 932:
        case 936:
        case 949:
        case 950:
            return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
//
//  Function: SetFarEastThread
//
//  Purpose:  FarEast version wants to display bi-lingual string according console OCP
//
//  Arguments: None
//
//  Returns:  None
//----------------------------------------------------------------------------
void SetFarEastThread()
{
    LANGID LangId = 0;

    switch(GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            {
                LANGID TmpLangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));

                if (TmpLangId == LANG_JAPANESE ||
                    TmpLangId == LANG_KOREAN   ||
                    TmpLangId == LANG_CHINESE    ) {
                    LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                }
            }
            break;
    }

    if (LangId) {
        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    }
}

//----------------------------------------------------------------------------
//
//  Function: ConsolePrint
//
//  Purpose:  There is a bug in CRT library that unicode FE characters can't
//            convert correctly, so we output characters directly.
//
//  Arguments: None
//
//  Returns:  None
//----------------------------------------------------------------------------
void ConsolePrint( WCHAR *szFirstString, ... )
{
    HANDLE StdOut;
    DWORD WrittenCount;
    WCHAR OutputBuffer[MAKEBOOT_MAX_STRING_LEN];
    va_list arglist;

    if((StdOut = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
        return;
    }

    va_start( arglist, szFirstString );

    wvsprintf( OutputBuffer, szFirstString, arglist );

    WriteConsoleW(
            StdOut,
            OutputBuffer,
            lstrlenW(OutputBuffer),
            &WrittenCount,
            NULL
            );

    va_end( arglist );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makeboot\16bit\usa\dntext.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      dntext.c
//
// Description:
//      Translatable text for DOS based MAKEBOOT program.
//
//----------------------------------------------------------------------------

const char szNtVersionName[]              = "Windows XP SP1";
const char szDiskLabel1[]                 = "Windows XP SP1 Setup Boot Disk";
const char szDiskLabel2[]                 = "Windows XP SP1 Setup Disk #2";
const char szDiskLabel3[]                 = "Windows XP SP1 Setup Disk #3";
const char szDiskLabel4[]                 = "Windows XP SP1 Setup Disk #4";

const char szCannotFindFile[]             = "Cannot find file %s\n";
const char szNotEnoughMemory[]            = "Not enough free memory to complete request\n";
const char szNotExecFormat[]              = "%s is not in an executable file format\n";
const char szStars[]                      = "****************************************************";

const char szExplanationLine1[]           = "This program creates the Setup boot disks"; 
const char szExplanationLine2[]           = "for Microsoft %s.";
const char szExplanationLine3[]           = "To create these disks, you need to provide 6 blank,";
const char szExplanationLine4[]           = "formatted, high-density disks.";

const char szInsertFirstDiskLine1[]       = "Insert one of these disks into drive %c:.  This disk";                              
const char szInsertFirstDiskLine2[]       = "will become the %s.";

const char szInsertAnotherDiskLine1[]     = "Insert another disk into drive %c:.  This disk will";
const char szInsertAnotherDiskLine2[]     = "become the %s.";

const char szPressAnyKeyWhenReady[]       = "Press any key when you are ready.";

const char szCompletedSuccessfully[]      = "The setup boot disks have been created successfully.";
const char szComplete[]                   = "complete";

const char szUnknownSpawnError[]          = "An unknown error has occurred trying to execute %s.";
const char szSpecifyDrive[]               = "Please specify the floppy drive to copy the images to: ";
const char szInvalidDriveLetter[]         = "Invalid drive letter\n";
const char szNotAFloppy[]                 = "Drive %c: is not a floppy drive\n";

const char szAttemptToCreateFloppyAgain[] = "Do you want to attempt to create this floppy again?";
const char szPressEnterOrEsc[]            = "Press Enter to try again or Esc to exit.";

const char szErrorDiskWriteProtected[]    = "Error: Disk write protected\n";
const char szErrorUnknownDiskUnit[]       = "Error: Unknown disk unit\n";
const char szErrorDriveNotReady[]         = "Error: Drive not ready\n";
const char szErrorUnknownCommand[]        = "Error: Unknown command\n";
const char szErrorDataError[]             = "Error: Data error (Bad CRC)\n";
const char szErrorBadRequest[]            = "Error: Bad request structure length\n";
const char szErrorSeekError[]             = "Error: Seek error\n";
const char szErrorMediaTypeNotFound[]     = "Error: Media type not found\n";
const char szErrorSectorNotFound[]        = "Error: Sector not found\n";
const char szErrorWriteFault[]            = "Error: Write fault\n";
const char szErrorGeneralFailure[]        = "Error: General failure\n";
const char szErrorInvalidRequest[]        = "Error: Invalid request or bad command\n";
const char szErrorAddressMarkNotFound[]   = "Error: Address mark not found\n";
const char szErrorDiskWriteFault[]        = "Error: Disk write fault\n";
const char szErrorDmaOverrun[]            = "Error: Direct Memory Access (DMA) overrun\n";
const char szErrorCrcError[]              = "Error: Data read (CRC or ECC) error\n";
const char szErrorControllerFailure[]     = "Error: Controller failure\n";
const char szErrorDiskTimedOut[]          = "Error: Disk timed out or failed to respond\n";
const char szDiskLabel5[]                 = "Windows XP SP1 Setup Disk #5";
const char szDiskLabel6[]                 = "Windows XP SP1 Setup Disk #6";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\makedisk\makedisk.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

#define MAX_DISKS 40


//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;
int cdProduct;


HANDLE hActivateCopyThread, hCopyThreadIsAvailable;
CHAR chCopyThreadSource[ MAX_PATH ], chCopyThreadDestin[ MAX_PATH ];
CHAR chPreviousSource[ MAX_PATH ], chPreviousDestin[ MAX_PATH ];

void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName );
void DoThreadedCopy( LPSTR pszSource, LPSTR pszDestin );
DWORD CopyThread( LPVOID lpvParam );

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== MAKEDISK =============\n")
    PRINT2("Input Layout: %s\n",argv[2])
    PRINT2("Source ID: %s\n",argv[3])
    PRINT2("Compressed Source Path: %s\n",argv[4])
    PRINT2("Uncompressed Source Path: %s\n",argv[5])
    PRINT2("Target directory: %s\n",argv[6])
    PRINT2("CD Directory: %s\n",argv[7])
    PRINT2("Update Only: %s\n",argv[8])
    PRINT2("Show Overflows and Undeflows: %s\n",argv[9])
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("==================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Copy files into disk1, disk2, ... directories.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[logFile] - Path to append a log of actions and errors.\n");
    printf("[InLayout] - Path of Layout which lists files to copy.\n");
    printf("[SourceId] - Specifies the category of files to copy.\n");
    printf("[CompressedPath] - Path of compressed files.\n");
    printf("[UncompressedPath] - Path of uncompressed files.\n");
    printf("[Floppy Dir] - Directory where disk1, disk2, ... dirs should be.\n");
    printf("[CD Dir] - Directory where CD files are stored.\n");
    printf("[Update Only] - U for update files that have changed.  C otherwise.\n");
    printf("[Show Overflows/Underflows] - O to show, N to not show, D for dbg-files.\n\n");
}

int __cdecl DiskDirCompare(const void*,const void*);

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry ee;
    char sourcePath[MAX_PATH];
    char destinPath[MAX_PATH];
    int disks[MAX_DISKS];
    Entry *e;
    char *buf;
    int records,i;
    BOOL shouldCopy;
    BOOL update;
    BOOL bCompressedFile;
    BOOL bShowOverflows;
    BOOL bCopyDbgFiles;
    HANDLE hSource,hDestin, hThread;
    DWORD actualSize,bomSize, dwThreadID;
    WIN32_FIND_DATA fdSource, fdDestin;

    if (argc!=10) {Usage(); return (1);}
    if ((logFile=fopen(argv[1],"a"))==NULL) {
        printf("ERROR Couldn't open log file %s.\n",argv[1]);
        return (1);
    }

    bShowOverflows = (!_stricmp(argv[9],"O"));
    bCopyDbgFiles  = (!_stricmp(argv[9],"D"));

    hActivateCopyThread    = CreateEvent( NULL, FALSE, FALSE, NULL );
    hCopyThreadIsAvailable = CreateEvent( NULL, FALSE, TRUE,  NULL );
    hThread = CreateThread( NULL, 0, CopyThread, NULL, 0, &dwThreadID );
    CloseHandle( hThread );

    Header(argv);

    LoadFile(argv[2],&buf,&e,&records,"ALL");

    if ((argv[7][strlen(argv[7])-1])=='\\') argv[7][strlen(argv[7])-1]='\0';
    if ((argv[6][strlen(argv[6])-1])=='\\') argv[6][strlen(argv[6])-1]='\0';

    //
    // On the cd all files will be on disk 1.  If any files are not
    // on disk 1, this must be the floppies.
    //
    for (cdProduct=1,i=0;i<records;i++)
        if (e[i].disk>1) {
            cdProduct=0;
            break;
        }

    qsort(e,records,sizeof(ee),DiskDirCompare);

    for (i=0;i<MAX_DISKS;i++)
        disks[i]=0;

    for (i=0;i<records;i++) {
        if (e[i].cdpath[strlen(e[i].cdpath)-1]=='\\') e[i].cdpath[strlen(e[i].cdpath)-1]='\0';
        if (e[i].path[strlen(e[i].path)-1]=='\\') e[i].path[strlen(e[i].path)-1]='\0';
        disks[e[i].disk]++;
    }

    update = (_stricmp(argv[8],"u")==0);

    for (i=0;i<records;i++) {
        if (!((records-i)%100))
            printf("INFO Files remaining:%5d/%d\n",records-i,records);
        ee=e[i];

        if (!_stricmp(ee.source,argv[3])) {    // if category matches

/***
        //
        //  It's a compressed file IFF platform is x86 AND
        //  the nocompress flag is NOT set (i.e. null) AND
        //  we're NOT copying dbg-files.
        //

        bCompressedFile = (( ! stricmp( ee.platform, "x86" )) &&
                   ( ! ee.nocompress[ 0 ] ) &&
                   ( ! bCopyDbgFiles ));
***/

            //	It's a compressed file if the nocompress flag is NOT set
            //	and we're NOT copying dbg-files.  That is, we now compress
            //	for all platforms, even RISC.
            //
            bCompressedFile =  !ee.nocompress[0] && !bCopyDbgFiles;

            //printf ( "%s, bCompressedFile = %d\n", ee.name, bCompressedFile );

            //
            // For floppies, force compression unless nocomp
            // has the special value "xfloppy."
            //
            if (!_stricmp(ee.platform,"x86")
                && !cdProduct && !bCompressedFile
                && _strnicmp(ee.nocompress,"xfloppy",7)) {
                bCompressedFile = TRUE;
            }

            if ( bCompressedFile ) {
                strcpy( sourcePath, argv[ 4 ] );    // use compressed path
                bomSize = ee.csize;         // and compressed size
            } else {
                strcpy( sourcePath, argv[ 5 ] );    // uncompressed path
                bomSize = ee.size;          // uncompressed size
            }

            strcat(sourcePath,ee.path);
            strcat(sourcePath,"\\");

            if (bCompressedFile) {

                convertName(ee.name,strchr(sourcePath,0));

            } else if (bCopyDbgFiles) {

                MakeDbgName(ee.name,strchr(sourcePath,0));

            } else {

                strcat( sourcePath, ee.name );
            }

            if (cdProduct || !ee.disk) {

                //
                // File goes on the CD.
                //
                strcpy(destinPath,argv[7]);

                if (!bCopyDbgFiles) {
                    strcat(destinPath,ee.cdpath);
                }

            } else {

                //
                // File goes on a floppy.
                //
                strcpy(destinPath,argv[6]);
                sprintf(&destinPath[strlen(destinPath)],"\\disk%d",ee.disk);
            }

            strcat(destinPath,"\\");

            if (bCopyDbgFiles) {

                MakeDbgName(ee.name,strchr(destinPath,0));

            } else {
                if (ee.medianame[0]) {
                    if (bCompressedFile) {
                        convertName(ee.medianame,strchr(destinPath,0));
                        PRINT2("WARNING: renaming compressed file %s\n",destinPath);
                    } else {
                        strcat( destinPath, ee.medianame );
                    }
                } else {
                    if (bCompressedFile) {
                        convertName(ee.name,strchr(destinPath,0));
                    } else {
                        strcat(destinPath,ee.name);
                    }
                }
            }

            if (disks[ee.disk] > 1) {

                //
                //  Don't attempt to copy same file twice (target file might
                //  not yet completely exist since threaded copy might not be
                //  complete, so can't rely on timestamp equivalence yet).
                //

                if ( _stricmp( sourcePath, chPreviousSource ) ||
                     _stricmp( destinPath, chPreviousDestin )) {

                    hSource=FindFirstFile( sourcePath, &fdSource );

                    if (hSource==INVALID_HANDLE_VALUE) {
                        PRINT2("ERROR Source: %s\n",sourcePath)
                    } else {
                        FindClose( hSource );

                        actualSize = ROUNDUP2( fdSource.nFileSizeLow,
                                               ALLOCATION_UNIT );

                        if ( bShowOverflows ) {
                            if (bomSize<actualSize)
                                fprintf(logFile,"ERROR Overflow %d,%s Size: %d BOM: %d Diff: %d\n",ee.disk,ee.name,actualSize,bomSize,actualSize-bomSize);
                            else if (bomSize>actualSize)
                                fprintf(logFile,"INFO Underflow %d,%s Size: %d BOM: %d Diff: %d\n",ee.disk,ee.name,actualSize,bomSize,actualSize-bomSize);
                        }

                        shouldCopy=TRUE;

                        if (update) {
                            hDestin=FindFirstFile( destinPath, &fdDestin );

                            if (hDestin==INVALID_HANDLE_VALUE) {
                                PRINT2("New file %s\n", destinPath)
                            } else {
                                FindClose( hDestin );

                                if ( CompareFileTime( &fdSource.ftLastWriteTime,&fdDestin.ftLastWriteTime ) <= 0 ) {
                                    shouldCopy=FALSE;
                                } else {
                                    PRINT2("Updating %s\n",destinPath)
                                }

                            }
                        }

                        if (shouldCopy) {
                            DoThreadedCopy( sourcePath, destinPath );
                            strcpy( chPreviousSource, sourcePath );
                            strcpy( chPreviousDestin, destinPath );
                        }
                    }
                }
            } else {
                PRINT3("WARNING Skipped Disk %d, File: %s\n",ee.disk,ee.name)
            }
        }
    }
    fclose(logFile);
    WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );

    return 0;
}


int __cdecl DiskDirCompare(const void *v1, const void *v2)
{
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    //
    // If the files are not on the same disk,
    // the comparison is easy.
    //
    if (e1->disk != e2->disk) {
        return (e1->disk - e2->disk);
    }

    //
    // If this is a cd-rom, sort by location on the cd.
    //
    if (cdProduct) {
        return (_stricmp(e1->cdpath,e2->cdpath));
    }

    //
    // Floppy product: we know the files are on the same disk
    // and files on the floppy are all in the same directory.
    //
    return (0);
}


void DoThreadedCopy( LPSTR pszSource, LPSTR pszDestin ) {
    WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );
    strcpy( chCopyThreadSource, pszSource );
    strcpy( chCopyThreadDestin, pszDestin );
    SetEvent( hActivateCopyThread );
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD CopyThread( LPVOID lpvParam ) {

    BOOL bSuccess;
    UINT i, len;

    for (;;) {

        WaitForSingleObject( hActivateCopyThread, INFINITE );

        bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        if ( ! bSuccess ) {

            SetFileAttributes( chCopyThreadDestin, FILE_ATTRIBUTE_NORMAL );

            len = strlen( chCopyThreadDestin );
            for ( i = 2; i < len; i++ ) {
                if ( chCopyThreadDestin[ i ] == '\\' ) {
                    chCopyThreadDestin[ i ] = '\0';
                    CreateDirectory( chCopyThreadDestin, NULL );
                    chCopyThreadDestin[ i ] = '\\';
                }
            }

            bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        }

        if ( ! bSuccess ) {
            PRINT4( "ERROR Source: %s\n"
                    "      Destin: %s\n"
                    "      GLE=%d\n",
                    chCopyThreadSource,
                    chCopyThreadDestin,
                    GetLastError() )
        }

        SetEvent( hCopyThreadIsAvailable );

    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName ) {

    //
    //  Converts "filename.ext" into "ext\filename.dbg".
    //

    const char *p = strchr( pszSourceName, '.' );

    if ( p != NULL ) {
        strcpy( pszTargetName, p + 1 );             // old extension
        strcat( pszTargetName, "\\" );              // path separator
        strcat( pszTargetName, pszSourceName );         // base name
        strcpy( strchr( pszTargetName, '.' ), ".dbg" );     // new extension
    } else
        strcpy( pszTargetName, pszSourceName );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mbytes\mbytes.c ===
/*

Modifications:

12.05.94	Joe Holman	Created to count max # of bytes in platform product(s).
03.14.95	Joe Holman	Provide #s for local source in Winnt and Winnt32.
xx.xx.95	Joe Holman	Add code to look at value in DOSNET.INF and error
						out if we go over the current value.

Overview:

	tally%platform% values are the # of bytes needed on the machine for 
	all of the system files in their UNCOMPRESSED state. 

	localSrc%platform% values are the # of bytes to copy the compressed
	and uncompressed files to the local source directories for a Winnt or
	Winnt32 operation.

*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;

struct _list {

    char name[15];   // name of file

};
struct _list arrayX86[2000];
struct _list arrayMips[2000];
struct _list arrayAlpha[2000];
struct _list arrayPpc[2000];


//	Tally up the # of bytes required for the system from the files included.
//

long tallyX86,
	tallyMips,
	tallyAlpha,
	tallyPpc;

int	iX86=0, iMips=0, iAlpha=0, iPpc=0;

long localSrcX86=0, localSrcMips=0, localSrcAlpha=0, localSrcPpc=0;




BOOL	NotListedYetX86 ( const char * strName ) {

	int	i;

	for ( i = 0; i < iX86; ++i ) {

		if ( !_stricmp ( arrayX86[i].name, strName ) ) {
			return (FALSE);   // name is already in list.
		}
	}

	sprintf ( arrayX86[iX86].name, "%s", strName );
	++iX86; 
	return (TRUE);	// not previously in list.
}
BOOL	NotListedYetMips ( const char * strName ) {

	int	i;

	for ( i = 0; i < iMips; ++i ) {

		if ( !_stricmp ( arrayMips[i].name, strName ) ) {
			return (FALSE);   // name is already in list.
		}
	}

	sprintf ( arrayMips[iMips].name, "%s", strName );
	++iMips; 

	return (TRUE);	// not previously in list.
}
BOOL	NotListedYetAlpha ( const char * strName ) {

	int	i;

	for ( i = 0; i < iAlpha; ++i ) {

		if ( !_stricmp ( arrayAlpha[i].name, strName ) ) {
			return (FALSE);   // name is already in list.
		}
	}

	sprintf ( arrayAlpha[iAlpha].name, "%s", strName );
	++iAlpha; 

	return (TRUE);	// not previously in list.
}
BOOL	NotListedYetPpc ( const char * strName ) {

	int	i;

	for ( i = 0; i < iPpc; ++i ) {

		if ( !_stricmp ( arrayPpc[i].name, strName ) ) {
			return (FALSE);   // name is already in list.
		}
	}

	sprintf ( arrayPpc[iPpc].name, "%s", strName );
	++iPpc; 


	return (TRUE);	// not previously in list.
}


void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    Msg ("\n=========== MBYTES =============\n");
	Msg("Log file: %s\n", argv[1]);
    Msg("Input BOM: %s\n",argv[2]);
    Msg("Product: %s\n",argv[3]);
    time(&t); 
	Msg("Time: %s",ctime(&t));
    Msg("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Provides # of bytes in product, Workstation or Server.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM layout file to get sizes from.\n");
    printf("[Product] - Product to lay out.\n");
    printf("            NTCD = Workstation on CD\n");
    printf("            LMCD = Server on CD\n");
}

__cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry *e;
    int records,i;
    char *buf;

    if (argc!=4) { 

		Usage(); 
		return(1); 
	}
    if ((logFile=fopen(argv[1],"a"))==NULL) {

    	printf("ERROR Couldn't open log file %s\n",argv[1]);
    	return(1);
    }

    Header(argv);

	//	Get files for product, either Workstation(NTCD) or Server(ASCD).
	//
    LoadFile(argv[2],&buf,&e,&records,argv[3]);

	

/**
	for ( i = 0; i < records; ++i ) {
	
		Msg ( "record #%d,  %s, size=%d, csize=%d, disk=%d\n",
				i, e[i].name, e[i].size, e[i].csize, e[i].disk );
	}	
**/

	//	This adds the number of bytes for x86bins, mipsbins, alphabins,
	//	and ppcbins.
	//	NOTE:  	Some files are listed more than 1 time due to multiple inf 
	//			entries in multiple inf files, so our #s we get a just a tad 
	//			bigger than actual #s.

	for ( i = 0; i < records; ++i ) {

		//	Tally up the bytes.
		//
    	if ( !_stricmp ( e[i].source, "ppcbins" ) ) {

			if ( NotListedYetPpc( e[i].name ) ) {
			
				tallyPpc += e[i].size;

				if ( e[i].nocompress[0] ) {

					localSrcPpc += e[i].size;
				}
				else {

					localSrcPpc += e[i].csize;
				}
			}
		}
    	else if ( !_stricmp ( e[i].source, "x86bins" ) ) {

			if ( NotListedYetX86( e[i].name ) ) {

				tallyX86 += e[i].size;

				if ( e[i].nocompress[0] ) {

					localSrcX86 += e[i].size;
				}
				else {

					localSrcX86 += e[i].csize;
				}
			}
		}
    	else if ( !_stricmp ( e[i].source, "mipsbins" ) ) {
			
			if ( NotListedYetMips( e[i].name ) ) {

				tallyMips += e[i].size;

				if ( e[i].nocompress[0] ) {

					localSrcMips += e[i].size;
				}
				else {

					localSrcMips += e[i].csize;
				}
			}
		}
    	else if ( !_stricmp ( e[i].source, "alphabins" ) ){
			
			if ( NotListedYetAlpha( e[i].name ) ) {

				tallyAlpha += e[i].size;

				if ( e[i].nocompress[0] ) {

					localSrcAlpha += e[i].size;
				}
				else {

					localSrcAlpha += e[i].csize;
				}
			}
		}
		else if ( !_stricmp ( e[i].source, "ppcdbg" )   ||
				  !_stricmp ( e[i].source, "alphadbg" ) ||
				  !_stricmp ( e[i].source, "mipsdbg" )  ||
				  !_stricmp ( e[i].source, "x86dbg" )   ||
				  !_stricmp ( e[i].source, "infs" )        
														) {

			//	Do nothing with these.
		}
		else {

			Msg ( "ERROR:  source = %s\n", e[i].source ); 
		}

	}

	Msg ( "%d X86   files are %ld bytes\n", iX86,  tallyX86 );
	Msg ( "%d Mips  files are %ld bytes\n", iMips, tallyMips );
	Msg ( "%d Alpha files are %ld bytes\n", iAlpha,tallyAlpha );
	Msg ( "%d Ppc   files are %ld bytes\n", iPpc,  tallyPpc );

	Msg ( "\n\n" );

	//	For x86 local sources, add 3M in for the boot floppies, in case
	//	someone does a /b option.
	//
	localSrcX86 += (3*1024*1024);

	//	Add in a fudge factor to help out people with larger cluster
	//	sizes. We'll work with 16K clusters
	//
	localSrcX86   += (16*1024*iX86);
	localSrcMips  += (16*1024*iMips);
	localSrcAlpha += (16*1024*iAlpha);
	localSrcPpc   += (16*1024*iPpc);

	//	Add in a for 20M pagefile we need to reserve for.
	//
	localSrcX86   += (20*1024*1024);
	localSrcMips  += (20*1024*1024);
	localSrcAlpha += (20*1024*1024);
	localSrcPpc   += (20*1024*1024);

	Msg ( "%d X86   local source %ld bytes\n", iX86,  localSrcX86 );
	Msg ( "%d Mips  local source %ld bytes\n", iMips, localSrcMips );
	Msg ( "%d Alpha local source %ld bytes\n", iAlpha,localSrcAlpha );
	Msg ( "%d Ppc   local source %ld bytes\n", iPpc,  localSrcPpc );

    fclose(logFile);
    free(e);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mcopy\mcopy.c ===
/*

Modifications:

01.25.94	Joe Holman		Created to log errs while copying a single file. 



*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    Msg ("\n=========== MCOPY =============\n");
	Msg("Log file: %s\n", argv[1]);
    Msg("SrcFile: %s\n",argv[2]);
    Msg("DstFile: %s\n",argv[3]);
    time(&t); 
	Msg("Time: %s",ctime(&t));
    Msg("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Copies a single file.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[SrcFile] - Path of src file location.\n");
    printf("[DstFile] - Path of dst file location.\n");
}

__cdecl main(int argc, char * argv[] ) {

	BOOL	b;

    if (argc!=4) { 

		Usage(); 
		return(1); 
	}
    if ((logFile=fopen(argv[1],"a"))==NULL) {

    	printf("ERROR Couldn't open log file %s\n",argv[1]);
    	return(1);
    }

    Header(argv);

    SetFileAttributes ( argv[3], FILE_ATTRIBUTE_NORMAL );

	b = CopyFile ( argv[2], argv[3], FALSE );

	if ( !b ) {

		Msg ( "ERROR:  CopyFile ( %s, %s ), gle = %ld\n",
						argv[2], argv[3], GetLastError() );
	}
    else {

        // If no error, set the file attributes to NORMAL.
        //

        if ( !SetFileAttributes ( argv[3], FILE_ATTRIBUTE_NORMAL ) ) {

            Msg ( "ERROR:  SetFileAttributes on %s, gle = %ld\n", argv[3], GetLastError() );
        }
    }

    fclose(logFile);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mcpyfile\snglthrd.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

#define MAX_DISKS 40


//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;
int cdProduct;


//HANDLE hActivateCopyThread, hCopyThreadIsAvailable;
//CHAR chCopyThreadSource[ MAX_PATH ], chCopyThreadDestin[ MAX_PATH ];
//CHAR chPreviousSource[ MAX_PATH ], chPreviousDestin[ MAX_PATH ];

void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName );
void DoFileCopy( LPSTR , LPSTR );
//DWORD CopyThread( LPVOID lpvParam );

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    Msg ("\n=========== MCPYFILE =============\n");
    Msg ("logfile     : %s\n", argv[1] );
    Msg ("Input Layout: %s\n",argv[2]);
    Msg ("category    : %s\n",argv[3]);
    Msg ("Compressed files: %s\n", argv[4]);
    Msg ("Uncompressed files  : %s\n", argv[5]);
    Msg ("Hard drive: %s\n",argv[6]);
    Msg ("Copy d-DBG, x-FLOPPY, c-CDROM files: %s\n", argv[7] );
    time(&t);
    Msg ("Time: %s",ctime(&t));
    Msg ("==================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Copy files to hardrive or into disk1, disk2, ... dirs.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[logFile] - Path to append a log of actions and errors.\n");
    printf("[InLayout] - Path of Layout which lists files to copy.\n");
    printf("[Category] - Specifies the category of files to copy.\n");
	printf("[files share] - location of Compressed files.\n" );
	printf("[files share] - location of Uncompressed files\n" );
    printf("[Harddrive] - Drive where files are stored.\n");
    printf("[copy dbg,floppy,or cd files] - use D for .dbg files or x for floppy files\n" );
}

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry ee;
    char sourcePath[MAX_PATH];
    char destinPath[MAX_PATH];
    int disks[MAX_DISKS];
    Entry *e;
    char *buf;
    int records,i;
    BOOL shouldCopy;
    BOOL bCompressedFile;
    BOOL bCopyDbgFiles;
    HANDLE hSource,hDestin, hThread;
    DWORD actualSize,bomSize, dwThreadID;
    WIN32_FIND_DATA fdSource, fdDestin;

    if ( argc != 8 ) {
		Usage();
		return(1);
	}

    if ((logFile=fopen(argv[1],"a"))==NULL) {

        printf("ERROR Couldn't open log file %s.\n",argv[1]);
        return(1);
    }

//    hActivateCopyThread    = CreateEvent( NULL, FALSE, FALSE, NULL );
//    hCopyThreadIsAvailable = CreateEvent( NULL, FALSE, TRUE,  NULL );
//    hThread = CreateThread( NULL, 0, CopyThread, NULL, 0, &dwThreadID );
//    CloseHandle( hThread );

    Header(argv);

	//	Load all of the current entries in the layout file
	//	provided to the program.
	//
    LoadFile(argv[2],&buf,&e,&records,"ALL");

    cdProduct     = TRUE;
    bCopyDbgFiles = FALSE;
    if ( !_stricmp ( "ntflop", argv[3] ) || !_stricmp ( "lmflop", argv[3] ) ||
		  _stricmp ( argv[7], "x" ) == 0 ) {

        cdProduct = FALSE;
        bCopyDbgFiles = FALSE;

        Msg ( "Making X86 Floppies...\n" );
    }
    else {
        Msg ( "Making CDs...\n" );
        bCopyDbgFiles = !_stricmp( argv[7], "d" );
    }

    Msg ( "bCopyDbgFiles = %d\n", bCopyDbgFiles );

    for (i=0;i<MAX_DISKS;i++) {
    	disks[i]=0;
	}

    for (i=0;i<records;i++) {

        if (e[i].cdpath[strlen(e[i].cdpath)-1]=='\\') {

			e[i].cdpath[strlen(e[i].cdpath)-1]='\0';
		}
        if (e[i].path[strlen(e[i].path)-1]=='\\') {

			e[i].path[strlen(e[i].path)-1]='\0';
		}

        disks[e[i].disk]++;
    }

    for (i=0;i<records;i++) {

    	ee=e[i];

    	if (!_stricmp(ee.source,argv[3])) {    // if category matches

			if ( cdProduct ) {

				//	Making CD.
				//
        		//
        		//  It's a compressed file IFF
        		//  the nocompress flag is NOT set (i.e. null) AND
        		//  we're NOT copying dbg-files.
        		//
        		bCompressedFile = !ee.nocompress[0] && !bCopyDbgFiles;

			}
			else {

				//	Making x86 floppies.
				//
				//	NOTE:  in Layout.C, we go back to the convention of:
				//
				//			""  == yes, compress this file
				//			"x" == no don't compress this file
				//
				bCompressedFile = _stricmp(ee.nocompress, "x" );

				//Msg ( "%s, bCompressedFile = %d\n", ee.name, bCompressedFile );

			}


//Msg ( "bCompressedFile = %d, %s\n", bCompressedFile, ee.name );

        	if ( bCompressedFile ) {
        		strcpy( sourcePath, argv[ 4 ] );    // use compressed path
        		bomSize = ee.csize;         // and compressed size
        	}
        	else {
        		strcpy( sourcePath, argv[ 5 ] );    // uncompressed path
        		bomSize = ee.size;          // uncompressed size
        	}

        	strcat(sourcePath,ee.path);
        	strcat(sourcePath,"\\");

        	if ( bCompressedFile ) {
        		convertName( ee.name, strchr( sourcePath, 0 ));
			}
        	else if ( bCopyDbgFiles ) {
        		MakeDbgName( ee.name, strchr( sourcePath, 0 ));
			}
        	else {
        		strcat( sourcePath, ee.name );
			}


        	if ( cdProduct ) {
        		strcpy(destinPath,argv[6]);
        		if ( ! bCopyDbgFiles ) {
            		strcat(destinPath,ee.cdpath);
				}
            }
            else {
                strcpy(destinPath,argv[6]);
        		sprintf(&destinPath[strlen(destinPath)],"\\disk%d",ee.disk);
            }

        	strcat(destinPath,"\\");

        	if ( bCopyDbgFiles ) {
        		MakeDbgName( ee.name, strchr( destinPath, 0 ));
			}
        	else {
        		if (ee.medianame[0]) {
            		if ( bCompressedFile ) {
            			convertName( ee.medianame, strchr( destinPath, 0 ));

						//	For simplification in the BOM, we no longer
						//	rename compressed files. I.E, any file that has
						//	to be renamed, CANNOT be compressed.
						//
            			Msg ( "ERROR: renaming compressed file not supported:  %s\n",
                					destinPath );
            		}
            		else {
            			strcat( destinPath, ee.medianame );
					}
        		}
        		else {
            		if ( bCompressedFile ) {
            			convertName( ee.name, strchr( destinPath, 0 ));
					}
            		else {
            			strcat( destinPath, ee.name );
					}
        		}
        	}

            if (disks[ee.disk]>1) {

                hSource=FindFirstFile( sourcePath, &fdSource );

                if (hSource==INVALID_HANDLE_VALUE) {
                    Msg ("ERROR Source: %s\n",sourcePath);
				}
                else {

                    FindClose( hSource );  // close the source up.

					if ( !cdProduct ) {
            			actualSize = ROUNDUP2( fdSource.nFileSizeLow,
                           								DMF_ALLOCATION_UNIT );
					}
					else {
            			actualSize = ROUNDUP2( fdSource.nFileSizeLow,
                           								ALLOCATION_UNIT );
					}

                    //  Check the size of the file vs. the size in the 
                    //  bom just for a verification of file sizes.
                    //  Don't do this for Dbg files, since these sizes are
                    //  never put in the layout.
                    //
                    if ( !bCopyDbgFiles && (bomSize < actualSize) ) {
                           Msg ( "ERROR:  disk#%d, %s Size of file: %d > BOM: %d Diff: %d\n",
							ee.disk,ee.name,
							actualSize,bomSize,actualSize-bomSize);
					}

                    hDestin=FindFirstFile( destinPath, &fdDestin );

                    if (hDestin==INVALID_HANDLE_VALUE) {

                        //  File doesn't exist, must copy it now.
                        //
                        //  Msg ("New file %s\n", destinPath);
                        DoFileCopy ( sourcePath, destinPath );
                    }
                    else {

                        //  File exists, but let's check the time stamp
                        //  to see if the source is newer.
                        //

                        FindClose( hDestin ); // close the destination

                		if ( CompareFileTime( 
                                    &fdSource.ftLastWriteTime,
                              		&fdDestin.ftLastWriteTime ) > 0 ) {

                            //  The source IS newer, copy the new file NOW. 
                            DoFileCopy ( sourcePath, destinPath );

						}

                    }

                }
        	}
            else {
                Msg ("WARNING Skipped Disk %d, File: %s\n",ee.disk,ee.name);
            }
    	}
    }
    fclose(logFile);
    Header(argv);
    //WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );
}


/**
void DoThreadedCopy( LPSTR pszSource, LPSTR pszDestin ) {
    WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );
    strcpy( chCopyThreadSource, pszSource );
    strcpy( chCopyThreadDestin, pszDestin );
    SetEvent( hActivateCopyThread );
    }

***/

void DoFileCopy ( LPSTR chCopyThreadSource, LPSTR chCopyThreadDestin ) {

    BOOL bSuccess;
    UINT i, len;

    Msg ( "Copy:  %s >>> %s\n", chCopyThreadSource, chCopyThreadDestin );

    bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

    if ( ! bSuccess ) {

        SetFileAttributes( chCopyThreadDestin, FILE_ATTRIBUTE_NORMAL );

        len = strlen( chCopyThreadDestin );
        for ( i = 2; i < len; i++ ) {
            if ( chCopyThreadDestin[ i ] == '\\' ) {
                chCopyThreadDestin[ i ] = '\0';
                CreateDirectory( chCopyThreadDestin, NULL );
                chCopyThreadDestin[ i ] = '\\';
            }
        }

        bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

    }

    if ( ! bSuccess ) {
        	Msg (   "ERROR Source: %s\n"
                    "      Destin: %s\n"
                    "      GLE=%d\n",
                    chCopyThreadSource,
                    chCopyThreadDestin,
                    GetLastError() );
    }

}

/****

DWORD CopyThread( LPVOID lpvParam ) {

    BOOL bSuccess;
    UINT i, len;

    for(;;) {

    WaitForSingleObject( hActivateCopyThread, INFINITE );

    bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        if ( ! bSuccess ) {

        SetFileAttributes( chCopyThreadDestin, FILE_ATTRIBUTE_NORMAL );

        len = strlen( chCopyThreadDestin );
        for ( i = 2; i < len; i++ ) {
        if ( chCopyThreadDestin[ i ] == '\\' ) {
            chCopyThreadDestin[ i ] = '\0';
            CreateDirectory( chCopyThreadDestin, NULL );
            chCopyThreadDestin[ i ] = '\\';
            }
        }

        bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        }

        if ( ! bSuccess ) {
        	Msg (   "ERROR Source: %s\n"
                    "      Destin: %s\n"
                    "      GLE=%d\n",
                    chCopyThreadSource,
                    chCopyThreadDestin,
                    GetLastError() );
        }

    SetEvent( hCopyThreadIsAvailable );

    }

    return 0;

    }

***/


void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName ) {

    //
    //  Converts "filename.ext" into "ext\filename.dbg".
    //

    const char *p = strchr( pszSourceName, '.' );

    if ( p != NULL ) {
        strcpy( pszTargetName, p + 1 );                 // old extension
        strcat( pszTargetName, "\\" );                  // path separator
        strcat( pszTargetName, pszSourceName );         // base name
        strcpy( strchr( pszTargetName, '.' ), ".dbg" ); // new extension
    }
    else {
        strcpy( pszTargetName, pszSourceName );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\msize\msize.c ===
//
//	05.10.94	Joe Holman	Get compressed and nocompressed sizes for files
//							in the product via a bom.	
//  08.12.94    Joe Holman  Add code to get PPC files paths.
//	01.16.95	Joe Holman	If get error finding file, still round-up to DMF
//							allocation unit.
//
//


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

//	Tally up the # of bytes required for the system from the files included.
//

long tallyX86Compressed,
	tallyX86Uncompress,
	tallyMipsCompressed,
	tallyMipsUncompress,
	tallyAlphaCompressed,
	tallyAlphaUncompress,
	tallyPpcCompressed,
	tallyPpcUncompress;

//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}


void Header(argv,argc)
char* argv[];
int argc;
{
    time_t t;

    Msg ("\n=========== MSIZE =============\n");
	Msg ("Log file : %s\n", argv[1]);
    Msg ("Input BOM: %s\n", argv[2]);
    Msg ("Category : %s\n", argv[3]);
    Msg ("x86 Uncompressed files: %s\n", argv[4]);
    Msg ("x86 Compressed files  : %s\n", argv[5]);
    Msg ("mips Uncompressed files: %s\n", argv[6]);
    Msg ("mips Compressed files  : %s\n", argv[7]);
    Msg ("alpha Uncompressed files: %s\n", argv[8]);
    Msg ("alpha Compressed files  : %s\n", argv[9]);
    Msg ("x86 dbg files  : %s\n",          argv[10]);
    Msg ("mips dbg files: %s\n",           argv[11]);
    Msg ("alpha dbg files  : %s\n",        argv[12]);

    Msg ("ppc uncompressed files  : %s\n",  argv[13]);
    Msg ("ppc compressed files: %s\n",      argv[14]);
    Msg ("ppc dbg files  : %s\n",           argv[15]);

    time(&t); 
	Msg ("Time: %s",ctime(&t));
    Msg ("==============================\n\n");
}

void Usage()
{
    printf("PURPOSE: Fills in the correct sizes for files in the BOM.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM which lists files whose sizes are to be updated.\n");
    printf("[Category] - Specifies the category of files whose sizes are updated.\n");
	printf("[files share] - location of x86 uncompressed files.\n" );
	printf("[files share] - location of x86 compressed files\n" );
	printf("[files share] - location of mips uncompressed files.\n" );
	printf("[files share] - location of mips compressed files\n" );
	printf("[files share] - location of alpha uncompressed files.\n" );
	printf("[files share] - location of alpha compressed files\n" );
	printf("[dbg share] - location of x86 dbg files\n" );
	printf("[dbg share] - location of mips dbg files.\n" );
	printf("[dbg share] - location of alpha dbg files\n" );

	printf("[files share] - location of ppc uncompressed files\n" );
	printf("[files share] - location of ppc compressed files.\n" );
	printf("[dbg share] - location of ppc dbg files\n" );
    printf("\n");
}

#define PATH_X86        0
#define PATH_MIPS       1
#define PATH_ALPHA      2
#define PATH_X86_DBG    3
#define PATH_MIPS_DBG   4
#define PATH_ALPHA_DBG  5
#define PATH_PPC        6
#define PATH_PPC_DBG    7
#define PATH_ERROR     -1 


int DetermineLocation ( const char * source, const char * path,
                        const char * name, int i ) {

    if ( !_stricmp ( source, "ppcbins" ) ) {

        return PATH_PPC;
    } 
    if ( !_stricmp ( source, "ppcdbg" ) ) {

        return PATH_PPC_DBG;
    } 

    if ( !_stricmp ( source, "x86bins" ) ) {

        return PATH_X86;
    } 

    if ( !_stricmp ( source, "mipsbins" ) ) {

        return PATH_MIPS;
    } 

    if ( !_stricmp ( source, "alphabins" ) ) {

        return PATH_ALPHA;
    } 

    if ( !_stricmp ( source, "x86dbg" ) ) {

        return PATH_X86_DBG;
    } 

    if ( !_stricmp ( source, "mipsdbg" ) ) {

        return PATH_MIPS_DBG;
    } 

    if ( !_stricmp ( source, "alphadbg" ) ) {

        return PATH_ALPHA_DBG;
    } 

    if ( !_stricmp ( source, "infs" ) ) {

        if ( !_stricmp( path, "\\mips" ) ) {

            return PATH_MIPS;
        }
        if ( !_stricmp( path, "\\alpha" ) ) {

            return PATH_ALPHA;
        }

        return PATH_X86;    // infs are generally the same same for each 
                            // platform
    } 

    Msg ( "DetermineLocation: ERROR unknown source: source=%s, path=%s, name=%s, i=%d\n", 
                    source, path, name, i );

    return (PATH_ERROR); 
}

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *tempFile;
    Entry* e;
    HANDLE h;
    char tempName[MAX_PATH];
    int records, i, result;
    char* buf;
    WIN32_FIND_DATA fd;

    srand((unsigned)time(NULL));

    if ( argc != 16 ) { 
		Usage(); 
		return(1); 
	}

    if ((logFile=fopen(argv[1],"a"))==NULL) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }

    Header(argv,argc);

    tempName[0]='\0';
    sprintf(tempName,"%d.000",rand());

    if (MyOpenFile(&tempFile,tempName,"wb")) {
		return(1);
	}
    
    result = fseek ( tempFile, SEEK_SET, 0 );
    if (result) {
        printf("ERROR Unable to seek beginning of file: %s\n", tempName);
        return(1);
    }

    if (!_stricmp(argv[3],"NTFLOP") ||
		!_stricmp(argv[3],"LMFLOP") ||
		!_stricmp(argv[3],"NTCD")   ||
		!_stricmp(argv[3],"LMCD")) {

        Msg ( "Loading records:  %s\n", argv[3] ); 
		LoadFile(argv[2],&buf,&e,&records,argv[3]);
	}
    else {
        //Msg ( "Loading records:  %s\n", "ALL" ); 
		//LoadFile(argv[2],&buf,&e,&records,"ALL");
        Msg ( "ERROR: for media generation, we don't need to load ALL\n" );
        return (1);
	}


	//	Show the records just loaded in.
	//
	Msg ( "# records just loaded = %d\n", records );

/**
	for ( i = 0; i < records; ++i ) {
	
		Msg ( "record #%d,  %s, size=%d, csize=%d, disk=%d, source=%s\n", 
				i, e[i].name, e[i].size, e[i].csize, e[i].disk, e[i].source );
	}	
**/

	//	Set the tally counts to zero.
	//
	tallyX86Compressed = 0;
	tallyX86Uncompress = 0;
	tallyMipsCompressed = 0;
	tallyMipsUncompress = 0;
	tallyAlphaCompressed = 0;
	tallyAlphaUncompress = 0;
	tallyPpcCompressed = 0;
	tallyPpcUncompress = 0;
	

	for ( i = 0; i < records; ++i ) {

		char	filePathU[200]; // uncompressed
        char    filePathC[200]; // compressed
        int     location;

        //  Determine what path to use.
        //
        //  argv[4] - uncompress x86
        //  argv[5] - compressed x86
        //  argv[6] - uncompress mips 
        //  argv[7] - compressed mips 
        //  argv[8] - uncompress alpha 
        //  argv[9] - compressed alpha 
        //  argv[10] - x86 dbg
        //  argv[11] - mips dbg
        //  argv[12] - alpha dbg
        //  argv[13] - uncompress ppc
        //  argv[14] - compressed ppc
        //  argv[15] - ppc dbg
        //
        switch ( location = DetermineLocation ( e[i].source, e[i].path, e[i].name, i ) ) {

            case PATH_PPC :

		                sprintf ( filePathU, "%s\\%s", argv[13], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[14] );
                        break;


            case PATH_X86 :

		                sprintf ( filePathU, "%s\\%s", argv[4], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[5] );
                        break;


            case PATH_MIPS :

		                sprintf ( filePathU, "%s\\%s", argv[6], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[7] );
                        break;

            case PATH_ALPHA :

		                sprintf ( filePathU, "%s\\%s", argv[8], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[9] );
                        break;

            case PATH_PPC_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[15], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[15], e[i].path, e[i].name);
               break;

            case PATH_X86_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[10], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[10], e[i].path, e[i].name);
               break;


            case PATH_MIPS_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[11], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[11], e[i].path, e[i].name);
               break;

            case PATH_ALPHA_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[12], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[12], e[i].path, e[i].name);
               break;

            default :

               sprintf ( filePathU, "%s", "ERROR path" );
               sprintf ( filePathC, "%s", "ERROR path" );
               Msg ( "ERROR: should never get here...\n" );
               break;
        }

		//	Get the UNCOMPRESSED size.
		//

        h = FindFirstFile( filePathU, &fd );

        if ( h == INVALID_HANDLE_VALUE ) {
			Msg ( "ERROR finding:  %s, gle=%d\n", filePathU,GetLastError() );
			fd.nFileSizeLow = 1;  // just make one DMF unit
		}
        else {
            FindClose( h );
        }
		e[i].size = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );

        if ( location == PATH_X86_DBG   ||
             location == PATH_MIPS_DBG  || 
             location == PATH_ALPHA_DBG ||
             location == PATH_PPC_DBG      ) {

            //  DBG files are NOT compressed. So just fill in the
            //  size.
            //

            e[i].csize = e[i].size;

            goto SKIP_COMPRESSED;
        } 

		//	Get the COMPRESSED size.
		//
		convertName( e[i].name, strchr( filePathC, 0 ));

        h = FindFirstFile( filePathC, &fd );

        if ( h == INVALID_HANDLE_VALUE ) {
			Msg ( "ERROR finding:  %s, gle=%d\n", filePathC, GetLastError() );
			fd.nFileSizeLow = 1;  // just make one DMF unit
		}
        else {
            FindClose( h );
        }
		e[i].csize = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );

SKIP_COMPRESSED:;

		//	If source grouping is INFS
		//	adjust sizes accordingly now. 
		//
		if ( !_stricmp ( "INFS", e[i].source ) ) {

#define INF_FUDGE 2048 // should be at least 2048 bytes. 

		    e[i].csize += INF_FUDGE;
			e[i].csize = ROUNDUP2( e[i].csize, DMF_ALLOCATION_UNIT );
			e[i].size  += INF_FUDGE;
			e[i].size  = ROUNDUP2( e[i].size, DMF_ALLOCATION_UNIT );

			Msg ( "%s INF file, fudge size up by %d bytes...\n",
						e[i].name, INF_FUDGE ); 
		}


		//	Tally up the bytes.
		//
		switch ( location ) {

			case PATH_X86 :
				tallyX86Compressed += e[i].csize;
				tallyX86Uncompress += e[i].size;
				break;
			case PATH_MIPS :
				tallyMipsCompressed += e[i].csize;
				tallyMipsUncompress += e[i].size;
				break;
			case PATH_ALPHA :
				tallyAlphaCompressed += e[i].csize;
				tallyAlphaUncompress += e[i].size;
				break;
			case PATH_PPC :
				tallyPpcCompressed += e[i].csize;
				tallyPpcUncompress += e[i].size;
				break;
			default :
				break;
		}

/**
		Msg ( "%s, %s, size = %d, csize = %d\n%s\n%s\n", 
							e[i].name, e[i].source, e[i].size, e[i].csize,
                    filePathU, filePathC );
**/

	}

    //	Print all the records back to the tempFile.
    //	Put the informative header back into the file as the first line.
	//
    i=0; while ((fputc(buf[i++],tempFile))!='\n');

    for ( i = 0; i < records; ++i ) {

	   	EntryPrint(&e[i],tempFile);
/**		
		Msg ( "EntryPrint: #%d,  %s, size=%d, csize=%d, disk=%d,source=%s\n", 
			i, e[i].name, e[i].size, e[i].csize, e[i].disk, e[i].source );
**/
    }

    fclose(logFile);
    fclose(tempFile);
    free(buf);
    free(e);

    if (!CopyFile(tempName,argv[2],FALSE)) {
		Msg ("ERROR Couldn't copy %s to %s\n",tempName,argv[2]);
		Msg ( "CopyFile GLE=%ld leaving temp file for investigation...\n", 
					GetLastError() );
    }
	else {
    	DeleteFile(tempName);
	}


	//	Give tally counts.
	//
	Msg ( "tallyX86Compressed = %ld\n", tallyX86Compressed );
	Msg ( "tallyX86Uncompressed = %ld\n", tallyX86Uncompress );
	Msg ( "tallyMipsCompressed = %ld\n", tallyMipsCompressed );
	Msg ( "tallyMipsUncompressed = %ld\n", tallyMipsUncompress );
	Msg ( "tallyAlphaCompressed = %ld\n", tallyAlphaCompressed );
	Msg ( "tallyAlphaUncompressed = %ld\n", tallyAlphaUncompress );
	Msg ( "tallyPpcCompressed = %ld\n", tallyPpcCompressed );
	Msg ( "tallyPpcUncompressed = %ld\n", tallyPpcUncompress );


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mlayout\mlayout.c ===
/*

Modifications:

01.10.94    Joe Holman  Added DISK_TO_START_NUMBERING_AT because
                we now have 2 bootdisks, thus we to start
                making floppies on disk # 3.
01.11.94    Joe Holman  Change value back to 2.
05.05.94	Joe Holman	Change # to 1.
06.10.94	Joe Holman	Made CD specific changes.
07.21.94	Joe Holman	Added code to check for textmode/gui-mode disk swaps.


*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

FILE* logFile;
char* product;
int useCdPath;

BOOL    bAssigned[15000];   // should put this in Entry struct after Beta.

struct _list {

    char name[15];   // name of file
    int size;
    int csize;
    int disk;
    int priority;
    char nocompress[15];

};
struct _list fileList[15000];
int numFiles;
int    totalCompressed=0;
int    totalUnCompressed=0;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== MLAYOUT =============\n")
    PRINT2("Input BOM: %s\n",argv[2])
    PRINT2("Output Layout: %s\n",argv[3])
    PRINT2("Product: %s\n",argv[4])
    PRINT2("Floppy Size: %s\n",argv[5])
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Assigns files to disks and generates a layout file.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM for which a layout is to be made.\n");
    printf("[OutLayout] - Path of new layout.\n");
    printf("[Product] - Product to lay out.\n");
    printf("            NTFLOP = Windows NT on floppy\n");
    printf("            LMFLOP = Lan Manager on floppy\n");
    printf("            NTCD = Windows NT on CD\n");
    printf("            LMCD = Lan Manager on CD\n");
    printf("            SDK = Software Development Kit\n");
    printf("[FloppySize] - Size in bytes of the second disk.\n\n");
}

int __cdecl PrioritySizeNameCompare(const void*,const void*);

int Same(e1,e2)
Entry* e1;
Entry* e2;
{
    char *p1, *p2;

    if (useCdPath)
    {
    p1=e1->cdpath;
    p2=e2->cdpath;
    }
    else
    {
    p1="x";
    p2=p1;
    }

    return( (!_stricmp(e1->name,e2->name)) &&
        (!_stricmp(e1->path,e2->path)) &&
        (!_stricmp(e1->source,e2->source)) &&
        (!_stricmp(p1,p2)));
}

BOOL    FindFile ( char * name ) {

    int i;

    for ( i = 0; i < numFiles; ++i ) {

        if ( _stricmp ( name, fileList[i].name ) == 0 ) {

            return TRUE;    // found the file in the file list
        }

    }

    return FALSE;   // did NOT find the file in the file list.

}

void    AddFileToList ( char * name,
                        int size,
                        int csize,
                        int disk,
                        int priority,
                        char * nocompress ) {

    sprintf ( fileList[numFiles].name, "%s", name );
    fileList[numFiles].size  = size;
    fileList[numFiles].csize = csize;
    fileList[numFiles].disk  = disk;
    fileList[numFiles].priority = priority;
    sprintf ( fileList[numFiles].nocompress, "%s", nocompress );

    totalUnCompressed += fileList[numFiles].size;
    totalCompressed   += fileList[numFiles].csize;

    //Msg ( "totalUncomp = %d, size = %d,totalComp = %d, csize = %d\n", totalUnCompressed, fileList[numFiles].size, totalCompressed, fileList[numFiles].csize );

    if ( fileList[numFiles].size < fileList[numFiles].csize ) {

        Msg ( "ER: %s compressed bigger than uncomp\n", fileList[numFiles].name );
    }

    ++numFiles;


}

//	MakeEntries figures out if a file's name is already in the list of
//	files to layout.  The end result is a list of files, with no duplicates.
//	
void    MakeEntries ( Entry * e, int records ) {


    int i;
    BOOL    bInList;

    int numFiles = 0;

    for ( i = 0; i < records; i++ ) {

        bInList = FindFile ( e[i].name );

        if ( !bInList ) {

            AddFileToList ( e[i].name,
                            e[i].size,
                            e[i].csize,
                            e[i].disk,
                            e[i].priority,
                            e[i].nocompress );
        }
    }

}
void    ShowEntriesAll ( int records, Entry * e ) {

    int i;

	Msg ( "\n\n\nShowEntriesAll - show each of the %d file(s) and where it lays...\n\n", records );

    for ( i = 0; i < records; ++i ) {

        Msg ( "%s,%d,%s,nocomp=%d,comp=%d,priority=%d,disk=%d,%s\n",
                                    e[i].name,
                                    i,
                                    e[i].platform,
                                    e[i].size,
                                    e[i].csize,
                                    e[i].priority,
                                    e[i].disk,
                                    e[i].nocompress );

    }
}
void    ShowEntries ( void ) {

    int i;

    totalCompressed=0;
    totalUnCompressed=0;

    for ( i = 0; i < numFiles; ++i ) {

        Msg ( "#%d\t%s,nocomp=%d,comp=%d,priority=%d,disk=%d,%s\n",
                                    i,
                                    fileList[i].name,
                                    fileList[i].size,
                                    fileList[i].csize,
                                    fileList[i].priority,
                                    fileList[i].disk,
                                    fileList[i].nocompress );

        totalCompressed+=fileList[i].csize;
        totalUnCompressed+=fileList[i].size;
    }

    Msg ( "totalCompressed = %d, totalUnCompressed = %d\n\n\n",
        totalCompressed, totalUnCompressed );

}

//
//  Returns TRUE if a file hasn't been assigned a disk #, ie. 0.
//  Returns FALSE if all have been assigned.
//
BOOL    FileUnAssigned ( void ) {

    int i;

    for ( i = 0; i < numFiles; ++i ) {

        if ( fileList[i].disk == 0 ) {

            return TRUE;
        }

    }

    return FALSE;

}

void    StuffDiskNumIntoRecords ( int records, Entry * e ) {

    int i, j;

	//	Verify that all entries in the list have a disk # assigned to them.
	//
	Msg ( "\n\n\nVerifying fileList assignments...\n\n" );
	for ( i = 0; i < numFiles; ++i ) {

		if ( fileList[i].disk < 1 ) {

			Msg ( "ERROR:  fileList %s >>> has not been assigned a disk...\n",
				fileList[i].name );
		}
	}

	Msg ( "\n\n\nAssigning fileList #s to record #s...\n\n" );
    for ( i = 0; i < records; ++i ) {

        for ( j = 0; j < numFiles; ++j ) {

            if ( _stricmp ( fileList[j].name, e[i].name ) == 0 ) {

                e[i].disk = fileList[j].disk;

                //Msg ( "disk assignment for:  %s  #%d\n", e[i].name, e[i].disk );

            }

        }

    }

	//	Verify that all entries now have a disk # assigned to them.
	//
	for ( i = 0; i < records; ++i ) {

		if ( e[i].disk < 1 ) {

			Msg ( "ERROR:  %s >>> has not been assigned to a disk...\n",
				e[i].name );
		}
	}

}

void LayoutAssignDisks(e,diskSize,records)
Entry* e;
int diskSize;
int records;
{

    //
    // Files must always start at disk 1.
    //
    #define DISK_TO_START_NUMBERING_AT 1
    #define CD_TO_START_NUMBERING_AT 1

    int disk=DISK_TO_START_NUMBERING_AT;
    int freeSpace, i;
    int workingPriority = 0;
	int	firstGuiModeDisk = 666;

#define DMF_CLUSTER_FILES	32

	//	For DMF, every DMF_CLUSTER_FILES files increases the DMF table by 1 cluster, ie. 2K.
	//
	int	iNumFiles = 1;

    //
    //  Make a entry for each unique file for the product.
    //	This reduces multiple entries in e due to multiple lines of inf
	//	information.
	//
    MakeEntries ( e, records );
    //ShowEntries ( );

    //  Priority values can be from 1-1000;
    //

#define FAT_TABLE_GROWTH_FUDGE	2*512	// 1K of extra space.	

    do {

        //  Free space left to begin with is the disk size.
        //
	    freeSpace = diskSize - FAT_TABLE_GROWTH_FUDGE;

		Msg ( "\n\n\n\n\nInitial Disk #%d freeSpace = %d\n", disk, freeSpace );

        //  First, find all the files that
        //  are HARDCODED to go on this disk.
        //
        //
        Msg ( "\n\n\nAnalyze HARDCODED disk #s...\n\n" );
	    for ( i=0; i < numFiles; i++) {

	        if ( fileList[i].disk == disk ) {

		        if ( fileList[i].nocompress[0] == 'x' ||
                     fileList[i].nocompress[0] == 'X'    ) {

		            freeSpace -= fileList[i].size;

					Msg ( "freeSpace(nocomp) = %d, %d, %s, disk #%d, prio = %d, iNumFiles = %d\n",
                                freeSpace,
                                fileList[i].size,
                                fileList[i].name, disk, fileList[i].priority,
								iNumFiles );

                }
                else {

		            freeSpace -= fileList[i].csize;

					Msg ( "freeSpace(comp) = %d, %d, %s, disk #%d, prio = %d, iNumFiles = %d\n",
                                freeSpace,
                                fileList[i].csize, fileList[i].name, disk, fileList[i].priority, iNumFiles );
                }

				++iNumFiles;	// assigned a file.
				if ( iNumFiles % DMF_CLUSTER_FILES == 0 ) {

					freeSpace -=
								(DMF_ALLOCATION_UNIT+DMF_ALLOCATION_UNIT);
					Msg ( "WARNING: getting ready for %d more files, DMF_CLUSTER_FILES, freeSpace = %d, iNumFiles=%d\n",
													freeSpace, iNumFiles);
				}
            }
        }

        //  We have a big problem if our freespace is less than 0.
        //  I.E, too many disks have HARDCODED disk # for this disk.
        //
        if ( freeSpace < 0 ) {

            Msg ( "ERROR:  disk #%d freeSpace = %d\n", disk, freeSpace );
            Msg ( ">>>> Too many files with HARDCODED disk #%d\n", disk);
        }

#define NOT_ASSIGNED_YET 0
#define MAX_GROUPING_NUM 999	// > 999, ie. 1000+ means don't put on floppy.

        //  Now let's deal with the PRIORITY.
        //
        Msg ( "\n\n\nAnalyze GROUPINGS...\n\n" );

        workingPriority = 0;

        do {

            for ( i = 0; i < numFiles; ++i ) {

                int fileSize;

                if ( fileList[i].disk == NOT_ASSIGNED_YET ) {


		            if ( fileList[i].nocompress[0] == 'x' ||
                         fileList[i].nocompress[0] == 'X'    ) {

                        fileSize = fileList[i].size;
                    }
                    else {
                        fileSize = fileList[i].csize;
                    }

					//	Verify that the file size
					//	is on a sector boundary.
					//
					if ( (fileSize % DMF_ALLOCATION_UNIT) != 0 ) {
						Msg ( "ERROR:  %s, size isn't on DMF_A_U boundary %d\n",
									fileList[i].name, fileSize );
					}

                    if ( fileList[i].priority <= workingPriority &&
                         (freeSpace-fileSize > 0)
					   )  {

                        freeSpace -= fileSize;
                        fileList[i].disk = disk;


					    Msg ( "freespace(%s) = %d, %s, disk #%d, SIZE=%d, priority = %d, csize=%d,size=%d, iNumFiles = %d\n",
                                (_stricmp(fileList[i].nocompress,"x")) ? "comp" : "nocomp",
                                freeSpace,
                                fileList[i].name, disk, fileSize,
								workingPriority,
                                fileList[i].csize, fileList[i].size, iNumFiles );

						++iNumFiles;
						if ( iNumFiles % DMF_CLUSTER_FILES == 0 ) {

							freeSpace -=
								(DMF_ALLOCATION_UNIT+DMF_ALLOCATION_UNIT);
							Msg ( "WARNING:  getting ready for %d more files, DMF_CLUSTER_FILES, freeSpace = %d, iNumFiles=%d\n",
													freeSpace, iNumFiles);
						}
                    }

                }

            }

            ++workingPriority;

            if ( workingPriority > MAX_GROUPING_NUM ) {

                break;
            }

/**
            Msg ( "workingPriority = %d, freeSpace = %d, disk = %d\n",
                    workingPriority, freeSpace, disk );
**/

        } while ( (freeSpace > 0) && FileUnAssigned() );

        Msg ( "Disk %d Excess Space:  %d\n", disk, freeSpace );

		//	Increment the disk #.
		//	Reset the num of files for the cluster information.
		//
        ++disk;
		iNumFiles = 1;

    } while ( FileUnAssigned() );

    //ShowEntriesAll ( records, e );
    StuffDiskNumIntoRecords ( records, e );

	//	Let's verify that no files are off the textmode/gui mode boundry 
	//	disk.
	//

#define FIRST_GUI_MODE_PRIORITY_VALUE	60

	//	Step #1.  Find the floppy with the last textmode file.
	//
	Msg ( "firstGuiModeDisk:  %d\n", firstGuiModeDisk );

    for ( i = 0; i < records; ++i ) {

		if ( e[i].priority >= FIRST_GUI_MODE_PRIORITY_VALUE ) { 

			if ( e[i].disk < firstGuiModeDisk ) {

				firstGuiModeDisk = e[i].disk;

				Msg ( "firstGuiModeDisk:  %d (%s,%d)\n", firstGuiModeDisk,
									e[i].name, e[i].disk );
			}

		}

	}

	//	Step #2.  Just verify that no textmode files are on any disk
	//	above 'firstGuiModeDisk'.

	for ( i = 0; i < records; ++i ) {

		if ( e[i].priority < FIRST_GUI_MODE_PRIORITY_VALUE &&
			 e[i].disk     > firstGuiModeDisk &&
			 e[i].priority != 0 /* value used if file is HARDCODED on disk*/ ) {

			Msg ( "ERROR:  We have a disk swap:  %d, %d, %s\n", e[i].priority,
														    e[i].disk,
															e[i].name );

		}

	}

}

void LayoutAssignCD(e,diskSize,records)
Entry* e;
int diskSize;
int records;
{

    int freeSpace, i;
    int fileSize;


/***
    //
    //  Make a entry for each unique file for the product.
    //	This reduces multiple entries in e due to multiple lines of inf
	//	information.
	//
    MakeEntries ( e, records );
**/

    //  For CDs, we need to work with each entry in the expanded BOM.
    //
    //ShowEntriesAll ( records, e );


    //  Free space left to begin with is the disk size.
    //
	freeSpace = diskSize;

	Msg ( "\nInitial CD freeSpace = %d\n", freeSpace );

	for ( i=0; i < records; i++) {

	    if ( e[i].nocompress[0] == 'x' ||
             e[i].nocompress[0] == 'X'    ) {

             fileSize = e[i].size;
        }
        else {
             fileSize = e[i].csize;
        }

        freeSpace -= fileSize;

        //  Force all files on CD to be on disk CD_TO...
        //
        e[i].disk = CD_TO_START_NUMBERING_AT;

        if ( freeSpace < 0 ) {

            Msg ( "ERROR:  freeSpace = %d, diskSize = %d\n",
                                freeSpace, diskSize );
        }
        else {

             //Msg ( "%d, %s\n", freeSpace, e[i].name );
        }
     }

    Msg ( "Excess Space:  %d\n", freeSpace );

    //ShowEntriesAll ( records, e );


}

__cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *outLayout;
    Entry *e;
    int records,i,result;
    char *buf;

    if (argc!=6) { Usage(); return(1); }
    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
    printf("ERROR Couldn't open log file %s\n",argv[1]);
    return(1);
    }
    Header(argv);
    LoadFile(argv[2],&buf,&e,&records,argv[4]);

    if (MyOpenFile(&outLayout,argv[3],"wb")) return(1);

    //	Go to the very beginning of the file.
    //
    result = fseek ( outLayout, SEEK_SET, 0 );
    if (result) {
        printf("ERROR Unable to seek beginning of file: %s\n", argv[3]);
        return(1);
    }

    if (!_stricmp(argv[4],"ntflop") || !_stricmp(argv[4],"lmflop")) {
    	useCdPath=0;
	}
    else {
    	useCdPath=1;
	}

/**
	for ( i = 0; i < records; ++i ) {
	
		Msg ( "record #%d,  %s, size=%d, csize=%d, disk=%d\n",
				i, e[i].name, e[i].size, e[i].csize, e[i].disk );
	}	
**/

	Msg ( "useCdPath = %d\n", useCdPath );

    //
    // munge the compress flag depending on the product type.
    // if we are laying out floppies, then files are always
    // compressed unless a special flag is set in the bom.
	//	X just means don't compress for CD.  XFLOPPY means
	//	don't compress EVEN for FLOPPIES.
	//	Any other value than xfloppy will compress the file for floppies.
	//
	//	NOTE:  from here on out, floppies will use the "" == compress and
	//			"x" == nocompress.  Ie. used in MakeDisk.exe.
    //
    if(!useCdPath) {

		//	Just working in the NTFLOP or LMFLOP case, ie. floppies.
		//
        for (i=0;i<records;i++) {

            if(_strnicmp(e[i].nocompress,"xfloppy",7)) {

				//	Compress this file on floppies.
				//
                e[i].nocompress[0] = '\0';
                e[i].nocompress[1] = '\0';

            } else {

				//	Don't compress this file for floppies.	
				//
                e[i].nocompress[0] = 'x';
                e[i].nocompress[1] = '\0';

				Msg ( "Forcing NO COMPRESSION on this file for floppies:  %s\n",					e[i].name );
            }
        }
    }

    qsort(e,records,sizeof(Entry),PrioritySizeNameCompare);

    if ( useCdPath ) {
        LayoutAssignCD ( e, atoi(argv[5]),records);
    }
    else {
        LayoutAssignDisks(e,atoi(argv[5]),records);
    }

	//	Write out the informative column header.
	//
    i=0; while ((fputc(buf[i++],outLayout))!='\n');

	//	Write out each line to the layout file.
	//
    for (i=0;i<records;i++) {

		//Msg ( "EntryPrint #%d,  %s, size=%d, csize=%d, disk=%d\n",
		//		i, e[i].name, e[i].size, e[i].csize, e[i].disk );
    	EntryPrint(&e[i],outLayout);
	}

    fclose(outLayout);
    fclose(logFile);
    free(e);
    return(0);
}

int __cdecl PrioritySizeNameCompare(const void *v1, const void *v2)
{
    int result;
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    if (e1->priority!=e2->priority)
    return(e1->priority-e2->priority);
    if (e1->size!=e2->size)
    return(e2->size-e1->size);
    if (result=_stricmp(e1->name,e2->name))
    return(result);
    if (useCdPath)
    return(_stricmp(e1->cdpath,e2->cdpath));
    else
    return(0);  // always the same for floppies
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\msize\msizeppc.c ===
//
//	05.10.94	Joe Holman	Get compressed and nocompressed sizes for files
//							in the product via a bom.	
//  08.12.94    Joe Holman  Add code to get PPC files paths.
//
//


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}


void Header(argv,argc)
char* argv[];
int argc;
{
    time_t t;

    Msg ("\n=========== MSIZE =============\n");
	Msg ("Log file : %s\n", argv[1]);
    Msg ("Input BOM: %s\n", argv[2]);
    Msg ("Category : %s\n", argv[3]);
    Msg ("x86 Uncompressed files: %s\n", argv[4]);
    Msg ("x86 Compressed files  : %s\n", argv[5]);
    Msg ("mips Uncompressed files: %s\n", argv[6]);
    Msg ("mips Compressed files  : %s\n", argv[7]);
    Msg ("alpha Uncompressed files: %s\n", argv[8]);
    Msg ("alpha Compressed files  : %s\n", argv[9]);
    Msg ("x86 dbg files  : %s\n",          argv[10]);
    Msg ("mips dbg files: %s\n",           argv[11]);
    Msg ("alpha dbg files  : %s\n",        argv[12]);

    Msg ("ppc uncompressed files  : %s\n",  argv[13]);
    Msg ("ppc compressed files: %s\n",      argv[14]);
    Msg ("ppc dbg files  : %s\n",           argv[15]);

    time(&t); 
	Msg ("Time: %s",ctime(&t));
    Msg ("==============================\n\n");
}

void Usage()
{
    printf("PURPOSE: Fills in the correct sizes for files in the BOM.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM which lists files whose sizes are to be updated.\n");
    printf("[Category] - Specifies the category of files whose sizes are updated.\n");
	printf("[files share] - location of x86 uncompressed files.\n" );
	printf("[files share] - location of x86 compressed files\n" );
	printf("[files share] - location of mips uncompressed files.\n" );
	printf("[files share] - location of mips compressed files\n" );
	printf("[files share] - location of alpha uncompressed files.\n" );
	printf("[files share] - location of alpha compressed files\n" );
	printf("[dbg share] - location of x86 dbg files\n" );
	printf("[dbg share] - location of mips dbg files.\n" );
	printf("[dbg share] - location of alpha dbg files\n" );

	printf("[files share] - location of ppc uncompressed files\n" );
	printf("[files share] - location of ppc compressed files.\n" );
	printf("[dbg share] - location of ppc dbg files\n" );
    printf("\n");
}

int __cdecl NameCompare(const void*,const void*);
int __cdecl MediaNameCompare(const void*,const void*);

#define PATH_X86        0
#define PATH_MIPS       1
#define PATH_ALPHA      2
#define PATH_X86_DBG    3
#define PATH_MIPS_DBG   4
#define PATH_ALPHA_DBG  5
#define PATH_PPC        6
#define PATH_PPC_DBG    7
#define PATH_ERROR  -1 
int DetermineLocation ( const char * source, const char * path ) {

    if ( !_stricmp ( source, "ppcbins" ) ) {

        return PATH_PPC;
    } 
    if ( !_stricmp ( source, "ppcdbg" ) ) {

        return PATH_PPC_DBG;
    } 

    if ( !_stricmp ( source, "x86bins" ) ) {

        return PATH_X86;
    } 

    if ( !_stricmp ( source, "mipsbins" ) ) {

        return PATH_MIPS;
    } 

    if ( !_stricmp ( source, "alphabins" ) ) {

        return PATH_ALPHA;
    } 

    if ( !_stricmp ( source, "x86dbg" ) ) {

        return PATH_X86_DBG;
    } 

    if ( !_stricmp ( source, "mipsdbg" ) ) {

        return PATH_MIPS_DBG;
    } 

    if ( !_stricmp ( source, "alphadbg" ) ) {

        return PATH_ALPHA_DBG;
    } 

    if ( !_stricmp ( source, "infs" ) ) {

        if ( !_stricmp( path, "\\mips" ) ) {

            return PATH_MIPS;
        }
        if ( !_stricmp( path, "\\alpha" ) ) {

            return PATH_ALPHA;
        }

        return PATH_X86;    // infs are generally the same same for each 
                            // platform
    } 

    if ( !_stricmp ( source, "tagfiles" ) ) {

        return PATH_X86;    // infs are generally the same same for each 
                            // platform
    } 

    Msg ( "DetermineLocation: ERROR unknown source: %s\n", source );

    return (PATH_ERROR); 
}

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *tempFile;
    Entry* e;
    HANDLE h;
    char tempName[MAX_PATH];
    int records, i;
    char* buf;
    WIN32_FIND_DATA fd;

    srand((unsigned)time(NULL));

    if ( argc != 16 ) { 
		Usage(); 
		return(1); 
	}

    if ((logFile=fopen(argv[1],"a"))==NULL) {
		printf("ERROR Couldn't open log file: %s\n",argv[1]);
		return(1);
    }

    Header(argv,argc);

    tempName[0]='\0';
    sprintf(tempName,"%d.000",rand());

    if (MyOpenFile(&tempFile,tempName,"wb")) {
		return(1);
	}

    if (!_stricmp(argv[3],"NTFLOP") ||
		!_stricmp(argv[3],"LMFLOP") ||
		!_stricmp(argv[3],"NTCD")   ||
		!_stricmp(argv[3],"LMCD")) {

        Msg ( "Loading records:  %s\n", argv[3] ); 
		LoadFile(argv[2],&buf,&e,&records,argv[3]);
	}
    else {
        //Msg ( "Loading records:  %s\n", "ALL" ); 
		//LoadFile(argv[2],&buf,&e,&records,"ALL");
        Msg ( "ERROR: for media generation, we don't need to load ALL\n" );
        return (1);
	}


	//	Show the records just loaded in.
	//
	Msg ( "# records just loaded = %d\n", records );

	//qsort(e,records,sizeof(Entry),NameCompare);

/**
	for ( i = 0; i < records; ++i ) {
	
		Msg ( "record #%d,  %s, size=%d, csize=%d, disk=%d, source=%s\n", 
				i, e[i].name, e[i].size, e[i].csize, e[i].disk, e[i].source );
	}	
**/

#define BBBB
#ifdef  BBBB
	for ( i = 0; i < records; ++i ) {

		char	filePathU[200]; // uncompressed
        char    filePathC[200]; // compressed
        int     location;

        //  Determine what path to use.
        //
        //  argv[4] - uncompress x86
        //  argv[5] - compressed x86
        //  argv[6] - uncompress mips 
        //  argv[7] - compressed mips 
        //  argv[8] - uncompress alpha 
        //  argv[9] - compressed alpha 
        //  argv[10] - x86 dbg
        //  argv[11] - mips dbg
        //  argv[12] - alpha dbg
        //  argv[13] - uncompress ppc
        //  argv[14] - compressed ppc
        //  argv[15] - ppc dbg
        //
        switch ( location = DetermineLocation ( e[i].source, e[i].path ) ) {

            case PATH_PPC :

		                sprintf ( filePathU, "%s\\%s", argv[13], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[14] );
                        break;


            case PATH_X86 :

		                sprintf ( filePathU, "%s\\%s", argv[4], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[5] );
                        break;


            case PATH_MIPS :

		                sprintf ( filePathU, "%s\\%s", argv[6], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[7] );
                        break;

            case PATH_ALPHA :

		                sprintf ( filePathU, "%s\\%s", argv[8], e[i].name );
                        sprintf ( filePathC, "%s\\",   argv[9] );
                        break;

            case PATH_PPC_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[15], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[15], e[i].path, e[i].name);
               break;

            case PATH_X86_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[10], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[10], e[i].path, e[i].name);
               break;


            case PATH_MIPS_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[11], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[11], e[i].path, e[i].name);
               break;

            case PATH_ALPHA_DBG :

		       sprintf ( filePathU, "%s%s\\%s", argv[12], e[i].path, e[i].name);
               sprintf ( filePathC, "%s%s\\%s", argv[12], e[i].path, e[i].name);
               break;

            default :

               sprintf ( filePathU, "%s", "ERROR path" );
               sprintf ( filePathC, "%s", "ERROR path" );
               Msg ( "ERROR: should never get here...\n" );
               break;
        }

		//	Get the UNCOMPRESSED size.
		//

        h = FindFirstFile( filePathU, &fd );

        if ( h == INVALID_HANDLE_VALUE ) {
			Msg ( "ERROR finding:  %s\n", filePathU );
			e[i].size = 1;
		}
        else {
		    e[i].size = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );
            FindClose( h );
        }

        if ( location == PATH_X86_DBG   ||
             location == PATH_MIPS_DBG  || 
             location == PATH_ALPHA_DBG ||
             location == PATH_PPC_DBG      ) {

            //  DBG files are NOT compressed. So just fill in the
            //  size.
            //

            e[i].csize = e[i].size;

            goto SKIP_COMPRESSED;
        } 

		//	Get the COMPRESSED size.
		//
		convertName( e[i].name, strchr( filePathC, 0 ));

        h = FindFirstFile( filePathC, &fd );

        if ( h == INVALID_HANDLE_VALUE ) {
		    e[i].csize = 1;
			Msg ( "ERROR finding:  %s\n", filePathC );
		}
        else {
			e[i].csize = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );
            FindClose( h );
        }

SKIP_COMPRESSED:;

		//	If source grouping is INFS or TAGFILE 
		//	adjust sizes accordingly now. 
		//
		if ( !_stricmp ( "INFS", e[i].source ) ) {

#define INF_FUDGE 2048 // should be at least 2048 bytes. 

		    e[i].csize += INF_FUDGE;
			e[i].csize = ROUNDUP2( e[i].csize, DMF_ALLOCATION_UNIT );
			e[i].size  += INF_FUDGE;
			e[i].size  = ROUNDUP2( e[i].size, DMF_ALLOCATION_UNIT );

			Msg ( "%s INF file, fudge size up by %d bytes...\n",
						e[i].name, INF_FUDGE ); 
		}

		if ( !_stricmp ( "TAGFILES", e[i].source ) ) {

#define TAGFILE_SIZE DMF_ALLOCATION_UNIT	// just 1 sector of file needed

			e[i].csize = TAGFILE_SIZE;	// just 1 sector of file needed
			e[i].size  = TAGFILE_SIZE;	// just 1 sector of file needed

			Msg ( "%s, size hardcoded to 1 sector of %d bytes...\n",
						e[i].name, TAGFILE_SIZE ); 
		}

/**
		Msg ( "%s, %s, size = %d, csize = %d\n%s\n%s\n", 
							e[i].name, e[i].source, e[i].size, e[i].csize,
                    filePathU, filePathC );
**/

	}

#else

	//	The right thing to do for floppies on X86 is below, that is
	//	get the real file sizes for the x86 compressed and noncompressed
	//	files.
	if ( !_stricmp ( argv[3], "NTFLOP" ) || !_stricmp ( argv[3], "LMFLOP" ) ) {

		char	filePath[200];

		for ( i = 0; i < records; ++i ) {

			//	Get the UNCOMPRESSED size.
			//

			sprintf ( filePath, "%s\\%s", argv[4], e[i].name );

            h = FindFirstFile( filePath, &fd );

            if ( h == INVALID_HANDLE_VALUE ) {
				Msg ( "ERROR finding:  %s\n", filePath );
			    e[i].size = ROUNDUP2( 1, DMF_ALLOCATION_UNIT );
			}
            else {
				e[i].size = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );
                FindClose( h );
            }

			//	Get the COMPRESSED size.
			//
			sprintf ( filePath, "%s\\", argv[5] );
			convertName( e[i].name, strchr( filePath, 0 ));

            h = FindFirstFile( filePath, &fd );

            if ( h == INVALID_HANDLE_VALUE ) {
			    e[i].csize = ROUNDUP2( 1, DMF_ALLOCATION_UNIT );
				Msg ( "ERROR finding:  %s\n", filePath );
			}
            else {
				e[i].csize = ROUNDUP2( fd.nFileSizeLow, DMF_ALLOCATION_UNIT );
                FindClose( h );
            }

			//	If source grouping is INFS or TAGFILE 
			//	adjust sizes accordingly now. 
			//
			if ( !_stricmp ( "INFS", e[i].source ) ) {

#define INF_FUDGE 2048 // should be at least 2048 bytes. 

				e[i].csize += INF_FUDGE;
				e[i].csize = ROUNDUP2( e[i].csize, DMF_ALLOCATION_UNIT );
				e[i].size  += INF_FUDGE;
				e[i].size  = ROUNDUP2( e[i].size, DMF_ALLOCATION_UNIT );

				Msg ( "%s INF file, fudge size up by %d bytes...\n",
						e[i].name, INF_FUDGE ); 
			}

			if ( !_stricmp ( "TAGFILES", e[i].source ) ) {

#define TAGFILE_SIZE DMF_ALLOCATION_UNIT	// just 1 sector of file needed

				e[i].csize = TAGFILE_SIZE;	// just 1 sector of file needed
				e[i].size  = TAGFILE_SIZE;	// just 1 sector of file needed

				Msg ( "%s, size hardcoded to 1 sector of %d bytes...\n",
						e[i].name, TAGFILE_SIZE ); 
			}

/**
			Msg ( "%s,  size = %d, csize = %d\n", 
							e[i].name, e[i].size, e[i].csize );
**/

		}
	}
	else {

		//	Get sizes for CD files.
		//	This may be very similar to above eventually...
		//	but, need to find out...
	}

#endif // BBBB

	//	Print all the records back to the tempFile.
	//
	fseek ( tempFile, SEEK_SET, 0 );

	//	Put the informative header back into the file as the first line.
	//
    i=0; while ((fputc(buf[i++],tempFile))!='\n');

    for ( i = 0; i < records; ++i ) {

	   	EntryPrint(&e[i],tempFile);
/**		
		Msg ( "EntryPrint: #%d,  %s, size=%d, csize=%d, disk=%d,source=%s\n", 
			i, e[i].name, e[i].size, e[i].csize, e[i].disk, e[i].source );
**/
    }

    fclose(logFile);
    fclose(tempFile);
    free(buf);
    free(e);

    if (!CopyFile(tempName,argv[2],FALSE)) {
		Msg ("ERROR Couldn't copy %s to %s\n",tempName,argv[2]);
		Msg ( "CopyFile GLE=%ld leaving temp file for investigation...\n", 
					GetLastError() );
    }
	else {
    	DeleteFile(tempName);
	}

    return(0);
}

int __cdecl NameCompare(const void *v1, const void *v2)
{
    Entry* e1 = (Entry *)v1;
    Entry* e2 = (Entry *)v2;

    return(_stricmp(e2->name,e1->name));
}

int __cdecl MediaNameCompare(const void *v1, const void *v2)
{
    Entry* e1 = (Entry *)v1;
    Entry* e2 = (Entry *)v2;

    return(_stricmp(e2->medianame,e1->medianame));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mcpyfile\mcpyfile.c ===
/*

Modifications:

    12.12.95	Joe Holman		Added GetLastError() to a FindFirstFile()
                                error path.

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

#define MAX_DISKS 40


//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))


FILE* logFile;
int cdProduct;


HANDLE hActivateCopyThread, hCopyThreadIsAvailable;
CHAR chCopyThreadSource[ MAX_PATH ], chCopyThreadDestin[ MAX_PATH ];
CHAR chPreviousSource[ MAX_PATH ], chPreviousDestin[ MAX_PATH ];

void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName );
void DoThreadedCopy( LPSTR pszSource, LPSTR pszDestin );
DWORD CopyThread( LPVOID lpvParam );

void    Msg ( const char * szFormat, ... ) {

    va_list vaArgs;

    va_start ( vaArgs, szFormat );
    vprintf  ( szFormat, vaArgs );
    vfprintf ( logFile, szFormat, vaArgs );
    va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    Msg ("\n=========== MCPYFILE =============\n");
    Msg ("logfile     : %s\n", argv[1] );
    Msg ("Input Layout: %s\n",argv[2]);
    Msg ("category    : %s\n",argv[3]);
    Msg ("Compressed files: %s\n", argv[4]);
    Msg ("Uncompressed files  : %s\n", argv[5]);
    Msg ("Hard drive: %s\n",argv[6]);
    Msg ("Copy d-DBG, x-FLOPPY, c-CDROM files: %s\n", argv[7] );
    time(&t);
    Msg ("Time: %s",ctime(&t));
    Msg ("==================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Copy files to hardrive or into disk1, disk2, ... dirs.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[logFile] - Path to append a log of actions and errors.\n");
    printf("[InLayout] - Path of Layout which lists files to copy.\n");
    printf("[Category] - Specifies the category of files to copy.\n");
    printf("[files share] - location of Compressed files.\n" );
    printf("[files share] - location of Uncompressed files\n" );
    printf("[Harddrive] - Drive where files are stored.\n");
    printf("[copy dbg,floppy,or cd files] - use D for .dbg files or x for floppy files\n" );
}

int __cdecl DiskDirCompare(const void*,const void*);

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    Entry ee;
    char sourcePath[MAX_PATH];
    char destinPath[MAX_PATH];
    int disks[MAX_DISKS];
    Entry *e;
    char *buf;
    int records,i;
    BOOL shouldCopy;
    BOOL update;
    BOOL bCompressedFile;
    BOOL bCopyDbgFiles;
    HANDLE hSource,hDestin, hThread;
    DWORD actualSize,bomSize, dwThreadID;
    WIN32_FIND_DATA fdSource, fdDestin;

    if ( argc != 8 ) {
        Usage();
        return (1);
    }

    if ((logFile=fopen(argv[1],"a"))==NULL) {

        printf("ERROR Couldn't open log file %s.\n",argv[1]);
        return (1);
    }

    hActivateCopyThread    = CreateEvent( NULL, FALSE, FALSE, NULL );
    hCopyThreadIsAvailable = CreateEvent( NULL, FALSE, TRUE,  NULL );
    hThread = CreateThread( NULL, 0, CopyThread, NULL, 0, &dwThreadID );
    CloseHandle( hThread );

    Header(argv);

    //	Load all of the current entries in the layout file
    //	provided to the program.
    //
    LoadFile(argv[2],&buf,&e,&records,"ALL");

    cdProduct     = TRUE;
    bCopyDbgFiles = FALSE;
    update        = TRUE;
    if ( !_stricmp ( "ntflop", argv[3] ) || !_stricmp ( "lmflop", argv[3] ) ||
         _stricmp ( argv[7], "x" ) == 0 ) {

        cdProduct = FALSE;
        bCopyDbgFiles = FALSE;

        Msg ( "Making X86 Floppies...\n" );
    } else {
        Msg ( "Making CDs...\n" );
        bCopyDbgFiles = !_stricmp( argv[7], "d" );
    }

    Msg ( "bCopyDbgFiles = %d\n", bCopyDbgFiles );
    //qsort(e,records,sizeof(ee),DiskDirCompare);

    for (i=0;i<MAX_DISKS;i++) {
        disks[i]=0;
    }

    for (i=0;i<records;i++) {

        if (e[i].cdpath[strlen(e[i].cdpath)-1]=='\\') {

            e[i].cdpath[strlen(e[i].cdpath)-1]='\0';
        }
        if (e[i].path[strlen(e[i].path)-1]=='\\') {

            e[i].path[strlen(e[i].path)-1]='\0';
        }

        disks[e[i].disk]++;
    }

    for (i=0;i<records;i++) {

        if (!((records-i)%100)) {
            printf("# files remaining:%5d/%d\n",records-i,records);
        }

        ee=e[i];

        if (!_stricmp(ee.source,argv[3])) {    // if category matches

            if ( cdProduct ) {

                //	Making CD.
                //
                //
                //  It's a compressed file IFF
                //  the nocompress flag is NOT set (i.e. null) AND
                //  we're NOT copying dbg-files.
                //
                bCompressedFile = !ee.nocompress[0] && !bCopyDbgFiles;

            } else {

                //	Making x86 floppies.
                //
                //	NOTE:  in Layout.C, we go back to the convention of:
                //
                //			""  == yes, compress this file
                //			"x" == no don't compress this file
                //
                bCompressedFile = _stricmp(ee.nocompress, "x" );

                //Msg ( "%s, bCompressedFile = %d\n", ee.name, bCompressedFile );

            }


//Msg ( "bCompressedFile = %d, %s\n", bCompressedFile, ee.name );

            if ( bCompressedFile ) {
                strcpy( sourcePath, argv[ 4 ] );    // use compressed path
                bomSize = ee.csize;         // and compressed size
            } else {
                strcpy( sourcePath, argv[ 5 ] );    // uncompressed path
                bomSize = ee.size;          // uncompressed size
            }

            strcat(sourcePath,ee.path);
            strcat(sourcePath,"\\");

            if ( bCompressedFile ) {
                convertName( ee.name, strchr( sourcePath, 0 ));
            } else if ( bCopyDbgFiles ) {
                MakeDbgName( ee.name, strchr( sourcePath, 0 ));
            } else {
                strcat( sourcePath, ee.name );
            }


            //  May have to massage disk1...disk tagfiles...
            if ( cdProduct ) {
                strcpy(destinPath,argv[6]);
                if ( ! bCopyDbgFiles ) {
                    strcat(destinPath,ee.cdpath);
                }
            } else {
                strcpy(destinPath,argv[6]);
                sprintf(&destinPath[strlen(destinPath)],"\\disk%d",ee.disk);
            }

            strcat(destinPath,"\\");

            if ( bCopyDbgFiles ) {
                MakeDbgName( ee.name, strchr( destinPath, 0 ));
            } else {
                if (ee.medianame[0]) {
                    if ( bCompressedFile ) {
                        convertName( ee.medianame, strchr( destinPath, 0 ));

                        //	For simplification in the BOM, we no longer
                        //	rename compressed files. I.E, any file that has
                        //	to be renamed, CANNOT be compressed.
                        //
                        Msg ( "ERROR: renaming compressed file not supported:  %s\n",
                              destinPath );
                    } else {
                        strcat( destinPath, ee.medianame );
                    }
                } else {
                    if ( bCompressedFile ) {
                        convertName( ee.name, strchr( destinPath, 0 ));
                    } else {
                        strcat( destinPath, ee.name );
                    }
                }
            }

            if (disks[ee.disk]>1) {

                //
                //  Don't attempt to copy same file twice (target file might
                //  not yet completely exist since threaded copy might not be
                //  complete, so can't rely on timestamp equivalence yet).
                //
                if ( _stricmp( sourcePath, chPreviousSource ) ||
                     _stricmp( destinPath, chPreviousDestin )) {

                    hSource=FindFirstFile( sourcePath, &fdSource );

                    if (hSource==INVALID_HANDLE_VALUE) {
                        Msg ("ERROR Source: %s, gle()=%d\n",sourcePath, GetLastError());
                    } else {

                        FindClose( hSource );

                        if ( !cdProduct ) {
                            actualSize = ROUNDUP2( fdSource.nFileSizeLow,
                                                   DMF_ALLOCATION_UNIT );
                        } else {
                            actualSize = ROUNDUP2( fdSource.nFileSizeLow,
                                                   ALLOCATION_UNIT );
                        }

                        //  Check the size of the file vs. the size in the
                        //  bom just for a verification of file sizes.
                        //  Don't do this for Dbg files, since these sizes are
                        //  never put in the layout.
                        //
                        if ( !bCopyDbgFiles && (bomSize < actualSize) ) {
                            Msg ( "ERROR:  disk#%d, %s Size of file: %d > BOM: %d Diff: %d\n",
                                  ee.disk,ee.name,
                                  actualSize,bomSize,actualSize-bomSize);
                        }

                        shouldCopy=TRUE;

                        if (update) {

                            hDestin=FindFirstFile( destinPath, &fdDestin );

                            if (hDestin==INVALID_HANDLE_VALUE) {
                                //  Msg ("New file %s\n", destinPath);
                            } else {
                                FindClose( hDestin );

                                if ( CompareFileTime( &fdSource.ftLastWriteTime,
                                                      &fdDestin.ftLastWriteTime ) <= 0 ) {
                                    shouldCopy=FALSE;
                                } else {
                                    //Msg ("Updating %s\n",destinPath);
                                }

                            }
                        }

                        if (shouldCopy) {
                            Msg ( "Copy:  %s >>> %s\n", sourcePath, destinPath);
                            DoThreadedCopy( sourcePath, destinPath );
                            strcpy( chPreviousSource, sourcePath );
                            strcpy( chPreviousDestin, destinPath );
                        }
                    }
                }
            } else {
                Msg ("WARNING Skipped Disk %d, File: %s\n",ee.disk,ee.name);
            }
        }
    }
    fclose(logFile);
    WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );

    return 0;
}


int __cdecl DiskDirCompare(const void *v1, const void *v2)
{
    Entry *e1 = (Entry *)v1;
    Entry *e2 = (Entry *)v2;

    //
    // If the files are not on the same disk,
    // the comparison is easy.
    //
    if (e1->disk != e2->disk) {
        return (e1->disk - e2->disk);
    }

    //
    // If this is a cd-rom, sort by location on the cd.
    //
    if (cdProduct) {
        return (_stricmp(e1->cdpath,e2->cdpath));
    }

    //
    // Floppy product: we know the files are on the same disk
    // and files on the floppy are all in the same directory.
    //
    return (0);
}


void DoThreadedCopy( LPSTR pszSource, LPSTR pszDestin ) {
    WaitForSingleObject( hCopyThreadIsAvailable, INFINITE );
    strcpy( chCopyThreadSource, pszSource );
    strcpy( chCopyThreadDestin, pszDestin );
    SetEvent( hActivateCopyThread );
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD CopyThread( LPVOID lpvParam ) {

    BOOL bSuccess;
    UINT i, len;

    for (;;) {

        WaitForSingleObject( hActivateCopyThread, INFINITE );

        bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        if ( ! bSuccess ) {

            SetFileAttributes( chCopyThreadDestin, FILE_ATTRIBUTE_NORMAL );

            len = strlen( chCopyThreadDestin );
            for ( i = 2; i < len; i++ ) {
                if ( chCopyThreadDestin[ i ] == '\\' ) {
                    chCopyThreadDestin[ i ] = '\0';
                    CreateDirectory( chCopyThreadDestin, NULL );
                    chCopyThreadDestin[ i ] = '\\';
                }
            }

            bSuccess = CopyFile( chCopyThreadSource, chCopyThreadDestin, FALSE );

        }

        if ( ! bSuccess ) {
            Msg (   "ERROR Source: %s\n"
                    "      Destin: %s\n"
                    "      GLE=%d\n",
                    chCopyThreadSource,
                    chCopyThreadDestin,
                    GetLastError() );
        }

        SetEvent( hCopyThreadIsAvailable );
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


void MakeDbgName( LPCSTR pszSourceName, LPSTR pszTargetName ) {

    //
    //  Converts "filename.ext" into "ext\filename.dbg".
    //

    const char *p = strchr( pszSourceName, '.' );

    if ( p != NULL ) {
        strcpy( pszTargetName, p + 1 );                 // old extension
        strcat( pszTargetName, "\\" );                  // path separator
        strcat( pszTargetName, pszSourceName );         // base name
        strcpy( strchr( pszTargetName, '.' ), ".dbg" ); // new extension
    } else {
        strcpy( pszTargetName, pszSourceName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\mtc\mtc.c ===
/*
 *      10.25.94        Joe Holman  TC-like program changed to perform
 *                                  logging ERRORs for media.
 *		01.17.95		Joe Holman	Every file that is copied gets NORMAL attrs.
 *      02.01.95        Joe Holman  Revamped algorithm and allow empty dirs
 *                                  to be copied.
 *
 */
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <time.h>


// Forward Function Declartions...
BOOL    CopyNode( char * );
void __cdecl main( int, char ** );
void    MyMakeDir ( char * );
void    MyCopyFile ( const char * , const char * );

ULONG   numFilesCopied=0;

char gSource[MAX_PATH];
char gDest[MAX_PATH];
char realDest[MAX_PATH];
char tempdir[MAX_PATH];
char tempfile[MAX_PATH];
//int  drv;

int srclen, dstlen;

FILE    * logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Usage( void ) {

    printf ( "Usage: mTC logFile src-tree dst-tree" );
    exit (1);
}

char fPathChr ( int c ) {

    return (char) ( c == '\\' || c == '/' );
}

void Header(argv)
    char* argv[];
{
    time_t t;

    Msg ("\n=========== MTC =============\n");
    Msg ("LogFile    : %s\n",argv[1]);
    Msg ("Source     : %s\n",argv[2]);
    Msg ("Destination: %s\n",argv[3]);
    time(&t);
    Msg ("Time       : %s",ctime(&t));
    Msg ("================================\n\n");
}

/*  ExpandPath - construct a path from the root to the specified file
 *  correctly handling ., .. and current directory/drive references.
 *
 *  src 	source path for input
 *  dst 	destination buffer
 *  returns	TRUE if error detected
 */
ExpandPath (src, dst)
char *src, *dst;
{

    LPSTR FilePart;
    LPSTR p;
    BOOL  Ok;

    Ok =  (!GetFullPathName( (LPSTR) src,
                             (DWORD) MAX_PATH,
                             (LPSTR) dst,
                             &FilePart ));

    if ( !Ok ) {
        p = src + strlen( src ) - 1;
        if ( *p  == '.' ) {
            if ( p > src ) {
                p--;
                if ( *p != '.' && *p != ':' && !fPathChr(*p) ) {
                    strcat( dst, "." );
                }
            }
        }
    }

    return Ok;

}

BOOL RecurseSrcDir ( const char * gSource, const char * gDest ) {


    WIN32_FIND_DATA wfd;
    HANDLE  fHandle;
    BOOL    bRC=TRUE;
    ULONG   gle;
    char    szSrc[MAX_PATH];
    char    szDst[MAX_PATH];
    char    szPath[MAX_PATH];
    char    szDest[MAX_PATH];
    char    szFind[MAX_PATH];
    char    szSrcFile[MAX_PATH];
    char    szDstFile[MAX_PATH];

    //  Get rid of any trailing forward slashes.
    //
    strcpy ( szSrc, gSource );
    strcpy ( szDst, gDest   );
    if ( szSrc[strlen(szSrc)-1] == '\\' ) {
        szSrc[strlen(szSrc)-1] = '\0';
    }
    if ( szDst[strlen(szDst)-1] == '\\' ) {
        szDst[strlen(szDst)-1] = '\0';
    }

    //Msg ( "entered:  szSrc = %s, szDst = %s\n", szSrc, szDst );

    sprintf ( szFind, "%s\\*.*", szSrc );

    fHandle = FindFirstFile ( szFind, &wfd );

    if ( fHandle == INVALID_HANDLE_VALUE ) {

        //  An error occurred finding a directory.
        //
        Msg ( "ERROR R FindFirstFile FAILED, szFind = %s, GLE = %ld\n",
                    szFind, GetLastError() );
	    return (FALSE);
	}
    else {

        //  Since this is the first time finding a directory,
        //  go to the loops code that makes the same directory on the
        //  destination.
        //
        goto DIR_LOOP_ENTRY;

    }

    do {

DIR_CONTINUE:;

        bRC = FindNextFile ( fHandle, &wfd );

        if ( !bRC ) {

            //  An error occurred with FindNextFile.
            //
            gle = GetLastError();
            if ( gle == ERROR_NO_MORE_FILES ) {

                //Msg ( "ERROR_NO_MORE_FILES...\n" );
                FindClose ( fHandle );
                return (TRUE);
            }
            else {
                Msg ( "ERROR R FindNextFile FAILED, GLE = %ld\n",
                                                        GetLastError() );
                FindClose ( fHandle );
                exit ( 1 );
            }
        }
        else {

DIR_LOOP_ENTRY:;

            // Msg ( "wfd.cFileName = %s\n", wfd.cFileName );

            //  If not directory, don't just continue.
            //
            if ( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

                sprintf ( szSrcFile, "%s\\%s", szSrc, wfd.cFileName );
                sprintf ( szDstFile, "%s\\%s", szDst, wfd.cFileName );

                MyCopyFile ( szSrcFile, szDstFile );

                goto DIR_CONTINUE;
            }

            //  Don't do anything with . and .. directory entries.
            //
            if (!strcmp ( wfd.cFileName, "." ) ||
                !strcmp ( wfd.cFileName, "..")   ) {

                //Msg ( "Don't do anything with . or .. dirs.\n" );
                goto DIR_CONTINUE;
            }

            //  Don't do anything with HIDDEN directory entries.
            //
            if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ) {

                //Msg ( "Don't do anything with HIDDEN dirs.\n" );
                goto DIR_CONTINUE;
            }

            sprintf ( szPath, "%s\\%s", szSrc,   wfd.cFileName );
            sprintf ( szDest, "%s\\%s", szDst,   wfd.cFileName );

            //Msg ( "szPath = %s\n", szPath );
            //Msg ( "md szDest = %s\n", szDest );

            MyMakeDir ( szDest );

            //  Keep recursing down the directories.
            //
            RecurseSrcDir ( szPath, szDest );

        }

    } while ( bRC );

    return ( TRUE );


}

BOOL MakeCommandDir ( const char * dest ) {

    char szDest[MAX_PATH];
    char szLast[MAX_PATH];      // contains last directory made
    char * blah;
    int i;

    strcpy ( szLast, dest );

    //  Exception case - if the specified directory is just the root, then
    //  just ignore this code, since the root directory exists by default.
    if ( szLast[1] == ':'  &&
         szLast[2] == '\\' &&
         szLast[3] == '\0'    ) {

        return ( TRUE );

    }


    //  Clean-up any trailing slashes.
    //
    if ( szLast[strlen(szLast)-1] == '\\' ) {

        szLast[strlen(szLast)-1] = '\0';
    }

    //Msg ( "MakeCommandDir, %s\n", szLast );

    //  Copy and skip the D:\ chars.
    //
    szDest[0] = szLast[0];
    szDest[1] = szLast[1];
    szDest[2] = szLast[2];

    blah = szLast;
    blah += 3;
    i = 3;

    while ( 1 ) {

        if ( *blah == '\0' ) {

            szDest[i] = *blah;
            MyMakeDir ( szDest );  // make the directory...

            break;
        }
        else if ( *blah == '\\' ) {

            szDest[i] = '\0';
            MyMakeDir ( szDest );  // make the directory...

            szDest[i] = *blah;    // now, since the dir exists, put the slash
                                    // back in.
        }
        else {
            szDest[i] = *blah;
        }

        ++blah; ++i;
    }

    return ( TRUE );
}

void __cdecl main ( int argc, char * argv[] ) {

    if ( argc != 4) {
        Usage();
        exit(1);
    }
    if ((logFile=fopen(argv[1],"a"))==NULL) {

        printf("ERROR Couldn't open logFile:  %s\n",argv[1]);
        exit(1);
    }
    Header(argv);

    Msg ( "%s %s %s %s\n", argv[0], argv[1], argv[2], argv[3] );

    if ( ExpandPath (argv[2], gSource) ) {
        Msg ( "ERROR Invalid source: %s\n", argv[2] );
        exit(1);
    }
    if ( ExpandPath (argv[3], gDest) ) {
        Msg ( "ERROR Invalid destination: %s\n", argv[3] );
        exit(1);
    }

    Msg ( "gSource = %s\n", gSource );
    Msg ( "gDest   = %s\n", gDest );

    srclen = strlen (gSource);
    dstlen = strlen (gDest);

    if (!strcmp(gSource, gDest)) {
        Msg ("ERROR gSource == gDest\n" );
        exit(1);
    }

    //  Make any destination directories specified on the command line.
    //
    MakeCommandDir ( gDest );

    //  Make the src directory structure on the destination.
    //
    RecurseSrcDir ( gSource, gDest );

    Msg ( "\nnumFilesCopied:  %ld\n",  numFilesCopied );

    exit(0);
}

/***************************************************************************\

MEMBER:     strbscan

SYNOPSIS:   Returns pointer to first character from string in set

ALGORITHM:

ARGUMENTS:  const LPSTR	    - search string
	    const LPSTR	    - set of characters

RETURNS:    LPSTR     - pointer to first matching character

NOTES:	

HISTORY:    davegi 28-Jul-90
		Rewritten from 286 MASM

KEYWORDS:

SEEALSO:

\***************************************************************************/

#include    <assert.h>
#include    <process.h>
#include    <stdio.h>
#include    <string.h>
#include    <stdlib.h>
#include    <windows.h>

LPSTR
strbscan (
    const LPSTR	pszStr,
    const LPSTR	pszSet
    ) {

    assert( pszStr );
    assert( pszSet );

    return pszStr + strcspn( pszStr, pszSet );
}
static char szDot[] =	    ".";
static char szDotDot[] =    "..";
static char szColon[] =     ":";
static char szPathSep[] =   "\\/:";

/**	FindFilename - find filename in string
 *
 *	Find last /\:-separated component in string
 *
 *	psz	    pointer to string to search
 *
 *	returns     pointer to filename
 */
static char *FindFilename (char *psz)
{
    char *p;

    while (TRUE) {
	    p = strbscan (psz, szPathSep);
	    if (*p == 0) {
	        return psz;
        }
	    psz = p + 1;
	}
}


void    MyCopyFile ( const char * src, const char * dst ) {

    BOOL    fCopy = TRUE;
    BOOL    bRC;

    //  Copy the file if the src is newer than the dst.
    //

    //  See if the dst exists first.
    //
    if (_access (dst, 00) != -1 ) {

        struct _stat srcbuf;
        struct _stat dstbuf;
        int irc;

        //  The dst exists, see if we need to copy the src (newer).
        //
        irc = _stat (src, &srcbuf);

        if ( irc == -1 ) {

            Msg ( "MyCopyFile ERROR stat src FAILed:  %s\n", src );
        }

        irc = _stat (dst, &dstbuf);

        if ( irc == -1 ) {

            Msg ( "MyCopyFile ERROR stat dst FAILed:  %s\n", dst );
        }

        if ( srcbuf.st_mtime <= dstbuf.st_mtime) {

            //  The src is NOT newer than the dst, don't copy.
            fCopy = FALSE;
        }

    }
    else {

        //  Dst doesn't exist.  Copy the file over.
        //
        //Msg ( "Dst doesn't exist, so copy over:  %s\n", dst );
        fCopy = TRUE;
    }


    if ( fCopy ) {

        bRC = CopyFile ( src, dst, FALSE );

        if ( !bRC ) {

            Msg ( "CopyFile ERROR, gle = %ld:  %s >>> %s\n",
                                        GetLastError(), src, dst );
            exit ( 1 );
        }
        else {
			BOOL	b;

            Msg ( "CopyFile:  %s >>> %s [OK]\n", src, dst );

			b = SetFileAttributes ( dst, FILE_ATTRIBUTE_NORMAL );

			if ( !b ) {

				Msg ( "ERROR SetFileAttributes:  %s, gle() = %ld\n",
											dst, GetLastError() );
			}

            ++numFilesCopied;
        }
    }

}

void    MyMakeDir ( char * szPath ) {

    char szDirToMake[MAX_PATH];
    int numChars = strlen ( szPath );
    struct _stat dbuf;

    //  szPath is the string of the destination path.
    //  Currently, this assumes a local drive on the machine.
    //  We could change the below code to skip the first \\server\share
    //  names in a UNC specified path, if ever needed.
    //

    strcpy ( szDirToMake, szPath );

    //Msg ( "szDirToMake = %s\n", szDirToMake );

    if ( _stat ( szDirToMake, &dbuf) == 0 ) {

       if ( dbuf.st_mode & S_IFDIR ) {

            //  Wanted directory exists already.
            //
       }
       if ( dbuf.st_mode & S_IFREG ) {

            //  Wanted directory to make already exists as a FILE !
            //
            Msg ("ERROR MyMakeDir(%s) is a file already.", szDirToMake);
            exit ( 1 );
       }
    }
    else {

        if ( errno == ENOENT ) {

            BOOL b;

            b = CreateDirectory ( szDirToMake, NULL );
            if ( !b ) {
                Msg ("ERROR Unable to CreateDirectory(%s), gle = %ld\n",
                                         szDirToMake, GetLastError() );
                exit(1);
            }
            else {

                Msg ( "md %s [OK]\n", szDirToMake );
            }
        }
        else {
             Msg ( "MyMakeDir ERROR (%s) stat FAILED...\n", szDirToMake );
             exit(1);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkmem.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkmem.c

Abstract:

    Memory allocation routines for online books program

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"


VOID
OutOfMemory(
    VOID
    )

/*++

Routine Description:

    Display an out of memory message box and terminate.

Arguments:

    None.

Return Value:

    THIS ROUTINE DOES NOT RETURN TO ITS CALLER

--*/

{
    MessageBox(hInst,L"OOM",NULL,MB_OK);    // BUGBUG
    ExitProcess(1);
}


PVOID
MyMalloc(
    IN DWORD Size
    )

/*++

Routine Description:

    Allocate a zeroed-out block of memory.
    If allocation fails this routine does not return.

Arguments:

    Size - supplies the number of bytes of memory required.
        The memory block can be freed with MyFree when no
        longer needed.

Return Value:

    Pointer to buffer of the requested size. The buffer will
    be zeroed out.

--*/

{
    PVOID p = (PVOID)LocalAlloc(LPTR,Size);

    if(!p) {
        OutOfMemory();
    }

    return(p);
}


VOID
MyFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Free a block of memory previously alocated by MyMalloc.

Arguments:

    Block - supplied pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkinst.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkinst.c

Abstract:

    Routine to install the on-line books to a local hard drive.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"

//
// Define structure that described a file to be copied.
//
typedef struct _FILETOCOPY {
    struct _FILETOCOPY *Next;
    WIN32_FIND_DATA FindData;
} FILETOCOPY, *PFILETOCOPY;

//
// Header of a linked list describing the files to be copied.
//
PFILETOCOPY CopyList;

//
// Custom window message
//
#define WMX_I_AM_READY      (WM_USER+567)


VOID
TearDownCopyList(
    VOID
    )

/*++

Routine Description:

    Delete the copy list structure, freeing all memory used by it.

Arguments:

    None.

Return Value:

    None. CopyList will be NULL on exit.

--*/

{
    PFILETOCOPY p,q;

    for(p=CopyList; p; p=q) {

        q = p->Next;
        MyFree(p);
    }

    CopyList = NULL;
}


BOOL
BuildFileList(
    IN PWSTR Directory
    )

/*++

Routine Description:

    Build a list of files contained in a given directory.

Arguments:

    Directory - supplies the directory whose contents are to be enumarated
        and placed in a list.

Return Value:

    Boolean value indicating outcome. If the return value is TRUE then the
    global CopyList variable will point to a linked list of files in
    the directory.

--*/

{
    HANDLE h;
    PFILETOCOPY p;
    WCHAR SearchSpec[MAX_PATH];
    PFILETOCOPY Previous;
    BOOL b;

    Previous = NULL;

    lstrcpy(SearchSpec,Directory);
    lstrcat(SearchSpec,L"\\*");

    p = MyMalloc(sizeof(FILETOCOPY));
    h = FindFirstFile(SearchSpec,&p->FindData);
    if(h != INVALID_HANDLE_VALUE) {

        CopyList = p;
        Previous = p;

        do {

            p = MyMalloc(sizeof(FILETOCOPY));

            if(b = FindNextFile(h,&p->FindData)) {

                Previous->Next = p;
                Previous = p;
            }
        } while(b);

        FindClose(h);
    }

    MyFree(p);

    if(!(b = (GetLastError() == ERROR_NO_MORE_FILES))) {
        TearDownCopyList();
    }

    return(b);
}


DWORD WINAPI
ThreadBuildFileList(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    Entry point for worker thread that builds a list of files to be copied.
    This thread is designed to be started by the ActionWithBillboard().

Arguments:

    ThreadParameter - supplies thread parameters. This is expected to point
        to a ACTIONTHREADPARAMS structure, from which we can determine the
        billboard dialog's window handle and the directory to be enumerated.

Return Value:

    Always 0. The actual 'return value' is communicated buy posting a message
    to the billboard dialog, and is the value returned by BuildFileList().


--*/

{
    PACTIONTHREADPARAMS p;
    BOOL b;

    p = ThreadParameter;

    //
    // Allow time for billboard dialog to come up
    //
    Sleep(250);

    //
    // Do it.
    //
    b = BuildFileList(p->UserData);

    //
    // Tell the billboard that we're done.
    //
    PostMessage(p->hdlg,WM_COMMAND,IDOK,b);

    ExitThread(0);
    return 0;   // prevent compiler warning
}



INT_PTR
CALLBACK
DlgProcInstall(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    DWORD rc;
    WCHAR Directory[MAX_PATH];
    int i;

    switch(msg) {

    case WM_INITDIALOG:

        CenterDialogOnScreen(hdlg);

        GetWindowsDirectory(Directory,MAX_PATH);
        lstrcat(Directory,L"\\BOOKS");
        SetDlgItemText(hdlg,IDC_INSTALL_TO,Directory);
        SendDlgItemMessage(hdlg,IDC_INSTALL_TO,EM_SETSEL,0,(LPARAM)-1);
        SendDlgItemMessage(hdlg,IDC_INSTALL_TO,EM_LIMITTEXT,MAX_PATH-1,0);
        SetFocus(GetDlgItem(hdlg,IDC_INSTALL_TO));

        PostMessage(hdlg,WMX_I_AM_READY,0,lParam);

        //
        // Tell Windows we set the focus
        //
        return(FALSE);

    case WMX_I_AM_READY:

        do {
            rc = ActionWithBillboard(
                    ThreadBuildFileList,
                    hdlg,
                    IDS_FILELIST_CAPTION,
                    IDS_FILELIST,
                    *(PWSTR *)lParam
                    );

            //
            // If rc is 0, we could not build file list.
            //
            if(!rc) {

                //
                // See if user wants to cancel or retry.
                //
                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_CANT_GET_FILE_LIST,
                        0,
                        MB_RETRYCANCEL | MB_ICONSTOP | MB_SETFOREGROUND | MB_APPLMODAL
                        );

                if(i = IDCANCEL) {
                    EndDialog(hdlg,FALSE);
                    break;
                }
            }

        } while(!rc);

        break;

    case WM_COMMAND:

        switch(HIWORD(wParam)) {

        case BN_CLICKED:

            switch(LOWORD(wParam)) {

            case IDOK:

                //
                // See whether the user gave us something reasonable
                // before attempting the copy.
                //
                return(FALSE);

            case IDCANCEL:

                EndDialog(hdlg,FALSE);
                return(FALSE);
            }

            break;
        }

        break;

    case WM_QUERYDRAGICON:

        return(MainIcon != 0);

    default:
        return(FALSE);

    }

    return(TRUE);
}


BOOL
DoInstall(
    IN OUT PWSTR *Location
    )
{
    BOOL rc;

    rc = (BOOL)DialogBoxParam(
                  hInst,
                  MAKEINTRESOURCE(DLG_INSTALL),
                  NULL,
                  DlgProcInstall,
                  (LPARAM)Location
                  );

    TearDownCopyList();

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\openall\openall.c ===
/*

Modifications:

07.08.96	Joe Holman		Created to open all files for links. 



*/



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>

FILE* logFile;

void	Msg ( const char * szFormat, ... ) {

	va_list vaArgs;

	va_start ( vaArgs, szFormat );
	vprintf  ( szFormat, vaArgs );
	vfprintf ( logFile, szFormat, vaArgs );
	va_end   ( vaArgs );
}

void Header(argv)
char* argv[];
{
    time_t t;

    Msg ("\n=========== MCOPY =============\n");
	Msg("Log file: %s\n", argv[1]);
    time(&t); 
	Msg("Time: %s",ctime(&t));
    Msg("================================\n\n");
}

void Usage()
{
    printf("PURPOSE: Calls GetFileAttrEx on all files recursively.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Complete full path to append a log of actions and errors.\n");
}

void MyGetFileAttrEx ( char * szFile ) {

    BOOL    bRC;
    WIN32_FILE_ATTRIBUTE_DATA wfd;
    GET_FILEEX_INFO_LEVELS gfi;

    bRC = GetFileAttributesEx ( szFile, 0, &wfd );

    if ( !bRC ) {

        Msg ( "ERROR: GetFileAttributesEx ( %s ), gle = %ld\n", szFile, GetLastError () );

    }
    else {
        Msg ( "[OK] GetFileAttributesEx ( %s )\n", szFile );
    }


}

BOOL GetFiles ( char * lastPath ) {

    WIN32_FIND_DATA wfd;
    HANDLE  fHandle;
    BOOL    bRC=TRUE;
    ULONG   gle;
    char    szSrc[256];
    char    szPath[256];
    char    szFind[256];
    char    szSrcFile[256];

    strcpy ( szSrc, lastPath );

    sprintf ( szFind, "%s\\*.*", szSrc );

    fHandle = FindFirstFile ( szFind, &wfd );

    if ( fHandle == INVALID_HANDLE_VALUE ) {

        //  An error occurred finding a file/directory.
        //
        Msg ( "ERROR R FindFirstFile FAILED, szFind = %s, GLE = %ld\n",
                    szFind, GetLastError() );
	    return (FALSE);
	}
    else {

        //  Since this is the first time finding a directory,
        //  go to the loops code that makes the same directory on the
        //  destination.
        //
        goto DIR_LOOP_ENTRY;

    }

    do {

DIR_CONTINUE:;

        bRC = FindNextFile ( fHandle, &wfd );

        if ( !bRC ) {

            //  An error occurred with FindNextFile.
            //
            gle = GetLastError();
            if ( gle == ERROR_NO_MORE_FILES ) {

                //Msg ( "ERROR_NO_MORE_FILES...\n" );
                FindClose ( fHandle );
                return (TRUE);
            }
            else {
                Msg ( "ERROR R FindNextFile FAILED, GLE = %ld\n",
                                                        GetLastError() );
                FindClose ( fHandle );
                exit ( 1 );
            }
        }
        else {

DIR_LOOP_ENTRY:;

            // Msg ( "wfd.cFileName = %s\n", wfd.cFileName );

            //  If not directory, don't just continue.
            //
            if ( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

                sprintf ( szSrcFile, "%s\\%s", szSrc, wfd.cFileName );

                MyGetFileAttrEx ( szSrcFile );

                goto DIR_CONTINUE;
            }

            //  Don't do anything with . and .. directory entries.
            //
            if (!strcmp ( wfd.cFileName, "." ) ||
                !strcmp ( wfd.cFileName, "..")   ) {

                //Msg ( "Don't do anything with . or .. dirs.\n" );
                goto DIR_CONTINUE;
            }

            sprintf ( szPath, "%s\\%s", szSrc,   wfd.cFileName );

            //Msg ( "szPath = %s\n", szPath );

            //  Keep recursing down the directories.
            //
            GetFiles ( szPath );

        }

    } while ( bRC );

    return ( TRUE );


}

    


__cdecl main(int argc, char * argv[] ) {

	BOOL	b;

    if (argc!=2) { 

		Usage(); 
		return(1); 
	}
    if ((logFile=fopen(argv[1],"a"))==NULL) {

    	printf("ERROR Couldn't open log file %s\n",argv[1]);
    	return(1);
    }

    Header(argv);


    GetFiles ( "." );

    fclose(logFile);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkres.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkmem.c

Abstract:

    Resource manipulation routines for online books program.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"


PWSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Load a string from the application's string table resource
    and place it into a buffer.

Arguments:

    StringId - supplies the string table id of the string to be retreived.

Return Value:

    Pointer to a buffer containing the string. If any error
    occured the buffer will be empty.

    The caller can free the buffer via MyFree when done with it.

--*/

{
    WCHAR buf[4096];
    int i;
    PWSTR p;

    i = LoadString(hInst,StringId,buf,sizeof(buf)/sizeof(buf[0]));

    if(!i) {
        buf[0] = 0;
    }

    return DupString(buf);
}


int
MessageBoxFromMessage(
    IN HWND Owner,
    IN UINT MessageId,
    IN UINT CaptionStringId,
    IN UINT Style,
    ...
    )

/*++

Routine Description:

    Display a message box whose text is a formatted message and whose caption
    is a string in the application's string resources.

Arguments:

    Owner - supplied handle of owner window

    MessageId - supplies id of message in message table resources

    CaptionStringId - supplies id of string in string resources. If this
        value is 0 the default ("Error") is used.

    Style - supplies style flags to be passed to MessageBox

Return Value:

    Return value from MessageBox.

--*/

{
    PWSTR Text,Caption;
    va_list arglist;
    DWORD d;
    int i;

    va_start(arglist,Style);

    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            hInst,
            MessageId,
            0,
            (LPTSTR)&Text,
            0,
            &arglist
            );

    va_end(arglist);

    if(!d) {
        OutOfMemory();
    }

    Caption = CaptionStringId ? MyLoadString(CaptionStringId) : NULL;

    i = MessageBox(Owner,Text,Caption,Style);

    if(Caption) {
        MyFree(Caption);
    }

    LocalFree(Text);

    return(i);
}


PWSTR
RetreiveMessage(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Retreive and format a message from the application's message resources.

Arguments:

    MessageId - supplies the message id of the message to be
        retreived and formatted.

    ... - additional arguments supply strings to be inserted into the
        message as it is formatted.

Return Value:

    Pointer to a buffer containing the string. If any error
    occured the buffer will be empty.

    The caller can free the buffer via MyFree when done with it.

--*/

{
    va_list arglist;
    DWORD d;
    PWSTR p,q;

    va_start(arglist,MessageId);

    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            hInst,
            MessageId,
            0,
            (LPTSTR)&p,
            0,
            &arglist
            );

    va_end(arglist);

    if(!d) {
        OutOfMemory();
    }

    //
    // Move the string to a buffer allocated with MyAlloc so the caller
    // can use MyFree instead of LocalFree (to avoid confusion).
    //
    q = DupString(p);
    LocalFree((HLOCAL)p);
    return(q);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkprof.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkprof.c

Abstract:

    Profile routines for online books program

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"


//
// Registry key where profile values are stored.
//
PWSTR BooksProfileKeyName   = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Online Books";

//
// Name of profile value that stores the last known location
// of the online books helpfile. This value varies depending
// on the product (workstation/server) and is set in FixupNames().
//
PWSTR BooksProfileLocation;



PWSTR
MyGetProfileValue(
    IN PWSTR ValueName,
    IN PWSTR DefaultValue
    )

/*++

Routine Description:

    Retreive a profile value as a unicode string.

Arguments:

    ValueName - supplies the name of the value to be retreived.

    DefaultValue - supplies the default value, which is used if
        the given value cannot be retreived for any reason.

Return Value:

    Pointer to the profile value. The caller can free this
    buffer with MyFree when done with it. Note that this
    routine always returns a valid pointer.

--*/

{
    LONG l;
    DWORD Disposition;
    WCHAR Value[128];
    HKEY hKey;
    DWORD DataType;
    DWORD DataSize;

    //
    // Create the key if it does not exist.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            BooksProfileKeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ,
            NULL,
            &hKey,
            &Disposition
            );

    if(l == NO_ERROR) {

        DataSize = sizeof(Value);

        l = RegQueryValueEx(
                hKey,
                ValueName,
                NULL,
                &DataType,
                (LPBYTE)Value,
                &DataSize
                );

        RegCloseKey(hKey);

        if((l != NO_ERROR) || (DataType != REG_SZ)) {
            lstrcpy(Value,DefaultValue);
        }

    } else {
        lstrcpy(Value,DefaultValue);
    }

    return DupString(Value);
}


BOOL
MySetProfileValue(
    IN  PWSTR ValueName,
    OUT PWSTR Value
    )

/*++

Routine Description:

    Save a unicode string profile value.

Arguments:

    ValueName - supplies the name of the value to be set.

    Value - supplies the value to be set.

Return Value:

    Boolean value indicating whether the operation succeeded.

--*/

{
    LONG l;
    DWORD Disposition;
    HKEY hKey;

    //
    // Create the key if it does not exist.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            BooksProfileKeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,
            &hKey,
            &Disposition
            );

    if(l == NO_ERROR) {

        l = RegSetValueEx(
                hKey,
                ValueName,
                0,
                REG_SZ,
                (PBYTE)Value,
                (lstrlen(Value)+1)*sizeof(WCHAR)
                );

        RegCloseKey(hKey);
    }

    return(l == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkhlpfil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkhlpfil.c

Abstract:

    Routines to manipulate help files and help file names.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"
#include <shellapi.h>


//
// Fixed name of the help file. This is dependent on whether
// this is server or workstation and is set in FixupNames().
//
PWSTR HelpFileName;

//
// Path on CD-ROM where online books files are located.
// We "just know" this value.
//
PWSTR PathOfBooksFilesOnCd = L"\\SUPPORT\\BOOKS";


VOID
FormHelpfilePaths(
    IN  WCHAR Drive,            OPTIONAL
    IN  PWSTR Path,
    IN  PWSTR FilenamePrepend,  OPTIONAL
    OUT PWSTR Filename,
    OUT PWSTR Directory         OPTIONAL
    )

/*++

Routine Description:

    Form the full pathname of the main online books help file
    and of the directory containing the help file (ie, the pathname
    of the help file without the filename part).

    The filename part of the name is determined by the server/workstation
    setting and is fixed.

Arguments:

    Drive - if specified, supplies the drive letter of the drive
        on which the help file is located. If not specified, the
        file is assumed to be on a UNC or other path as described
        by Path.

    Path - supplies the path component of the location of the
        help file name. This can be relative to a drive (if Drive is specified)
        of a complete path component (Drive is not specified).

    FilenamePrepend - if specified, supplies a string to be prepended
        to the generated full pathname of the helpfile. This is useful
        when generating command lines.

    Filename - receives the full pathname of the help file. The caller must
        ensure that the buffer is large enough.

    Directory - if specified, receives the full path of the directory
        in which the helpfile is located. The caller must ensure that the
        buffer is large enough.

Return Value:

    None.

--*/

{
    if(Drive) {

        wsprintf(
            Filename,
            L"%s%c:%s\\%s",
            FilenamePrepend ? FilenamePrepend : L"",
            Drive,
            Path,
            HelpFileName
            );

        if(Directory) {
            wsprintf(Directory,L"%c:%s",Drive,Path);
        }

    } else {

        wsprintf(
            Filename,
            L"%s%s\\%s",
            FilenamePrepend ? FilenamePrepend : L"",
            Path,
            HelpFileName
            );

        if(Directory) {
            lstrcpy(Directory,Path);
        }
    }
}


BOOL
CheckHelpfilePresent(
    IN PWSTR Path
    )

/*++

Routine Description:

    Determine if the relevent helpfile (a fixed name depending on
    whether this is workstation or server) is accessible.

Arguments:

    Path - supplies the path to the helpfile (a full path that does not
        include the filename part and should not end with a backslash).

Return Value:

    Boolean value indicating whether the file is accessible.

--*/

{
    WCHAR Filename[MAX_PATH];

    FormHelpfilePaths(0,Path,NULL,Filename,NULL);

    return DoesFileExist(Filename);
}


VOID
FireUpWinhelp(
    IN WCHAR Drive, OPTIONAL
    IN PWSTR Path
    )

/*++

Routine Description:

    Invoke winhlp32.exe on the relevent online books helpfile.
    This routine also stores the helpfile location in the
    application profile if winhlp32 could be successfully executed.

Arguments:

    Drive - if specified, supplies the drive letter of the drive
        on which the help file is located. If not specified, the
        file is assumed to be on a UNC or other path as described
        by Path.

    Path - supplies the path component of the location of the
        help file name. This can be relative to a drive (if Drive is specified)
        of a complete path component (Drive is not specified).

Return Value:

    None. If winhlp32 cannot be started a fatal error is generated
    and this routine does not return to its caller.

--*/
{
    WCHAR CommandLine[MAX_PATH];
    WCHAR CurrentDirectory[MAX_PATH];

    FormHelpfilePaths(
        Drive,
        Path,
        NULL,
        CommandLine,
        CurrentDirectory
        );

	if(((INT_PTR)ShellExecute(NULL, L"open", CommandLine, NULL, NULL, SW_SHOWNORMAL)) > 32) {
        //
        // Remember the location of the help file.
        //
        MySetProfileValue(BooksProfileLocation,CurrentDirectory);
    } else {
        MyError(NULL,IDS_CANT_START_WINHELP,TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bom\size\size.c ===
/*

    05.21.96    Joe Holman      Add code to insert filesizes, if file found, instead of
                                using 999.
                                This will help in not running out of disk space when
                                installing network components via the network cpl applet.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include "general.h"

//
// Macro for rounding up any number (x) to multiple of (n) which
// must be a power of 2.  For example, ROUNDUP( 2047, 512 ) would
// yield result of 2048.
//

#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))

char * pEnv = NULL;
#define MFL 256

FILE* logFile;

void Header(argv)
char* argv[];
{
    time_t t;

    PRINT1("\n=========== SIZE =============\n")
    PRINT2("Input BOM: %s\n",argv[2])
    PRINT2("Source ID: %s\n",argv[3])
    PRINT2("Source Path: %s\n",argv[4])
    PRINT2("Compressed: %s\n",argv[5])
    time(&t); PRINT2("Time: %s",ctime(&t))
    PRINT1("==============================\n\n")
}

void Usage()
{
    printf("PURPOSE: Fills in the correct sizes for files in the BOM.\n");
    printf("\n");
    printf("PARAMETERS:\n");
    printf("\n");
    printf("[LogFile] - Path to append a log of actions and errors.\n");
    printf("[InBom] - Path of BOM which lists files whose sizes are to be updated.\n");
    printf("[SourceId] - Specifies the category of files whose sizes are updated.\n");
    printf("[SourcePath] - Path of the files in <SourceId>.\n");
    printf("[Compressed] - 'C' compressed, 'N' uncompressed, 'B' update both, 'F' random, 'Z' fixed.\n");
    printf("\n");
    printf("If [SourceId] begins with a #, then certain entries in the BOM\n");
    printf("are to be filtered out based on the values following the #.\n");
    printf("#A-FR means to exclude all files marked with A-FR in the group field.\n");
    printf("#A+FR means to exclude all files not marked with A-FR in the group field.\n");
    printf("#A-* means to exclude all files marked with A- in the group field.\n");
    printf("\n");
    printf("If [SourceId] is NTFLOP, LMFLOP, NTCD, or LMCD no sizes are updated and\n");
    printf("the only the entries in the BOM relating to the specified product are output.\n");
}

void AssignSize(newsize,flag,e,i,path)
int newsize;
char* flag;
Entry* e;
int i;
char* path;
{
    if (!_stricmp(flag,"b") || _stricmp(flag,"c"))
    {
	if (newsize==1)
	    if (e[i].size>1)
		PRINT2("WARNING Can't find %s.  Uncompressed size is hardwired.\n",path)
	    else
	    {
		PRINT2("ERROR Can't find %s.  Size will be set to 1.\n",path)
		e[i].size=1;
	    }
	else if (e[i].size<1)
	    e[i].size=newsize;
    }
    if (!_stricmp(flag,"b") || _stricmp(flag,"n"))
    {
	if (newsize==1)
	    if (e[i].csize>1)
		PRINT2("WARNING Can't find %s.  Compressed size is hardwired.\n",path)
	    else
	    {
		PRINT2("ERROR Can't find %s.  Size will be set to 1.\n",path)
		e[i].csize=1;
	    }
	else if (e[i].csize<1)
	    e[i].csize=newsize;
    }
}

int __cdecl NameCompare(const void*,const void*);
int __cdecl MediaNameCompare(const void*,const void*);

DWORD GetFileSizeOrDefault999 ( char * fileName ) {

    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    CHAR  filePath[MFL];

    //  Let's first try the path the binaries just points to on the build machines.
    //
    if ( pEnv != NULL ) {

        sprintf ( filePath, "%s\\%s", pEnv, fileName );
    }
    else {

        sprintf ( filePath, "\\binaries\\%s", fileName );
    }

    FindHandle = FindFirstFile ( filePath, &FindData );
    if ( FindHandle == INVALID_HANDLE_VALUE ) {


	    PRINT2("size.exe - Warning - Couldn't find:  %s  assigning 999.\n", fileName );

        return ( 999 );
    }
    else {

        FindClose ( FindHandle );
        return ( FindData.nFileSizeLow );
    }

}

int __cdecl main(argc,argv)
int argc;
char* argv[];
{
    FILE *tempFile;
    Entry* e;
    HANDLE h;
    char path[MAX_PATH], tempName[MAX_PATH];
    DWORD size;
    int records, i;
    char* buf;
    int subMatch;
    WIN32_FIND_DATA fd;

    srand((unsigned)time(NULL));

    if (argc!=6) { Usage(); return(1); }

    if ((logFile=fopen(argv[1],"a"))==NULL)
    {
	printf("ERROR Couldn't open log file: %s\n",argv[1]);
	return(1);
    }
    Header(argv);

    tempName[0]='\0';
    sprintf(tempName,"%d.000",rand());

    //  Get the directory where the build machines keep binaries.
    //
    pEnv = getenv ( "_nttree" );
    if ( pEnv == NULL ) {
        pEnv = getenv ( "binaries" );
    }
    if ( pEnv != NULL ) {

        printf ( "pEnv = %s\n", pEnv );
    }

    if (MyOpenFile(&tempFile,tempName,"wb")) return(1);

    if (!_stricmp(argv[3],"NTFLOP") ||
	!_stricmp(argv[3],"LMFLOP") ||
	!_stricmp(argv[3],"NTCD")   ||
	!_stricmp(argv[3],"LMCD"))
	LoadFile(argv[2],&buf,&e,&records,argv[3]);
    else
	LoadFile(argv[2],&buf,&e,&records,"ALL");

    if (!_stricmp(argv[5],"f") || !_stricmp(argv[5],"z"))
    {
	for (i=0;i<records;i++)
	{
	    if (!_stricmp(argv[5],"f"))
	    {
		//
		//  Since average size of uncompressed x86 file in the system
		//  is 64K, we'll pick a random number up to twice that.
		//  Since rand() returns 0..0x7FFF, and we don't care about
		//  low bits since we're rounding-up to ALLOCATION_UNIT, we
		//  can just shift rand() left four bits to achieve range
		//  from 0..0x7FFF0, then we'll mask-off all but low bits
		//  necessary for 0 to 128K.
		//

		if (e[i].size<=0)
		    e[i].size = ROUNDUP2( (( (unsigned)rand() << 4 ) & 0x1FFFF ), ALLOCATION_UNIT );
		if (e[i].csize<=0)
		    e[i].csize= ROUNDUP2( (( (unsigned)rand() << 4 ) & 0x1FFFF ), ALLOCATION_UNIT );
	    }
	    else
	    {

            //  Only give filesize of 999 if we can't find the file, ie. get its built size.
            //
		    if (e[i].size<=0) {

                e[i].size = GetFileSizeOrDefault999 (e[i].name);
            }

            //  Do as we always did here for compressed field.
            //
		    if (e[i].csize<=0) e[i].csize=999;
	    }
	}

	qsort(e,records,sizeof(Entry),NameCompare);
	for (i=1;i<records;i++)
	    if (!_stricmp(e[i].name,e[i-1].name))
	    {
		e[i].size=e[i-1].size;
		e[i].csize=e[i-1].csize;
	    }

	qsort(e,records,sizeof(Entry),MediaNameCompare);
	for (i=1;i<records;i++)
	    if (!_stricmp(e[i].medianame,e[i-1].medianame) && (strlen(e[i].medianame)>0))
	    {
		e[i].size=e[i-1].size;
		e[i].csize=e[i-1].csize;
	    }
    }
    else for (i=0;i<records;i++)
    {
	if (!_stricmp(e[i].source,argv[3]))
	{
	    strcpy(path,argv[4]);
	    strcat(path,e[i].path);
	    if (e[i].path[strlen(e[i].path)-1]!='\\')
		strcat(path,"\\");
	    if ( !_stricmp(argv[5], "c" ))
		convertName( e[i].name, strchr( path, 0 ));
	    else
		strcat(path,e[i].name);

            h = FindFirstFile( path, &fd );

            if ( h == INVALID_HANDLE_VALUE )
                AssignSize( 1, argv[ 5 ], e, i, path );
            else
            {
		size = ROUNDUP2( fd.nFileSizeLow, ALLOCATION_UNIT );
		AssignSize( size, argv[5], e, i, path );
                FindClose( h );
            }
        }
    };

    i=0; while ((fputc(buf[i++],tempFile))!='\n');

    for (i=0;i<records;i++)
    {
	if (argv[3][0]=='#') {
	    if (argv[3][1]==e[i].flopmedia[0]) {
		subMatch=(!_stricmp(&argv[3][3],&e[i].flopmedia[2]) || (argv[3][3]=='*'));
		if ((argv[3][2]=='+') && !subMatch) e[i].source[0]='\0';
		if ((argv[3][2]=='-') && subMatch)  e[i].source[0]='\0';
	    }
	}
	if (e[i].source[0])
	    EntryPrint(&e[i],tempFile);
    }

    fclose(logFile);
    fclose(tempFile);
    free(buf);
    free(e);

    if (!CopyFile(tempName,argv[2],FALSE))
	PRINT3("ERROR Couldn't copy %s to %s\n",tempName,argv[2])
    DeleteFile(tempName);

    return(0);
}

int __cdecl NameCompare(const void *v1, const void *v2)
{
    Entry* e1 = (Entry *)v1;
    Entry* e2 = (Entry *)v2;

    return(_stricmp(e2->name,e1->name));
}

int __cdecl MediaNameCompare(const void *v1, const void *v2)
{
    Entry* e1 = (Entry *)v1;
    Entry* e2 = (Entry *)v2;

    return(_stricmp(e2->medianame,e1->medianame));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkthrdlg.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkthrdlg.c

Abstract:

    Routines that implement a billboard-type dialog, for displaying
    a message while the program carries out some action.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"


//
// Define structure used internally to communicate information
// to the billboard dialog procedure.
//
typedef struct _BILLBOARDPARAMS {
    PTHREAD_START_ROUTINE ThreadEntry;
    PWSTR Caption;
    PWSTR Text;
    PVOID UserData;
    HWND OwnerWindow;
} BILLBOARDPARAMS, *PBILLBOARDPARAMS;

//
// Custom window message the dialog sends to itself
// to indicate that WM_INITDIALOG is done.
//
// lParam = thread handle of action worker thread
//
#define WMX_I_AM_READY      (WM_USER+567)

//
// Name of property we use to store thread parameters.
//
PWSTR ThreadParamsPropertyName = L"__threadparams";


INT_PTR
CALLBACK
DlgProcBillboard(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the 'billboard-with-associated-action'
    dialog. When the dialog is initializing we create a worker thread
    to perform the action. This allows us to remain responsive to the
    user without yielding, etc.

Arguments:

    hdlg - supplies handle of dialog box

    msg - supplies the message on which the dialog procedure is to act

    wParam - supplies message-dependent data

    lParam - supplies message-dependent data

Return Value:

    Message-dependent.

--*/

{
    PBILLBOARDPARAMS Params;
    HANDLE h;
    DWORD ThreadId;
    PACTIONTHREADPARAMS params;

    switch(msg) {

    case WM_INITDIALOG:

        Params = (PBILLBOARDPARAMS)lParam;

        CenterDialogInWindow(hdlg,Params->OwnerWindow);

        //
        // Set the text fields.
        //
        SetWindowText(hdlg,Params->Caption);
        SetDlgItemText(hdlg,IDT_BILLBOARD_TEXT,Params->Text);

        //
        // Create the thread parameters
        //
        params = MyMalloc(sizeof(ACTIONTHREADPARAMS));
        if (params) {
           SetProp(hdlg,ThreadParamsPropertyName,(HANDLE)params);
   
           params->hdlg = hdlg;
           params->UserData = Params->UserData;

        } else {
           OutOfMemory();
        }

        //
        // Create the worker thread. The worker thread
        // should have a sleep(100) as its first thing to let the
        // billboard finish coming up. And when it's done it has
        // to send us a WM_COMMAND as notification.
        //
        h = CreateThread(
                NULL,
                0,
                Params->ThreadEntry,
                params,
                CREATE_SUSPENDED,
                &ThreadId
                );

        if(h == NULL) {
            OutOfMemory();
        } else {
            PostMessage(hdlg,WMX_I_AM_READY,0,(LPARAM)h);
        }

        break;

    case WMX_I_AM_READY:

        //
        // Dialog is displayed; kick off the worker thread.
        //
        ResumeThread((HANDLE)lParam);
        CloseHandle((HANDLE)lParam);
        break;

    case WM_COMMAND:

        //
        // End the dialog.
        //
        if(LOWORD(wParam) == IDOK) {

            {
               HANDLE tmpparams = GetProp(hdlg,ThreadParamsPropertyName);
               if (tmpparams) {
                  MyFree((PVOID)tmpparams);
               }
            }            

            EndDialog(hdlg,(int)lParam);
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


DWORD
ActionWithBillboard(
    IN PTHREAD_START_ROUTINE ThreadEntry,
    IN HWND                  OwnerWindow,
    IN UINT                  CaptionStringId,
    IN UINT                  TextStringId,
    IN PVOID                 UserData
    )

/*++

Routine Description:

    Main entry point for carrying out an action with a 'please wait'
    dialog box.

Arguments:

    ThreadEntry - supplies the address of a worker thread that will carry
        out the action.

    OwnerWindow - supplies the window handle of the window that is to own
        the billboard dialog.

    CaptionStringId - supplies the resource string id of the string to be
        used as the billboard caption.

    TextStringId - supplies the resource string id of the string ot be
        used as the billboard text.

    UserData - supplies a caller-defined value that is meaningful to the
        worker thread. This valus is passed to the thread as the UserData
        member of the ACTIONTHREADPARAMS structure.

Return Value:

    The value returned by the action's worker thread.

--*/

{
    BILLBOARDPARAMS p;
    DWORD i;

    //
    // Load the two strings and create a params structure.
    //
    p.Caption = MyLoadString(CaptionStringId);
    p.Text = MyLoadString(TextStringId);
    p.ThreadEntry = ThreadEntry;
    p.UserData = UserData;
    p.OwnerWindow = OwnerWindow;

    i = (DWORD)DialogBoxParam(
                  hInst,
                  MAKEINTRESOURCE(DLG_BILLBOARD),
                  OwnerWindow,
                  DlgProcBillboard,
                  (LPARAM)&p
                  );

    MyFree(p.Text);
    MyFree(p.Caption);

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\dialogs.h ===
#define DLG_PROMPT                  100
#define IDT_MAIN_CAPTION            101
#define IDC_LOCATION_FRAME          104
#define IDB_BROWSE                  105
#define IDC_LOCATION                106
#define DLG_INSTALL                 200
#define IDC_INSTALL_TO              203
#define IDT_INSTALL_FREESPACE       207
#define DLG_BILLBOARD               300
#define IDT_BILLBOARD_TEXT          301
#define ID_HELP                     102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\rc_ids.h ===
#define IDS_CANT_START_WINHELP      3
#define IDS_BAD_LOCATION            4
#define IDS_BROWSE_TITLE            5
#define IDS_FILETYPE_NAME           6
#define IDS_USAGE                   7
#define IDS_FILELIST_CAPTION        8
#define IDS_FILELIST                9
#define IDS_LAYOUT_INF_DAMAGED      10

#define IDI_MAIN                    0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\makefile.inc ===
obj\$(TARGET_DIRECTORY)\books.res: books.rc dialogs.dlg dialogs.h msg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\books.h ===
#include <windows.h>
#include <commdlg.h>
#include "rc_ids.h"
#include "dialogs.h"
#include "msg.h"


//
// Define enumeration type for product type.
// The user can override the product type on the command line
// (ie, if we are on a workstation normally we look for worksttion
// books, but user can override this).
//
typedef enum {
    ForceNone,
    ForceServer,
    ForceWorkstation
} ForceProduct;


//
// module handle
//
extern HANDLE hInst;

//
// Handle of main icon.
//
extern HICON MainIcon;

//
// Command line parameters
//
extern ForceProduct CmdLineForce;

//
// Fixed name of the help file. This is dependent on whether
// this is server or workstation and is set in FixupNames().
//
extern PWSTR HelpFileName;

//
// Path on CD-ROM where online books files are located.
// We "just know" this value.
//
extern PWSTR PathOfBooksFilesOnCd;

//
// Name of profile value that stores the last known location
// of the online books helpfile. This value varies depending
// on the product (workstation/server).
//
extern PWSTR BooksProfileLocation;

//
// Profile routines. These actually operate on registry data.
// See bkprof.c.
//
PWSTR
MyGetProfileValue(
    IN PWSTR ValueName,
    IN PWSTR DefaultValue
    );

BOOL
MySetProfileValue(
    IN  PWSTR ValueName,
    OUT PWSTR Value
    );


//
// Routines to manipulate help files and help file names.
// See bkhlpfil.c.
//
VOID
FormHelpfilePaths(
    IN  WCHAR Drive,            OPTIONAL
    IN  PWSTR Path,
    IN  PWSTR FilenamePrepend,  OPTIONAL
    OUT PWSTR Filename,
    OUT PWSTR Directory         OPTIONAL
    );

BOOL
CheckHelpfilePresent(
    IN PWSTR Path
    );

VOID
FireUpWinhelp(
    IN WCHAR Drive, OPTIONAL
    IN PWSTR Path
    );


//
// Memory manipulation routines. Note that MyMalloc always
// succeeds (it does not return if it fails).
// See bkmem.c.
//
VOID
OutOfMemory(
    VOID
    );

PVOID
MyMalloc(
    IN DWORD Size
    );

VOID
MyFree(
    IN PVOID Block
    );


//
// Resource manipulation routines.
// See bkres.c.
//
PWSTR
MyLoadString(
    IN UINT StringId
    );

PWSTR
RetreiveMessage(
    IN UINT MessageId,
    ...
    );

int
MessageBoxFromMessage(
    IN HWND Owner,
    IN UINT MessageId,
    IN UINT CaptionStringId,
    IN UINT Style,
    ...
    );


//
// Routine to install the on-line books to a local hard drive.
// See bkinst.c.
//
BOOL
DoInstall(
    IN OUT PWSTR *Location
    );


//
// Routine to carry out an action with a billboard
// telling the user what is going on.
// See bkthrdlg.c.
//
DWORD
ActionWithBillboard(
    IN PTHREAD_START_ROUTINE ThreadEntry,
    IN HWND                  OwnerWindow,
    IN UINT                  CaptionStringId,
    IN UINT                  TextStringId,
    IN PVOID                 UserData
    );

//
// Structure that is passed to ThreadEntry.
//
typedef struct _ACTIONTHREADPARAMS {
    HWND hdlg;
    PVOID UserData;
} ACTIONTHREADPARAMS, *PACTIONTHREADPARAMS;


//
// Miscellaneous utility routines.
// See bkutils.c.
//
WCHAR
LocateCdRomDrive(
    VOID
    );

BOOL
IsCdRomInDrive(
    IN WCHAR Drive,
    IN PWSTR TagFile
    );

UINT
MyGetDriveType(
    IN WCHAR Drive
    );

BOOL
DoesFileExist(
    IN PWSTR File
    );

PWSTR
DupString(
    IN PWSTR String
    );

VOID
CenterDialogOnScreen(
    IN HWND hdlg
    );

VOID
CenterDialogInWindow(
    IN HWND hdlg,
    IN HWND hwnd
    );

VOID
MyError(
    IN HWND Owner,
    IN UINT StringId,
    IN BOOL Fatal
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\bkutils.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bkutils.c

Abstract:

    Miscellaneous utility functions for online books program.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"


UINT
MyGetDriveType(
    IN WCHAR Drive
    )

/*++

Routine Description:

    Determine the type of a drive (removeable, fixed, net, cd, etc).

Arguments:

    Drive - supplies drive letter of drive whose type is needed.

Return Value:

    Same set of values as returned by GetDriveType() API.

--*/

{
    WCHAR DriveName[3];

    DriveName[0] = Drive;
    DriveName[1] = L':';
    DriveName[2] = 0;

    return GetDriveType(DriveName);
}


WCHAR
LocateCdRomDrive(
    VOID
    )

/*++

Routine Description:

    Determine if a CD-ROM drive is attached to the computer and
    return its drive letter. If there's more than one cd-rom drive
    the one with the alphabetically lower drive letter is returned.

Arguments:

    None.

Return Value:

    Drive letter of CD-ROM drive, or 0 if none could be located.

--*/

{
    WCHAR Drive;
    UINT OldMode;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_CDROM) {
            SetErrorMode(OldMode);
            return Drive;
        }
    }

    SetErrorMode(OldMode);
    return 0;
}


BOOL
IsCdRomInDrive(
    IN WCHAR Drive,
    IN PWSTR TagFile
    )

/*++

Routine Description:

    Determine if a particular CD-ROM is in a drive,
    based on the presence of a given tagfile.

Arguments:

    Drive - supplies drive letter of drive to be checked
        for presence of the tagfile.

    TagFile - supplies drive-relative path (from root)
        of the file whose presence validates the presence
        of a volume.

Return Value:

    Boolean value indicating whether the tagfile could be
    accessed.

--*/

{
    WCHAR Path[MAX_PATH];

    if(*TagFile == L'\\') {
        TagFile++;
    }

    wsprintf(Path,L"%c:\\%s",Drive,TagFile);

    return DoesFileExist(Path);
}


BOOL
DoesFileExist(
    IN PWSTR File
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.

Arguments:

    File - supplies full path of file whose accessibility
        is in question.

Return Value:

    Boolean value indicating whether file is accessible.

--*/

{
    UINT OldMode;
    HANDLE h;
    WIN32_FIND_DATA FindData;

    //
    // Avoid system popups.
    //
    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    h = FindFirstFile(File,&FindData);

    SetErrorMode(OldMode);

    if(h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    FindClose(h);
    return(TRUE);
}


PWSTR
DupString(
    IN PWSTR String
    )

/*++

Routine Description:

    Duplicate a string and return a pointer to the copy.

    This routine always succeeds.

Arguments:

    String - supplies pointer to the string to be duplicated.

Return Value:

    Pointer to copy of string. Caller can free this buffer with
    MyFree when the copy is no longer needed.

--*/

{
    PWSTR p = MyMalloc((lstrlen(String)+1)*sizeof(WCHAR));

    lstrcpy(p,String);

    return p;
}


VOID
CenterDialogOnScreen(
    IN HWND hdlg
    )

/*++

Routine Description:

    Center a window on the screen.

Arguments:

    hdlg - supplies handle of window to be centered on the screen.

Return Value:

    None.

--*/

{
    RECT  rcWindow;
    LONG  x,y,w,h;
    POINT point;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN),
          sy = GetSystemMetrics(SM_CYSCREEN);

    GetWindowRect (hdlg,&rcWindow);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = (sx - w) / 2;
    y = (sy - h) / 2;

    MoveWindow(hdlg,x,y,w,h,FALSE);
}


VOID
CenterDialogInWindow(
    IN HWND hdlg,
    IN HWND hwnd
    )

/*++

Routine Description:

    Center a dialog relative to a window.

Arguments:

    hdlg - supplies handle of window to be centered relative to a window

    hwnd - supplies handle of window relative to which hdlg is to be centered.

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,y,w,h;
    POINT point;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN),
          sy = GetSystemMetrics(SM_CYSCREEN);

    point.x = point.y = 0;
    ClientToScreen(hwnd,&point);
    GetWindowRect (hdlg,&rcWindow);
    GetClientRect (hwnd,&rcFrame );

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    if (x + w > sx) {
        x = sx - w;
    } else if (x < 0) {
        x = 0;
    }
    if (y + h > sy) {
        y = sy - h;
    } else if (y < 0) {
        y = 0;
    }

    MoveWindow(hdlg,x,y,w,h,FALSE);
}


VOID
MyError(
    IN HWND Owner,
    IN UINT StringId,
    IN BOOL Fatal
    )

/*++

Routine Description:

    Display message box whose text is taken from the application's
    string resources. The caption will be "Error"; the icon will be
    ICONSTOP for fatal errors and ICONINFORMATION for nonfatal ones.

Arguments:

    Owner - supplies the window handle of the window that is to own
        the message box.

    StringId - supplies the string Id of the message to be displayed.

    Fatal - if TRUE, this is a fatal error and this routine does not
        return to the caller but exits via ExitProcess().

Return Value:

    Returns only if the error is non-fatal.

--*/

{
    PWSTR p;

    //
    // Load error string
    //
    p = MyLoadString(StringId);

    //
    // Put up message box indicating the error.
    //
    MessageBox(
        Owner,
        p,
        NULL,
        MB_OK | MB_SETFOREGROUND | MB_TASKMODAL | (Fatal ? MB_ICONSTOP : MB_ICONINFORMATION)
        );

    if(Fatal) {
        ExitProcess(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\sbentry.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.h

Abstract:

    Contains the OS boot entry and boot options
    abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

//
// Allocate & Deallocate routines
//
typedef void* (* SBEMemAllocateRoutine)(size_t  Size);
typedef void (* SBEMemFreeRoutine)(void *Memory);

extern SBEMemAllocateRoutine    AllocRoutine;
extern SBEMemFreeRoutine        FreeRoutine;


#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))


//
// Internal attributes for the boot entry
//
#define OSBE_ATTRIBUTE_NEW      0x00000001
#define OSBE_ATTRIBUTE_DELETED  0x00000002
#define OSBE_ATTRIBUTE_WINDOWS  0x00000004
#define OSBE_ATTRIBUTE_DIRTY    0x10000000


//
// OS_BOOT_ENTRY abstraction
//
typedef struct _OS_BOOT_ENTRY   *POS_BOOT_ENTRY;
typedef struct _OS_BOOT_OPTIONS *POS_BOOT_OPTIONS;

typedef VOID (* OSBEDeleteMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef BOOLEAN (* OSBEFlushMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef struct _OS_BOOT_ENTRY {
    //
    // Data members
    //
    ULONG   Version;
    ULONG   Id;    
    WCHAR   FriendlyName[MAX_PATH];
    WCHAR   OsLoaderVolumeName[MAX_PATH];
    WCHAR   OsLoaderPath[MAX_PATH];
    WCHAR   BootVolumeName[MAX_PATH];
    WCHAR   BootPath[MAX_PATH];
    WCHAR   OsLoadOptions[MAX_PATH];
    ULONG   Attributes;
    POS_BOOT_OPTIONS    BootOptions;
    POS_BOOT_ENTRY      NextEntry;

    //
    // Methods
    //
    OSBEDeleteMethod    Delete;
    OSBEFlushMethod     Flush;
} OS_BOOT_ENTRY;

#define OSBE_IS_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBE_IS_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_NEW)
#define OSBE_IS_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DELETED)
#define OSBE_IS_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_WINDOWS)

#define OSBE_SET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBE_SET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_NEW)
#define OSBE_SET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DELETED)
#define OSBE_SET_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_WINDOWS)

#define OSBE_RESET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)
#define OSBE_RESET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_NEW)
#define OSBE_RESET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DELETED)
#define OSBE_RESET_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_WINDOWS)



//
// OS_BOOT_OPTIONS abstraction
//
typedef VOID (* OSBODeleteMethod)(
                    IN POS_BOOT_OPTIONS This
                    );

typedef POS_BOOT_ENTRY (* OSBOAddNewBootEntryMethod)(
                            IN POS_BOOT_OPTIONS This,
                            IN PCWSTR            FriendlyName,
                            IN PCWSTR            OsLoaderVolumeName,
                            IN PCWSTR            OsLoaderPath,
                            IN PCWSTR            BootVolumeName,
                            IN PCWSTR            BootPath,
                            IN PCWSTR            OsLoadOptions
                            );

typedef BOOLEAN (* OSBODeleteBootEntryMethod)(
                        IN POS_BOOT_OPTIONS This,
                        IN POS_BOOT_ENTRY   BootEntry
                        );

typedef BOOLEAN (* OSBOFlushMethod)(
                    IN POS_BOOT_OPTIONS This 
                    );

typedef struct _OS_BOOT_OPTIONS {
    //
    // Data members
    //
    ULONG               Version;
    ULONG               Attributes;
    ULONG               Timeout;
    POS_BOOT_ENTRY      CurrentEntry;
    POS_BOOT_ENTRY      BootEntries;
    ULONG               EntryCount;
    PULONG              BootOrder;
    ULONG               BootOrderCount;

    //
    // Methods
    //
    OSBODeleteMethod            Delete;
    OSBOFlushMethod             Flush;
    OSBOAddNewBootEntryMethod   AddNewBootEntry;
    OSBODeleteBootEntryMethod   DeleteBootEntry;    
} OS_BOOT_OPTIONS;


#define OSBO_IS_DIRTY(_osbo)        (((POS_BOOT_OPTIONS)(_osbo))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBO_SET_DIRTY(_osbo)       (((POS_BOOT_OPTIONS)(_osbo))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBO_RESET_DIRTY(_osbo)     (((POS_BOOT_OPTIONS)(_osbo))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)

//
// OS_BOOT_ENTRY Methods
//
PCWSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

PCWSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

__inline
VOID
OSBEDelete(
    IN POS_BOOT_ENTRY This
    )
{
    if (This) {
        (This->Delete)(This);
    }
}

__inline
BOOLEAN
OSBEFlush(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->Flush(This) : FALSE;
}


__inline
ULONG
OSBEGetId(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->Id : (-1);
}

__inline
PCWSTR
OSBEGetFriendlyName(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCWSTR
OSBESetFriendlyName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->FriendlyName);
        
        wcsncpy(This->FriendlyName, Name, Size - 1);
        This->FriendlyName[Size - 1] = UNICODE_NULL;
        NewName = This->FriendlyName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderVolumeName : NULL;
}

__inline
PCWSTR
OSBESetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderVolumeName);
        
        wcsncpy(This->OsLoaderVolumeName, Name, Size - 1);
        This->OsLoaderVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoaderPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderPath : NULL;
}

__inline
PCWSTR
OSBESetOsLoaderPath(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderPath);
        
        wcsncpy(This->OsLoaderPath, Name, Size - 1);
        This->OsLoaderPath[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetBootVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootVolumeName : NULL;
}

__inline
PCWSTR
OSBESetBootVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootVolumeName);        
    
        wcsncpy(This->BootVolumeName, Name, Size - 1);
        This->BootVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->BootVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetBootPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootPath : NULL;
}

__inline
PCWSTR
OSBESetBootPath(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootPath);        
    
        wcsncpy(This->BootPath, Name, Size - 1);
        This->BootPath[Size - 1] = UNICODE_NULL;
        NewName = This->BootPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoadOptions(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoadOptions : NULL;
}
    
__inline
PCWSTR
OSBESetOsLoadOptions(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR LoadOptions
    )
{
    WCHAR Buffer[MAX_PATH];
    PWSTR NewOptions = NULL;
    
    if (This && LoadOptions) {
        ULONG   Size = ARRAY_SIZE(This->OsLoadOptions);
        
        wcscpy(Buffer, LoadOptions);
        _wcsupr(Buffer);
        wcsncpy(This->OsLoadOptions, Buffer, Size - 1);
        This->OsLoadOptions[Size - 1] = UNICODE_NULL;
        NewOptions = This->OsLoadOptions;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewOptions;
}

//
// OS_BOOT_OPTIONS Methods
//   
__inline
BOOLEAN
OSBOFlush(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Flush(This)) : FALSE;
}
    
__inline    
VOID
OSBODelete(
    IN POS_BOOT_OPTIONS This
    )
{
    if (This) {
        This->Delete(This);
    }        
}

__inline
POS_BOOT_ENTRY
OSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->AddNewBootEntry(This,
                            FriendlyName,
                            OsLoaderVolumeName,
                            OsLoaderPath,
                            BootVolumeName,
                            BootPath,
                            OsLoadOptions);                    
        OSBO_SET_DIRTY(This);
    }

    return Entry;
}


__inline
POS_BOOT_ENTRY
OSBOGetActiveBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->CurrentEntry;
    }
    
    return Entry;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );
    

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );

POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    );

POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    );

ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    );

POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );    

__inline
ULONG
OSBOGetTimeOut(
    IN  POS_BOOT_OPTIONS    This
    )
{
    return (This) ? This->Timeout : 0;
}

__inline
ULONG
OSBOSetTimeOut(
    IN  POS_BOOT_OPTIONS    This,
    IN  ULONG Timeout
    )
{
    ULONG   OldTimeout = 0;

    if (This) {
        OldTimeout = This->Timeout;
        This->Timeout = Timeout;
        OSBE_SET_DIRTY(This);
    }

    return OldTimeout;
}

__inline
ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->EntryCount;
    }

    return Count;
}


__inline
ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->BootOrderCount;
    }

    return Count;
}

__inline
ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    )
{
    ULONG Entry = -1;

    if (Index < OSBOGetOrderedBootEntryCount(This)) {            
        Entry = This->BootOrder[Index];
    }

    return Entry;
}

__inline
BOOLEAN
OSBOLibraryInit(
    SBEMemAllocateRoutine AllocFunction,
    SBEMemFreeRoutine FreeFunction
    )
{
    BOOLEAN Result = FALSE;

    if (AllocFunction && FreeFunction) {
        AllocRoutine = AllocFunction;
        FreeRoutine = FreeFunction;

        Result = TRUE;
    }

    return Result;
}
    

//
// memory allocation & deallocation routines
//
__inline
void*
__cdecl
SBE_MALLOC(
    IN  size_t  Size
    )
{
    return AllocRoutine ? AllocRoutine(Size) : NULL;
}

__inline
void    
__cdecl 
SBE_FREE(
    IN  void *Memory
    )
{
    if (Memory && FreeRoutine) {
        FreeRoutine(Memory);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\books\ntbooks.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    books.c

Abstract:

    Main module for on-line reference books installation/invocation.

Author:

    Ted Miller (tedm) 5-Jan-1995

Revision History:

--*/


#include "books.h"
#include <setupapi.h>
#include <stdlib.h>

WCHAR TagFile[MAX_PATH];
WCHAR CdRomName[250];

//
// Module handle
//
HANDLE hInst;

//
// Handle of main icon.
//
HICON MainIcon;

//
// Command line parameters
//
ForceProduct CmdLineForce = ForceNone;
BOOL CmdLineForcePrompt = FALSE;


typedef struct _PROMPTDIALOGPARAMS {
    PWSTR MainMessage;
    PWSTR InitialLocation;
    PWSTR FinalLocation;
} PROMPTDIALOGPARAMS, *PPROMPTDIALOGPARAMS;


INT_PTR
CALLBACK
DlgProcPrompt(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
FixupNames(
    VOID
    );

VOID
DoBooks(
    IN WCHAR CdRomDrive,
    IN PWSTR PreviousLocation
    );

BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    );

VOID
Usage(
    VOID
    );

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    PWSTR BooksLocation;
    WCHAR CdRomDrive;
    WCHAR Path[MAX_PATH];

    hInst = GetModuleHandle(NULL);

    MainIcon = LoadIcon(hInst,MAKEINTRESOURCE(IDI_MAIN));

    if(!ParseArgs(argc,argv)) {
        Usage();
    }

    FixupNames();

    //
    // Get BooksLocation profile value.
    //
    BooksLocation = MyGetProfileValue(BooksProfileLocation,L"");

	if (!BooksLocation[0] && !CmdLineForcePrompt) {

		//
		// Look for the Help file in its normal location and make
		// sure it's present. If it is, set BooksLocation.
		//
		WCHAR pwcsHelpPath[_MAX_PATH];

		if (GetWindowsDirectory(pwcsHelpPath, _MAX_PATH)) {
			lstrcat(pwcsHelpPath, L"\\Help");
			if (DoesFileExist(pwcsHelpPath))
				BooksLocation = DupString(pwcsHelpPath);
		}
	}

    if(BooksLocation[0] && !CmdLineForcePrompt) {

        //
        // BooksLocation has been set previously. This is no guarantee that
        // the location is currently accessible. Check to see if the help file
        // is available. If not we will prompt the user.
        //
        if(CheckHelpfilePresent(BooksLocation)) {

            //
            // The help file is accessible. Fire up winhelp.
            //
            FireUpWinhelp(0,BooksLocation);
        } else {

            //
            // The help file is not currently accessible.
            //
            DoBooks(LocateCdRomDrive(),BooksLocation);
        }

    } else {

        //
        // Books location was not specified already.
        // In this case look for a cd-rom drive.
        //
        if(CdRomDrive = LocateCdRomDrive()) {

            //
            // Form the path of the helpfile on the CD
            //
            Path[0] = CdRomDrive;
            Path[1] = L':';
            Path[2] = 0;
            lstrcat(Path,PathOfBooksFilesOnCd);

            //
            // Found a cd-rom drive. Look for the relevent nt cd in there
            // and make sure the help file is there too just for good measure.
            //
            if(!CmdLineForcePrompt
            && IsCdRomInDrive(CdRomDrive,TagFile)
            && CheckHelpfilePresent(Path))
            {
                //
                // The nt cd-rom is in there. Fire up winhelp.
                //
                FireUpWinhelp(CdRomDrive,PathOfBooksFilesOnCd);

            } else {

                //
                // Prompt for the nt cd-rom, or an alternate location.
                //
                DoBooks(CdRomDrive,NULL);
            }
        } else {

            //
            // No cd-rom drive; prompt for an alternate location.
            //
            DoBooks(0,NULL);
        }
    }

    return 0;
}


VOID
Usage(
    VOID
    )
{
    MyError(NULL,IDS_USAGE,TRUE);
}


BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    )
{
    int i;

    for(argc--,i=1; argc; argc--,i++) {

        if((argv[i][0] == '-') || (argv[i][0] == '/')) {

            switch(argv[i][1]) {

            case 's':
            case 'S':

                //
                // accept /s or /server
                //
                if(!argv[i][2]) {
                    CmdLineForce = ForceServer;
                } else {
                    if(lstrcmpiA(argv[i]+1,"server")) {
                        return(FALSE);
                    }
                    CmdLineForce = ForceServer;
                }

                break;

            case 'w':
            case 'W':

                //
                // accept /w or /workstation
                //
                if(!argv[i][2]) {
                    CmdLineForce = ForceWorkstation;
                } else {
                    if(lstrcmpiA(argv[i]+1,"workstation")) {
                        return(FALSE);
                    }
                    CmdLineForce = ForceWorkstation;
                }

                break;

            case 'n':
            case 'N':

                //
                // Ignore remembered location (ie, *N*ew location)
                //
                if(argv[i][2]) {
                    return(FALSE);
                } else {
                    CmdLineForcePrompt = TRUE;
                }
                break;

            default:

                return(FALSE);
            }
        } else {

            //
            // All args are switches
            //
            return(FALSE);
        }
    }

    return(TRUE);
}


VOID
DoBooks(
    IN WCHAR CdRomDrive,
    IN PWSTR PreviousLocation
    )
{
    DWORD Id;
    INT_PTR DialogReturn;
    WCHAR CurrentDirectory[MAX_PATH];
//  UINT DriveType;
    PROMPTDIALOGPARAMS Params;

    //
    // The dialog looks slightly different depending on
    // whether there is a CD-ROM drive in the system.
    //
    // If there is we say something like "insert the cdrom in
    // the drive or give an alternate location." If there is not
    // we say something like "tell us where the files are."
    //
//retry:

    if(PreviousLocation) {

        Id = CdRomDrive ? MSG_PROMPT_CD : MSG_PROMPT_NO_CD;
        Params.InitialLocation = PreviousLocation;

    } else {

        Id = CdRomDrive ? MSG_PROMPT_CD_FIRST : MSG_PROMPT_NO_CD_FIRST;

        if(CdRomDrive) {

            wsprintf(CurrentDirectory,L"%c:%s",CdRomDrive,PathOfBooksFilesOnCd);

        } else {
            GetCurrentDirectory(
                sizeof(CurrentDirectory)/sizeof(CurrentDirectory[0]),
                CurrentDirectory
                );
        }

        Params.InitialLocation = CurrentDirectory;
    }

    Params.MainMessage = RetreiveMessage(Id,PreviousLocation,CdRomName);

    DialogReturn = DialogBoxParam(
                        hInst,
                        MAKEINTRESOURCE(DLG_PROMPT),
                        NULL,
                        DlgProcPrompt,
                        (LPARAM)&Params
                        );

    MyFree(Params.MainMessage);

    if(DialogReturn) {

        //
        // Removed the copy stuff for now, as it's not done yet
        // and not likely to be completed any time soon.
        //
#if 0
        //
        // If the path is a UNC path this should be 0 (drive type unknown)
        // so the test below will work just fine
        //
        DriveType = MyGetDriveType(Params.FinalLocation[0]);

        //
        // If there is no previous location and the files are
        // not on a local hard drive offer to install them on
        // the hard drive.
        //
        // Treat removable drives like hard drives, because it's unlikely
        // the files are on a floppy and removable hard drives come back as
        // DRIVE_REMOVABLE, not DRIVE_FIXED.
        //
        if(!PreviousLocation && (DriveType != DRIVE_FIXED) && (DriveType != DRIVE_REMOVABLE)) {

            if(!DoInstall(&Params.FinalLocation)) {
                MyFree(Params.FinalLocation);
                PreviousLocation = NULL;
                goto retry;
            }
        }
#endif

        FireUpWinhelp(0,Params.FinalLocation);
    }
}


VOID
FixupNames(
    VOID
    )
{
    HKEY hKey;
    LONG l;
    DWORD DataType;
    WCHAR Data[128];
    DWORD DataSize;
    BOOL IsServer;
    BOOL b;
    UINT SourceId;
    HINF Inf;

    //
    // Figure out if this is a server or workstation and fix up
    // the global cd-rom name and tagfile variables accordingly.
    //
    // Open HKLM\System\CCS\Control\ProductOptions and check ProductType value.
    // If it's 'winnt' then this is a workststion. Otherwise assume server.
    //
    switch(CmdLineForce) {

    case ForceServer:

        IsServer = TRUE;
        break;

    case ForceWorkstation:

        IsServer = FALSE;
        break;

    case ForceNone:
    default:

        IsServer= FALSE;

        l = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\ProductOptions",
                0,
                KEY_READ,
                &hKey
                );

        if(l == NO_ERROR) {

            DataSize = sizeof(Data)/sizeof(Data[0]);

            l = RegQueryValueEx(
                    hKey,
                    L"ProductType",
                    0,
                    &DataType,
                    (LPBYTE)Data,
                    &DataSize
                    );

            RegCloseKey(hKey);

            if((l == NO_ERROR) && (DataType == REG_SZ) && lstrcmpi(Data,L"winnt")) {
                IsServer = TRUE;
            }
        }

        break;
    }

    if(IsServer) {
        HelpFileName = L"WINDOWS.CHM";
        BooksProfileLocation = L"ServerBooksLocation";
    } else {
        HelpFileName = L"WINDOWS.CHM";
        BooksProfileLocation = L"WorkstationBooksLocation";
    }

    //
    // Get information about the NT CD-ROM. We assume that the books files
    // are on the same CD as the basic system, which also must have
    // ntoskrnl.exe on it.
    //
    b = FALSE;
    Inf = SetupOpenMasterInf();
    if(Inf != INVALID_HANDLE_VALUE) {

        if(SetupGetSourceFileLocation(Inf,NULL,L"NTOSKRNL.EXE",&SourceId,NULL,0,NULL)) {

            b = SetupGetSourceInfo(
                    Inf,
                    SourceId,
                    SRCINFO_TAGFILE,
                    TagFile,
                    sizeof(TagFile)/sizeof(WCHAR),
                    NULL
                    );

            if(b) {

                b = SetupGetSourceInfo(
                        Inf,
                        SourceId,
                        SRCINFO_DESCRIPTION,
                        CdRomName,
                        sizeof(CdRomName)/sizeof(WCHAR),
                        NULL
                        );
            }
        }

        SetupCloseInfFile(Inf);
    }

    if(!b) {
        MyError(NULL,IDS_LAYOUT_INF_DAMAGED,TRUE);
    }
}




////////////////////////////////////////////////////////


PWSTR PropertyName = L"__mydlgparams";

BOOL
PromptDialogOk(
    IN HWND hdlg
    )
{
    WCHAR Location[MAX_PATH];
    UINT Length;
    PPROMPTDIALOGPARAMS DlgParams;

    DlgParams = (PPROMPTDIALOGPARAMS)GetProp(hdlg,PropertyName);

    //
    // Get the text the user has typed into the edit control
    // as the location of the files.
    //
    Length = GetDlgItemText(hdlg,IDC_LOCATION,Location,MAX_PATH);

    //
    // Remove trailing backslash if any.
    //
    if(Length && (Location[Length-1] == L'\\')) {
        Location[Length-1] = 0;
    }

    //
    // See whether the online books help file is at that location.
    //
    if(CheckHelpfilePresent(Location)) {
        DlgParams->FinalLocation = DupString(Location);
        return(TRUE);
    }

    //
    // See whether the online books help file is in the subdirectory
    // where it would be on the CD.
    //
    lstrcat(Location,PathOfBooksFilesOnCd);

    if(CheckHelpfilePresent(Location)) {
        DlgParams->FinalLocation = DupString(Location);
        return(TRUE);
    }

    return(FALSE);
}


BOOL
PromptDialogBrowse(
    IN HWND hdlg
    )
{
    BOOL b;
    OPENFILENAME on;
    WCHAR Filter[256];
    WCHAR Location[MAX_PATH];
    PWSTR Title;
    WCHAR InitialDir[MAX_PATH];
    PWSTR p;
    DWORD len;

    p = MyLoadString(IDS_FILETYPE_NAME);
    lstrcpy(Filter,p);
    MyFree(p);
    len = lstrlen(Filter)+1;
    lstrcpy(Filter+len,HelpFileName);
    len += lstrlen(HelpFileName) + 1;
    Filter[len] = 0;

    lstrcpy(Location,HelpFileName);
    Title = MyLoadString(IDS_BROWSE_TITLE);
    GetDlgItemText(hdlg,IDC_LOCATION,InitialDir,MAX_PATH);

    on.lStructSize = sizeof(on);
    on.hwndOwner = hdlg;
    on.hInstance = hInst;
    on.lpstrFilter = Filter;
    on.lpstrCustomFilter = NULL;
    on.nMaxCustFilter = 0;
    on.nFilterIndex = 1;
    on.lpstrFile = Location;
    on.nMaxFile = MAX_PATH;
    on.lpstrFileTitle = NULL;
    on.nMaxFileTitle = 0;
    on.lpstrInitialDir = InitialDir;
    on.lpstrTitle = Title;
    on.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    on.nFileOffset = 0;
    on.nFileExtension = 0;
    on.lpstrDefExt = L"HLP";
    on.lCustData = 0;
    on.lpfnHook = NULL;
    on.lpTemplateName = NULL;

    b = GetOpenFileName(&on);

    MyFree(Title);

    if(b) {
        //
        // User said ok. The full path of the help file is in
        // Location. Ignore the actual filename; the path is
        // what we want.
        //
        Location[on.nFileOffset ? on.nFileOffset-1 : 0] = 0;

        //
        // Set the text in the edit cntrol so the dialog
        // can fetch it later.
        //
        SetDlgItemText(hdlg,IDC_LOCATION,Location);
    }

    return b;
}



INT_PTR
CALLBACK
DlgProcPrompt(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PPROMPTDIALOGPARAMS DlgParams;

    switch(msg) {

    case WM_INITDIALOG:

        CenterDialogOnScreen(hdlg);

        DlgParams = (PPROMPTDIALOGPARAMS)lParam;

        //
        // Set the main text message.
        //
        SetDlgItemText(hdlg,IDT_MAIN_CAPTION,DlgParams->MainMessage);

        //
        // Set the text in the edit control and select all of it.
        // Also set focus to that control.
        //
        SetDlgItemText(hdlg,IDC_LOCATION,DlgParams->InitialLocation);
        SendDlgItemMessage(hdlg,IDC_LOCATION,EM_SETSEL,0,(LPARAM)(-1));
        SendDlgItemMessage(hdlg,IDC_LOCATION,EM_LIMITTEXT,MAX_PATH-1,0);
        SetFocus(GetDlgItem(hdlg,IDC_LOCATION));

        //
        // Remember the init params
        //
        if(!SetProp(hdlg,PropertyName,(HANDLE)lParam)) {
            OutOfMemory();
        }

        //
        // Tell windows we set the focus.
        //
        return(FALSE);

    case WM_COMMAND:

        switch(HIWORD(wParam)) {

        case BN_CLICKED:

            switch(LOWORD(wParam)) {

            case IDB_BROWSE:

                if(!PromptDialogBrowse(hdlg)) {
                    break;
                }
                // FALL THROUGH IF BROWSE WAS SUCCESSFUL

            case IDOK:

                if(PromptDialogOk(hdlg)) {
                    EndDialog(hdlg,TRUE);
                } else {
                    MyError(hdlg,IDS_BAD_LOCATION,FALSE);
                }

                return(FALSE);

            case IDCANCEL:

                EndDialog(hdlg,FALSE);
                return(FALSE);
            }

            break;
        }

        break;

    case WM_QUERYDRAGICON:

        return(MainIcon != NULL);

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\bootini\bootient.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    bootient.c

Abstract:

    Contains the Boot.ini OS boot entry and boot options
    abstraction implementation.

Author:


Revision History:

    None.

--*/

#include <bootient.h>

//
// defines
//
#define BOIOS_SECTION_NAME_START    TEXT('[')
#define BOIOS_SECTION_NAME_END      TEXT(']')
#define BOIOS_SECTION_NAME_START_STR    TEXT("[")
#define BOIOS_SECTION_NAME_END_STR      TEXT("]")


#define BOIOS_BOOTLOADER_SECTION    TEXT("boot loader")
#define BOIOS_OS_SECTION            TEXT("operating systems")
#define BOIOS_TIMEOUT_KEY           TEXT("timeout=")
#define BOIOS_DEFAULT_KEY           TEXT("default=")

#define MAX_BOOT_INI_SIZE           (4 * 1024)

static
PTSTR
BOIOSFixupString(
    IN PTSTR String,
    IN PTSTR SpecialChars
    )
{    
    PTSTR   ResultStr = String;

    //
    // Verify arguments
    //
    if (ResultStr && SpecialChars) {        
        ULONG   Index;
        BOOLEAN DoneWithStart = FALSE;
        TCHAR   Buffer[MAX_PATH * 4] = {0};
        TCHAR   NextIndex = 0;        

        //
        // skip unwanted characters
        //
        for (Index = 0; String[Index]; Index++) {
            if (!_tcschr(SpecialChars, String[Index])) {
                Buffer[NextIndex++] = String[Index];
            }
        }

        //
        // Null terminate the string
        //
        Buffer[NextIndex] = 0;

        if (!NextIndex) {
            ResultStr = NULL;
        } else {
            //
            // Copy back the new string to the 
            // input / output buffer
            //
            _tcscpy(ResultStr, Buffer);
        }
    }

    return ResultStr;
}

//
// BOI_OS_SECTION Methods
//
PBOI_SECTION
BOISectionCreate(
    IN PCTSTR   SectionData
    )
{
    PBOI_SECTION    This = NULL;

    if (SectionData) {
        PTSTR Buffer = (PTSTR)SBE_MALLOC((_tcslen(SectionData) + 1) * sizeof(TCHAR));

        if (Buffer && _tcscpy(Buffer, SectionData)) {
            PTSTR   SectionNameStart = _tcschr(Buffer, BOIOS_SECTION_NAME_START);
            PTSTR   SectionNameEnd = _tcschr(Buffer, BOIOS_SECTION_NAME_END);
            BOOLEAN Result = FALSE;

            if (SectionNameStart && SectionNameEnd && (SectionNameEnd > SectionNameStart)) {
                This = (PBOI_SECTION)SBE_MALLOC(sizeof(BOI_SECTION));

                if (*Buffer && This) {
                    DWORD   DataLength = (_tcslen(Buffer) + 1) * sizeof(TCHAR);

                    DataLength -= (((SectionNameEnd + 1) - Buffer) * sizeof(TCHAR));

                    //
                    // Init default object state
                    //
                    memset(This, 0, sizeof(BOI_SECTION));

                    //
                    // Get the name
                    //
                    _tcsncpy(This->Name, SectionNameStart + 1, 
                        SectionNameEnd - SectionNameStart - 1);


                    //
                    // Replicate the contents and keep it
                    //
                    This->Contents =  (PTSTR)SBE_MALLOC(DataLength);

                    if (This->Contents) {
                        _tcscpy(This->Contents, SectionNameEnd + 1);
                        Result = TRUE;
                    } else {
                        Result = FALSE;
                    }                    
                }

                if (!Result) {
                    BOISectionDelete(This);
                    This = NULL;
                }
            }

            SBE_FREE(Buffer);
        }            
    }

    return This;
}

VOID
BOISectionDelete(
    IN PBOI_SECTION This
    )
{
    if (This) {
        if (This->Contents) {
            SBE_FREE(This->Contents);
        }

        SBE_FREE(This);
    }
}

static
BOOLEAN
BOISectionWrite(
    IN PBOI_SECTION This,
    IN OUT PTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;
    
    if (This && Buffer) {
        _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
        _tcscat(Buffer, BOISectionGetName(This));
        _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
        _tcscat(Buffer, TEXT("\r\n"));

        if (This->Contents) {
            _tcscat(Buffer, This->Contents);
        }            
    }

    return Result;
}


//
// BOI_OS_BOOT_ENTRY Methods
//

static
VOID
BOIOSBEInit(
    IN PBOI_OS_BOOT_ENTRY This
    )
{
    This->OsBootEntry.Delete = BOIOSBEDelete;
    This->OsBootEntry.Flush = BOIOSBEFlush;
}

PBOI_SECTION
BOIOSBOFindSection(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PTSTR SectionName
    )
{
    PBOI_SECTION Entry = NULL;

    for (Entry = This->Sections; Entry; Entry = Entry->Next) {
        if (!_tcsicmp(Entry->Name, SectionName)) {
            break;  // found the required section
        }
    }

    return Entry;
}

static
POS_BOOT_ENTRY
BOIOSBECreate(
    IN ULONG  Id,
    IN PCTSTR BootEntryLine,
    IN PBOI_OS_BOOT_OPTIONS Container
    )
{    
    POS_BOOT_ENTRY  Entry = NULL;

    if (BootEntryLine && Container) {
        BOOLEAN Result = FALSE;
        TCHAR   Buffer[MAX_PATH * 4];
        TCHAR   Token[MAX_PATH];
        PBOI_OS_BOOT_ENTRY  BootEntry = (PBOI_OS_BOOT_ENTRY)SBE_MALLOC(sizeof(BOI_OS_BOOT_ENTRY));
        POS_BOOT_ENTRY BaseBootEntry = (POS_BOOT_ENTRY)BootEntry;
                
        //
        // Replicate the input string
        //
        _tcsncpy(Buffer, BootEntryLine, sizeof(Buffer)/sizeof(TCHAR));

        //
        // Remove unwanted charcters in the string
        //
        if (BootEntry && BOIOSFixupString(Buffer, TEXT("\n\r"))) {
            PTSTR   EqualSign = _tcschr(Buffer, TEXT('='));

            //
            // Initialize object state
            //
            memset(BootEntry, 0, sizeof(BOI_OS_BOOT_ENTRY));
            BOIOSBEInit(BootEntry);            
            BaseBootEntry->Id = Id;
            BaseBootEntry->BootOptions = (POS_BOOT_OPTIONS)Container;

            if (EqualSign) {
                PTSTR Slash;
                
                *EqualSign = 0;                
                Slash = _tcschr(Buffer, TEXT('\\'));

                if (Slash) {
                    PTSTR   NameStart = NULL, NameEnd = NULL;
                    PTSTR   NextToken = NULL;

                    Result = TRUE;
                    *Slash = 0;

                    //
                    // Parse & set the boot device name
                    //
                    _tcscpy(Token, Buffer);
                    BOIOSFixupString(Token, TEXT("\n\r "));
                    _tcslwr(Token);
                    OSBESetBootVolumeName(BaseBootEntry, Token);

                    //
                    // if it starts with "C:" its either old OS,
                    // or CmdCons or WinPE or Setup entry
                    //
                    if (_tcschr(Token, TEXT(':'))) {
                        OSBE_SET_OLDOS(BaseBootEntry);
                    }

                    //
                    // Parse & set the boot path
                    //
                    _tcscpy(Token, Slash + 1);
                    BOIOSFixupString(Token, TEXT("\n\r "));
                    OSBESetBootPath(BaseBootEntry, Token);


                    //
                    // Parse & set the friendly name
                    //                    
                    NameStart = _tcschr(EqualSign + 1, TEXT('\"'));

                    //
                    // Set friendly name
                    //
                    if (NameStart) {                        
                        NameEnd = _tcschr(NameStart + 1, TEXT('\"'));
                    }                        

                    if (NameEnd) {  
                        _tcsncpy(Token, NameStart, NameEnd - NameStart);
                        Token[NameEnd - NameStart] = 0;
                        BOIOSFixupString(Token, TEXT("\r\n\""));
                        OSBESetFriendlyName(BaseBootEntry, Token);
                    } else {
                        Result = FALSE;
                    }                        

                    //
                    // Set osload options 
                    //                    
                    NextToken = _tcschr(EqualSign + 1, TEXT('/'));

                    if (NextToken) {  
                        _tcscpy(Token, NextToken);
                        BOIOSFixupString(Token, TEXT("\r\n"));
                        OSBESetOsLoadOptions(BaseBootEntry, Token);
                    }                        
                }                    
            }

            if (!Result) {
                SBE_FREE(BaseBootEntry);
                BaseBootEntry = NULL;
            } else {
                Entry = BaseBootEntry;
            }                
        }
    }

    return Entry;
}

static
VOID
BOIOSBEDelete(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    PBOI_OS_BOOT_ENTRY  This = (PBOI_OS_BOOT_ENTRY)Obj;
    
    if (This) {
        SBE_FREE(This);
    }        
}

static
BOOLEAN
BOIOSBEWrite(
    IN POS_BOOT_ENTRY  This,
    IN OUT PTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;

    if (This && Buffer && !OSBE_IS_DELETED(This)) {
        _tcscat(Buffer, OSBEGetBootVolumeName(This));
        _tcscat(Buffer, TEXT("\\"));
        _tcscat(Buffer, OSBEGetBootPath(This));
        _tcscat(Buffer, TEXT("="));
        _tcscat(Buffer, TEXT("\""));
        _tcscat(Buffer, OSBEGetFriendlyName(This));
        _tcscat(Buffer, TEXT("\""));
        _tcscat(Buffer, TEXT(" "));
        _tcscat(Buffer, OSBEGetOsLoadOptions(This));
        _tcscat(Buffer, TEXT("\r\n"));
        Result = TRUE;
    }

    return Result;
}


static
BOOLEAN
BOIOSBEFlush(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    return TRUE;   // currently can't flush individual entries
}

//
// BOI_OS_BOOT_OPTIONS Methods
//
static
VOID
BOIOSBOInit(
    IN PBOI_OS_BOOT_OPTIONS  This
    )
{
    This->OsBootOptions.Delete = BOIOSBODelete;
    This->OsBootOptions.Flush = BOIOSBOFlush;
    This->OsBootOptions.AddNewBootEntry = BOIOSBOAddNewBootEntry;
    This->OsBootOptions.DeleteBootEntry = OSBODeleteBootEntry;
}

BOOLEAN
BOIOSBOParseAndCreateBootEntries(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section    
    )
{
    BOOLEAN Result = FALSE;

    if (This && Section) {
        Result = TRUE;
    
        if (Section->Contents) {
            PTSTR   NextLineStart = Section->Contents;
            PTSTR   NextLineEnd;
            TCHAR   OldChar;
            POS_BOOT_ENTRY  FirstBootEntry = NULL;
            POS_BOOT_ENTRY  BootEntry = NULL;
            POS_BOOT_ENTRY  LastBootEntry = NULL;
            ULONG BootEntryCount;

            while (NextLineStart) {
                NextLineEnd = _tcschr(NextLineStart, TEXT('\r'));

                if (NextLineEnd) {
                    if (*(NextLineEnd + 1) == TEXT('\n')) {
                        NextLineEnd++;
                    }

                    NextLineEnd++;
                    OldChar = *NextLineEnd;
                    *NextLineEnd = 0;
                }                    

                //
                // Each boot entry line needs to be more than 2 characters in 
                // length and contain an entry of "a=b" form
                //
                if ((!NextLineEnd || ((NextLineEnd - NextLineStart) > 2)) &&
                    (_tcschr(NextLineStart, TEXT('=')))) {
                    BootEntry = BOIOSBECreate(This->NextEntryId++, NextLineStart, This);

                    if (BootEntry) {
                        This->OsBootOptions.EntryCount++;

                        if (!FirstBootEntry) {
                            FirstBootEntry = LastBootEntry = BootEntry;
                        } else {
                            LastBootEntry->NextEntry = BootEntry;
                            LastBootEntry = BootEntry;
                        }                                            
                    } else {
                        Result = FALSE;

                        break;  // don't continue on
                    }                                                                            
                }                    

                if (NextLineEnd) {
                    *NextLineEnd = OldChar;
                }

                NextLineStart = NextLineEnd;
            }

            This->OsBootOptions.BootEntries = FirstBootEntry;
            
            //
            // Initialize the boot order array
            // NOTE : Doesn't make much sense with boot.ini currently
            //
            BootEntryCount = OSBOGetBootEntryCount((POS_BOOT_OPTIONS)This);

            if (BootEntryCount) {
                PULONG  BootOrder = (PULONG)SBE_MALLOC(BootEntryCount * sizeof(ULONG));

                if (BootOrder) {
                    ULONG Index = 0;
                    memset(BootOrder, 0, sizeof(ULONG) * BootEntryCount);

                    BootEntry = OSBOGetFirstBootEntry((POS_BOOT_OPTIONS)This);

                    while (BootEntry && (Index < BootEntryCount)) {
                        BootOrder[Index] = OSBEGetId(BootEntry);
                        BootEntry = OSBOGetNextBootEntry((POS_BOOT_OPTIONS)This, BootEntry);
                    }

                    This->OsBootOptions.BootOrder = BootOrder;
                    This->OsBootOptions.BootOrderCount = BootEntryCount;
                }
            }
        }
    }

    return Result;
}

BOOLEAN
BOIOSBOParseTimeoutAndActiveEntry(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section
    )
{
    BOOLEAN Result = FALSE;

    if (This && Section && !_tcsicmp(Section->Name, BOIOS_BOOTLOADER_SECTION)) {
        TCHAR   Buffer[MAX_PATH * 2];
        TCHAR   Timeout[MAX_PATH];
        TCHAR   Default[MAX_PATH];
        PTSTR   DefKey, TimeoutKey;
        PTSTR   DefValue;
        DWORD   TimeKeyLength = _tcslen(BOIOS_TIMEOUT_KEY);
        DWORD   DefKeyLength = _tcslen(BOIOS_DEFAULT_KEY);
        DWORD   CopyLength;

        Result = TRUE;
        
        _tcscpy(Buffer, Section->Contents);
        _tcslwr(Buffer);
        BOIOSFixupString(Buffer, TEXT("\r\n "));

        Timeout[0] = Default[0] = 0;
        
        DefKey = _tcsstr(Buffer, BOIOS_DEFAULT_KEY);
        TimeoutKey = _tcsstr(Buffer, BOIOS_TIMEOUT_KEY);
        
        if (DefKey && TimeoutKey) {
            if (DefKey > TimeoutKey) {        
                CopyLength = DefKey - TimeoutKey - TimeKeyLength;
                _tcsncpy(Timeout, TimeoutKey + TimeKeyLength, CopyLength);
                Timeout[CopyLength] = 0;                
                _tcscpy(Default, DefKey + DefKeyLength);
            } else {
                CopyLength = TimeoutKey - DefKey - DefKeyLength;
                _tcsncpy(Default, DefKey + DefKeyLength, CopyLength);
                Default[CopyLength] = 0;                
                _tcscpy(Timeout, TimeoutKey + TimeKeyLength);
            }
        } else if (DefKey) {
            _tcscpy(Default, DefKey + DefKeyLength);
        } else if (TimeoutKey) {
            _tcscpy(Timeout, TimeoutKey + TimeKeyLength);
        }                        

        if (TimeoutKey) {        
            ULONG TimeoutValue = _ttol(Timeout);

            OSBOSetTimeOut((POS_BOOT_OPTIONS)This, TimeoutValue);
        }

        if (DefKey) {
            PTSTR   BootPath = _tcschr(Default, TEXT('\\'));

            if (BootPath) {
                POS_BOOT_ENTRY CurrEntry;

                *BootPath = 0;                
                CurrEntry = OSBOGetFirstBootEntry((POS_BOOT_OPTIONS)This);                

                while (CurrEntry) {
                    if (_tcsstr(Default, OSBEGetBootVolumeName(CurrEntry)) &&
                        !_tcsicmp(OSBEGetBootPath(CurrEntry), BootPath + 1)) {
                        break;
                    }

                    CurrEntry = OSBOGetNextBootEntry((POS_BOOT_OPTIONS)This, CurrEntry);
                }

                if (CurrEntry) {
                    OSBOSetActiveBootEntry((POS_BOOT_OPTIONS)This, CurrEntry);
                }                        
            } else {
                Result = FALSE;
            }                    
        }            

        OSBO_RESET_DIRTY((POS_BOOT_OPTIONS)This);
    }

    return Result;
}

POS_BOOT_OPTIONS
BOIOSBOCreate(
    IN PCTSTR   BootIniPath,
    IN BOOLEAN  OpenExisting
    )
{
    POS_BOOT_OPTIONS This = NULL;

    if (BootIniPath) {
        BY_HANDLE_FILE_INFORMATION FileInfo = {0};
        PCHAR   FileContent = NULL;
        HANDLE  BootIniHandle;

        //
        // Open the file
        //
        BootIniHandle = CreateFile(BootIniPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,                                    
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if ((BootIniHandle != INVALID_HANDLE_VALUE) &&
            GetFileInformationByHandle(BootIniHandle,
                &FileInfo)){
            //
            // Map the file
            //
            HANDLE MapHandle = CreateFileMapping(BootIniHandle,
                                    NULL,
                                    PAGE_READONLY,
                                    FileInfo.nFileSizeHigh,
                                    FileInfo.nFileSizeLow,
                                    NULL);

            if (MapHandle) {
                //
                // Get hold of view for the file content
                //
                PVOID   FileView = MapViewOfFile(MapHandle,
                                        FILE_MAP_READ,
                                        0,
                                        0,
                                        0);

                if (FileView) {
                    DWORD BytesRead = 0;

                    //
                    // Allocate the buffer and read the file contents
                    //
                    FileContent = SBE_MALLOC(FileInfo.nFileSizeLow + 1);

                    if (FileContent) {
                        if (!ReadFile(BootIniHandle,
                                FileContent,
                                FileInfo.nFileSizeLow,
                                &BytesRead,
                                NULL)) {
                            SBE_FREE(FileContent);
                            FileContent = NULL;
                        } else {
                            FileContent[FileInfo.nFileSizeLow] = 0;
                        }                            
                    } 

                    UnmapViewOfFile(FileView);
                }

                CloseHandle(MapHandle);
            }
            
            CloseHandle(BootIniHandle);
        } else {
            //
            // Could be that user is creating boot options fresh
            //
            if (!OpenExisting) {        
                PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)SBE_MALLOC(sizeof(BOI_OS_BOOT_OPTIONS));

                if (Obj) {
                    //
                    // Initialize object
                    //
                    memset(Obj, 0, sizeof(BOI_OS_BOOT_OPTIONS));
                    BOIOSBOInit(Obj);
                    _tcscpy(Obj->BootIniPath, BootIniPath);                    
                }                    

                This = (POS_BOOT_OPTIONS)Obj;
            }                    
        }

        //
        // If there is any file content then parse it
        //
        if (FileContent) {
#ifdef UNICODE
            PWSTR   Content = SBE_MALLOC((FileInfo.nFileSizeLow + 1) * sizeof(WCHAR));

            //
            // Convert the Ansi/OEM content to unicode content
            //
            if (Content) {
                if (MultiByteToWideChar(CP_OEMCP,
                        0,
                        FileContent,
                        FileInfo.nFileSizeLow,
                        Content,
                        FileInfo.nFileSizeLow + 1)) {
                    Content[FileInfo.nFileSizeLow ] = 0;                        
                } else {
                    SBE_FREE(Content);
                    Content = NULL;
                }                    
            } else {
                SBE_FREE(FileContent);
                FileContent = NULL;
            }   
            
#else
            PCHAR   Content = FileContent;
#endif

            if (Content && FileContent) {
                TCHAR   NextLine[MAX_PATH * 4];
                PTSTR   NextSectionStart = _tcschr(Content, BOIOS_SECTION_NAME_START);
                PTSTR   NextSectionEnd;
                PBOI_SECTION SectionList = NULL;
                PBOI_SECTION Section = NULL;
                PBOI_SECTION TailSection = NULL;
                BOOLEAN Result = TRUE;

                //
                // Prase the whole files and create section objects
                //
                while (NextSectionStart) {
                    TCHAR   OldChar;
                    
                    Section = NULL;
                    
                    NextSectionEnd = _tcschr(NextSectionStart + 1, BOIOS_SECTION_NAME_START);

                    if (NextSectionEnd) {                        
                        OldChar = *NextSectionEnd;
                        *NextSectionEnd = 0;    // null terminate                        
                    }                    

                    //
                    // Create the section object
                    //
                    Section = BOISectionCreate(NextSectionStart);

                    if (NextSectionEnd) {                        
                        *NextSectionEnd = OldChar; 
                    }                    
                    
                    if (Section) {
                        if (!SectionList) {
                            SectionList = Section;
                        } else {                            
                            TailSection->Next = Section;
                        }                            
                        
                        TailSection = Section;
                    } else {
                        Result = FALSE;
                        break;
                    }                       

                    NextSectionStart = NextSectionEnd;
                }                

                if (Result) {
                    PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)SBE_MALLOC(sizeof(BOI_OS_BOOT_OPTIONS));

                    if (Obj) {
                        //
                        // Initialize object
                        //
                        memset(Obj, 0, sizeof(BOI_OS_BOOT_OPTIONS));
                        BOIOSBOInit(Obj);
                        _tcscpy(Obj->BootIniPath, BootIniPath);

                        Obj->Sections = SectionList;
                        SectionList = NULL;

                        //
                        // Get hold of [operating systems] section and
                        // parse its entries and create boot entries
                        //
                        Section = BOIOSBOFindSection(Obj, BOIOS_OS_SECTION);

                        if (Section) {
                            Result = BOIOSBOParseAndCreateBootEntries(Obj, Section);
                        }                                                        

                        //
                        // Get hold of [boot loader] section and prase its
                        // entries
                        //
                        if (Result) {
                            Section = BOIOSBOFindSection(Obj, BOIOS_BOOTLOADER_SECTION);

                            if (Section) {                                    
                                Result = BOIOSBOParseTimeoutAndActiveEntry(Obj, Section);
                            }
                        }

                        if (!Result) {
                            //
                            // Delete the object to free up all the sections
                            // and the entries
                            //
                            BOIOSBODelete((POS_BOOT_OPTIONS)Obj);
                            Obj = NULL;
                        } 

                        This = (POS_BOOT_OPTIONS)Obj;
                    } else {
                        Result = FALSE;
                    }                        
                }

                //
                // free up the allocated sections, in case of failure
                //
                if (!Result && SectionList) {
                    while (SectionList) {
                        Section = SectionList;
                        SectionList = SectionList->Next;
                        BOISectionDelete(Section);
                    }                                            
                }

                //
                // Free the content
                //
                if ((PVOID)Content != (PVOID)FileContent) {
                    SBE_FREE(Content);               
                }            
            }

            SBE_FREE(FileContent);
        }
    }
    
    return This;
}

static        
VOID
BOIOSBODelete(
    IN POS_BOOT_OPTIONS Obj
    )
{
    PBOI_OS_BOOT_OPTIONS This = (PBOI_OS_BOOT_OPTIONS)Obj;
    
    if (This) {
        PBOI_SECTION CurrSection, PrevSection;
        
        //
        // delete each boot entry 
        //
        POS_BOOT_ENTRY Entry = OSBOGetFirstBootEntry(Obj);
        POS_BOOT_ENTRY PrevEntry;

        while (Entry) {
            PrevEntry = Entry;
            Entry = OSBOGetNextBootEntry(Obj, Entry);
            OSBEDelete(PrevEntry);
        }

        //
        // delete all the sections
        //
        CurrSection = This->Sections;

        while (CurrSection) {
            PrevSection = CurrSection;
            CurrSection = CurrSection->Next;
            BOISectionDelete(PrevSection);
        }

        if (Obj->BootOrder) {
            SBE_FREE(Obj->BootOrder);
        }

        //
        // delete the main object
        //
        SBE_FREE(This);
    }        
}

static
POS_BOOT_ENTRY
BOIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    )
{
    PBOI_OS_BOOT_ENTRY  Entry = NULL;

    if (This && FriendlyName && BootVolumeName && BootPath) {
        Entry = SBE_MALLOC(sizeof(BOI_OS_BOOT_ENTRY));

        if (Entry) {
            ULONG   OrderCount;
            PULONG  NewOrder;
            POS_BOOT_ENTRY BaseEntry = (POS_BOOT_ENTRY)Entry;
            PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)This;
        
            //
            // init core fields
            //
            memset(Entry, 0, sizeof(BOI_OS_BOOT_ENTRY));
            BOIOSBEInit(Entry);            
            Entry->OsBootEntry.BootOptions = This;

            //
            // fill in the attributes
            //
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, FriendlyName);
            OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry, BootVolumeName);
            OSBESetBootPath((POS_BOOT_ENTRY)Entry, BootPath);            

            if (OsLoadOptions) {
                OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry, OsLoadOptions);
            }

            BaseEntry->Id = Obj->NextEntryId++;

            //
            // Flush the entry now to get a proper Id;
            //
                
            Entry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;            
            Entry->OsBootEntry.NextEntry = This->BootEntries;
            This->BootEntries = (POS_BOOT_ENTRY)Entry;
            This->EntryCount++;

            //
            // Put the new entry at the end of the boot order
            //
            OrderCount = OSBOGetOrderedBootEntryCount(This);

            NewOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

            if (NewOrder) {
                memset(NewOrder, 0, sizeof(ULONG) * (OrderCount + 1));

                //
                // copy over the old ordered list
                //
                memcpy(NewOrder, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewOrder[OrderCount] = OSBEGetId((POS_BOOT_ENTRY)Entry);
                SBE_FREE(This->BootOrder);
                This->BootOrder = NewOrder;
                This->BootOrderCount = OrderCount + 1;
            } else {
                OSBODeleteBootEntry(This, BaseEntry);
                Entry = NULL;
            }                    

            if (Entry) {
                //
                // mark it dirty and new for flushing
                //
                OSBE_SET_NEW(Entry);
                OSBE_SET_DIRTY(Entry);                                
            }                
        }
    }        
    
    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
BOIOSBOWrite(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PCTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;

    if (This && Buffer) {
        TCHAR   BackupFileName[MAX_PATH];
        PTSTR   Extension;
        HANDLE  FileHandle;

        //
        // Create a backup name
        //
        _tcscpy(BackupFileName, This->BootIniPath);
        Extension = _tcschr(BackupFileName, TEXT('.'));

        if (Extension) {
            _tcscpy(Extension, TEXT(".BAK"));
        } else {
            _tcscat(BackupFileName, TEXT(".BAK"));
        }            

        //
        // Delete the backup file if it exists
        //
        SetFileAttributes(BackupFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BackupFileName);

        //
        // Copy the existing boot.ini as backup file
        //
        SetFileAttributes(This->BootIniPath, FILE_ATTRIBUTE_NORMAL);
        CopyFile(This->BootIniPath, BackupFileName, FALSE);

        //
        // Create new boot.ini file
        //
        FileHandle = CreateFile(This->BootIniPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (FileHandle && (FileHandle != INVALID_HANDLE_VALUE)) {
            PCHAR   AnsiBuffer;
            ULONG   BufferLength = _tcslen(Buffer);
            DWORD   BytesWritten = 0;

            Result = TRUE;
            
#ifdef UNICODE
            //
            // Convert the unicode buffer to ansi buffer
            //
            AnsiBuffer = (PCHAR)SBE_MALLOC(BufferLength + 1);

            if (AnsiBuffer) {
                memset(AnsiBuffer, 0, BufferLength);

                if (WideCharToMultiByte(CP_OEMCP,
                        0,
                        Buffer,
                        BufferLength,
                        AnsiBuffer,
                        BufferLength,
                        NULL,
                        NULL)) {
                    Result = TRUE;
                    AnsiBuffer[BufferLength] = 0;
                } else {
                    Result = FALSE;
                }                            
            }
#else   
            AnsiBuffer = Buffer;
#endif

            //
            // Write the buffer to the file
            //
            if (AnsiBuffer && 
                !WriteFile(FileHandle, 
                        AnsiBuffer,
                        BufferLength,
                        &BytesWritten,
                        NULL)) {
                Result = FALSE;                            
            }                  

            if ((PVOID)AnsiBuffer != (PVOID)Buffer) {
                SBE_FREE(AnsiBuffer);
                AnsiBuffer = NULL;
            }

            //
            // Done with the file handle
            //
            CloseHandle(FileHandle);

            SetFileAttributes(This->BootIniPath, 
                FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }            
    }        

    return Result;
}

static
BOOLEAN
BOIOSBOFlush(
    IN POS_BOOT_OPTIONS Obj
    )
{
    BOOLEAN Result = FALSE;
    PBOI_OS_BOOT_OPTIONS  This = (PBOI_OS_BOOT_OPTIONS)Obj;    

    if (This) { 
        PTSTR   Buffer = (PTSTR)SBE_MALLOC(MAX_BOOT_INI_SIZE * sizeof(TCHAR));

        if (Buffer) {
            TCHAR   ScratchBuffer[MAX_PATH * 2] = {0};
            POS_BOOT_ENTRY ActiveEntry = OSBOGetActiveBootEntry(Obj);
            POS_BOOT_ENTRY CurrentEntry;
            PBOI_SECTION   CurrentSection;

            Result = TRUE;
            
            memset(Buffer, 0, MAX_BOOT_INI_SIZE * sizeof(TCHAR));            

            //
            // first flush the boot options
            //
            _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
            _tcscat(Buffer, BOIOS_BOOTLOADER_SECTION);
            _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write time out
            //
            _tcscat(Buffer, BOIOS_TIMEOUT_KEY);
            _tcscat(Buffer, _ltot(Obj->Timeout, ScratchBuffer, 10));
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write active entry
            //
            if (ActiveEntry) {
                _tcscpy(ScratchBuffer, BOIOS_DEFAULT_KEY);
                _tcscat(ScratchBuffer, OSBEGetBootVolumeName(ActiveEntry));
                _tcscat(ScratchBuffer, TEXT("\\"));
                _tcscat(ScratchBuffer, OSBEGetBootPath(ActiveEntry));
                _tcscat(ScratchBuffer, TEXT("\r\n"));

                _tcscat(Buffer, ScratchBuffer);
            }                

            //
            // Write the boot entries section 
            //
            _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
            _tcscat(Buffer, BOIOS_OS_SECTION);
            _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write each boot entry now
            //

            //
            // First write the valid arc entries
            //
            CurrentEntry = OSBOGetFirstBootEntry(Obj);

            while (Result && CurrentEntry) {
                if (!OSBE_IS_DELETED(CurrentEntry) &&
                    !OSBE_IS_OLDOS(CurrentEntry)) {
                    Result = BOIOSBEWrite(CurrentEntry, Buffer);                    
                }
                
                CurrentEntry = OSBOGetNextBootEntry(Obj, CurrentEntry);
            }

            //
            // Now write the old OS entries
            // NOTE : We do this for backward compatabily reasons
            //
            CurrentEntry = OSBOGetFirstBootEntry(Obj);

            while (Result && CurrentEntry) {
                if (OSBE_IS_OLDOS(CurrentEntry)) {
                    Result = BOIOSBEWrite(CurrentEntry, Buffer);                    
                }
                
                CurrentEntry = OSBOGetNextBootEntry(Obj, CurrentEntry);
            }

            //
            // Write any additions sections which were present on the
            // 
            CurrentSection = BOIOSGetFirstSection(This);

            while (Result && CurrentSection) {
                //
                // Write all the other additional sections in boot.ini other
                // than [boot loader] and [operating systems]
                //
                if (_tcsicmp(BOISectionGetName(CurrentSection), BOIOS_BOOTLOADER_SECTION) &&
                    _tcsicmp(BOISectionGetName(CurrentSection), BOIOS_OS_SECTION)) {
                    Result = BOISectionWrite(CurrentSection, Buffer);
                }

                CurrentSection = BOIOSGetNextSection(This, CurrentSection);
            }         

            Result = BOIOSBOWrite(This, Buffer);

            //
            // Free the allocated buffer
            //
            SBE_FREE(Buffer);
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\sbentry.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.c

Abstract:

    Contains the OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/


#include <sbentry.h>
#include <stdio.h>

SBEMemAllocateRoutine    AllocRoutine = NULL;
SBEMemFreeRoutine        FreeRoutine = NULL;

//
// OS_BOOT_ENTRY Methods
//
PCWSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    PWSTR   Option = NULL;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);
        Length = wcslen(Buffer);

        if (Length) {
            //
            // Add a space at the end if required
            //
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            if ((!wcsstr(This->OsLoadOptions, Buffer)) &&
                ((wcslen(This->OsLoadOptions) + Length) < MAX_PATH)) {
                wcscat(This->OsLoadOptions, Buffer);                
                Option = This->OsLoadOptions;
            }

            OSBE_SET_DIRTY(This);
            OSBO_SET_DIRTY(This->BootOptions);
        }
    }

    return Option;
}

PCWSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    PWSTR   Option = NULL;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);
        Length = wcslen(Buffer);

        if (Length) {
            PWSTR   OldOption;
            
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            OldOption = wcsstr(This->OsLoadOptions, Buffer);

            if (OldOption) {
                PWSTR NextToken = wcschr(OldOption + 1, L'/');

                if (NextToken) {
                    wcscpy(OldOption, NextToken);
                } else {
                    *OldOption = UNICODE_NULL;
                }

                Option = This->OsLoadOptions;
                
                OSBE_SET_DIRTY(This);
                OSBO_SET_DIRTY(This->BootOptions);
            }                
        }
    }

    return Option;
}

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    BOOLEAN Result = FALSE;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);

        Length = wcslen(Buffer);

        if (Length) {
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            Result = wcsstr(This->OsLoadOptions, Buffer) ? TRUE : FALSE;            
        }
    }

    return Result;
}


//
// OS_BOOT_OPTIONS Methods
//
POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        for (Entry = This->BootEntries; Entry; Entry = Entry->NextEntry) {
            if (Entry->Id == Id) {
                break;  // found the required entry
            }
        }
    }

    return Entry;
}

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    ULONG Index = -1;

    if (This) {
        ULONG EntryIndex;
        
        for (EntryIndex = 0; 
            EntryIndex < OSBOGetOrderedBootEntryCount(This); 
            EntryIndex++) {

            if (This->BootOrder[EntryIndex] == Id) {
                Index = EntryIndex;
                break;  // found the required entry
            }
        }
    }

    return Index;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    BOOLEAN Result = FALSE;

    if (This && BootEntry) {
        POS_BOOT_ENTRY  CurrEntry = NULL;
        POS_BOOT_ENTRY  PrevEntry = NULL;

        for (CurrEntry = This->BootEntries;
             CurrEntry != BootEntry;
             PrevEntry = CurrEntry, CurrEntry = CurrEntry->NextEntry) {
            // do nothing             
        }                

        if (CurrEntry) {
            ULONG Order;
            POS_BOOT_ENTRY  OrderedEntry;

            //
            // Set the required attributes
            //
            OSBE_SET_DELETED(BootEntry);            
            OSBE_SET_DIRTY(BootEntry);
            OSBO_SET_DIRTY(This);
            
            //
            // Flush the changes
            //
            Result = OSBEFlush(BootEntry);

            if (Result) {
                //
                // Remove references to the entries
                //
                if (PrevEntry) {
                    PrevEntry->NextEntry = BootEntry->NextEntry;
                } else {
                    This->BootEntries = BootEntry->NextEntry;
                }  

                if (This->EntryCount) {
                    This->EntryCount--;
                }                    

                //
                // if this entry was ordered then remove
                // reference from the order too
                //
                Order = OSBOFindBootEntryOrder(This, OSBEGetId(BootEntry));

                if (Order != (-1)) {
                    ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);

                    OrderCount--;
                    
                    if (OrderCount) {
                        PULONG  NewOrder = SBE_MALLOC(OrderCount * sizeof(ULONG));                

                        if (NewOrder) {
                            //
                            // copy entries before the current entry
                            //
                            memcpy(NewOrder, This->BootOrder, Order * sizeof(ULONG));

                            //
                            // copy entries after the current entry
                            //
                            memcpy(NewOrder + Order, This->BootOrder + Order + 1,
                                (OrderCount - Order) * sizeof(ULONG));

                            SBE_FREE(This->BootOrder);
                            This->BootOrder = NewOrder;
                            This->BootOrderCount = OrderCount;
                            Result = TRUE;
                        } else {
                            Result = FALSE;
                        }                            
                    } else {
                        SBE_FREE(This->BootOrder);
                        This->BootOrder = NULL;
                        This->BootOrderCount = 0;
                    }                        
                }


                if (BootEntry == OSBOGetActiveBootEntry(This)) {
                    ULONG Index;
                    
                    //
                    // Update the active boot entry and the next boot entry
                    //
                    This->CurrentEntry = NULL;
                    Index = OSBOGetBootEntryIdByOrder(This, 0);

                    if (Index != (-1)) {
                        This->CurrentEntry = OSBOFindBootEntry(This, Index);
                    }
                }                    

                //
                // Since we updated some state mark it dirty
                //
                OSBO_SET_DIRTY(This);
                
                OSBEDelete(BootEntry);            
            }                
        }            
    }

    return Result;
}

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    POS_BOOT_ENTRY  OldActiveEntry = NULL;

    if (This && BootEntry) {
        ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);
        OldActiveEntry = OSBOGetActiveBootEntry(This);

        if ((OrderCount > 0) && (OldActiveEntry != BootEntry)) {
            ULONG Index;
            ULONG ActiveIndex = OSBOFindBootEntryOrder(This,
                                    OSBEGetId(BootEntry));

            //
            // If the entry is already present in the boot order
            // and move it to the start of the list
            //
            if (ActiveIndex != (-1)) {                
                for (Index = ActiveIndex; Index; Index--) {
                    This->BootOrder[Index] = This->BootOrder[Index - 1];
                }

                This->BootOrder[0] = BootEntry->Id;
            } else {
                //
                // This is a new entry in ordered list. Grow the ordered boot
                // entry list with this new entry at the start
                //
                PULONG  NewBootOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                memcpy(NewBootOrder + 1, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewBootOrder[0] = BootEntry->Id;

                SBE_FREE(This->BootOrder);
                This->BootOrder = NewBootOrder;
            }

            //
            // Update the active boot entry and the next boot entry
            //
            This->CurrentEntry = NULL;
            Index = OSBOGetBootEntryIdByOrder(This, 0);

            if (Index != (-1)) {
                This->CurrentEntry = OSBOFindBootEntry(This, Index);
            }

            //
            // Since we updated some state mark it dirty
            //
            OSBO_SET_DIRTY(This);
        }        
    }

    return OldActiveEntry;
}

POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN OUT PULONG Index
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This && Index) {
        *Index = 0;        
        Entry = OSBOGetNextBootEntry(This, Index);
    }                            

    return Entry;
}

POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    )    
{
    POS_BOOT_ENTRY  Entry = NULL;

    //
    // TBD : Might want to optimize this, since
    // each boot entry now has a pointer to the next
    // boot entry
    //
    if (This && Index) {
        ULONG   Count = *Index;
        POS_BOOT_ENTRY  CurrEntry;

        for (CurrEntry = This->BootEntries;
             CurrEntry;
             CurrEntry = CurrEntry->NextEntry, Count--) {

            if (!Count) {
                Entry = CurrEntry;
                (*Index)++;

                break;
            }                
        }                     
    }        

    return Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\bootini\bootient.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    bootient.h

Abstract:

    Boot.ini boot options and boot entry abstractions

Author:


Revision History:

    None.

--*/

#pragma once

#include <sbentry.h>

//
// Boot.ini extra section abstraction
//
typedef struct _BOI_SECTION *PBOI_SECTION;

typedef struct _BOI_SECTION {
    PBOI_SECTION    Next;
    TCHAR           Name[MAX_PATH];
    PTSTR           Contents;
    DWORD           Size;
} BOI_SECTION;


//
// Boot.ini boot entry abstraction
//
typedef struct _BOI_OS_BOOT_ENTRY {
    OS_BOOT_ENTRY   OsBootEntry;    
} BOI_OS_BOOT_ENTRY, *PBOI_OS_BOOT_ENTRY;

//
// Boot.ini boot options abstraction
//
typedef struct _BOI_OS_BOOT_OPTIONS {
    OS_BOOT_OPTIONS     OsBootOptions;
    TCHAR               BootIniPath[MAX_PATH];
    PBOI_SECTION        Sections;
    ULONG               NextEntryId;
} BOI_OS_BOOT_OPTIONS, *PBOI_OS_BOOT_OPTIONS;


//
// BOI_OS_SECTION Methods
//
PBOI_SECTION
BOISectionCreate(
    IN PCTSTR   SectionData
    );

VOID
BOISectionDelete(
    IN PBOI_SECTION This
    );

__inline
PCTSTR
BOISectionGetName(
    IN PBOI_SECTION This
    )
{
    return (This) ? This->Name : NULL;
}

//
// BOI_OS_BOOT_ENTRY Methods
//
POS_BOOT_ENTRY
BOIOSBECreate(
    IN ULONG Id,
    IN PCTSTR EntryLine,
    IN PBOI_OS_BOOT_OPTIONS Container
    );

VOID
BOIOSBEDelete(
    IN  POS_BOOT_ENTRY  This
    );

BOOLEAN
BOIOSBEFlush(
    IN POS_BOOT_ENTRY This
    );

//
// BOI_OS_BOOT_OPTIONS Methods
//
POS_BOOT_OPTIONS
BOIOSBOCreate(
    IN PCTSTR BootIniPath,
    IN BOOLEAN OpenExisting
    );

    
BOOLEAN
BOIOSBOFlush(
    IN POS_BOOT_OPTIONS This
    );
    
VOID
BOIOSBODelete(
    IN POS_BOOT_OPTIONS This
    );

POS_BOOT_ENTRY
BOIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    );


__inline
PBOI_SECTION
BOIOSGetFirstSection(
    IN PBOI_OS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Sections) : NULL;
}

__inline
PBOI_SECTION
BOIOSGetNextSection(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section
    )
{
    return (This && Section) ? (Section->Next) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\bootini\sbentry.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.c

Abstract:

    Contains the OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/


#include <sbentry.h>
#include <stdio.h>

SBEMemAllocateRoutine    AllocRoutine = NULL;
SBEMemFreeRoutine        FreeRoutine = NULL;

//
// OS_BOOT_ENTRY Methods
//
PCTSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    PTSTR   Option = NULL;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);
        Length = _tcslen(Buffer);

        if (Length) {
            //
            // Add a space at the end if required
            //
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            if ((!_tcsstr(This->OsLoadOptions, Buffer)) &&
                ((_tcslen(This->OsLoadOptions) + Length) < MAX_PATH)) {
                _tcscat(This->OsLoadOptions, Buffer);                
                Option = This->OsLoadOptions;
            }

            OSBE_SET_DIRTY(This);
            OSBO_SET_DIRTY(This->BootOptions);
        }
    }

    return Option;
}

PCTSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    PTSTR   Option = NULL;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);
        Length = _tcslen(Buffer);

        if (Length) {
            PTSTR   OldOption;
            
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            OldOption = _tcsstr(This->OsLoadOptions, Buffer);

            if (OldOption) {
                PTSTR NextToken = _tcschr(OldOption + 1, L'/');

                if (NextToken) {
                    _tcscpy(OldOption, NextToken);
                } else {
                    *OldOption = UNICODE_NULL;
                }

                Option = This->OsLoadOptions;
                
                OSBE_SET_DIRTY(This);
                OSBO_SET_DIRTY(This->BootOptions);
            }                
        }
    }

    return Option;
}

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    BOOLEAN Result = FALSE;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);

        Length = _tcslen(Buffer);

        if (Length) {
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            Result = _tcsstr(This->OsLoadOptions, Buffer) ? TRUE : FALSE;            
        }
    }

    return Result;
}


//
// OS_BOOT_OPTIONS Methods
//
POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        for (Entry = This->BootEntries; Entry; Entry = Entry->NextEntry) {
            if (Entry->Id == Id) {
                break;  // found the required entry
            }
        }
    }

    return Entry;
}

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    ULONG Index = -1;

    if (This) {
        ULONG EntryIndex;
        
        for (EntryIndex = 0; 
            EntryIndex < OSBOGetOrderedBootEntryCount(This); 
            EntryIndex++) {

            if (This->BootOrder[EntryIndex] == Id) {
                Index = EntryIndex;
                break;  // found the required entry
            }
        }
    }

    return Index;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    BOOLEAN Result = FALSE;

    if (This && BootEntry) {
        POS_BOOT_ENTRY  CurrEntry = NULL;
        POS_BOOT_ENTRY  PrevEntry = NULL;

        for (CurrEntry = This->BootEntries;
             CurrEntry != BootEntry;
             PrevEntry = CurrEntry, CurrEntry = CurrEntry->NextEntry) {
            // do nothing             
        }                

        if (CurrEntry) {
            ULONG Order;
            POS_BOOT_ENTRY  OrderedEntry;

            //
            // Set the required attributes
            //
            OSBE_SET_DELETED(BootEntry);            
            OSBE_SET_DIRTY(BootEntry);
            OSBO_SET_DIRTY(This);
            
            //
            // Flush the changes
            //
            Result = OSBEFlush(BootEntry);

            if (Result) {
                //
                // Remove references to the entries
                //
                if (PrevEntry) {
                    PrevEntry->NextEntry = BootEntry->NextEntry;
                } else {
                    This->BootEntries = BootEntry->NextEntry;
                }  

                if (This->EntryCount) {
                    This->EntryCount--;
                }                    

                //
                // if this entry was ordered then remove
                // reference from the order too
                //
                Order = OSBOFindBootEntryOrder(This, OSBEGetId(BootEntry));

                if (Order != (-1)) {
                    ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);

                    OrderCount--;
                    
                    if (OrderCount) {
                        PULONG  NewOrder = SBE_MALLOC(OrderCount * sizeof(ULONG));                

                        if (NewOrder) {
                            //
                            // copy entries before the current entry
                            //
                            memcpy(NewOrder, This->BootOrder, Order * sizeof(ULONG));

                            //
                            // copy entries after the current entry
                            //
                            memcpy(NewOrder + Order, This->BootOrder + Order + 1,
                                (OrderCount - Order) * sizeof(ULONG));

                            SBE_FREE(This->BootOrder);
                            This->BootOrder = NewOrder;
                            This->BootOrderCount = OrderCount;
                            Result = TRUE;
                        } else {
                            Result = FALSE;
                        }                            
                    } else {
                        SBE_FREE(This->BootOrder);
                        This->BootOrder = NULL;
                        This->BootOrderCount = 0;
                    }                        
                }


                if (BootEntry == OSBOGetActiveBootEntry(This)) {
                    ULONG Index;
                    
                    //
                    // Update the active boot entry and the next boot entry
                    //
                    This->CurrentEntry = NULL;
                    Index = OSBOGetBootEntryIdByOrder(This, 0);

                    if (Index != (-1)) {
                        This->CurrentEntry = OSBOFindBootEntry(This, Index);
                    }
                }                    

                //
                // Since we updated some state mark it dirty
                //
                OSBO_SET_DIRTY(This);
                
                OSBEDelete(BootEntry);            
            }                
        }            
    }

    return Result;
}

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    POS_BOOT_ENTRY  OldActiveEntry = NULL;

    if (This && BootEntry) {
        ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);
        OldActiveEntry = OSBOGetActiveBootEntry(This);

        if ((OrderCount > 0) && (OldActiveEntry != BootEntry)) {
            ULONG Index;
            ULONG ActiveIndex = OSBOFindBootEntryOrder(This,
                                    OSBEGetId(BootEntry));

            //
            // If the entry is already present in the boot order
            // and move it to the start of the list
            //
            if (ActiveIndex != (-1)) {                
                for (Index = ActiveIndex; Index; Index--) {
                    This->BootOrder[Index] = This->BootOrder[Index - 1];
                }

                This->BootOrder[0] = BootEntry->Id;
            } else {
                //
                // This is a new entry in ordered list. Grow the ordered boot
                // entry list with this new entry at the start
                //
                PULONG  NewBootOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                memcpy(NewBootOrder + 1, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewBootOrder[0] = BootEntry->Id;

                SBE_FREE(This->BootOrder);
                This->BootOrder = NewBootOrder;
            }

            //
            // Update the active boot entry and the next boot entry
            //
            This->CurrentEntry = NULL;
            Index = OSBOGetBootEntryIdByOrder(This, 0);

            if (Index != (-1)) {
                This->CurrentEntry = OSBOFindBootEntry(This, Index);
            }

            //
            // Since we updated some state mark it dirty
            //
            OSBO_SET_DIRTY(This);
        }        
    }

    return OldActiveEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\bootini\sbentry.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.h

Abstract:

    Contains the OS boot entry and boot options
    abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <tchar.h>

//
// Allocate & Deallocate routines
//
typedef void* (* SBEMemAllocateRoutine)(size_t  Size);
typedef void (* SBEMemFreeRoutine)(void *Memory);

extern SBEMemAllocateRoutine    AllocRoutine;
extern SBEMemFreeRoutine        FreeRoutine;


#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))


//
// Internal attributes for the boot entry
//
#define OSBE_ATTRIBUTE_NEW      0x00000001
#define OSBE_ATTRIBUTE_DELETED  0x00000002
#define OSBE_ATTRIBUTE_OLDOS    0x00000004
#define OSBE_ATTRIBUTE_DIRTY    0x10000000


//
// OS_BOOT_ENTRY abstraction
//
typedef struct _OS_BOOT_ENTRY   *POS_BOOT_ENTRY;
typedef struct _OS_BOOT_OPTIONS *POS_BOOT_OPTIONS;

typedef VOID (* OSBEDeleteMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef BOOLEAN (* OSBEFlushMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef struct _OS_BOOT_ENTRY {
    //
    // Data members
    //
    ULONG   Version;
    ULONG   Id;    
    TCHAR   FriendlyName[MAX_PATH];
    TCHAR   OsLoaderVolumeName[MAX_PATH];
    TCHAR   OsLoaderPath[MAX_PATH];
    TCHAR   BootVolumeName[MAX_PATH];
    TCHAR   BootPath[MAX_PATH];
    TCHAR   OsLoadOptions[MAX_PATH];
    ULONG   Attributes;
    POS_BOOT_OPTIONS    BootOptions;
    POS_BOOT_ENTRY      NextEntry;

    //
    // Methods
    //
    OSBEDeleteMethod    Delete;
    OSBEFlushMethod     Flush;
} OS_BOOT_ENTRY;

#define OSBE_IS_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBE_IS_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_NEW)
#define OSBE_IS_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DELETED)
#define OSBE_IS_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_OLDOS)

#define OSBE_SET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBE_SET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_NEW)
#define OSBE_SET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DELETED)
#define OSBE_SET_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_OLDOS)

#define OSBE_RESET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)
#define OSBE_RESET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_NEW)
#define OSBE_RESET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DELETED)
#define OSBE_RESET_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_OLDOS)


//
// OS_BOOT_OPTIONS abstraction
//
typedef VOID (* OSBODeleteMethod)(
                    IN POS_BOOT_OPTIONS This
                    );

typedef POS_BOOT_ENTRY (* OSBOAddNewBootEntryMethod)(
                            IN POS_BOOT_OPTIONS This,
                            IN PCTSTR            FriendlyName,
                            IN PCTSTR            OsLoaderVolumeName,
                            IN PCTSTR            OsLoaderPath,
                            IN PCTSTR            BootVolumeName,
                            IN PCTSTR            BootPath,
                            IN PCTSTR            OsLoadOptions
                            );

typedef BOOLEAN (* OSBODeleteBootEntryMethod)(
                        IN POS_BOOT_OPTIONS This,
                        IN POS_BOOT_ENTRY   BootEntry
                        );

typedef BOOLEAN (* OSBOFlushMethod)(
                    IN POS_BOOT_OPTIONS This 
                    );

typedef struct _OS_BOOT_OPTIONS {
    //
    // Data members
    //
    ULONG               Version;
    ULONG               Attributes;
    ULONG               Timeout;
    POS_BOOT_ENTRY      CurrentEntry;
    POS_BOOT_ENTRY      BootEntries;
    ULONG               EntryCount;
    PULONG              BootOrder;
    ULONG               BootOrderCount;

    //
    // Methods
    //
    OSBODeleteMethod            Delete;
    OSBOFlushMethod             Flush;
    OSBOAddNewBootEntryMethod   AddNewBootEntry;
    OSBODeleteBootEntryMethod   DeleteBootEntry;    
} OS_BOOT_OPTIONS;


#define OSBO_IS_DIRTY(_osbo)        (((POS_BOOT_OPTIONS)(_osbo))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBO_SET_DIRTY(_osbo)       (((POS_BOOT_OPTIONS)(_osbo))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBO_RESET_DIRTY(_osbo)     (((POS_BOOT_OPTIONS)(_osbo))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)

//
// OS_BOOT_ENTRY Methods
//
PCTSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

PCTSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

__inline
VOID
OSBEDelete(
    IN POS_BOOT_ENTRY This
    )
{
    if (This) {
        (This->Delete)(This);
    }
}

__inline
BOOLEAN
OSBEFlush(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->Flush(This) : FALSE;
}


__inline
ULONG
OSBEGetId(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->Id : (-1);
}

__inline
PCTSTR
OSBEGetFriendlyName(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCTSTR
OSBESetFriendlyName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->FriendlyName);
        
        _tcsncpy(This->FriendlyName, Name, Size - 1);
        This->FriendlyName[Size - 1] = UNICODE_NULL;
        NewName = This->FriendlyName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderVolumeName : NULL;
}

__inline
PCTSTR
OSBESetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderVolumeName);
        
        _tcsncpy(This->OsLoaderVolumeName, Name, Size - 1);
        This->OsLoaderVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoaderPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderPath : NULL;
}

__inline
PCTSTR
OSBESetOsLoaderPath(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderPath);
        
        _tcsncpy(This->OsLoaderPath, Name, Size - 1);
        This->OsLoaderPath[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetBootVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootVolumeName : NULL;
}

__inline
PCTSTR
OSBESetBootVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootVolumeName);        
    
        _tcsncpy(This->BootVolumeName, Name, Size - 1);
        This->BootVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->BootVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetBootPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootPath : NULL;
}

__inline
PCTSTR
OSBESetBootPath(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootPath);        
    
        _tcsncpy(This->BootPath, Name, Size - 1);
        This->BootPath[Size - 1] = UNICODE_NULL;
        NewName = This->BootPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoadOptions(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoadOptions : NULL;
}
    
__inline
PCTSTR
OSBESetOsLoadOptions(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR LoadOptions
    )
{
    TCHAR Buffer[MAX_PATH];
    PTSTR NewOptions = NULL;
    
    if (This && LoadOptions) {
        ULONG   Size = ARRAY_SIZE(This->OsLoadOptions);
        
        _tcscpy(Buffer, LoadOptions);
        _tcsupr(Buffer);
        _tcsncpy(This->OsLoadOptions, Buffer, Size - 1);
        This->OsLoadOptions[Size - 1] = UNICODE_NULL;
        NewOptions = This->OsLoadOptions;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewOptions;
}

//
// OS_BOOT_OPTIONS Methods
//   
__inline
BOOLEAN
OSBOFlush(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Flush(This)) : FALSE;
}
    
__inline    
VOID
OSBODelete(
    IN POS_BOOT_OPTIONS This
    )
{
    if (This) {
        This->Delete(This);
    }        
}

__inline
POS_BOOT_ENTRY
OSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->AddNewBootEntry(This,
                            FriendlyName,
                            OsLoaderVolumeName,
                            OsLoaderPath,
                            BootVolumeName,
                            BootPath,
                            OsLoadOptions);                    
        OSBO_SET_DIRTY(This);
    }

    return Entry;
}


__inline
POS_BOOT_ENTRY
OSBOGetActiveBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->CurrentEntry;
    }
    
    return Entry;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );
    

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );

ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    );

POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );    

__inline
ULONG
OSBOGetTimeOut(
    IN  POS_BOOT_OPTIONS    This
    )
{
    return (This) ? This->Timeout : 0;
}

__inline
ULONG
OSBOSetTimeOut(
    IN  POS_BOOT_OPTIONS    This,
    IN  ULONG Timeout
    )
{
    ULONG   OldTimeout = 0;

    if (This) {
        OldTimeout = This->Timeout;
        This->Timeout = Timeout;
        OSBE_SET_DIRTY(This);
    }

    return OldTimeout;
}

__inline
ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->EntryCount;
    }

    return Count;
}


__inline
ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->BootOrderCount;
    }

    return Count;
}

__inline
ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    )
{
    ULONG Entry = -1;

    if (Index < OSBOGetOrderedBootEntryCount(This)) {            
        Entry = This->BootOrder[Index];
    }

    return Entry;
}

__inline
BOOLEAN
OSBOLibraryInit(
    SBEMemAllocateRoutine AllocFunction,
    SBEMemFreeRoutine FreeFunction
    )
{
    BOOLEAN Result = FALSE;

    if (AllocFunction && FreeFunction) {
        AllocRoutine = AllocFunction;
        FreeRoutine = FreeFunction;

        Result = TRUE;
    }

    return Result;
}

__inline
POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->BootEntries) : NULL;
}
    

__inline
POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY PrevEntry
    )
{
    return (This && PrevEntry) ? PrevEntry->NextEntry : NULL;
}

    

//
// memory allocation & deallocation routines
//
__inline
void*
__cdecl
SBE_MALLOC(
    IN  size_t  Size
    )
{
    return AllocRoutine ? AllocRoutine(Size) : NULL;
}

__inline
void    
__cdecl 
SBE_FREE(
    IN  void *Memory
    )
{
    if (Memory && FreeRoutine) {
        FreeRoutine(Memory);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\efi\efisbent.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efisbent.c

Abstract:

    Contains the EFI OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#include <efisbent.h>
#include <ntosp.h>
#include <stdio.h>

//
// global variables
//
BOOLEAN PriviledgeSet = FALSE;

//
// EFI_OS_BOOT_ENTRY Methods
//

static
VOID
EFIOSBEInit(
    IN PEFI_OS_BOOT_ENTRY This
    )
{
    This->OsBootEntry.Delete = EFIOSBEDelete;
    This->OsBootEntry.Flush = EFIOSBEFlush;
}

static
POS_BOOT_ENTRY
EFIOSBECreate(
    IN PBOOT_ENTRY NtBootEntry,
    IN POS_BOOT_OPTIONS Container
    )
{    
    PEFI_OS_BOOT_ENTRY  Entry = NULL;

    if (NtBootEntry && Container) {        
        Entry = SBE_MALLOC(sizeof(EFI_OS_BOOT_ENTRY));

        if (Entry) {
            PWSTR       TempUniStr;
            NTSTATUS    Status = STATUS_SUCCESS;
            ULONG       Size;
            PFILE_PATH  FilePath;
                        
            memset(Entry, 0, sizeof(EFI_OS_BOOT_ENTRY));
            EFIOSBEInit(Entry);
            
            Entry->OsBootEntry.Id = NtBootEntry->Id;
            Entry->OsBootEntry.BootOptions = Container;

            //
            // If this is a Windows boot options set the windows attribute
            //
            if ( IS_BOOT_ENTRY_WINDOWS(NtBootEntry) ) {
                OSBE_SET_WINDOWS(Entry);
            }
            
            //
            // Get the friendly name
            //
            TempUniStr = ADD_OFFSET(NtBootEntry, FriendlyNameOffset);
            
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, TempUniStr);

            //
            // Get the loader path
            //
            FilePath = ADD_OFFSET(NtBootEntry, BootFilePathOffset);            
            
            if (FilePath->Type != FILE_PATH_TYPE_NT) {            
                Size = 0;
                
                Status = NtTranslateFilePath(FilePath,
                                FILE_PATH_TYPE_NT,
                                NULL,
                                &Size);
                
                if (Size != 0) {
                    PFILE_PATH NtFilePath = SBE_MALLOC(Size);

                    if (NtFilePath) {                        
                        Status = NtTranslateFilePath(FilePath,
                                    FILE_PATH_TYPE_NT,
                                    NtFilePath,
                                    &Size);

                        if (NT_SUCCESS(Status)) {            
                            PWSTR   VolumeName = (PWSTR)(NtFilePath->FilePath);

                            OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry,                                
                                    VolumeName);

                            OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry,
                                VolumeName + wcslen(VolumeName) + 1);
                        }

                        SBE_FREE(NtFilePath);
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }                        
                }

                //
                // Its possible for some reason we didn't get NT path
                // for loader volume, for e.g. it may not be present at all
                // So ignore such cases
                //
                Status = STATUS_SUCCESS;
            } else {
                PWSTR   VolumeName = (PWSTR)(FilePath->FilePath);
                
                OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry,                                
                        VolumeName);

                OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry,
                    VolumeName + wcslen(VolumeName) + 1);
            }
            
            if (NT_SUCCESS(Status)) {
                PWINDOWS_OS_OPTIONS OsOptions;

                //
                // Get the OsLoadOptions & Boot path if its windows
                // entry
                //
                OsOptions = (PWINDOWS_OS_OPTIONS)NtBootEntry->OsOptions;

                if (IS_BOOT_ENTRY_WINDOWS(NtBootEntry)) {
                    OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry,
                        OsOptions->OsLoadOptions);

                    FilePath = ADD_OFFSET(OsOptions, OsLoadPathOffset);

                    if (FilePath->Type != FILE_PATH_TYPE_NT) {            
                        Size = 0;
                        
                        Status = NtTranslateFilePath(FilePath,
                                        FILE_PATH_TYPE_NT,
                                        NULL,
                                        &Size);

                        if (Size != 0) {
                            PFILE_PATH NtFilePath = SBE_MALLOC(Size);

                            if (NtFilePath) {                                
                                Status = NtTranslateFilePath(FilePath,
                                            FILE_PATH_TYPE_NT,
                                            NtFilePath,
                                            &Size);

                                if (NT_SUCCESS(Status)) {
                                    PWSTR   VolumeName = (PWSTR)(NtFilePath->FilePath);

                                    OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry,                                        
                                        VolumeName);

                                    OSBESetBootPath((POS_BOOT_ENTRY)Entry,
                                        VolumeName + wcslen(VolumeName) + 1);
                                }

                                SBE_FREE(NtFilePath);
                            } else {
                                Status = STATUS_NO_MEMORY;
                            }                        
                        }

                        //
                        // Its possible for some reason we didn't get NT path
                        // for Boot volume, for e.g. it may not be present at all
                        // So ignore such cases
                        //
                        Status = STATUS_SUCCESS;
                    } else {
                        PWSTR   VolumeName = (PWSTR)(FilePath->FilePath);
                        
                        OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry,                                        
                            VolumeName);

                        OSBESetBootPath((POS_BOOT_ENTRY)Entry,
                            VolumeName + wcslen(VolumeName) + 1);
                    }                            
                }
            }

            if (!NT_SUCCESS(Status)) {
                SBE_FREE(Entry);
                Entry = NULL;
            }
        }
    }

    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
EFIOSBEFillNtBootEntry(
    IN PEFI_OS_BOOT_ENTRY Entry
    )
{
    BOOLEAN Result = FALSE;

    if (Entry) {
        ULONG   RequiredLength;
        ULONG   OsOptionsOffset;
        ULONG   OsOptionsLength;
        ULONG   FriendlyNameOffset;
        ULONG   BootPathOffset;
        ULONG   BootPathLength;
        ULONG   LoaderPathOffset;
        ULONG   LoaderPathLength;
        ULONG   WinOsOptionsLength;
        POS_BOOT_ENTRY  BaseEntry = (POS_BOOT_ENTRY)Entry;
        
        if (Entry->NtBootEntry) {
            SBE_FREE(Entry->NtBootEntry);
        }                

        RequiredLength = FIELD_OFFSET(BOOT_ENTRY, OsOptions);

        //
        // TDB : What about non windows OS options ?
        //
        OsOptionsOffset = RequiredLength;
        RequiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        RequiredLength += (wcslen(OSBEGetOsLoadOptions(BaseEntry)) + 1) * sizeof(WCHAR);                
        
        //
        // for boot path as part of windows OS options
        //
        RequiredLength = BootPathOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
        RequiredLength += (wcslen(OSBEGetBootVolumeName(BaseEntry)) + 1) * sizeof(WCHAR);
        RequiredLength += (wcslen(OSBEGetBootPath(BaseEntry)) + 1) * sizeof(WCHAR);
        BootPathLength = (RequiredLength - BootPathOffset);
        OsOptionsLength = (RequiredLength - OsOptionsOffset);

        //
        // for friendly name
        //
        RequiredLength = FriendlyNameOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += (wcslen(OSBEGetFriendlyName(BaseEntry)) + 1) * sizeof(WCHAR);

        // 
        // for loader path
        //
        RequiredLength = LoaderPathOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
        RequiredLength += (wcslen(OSBEGetOsLoaderVolumeName(BaseEntry)) + 1) * sizeof(WCHAR);
        RequiredLength += (wcslen(OSBEGetOsLoaderPath(BaseEntry)) + 1) * sizeof(WCHAR);       
        LoaderPathLength = (RequiredLength - LoaderPathOffset);


        Entry->NtBootEntry = (PBOOT_ENTRY)SBE_MALLOC(RequiredLength);

        if (Entry->NtBootEntry) {
            PBOOT_ENTRY NtBootEntry = Entry->NtBootEntry;
            PFILE_PATH  BootPath = ADD_BYTE_OFFSET(NtBootEntry, BootPathOffset);
            PFILE_PATH  LoaderPath = ADD_BYTE_OFFSET(NtBootEntry, LoaderPathOffset);
            PWSTR       FriendlyName = (PWSTR)(ADD_BYTE_OFFSET(NtBootEntry, FriendlyNameOffset));
            PWINDOWS_OS_OPTIONS WindowsOptions = ADD_BYTE_OFFSET(NtBootEntry, OsOptionsOffset);
            PWSTR   TempStr;

            memset(NtBootEntry, 0, RequiredLength);
            
            //
            // Fill the base part
            //
            NtBootEntry->Version = BOOT_ENTRY_VERSION;
            NtBootEntry->Length = RequiredLength;
            NtBootEntry->Id = OSBEGetId(BaseEntry);
            NtBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
            NtBootEntry->OsOptionsLength = OsOptionsLength;
            NtBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)FriendlyName - (PUCHAR)NtBootEntry);
            NtBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)LoaderPath - (PUCHAR)NtBootEntry);
            
            //
            // Fill in the windows os options
            //
            strcpy(WindowsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
            WindowsOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
            WindowsOptions->Length = OsOptionsLength;
            WindowsOptions->OsLoadPathOffset = (ULONG)((PUCHAR)BootPath - (PUCHAR)WindowsOptions);
            wcscpy(WindowsOptions->OsLoadOptions, OSBEGetOsLoadOptions(BaseEntry));

            //
            // Fill in the Boot path FILE_PATH
            //
            BootPath->Version = FILE_PATH_VERSION;
            BootPath->Length = BootPathLength;
            BootPath->Type = FILE_PATH_TYPE_NT;
            TempStr = (PWSTR)(BootPath->FilePath);
            wcscpy(TempStr, OSBEGetBootVolumeName(BaseEntry));
            TempStr += wcslen(TempStr) + 1;
            wcscpy(TempStr, OSBEGetBootPath(BaseEntry));

            //
            // Fill the friendly name
            //
            wcscpy(FriendlyName, OSBEGetFriendlyName(BaseEntry));

            //
            // Fill in the loader path FILE_PATH
            //
            LoaderPath->Version = FILE_PATH_VERSION;
            LoaderPath->Length = LoaderPathLength;
            LoaderPath->Type = FILE_PATH_TYPE_NT;
            TempStr = (PWSTR)(LoaderPath->FilePath);
            wcscpy(TempStr, OSBEGetOsLoaderVolumeName(BaseEntry));
            TempStr += wcslen(TempStr) + 1;
            wcscpy(TempStr, OSBEGetOsLoaderPath(BaseEntry));

            Result = TRUE;
        }
    }

    return Result;
}

static
VOID
EFIOSBEDelete(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    PEFI_OS_BOOT_ENTRY  This = (PEFI_OS_BOOT_ENTRY)Obj;
    
    if (This) {
        if (This->NtBootEntry) {
            SBE_FREE(This->NtBootEntry);
        }
        
        SBE_FREE(This);
    }        
}

static
BOOLEAN
EFIOSBEFlush(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    BOOLEAN Result = FALSE;
    PEFI_OS_BOOT_ENTRY  This = (PEFI_OS_BOOT_ENTRY)Obj;    

    if (This) {
        NTSTATUS Status = STATUS_SUCCESS;
        
        if (OSBE_IS_DIRTY(This)) {
            if (OSBE_IS_DELETED(This)) {
                //
                // Delete this entry
                //
                Status = NtDeleteBootEntry(This->OsBootEntry.Id);
            } else if (OSBE_IS_NEW(This)) {
                //
                // Add this as new boot entry
                //
                Status = EFIOSBEFillNtBootEntry(This);

                if (NT_SUCCESS(Status)) {
                    Status = NtAddBootEntry(This->NtBootEntry,
                                &(This->OsBootEntry.Id));
                }                                
            } else {
                //
                // Just change this boot entry
                //
                Status = EFIOSBEFillNtBootEntry(This);

                if (NT_SUCCESS(Status)) {
                    Status = NtModifyBootEntry(This->NtBootEntry);
                }                                
            }

            if (NT_SUCCESS(Status)) {
                OSBE_RESET_DIRTY(This);
                Result = TRUE;
            }             
        } else {
            Result = TRUE;  // nothing to flush
        }
    }

    return Result;
}

//
// EFI_OS_BOOT_OPTIONS Methods
//
static
VOID
EFIOSBOInit(
    IN PEFI_OS_BOOT_OPTIONS  This
    )
{
    This->OsBootOptions.Delete = EFIOSBODelete;
    This->OsBootOptions.Flush = EFIOSBOFlush;
    This->OsBootOptions.AddNewBootEntry = EFIOSBOAddNewBootEntry;
    This->OsBootOptions.DeleteBootEntry = OSBODeleteBootEntry;
}

POS_BOOT_OPTIONS
EFIOSBOCreate(
    VOID
    )
{
    PEFI_OS_BOOT_OPTIONS This = NULL;
    BOOLEAN WasEnabled = FALSE;

    if (PriviledgeSet || 
        NT_SUCCESS(RtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, 
                            TRUE,
                            FALSE,
                            &WasEnabled))) {
        PriviledgeSet = TRUE;    
        This = SBE_MALLOC(sizeof(EFI_OS_BOOT_OPTIONS));    
    } 
    
    if (This) {
        NTSTATUS    Status;
        ULONG       Length = 0;
        
        memset(This, 0, sizeof(EFI_OS_BOOT_OPTIONS));       
        EFIOSBOInit(This);

        //
        // Get hold of NT boot entries
        //
        Status = NtQueryBootOptions(NULL, &Length);

        if (Length) {
            This->NtBootOptions = SBE_MALLOC(Length);

            if (This->NtBootOptions) {
                Status = NtQueryBootOptions(This->NtBootOptions,
                                &Length);

                if (NT_SUCCESS(Status)) {
                    //
                    // save off the timeout period
                    //
                    This->OsBootOptions.Timeout = This->NtBootOptions->Timeout;

                    //
                    // enumerate all the boot entries
                    //
                    Length = 0;
                    Status = NtEnumerateBootEntries(NULL, &Length);

                    if (Length) {
                        This->NtBootEntries = SBE_MALLOC(Length);

                        if (This->NtBootEntries) {
                            Status = NtEnumerateBootEntries(This->NtBootEntries,
                                            &Length);
                        } else {
                            Status = STATUS_NO_MEMORY;
                        }                            
                    } 
                }
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        }

        //
        // Convert the NT boot entries to our representation
        //
        if (NT_SUCCESS(Status) && (This->NtBootEntries)) {
            PBOOT_ENTRY_LIST    ListEntry = This->NtBootEntries;
            PBOOT_ENTRY         CurrentNtEntry = &(ListEntry->BootEntry);
            PEFI_OS_BOOT_ENTRY  CurrentOsEntry = NULL;
            PEFI_OS_BOOT_ENTRY  LastEntry = NULL;

            while (CurrentNtEntry) {
                //
                // Create the OS entry
                //
                CurrentOsEntry = (PEFI_OS_BOOT_ENTRY)EFIOSBECreate(CurrentNtEntry, 
                                                        (POS_BOOT_OPTIONS)This);

                if (!CurrentOsEntry)  {
                    Status = STATUS_NO_MEMORY;

                    break;
                }

                //
                // found one more valid entry
                //
                This->OsBootOptions.EntryCount++;
                CurrentOsEntry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;

                //
                // If this is the first entry then setup the linked list head
                //
                if (!This->OsBootOptions.BootEntries) {
                    This->OsBootOptions.BootEntries = (POS_BOOT_ENTRY)(CurrentOsEntry);
                } 

                if (LastEntry) {
                    LastEntry->OsBootEntry.NextEntry = (POS_BOOT_ENTRY)CurrentOsEntry;
                }                    

                LastEntry = CurrentOsEntry;

                //
                // process the next entry, if available
                //
                if (ListEntry->NextEntryOffset) {
                    ListEntry = ADD_OFFSET(ListEntry, NextEntryOffset);
                    CurrentNtEntry = &(ListEntry->BootEntry);
                } else {
                    CurrentNtEntry = NULL;
                }                    
            }                                    
        }
        
        //
        // Now query the boot order
        //
        if (NT_SUCCESS(Status)) {
            Length = 0;

            Status = NtQueryBootEntryOrder(NULL,
                            &Length);

            if (Length) {
                PULONG  BootOrder = SBE_MALLOC(Length * sizeof(ULONG));

                if (BootOrder) {
                    memset(BootOrder, 0, Length);
                    This->OsBootOptions.BootOrder = BootOrder;
                    This->OsBootOptions.BootOrderCount = Length;

                    Status = NtQueryBootEntryOrder(BootOrder,
                                &Length);
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }

        //
        // Now setup the valid entries
        //
        if (NT_SUCCESS(Status)) {
            ULONG FirstEntryId = OSBOGetBootEntryIdByOrder((POS_BOOT_OPTIONS)This,
                                        0);

            if (FirstEntryId != (-1)) {
                This->OsBootOptions.CurrentEntry = 
                        OSBOFindBootEntry((POS_BOOT_OPTIONS)This,
                                FirstEntryId);
            } else {
                This->OsBootOptions.CurrentEntry = NULL;
            }
        }
        
        if (!NT_SUCCESS(Status)) {
            EFIOSBODelete((POS_BOOT_OPTIONS)This);
            This = NULL;
        }
    }

    return (POS_BOOT_OPTIONS)This;
}

static        
VOID
EFIOSBODelete(
    IN POS_BOOT_OPTIONS Obj
    )
{
    PEFI_OS_BOOT_OPTIONS This = (PEFI_OS_BOOT_OPTIONS)Obj;
    
    if (This) {
        //
        // delete each boot entry 
        //
        ULONG Index = 0;
        POS_BOOT_ENTRY Entry = OSBOGetFirstBootEntry(Obj, &Index);
        POS_BOOT_ENTRY NextEntry;

        while (Entry) {
            NextEntry = Entry->NextEntry;
            OSBEDelete(Entry);
            Entry = NextEntry;
        }

        //
        // delete the options
        //
        if (This->NtBootOptions)
            SBE_FREE(This->NtBootOptions);

        SBE_FREE(This);
    }        
}

static
POS_BOOT_ENTRY
EFIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    )
{
    PEFI_OS_BOOT_ENTRY  Entry = NULL;

    if (This && FriendlyName && OsLoaderVolumeName && OsLoaderPath &&
        BootVolumeName && BootPath) {
        Entry = SBE_MALLOC(sizeof(EFI_OS_BOOT_ENTRY));

        if (Entry) {
            memset(Entry, 0, sizeof(EFI_OS_BOOT_ENTRY));

            //
            // init core fields
            //
            EFIOSBEInit(Entry);            
            Entry->OsBootEntry.BootOptions = This;

            //
            // fill in the attributes
            //
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, FriendlyName);
            OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry, OsLoaderVolumeName);
            OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry, OsLoaderPath);
            OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry, BootVolumeName);
            OSBESetBootPath((POS_BOOT_ENTRY)Entry, BootPath);            

            if (OsLoadOptions) {
                OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry, OsLoadOptions);
            }
            
            //
            // Set the attribute specifying that this is a Windows option
            //
            OSBE_SET_WINDOWS(Entry);

            //
            // mark it dirty and new for flushing
            //
            OSBE_SET_NEW(Entry);
            OSBE_SET_DIRTY(Entry);                    

            //
            // Flush the entry now to get a proper Id;
            //
            if (!OSBEFlush((POS_BOOT_ENTRY)Entry)) {
                SBE_FREE(Entry);
                Entry = NULL;
            } else {
                ULONG   OrderCount;
                PULONG  NewOrder;
                
                Entry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;            
                Entry->OsBootEntry.NextEntry = This->BootEntries;
                This->BootEntries = (POS_BOOT_ENTRY)Entry;
                This->EntryCount++;

                //
                // Put the new entry at the end of the boot order
                //
                OrderCount = OSBOGetOrderedBootEntryCount(This);

                NewOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                if (NewOrder) {
                    memset(NewOrder, 0, sizeof(ULONG) * (OrderCount + 1));

                    //
                    // copy over the old ordered list
                    //
                    memcpy(NewOrder, This->BootOrder, sizeof(ULONG) * OrderCount);
                    NewOrder[OrderCount] = OSBEGetId((POS_BOOT_ENTRY)Entry);
                    SBE_FREE(This->BootOrder);
                    This->BootOrder = NewOrder;
                    This->BootOrderCount = OrderCount + 1;
                } else {
                    SBE_FREE(Entry);
                    Entry = NULL;
                }                    
            }                
        }
    }        
    
    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
EFIOSBOFlush(
    IN POS_BOOT_OPTIONS Obj
    )
{
    BOOLEAN Result = FALSE;
    PEFI_OS_BOOT_OPTIONS  This = (PEFI_OS_BOOT_OPTIONS)Obj;    

    if (This) { 
        ULONG Index;
        ULONG FieldsToChange = BOOT_OPTIONS_FIELD_COUNTDOWN |
                               BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID;
        ULONG OrderCount;                               
                               
        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Obj, &Index);

        //
        // First update the required entries
        //
        Result = TRUE;
        
        while (Entry) {
            if (!OSBE_IS_DELETED(Entry) && !OSBE_IS_NEW(Entry) &&
                !NT_SUCCESS(EFIOSBEFlush(Entry))) {
                Result = FALSE;
            }

            Entry = OSBOGetNextBootEntry(Obj, &Index);
        }

        if (Result) {
            Entry = OSBOGetFirstBootEntry(Obj, &Index);

            //
            // Next delete the required entries
            //
            Result = TRUE;
            
            while (Entry) {
                if (OSBE_IS_DELETED(Entry) && !NT_SUCCESS(EFIOSBEFlush(Entry))) {
                    Result = FALSE;
                }

                Entry = OSBOGetNextBootEntry(Obj, &Index);
            }
        }            

        if (Result) {
            POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Obj, &Index);

            //
            // Now create the required entries
            //            
            while (Entry) {
                if (OSBE_IS_NEW(Entry) && !NT_SUCCESS(EFIOSBEFlush(Entry))) {
                    Result = FALSE;
                }

                Entry = OSBOGetNextBootEntry(Obj, &Index);
            }
        }

        //
        // Safety check
        //
        OrderCount = min(Obj->BootOrderCount, Obj->EntryCount);
        
        //
        // Write the boot entry order
        //        
        if (!NT_SUCCESS(NtSetBootEntryOrder(Obj->BootOrder,
                            OrderCount))) {
            Result = FALSE;
        }

        //
        // Write the other boot options
        //
        This->NtBootOptions->Timeout = Obj->Timeout;

        //
        // Make sure NextBootEntry points to the active boot entry
        // so that we can boot the active boot entry
        //                
        if (Obj->BootOrderCount) {
            This->NtBootOptions->NextBootEntryId = Obj->BootOrder[0];
        }            
            
        if (!NT_SUCCESS(NtSetBootOptions(This->NtBootOptions,
                            FieldsToChange))) {
            Result = FALSE;
        }            
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\test\test.c ===
#include <efisbent.h>
#include <tchar.h>
#include <stdlib.h>


VOID
TraceResult(
    IN  PWSTR   Feature,
    IN BOOLEAN  Result
    )
{
    wprintf(L"%ws : %ws\n", Feature, Result ? L"Passed" : L"Failed");

    if (!Result) {
        exit(0);
    }        
}

VOID
DumpFilePath(
    IN  PFILE_PATH  FilePath
    )
{
    if (FilePath) {
        wprintf(L"%d:%ws\n", 
            FilePath->Type,
            FilePath->FilePath);
    }
}

VOID
DumpOsBootEntry(
    IN  POS_BOOT_ENTRY  Entry
    )
{
    if (Entry) {
        wprintf(L"%0d=>%ws,(%ws,%ws),(%ws,%ws),%ws\n", 
            OSBEGetId(Entry),
            OSBEGetFriendlyName(Entry),
            OSBEGetOsLoaderVolumeName(Entry),
            OSBEGetOsLoaderPath(Entry),
            OSBEGetBootVolumeName(Entry),
            OSBEGetBootPath(Entry),
            OSBEGetOsLoadOptions(Entry)
            );   

                    
    }
}

VOID
DumpOsBootOptions(
    IN  POS_BOOT_OPTIONS Options
    )
{
    if (Options) {
        ULONG   Index;
        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Options, &Index);

        wprintf(L"\n");
        
        while (Entry) {
            DumpOsBootEntry(Entry);
            Entry = OSBOGetNextBootEntry(Options, &Index);
        }

        for (Index=0; 
            Index < OSBOGetOrderedBootEntryCount(Options);
            Index++) {
            wprintf(L"%04d,", OSBOGetBootEntryIdByOrder(Options, Index));
        }                                            

        wprintf(L"\n\n");
    }
}

INT
__cdecl 
main(
    IN  INT Argc,
    IN  CHAR *Argv[]
    )
{
    POS_BOOT_OPTIONS    OsBootOptions = NULL;
    POS_BOOT_ENTRY  NewEntry;
    POS_BOOT_ENTRY  ActiveBootEntry;
    POS_BOOT_ENTRY  ConvertedEntry;

    OsBootOptions = EFIOSBOCreate();    

    TraceResult(L"Creating EFI OS BootOptions", (OsBootOptions != NULL));

    DumpOsBootOptions(OsBootOptions);        

    //
    // Add test
    //
    NewEntry = OSBOAddNewBootEntry(OsBootOptions,
                    L"Add Testing",
                    L"\\Device\\HarddiskVolume1",
                    L"\\setupldr.efi",
                    L"\\Device\\HarddiskVolume3",
                    L"\\WINDOWS",
                    L"/dummy1 /dummy2");                
                    
    TraceResult(L"Add test : ", (NewEntry != NULL));    
    DumpOsBootEntry(NewEntry);
    
    //
    // Search test
    //
    ActiveBootEntry = OSBOFindBootEntry(OsBootOptions, 10);
    TraceResult(L"Getting boot entry 0", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);

    //
    // Get active test
    //
    ActiveBootEntry = OSBOGetActiveBootEntry(OsBootOptions);
    TraceResult(L"Getting active boot entry", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);

    //
    // Set active test
    //
    ActiveBootEntry = OSBOSetActiveBootEntry(OsBootOptions, NewEntry);
    TraceResult(L"Setting active boot entry", (ActiveBootEntry != NULL));
    ActiveBootEntry = OSBOGetActiveBootEntry(OsBootOptions);
    TraceResult(L"Getting active boot entry again", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);    

    DumpOsBootOptions(OsBootOptions);   
    
    //
    // Delete boot entry test
    //
    TraceResult(L"Deleting new boot entry",
            OSBODeleteBootEntry(OsBootOptions, NewEntry));

    DumpOsBootOptions(OsBootOptions);   
    
    OSBODelete(OsBootOptions);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\compliance.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    compliance.c

Abstract:

    compliance checking routines.

Author:

    Andrew Ritz (andrewr) 2-Sept-1998

Revision History:

    2-Sept-1998 (andrewr) - created


Notes:

    These routines are for compliance checking:

    They check to see if an upgrade is allowed from the specified source to the destination.
    Since there are so many SKUs to be supported, it's necessary to have a small framework
    in place to handle all of these cases.  There are generally three parts to the compliance
    check:

    1) retreive source information and determine what SKU you want to install
    2) retrieve target information and determine what you are installing over
    3) do the actual compliance check of the target against the source to determine if upgrades
    are allowed, or if any installations are allowed from the target to the source.

    These types of checks need to be run in both kernel-mode and user-mode installations, so this
    common code library was created.  The kernel-mode specific code is in an #ifdef KERNEL_MODE
    block, and the usermode-specific code is in the #else branch.  Common code is outside of
    any #ifdef.  This library is only to be run (will only link with) setupdd.sys or winnt32a|u.dll.
    So when you change this code, keep in mind that it needs to run in both kernel mode and user mode.

    Also note that we have to do a bunch of handwaving since NT supports upgrades from win95.  Because of
    this, we cannot simply read the setupreg.hiv for some information about the installation.  Instead, we
    encode some additional information into setupp.ini (which is encoded in such a way as to discourage
    tinkering with it, but it by no means secure.  It provides about the same level of security (obscurity?!?)
    as setupreg.hiv gave us in the past.)


--*/




#ifdef KERNEL_MODE
    #include "textmode.h"
#else
    #include "winnt32.h"
    #include <stdio.h>
#endif

#include "COMPLIANCE.H"
#include "crcmodel.h"

#ifdef KERNEL_MODE
    #define assert(x) ASSERT(x);
#else
    #if DBG
        #define assert(x) if (!(x)) DebugBreak();
    #else
        #define assert(x)
    #endif
#endif

//
// NOTE - this MUST match setup\textmode\kernel\spconfig.c's array of product suites
// NOTE - need to handle terminal server, as well as citrix terminal server on NT3.51
//
#define SUITE_VALUES        COMPLIANCE_INSTALLSUITE_SBS,    \
                            COMPLIANCE_INSTALLSUITE_ENT,    \
                            COMPLIANCE_INSTALLSUITE_BACK,   \
                            COMPLIANCE_INSTALLSUITE_COMM,   \
                            COMPLIANCE_INSTALLSUITE_HYDRA,  \
                            COMPLIANCE_INSTALLSUITE_SBSR,   \
                            COMPLIANCE_INSTALLSUITE_EMBED,  \
                            COMPLIANCE_INSTALLSUITE_DTC,    \
                            COMPLIANCE_INSTALLSUITE_PER,    \
                            COMPLIANCE_INSTALLSUITE_BLADE


//
// globals
//

//
// Common functions shared between user-mode and kernel mode
//


DWORD
CRC_32(LPBYTE pb, DWORD cb)
{

//              CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//              but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//              we can store the CRC at the end of the block and expect 0 to be
//              the value of the CRC of the resulting block (including the stored
//              CRC).

        cm_t cmt = {
                32,             // cm_width  Parameter: Width in bits [8,32].
                0x04C11DB7, // cm_poly   Parameter: The algorithm's polynomial.
                0xFFFFFFFF, // cm_init   Parameter: Initial register value.
                TRUE,           // cm_refin  Parameter: Reflect input bytes?
                TRUE,           // cm_refot  Parameter: Reflect output CRC?
                0, // cm_xorot  Parameter: XOR this to output CRC.
                0                       // cm_reg        Context: Context during execution.
        };

        // Documented test case for CRC-32:
        // Checking "123456789" should return 0xCBF43926

        cm_ini(&cmt);
        cm_blk(&cmt, pb, cb);

        return cm_crc(&cmt);
}

#ifdef KERNEL_MODE

BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PUNICODE_STRING CSDVersion OPTIONAL
    );

BOOLEAN
DetermineSourceVersionInfo(
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  )
/*++

Routine Description:

  Finds the version and build number from

Arguments:

  InfPath - Fully qualified path to a inf file containing
  [version] section.

  Version - Place holder for version information
  BuildNumber - Place holder for build number

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  ULONG Major = 0, Minor = 0, Build = 0;

  //
  // We use PsGetVersion(...) API exported by the kernel
  //
  PsGetVersion(&Major, &Minor, &Build, NULL);

  if ((Major > 0) || (Minor > 0) || (Build > 0)) {
    Result = TRUE;

    if (Version)
      *Version = Major * 100 + Minor;

    if (BuildNumber)
      *BuildNumber = Build;
  }

  return Result;
}

#else

BOOLEAN
pGetVersionFromStr(
  TCHAR *VersionStr,
  DWORD *Version,
  DWORD *BuildNumber
  )
/*++

Routine Description:

  Parses a string with version information like "5.0.2195.1"
  and returns the values.

Arguments:

  VersionStr - The version string (most of the time its DriverVer string
               from the [Version] section in a inf like dosnet.inf)
  Version - The version (i.e. major * 100 + minor)
  BuildNumber - The build number like 2195

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  DWORD MajorVer = 0, MinorVer = 0, BuildNum = 0;
  TCHAR *EndPtr;
  TCHAR *EndChar;
  TCHAR TempBuff[64] = {0};

  if (VersionStr) {
    EndPtr = _tcschr(VersionStr, TEXT('.'));

    if (EndPtr) {
      _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
      MajorVer = _tcstol(TempBuff, &EndChar, 10);

      VersionStr = EndPtr + 1;

      if (VersionStr) {
        EndPtr = _tcschr(VersionStr, TEXT('.'));

        if (EndPtr) {
          memset(TempBuff, 0, sizeof(TempBuff));
          _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
          MinorVer = _tcstol(TempBuff, &EndChar, 10);

          VersionStr = EndPtr + 1;

          if (VersionStr) {
            EndPtr = _tcschr(VersionStr, TEXT('.'));

            if (EndPtr) {
              memset(TempBuff, 0, sizeof(TempBuff));
              _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));

              BuildNum = _tcstol(TempBuff, &EndChar, 10);
            }
          }
        }
      }
    }
  }

  if ((MajorVer > 0) || (MinorVer > 0) || (BuildNum > 0))
    Result = TRUE;

  if (Result) {
    if (Version)
      *Version = (MajorVer * 100) + MinorVer;

    if (BuildNumber)
      *BuildNumber = BuildNum;
  }

  return Result;
}

BOOLEAN
DetermineSourceVersionInfo(
  IN TCHAR *InfPath,
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  )
/*++

Routine Description:

  Finds the version and build number from

Arguments:

  InfPath - Fully qualified path to inf file containing
  [version] section.

  Version - Place holder for version information
  BuildNumber - Place holder for build number

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  TCHAR FileName[MAX_PATH];
  TCHAR Buffer[64] = {0};
  DWORD CharCount;

  CharCount = GetPrivateProfileString(TEXT("Version"), TEXT("DriverVer"), TEXT("0"),
                  Buffer, sizeof(Buffer)/sizeof(TCHAR), InfPath);

  if (CharCount) {
    TCHAR *TempPtr = _tcschr(Buffer, TEXT(','));

    if (TempPtr) {
      TempPtr++;
      Result = pGetVersionFromStr(TempPtr, Version, BuildNumber);
    }
  }

  return Result;
}


#endif


DWORD
DetermineSourceProduct(
    OUT DWORD *SourceSkuVariation,
    IN  PCOMPLIANCE_DATA Target
    )
/*++

Routine Description:

    This routine determines which sku you are installing.

    It does this by looking at
    a) the source install type
    b) the source install "sku" (stepup or full install)
    c) source suite type

Arguments:

    None.

Return Value:

    a COMPLIANCE_SKU_* flag indicating what sku you are installing, and COMPLIANCE_SKU_NONE for error

--*/

{
    COMPLIANCE_DATA cd;

    DWORD sku = COMPLIANCE_SKU_NONE;

    *SourceSkuVariation = COMPLIANCE_INSTALLVAR_SELECT;

#ifdef KERNEL_MODE

    if (!pSpGetCurrentInstallVariation(PidString,SourceSkuVariation)) {
        return(COMPLIANCE_SKU_NONE);
    }

    if (!pSpDetermineSourceProduct(&cd)) {
        return(COMPLIANCE_SKU_NONE);
    }
#else
    if (!GetSourceInstallVariation(SourceSkuVariation)) {
        return(COMPLIANCE_SKU_NONE);
    }

    if (!GetSourceComplianceData(&cd,Target)){
        return(COMPLIANCE_SKU_NONE);
    }
#endif

    switch (cd.InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTW:
            // suite check is done because kernel mode does not detect personal for the type.
            if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_PER) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTWPU;
                } else {
                    sku = COMPLIANCE_SKU_NTWPFULL;
                }
            } else {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTW32U;
                } else {
                    sku = COMPLIANCE_SKU_NTWFULL;
                }
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTWPU;
            } else {
                sku = COMPLIANCE_SKU_NTWPFULL;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTS:
            // suite checks are done because kernel mode does not detect dtc or ent for the type.
            if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_DTC) {
                sku = COMPLIANCE_SKU_NTSDTC;
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_BLADE) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSBU;
                } else {
                    sku = COMPLIANCE_SKU_NTSB;
                }
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_SBSR) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSBSU;
                } else {
                    sku = COMPLIANCE_SKU_NTSBS;
                }
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_ENT) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSEU;
                } else {
                    sku = COMPLIANCE_SKU_NTSEFULL;
                }
            } else {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSU;
                } else {
                    sku = COMPLIANCE_SKU_NTSFULL;
                }
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSBU;
            } else {
                sku = COMPLIANCE_SKU_NTSB;
            }
            break;
	
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSBSU;
            } else {
                sku = COMPLIANCE_SKU_NTSBS;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSEU;
            } else {
                sku = COMPLIANCE_SKU_NTSEFULL;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            sku = COMPLIANCE_SKU_NTSDTC;
            break;

        default:
            sku = COMPLIANCE_SKU_NONE;
    }


    return( sku );
}

BOOLEAN
CheckCompliance(
    IN DWORD SourceSku,
    IN DWORD SourceSkuVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA pcd,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    )
/*++

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    SourceSku           - a COMPLIANCE_SKU_* flag indicating the source type
    SourceSkuVariation  - a COMPLIANCE_VARIATION_* flag indicating what variation the source is
    pcd                 - pointer to a COMPLIANCE_DATA structure describing the current source
    Reason              - COMPLIANCEERR_ flag indicating why compliance check fails

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

    NOTE : The error value could be set irrespective of return value of TRUE or false. For full media
    the return value is always true and only the "NoUpgradeAllowed" variable gets set indicating
    whether upgrade is allowed or not.

--*/
{
    PCCMEDIA    SourceMedia = 0;
    BOOL        UpgradeAllowed = FALSE;
    BOOLEAN     Result;
    TCHAR       DebugStr[1024];

    if (pcd) {
        SourceMedia = CCMediaCreate(SourceSku, SourceSkuVariation,
                                        SourceVersion, SourceBuildNum);

        if (SourceMedia) {
            Result = SourceMedia->CheckInstall(SourceMedia, pcd, Reason, &UpgradeAllowed);
            *NoUpgradeAllowed = (UpgradeAllowed) ? FALSE : TRUE;

            CCMemFree(SourceMedia);
        } else {
            *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
            *NoUpgradeAllowed = TRUE;
            Result = FALSE;
        }
    } else {
        *Reason = COMPLIANCEERR_UNKNOWNTARGET;
        *NoUpgradeAllowed = TRUE;
        Result = FALSE;
    }

    return Result;
}


BOOL IsValidStepUpMode(
    CHAR  *StepUpArray,
    ULONG *StepUpMode
    )
{

    DWORD crcvalue,outval;

    #define BASE 'a'


    crcvalue = CRC_32( (LPBYTE)StepUpArray, 10 );
    RtlCopyMemory(&outval,&StepUpArray[10],sizeof(DWORD));
    if (crcvalue != outval ) {

#ifdef DBG

#ifdef KERNEL_MODE
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Setup: SpGetStepUpMode CRC didn't match for StepUpArray: %x %x\n", crcvalue, outval ));
#else
        OutputDebugString(TEXT("IsValidStepUpMode CRC failed\n"));
#endif

#endif // DBG

        return(FALSE);
        }

    if ((StepUpArray[3]-BASE)%2) {
        if ((StepUpArray[5]-BASE)%2) {

#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: this is stepup mode\n"));
#else
            OutputDebugString(TEXT("this is stepup mode\n"));
#endif

#endif //DBG

            *StepUpMode = 1;
            return(TRUE);
        } else {
#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: bad pid signature\n"));
#else
            OutputDebugString(TEXT("bad pid signature\n"));
#endif

#endif //DBG

            return(FALSE);
        }
    } else
        if ((StepUpArray[5]-BASE)%2) {

#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: bad pid signature\n"));
#else
            OutputDebugString(TEXT("bad pid signature\n"));
#endif

#endif //DBG

            return(FALSE);
        } else {
            *StepUpMode = 0;
            return(TRUE);
        }

    //
    // should never make it here
    //
    assert(FALSE);
    return(TRUE);

}



//
// Kernel mode only functions
//
#ifdef KERNEL_MODE
BOOL
pSpDetermineSourceProduct(
    PCOMPLIANCE_DATA pcd
    )
{
    ULONG i,tmp;

    TCHAR Dbg[1000];

    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)

    RtlZeroMemory(pcd,sizeof(COMPLIANCE_DATA));

    pcd->InstallType = AdvancedServer ?
                        COMPLIANCE_INSTALLTYPE_NTS :
                        COMPLIANCE_INSTALLTYPE_NTW ;
    pcd->RequiresValidation = (StepUpMode) ? TRUE : FALSE;


    for (i = 0,tmp=SuiteType; i<SuiteArrayCount;i++) {
        if (tmp&1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    if (pcd->InstallSuite == COMPLIANCE_INSTALLSUITE_UNKNOWN) {
        pcd->InstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
    }

    return TRUE;

}

BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    )
/*++

Routine Description:

    This routine determines what "variation" you have installed (retail,oem, select,etc.)

Arguments:

    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag

    It looks at the product Id in the registry to determine this, assuming that the
    product ID is a PID2.0 string.

Return Value:

    None.

--*/

{

    BOOLEAN retval = FALSE;
    WCHAR	Pid20Site[4] = {0};

    assert(CurrentInstallVariation != NULL);
    assert(szPid20 != NULL);

    if (!CurrentInstallVariation) {
        return(FALSE);
    }

    if (!szPid20 || (wcslen(szPid20) < 5)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
        return(TRUE);
    }

    *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    //
    // some versions of the product ID have hyphens in the registry, some do not
    //
    if (wcslen(szPid20) >= 8) {
	    if (wcschr(szPid20, '-')) {
	        wcsncpy(Pid20Site, szPid20 + 6, 3);
	    } else {
	        wcsncpy(Pid20Site, szPid20 + 5, 3);
	    }
	}		

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "Current site code: %S\n", Pid20Site ));

    if (wcscmp(Pid20Site, OEM_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;

    } else if (wcscmp(Pid20Site, SELECT_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    } else if (wcscmp(Pid20Site, MSDN_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;

    } else if (wcsncmp(szPid20, EVAL_MPC, 5) == 0) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    } else if ((wcsncmp(szPid20, SRV_NFR_MPC, 5) == 0) ||
               (wcsncmp(szPid20, ASRV_NFR_MPC, 5) == 0) ||
               (wcsncmp(szPid20, NT4SRV_NFR_MPC, 5) == 0)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_NFR;

    } else {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;

    }

    return(TRUE);

}


BOOLEAN
pSpDetermineCurrentInstallation(
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PCOMPLIANCE_DATA pcd
    )
/*++

Routine Description:

    This routine determines the sku you have currently have installed

Arguments:

    OsPartRegion - what region we're interested in looking at
    SystemRoot   - systemroot we want to look at
    pcd          - pointer to COMPLIANCE_DATA structure that gets filled in with info about the
                   installation the first params point to

Return Value:

    None.

--*/
{
    ULONG               MajorVersion, MinorVersion,
                        BuildNumber, ProductSuiteMask, ServicePack;
    NT_PRODUCT_TYPE     ProductType;
    UPG_PROGRESS_TYPE   UpgradeProgressValue;
    PWSTR               UniqueIdFromReg = NULL, Pid = NULL;
    NTSTATUS            NtStatus;
    ULONG               i,tmp;
    BOOLEAN             bIsEvalVariation = FALSE;
    DWORD               *pInstallSuite = 0;
    DWORD               *pInstallType = 0;


    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)

    assert( pcd != NULL ) ;

    RtlZeroMemory(pcd,sizeof(COMPLIANCE_DATA));

    NtStatus = SpDetermineProduct(OsPartRegion,
                                  SystemRoot,
                                  &ProductType,
                                  &MajorVersion,
                                  &MinorVersion,
                                  &BuildNumber,
                                  &ProductSuiteMask,
                                  &UpgradeProgressValue,
                                  &UniqueIdFromReg,
                                  &Pid,
                                  &bIsEvalVariation,
                                  NULL,
                                  &ServicePack);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: pSpIsCompliant couldn't SpDetermineProduct(), ec = %x\n", NtStatus ));
        return(FALSE);
    }

    /*
    //
    // Note that we don't handle the case of upgrading from win9x here
    // this is because the compliance check for win9x is *always* completed in
    // winnt32; you can't upgrade to NT from win9x without running winnt32.
    //
    pcd->InstallType = AdvancedServer ? COMPLIANCE_INSTALLTYPE_NTS : COMPLIANCE_INSTALLTYPE_NTW;
    */

    switch (ProductType) {
        case NtProductWinNt:
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;

        case NtProductLanManNt:
        case NtProductServer:
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTS;
            break;

        default:
            // by default assume the installation type to be
            // NT workstation
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;
    }

    pSpGetCurrentInstallVariation(Pid, &pcd->InstallVariation);

    //
    // if we defaulted in previous call and installation has time bomb
    // then assume the var is of type EVAL
    //
    if ((pcd->InstallVariation == COMPLIANCE_INSTALLVAR_CDRETAIL) && bIsEvalVariation)
        pcd->InstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    pcd->RequiresValidation = StepUpMode ? TRUE : FALSE;
    pcd->MinimumVersion = MajorVersion * 100 + MinorVersion*10;
    pcd->InstallServicePack = ServicePack;
    pcd->BuildNumberNt = BuildNumber;
    pcd->BuildNumberWin9x = 0;

    for (i = 0,tmp=ProductSuiteMask; i<SuiteArrayCount;i++) {
        if (tmp&1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    pInstallSuite = &(pcd->InstallSuite);
    pInstallType = &(pcd->InstallType);

    //
    // from the install suite find the correct type of install
    // type for the server (i.e. NTS, NTSE, NTSDTC or NTSTSE)
    //
    if (*pInstallSuite == COMPLIANCE_INSTALLSUITE_UNKNOWN)
        *pInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
    else {
        if (*pInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
            if ((BuildNumber <= 1381) &&
                    *pInstallSuite == COMPLIANCE_INSTALLSUITE_HYDRA) {
                *pInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
            } else {
                if (*pInstallSuite & COMPLIANCE_INSTALLSUITE_DTC) {
                    *pInstallType = COMPLIANCE_INSTALLTYPE_NTSDTC;
                } else {
                    if (*pInstallSuite & COMPLIANCE_INSTALLSUITE_ENT) {
                        *pInstallType = COMPLIANCE_INSTALLTYPE_NTSE;
                    }
                }
            }
        }
    }

    //
    // since there is no data center EVAL type if we detect its eval
    // because of time bomb set, we assume it to be CD-Retail.
    //
    if((pcd->InstallVariation == COMPLIANCE_INSTALLVAR_EVAL) &&
            (*pInstallType == COMPLIANCE_INSTALLTYPE_NTSDTC)) {
        pcd->InstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }	

    //
    // Free up the allocated memory
    //
    if (UniqueIdFromReg)
        SpMemFree(UniqueIdFromReg);

    if (Pid)
        SpMemFree(Pid);

    return(TRUE);
}

BOOLEAN
pSpIsCompliant(
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PBOOLEAN UpgradeOnlyCompliant
    )
/*++

Routine Description:

    This routine determines if the current specified installation is compliant for the
    source we want to install

Arguments:

    InfPath - inf file path containing [Version] section with DriverVer data
    OsPartRegion - points to target
    SystemRoot - points to target
    UpgradeOnlyCompliant - set to TRUE if we can only allow upgrades from the source SKU

Return Value:

    TRUE if the current target is compliant for the source.

--*/
{
    ULONG MajorVersion, MinorVersion, BuildNumber, ProductSuiteMask;
    NT_PRODUCT_TYPE ProductType;
    UPG_PROGRESS_TYPE UpgradeProgressValue;
    PWSTR UniqueIdFromReg, Pid;
    NTSTATUS NtStatus;
    BOOLEAN Rslt;
    BOOL UpgOnly = FALSE;
    COMPLIANCE_DATA TargetData;
    DWORD SourceData,SourceSkuVariation;
    UINT dontcare;
    BOOL dontcare2;

    assert(UpgradeOnlyCompliant != NULL);

    if ((SourceData = DetermineSourceProduct(&SourceSkuVariation,NULL))== COMPLIANCE_SKU_NONE) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "setup: Couldnt' determine source SKU\n" ));
        return(FALSE);
    }

    if (!pSpDetermineCurrentInstallation( OsPartRegion, SystemRoot, &TargetData)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "setup: pSpDetermineCurrentInstallation failed\n" ));
        return(FALSE);
    }

    UpgOnly = TargetData.RequiresValidation;

    Rslt = CheckCompliance(SourceData, SourceSkuVariation, SourceVersion,
                      SourceBuildNum, &TargetData,&dontcare,&dontcare2);

	*UpgradeOnlyCompliant = (UpgOnly != 0);

    return(Rslt);
}

#define NibbleToChar(x) (N2C[x])
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))
char N2C[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};


BOOLEAN
MyTranslatePrivateProfileStruct(
    PSTR   InputString,
    LPVOID lpStruct,
    UINT   uSizeStruct
    )
/*++

Routine Description:

    translates a string from an encoded checksummed version into the real structure.
    stolen from GetPrivateProfileStructA

Arguments:

    InputString - pointer to input string to convert
    lpStruct - point to structure that receives the converted data
    uSizeStruct - size of the input structure

Return Value:

    TRUE if it succeeds in translating into the specified structure, FALSE otherwise.

--*/

{

    CHAR szBuf[256] = {0};
    PSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen,tmp;
    BYTE checksum;
    BOOLEAN Result;

    lpFreeBuffer = NULL;
    lpBuf = (PSTR)szBuf;

    Result = FALSE;

    nLen = strlen( InputString );
    RtlCopyMemory( lpBuf, InputString, nLen );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            BYTE cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                    }
                break;
                }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
            }
        }

    return Result;
}



BOOLEAN
SpGetStepUpMode(
    PWSTR   PidExtraData,
    BOOLEAN *StepUpMode
    )
/*++

Routine Description:

    This routine determines if the specified source is in Step Up Mode or
    if it's a full retail install.

Arguments:

    PidExtraData - checksummed encoded data read out of setupp.ini
    StepUpMode   - set to TRUE if we're in stepup mode.  value is undefined if
                   we fail to translate the input data.

    This routine assumes that the data passed in is a string set by the "pidinit"
    program.  It decodes this data and makes sure the checksum is correct.
    It then checks the CRC value tacked onto the string to determine if the
    data has been tampered with.
    If both of these checks pass, then it looks at the actual data.
    The actual check is this: If the 3rd and 5th bytes are modulo 2 (when
    subtracted from the base value 'a'), then we're in stepup mode.  Otherwise
    we're in full retail mode.

    Note that the intent of this algorithm isn't to provide alot of security
    (it will be trivial to copy the desired setupp.ini over the current one),
    it's main intent is to discourage people from tampering with these values
    in the same manner that data is set in the default hives to discourage
    tampering.

Return Value:

    TRUE if we're able to determine the stepupmode.  FALSE if the input data is bogus.

--*/
{
    CHAR Buffer[64] = {0};
    CHAR StepUpArray[14];
    ULONG Needed;
    BOOL Mode;
    NTSTATUS NtStatus;

    NtStatus = RtlUnicodeToOemN(Buffer,
                                sizeof(Buffer),
                                &Needed,
                                PidExtraData,
                                wcslen(PidExtraData)*sizeof(WCHAR)
                                );

    if (! NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: SpGetStepUpMode couldn't RtlUnicodeToOemN failed, ec = %x\n", NtStatus ));
        return(FALSE);
    }


    if (!MyTranslatePrivateProfileStruct(Buffer,StepUpArray,sizeof(StepUpArray))) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: SpGetStepUpMode couldn't MyTranslatePrivateProfileStruct\n" ));
        return(FALSE);
    }

    if (!IsValidStepUpMode( StepUpArray , &Mode )) {
        return(FALSE);
    }

    *StepUpMode = Mode ? TRUE : FALSE;
    return(TRUE);



}

#endif


//
// User mode only functions
//

#ifndef KERNEL_MODE

BOOL
GetCdSourceInstallType(
    LPDWORD SourceInstallType
    )
/*++

Routine Description:

    This routine determines what version of NT you are installing, NTW or NTS.  It does this by looking in
    dosnet.inf

Arguments:

    SourceInstallType -- receives a COMPLIANCE_INSTALLTYPE flag indicating what type you are installing

Return Value:

    TRUE for success, FALSE for failure

--*/

{

    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

    wsprintf( FileName, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    GetPrivateProfileString(TEXT("Miscellaneous"), TEXT("ProductType"), TEXT("0"),
            Buffer, sizeof(Buffer)/sizeof(TCHAR), FileName);

    switch (_tcstoul(Buffer, &p, 10) ) {
        case 0:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;
        case 1:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTS;
            break;
        case 2:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTSE;
            break;
        case 3:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTSDTC;
            break;
        case 4:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTWP;
            break;
        case 5:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTSB;
            break;
        case 6:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTSBS;
            break;
        default:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTW;
            return(FALSE);
    }

    return(TRUE);

}

BOOL
GetStepUpMode(
    BOOL *StepUpMode
    )
/*++

Routine Description:

    This routine determines if the specified source is in Step Up Mode or
    if it's a full retail install.

Arguments:

    StepUpMode   - set to TRUE if we're in stepup mode.  value is undefined if
                   we fail to translate the input data.

    This routine assumes that the data passed in is a string set by the "pidinit"
    program.  It decodes this data and makes sure the checksum is correct.
    It then checks the CRC value tacked onto the string to determine if the
    data has been tampered with.
    If both of these checks pass, then it looks at the actual data.
    The actual check is this: If the 3rd and 5th bytes are modulo 2 (when
    subtracted from the base value 'a'), then we're in stepup mode.  Otherwise
    we're in full retail mode.

    Note that the intent of this algorithm isn't to provide alot of security
    (it will be trivial to copy the desired setupp.ini over the current one),
    it's main intent is to discourage people from tampering with these values
    in the same manner that data is set in the default hives to discourage
    tampering.

Return Value:

    TRUE if we're able to determine the stepupmode.  FALSE if the input data is bogus.

--*/
{

    char FileName[MAX_PATH];
    char  data[14];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

#ifdef UNICODE
    char SourcePath[MAX_PATH];
    BOOL changed = FALSE;

    WideCharToMultiByte(CP_ACP,
                        0,
                        NativeSourcePaths[0],
                        MAX_PATH,
                        SourcePath,
                        sizeof(SourcePath),
                        "?",
                        &changed);

    sprintf( FileName, "%s\\setupp.ini", SourcePath);
#else
    sprintf( FileName, "%s\\setupp.ini", NativeSourcePaths[0]);
#endif

    GetPrivateProfileStructA("Pid",
                             "ExtraData",
                             data,
                             sizeof(data),
                             FileName);



    if (!IsValidStepUpMode(data,StepUpMode)) {
        return(FALSE);
    }

    return(TRUE);

}

BOOL
GetSuiteInfoFromDosnet(
    OUT LPDWORD Suite
    )
/*++

Routine Description:

    This routine determines what suite you are installing
    It does this by looking at dosnet.inf

Arguments:

    Suite  -- receives a COMPLIANCE_INSTALLSUITE flag

Return Value:

    TRUE for success, FALSE for failure

--*/

{

    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

    *Suite = COMPLIANCE_INSTALLSUITE_ANY;

    wsprintf( FileName, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    GetPrivateProfileString(TEXT("Miscellaneous"), TEXT("ProductType"), TEXT("0"),
                Buffer, sizeof(Buffer)/sizeof(TCHAR), FileName);

    switch (_tcstoul(Buffer, &p, 10) ) {
        case 0:
        case 1:
            *Suite = COMPLIANCE_INSTALLSUITE_NONE;
            break;
        case 2:
            *Suite = COMPLIANCE_INSTALLSUITE_ENT;
            break;
        case 3:
            *Suite = COMPLIANCE_INSTALLSUITE_DTC;
            break;
        case 4:
            *Suite = COMPLIANCE_INSTALLSUITE_PER;
            break;
        case 5:
            *Suite = COMPLIANCE_INSTALLSUITE_BLADE;
            break;
        default:
            ;
#ifdef DBG
            OutputDebugString( TEXT("Invalid ProductType!\n"));
#endif
            return(FALSE);
    }

    return (TRUE);

}


BOOL
GetSourceInstallVariation(
    LPDWORD SourceInstallVariation
    )
/*++

Routine Description:

    This routine determines what variation of NT you are installing, SELECT,OEM,retail...

Arguments:

    SourceInstallVariation -- receives a COMPLIANCE_INSTALLVAR flag indicating what var
                              type you are installing

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    GetSourceInstallType(SourceInstallVariation);


    /*
    switch(SourceInstallType) {
        case SelectInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;
            break;

        case OEMInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_OEM;
            break;

        case RetailInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
            break;

        case MSDNInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;
            break;

        case EvalInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;
            break;

        case NFRInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_NFR;
            break;

        default:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;
            break;
    }
    */

    return(TRUE);
}


BOOL
GetSourceComplianceData(
    OUT PCOMPLIANCE_DATA pcd,
    IN  PCOMPLIANCE_DATA Target
    )
{
#ifdef USE_HIVE
    TCHAR HiveLocation[MAX_PATH];
    TCHAR HiveTarget[MAX_PATH];
    TCHAR HivePath[MAX_PATH];
    TCHAR HiveName[MAX_PATH] = TEXT("xSETREG");
    TCHAR lpszSetupReg[MAX_PATH] = TEXT("xSETREG\\ControlSet001\\Services\\setupdd");
    TCHAR TargetPath[MAX_PATH];

    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    DWORD tmp,i;
#endif

    BOOL RetVal = FALSE;

#ifdef DBG
    TCHAR Dbg[1000];
#endif

#ifdef USE_HIVE
    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)
#endif

    ZeroMemory( pcd, sizeof(COMPLIANCE_DATA) );

    if (!GetCdSourceInstallType(&pcd->InstallType)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getcdsourceinstalltype\n"));
#endif
        goto e0;
    }


    if (!GetSourceInstallVariation(&pcd->InstallVariation)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getsourceinstallvariation\n"));
#endif
        goto e0;
    }

    if (!GetStepUpMode(&pcd->RequiresValidation)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getstepupmode\n"));
#endif
        goto e0;
    }

    RetVal = GetSuiteInfoFromDosnet( &pcd->InstallSuite ) ;
    goto e0;

#ifdef USE_HIVE
    //
    // now we need to determine if we are installing enterprise or datacenter
    // To do this, we try to load the registry hive, but this won't work on
    // win9x or nt 3.51.  So we use dosnet.inf to get the information we need
    // in those cases.
    //
    if ( (Target->InstallType &
         (COMPLIANCE_INSTALLTYPE_WIN31 | COMPLIANCE_INSTALLTYPE_WIN9X)) ||
         (Target->BuildNumberNt < 1381) ) {
        RetVal = GetSuiteInfoFromDosnet( &pcd->InstallSuite ) ;
        goto e0;
    }


    //
    // copy the hive locally since you can only have one open on a hive at a time
    //
    wsprintf( HiveLocation, TEXT("%s\\setupreg.hiv"), NativeSourcePaths[0]);
    GetTempPath(MAX_PATH,TargetPath);
    GetTempFileName(TargetPath,TEXT("set"),0,HiveTarget);

    CopyFile(HiveLocation,HiveTarget,FALSE);
    SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);

#ifdef DBG
    OutputDebugString(HiveLocation);
    OutputDebugString(TEXT("\n"));
    OutputDebugString(HiveTarget);
#endif

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HiveName, HiveTarget );
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        wsprintf( Dbg, TEXT("Couldn't RegLoadKey, ec = %d\n"), rslt );
        OutputDebugString(Dbg);
#endif
        //assert(FALSE);
        goto e1;
    }

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegOpenKey\n"));
#endif
        //assert(FALSE);
        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegQueryValueEx\n"));
#endif
        //assert(FALSE);
        goto e3;
    }

    for (i = 0,tmp=Buffer[3]; i<SuiteArrayCount;i++) {
        if (tmp & 1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

e1:
    if (GetFileAttributes(HiveTarget) != 0xFFFFFFFF) {
        SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(HiveTarget);
    }
#endif // USE_HIVE
e0:

    return(RetVal);

}


BOOL
GetCurrentNtVersion(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallSuite
    )
/*++

Routine Description:

    This routine determines what type of NT you currently have installed, NTW or NTS,
    as well as what product suite you have installed.

    It looks in the registry for this data.

Arguments:

    CurrentInstallType - receives a COMPLIANCE_INSTALLTYPE_* flag
    CurrentInstallSuite - receives a COMPLIANCE_INSTALLSUITE_* flag

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    LPCTSTR lpszProductKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
    LPCTSTR lpszProductType = TEXT("ProductType");
    LPCTSTR lpszProductSuite = TEXT("ProductSuite");
    LPCTSTR lpszProductSuites[] = { TEXT("Small Business"),
                                    TEXT("Enterprise"),
                                    TEXT("BackOffice"),
                                    TEXT("CommunicationServer"),
                                    TEXT("Terminal Server"),
                                    TEXT("Small Business(Restricted)"),
                                    TEXT("EmbeddedNT"),
                                    TEXT("DataCenter"),
                                    TEXT("Personal"),
                                    TEXT("Blade")
                                  };

    DWORD   ProductSuites[] = { SUITE_VALUES };

    #define CountProductSuites  sizeof(ProductSuites)/sizeof(DWORD)

    LPCTSTR lpszProductTypeNTW = TEXT("WinNT");

    LPCTSTR lpszCitrixKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\Citrix");
    LPCTSTR lpszOemKey = TEXT("OemId");
    LPCTSTR lpszProductVersion = TEXT("ProductVersion");

    HKEY hKey;
    long rslt;
    DWORD Type;
    LPTSTR p;
    TCHAR Buffer[MAX_PATH];
    DWORD BufferSize = sizeof(Buffer);
    DWORD i;
    BOOL retval = FALSE;


    //
    // default to NTW
    //
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTW;
    *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszProductKey,&hKey);
    if (rslt != NO_ERROR) {
        return(FALSE);
    }

    rslt = RegQueryValueEx(hKey, lpszProductType, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != NO_ERROR || Type != REG_SZ) {
        goto exit;
    }

    if (lstrcmpi(Buffer,lpszProductTypeNTW) != 0) {
        //
        // we have some version of NTS
        //
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTS;
    }

    retval = TRUE;

    BufferSize = sizeof(Buffer);
    ZeroMemory(Buffer,sizeof(Buffer));
    rslt = RegQueryValueEx(hKey, lpszProductSuite, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != NO_ERROR || Type != REG_MULTI_SZ) {
        //
        // might not be there for NT 3.51, just succeed if it's not there
        // Also, won't be there for Professional - aka WKS
        //
        goto exit;
    }

    p = &Buffer[0];
    while (p && *p) {
        for (i = 0; i < CountProductSuites; i++) {
            if (lstrcmp(p, lpszProductSuites[i]) == 0) {
                *CurrentInstallSuite |= ProductSuites[i];
            }
        }

        //
        // point to the next product suite
        //
        p += lstrlen(p) + 1;
    }

    retval = TRUE;

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_DTC)
     && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSDTC;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_ENT)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSE;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_BLADE)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSB;
    }
    
    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_SBSR)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSBS;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_PER)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTW) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTWP;
    }

    if (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_ANY) {
        *CurrentInstallSuite = *CurrentInstallSuite & (~COMPLIANCE_INSTALLSUITE_NONE);
    }


exit:
    RegCloseKey(hKey);

    //
    // if we haven't found a product suite at this point, look for Citrix WinFrame,
    // which we'll treat as terminal server
    //

    if (*CurrentInstallSuite == COMPLIANCE_INSTALLSUITE_NONE) {

        rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszCitrixKey,&hKey);
        if (rslt != NO_ERROR) {
            return(TRUE);
        }

        BufferSize = sizeof(Buffer);
        rslt = RegQueryValueEx(
                       hKey,
                       lpszOemKey,
                       NULL,
                       &Type,
                       (LPBYTE) Buffer,
                       &BufferSize);
        if (rslt == NO_ERROR && Type == REG_SZ) {
            if (Buffer[0] != TEXT('\0')) {
                BufferSize = sizeof(Buffer);
                rslt = RegQueryValueEx(
                                hKey,
                                lpszProductVersion,
                                NULL,
                                &Type,
                                (LPBYTE) Buffer,
                                &BufferSize);

                if (rslt == NO_ERROR) {
                    *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_HYDRA;
                    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return(retval);
}

BOOL
GetCurrentInstallVariation(
    OUT LPDWORD CurrentInstallVariation,
    IN  DWORD   CurrentInstallType,
    IN  DWORD   CurrentInstallBuildNT,
    IN  DWORD   InstallVersion
    )
/*++

Routine Description:

    This routine determines what "variation" you have installed (retail,oem, select,etc.)

Arguments:

    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag

    It looks at the product Id in the registry to determine this, assuming that the
    product ID is a PID2.0 string. To check whether its a EVAL variation or not
    it looks at "PriorityQuantumMatrix" value in registry

Return Value:

    None.

--*/

{
    LPCTSTR lpszPidKeyWin      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    LPCTSTR lpszPidKeyWinNT    = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
    LPCTSTR lpszProductId      = TEXT("ProductId");
    LPCTSTR szEvalKey          = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Executive");
    LPCTSTR szPQMValue         = TEXT("PriorityQuantumMatrix");

    HKEY    hKey = NULL;
    long    rslt;
    DWORD   Type;
    LPTSTR  p;
    TCHAR   Buffer[MAX_PATH];
    DWORD   BufferSize = sizeof(Buffer);
    DWORD   i;
    BOOL    bResult = FALSE;
    BOOLEAN bDone = FALSE;
    TCHAR   Pid20Site[4];
    TCHAR   MPCCode[6] = {-1};
    BYTE    abPQM[64] = {-1};

    *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,
                      ISNT() ? lpszPidKeyWinNT : lpszPidKeyWin,
                      &hKey);

    if (rslt != NO_ERROR) {
        goto exit;
    }

    rslt = RegQueryValueEx(hKey, lpszProductId, NULL, &Type, (LPBYTE) Buffer, &BufferSize);

    if (rslt != NO_ERROR || Type!=REG_SZ || (!IsWinPEMode() && (lstrlen(Buffer) < 20))) {
        //
        // nt 3.51 is pid 1.0 instead of pid 2.0.  Just assume it's
        // oem variation for now.
        //
        if (((CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) ||
            (CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTW)  ||
            (CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTSTSE)) &&
            (CurrentInstallBuildNT < 1381 )) {
            *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;
            bResult = TRUE;
        }
        goto exit;
    }

    // get the MPC code from PID
    lstrcpyn(MPCCode, Buffer, 6);

    //
    // some versions of the product ID have hyphens in the registry, some do not
    //
    if (_tcschr(Buffer, TEXT('-'))) {
        lstrcpyn(Pid20Site,&Buffer[6],4);
        Pid20Site[3] = (TCHAR) NULL;
    } else {
        lstrcpyn(Pid20Site,&Buffer[5],4);
        Pid20Site[3] = (TCHAR) NULL;
    }

//    OutputDebugString(Pid20Site);
//    OutputDebugString(TEXT("\r\n"));
//    OutputDebugString(MPCCode);


    if (lstrcmp(Pid20Site, OEM_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;

    } else if (lstrcmp(Pid20Site, SELECT_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    } else if (lstrcmp(Pid20Site, MSDN_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;

    } else if (lstrcmp(MPCCode, EVAL_MPC) == 0) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    } else if ((lstrcmp(MPCCode, SRV_NFR_MPC) == 0) ||
             (lstrcmp(MPCCode, ASRV_NFR_MPC) == 0) ||
             (lstrcmp(MPCCode, NT4SRV_NFR_MPC) == 0)){
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_NFR;

    } else {
        //
        // find out if installation is of type EVAL variation (On NT install only)
        // if timebomb is set we assume its EVAL except for DataCenter because
        // there is no EVAL DataCenter SKU.
        //
        if (ISNT() && (CurrentInstallType != COMPLIANCE_INSTALLTYPE_NTSDTC) && (InstallVersion < 500)) {
            HKEY    hEvalKey = NULL;

            if (RegOpenKey(HKEY_LOCAL_MACHINE, szEvalKey, &hEvalKey) == ERROR_SUCCESS) {
                DWORD   dwSize = sizeof(abPQM);

                if (RegQueryValueEx(hEvalKey, szPQMValue, NULL, &Type, abPQM, &dwSize)
                        == ERROR_SUCCESS) {

                    // any of bytes 4-7 (inclusive)
                    if ((Type == REG_BINARY) && (dwSize >= 8) && (*(ULONG *)(abPQM + 4))) {
                        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;
					}
                }

                RegCloseKey(hEvalKey);
            }
        }


        // last default assumption (since we could not find var type).
        if (*CurrentInstallVariation == COMPLIANCE_INSTALLVAR_SELECT)
	        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }

    bResult = TRUE;

exit:
    //
    // If we couldn't find a PID, just treat the current OS as retail
    //
    if (!bResult) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
        bResult = TRUE;
    }

    if (hKey)
        RegCloseKey(hKey);

    return  bResult;
}


BOOL
DetermineCurrentInstallation(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallVariation,
    LPDWORD CurrentInstallVersion,
    LPDWORD CurrentInstallBuildNT,
    LPDWORD CurrentInstallBuildWin9x,
    LPDWORD CurrentInstallSuite,
    LPDWORD CurrentInstallServicePack
    )
/*++

Routine Description:

    This routine determines the current installation you have installed, including
    a) current install type (NTW,NTS,Win9x
    b) current install variation (oem,select, retail)
    c) current install version (for NT only!)
    d) current install suite (SBS, ENTERPRISE,etc.)

Arguments:

    CurrentInstallType -  receives a COMPLIANCE_INSTALLTYPE_* flag
    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag
    CurrentInstallVersion - receives a representation of the build (major.minor * 100), ie., 3.51 == 351
    CurrentInstallBuildNT -  build number for an nt install
    CurrentInstallBuildWin9 - build number for a win9x install
    CurrentInstallSuite - receives a COMPLIANCE_INSTALLSUITE_* flag

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL useExtendedInfo;
    union {
        OSVERSIONINFO Normal;
        OSVERSIONINFOEX Ex;
    } Ovi;


#ifdef DBG
    TCHAR dbg[1000];
#endif

    if (!CurrentInstallType || !CurrentInstallVariation || !CurrentInstallVersion || !CurrentInstallSuite) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    useExtendedInfo = TRUE;
    Ovi.Ex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Ex) ) {
        //
        // EX size not available; try the normal one
        //

        Ovi.Normal.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Normal) ) {
            assert(FALSE);
            return(FALSE);
        }

        useExtendedInfo = FALSE;
    }

    switch (Ovi.Normal.dwPlatformId) {
        case VER_PLATFORM_WIN32s:
#ifdef DBG
            OutputDebugString(TEXT("Win32s current installation!!!"));
#endif
            //assert(FALSE);
            return(FALSE);
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            *CurrentInstallType = COMPLIANCE_INSTALLTYPE_WIN9X;
            *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
            *CurrentInstallBuildNT = 0;
            *CurrentInstallBuildWin9x = Ovi.Normal.dwBuildNumber;
#ifdef DBG
            wsprintf(dbg, TEXT("%d\n"), *CurrentInstallBuildWin9x);
            OutputDebugString(dbg);
#endif
            //
            // Need to know what version of windows is installed so we can block upgrade
            // from win95.
            //
            *CurrentInstallVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;

            if (useExtendedInfo) {
                *CurrentInstallServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
            } else {
                *CurrentInstallServicePack = 0;
            }
            break;
        case VER_PLATFORM_WIN32_NT:
            if (!GetCurrentNtVersion(
                                CurrentInstallType,
                                CurrentInstallSuite)) {
                return(FALSE);
            }

            *CurrentInstallVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;

            if (useExtendedInfo) {
                *CurrentInstallServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
            } else {
                *CurrentInstallServicePack = 0;
            }

            *CurrentInstallBuildWin9x = 0;
            *CurrentInstallBuildNT = Ovi.Normal.dwBuildNumber;

            if (*CurrentInstallBuildNT <= 1381
                && *CurrentInstallSuite == COMPLIANCE_INSTALLSUITE_HYDRA) {
                *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
            }

            break;
    default:
#ifdef DBG
        OutputDebugString(TEXT("unknown installation!!!"));
#endif
        assert(FALSE);
        return(FALSE);
    }

    if (!GetCurrentInstallVariation(CurrentInstallVariation,*CurrentInstallType,*CurrentInstallBuildNT, *CurrentInstallVersion)) {
#ifdef DBG
        OutputDebugString(TEXT("GetCurrentInstallVariation failed\n"));
#endif
        //assert(FALSE);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
IsCompliant(
    PBOOL UpgradeOnly,
    PBOOL NoUpgradeAllowed,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallVersion,
    PUINT Reason
    )
/*++

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    UpgradeOnly - This flag gets set to TRUE if the current SKU only allows upgrades.  This
                  lets winnt32 know that it should not allow a clean install from the current
                  media.  This get's set correctly regardless of the compliance check passing
    SrcSku      - COMPLIANCE_SKU flag indicating source sku (for error msg's)
    Reason      - COMPLIANCEERR flag indicating why compliance check failed.

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

--*/
{
    DWORD SourceSku;
    DWORD SourceSkuVariation;
    DWORD SourceVersion;
    DWORD SourceBuildNum;
    TCHAR DosnetPath[MAX_PATH] = {0};

    COMPLIANCE_DATA TargetData;

    ZeroMemory(&TargetData, sizeof(TargetData) );

    *UpgradeOnly = FALSE;
    *NoUpgradeAllowed = TRUE;
    *Reason = COMPLIANCEERR_UNKNOWN;
    *SrcSku = COMPLIANCE_SKU_NONE;
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    *CurrentInstallVersion = 0;

    if (!DetermineCurrentInstallation(&TargetData.InstallType,
                                  &TargetData.InstallVariation,
                                  &TargetData.MinimumVersion,
                                  &TargetData.BuildNumberNt,
                                  &TargetData.BuildNumberWin9x,
                                  &TargetData.InstallSuite,
                                  &TargetData.InstallServicePack)) {
#ifdef DBG
        OutputDebugString(TEXT("Error determining current installation"));
#endif
        *Reason = COMPLIANCEERR_UNKNOWNTARGET;
        return(FALSE);
    }

    *CurrentInstallType = TargetData.InstallType;
    if (TargetData.InstallType & COMPLIANCE_INSTALLTYPE_WIN9X) {
        *CurrentInstallVersion = TargetData.BuildNumberWin9x;
    } else {
        *CurrentInstallVersion = TargetData.BuildNumberNt;
    }

    if ((SourceSku = DetermineSourceProduct(&SourceSkuVariation,&TargetData)) == COMPLIANCE_SKU_NONE) {
#ifdef DBG
        OutputDebugString(TEXT("couldn't determine source sku!"));
#endif
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    wsprintf(DosnetPath, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    if (!DetermineSourceVersionInfo(DosnetPath, &SourceVersion, &SourceBuildNum)) {
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTW32U:
        //case COMPLIANCE_SKU_NTWU:
        //case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTSU:
        case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTWPU:
        case COMPLIANCE_SKU_NTSBU:
        case COMPLIANCE_SKU_NTSBSU:
            *UpgradeOnly = TRUE;
            break;
        default:
            *UpgradeOnly = FALSE;
    }

    *SrcSku = SourceSku;

    if( ISNT() && TargetData.MinimumVersion == 400 && TargetData.InstallServicePack < 500) {
        *Reason = COMPLIANCEERR_SERVICEPACK5;
        *NoUpgradeAllowed = TRUE;
        return(FALSE);
    }

    return CheckCompliance(SourceSku, SourceSkuVariation, SourceVersion,
                            SourceBuildNum, &TargetData, Reason, NoUpgradeAllowed);
}

BOOL 
IsWinPEMode(
    VOID
    )
/*++

Routine Description:

    Finds out if we are running under WinPE environment.

Arguments:

    None

Return value:

    TRUE or FALSE

--*/
{
    static BOOL Initialized = FALSE;
    static BOOL WinPEMode = FALSE;


    if (!Initialized) {
        TCHAR   *MiniNTKeyName = TEXT("SYSTEM\\CurrentControlSet\\Control\\MiniNT");
        HKEY    MiniNTKey = NULL;
        LONG    RegResult;
        
            
        RegResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                                MiniNTKeyName,
                                &MiniNTKey);

        if (RegResult == ERROR_SUCCESS) {
            WinPEMode = TRUE;
            RegCloseKey(MiniNTKey);
        }

        Initialized = TRUE;
    }                

    return WinPEMode;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\bootent\efi\efisbent.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efisbent.h

Abstract:

    EFI boot entry and EFI boot options abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <sbentry.h>

#if defined(EFI_NVRAM_ENABLED)       

//
// EFI boot entry abstraction
//
typedef struct _EFI_OS_BOOT_ENTRY {
    OS_BOOT_ENTRY   OsBootEntry;
    PBOOT_ENTRY     NtBootEntry;
} EFI_OS_BOOT_ENTRY, *PEFI_OS_BOOT_ENTRY;


//
// EFI boot options abstraction
//
typedef struct _EFI_OS_BOOT_OPTIONS {
    OS_BOOT_OPTIONS     OsBootOptions;
    PBOOT_OPTIONS       NtBootOptions;    
    PBOOT_ENTRY_LIST    NtBootEntries;
} EFI_OS_BOOT_OPTIONS, *PEFI_OS_BOOT_OPTIONS;


//
// EFI_OS_BOOT_ENTRY Methods
//
POS_BOOT_ENTRY
EFIOSBECreate(
    IN PBOOT_ENTRY Entry,
    IN POS_BOOT_OPTIONS Container
    );

VOID
EFIOSBEDelete(
    IN  POS_BOOT_ENTRY  This
    );

BOOLEAN
EFIOSBEFlush(
    IN POS_BOOT_ENTRY This
    );

//
// EFI_OS_BOOT_OPTIONS Methods
//
POS_BOOT_OPTIONS
EFIOSBOCreate(
    VOID
    );

    
BOOLEAN
EFIOSBOFlush(
    IN POS_BOOT_OPTIONS This
    );
    
VOID
EFIOSBODelete(
    IN POS_BOOT_OPTIONS This
    );

POS_BOOT_ENTRY
EFIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    );

BOOLEAN
EFIOSBEFillNtBootEntry(
    IN PEFI_OS_BOOT_ENTRY Entry
    );
    
BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    );    

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
            
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
            
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)    

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)   
#define ADD_BYTE_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_o))

    
#endif  // for EFI_NVRAM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\compchk.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    compliance.c

Abstract:

    compliance checking routines.

Author:

    Vijayachandran Jayaseelan (vijayj) - 31 Aug 1999

Revision History:

    none

Notes:
    These routines are used for compliance checking. CCMedia abstracts the
    install media and the already existing COMPLIANCE_DATA structure is
    used to abstract installation details.

    The current compliance checking design uses factory design pattern
    (Eric Gamma et.al.) to allow extensibility. Polymorphic behavior of
    compliance check is implemented using a function pointer.

    CCMediaCreate(...) creates the correct media object and binds the
    appropriate compliance checking method to the object. To support a new media
    type one needs to write a compliance check function for that
    media and change CCMediaCreate(...) function to create the appropriate
    media object bound to the new check function.

    The compliance matrix is a  multidimensional matrix i.e. type,
    variation, suite, version (version in turn is made up of major,
    minor and build# elements). Since changing a the multi-dimensional
    compliance matrix can be error prone and not extensible in terms of
    index management, a static global compliance matrix data structure was avoided.

--*/

#ifdef KERNEL_MODE

#include "textmode.h"
#define assert(x) ASSERT(x)

#else // KERNEL_MODE

#if DBG
#define assert(x) if (!(x)) DebugBreak();
#else
#define assert(x)
#endif // DBG

#include "winnt32.h"
#include <stdio.h>
#include <compliance.h>

#endif // for KERNEL_MODE

//
// macros
//

//
// indicates whether a given suite is installed
//
#define SUITE_INSTALLED(X, Y)  \
    (((X) & (Y)) ? TRUE : FALSE)


#define DEFAULT_MINIMUM_VALIDBUILD 2428

static BOOL bDisableBuildCheck = FALSE;


VOID
CCDisableBuildCheck( 
    VOID )
{
    bDisableBuildCheck = TRUE;
}


//
// indicates whether the build is allowed to upgrade 
// 


__inline
BOOL
IsValidBuild(
    IN  DWORD   InstallVersion,
    IN  DWORD   SourceInstallVersion )
{
    BOOL Result = TRUE;

    if (bDisableBuildCheck) {
        Result = TRUE;
    } else  if ((InstallVersion > 1381 && InstallVersion < 2031)  ||
                (InstallVersion > 2195 && InstallVersion < DEFAULT_MINIMUM_VALIDBUILD) ||
                (InstallVersion > SourceInstallVersion)) {
        Result = FALSE;
    }

    return Result;
}


BOOLEAN
CCProfessionalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional media, otherwise FALSE

--*/
{
    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
            if (CompData->MinimumVersion < 400) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                    *FailureReason = COMPLIANCEERR_NONE;
                    *UpgradeAllowed = TRUE;
                } else {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
            // note: 401 is 4.1
            if (CompData->MinimumVersion < 401) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullProfessionalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional full media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if ( ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) ||
                 ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 400)) ||
                 ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 500)) ||
                 (((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) || (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) ) 
                    && (CompData->MinimumVersion == 501) 
                    && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ){
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            } else {
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) &&
                (CompData->MinimumVersion >= 501) &&
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;
        default:
            CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


BOOLEAN
CCProfessionalUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional upgrade media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional upgrade media, otherwise FALSE

--*/
{
    if (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_NFR) {
        *FailureReason = COMPLIANCEERR_VARIATION;
        *UpgradeAllowed = FALSE;
    } else {
        switch (This->SourceVariation) {
            case COMPLIANCE_INSTALLVAR_OEM:
                if ( ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) ||
                     ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 400)) ||
                     ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 500) && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ||
                     (((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) || (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) ) 
                        && (CompData->MinimumVersion == 501) 
                        && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ){
                    *FailureReason = COMPLIANCEERR_VARIATION;
                    *UpgradeAllowed = FALSE;
                } else {
                    CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
                }
                break;
    
            default:
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
                break;
        }
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCPersonalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal media, otherwise FALSE

--*/
{
    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_WIN9X:
            // note: 401 is version 4.1
            if (CompData->MinimumVersion < 401) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            *UpgradeAllowed = FALSE;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullPersonalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal full media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                       (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;
        default:
            CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


BOOLEAN
CCPersonalUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal upgrade media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal upgrade media, otherwise FALSE

--*/
{
    if (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_NFR) {
        *FailureReason = COMPLIANCEERR_VARIATION;
        *UpgradeAllowed = FALSE;
    } else {
        switch (This->SourceVariation) {
            case COMPLIANCE_INSTALLVAR_OEM:
                if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                       (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) {
                    *FailureReason = COMPLIANCEERR_VARIATION;
                    *UpgradeAllowed = FALSE;
                }
                else {
                    CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
                }
                break;
            default:
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
                break;
        }
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCBladeServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server media.  Policy is to allow blade server to be installed on
    older version of blade or on Windows Powered boxes (ADS w/EMBED suite).

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    DWORD  SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (CompData->MinimumVersion < 500) {
                *UpgradeAllowed = FALSE;
                *FailureReason = COMPLIANCEERR_VERSION;
            } else {
                switch (CompData->InstallVariation) {
                    case COMPLIANCE_INSTALLVAR_CDRETAIL:
                    case COMPLIANCE_INSTALLVAR_FLOPPYRETAIL:
                    case COMPLIANCE_INSTALLVAR_OEM:
                    case COMPLIANCE_INSTALLVAR_SELECT:
                    case COMPLIANCE_INSTALLVAR_NFR:
                        if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                            *FailureReason = COMPLIANCEERR_NONE;
                            *UpgradeAllowed = TRUE;
                        } else {
                            *FailureReason = COMPLIANCEERR_VERSION;
                            *UpgradeAllowed = FALSE;
                        }

                        break;

                    default:
                        *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
                        *UpgradeAllowed = FALSE;
                        break;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
            SuitesToCheck = (COMPLIANCE_INSTALLSUITE_EMBED);

            if (!SUITE_INSTALLED(CompData->InstallSuite, SuitesToCheck)) {
                *FailureReason = COMPLIANCEERR_SUITE;
                *UpgradeAllowed = FALSE;
            } else {
                if (CompData->MinimumVersion < 400) {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                } else {
                    if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                        *FailureReason = COMPLIANCEERR_NONE;
                        *UpgradeAllowed = TRUE;
                    } else {
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                    }
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullBladeServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCBladeServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCSmallBusinessServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server media.  Policy is to only allow Whistler SBS to upgrade Win2k Server, 
	Whistler Server, and SBS 2k.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    DWORD  SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            if (CompData->MinimumVersion < 2195) {
                *UpgradeAllowed = FALSE;
                *FailureReason = COMPLIANCEERR_VERSION;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }
			break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSB:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullSmallBusinessServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    CCSmallBusinessServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCSmallBusinessServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCSmallBusinessServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server media, otherwise FALSE

--*/
{
    DWORD  SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
            SuitesToCheck = (COMPLIANCE_INSTALLSUITE_ENT |
                             COMPLIANCE_INSTALLSUITE_SBS |
                             COMPLIANCE_INSTALLSUITE_SBSR |
                             COMPLIANCE_INSTALLSUITE_BACK);

            if (SUITE_INSTALLED(CompData->InstallSuite, SuitesToCheck)) {
                *FailureReason = COMPLIANCEERR_SUITE;
                *UpgradeAllowed = FALSE;
            } else {
                if (CompData->MinimumVersion < 400) {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                } else {
                    if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                        *FailureReason = COMPLIANCEERR_NONE;
                        *UpgradeAllowed = TRUE;
                    } else {                
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                    }
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (CompData->BuildNumberNt < 1381) {
                *FailureReason = COMPLIANCEERR_SUITE;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server media, otherwise FALSE

--*/
{
    CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server media, otherwise FALSE

--*/
{
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
            // note: 501 is version 5.1 because of calculation major*100 + minor
            if (CompData->MinimumVersion < 501 && CompData->MinimumVersion > 351) {
                SuitesToCheck = (COMPLIANCE_INSTALLSUITE_SBS |
                                 COMPLIANCE_INSTALLSUITE_SBSR |
                                 COMPLIANCE_INSTALLSUITE_BACK);

                if (SUITE_INSTALLED(CompData->InstallSuite, SuitesToCheck)) {
                    *FailureReason = COMPLIANCEERR_SUITE;
                    *UpgradeAllowed = FALSE;
                } else {
                    if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                        *FailureReason = COMPLIANCEERR_NONE;
                        *UpgradeAllowed = TRUE;
                    } else {
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                    }
                }
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (CompData->BuildNumberNt < 1381) {
                *FailureReason = COMPLIANCEERR_SUITE;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;                
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server full media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server full media, otherwise FALSE

--*/
{
    CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


BOOLEAN
CCAdvancedServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server upgrade media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server upgrade media, otherwise FALSE

--*/
{
    DWORD   CurrentSuite = 0;
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            switch (CompData->InstallType) {
                case COMPLIANCE_INSTALLTYPE_NTS:
                    CurrentSuite = CompData->InstallSuite;

                    if (SUITE_INSTALLED(CurrentSuite, COMPLIANCE_INSTALLSUITE_ENT)) {
                        if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                            *FailureReason = COMPLIANCEERR_NONE;
                            *UpgradeAllowed = TRUE;
                        } else {
                            *FailureReason = COMPLIANCEERR_VERSION;
                            *UpgradeAllowed = FALSE;
                        }
                    } else {
                        if (SUITE_INSTALLED(CurrentSuite, COMPLIANCE_INSTALLSUITE_NONE)) {
                            *FailureReason = COMPLIANCEERR_TYPE;
                            *UpgradeAllowed = FALSE;
                        } else {
                            *FailureReason = COMPLIANCEERR_SUITE;
                            *UpgradeAllowed = FALSE;
                        }
                    }

                    break;

                case COMPLIANCE_INSTALLTYPE_NTSTSE:
                    *FailureReason = COMPLIANCEERR_SUITE;
                    *UpgradeAllowed = FALSE;

                    break;

                default:
                    CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);
                    break;
            }

            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCDataCenterCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    datacenter media.

Arguments:

    This            : datacenter media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    datacenter media, otherwise FALSE

--*/
{
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            if (CompData->MinimumVersion < 500) {
                *UpgradeAllowed = FALSE;
                *FailureReason = COMPLIANCEERR_VERSION;
            } else {
                switch (CompData->InstallVariation) {
                    case COMPLIANCE_INSTALLVAR_CDRETAIL:
                    case COMPLIANCE_INSTALLVAR_FLOPPYRETAIL:
                    case COMPLIANCE_INSTALLVAR_OEM:
                    case COMPLIANCE_INSTALLVAR_SELECT:
                    case COMPLIANCE_INSTALLVAR_NFR:
                        if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber)) {
                            *FailureReason = COMPLIANCEERR_NONE;
                            *UpgradeAllowed = TRUE;
                        } else {
                            *FailureReason = COMPLIANCEERR_VERSION;
                            *UpgradeAllowed = FALSE;
                        }

                        break;

                    default:
                        *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
                        *UpgradeAllowed = FALSE;
                        break;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCFullDataCenterCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    datacenter full media.

Arguments:

    This            : datacenter media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    datacenter full media, otherwise FALSE

--*/
{
    CCDataCenterCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


PCCMEDIA
CCMediaCreate(
    IN          DWORD   SourceSKU,
    IN          DWORD   SourceVariation,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber )
/*++

Routine Description:

    This routine creates a media object and binds the appropriate compliance
    checking function to the media object.

Arguments:

    SourceSKU       : the kind of SKU
    SourceVariation : the kind of variation (oem, msdn, retail etc)
    Version         : the version ((major ver + minor ver) * 100)
    BuildNumber     : the build number

Return Value:

    A new allocated and initialized media object of the appropriate type if
    the media type is supported otherwise NULL.

    NOTE:
    Once you are done with the object, free the media object using CCMemFree()
    macro. This function uses factory design pattern.

--*/
{
    PCCMEDIA    SourceMedia = CCMemAlloc(sizeof(CCMEDIA));

    if( !SourceMedia ) {
        return SourceMedia;
    }

    SourceMedia->SourceVariation = SourceVariation;
    SourceMedia->Version = Version;
    SourceMedia->BuildNumber = BuildNumber;

    switch (SourceSKU) {
        case COMPLIANCE_SKU_NTWFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTW;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullProfessionalCheck;
            break;

        case COMPLIANCE_SKU_NTW32U:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTW;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCProfessionalUpgCheck;

            break;

        case COMPLIANCE_SKU_NTWPFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTWP;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullPersonalCheck;

            break;

        case COMPLIANCE_SKU_NTWPU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTWP;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCPersonalUpgCheck;

            break;

        case COMPLIANCE_SKU_NTSB:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSB;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullBladeServerCheck;

            break;

        case COMPLIANCE_SKU_NTSBU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSB;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCBladeServerUpgCheck;
            
            break;
	
	case COMPLIANCE_SKU_NTSBS:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSBS;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullSmallBusinessServerCheck;
	
            break;
	
        case COMPLIANCE_SKU_NTSBSU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSBS;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCSmallBusinessServerUpgCheck;
	
            break;

        case COMPLIANCE_SKU_NTSFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTS;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullServerCheck;

            break;

        case COMPLIANCE_SKU_NTSU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTS;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCServerUpgCheck;
            break;

        case COMPLIANCE_SKU_NTSEFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSE;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullAdvancedServerCheck;

            break;

        case COMPLIANCE_SKU_NTSEU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSE;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCAdvancedServerUpgCheck;

            break;

        case COMPLIANCE_SKU_NTSDTC:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSDTC;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullDataCenterCheck;

            break;

        default:
            CCMemFree(SourceMedia);
            SourceMedia = 0;
            break;
    }

    return SourceMedia;
}

BOOLEAN
CCMediaInitialize(
    OUT PCCMEDIA        DestMedia,
    IN          DWORD   Type,
    IN          DWORD   Variation,
    IN          BOOLEAN StepupMedia,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber)
/*++

Routine Description:

    The routine initializes a CCMEDIA structure with the given values
    particularly the binding of "CheckInstall" method based on "Type"
    and "StepupMedia".

Arguments:

 DestMedia   - The media object which needs to be initialized
 Type  - The type of media object (eg. COMPLIANCE_INSTALLTYPE_NTS)
 Variation - The variation of the media object (eg. COMPLIANCE_INSTALLVAR_CDRETAIL)
 StepupMedia - TRUE if the media is a stepup media or FALSE otherwise
 Version  - Optional OS Version (major * 100 + minor)
 BuildNumber - Optinal Build number of OS (eg. 2172)

Return Value:

    TRUE if the given media object could be initialized otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (DestMedia) {
        Result = TRUE;

        DestMedia->SourceType = Type;
        DestMedia->SourceVariation = Variation;
        DestMedia->StepUpMedia = StepupMedia;
        DestMedia->Version = Version;
        DestMedia->BuildNumber = BuildNumber;
        DestMedia->CheckInstall = 0;

        switch (Type) {
            case COMPLIANCE_INSTALLTYPE_NTW:
                DestMedia->CheckInstall = StepupMedia ?
                    CCProfessionalUpgCheck : CCFullProfessionalCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTWP:
                DestMedia->CheckInstall = StepupMedia ?
                    CCPersonalUpgCheck : CCFullPersonalCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSB:
                DestMedia->CheckInstall = StepupMedia ?
                    CCBladeServerUpgCheck : CCFullBladeServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTS:
                DestMedia->CheckInstall = StepupMedia ?
                    CCServerUpgCheck : CCFullServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSE:
                DestMedia->CheckInstall = StepupMedia ?
                    CCAdvancedServerUpgCheck : CCFullAdvancedServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSDTC:
                if (!StepupMedia) {
                    DestMedia->CheckInstall = CCFullDataCenterCheck;
                } else {
                    Result = FALSE;
                }

                break;

            default:
                assert(FALSE);
                Result = FALSE;
                break;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

    UMTYPE=windows
Author:

    Andrew Ritz (andrewr)

!ENDIF

MAJORCOMP=setup
MINORCOMP=complnce

SOURCES=

INCLUDES=\
  $(INCLUDES);\
  $(BASE_INC_PATH);\
  $(DS_INC_PATH);\
  ..\..\inc;\

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\compfile.cpp ===
#pragma warning( disable:4786 )


#include <compfile.h>
//
// ComplianceFile methods
//
void ComplianceFile::readLines() {
  ifstream   inputFile(m_szFileName.c_str());

  if (!inputFile)
    throw InvalidFileName(m_szFileName);

  char    szTemp[256];
  int     counter = 0;

  while (!inputFile.eof()) {
    inputFile.getline(szTemp, sizeof(szTemp));

    if (szTemp[0] && szTemp[0] != ';')
      m_lines.push_back(szTemp);
  }
}

bool ComplianceFile::isSectionName(const string& szLine) const{
  if (szLine.length() > 2)
    return (szLine[0] == '[' && szLine[szLine.length() - 1] == ']');
  else
    return false;
}

void ComplianceFile::createSections() {
  vector<string>::const_iterator  iter = m_lines.begin();
  vector<string>  sectionLines;
  string          sectionName;

  while (iter != m_lines.end()) {
    if ((*iter)[0] == '[') {
      if (!isSectionName(*iter))
        throw Section::InvalidSectionFormat(*iter);

      if (iter != m_lines.begin()) {
        Section *pSec = sectionFactory().create(sectionName, sectionLines, *this);
        m_sections.push_back(pSec);

        if (sectionName == "[type#values]")
          m_typesSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[var#values]")
          m_varsSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[suite#values]")
          m_suitesSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[oldsource#values]")
          m_sourcesSection = dynamic_cast<ValueSection *>(pSec);       
        else if (sectionName == "[error#values]")
        	m_errorsSection = dynamic_cast<ValueSection *>(pSec);
      }
      
      sectionLines.clear();
      sectionName = (*iter);
    } else {
      sectionLines.push_back(*iter);
    }

    iter++;
  }

  if ((sectionLines.size() > 0) && isSectionName(sectionName))
    m_sections.push_back(sectionFactory().create(sectionName, sectionLines, *this));

  //
  // copy all the test sections here
  //
  vector<Section*>::const_iterator sec = m_sections.begin();

  while (sec != m_sections.end()) {
    if ((*sec)->name().find("[test#") != (*sec)->name().npos) 
      m_upgSections.push_back(dynamic_cast<TestSection*>(*sec));

    sec++;
  }
}

void ComplianceFile::executeTestCases(ostream& os) {
	vector<TestSection*>::iterator	iter = m_upgSections.begin();

	while (iter != m_upgSections.end()) {
		(*iter)->executeTestCases(os);
		iter++;
	}
}

vector<Section*>::iterator
ComplianceFile::findSection(vector<Section*> &sections, const string& szName){
  vector<Section*>::iterator iter = sections.begin();

  while (iter != sections.end()) {
    if ((*iter)->name() == szName)
      return iter;

    iter++;
  }

  return iter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\section.cpp ===
#pragma warning( disable:4786 )

#include <section.h>
#include <cstdlib>
#include <strutil.h>
#include <compfile.h>
#include <iomanip>

extern "C" {
  DWORD SourceInstallType = 0;
  CHAR  *SourcePaths[] = { 0 };
  CHAR  *NativeSourcePaths[] = {0};
  DWORD OsVersion;
  VOID GetSourceInstallType(LPDWORD InstallVariation){}
};

//
// ValueSection methods
//

void ValueSection::parse() {
  vector<string>::const_iterator  iter = lines().begin();

  while (iter != lines().end()) {
    vector<string>  tokens;

    Tokenize((const string&)(*iter), string(" ="), tokens);

    if (tokens.size() != 2)
      throw InvalidSectionFormat(name());

    m_values[tokens[0]] = toUnsignedLong(tokens[1].c_str());
    iter++;
  }
}

//
// TestSection methods
//
void TestSection::parse() {
  vector<string>::const_iterator  iter = lines().begin();

  while (iter != lines().end()) {
    m_testCases.push_back(testCaseFactory().create(*this, *iter));
    iter++;
  }
}

TestSection& TestSection::operator=(const TestSection& rhs){
	cerr << "Copying section " << endl;
  *(Section *)this = (Section&)rhs;
  
  m_testCases.clear();

  vector<TestCase*>::const_iterator iter = rhs.m_testCases.begin();

  while (iter != rhs.m_testCases.end()) {
    m_testCases.push_back(testCaseFactory().create(**iter));
    iter++;
  }

  return *this;
}

void TestSection::executeTestCases(ostream& os) {
	vector<TestCase*>::iterator iter = m_testCases.begin();

	bool allpassed = true;

  os << endl << endl 
     << "Executing test cases for {" << name() << "}" 
     << endl << endl;

	while (iter != m_testCases.end()) {		
		(*iter)->execute(os);

		if (!(*iter)->passed()) {
			os << dec << setw(3) << setfill('0') 
				 << (iter - m_testCases.begin() + 1) << ": TestCase : [" 
				 << (*iter)->line() << "]" << " FAILED" << endl;
			(*iter)->dump(os);
			allpassed = false;
		}
			
		iter++;
	}

	if (allpassed)
		os << "all the test cases passed for this section" << endl;
}


//
// ComplianceTestCase methods
//
void ComplianceTestCase::parse() {
  vector<string>  tokens;
  
  Tokenize(line(), string("#=,"), tokens);

  if (tokens.size() == 7) {
    m_expectedResult = ((tokens[6][0] == 'y') || (tokens[6][0] == 'Y'));
    sourceDetails();
    installationDetails(tokens);
  } else {
    throw InvalidFormat(line(), section().name());
  }
}

void ComplianceTestCase::sourceDetails() {
  vector<string>  tokens;

  Tokenize(section().name(), string("[#]"), tokens);

  if ((tokens.size() == 7) && (tokens[0] == "test")) {     
      m_sourceSKU = section().file().sourcesSection().value(tokens[1] + "#" + tokens[6]);
      m_sourceVAR = section().file().varsSection().value(tokens[5]);
      m_sourceVer = atof(tokens[2].c_str()) * 100; // (major * 100 + minor)
      m_sourceBuild = atol(tokens[3].c_str());
  }
  else
    throw Section::InvalidSectionName(section().name());
}

void ComplianceTestCase::installationDetails(const vector<string>& tokens) {
    int length,i;
    int version;

  if ((tokens.size() == 7)) {   
  	m_errExpected = section().file().errorsSection().value(tokens[5]);
    m_cd.InstallType = section().file().typesSection().value(tokens[0]);
    m_cd.InstallVariation = section().file().varsSection().value(tokens[4]);
    m_cd.InstallSuite = section().file().suitesSection().value(tokens[3]);
    m_cd.RequiresValidation = (section().name().find("#ccp") != section().name().npos);
    //m_cd.MinimumVersion = ::strtod(tokens[1].c_str()) * 100;
    length = tokens[1].size();
    i = 0;
    version = 0;
    while (i < length) {
        if( tokens[1][i] != '.'){
            version = version*10 + tokens[1][i] - '0';
        }
        else
        {
            if (i == (length-3)) { // two decimal places
                version = version*100+ (tokens[1][i+1] - '0')*10 + (tokens[1][i+2]-'0');
            }
            else{
                version = version*100+ (tokens[1][i+1] - '0');
            }
            i = length;
        }
        i++;
    }
    m_cd.MinimumVersion = version;
    // cerr << "minimum version" << m_cd.MinimumVersion << endl;
    m_cd.MaximumKnownVersionNt = 510;
    if( m_cd.InstallType & COMPLIANCE_INSTALLTYPE_WIN9X) {
        m_cd.BuildNumberWin9x = toUnsignedLong(tokens[2].c_str());
        m_cd.BuildNumberNt = 0;
    } else {
        m_cd.BuildNumberNt = toUnsignedLong(tokens[2].c_str());
        m_cd.BuildNumberWin9x = 0;
    }
  }
  else
    throw Section::InvalidSectionName(section().name());
}

bool ComplianceTestCase::passed() {
	bool  result = false;
  
  if (m_errExpected) {
  	// negative testcase
  	if (m_cd.RequiresValidation) {
  		// should have failed with expected error code & upgrade flag
	    result = (!m_passed && (m_errExpected == m_reason) &&
	    					(m_allowUpgrade == m_expectedResult));
		} else {
			// should pass with expected error code & upgrade flag			
			// target errors are special case
			result = ((m_reason != 0x5) ? m_passed : !m_passed) && (m_errExpected == m_reason) &&
								(m_allowUpgrade == m_expectedResult);
		}								
  }
  else {
    result = (m_passed && (m_allowUpgrade == m_expectedResult));
	}    

  return result;
}

void ComplianceTestCase::execute(ostream &os) {
	m_reason = 0;
	m_noUpgrade = true;

	m_passed = CheckCompliance(m_sourceSKU, m_sourceVAR, m_sourceVer,
	                m_sourceBuild, &m_cd,  &m_reason, &m_noUpgrade) ? true : false;
    
    m_allowUpgrade = (m_noUpgrade) ? false : true;  
}

void ComplianceTestCase::dump(ostream &os) {
    // (Error expected or not, The error that was expected in hex, Upgrade allowed)
	os << "Expected result : (error="  << hex << m_errExpected << ",upgradeallowed="
		 << ((m_expectedResult) ? "true" : "false") << ")" << endl;
		 
    // (Compliant or not(can we do clean install?), Reason in hex, Upgrade allowed)
	os << "Actual result   : (compliant=" << (m_passed  ? "true" : "false")
	   << ",error=" << hex << m_reason << ",upgradeallowed="
	   << ((m_allowUpgrade) ? "true" : "false") << ")" << endl;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\pidinit\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\pidinit\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\pidinit\crc-32.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    crc-32.h

Abstract:

--*/
#include "crcmodel.h"

DWORD WINAPI CRC_32(LPBYTE pb, DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\pidinit\crc-32.cpp ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    crc-32.cpp

Abstract:

--*/

#include <windows.h>
#include "crc-32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\strutil.h ===
#include <vector>
#include <cstdlib>

using namespace std;

//
// utility function to tokenize a given line based on the delimiters
// specified
//
template< class T >
unsigned Tokenize(const T &szInput, const T & szDelimiters, vector<T>& tokens) {
  unsigned uDelimiterCount = 0;

	tokens.clear();

	if(!szInput.empty()){
		if(!szDelimiters.empty()){
			T::const_iterator	inputIter = szInput.begin();
			T::const_iterator	copyIter = szInput.begin();

			while(inputIter != szInput.end()){			
				if(szDelimiters.find(*inputIter) != string::npos){
          if (copyIter < inputIter) {
						tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                                  inputIter - copyIter));
          }

          uDelimiterCount++;
          inputIter++;
          copyIter = inputIter;
          continue;
				}

			  inputIter++;
			}

      if(copyIter != inputIter){
				tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                              inputIter - szInput.begin()));
      }
		}
		else
			tokens.push_back(szInput);
	}

  return uDelimiterCount;
}

unsigned long toUnsignedLong(const string& str) {
  int radix = 10; //decimal

  if ((str.find("0x") != str.npos) || (str.find("0X") != str.npos))
    radix = 16; // hex decimal

  return ::strtoul(str.c_str(), 0, radix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\comptest.cpp ===
// comptest.cpp : Defines the entry point for the console application.
//
#pragma warning( disable:4786 )

#include <iostream>
#include <compfile.h>

using namespace std;

//
// main() entry point
//
 
int
__cdecl
main(
    int argc, 
    char* argv[]
    )
{
	if(argc > 1){
    try{
      ComplianceFile  inputFile(argv[1]);
		
      if (argc > 2) {
      	ofstream	outFile(argv[2]);
      	
      	if (!outFile.good())
      		throw ComplianceFile::InvalidFileName(argv[2]);

				inputFile.executeTestCases(outFile);      		
			}      		
			else
				inputFile.executeTestCases(cerr);
    }
    catch(ComplianceFile::InvalidFileFormat iff) {
      cerr << iff;
    }
    catch(ComplianceFile::InvalidFileName ifn) {
      cerr << ifn;
    }
    catch(ComplianceFile::MissingSection ms) {
      cerr << ms;
    }
    catch(Section::InvalidSectionFormat isf) {
      cerr << isf;
    }
    catch(Section::InvalidSectionName isn) {
      cerr << isn;
    }
    catch(ValueSection::ValueNotFound vnf) {
      cerr << vnf;
    }
    catch(TestCase::InvalidFormat itf) {
      cerr << itf;
    }
    catch(...){
      cerr << "Unknown Exception caught... :(" << endl;        
    }
	}
	else{
		cerr << "illegal usage :(" << endl;
	}

	return 0;
}

/*

namespace Compliance {

//
// static data initialization
//
const string UpgradeTestCase::m_szDelimiters = ":#";

//
// utility function to tokenize a given line based on the delimiters
// specified
//
template< class T >
unsigned Tokenize(const T &szInput, const T & szDelimiters, vector<T>& tokens) {
  unsigned uDelimiterCount = 0;

	tokens.clear();

	if(!szInput.empty()){
		if(!szDelimiters.empty()){
			T::const_iterator	inputIter = szInput.begin();
			T::const_iterator	copyIter = szInput.begin();

			while(inputIter != szInput.end()){			
				if(szDelimiters.find(*inputIter) != string::npos){
          if (copyIter < inputIter) {
						tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                                  inputIter - copyIter));
          }

          uDelimiterCount++;
          inputIter++;
          copyIter = inputIter;
          continue;
				}

			  inputIter++;
			}

      if(copyIter != inputIter){
				tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                              inputIter - szInput.begin()));
      }
		}
		else
			tokens.push_back(szInput);
	}

  return uDelimiterCount;
}

//
// debug output for section
//
ostream& operator<<(ostream &os, const Section &section){
	os << "Section Name: " << section.name() << endl;
	os << "Number of child sections : " << section.childSections().size() << endl;
  os << "Section content : " << endl;

  
  vector<string>::const_iterator liter = section.lines().begin();

  while (liter != section.lines().end()) 
    os << *liter++ << endl;

	// dump all the child sections
	vector<Section>::const_iterator	iter = section.childSections().begin();

	while (iter != section.childSections().end()) {
		os << (const Section &)(*iter) << endl;
    iter++;
	}

	return os;
}

//
// debug output for compliance file
//
ostream& operator<<(ostream& os, const ComplianceFile &cf){
	os << "------------------------------------------------------------" << endl;
	os << "Compliance File State - Dump" << endl;
	os << "Name : " << cf.name() << endl;
	os << "Num Lines : " << cf.lines().size() << endl;
	os << "Section Dump : " << endl;

  if (cf.topLevelSection())
	  os << *(cf.topLevelSection()) << endl;

	os << "------------------------------------------------------------" << endl;	

  return os;
}

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\compfile.h ===
#ifndef __COMPFILE_H_
#define __COMPFILE_H_

#include <vector>
#include <string>
#include <fstream>
#include <section.h>

//
// This class abstracts the compliance file
//
class ComplianceFile {
public:
	ComplianceFile(const string& szFileName){
    m_szFileName = szFileName;
    bindSectionFactory();
    readLines();
    createSections();
	}
 
  virtual ~ComplianceFile(){
    vector<Section*>::iterator  iter = m_sections.begin();

    while (iter != m_sections.end())
      delete *iter++;

    delete m_sectionFactory;
  }

  void executeTestCases(ostream& os);
  
  //
  // accessors
  //
  const string& name() const{ return m_szFileName; }
  const vector<string>& lines() const{ return m_lines; }
  const vector<Section*>& sections() const{ return m_sections; }
  const ValueSection& typesSection() const { return *m_typesSection; }
  const ValueSection& varsSection() const { return *m_varsSection; }
  const ValueSection& suitesSection() const { return *m_suitesSection; }
  const ValueSection& sourcesSection() const { return *m_sourcesSection; }
  const ValueSection& errorsSection() const { return *m_errorsSection; }
  const SectionFactory& sectionFactory() const { return *m_sectionFactory; }

  //
  // exception classes
  //
  struct InvalidFileName {
    InvalidFileName(const string& name) : m_name(name) {}
    
    friend ostream& operator<<(ostream& os, const InvalidFileName& rhs) {
      os << "Exception : Invalid file name : " << rhs.m_name;
      return os;
    }

    string  m_name;
  };
  
  struct InvalidFileFormat {
    InvalidFileFormat(const string& name) : m_name(name) {}
    
    friend ostream& operator<<(ostream& os, const struct InvalidFileFormat &rhs) {
      os << "Exception : Invalid file format : " << rhs.m_name;
      return os;
    }

    string m_name;
  };

  struct MissingSection {
    MissingSection(const string& name) : m_name(name){}

    friend ostream& operator<<(ostream& os, const struct MissingSection &rhs) {
      os << "Exception : The following section is missing : " << rhs.m_name;
      return os;
    }
  
    string m_name;
  };

  //
  // overloaded operators
  //
  friend ostream& operator<<(ostream& os, const ComplianceFile &cf);
  
  /*
  ComplianceFile& operator=(const ComplianceFile& rhs) {
    m_lines = rhs.m_lines;
    m_szFileName = rhs.m_szFileName;
    
    delete m_typesSection;
    m_typesSection = sectionFactory().create(rhs.typesSection());

    delete m_varsSection;
    m_varsSection = sectionFactory().create(rhs.varsSection());

    delete m_suitesSection;
    m_suitesSection = sectionFactory().create(rhs.suitesSection());
    
    m_upgSections = rhs.TestSections();
  }
  */
  void  executeTestCases();

protected:
  virtual void bindSectionFactory() {
    m_sectionFactory = new OldFormatSectionFactory();
  }

  //
  // data members
  //
  vector<string>	    m_lines;
  string                m_szFileName;
  ValueSection          *m_typesSection;
  ValueSection          *m_varsSection;
  ValueSection          *m_suitesSection;
  ValueSection          *m_sourcesSection;
  ValueSection          *m_errorsSection;
  SectionFactory        *m_sectionFactory;  
  vector<TestSection*>  m_upgSections;
  vector<Section*>      m_sections;

private:
  void  readLines();
  bool  isSectionName(const string& szLine) const;
  void  createSections();

  static vector<Section*>::iterator 
        findSection(vector<Section*> &sections, const string& szName);
};

#endif  // for __COMPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\comptest\section.h ===
#ifndef __SECTION_H_
#define __SECTION_H_

#include <windows.h>
#include <vector>
#include <string>
#include <map>
#include <iostream>

extern "C" {
#include <compliance.h>
}

using namespace std;

class ComplianceFile;

//
// This class represents a section in the compliance
// data file
//
class Section {
public:
  Section(const string &name, const vector<string>& lines,
          const ComplianceFile& file) : m_file(file) {
    m_name = name;
    m_lines = lines;
  }

  Section(const Section& rhs) : m_file(rhs.m_file){
    *this = rhs;
  }

  virtual ~Section() {}
  
  //
  // accessors
  //
  const string& name() const { return m_name; }
  const vector<string>& lines() const { return m_lines; }
  const ComplianceFile& file() const{ return m_file; }
  
  //
  // parses the section content
  //
  virtual void parse() {}

  //
  // exceptions which methods of this class
  // can throw
  //
  struct SectionException {
    SectionException(const string& sectionName) : m_name(sectionName) {}

    string m_name;

    friend ostream& operator<<(ostream& os, const struct SectionException& rhs) {
      os << "Exception : Section Error : " << rhs.m_name;
      return os;
    }
  };

  struct InvalidSectionFormat : public SectionException {
    InvalidSectionFormat(const string& sectionName) : SectionException(sectionName) {}

    friend ostream& operator<<(ostream& os, const struct InvalidSectionFormat& rhs) {
      os << "Exception : Invalid Section Format : " << rhs.m_name;
      return os;
    }
  };

  struct InvalidSectionName : public SectionException {
    InvalidSectionName(const string &sectionName) : SectionException(sectionName) {}

    friend ostream& operator<<(ostream& os, const struct InvalidSectionName &rhs) {
      os << "Exception : Invalid Section Name : " << rhs.m_name;
      return os;
    }
  };

  //
  // overloaded operators
  //
  Section& operator=(const Section& rhs) {
    m_name = rhs.m_name;
    m_lines = rhs.m_lines;

    return *this;
  }
    
protected:
  //
  // data members
  //
  string                m_name;
  vector<string>        m_lines;
  const ComplianceFile& m_file;
};


//
// This class represents a value section in the compliance
// data file
//
class ValueSection : public Section {
public:
  ValueSection(const string& name, const vector<string>& lines,
      const ComplianceFile& file) : Section(name, lines, file) {
    parse();
  }

  //
  // parse the section and create <name, value> pairs
  //
  virtual void parse();

  unsigned long value(const string &key) const{
    map<string, unsigned long>::const_iterator  iter = m_values.find(key);

    if (iter == m_values.end())
      throw ValueNotFound(name(), key);

    return (*iter).second;
  }

  //
  // exceptions which can be thrown by the methods
  // of this class
  //
  struct ValueNotFound : public Section::SectionException {
    ValueNotFound(const string& name, const string &valname) :
        SectionException(name), m_valname(valname){}

    string m_valname;

    friend ostream& operator<<(ostream& os, const struct ValueNotFound& rhs) {
      os << "Exception : Value " << rhs.m_valname << " was not found in "
         << rhs.m_name;
      return os;
    }
  };

protected:
  //
  // data members
  //
  map<string, unsigned long>  m_values;
};

//
// this class represents a single test case in an test
// section
//
class TestCase {
public:
  TestCase(const Section& section, const string& line) :
      m_section(section), m_line(line) {
  }

  virtual ~TestCase() {}

  //
  // accessors
  //
  const string& line() const { return m_line; }
  const Section& section() const { return m_section; }

  virtual void parse() = 0;
  virtual void execute(ostream &os) = 0;
  virtual bool passed() = 0;
  virtual void dump(ostream& os) = 0;

  //
  // exceptions
  //
  struct InvalidFormat {
    InvalidFormat(const string& line, const string& section) {
      m_line = line;
      m_section = section;
    };

    string m_section, m_line;

    friend ostream& operator<<(ostream& os, const struct InvalidFormat& rhs) {
      os << "Exception : Invalid Test Case : " << rhs.m_line << " in section : "
         << rhs.m_section;
      return os;
    }
  };

protected:
  //
  // data members
  //
  const Section&  m_section;
  string          m_line;
};

//
// this class represents a test case (single line
// in an test section) 
//
class ComplianceTestCase : public TestCase {
public:
  ComplianceTestCase(const Section& section, const string& line) :
      TestCase(section, line) {
    ::memset(&m_cd, 0, sizeof(COMPLIANCE_DATA));
    m_passed = false;
    m_allowUpgrade = false;
    parse();
  }

  virtual void execute(ostream &os);
  virtual bool passed();
  virtual void parse();
  virtual void dump(ostream& os);

protected:
  void sourceDetails();
  void installationDetails(const vector<string>& tokens);

  //
  // data members
  //
  bool            m_passed;
  COMPLIANCE_DATA m_cd;
  unsigned long   m_sourceSKU;
  unsigned long   m_sourceVAR;
  unsigned long   m_sourceVer;
  unsigned long   m_sourceBuild;
  bool            m_expectedResult;
  UINT            m_reason;
  BOOL            m_noUpgrade;
  bool            m_allowUpgrade;
  UINT            m_errExpected;
};

//
// default factory to create test cases
//
class TestCaseFactory {
public:
  virtual TestCase* create(const Section& section, const string& line) const {
    TestCase *pTestCase = new ComplianceTestCase(section, line);    
    return pTestCase;
  }

  virtual TestCase* create(const TestCase& tc) const {
    return create(tc.section(), tc.line());
  }
};


//
// this class represents the test section in the compliance
// data file
//
class TestSection : public Section {
public:
  TestSection(const string& name, const vector<string>& lines,
      const ComplianceFile& file) : Section(name, lines, file){
    bindFactory();
    parse();
  }
  
  ~TestSection() {
    vector<TestCase*>::iterator iter = m_testCases.begin();

    while (iter != m_testCases.end())
      delete (*iter++);

    delete m_tcFactory;
  }

  TestSection& operator=(const TestSection& rhs);

  void executeTestCases(ostream& os);

  //
  // accessors
  //
//  const vector<TestCase *> testCases() const{ return m_testCases; }
  const TestCaseFactory& testCaseFactory() const{ return *m_tcFactory; }

  void parse();

protected:
  void bindFactory() {
    m_tcFactory = new TestCaseFactory();
  }

  //
  // data members
  //
  vector<TestCase *>  m_testCases;
  TestCaseFactory     *m_tcFactory;
};


//
// default factory to create sections
//
class SectionFactory {
public:
  virtual Section* create(const string& name, 
            const vector<string>& lines, const ComplianceFile& file) const {
    return new Section(name, lines, file);
  }

  virtual Section* create(const Section& section) const {
    return create(section.name(), section.lines(), section.file());
  }
};


//
// current factory to create sections
//
class OldFormatSectionFactory : public SectionFactory {
public:
  virtual Section* create(const string& name, 
                const vector<string>& lines, const ComplianceFile& file) const {
    if (name.find("[test#") != name.npos)
      return new TestSection(name, lines, file);
    else if (name.find("#values]") != name.npos)
      return new ValueSection(name, lines, file);
    else
      return new Section(name, lines, file);
  }
};


#endif // for __SECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\encrypt\pch.h ===
#include <windows.h>
#include "encrypt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\complnce\pidinit\pidinit.c ===
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include "crc-32.h"

// length of the string we expect with the /m option
#define RPC_LENGTH 5

// (max) length of the _SUFFIX strings
#define RPC_SUFFIX_LENGTH 3

#define STEPUPFLAG              TEXT("_STEPUP_")
#define BASE                    'a'
#define DEFAULT_RPC	"00000"
#define SELECT_SUFFIX	"270"
#define MSDN_SUFFIX	"335"
#define RETAIL_SUFFIX	"000"
#define OEM_SUFFIX	"OEM"

    
DWORD WINAPI CRC_32(LPBYTE pb, DWORD cb)
{

//		CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//		but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//		we can store the CRC at the end of the block and expect 0 to be
//		the value of the CRC of the resulting block (including the stored
//		CRC).

	cm_t cmt = {
		32, 		// cm_width  Parameter: Width in bits [8,32].
		0x04C11DB7, // cm_poly	 Parameter: The algorithm's polynomial.
		0xFFFFFFFF, // cm_init	 Parameter: Initial register value.
		TRUE,		// cm_refin  Parameter: Reflect input bytes?
		TRUE,		// cm_refot  Parameter: Reflect output CRC?
		0, // cm_xorot  Parameter: XOR this to output CRC.
		0			// cm_reg	 Context: Context during execution.
	};

	// Documented test case for CRC-32:
	// Checking "123456789" should return 0xCBF43926
                        
	cm_ini(&cmt);
	cm_blk(&cmt, pb, cb);

	return cm_crc(&cmt);
}

VOID GiveUsage() {
    _tprintf(TEXT("pidinit -d <flags> -g <outputname> -m <mpccode> -s[smro] -z -h -?\n"));
    _tprintf(TEXT("writes a signature to <outputname> based on <flags>\n"));
    _tprintf(TEXT("-s (SiteType) s (select) m (msdn) r (retail) o (oem)\n"));
    _tprintf(TEXT("-z (decode)\n"));
    _tprintf(TEXT("-m <mpccode> : mpccode is a 5 digit number\n"));
    _tprintf(TEXT("-h or -? this message\n"));
}

int _cdecl
main(
 int argc,
 char *argvA[]
 ) 
/*++

Routine Description:

    Entry point to the setup program

Arguments:

    argc - Number of args.
    argvA - the commandline arguments.


Return Value:


--*/
{
    LPTSTR *argv;
    int argcount = 0;
    
    long rslt;

    char data[10+4+1] = {0};
    char buf[1000] = {0};

    DWORD value, crcvalue,outval;//,tmp;
    BOOL StepUp = FALSE;
    BOOL decode = FALSE;
    BOOL bMpc = FALSE;

    LPSTR SiteSuffix[] = { SELECT_SUFFIX,
                           MSDN_SUFFIX,
                           RETAIL_SUFFIX,
                           OEM_SUFFIX
                        };

    typedef enum SiteType {
        Select = 0,
        Msdn,
        Retail,
        Oem,        
    } ;

    enum SiteType st = Select;
    int i, randval;

    char *outname = NULL;
    char path[MAX_PATH];
    char *mpcName = NULL;
    char tString[RPC_LENGTH+RPC_SUFFIX_LENGTH+1];
    
    
    // do commandline stuff
#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    // check for commandline switches
    for (argcount=0; argcount<argc; argcount++) {
       if ((argv[argcount][0] == L'/') || (argv[argcount][0] == L'-')) {
            switch (towlower(argv[argcount][1])) {
            case 'd':
               if (lstrcmpi(&argv[argcount][2],STEPUPFLAG ) == 0) {
                   StepUp = TRUE;
               }
               break;
            case 'g':
                outname = argv[argcount + 1];
                break;
            case 's':
                switch (towlower(argv[argcount+1][0])) {
                    case 's':
                        st = Select;
                        break;
                    case 'm':
                        st = Msdn;
                        break;
                    case 'r':
                        st = Retail;
                        break;
                    case 'o':
                        st = Oem;
                        break;
                    default:
                        st = Select;
                        break;
                }
                break;

            case 'z':
                decode = TRUE;
                break;

	    case 'm':
		bMpc = TRUE;
		mpcName = argv[argcount + 1];
		break;

            case 'h':
            case '?':
               GiveUsage();
               return 1;
               break;                        
            default:
               break;
            }
       }
    }    

    if (!outname) {
        _tprintf(TEXT("you must supply a filename\n"));
        GiveUsage();
        return 1;
    }

    //
    // the decode section is really only for testing
    //
    if (decode) {
        _getcwd ( path, MAX_PATH );
        sprintf( path, "%s\\%s", path, outname );
        GetPrivateProfileStruct(  "Pid",
                                  "ExtraData",
                                  data, 
                                  14,
                                  path
                                  );

        crcvalue = CRC_32( (LPBYTE)data, 10 );
        memcpy(&outval,&data[10],sizeof(DWORD));
        if (crcvalue != outval ) {
            printf("CRC doesn't match %x %x!\n", crcvalue, outval);
            return 1;
        }

        if ((data[3]-BASE)%2) {
            if ((data[5]-BASE)%2) {
                printf("stepup mode\n");
                return 1;
            } else {
                printf("bogus!\n");
                return -1;
            }
        } else 
            if ((data[5]-BASE)%2) {
                printf("bogus!\n");
                return -1;
            } else {
                printf("full retail mode\n");
                return 1;
            }


    }
                                      
    srand( (unsigned)time( NULL ) );      
    
    for (i=0;i< 10; i++ ) {
        randval = rand() ;
        data[i] = BASE + (randval % 26);
    }

    if (StepUp) {
        if (!((data[3]- BASE)%2)) {
           data[3] = data[3] + 1;
        }

        if (!((data[5]- BASE )%2)) {
           data[5] = data[5] + 1;
        }                
    } else {
        if ((data[3]- BASE)%2) {
            data[3] = data[3] + 1;
        }
        if ((data[5]- BASE)%2) {
            data[5] = data[5] + 1;
        }        
    }

    //printf( "data : %s\n" , data );

    crcvalue = CRC_32( (LPBYTE)data, strlen(data) );
    memcpy(&data[10],&crcvalue,4);
    
    _getcwd ( path, MAX_PATH );
    sprintf( path, "%s\\%s", path, outname );

    WritePrivateProfileStruct( "Pid",
                               "ExtraData",
                               data,
                               14,
                               path
                             );


    //
    // Allow another to specify the RPC code
    //
    if (bMpc){
	lstrcpyn(tString,mpcName,RPC_LENGTH+1);
    } else {
        lstrcpyn(tString,DEFAULT_RPC,RPC_LENGTH+1);
    }
    lstrcpy(&tString[RPC_LENGTH],SiteSuffix[st]);
    WritePrivateProfileString( "Pid",
			       "Pid",
			       tString,
			       path
			     );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\encrypt\setpwd.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setpwd.c

Abstract:

    Sets a user's password based on OWF password hash strings
    Calls SamiChangePasswordUser with encoded passwords.

Author:

    Ovidiu Temereanca   17-Mar-2000     Initial implementation

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntsamp.h>
//#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
//#include <lmcons.h>
#include <align.h>
//#include <lm.h>
//#include <limits.h>
//#include <rpcutil.h>
//#include <secobj.h>
//#include <stddef.h>
//#include <ntdsapi.h>
//#include <dsgetdc.h>
#include <windows.h>

#include "encrypt.h"



NTSTATUS
pGetDomainId (
    IN      SAM_HANDLE ServerHandle,
    OUT     PSID* DomainId
    )

/*++

Routine Description:

    Return a domain ID of the account domain of a server.

Arguments:

    ServerHandle - A handle to the SAM server to open the domain on

    DomainId - Receives a pointer to the domain ID.
                Caller must deallocate buffer using SamFreeMemory.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS status;
    SAM_ENUMERATE_HANDLE EnumContext;
    PSAM_RID_ENUMERATION EnumBuffer = NULL;
    DWORD CountReturned = 0;
    PSID LocalDomainId = NULL;
    DWORD LocalBuiltinDomainSid[sizeof(SID) / sizeof(DWORD) + SID_MAX_SUB_AUTHORITIES];
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    BOOL b = FALSE;
    ULONG i;

    //
    // Compute the builtin domain sid.
    //
    RtlInitializeSid((PSID) LocalBuiltinDomainSid, &BuiltinAuthority, 1);
    *(RtlSubAuthoritySid((PSID)LocalBuiltinDomainSid,  0)) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Loop getting the list of domain ids from SAM
    //
    EnumContext = 0;
    do {

        //
        // Get several domain names.
        //
        status = SamEnumerateDomainsInSamServer (
                            ServerHandle,
                            &EnumContext,
                            &EnumBuffer,
                            8192,
                            &CountReturned
                             );

        if (!NT_SUCCESS (status)) {
            goto exit;
        }

        if (status != STATUS_MORE_ENTRIES) {
            b = TRUE;
        }

        //
        // Lookup the domain ids for the domains
        //

        for(i = 0; i < CountReturned; i++) {

            //
            // Free the sid from the previous iteration.
            //
            if (LocalDomainId != NULL) {
                SamFreeMemory (LocalDomainId);
                LocalDomainId = NULL;
            }

            //
            // Lookup the domain id
            //
            status = SamLookupDomainInSamServer (
                            ServerHandle,
                            &EnumBuffer[i].Name,
                            &LocalDomainId
                            );

            if (!NT_SUCCESS (status)) {
                goto exit;
            }

            if (RtlEqualSid ((PSID)LocalBuiltinDomainSid, LocalDomainId)) {
                continue;
            }

            *DomainId = LocalDomainId;
            LocalDomainId = NULL;
            status = NO_ERROR;
            goto exit;
        }

        SamFreeMemory(EnumBuffer);
        EnumBuffer = NULL;

    } while (!b);

    status = ERROR_NO_SUCH_DOMAIN;

exit:
    if (EnumBuffer != NULL) {
        SamFreeMemory(EnumBuffer);
    }

    return status;
}


DWORD
pSamOpenLocalUser (
    IN      PCWSTR UserName,
    IN      ACCESS_MASK DesiredAccess,
    IN      PSAM_HANDLE DomainHandle,
    OUT     PSAM_HANDLE UserHandle
    )

/*++

Routine Description:

    Returns a user handle given its name, desired access and a domain handle.

Arguments:

    UserName - Specifies the user name

    DesiredAccess - Specifies the desired access to this user

    DoaminHandle - A handle to the domain to open the user on

    UserHandle - Receives a user handle.
                 Caller must free the handle using SamCloseHandle.

Return Value:

    Error code for the operation.

--*/

{
    DWORD status;
    UNICODE_STRING uniUserName;
    ULONG rid, *prid;
    PSID_NAME_USE nameUse;

    //
    // Lookup the RID
    //
    RtlInitUnicodeString (&uniUserName, UserName);

    status = SamLookupNamesInDomain (
               DomainHandle,
               1,
               &uniUserName,
               &prid,
               &nameUse
               );
    if (status != NO_ERROR) {
        return status;
    }

    //
    // Save the RID
    //
    rid = *prid;

    //
    // free the memory.
    //
    SamFreeMemory (prid);
    SamFreeMemory (nameUse);

    //
    // Open the user object.
    //
    status = SamOpenUser(
                DomainHandle,
                DesiredAccess,
                rid,
                UserHandle
                );

    return status;
}


DWORD
SetLocalUserEncryptedPassword (
    IN      PCWSTR User,
    IN      PCWSTR OldPassword,
    IN      BOOL OldIsEncrypted,
    IN      PCWSTR NewPassword,
    IN      BOOL NewIsEncrypted
    )

/*++

Routine Description:

    Sets a new password for the given user. The password is in encrypted format (see encrypt.h for details).

Arguments:

    User - Specifies the user name

    OldPassword - Specifies the old password
    OldIsEncrypted - Specifies TRUE if old password is provided in encrypted form
                   or FALSE if it's in clear text
    OldIsComplex - Specifies TRUE if old password is complex; used only if OldIsEncrypted is TRUE,
                   otherwise it's ignored.
    NewPassword - Specifies the new password
    NewIsEncrypted - Specifies TRUE if new password is provided in encrypted form
                     or FALSE if it's in clear text

Return Value:

    Win32 error code for the operation.

--*/

{
    DWORD status;
    LM_OWF_PASSWORD lmOwfOldPwd;
    NT_OWF_PASSWORD ntOwfOldPwd;
    BOOL complexOldPassword;
    LM_OWF_PASSWORD lmOwfNewPwd;
    NT_OWF_PASSWORD ntOwfNewPwd;
    UNICODE_STRING unicodeString;
    PSID serverHandle = NULL;
    PSID sidAccountsDomain = NULL;
    SAM_HANDLE handleAccountsDomain = NULL;
    SAM_HANDLE handleUser = NULL;

    if (!User) {
        return ERROR_INVALID_PARAMETER;
    }

    if (OldIsEncrypted) {
        if (!StringDecodeOwfPasswordW (OldPassword, &lmOwfOldPwd, &ntOwfOldPwd, &complexOldPassword)) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        if (!EncodeLmOwfPasswordW (OldPassword, &lmOwfOldPwd, &complexOldPassword) ||
            !EncodeNtOwfPasswordW (OldPassword, &ntOwfOldPwd)
            ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (NewIsEncrypted) {
        if (!StringDecodeOwfPasswordW (NewPassword, &lmOwfNewPwd, &ntOwfNewPwd, NULL)) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        if (!EncodeLmOwfPasswordW (NewPassword, &lmOwfNewPwd, NULL) ||
            !EncodeNtOwfPasswordW (NewPassword, &ntOwfNewPwd)
            ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    __try {
        //
        // Use SamConnect to connect to the local domain ("")
        // and get a handle to the local SAM server
        //
        RtlInitUnicodeString (&unicodeString, L"");
        status = SamConnect (
                    &unicodeString,
                    &serverHandle,
                    SAM_SERVER_LOOKUP_DOMAIN | SAM_SERVER_ENUMERATE_DOMAINS,
                    NULL
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = pGetDomainId (serverHandle, &sidAccountsDomain);
        if (status != NO_ERROR) {
            __leave;
        }

        //
        // Open the domain.
        //
        status = SamOpenDomain (
                    serverHandle,
                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                    sidAccountsDomain,
                    &handleAccountsDomain
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = pSamOpenLocalUser (
                    User,
                    USER_CHANGE_PASSWORD,
                    handleAccountsDomain,
                    &handleUser
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = SamiChangePasswordUser (
                    handleUser,
                    !complexOldPassword,
                    &lmOwfOldPwd,
                    &lmOwfNewPwd,
                    TRUE,
                    &ntOwfOldPwd,
                    &ntOwfNewPwd
                    );
    }
    __finally {
        if (handleUser) {
            SamCloseHandle (handleUser);
        }
        if (handleAccountsDomain) {
            SamCloseHandle (handleAccountsDomain);
        }
        if (sidAccountsDomain) {
            SamFreeMemory (sidAccountsDomain);
        }
        if (serverHandle) {
            SamCloseHandle (serverHandle);
        }
    }

    return RtlNtStatusToDosError (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\encrypt\encrypt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Provides a set of functions dealing with OWF hash values of passwords.

Author:

    Ovidiu Temereanca (ovidiut) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include <windows.h>

#include "encrypt.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

PSTR
ConvertW2A (
    IN      PCWSTR Unicode,
    IN      UINT CodePage
    )

/*++

Routine Description:

    Converts an UNICODE string to it's ANSI equivalent, using the given codepage.

Arguments:

    Unicode - Specifies the string to be converted
    CodePage - Specifies the code page used for conversion

Return value:

    A pointer to the ANSI string if successful, or NULL on error. Call GetLastError()
    to determine the cause of failure.

--*/

{
    PSTR ansi = NULL;
    DWORD rc;

    rc = WideCharToMultiByte (
             CodePage,
             WC_NO_BEST_FIT_CHARS,
             Unicode,
             -1,
             NULL,
             0,
             NULL,
             NULL
             );

    if (rc || *Unicode == L'\0') {

        ansi = (PSTR)HeapAlloc (GetProcessHeap (), 0, (rc + 1) * sizeof (CHAR));
        if (ansi) {
            rc = WideCharToMultiByte (
                     CodePage,
                     WC_NO_BEST_FIT_CHARS,
                     Unicode,
                     -1,
                     ansi,
                     rc + 1,
                     NULL,
                     NULL
                     );

            if (!(rc || *Unicode == L'\0')) {
                rc = GetLastError ();
                HeapFree (GetProcessHeap (), 0, (PVOID)ansi);
                ansi = NULL;
                SetLastError (rc);
            }
        }
    }

    return ansi;
}


PWSTR
ConvertA2W (
    IN      PCSTR Ansi,
    IN      UINT CodePage
    )

/*++

Routine Description:

    Converts an ANSI string to it's UNICODE equivalent, using the given codepage.

Arguments:

    Ansi - Specifies the string to be converted
    CodePage - Specifies the code page used for conversion

Return value:

    A pointer to the UNICODE string if successful, or NULL on error. Call GetLastError()
    to determine the cause of failure.

--*/

{
    PWSTR unicode = NULL;
    DWORD rc;

    rc = MultiByteToWideChar (
             CodePage,
             MB_ERR_INVALID_CHARS,
             Ansi,
             -1,
             NULL,
             0
             );

    if (rc || *Ansi == '\0') {

        unicode = (PWSTR) HeapAlloc (GetProcessHeap (), 0, (rc + 1) * sizeof (WCHAR));
        if (unicode) {
            rc = MultiByteToWideChar (
                     CodePage,
                     MB_ERR_INVALID_CHARS,
                     Ansi,
                     -1,
                     unicode,
                     rc + 1
                     );

            if (!(rc || *Ansi == '\0')) {
                rc = GetLastError ();
                HeapFree (GetProcessHeap (), 0, (PVOID)unicode);
                unicode = NULL;
                SetLastError (rc);
            }
        }
    }

    return unicode;
}


/*++

Routine Description:

    EncodeLmOwfPassword converts a password to the LM OWF format.

Arguments:

    Password - Specifies the password to be hashed
    OwfPassword - Receives the hash form
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
EncodeLmOwfPasswordA (
    IN      PCSTR AnsiPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    CHAR oemPassword[LM_PASSWORD_SIZE_MAX];
    CHAR password[LM_PASSWORD_SIZE_MAX];
    BOOL complex;

    if (!AnsiPassword) {
        AnsiPassword = "";
    }

    complex = lstrlenA (AnsiPassword) > LM20_PWLEN;
    if (ComplexNtPassword) {
        *ComplexNtPassword = complex;
    }

    if (complex) {
        password[0] = 0;
    } else {
        lstrcpyA (oemPassword, AnsiPassword);
        CharUpperA (oemPassword);
        CharToOemA (oemPassword, password);
    }

    return CalculateLmOwfPassword (password, OwfPassword);
}

BOOL
EncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    PSTR ansi;
    BOOL b = FALSE;

    if (!Password) {
        Password = L"";
    }

    ansi = ConvertW2A (Password, CP_ACP);
    if (ansi) {
        b = EncodeLmOwfPasswordA (ansi, OwfPassword, ComplexNtPassword);
        HeapFree (GetProcessHeap (), 0, (PVOID)ansi);
    }

    return b;
}


/*++

Routine Description:

    StringEncodeLmOwfPassword converts a password to the LM OWF format, expressed as
    a string of characters (each byte converted to 2 hex digits).

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeLmOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    LM_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PSTR dest;

    if (!EncodeLmOwfPasswordA (Password, &owfPassword, ComplexNtPassword)) {
        return FALSE;
    }
    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (LM_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfA (dest, "%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}

BOOL
StringEncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    LM_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PWSTR dest;

    if (!EncodeLmOwfPasswordW (Password, &owfPassword, ComplexNtPassword)) {
        return FALSE;
    }

    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (LM_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfW (dest, L"%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}


/*++

Routine Description:

    EncodeNtOwfPassword converts a password to the NT OWF format.

Arguments:

    Password - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful hashing

--*/

BOOL
EncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    PWSTR unicode;
    BOOL b = FALSE;

    unicode = ConvertA2W (Password, CP_ACP);
    if (unicode) {
        b = EncodeNtOwfPasswordW (unicode, OwfPassword);
        HeapFree (GetProcessHeap (), 0, unicode);
    }

    return b;
}

BOOL
EncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    NT_PASSWORD pwd;

    if (Password) {
        pwd.Buffer = (PWSTR)Password;
        pwd.Length = (USHORT)lstrlenW (Password) * (USHORT)sizeof (WCHAR);
        pwd.MaximumLength = pwd.Length + (USHORT) sizeof (WCHAR);
    } else {
        ZeroMemory (&pwd, sizeof (pwd));
    }

    return CalculateNtOwfPassword (&pwd, OwfPassword);
}


/*++

Routine Description:

    StringEncodeNtOwfPassword converts a password to the NT OWF format, expressed as
    a string of characters (each byte converted to 2 hex digits).

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword
    )
{
    NT_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PSTR dest;

    if (!EncodeNtOwfPasswordA (Password, &owfPassword)) {
        return FALSE;
    }
    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (NT_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfA (dest, "%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}

BOOL
StringEncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword
    )
{
    NT_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PWSTR dest;

    if (!EncodeNtOwfPasswordW (Password, &owfPassword)) {
        return FALSE;
    }

    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (NT_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfW (dest, L"%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}


/*++

Routine Description:

    StringDecodeLmOwfPassword converts a hashed password to the LM OWF format

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful decoding of the string

--*/

BOOL
StringDecodeLmOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCSTR p;
    PBYTE dest;
    CHAR ch;

    if (lstrlenA (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F'))) {
            return FALSE;
        }
        if (*p <= '9') {
            ch |= *p - '0';
        } else if (*p <= 'F') {
            ch |= *p - 'A' + 10;
        } else {
            ch |= *p - 'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}

BOOL
StringDecodeLmOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCWSTR p;
    PBYTE dest;
    WCHAR ch;

    if (lstrlenW (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= L'0' && *p <= L'9') || (*p >= L'a' && *p <= L'f') || (*p >= L'A' && *p <= L'F'))) {
            return FALSE;
        }
        if (*p <= L'9') {
            ch |= *p - L'0';
        } else if (*p <= L'F') {
            ch |= *p - L'A' + 10;
        } else {
            ch |= *p - L'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = (BYTE)ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    StringDecodeNtOwfPassword converts a hashed password to the NT OWF format

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful decoding of the string

--*/

BOOL
StringDecodeNtOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCSTR p;
    PBYTE dest;
    CHAR ch;

    if (lstrlenA (EncodedOwfPassword) != sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F'))) {
            return FALSE;
        }
        if (*p <= '9') {
            ch |= *p - '0';
        } else if (*p <= 'F') {
            ch |= *p - 'A' + 10;
        } else {
            ch |= *p - 'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}

BOOL
StringDecodeNtOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCWSTR p;
    PBYTE dest;
    WCHAR ch;

    if (lstrlenW (EncodedOwfPassword) != sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= L'0' && *p <= L'9') || (*p >= L'a' && *p <= L'f') || (*p >= L'A' && *p <= L'F'))) {
            return FALSE;
        }
        if (*p <= L'9') {
            ch |= *p - L'0';
        } else if (*p <= L'F') {
            ch |= *p - L'A' + 10;
        } else {
            ch |= *p - L'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = (BYTE)ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    StringEncodeOwfPassword converts a password to its hashed format, expressed as
    a string of characters (each byte converted to 2 hex digits). The result is
    obtained joining the 2 substrings, one representing LM OWF and the other NT OWF

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    return StringEncodeLmOwfPasswordA (Password, EncodedPassword, ComplexNtPassword) &&
           StringEncodeNtOwfPasswordA (Password, EncodedPassword + STRING_ENCODED_LM_OWF_PWD_LENGTH);
}

BOOL
StringEncodeOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    return StringEncodeLmOwfPasswordW (Password, EncodedPassword, ComplexNtPassword) &&
           StringEncodeNtOwfPasswordW (Password, EncodedPassword + STRING_ENCODED_LM_OWF_PWD_LENGTH);
}


/*++

Routine Description:

    StringDecodeOwfPassword decodes a password's LM OWF and NT OWF forms from its hashed format,
    expressed as a string of hex digits.

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    LmOwfPassword - Receives the LM OWF hash form
    NtOwfPassword - Receives the NT OWF hash form
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringDecodeOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    PSTR p;
    CHAR ch;
    BOOL b;
    CHAR buffer[sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2 + 2];
    LM_OWF_PASSWORD lmNull;
    NT_OWF_PASSWORD ntNull;

    if (lstrlenA (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    lstrcpyA (buffer, EncodedOwfPassword);
    //
    // split the string in two
    //
    p = buffer + (sizeof (LM_OWF_PASSWORD) * 2);

    ch = *p;
    *p = 0;
    b = StringDecodeLmOwfPasswordA (EncodedOwfPassword, LmOwfPassword);
    *p = ch;

    if (b) {
        b = StringDecodeNtOwfPasswordA (p, NtOwfPassword);
    }

    if (b && ComplexNtPassword) {
        b = EncodeLmOwfPasswordA ("", &lmNull, NULL) && EncodeNtOwfPasswordA ("", &ntNull);
        if (b) {
            //
            // it's a complex password if the LM hash is for NULL pwd
            // but NT hash it's not
            //
            *ComplexNtPassword = CompareLmPasswords (LmOwfPassword, &lmNull) == 0 &&
                                 CompareNtPasswords (NtOwfPassword, &ntNull) != 0;
        }
    }

    return b;
}

BOOL
StringDecodeOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword                 OPTIONAL
    )
{
    PWSTR p;
    WCHAR ch;
    BOOL b;
    WCHAR buffer[sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2 + 2];
    LM_OWF_PASSWORD lmNull;
    NT_OWF_PASSWORD ntNull;

    if (lstrlenW (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    lstrcpyW (buffer, EncodedOwfPassword);
    //
    // split the string in two
    //
    p = buffer + (sizeof (LM_OWF_PASSWORD) * 2);

    ch = *p;
    *p = 0;
    b = StringDecodeLmOwfPasswordW (buffer, LmOwfPassword);
    *p = ch;

    if (b) {
        b = StringDecodeNtOwfPasswordW (p, NtOwfPassword);
    }

    if (b && ComplexNtPassword) {
        b = EncodeLmOwfPasswordW (L"", &lmNull, NULL) && EncodeNtOwfPasswordW (L"", &ntNull);
        if (b) {
            //
            // it's a complex password if the LM hash is for NULL pwd
            // but NT hash it's not
            //
            *ComplexNtPassword = CompareLmPasswords (LmOwfPassword, &lmNull) == 0 &&
                                 CompareNtPasswords (NtOwfPassword, &ntNull) != 0;
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\encrypt\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        CalculateLmOwfPassword
        CalculateNtOwfPassword

Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for WfW RPC SSP)

Revision History:

--*/

#include <windows.h>
#include <descrypt.h>
#include <md4.h>

#include "encrypt.h"


BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
    password is in LmOwfPassword.

    FALSE - Something failed. The LmOwfPassword is undefined.
--*/

{
    char StdEncrPwd[] = "KGS!@#$%";
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[0],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[0]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[1],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[1]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(TRUE);
}


BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
           password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);

    if (sizeof(*NtOwfPassword) != sizeof(MD4_Context.digest)) {
        return(FALSE);
    }

    memcpy((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest, sizeof(*NtOwfPassword));

    return(TRUE);
}

INT
CompareLmPasswords (
    IN      PLM_OWF_PASSWORD LmOwfPassword1,
    IN      PLM_OWF_PASSWORD LmOwfPassword2
    )

/*++

Routine Description:

    Compares 2 LM OWF passwords.

Arguments:

    LmOwfPassword1 - The first password to compare

    LmOwfPassword2 - The second password to compare

Return Values:

    0 if they are equal, -1 if first is smaller (regarded as a string of bytes),
    1 if first is greater

--*/

{
    PBYTE p1 = (PBYTE)LmOwfPassword1;
    PBYTE p2 = (PBYTE)LmOwfPassword2;
    DWORD size = sizeof (LM_OWF_PASSWORD);
    CHAR diff;

    while (size--) {
        diff = *p1++ - *p2++;
        if (diff) {
            return (INT)diff;
        }
    }
    return 0;
}

INT
CompareNtPasswords (
    IN      PNT_OWF_PASSWORD NtOwfPassword1,
    IN      PNT_OWF_PASSWORD NtOwfPassword2
    )

/*++

Routine Description:

    Compares 2 NT OWF passwords.

Arguments:

    NtOwfPassword1 - The first password to compare

    NtOwfPassword2 - The second password to compare

Return Values:

    0 if they are equal, -1 if first is smaller (regarded as a string of bytes),
    1 if first is greater

--*/

{
    PBYTE p1 = (PBYTE)NtOwfPassword1;
    PBYTE p2 = (PBYTE)NtOwfPassword2;
    DWORD size = sizeof (NT_OWF_PASSWORD);
    CHAR diff;

    while (size--) {
        diff = *p1++ - *p2++;
        if (diff) {
            return (INT)diff;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\excppkg\register.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    register.c

Abstract:

    Implementation of exception package migration registration.
    
    An exception package consists is a setupapi package that can be installed
    on the system.  The package consists of an exception INF, a catalog file, 
    and the corresponding files for the package.  All files in this package 
    must be signed.  The catalog is signed and contains signatures for all 
    other files in the catalog (including the INF).
    
    Packages to be migrated from downlevel systems are registered with the
    following APIs in this module.  The APIs simply validate that the package
    is put together properly and stores migration information in the registry
    in a well-known location.
    
    The data is stored under the following key:
    
    Software\Microsoft\Windows\CurrentVersion\Setup\ExceptionComponents
    
    There is one subkey corresponding to the GUID for each component.
    The data for each component is then stored under this key.
    
    In addition, the toplevel key has a "ComponentList" REG_EXPAND_SZ, which
    lists the order in which the components should be enumerated.
    
    Note that the following code only uses common system APIs instead of 
    any pre-defined library routines.  This is to ensure that this library can
    run on downlevel systems without any odd dependencies.

Author:

    Andrew Ritz (AndrewR) 21-Oct-1999

Revision History:

    Andrew Ritz (andrewr) 21-Oct-1999 : Created It

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <setupapi.h>
#include <ole2.h>
#include <excppkg.h>

#define COMPONENT_KEY  L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\ExceptionComponents"
#define COMPONENT_LIST L"ComponentList"

#define EXCEPTION_CLASS_GUID L"{F5776D81-AE53-4935-8E84-B0B283D8BCEF}"

#define COMPONENT_FRIENDLY_NAME L"FriendlyName"
#define COMPONENT_GUID          L"ComponentGUID"
#define COMPONENT_VERSION       L"Version"
#define COMPONENT_SUBVERSION    L"Sub-Version"
#define EXCEPTION_INF_NAME      L"ExceptionInfName"
#define EXCEPTION_CATALOG_NAME  L"ExceptionCatalogName"

#define MALLOC(_size_)  HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, _size_ )
#define FREE(_ptr_)     HeapFree( GetProcessHeap(), 0 , _ptr_ )


typedef struct _COMPONENT_ENUMERATION_LIST {
    LPGUID InputComponentList;
    DWORD  ComponentCount;
    DWORD  ValidatedCount;
    PDWORD ComponentVector;
} COMPONENT_ENUMERATION_LIST, *PCOMPONENT_ENUMERATION_LIST;
    

BOOL
WINAPI
_SetupSetRegisteredOsComponentsOrder(
    IN  DWORD    ComponentCount,
    IN  const LPGUID   ComponentList,
    IN  BOOL     DoValidation
    );

BOOL
pSetComponentData(
    IN HKEY hKey,
    IN const PSETUP_OS_COMPONENT_DATA ComponentData
    )
/*++

Routine Description:

    Set's the data in the SETUP_OS_COMPONENT_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data was successfully set in the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD value;
    PWSTR GuidString;

    //
    // just set the data, assume that it's already been validated
    //

    //
    // FriendlyName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_FRIENDLY_NAME,
                    0,
                    REG_SZ,
                    (CONST PBYTE)ComponentData->FriendlyName,
                    (wcslen(ComponentData->FriendlyName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }


    StringFromIID( &ComponentData->ComponentGuid, &GuidString );
    
    //
    // ComponentGUID
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_GUID,
                    0,
                    REG_SZ,
                    (CONST PBYTE)GuidString,
                    (wcslen(GuidString)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }    

    //
    // Version
    //
    value = MAKELONG( ComponentData->VersionMinor, ComponentData->VersionMajor );
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_VERSION,
                    0,
                    REG_DWORD,
                    (CONST PBYTE)&value,
                    sizeof(DWORD));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    //
    // build+QFE
    //
    value = MAKELONG( ComponentData->QFENumber, ComponentData->BuildNumber );
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_SUBVERSION,
                    0,
                    REG_DWORD,
                    (CONST PBYTE)&value,
                    sizeof(DWORD));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    RetVal = TRUE;

e1:
    CoTaskMemFree( GuidString );
e0:
    return(RetVal);
}

BOOL
pGetComponentData(
    IN HKEY hKey,
    IN const PSETUP_OS_COMPONENT_DATA ComponentData
    )
/*++

Routine Description:

    Retreives the data in the SETUP_OS_COMPONENT_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data was successfully retreived.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD Type,Size;
    DWORD Version;
    DWORD SubVersion;
    WCHAR GuidString[40];

    //
    // FriendlyName
    //
    Size = sizeof(ComponentData->FriendlyName);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_FRIENDLY_NAME,
                    0,
                    &Type,
                    (LPBYTE)ComponentData->FriendlyName,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    if (Type != REG_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }

    //
    // ComponentGUID
    //
    Size = sizeof(GuidString);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_GUID,
                    0,
                    &Type,
                    (LPBYTE)GuidString,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    if (Type != REG_SZ) {    
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }
    

    if (IIDFromString( GuidString, &ComponentData->ComponentGuid ) != S_OK) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }


    //
    // Version
    //
    Size = sizeof(Version);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_VERSION,
                    0,
                    &Type,
                    (LPBYTE)&Version,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e2;
    }

    if (Type != REG_DWORD) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }

    ComponentData->VersionMajor = HIWORD(Version);
    ComponentData->VersionMinor = LOWORD(Version);

    //
    // Sub-Version
    //
    Size = sizeof(SubVersion);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_SUBVERSION,
                    0,
                    &Type,
                    (LPBYTE)&SubVersion,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e3;
    }

    if (Type != REG_DWORD) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e3;
    }

    ComponentData->BuildNumber = HIWORD(SubVersion);
    ComponentData->QFENumber  = LOWORD(SubVersion);

    RetVal = TRUE;
    goto e0;

e3:
    ComponentData->VersionMajor = 0;
    ComponentData->VersionMinor = 0;
e2:
    ZeroMemory(
            &ComponentData->ComponentGuid, 
            sizeof(ComponentData->ComponentGuid));
e1:
    ComponentData->FriendlyName[0] = L'0';
e0:
    return(RetVal);
}

BOOL
pSetExceptionData(
    IN HKEY hKey,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Set's the data in the SETUP_OS_EXCEPTION_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data is successfully stored in the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;

    //
    // just set the data, assume that it's already been validated
    //

    //
    // InfName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    EXCEPTION_INF_NAME,
                    0,
                    REG_EXPAND_SZ,
                    (CONST PBYTE)ExceptionData->ExceptionInfName,
                    (wcslen(ExceptionData->ExceptionInfName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    //
    // CatalogName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    EXCEPTION_CATALOG_NAME,
                    0,
                    REG_EXPAND_SZ,
                    (CONST PBYTE)ExceptionData->CatalogFileName,
                    (wcslen(ExceptionData->CatalogFileName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    RetVal = TRUE;

e0:
    return(RetVal);
}

BOOL
pGetExceptionData(
    IN HKEY hKey,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Retreives the data in the SETUP_OS_EXCEPTION_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data is successfully retreived from the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD Type,Size;
    WCHAR Buffer[MAX_PATH];

    //
    // InfName
    //
    Size = sizeof(Buffer);
    rslt = RegQueryValueEx( 
                    hKey, 
                    EXCEPTION_INF_NAME,
                    0,
                    &Type,
                    (LPBYTE)Buffer,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    if (Type != REG_EXPAND_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    if (!ExpandEnvironmentStrings(
                Buffer,
                ExceptionData->ExceptionInfName,
                sizeof(ExceptionData->ExceptionInfName)/sizeof(WCHAR))) {
        RetVal = FALSE;
        goto e0;
    }

    //
    // Catalog Name
    //
    Size = sizeof(Buffer);
    rslt = RegQueryValueEx( 
                    hKey, 
                    EXCEPTION_CATALOG_NAME,
                    0,
                    &Type,
                    (LPBYTE)Buffer,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    if (Type != REG_EXPAND_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }

    if(!ExpandEnvironmentStrings(
                Buffer,
                ExceptionData->CatalogFileName,
                sizeof(ExceptionData->CatalogFileName)/sizeof(WCHAR))) {
        RetVal = FALSE;
        goto e1;
    }

    RetVal = TRUE;
    goto e0;


e1:
    ExceptionData->ExceptionInfName[0] = L'0';
e0:
    return(RetVal);

}


BOOL
WINAPI
SetupRegisterOsComponent(
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Registers the specified component as a exception migration component.
    
    This function does validation of the package, trying to assert that the
    package has a good probability of succeeding installation.  It then
    records the data about the package in the registry.
    

Arguments:

    ComponentData - specifies the component identification data
    ExceptionData - specifies the exception package identification data        
    
Return Value:

    TRUE if the component is successfully registered with the operating system.

--*/
{
    BOOL RetVal;
    HKEY hKey,hKeyComponent;
    LONG rslt;
    HINF hInf;
    DWORD ErrorLine;
    INFCONTEXT InfContext;
    WCHAR InfComponentGuid[64];
    PWSTR InputGuidString;
    WCHAR InfName[MAX_PATH];
    WCHAR CatalogName[MAX_PATH];
    WCHAR InfCatName[MAX_PATH];
    DWORD Disposition;

    DWORD ComponentCount;
    DWORD Size;
    PWSTR p;
    LPGUID ComponentList;

    //
    // parameter validation
    //
    if (!ComponentData || !ExceptionData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // make sure we only register a component for a revision level 
    // which we understand.
    //
    if ((ComponentData->SizeOfStruct != sizeof(SETUP_OS_COMPONENT_DATA)) || 
        (ExceptionData->SizeOfStruct != sizeof(SETUP_OS_EXCEPTION_DATA))) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // All of the parameters in the structure are required
    //
    if (!*ComponentData->FriendlyName || 
        !*ExceptionData->ExceptionInfName || !*ExceptionData->CatalogFileName) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // Make sure that the INF and catalog are both present.
    //
    ExpandEnvironmentStrings(
                    ExceptionData->ExceptionInfName,
                    InfName,
                    sizeof(InfName)/sizeof(WCHAR));

    ExpandEnvironmentStrings(
                    ExceptionData->CatalogFileName,
                    CatalogName,
                    sizeof(CatalogName)/sizeof(WCHAR));

    if (GetFileAttributes(InfName) == -1 ||
        GetFileAttributes(CatalogName) == -1) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the INF to do some validation
    //
    hInf = SetupOpenInfFile( InfName, 
                             NULL, //EXCEPTION_CLASS_GUID,
                             INF_STYLE_WIN4,
                             &ErrorLine);

    if (hInf == INVALID_HANDLE_VALUE) {
        // return last error code from setupopeninffile
        RetVal = FALSE;
        goto e0;
    }

    //
    // Make sure the class GUID matches the expected exception class
    // class GUID.
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"ClassGUID",
                    &InfContext)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfComponentGuid,
                    sizeof(InfComponentGuid),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e1;
    }

    if (_wcsicmp(EXCEPTION_CLASS_GUID, InfComponentGuid)) {
        SetLastError(ERROR_INVALID_CLASS);
        RetVal = FALSE;
        goto e1;
    }

    //
    // Make sure that the INF component ID matches the supplied GUID
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"ComponentId", 
                    &InfContext)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfComponentGuid,
                    sizeof(InfComponentGuid),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e1;
    }

    StringFromIID( &ComponentData->ComponentGuid, &InputGuidString );

    if (_wcsicmp(InfComponentGuid, InputGuidString)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }

    //
    // Make sure the INF has a catalogfile= line, and that this line matches
    // the specified catalog file
    //
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"CatalogFile", 
                    &InfContext)) {        
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfCatName,
                    sizeof(InfCatName),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e2;
    }

    p = wcsrchr( CatalogName, L'\\' );
    if (p) {
        p += 1;
    } else {
        p = CatalogName;
    }

    if (_wcsicmp(p, InfCatName)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }


    //
    // Everything seems to validate.  Try to add the new component.
    //

    //
    // Before we try to add the component, get the list of existing components 
    // so we can set the component in the list of components.
    // 
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL
                                    )) {
        RetVal = FALSE;
        goto e2;
    }

    ComponentList = (LPGUID)MALLOC((ComponentCount+1)*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e3;
    }
    
    //
    // put the new component at the tail of the component list (since this is
    // a zero-based array, this is easy to insert).
    //
    RtlMoveMemory(
            &ComponentList[ComponentCount],
            &ComponentData->ComponentGuid,
            sizeof(ComponentData->ComponentGuid));
    
    //
    // First open the main key which all components live under
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;
    }

    //
    // now look at the actual key we'll store this component under
    //
    rslt = RegCreateKeyEx(
                hKey,
                InputGuidString,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKeyComponent,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e4;
    } 
    
    //
    // If this component is already registered, then bail
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        SetLastError(ERROR_ALREADY_EXISTS);
        RetVal = FALSE;
        goto e5;
    }

    //
    // The key is created, now set all of the data under the key
    //
    if (!pSetComponentData(hKeyComponent, ComponentData) ||
        !pSetExceptionData(hKeyComponent, ExceptionData)) {
        //
        // if we failed, we need to delete everything under this key
        //
        rslt = GetLastError();
        RegDeleteKey( hKey, InputGuidString );
        SetLastError(rslt);
        RetVal = FALSE;
        goto e5;
    }    

    //
    // now set the component order in the registry
    //
    if (!_SetupSetRegisteredOsComponentsOrder(
                                    ComponentCount+1,
                                    ComponentList,
                                    FALSE)) {
        rslt = GetLastError();
        RegDeleteKey( hKey, InputGuidString );
        SetLastError(rslt);
        RetVal = FALSE;
        goto e5;
    }

    RetVal = TRUE;
        
e5:
    RegCloseKey(hKeyComponent);
e4:    
    RegCloseKey(hKey);
e3:
    FREE(ComponentList);
e2:
    CoTaskMemFree(InputGuidString);
e1:
    SetupCloseInfFile(hInf);
e0:
    return(RetVal);

}


BOOL
WINAPI
SetupUnRegisterOsComponent(
    IN const LPGUID ComponentGuid
    )
/*++

Routine Description:

    De-Registers the specified component as a exception migration component.
    
    This function only removes the exception package data from the registry.
    It does not remove any on-disk files which correspond with the migration
    component data.
    

Arguments:

    ComponentData - specifies the component identification data
    ExceptionData - specifies the exception package identification data        
    
Return Value:

    TRUE if the component is successfully registered with the operating system.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Size,ComponentCount;
    PWSTR GuidString;
    LPGUID ComponentList,NewList,src,dst;
    DWORD i;

    //
    // parameter validation
    //
    if (!ComponentGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    StringFromIID( ComponentGuid, &GuidString );
    
    //
    // open the main component key where all of the subcomponents live
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    //
    // query the component order list so that we can remove this component
    // from the list
    //
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL)) {
        RetVal = FALSE;
        goto e1;
    }

    ComponentList = (LPGUID)MALLOC((ComponentCount)*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e1;
    }

    NewList = (LPGUID)MALLOC((ComponentCount)*sizeof(GUID));
    if (!NewList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e3;
    }

    if (ComponentCount) {    
        //
        // Iterate through the list of components, keeping all of the components
        // except for the one we're removing.
        //
        BOOL FoundEntry;
        src = ComponentList;
        dst = NewList;
        i = 0;
        FoundEntry = FALSE;
        while(i < ComponentCount) {
            if (!IsEqualGUID(src,ComponentGuid)) {
                RtlMoveMemory(dst,src,sizeof(GUID));
                dst = dst + 1;
            } else {
                FoundEntry = TRUE;
            }
    
            src = src + 1;
            i +=1;
        }

        if (!FoundEntry) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            RetVal = FALSE;
            goto e3;
        }
    
        if (!_SetupSetRegisteredOsComponentsOrder(
                                        ComponentCount-1,
                                        NewList,
                                        FALSE)) {
            RetVal = FALSE;
            goto e3;
        }
    }

    //
    // Delete the key corresponding to the specified component.
    //
    rslt = RegDeleteKey( hKey, GuidString );
    if (rslt != ERROR_SUCCESS) {
        //
        // If this fails, we don't bother to put the component back in the list
        //
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;
    }

    RetVal = TRUE;

e3:
    FREE(NewList);
e2:
    FREE(ComponentList);
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}


BOOL
WINAPI
SetupEnumerateRegisteredOsComponents(
    IN PSETUPCOMPONENTCALLBACK SetupOsComponentCallback,
    IN DWORD_PTR Context
    )
/*++

Routine Description:

    This function calls the specified callback function once for each
    registered component.  The registered components are enumerated in
    the order defined by the "ComponentList".
    
    The enumeration stops if the enumerator returns FALSE or when all
    of the installed packages have been enumerated.        

Arguments:

    SetupOsComponentCallback - specifies a callback function which is called 
              once for each component.
    Context - specifies an opaque context point passed onto the callback
              function
              
The callback is of the form:
    
typedef BOOL
(CALLBACK *PSETUPCOMPONENTCALLBACK) (
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    );
    
    where
    
    SetupOsComponentData - specifies the component identification data for the 
                           component
    SetupOsExceptionData - specifies the exception package data for the 
                           component
    Context              - the context pointer passed into this function is passed
                           into the callback function
    
Return Value:

    TRUE if all of the components are enumerated.  If the callback stops
    enumeration, the function returns FALSE and GetLastError() returns 
    ERROR_CANCELLED.

--*/
{   
    BOOL    RetVal;
    LONG    rslt;
    HKEY    hKey,hKeyEnum;
    DWORD   Index = 0;
    DWORD   Disposition;
    WCHAR   SubKeyName[100];
    DWORD   Size;
    DWORD   ComponentCount;
    LPGUID  ComponentList;

    SETUP_OS_EXCEPTION_DATA OsExceptionDataInternal;
    SETUP_OS_COMPONENT_DATA OsComponentDataInternal;

    //
    // Caller must supply a callback
    //
    if (!SetupOsComponentCallback) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where all of the subcomponents live
    // (Note that we only require READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }


    //
    // query the component order list so that we can remove this component
    // from the list
    //
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!ComponentCount) {
        SetLastError(ERROR_NO_MORE_ITEMS);
        RetVal = TRUE;
        goto e1;
    }

    ComponentList = (LPGUID)MALLOC(ComponentCount*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // Iterate through the list of components, calling into the callback
    // for each one
    //
    for (Index = 0; Index < ComponentCount; Index++) {
        PWSTR GuidString;

        StringFromIID( &ComponentList[Index], &GuidString );

        //
        // open that key name
        //
        rslt = RegOpenKeyEx(
                    hKey,
                    GuidString,
                    0,
                    KEY_READ,
                    &hKeyEnum);

        CoTaskMemFree( GuidString );

        if (rslt != ERROR_SUCCESS) {
            SetLastError( rslt );
            RetVal = FALSE;
            goto e2;
        } 
        
        //
        // retreive the data under this key
        //
        OsComponentDataInternal.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
        OsExceptionDataInternal.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
        if (!pGetComponentData(hKeyEnum, &OsComponentDataInternal) ||
            !pGetExceptionData(hKeyEnum, &OsExceptionDataInternal)) {
            RetVal = FALSE;
            goto e3;
        } 
        
        if (!SetupOsComponentCallback( 
                            &OsComponentDataInternal, 
                            &OsExceptionDataInternal,
                            Context )) {
            SetLastError(ERROR_CANCELLED);
            RetVal = FALSE;
            goto e3;
        }

        RegCloseKey( hKeyEnum );
        hKeyEnum = NULL;

    }

    RetVal = TRUE;

e3:
    if (hKeyEnum) {
        RegCloseKey( hKeyEnum );
    }
e2:
    FREE( ComponentList );
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}
    

BOOL
WINAPI
SetupQueryRegisteredOsComponent(
    IN LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    )
/*++

Routine Description:

    Retrieves information about the specified component.
    
Arguments:

    ComponentGuid - specifies the GUID for the component to retreive data about
    ComponentData - receives the component identification data
    ExceptionData - receives the exception package identification data        
    
Return Value:

    TRUE if the component data is successfully retreieved.

--*/
{
    HKEY hKey,hKeyComponent;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    SETUP_OS_EXCEPTION_DATA OsExceptionDataInternal;
    SETUP_OS_COMPONENT_DATA OsComponentDataInternal;
    PWSTR GuidString;

    //
    // parameter validation
    //
    if (!ComponentGuid || !SetupOsComponentData || !SetupOsExceptionData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // make sure we only retreive a component for a revision level
    // which we understand
    //
    if (SetupOsComponentData->SizeOfStruct > sizeof(SETUP_OS_COMPONENT_DATA) || 
        SetupOsExceptionData->SizeOfStruct > sizeof(SETUP_OS_EXCEPTION_DATA)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where all of the subcomponents live
    // (note that we only need READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    StringFromIID( ComponentGuid, &GuidString );

    //
    // now look at the actual key this component lives under
    //
    rslt = RegOpenKeyEx(
                hKey,
                GuidString,
                0,
                KEY_READ,
                &hKeyComponent);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e1;
    } 
    
    //
    // retrieve the data into internal buffers
    //
    OsComponentDataInternal.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    OsExceptionDataInternal.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!pGetComponentData(hKeyComponent, &OsComponentDataInternal) ||
        !pGetExceptionData(hKeyComponent, &OsExceptionDataInternal)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // move the data into the caller supplied buffer, but only copy as much 
    // data as the caller will understand
    //
    RtlMoveMemory(SetupOsComponentData,&OsComponentDataInternal,SetupOsComponentData->SizeOfStruct);
    RtlMoveMemory(SetupOsExceptionData,&OsExceptionDataInternal,SetupOsExceptionData->SizeOfStruct);
    

    RetVal = TRUE;
e2:
    RegCloseKey( hKeyComponent );
e1:
    CoTaskMemFree( GuidString );
    RegCloseKey( hKey );
e0:
    return(RetVal);
}



BOOL
WINAPI
SetupQueryRegisteredOsComponentsOrder(
     OUT PDWORD   ComponentCount,
     OUT LPGUID   ComponentList OPTIONAL
    )
/*++

Routine Description:

    Retrieves a list which specifies the order in which components will be applied.
    
Arguments:

    ComponentCount - Receives the number of installed components
    ComponentList  - This buffer receives an array of component GUIDs.  If 
                     this parameter is specified, it must be at least
                     )ComponentCount *sizeof(GUID)) bytes large.
    
Return Value:

    TRUE if the component ordering data is successfully retreieved.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Type,Size;
    DWORD Count;
    GUID  CurrentGuid;
    DWORD Index;
    PWSTR RegData;
    PWSTR p;
    

    //
    // parameter validation
    //
    if (!ComponentCount) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where the component order list lives.
    // (note that we only need READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    //
    // if the key was just created, then there can be no registered components
    //
    if (Disposition == REG_CREATED_NEW_KEY) {
        *ComponentCount = 0;
        SetLastError( ERROR_SUCCESS );
        RetVal = TRUE;
        goto e1;
    }

    //
    // try to access the registry value, seeing how much space we need for the
    // component;
    //
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    &Type,
                    (LPBYTE)NULL,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        if (rslt == ERROR_FILE_NOT_FOUND) {
            *ComponentCount = 0;        
            SetLastError( ERROR_SUCCESS );
            RetVal = TRUE;
            goto e1;
        } else {
            SetLastError( rslt );
            RetVal = FALSE;
            goto e1;
        }
    }

    //
    // allocate enough space to retrieve the data (plus some slop)
    //
    RegData = (PWSTR) MALLOC(Size+4);
    if (!RegData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        RetVal = TRUE;
        goto e1;
    }
    
    //
    // Now query the data
    //
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    &Type,
                    (LPBYTE)RegData,
                    &Size);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e2;
    }

    //
    // Count how many registry entries we have
    //
    Count = 0;
    p = RegData;
    while(*p) {
        p += wcslen(p)+1;
        Count += 1;
    }

    *ComponentCount = Count;

    //
    // if the caller didn't specify the ComponentList parameter, they just 
    // wanted to know how much space to allocate, so we're done.
    //
    if (!ComponentList) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        RetVal = TRUE;
        goto e2;
    }

    //
    // loop through the component list again, converting the string GUID
    // into a GUID structure, and copy this into the caller supplied buffer
    //
    for(Index = 0,p=RegData; Index < Count ; Index++,p += wcslen(p)+1) {
        if (IIDFromString( p, &CurrentGuid ) != S_OK) {
            RetVal = FALSE;
            goto e2;
        }

        RtlMoveMemory(&ComponentList[Index],&CurrentGuid,sizeof(GUID));
    }

    RetVal = TRUE;

e2:
    FREE( RegData );
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}


BOOL
CALLBACK
pComponentListValidator(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PCOMPONENT_ENUMERATION_LIST cel = (PCOMPONENT_ENUMERATION_LIST) Context;
    
    DWORD i;

    i = 0;
    //
    // make sure that each component GUID is in our list once.
    //
    while(i < cel->ComponentCount) {
        if (IsEqualGUID(
                &SetupOsComponentData->ComponentGuid,
                &cel->InputComponentList[i])) {
            //
            // if the vector is already set, this means that the GUID
            // is already in the list and we've hit a dup.
            //
            if(cel->ComponentVector[i]) {
                return(FALSE);
            }
            cel->ComponentVector[i] = 1;
            cel->ValidatedCount += 1;
            break;
        }
        i += 1;        
    }
    
    return(TRUE);
}
    

BOOL
WINAPI
_SetupSetRegisteredOsComponentsOrder(
    IN  DWORD    ComponentCount,
    IN  const LPGUID   ComponentList,
    IN  BOOL     DoValidation
    )
/*++

Routine Description:

    Allows the caller to specify the order in which components should be 
    applied.
    
    This is an internal call that allows us to control whether or not we do
    parameter validation (We don't validate parameters on internal calls 
    because we are adding or removing components in internal calls and our
    validation checks will all be off by one.)
    
Arguments:

    ComponentCount - specifies the component order (by GUID). 
    ComponentList - specifies the number of registered components
    DoValidation  - specifies whether the component list should be validated
    
    
Return Value:

    TRUE if the component order is successfully changed.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Type,Size;
    DWORD Count;
    PWSTR RegData,p,GuidString;
    COMPONENT_ENUMERATION_LIST cel;

    cel.ComponentVector = NULL;

    if (DoValidation) {
        DWORD ActualComponentCount;

        //
        // parameter validation
        //
        if (!ComponentCount || !ComponentList) {
            SetLastError(ERROR_INVALID_PARAMETER);
            RetVal = FALSE;
            goto e0;
        }

        //
        // Make sure that the specified list contains all of the components and 
        // that all components are only listed once.
        //
        cel.InputComponentList = ComponentList;
        cel.ComponentCount = ComponentCount;
        cel.ValidatedCount = 0;
        cel.ComponentVector = MALLOC( ComponentCount * sizeof(DWORD));
        if (!cel.ComponentVector) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            RetVal = FALSE;
            goto e0;
        }

        RtlZeroMemory( cel.ComponentVector, ComponentCount * sizeof(DWORD));
    
        if (!SetupEnumerateRegisteredOsComponents( pComponentListValidator, (DWORD_PTR)&cel)) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }
        
        if (cel.ValidatedCount != ComponentCount) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }

        //
        // make sure that the caller is specifying the actual number of
        // registered components
        //
        if (!SetupQueryRegisteredOsComponentsOrder(&ActualComponentCount, NULL) ||
            ActualComponentCount != ComponentCount) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }

    }


    //
    // open the main component key where the component order list lives.
    //     
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &Disposition);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e1;
    }


    //
    // if the count is zero, we remove the value.
    //
    if (ComponentCount == 0) {
        rslt = RegDeleteValue(
                        hKey,
                        COMPONENT_LIST);

        SetLastError( rslt );
        RetVal = (rslt == ERROR_SUCCESS);
        goto e2;
    }

    //
    // allocate space for the string we will set in the registry
    // size = (# of components * (40 WCHAR for GuidString + 1 for NULL)
    //        +terminating NULL)
    //
    RegData = (PWSTR) MALLOC( sizeof(WCHAR) + 
                              (ComponentCount * (41*sizeof(WCHAR))) );
    if (!RegData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        RetVal = FALSE;
        goto e2;
    }

    Size = 0;
    for (Count = 0,p = RegData; Count < ComponentCount; Count++) {
    
        StringFromIID( &ComponentList[Count], &GuidString );

        wcscpy( p, GuidString );
        Size += (wcslen(p)+1)*sizeof(WCHAR);
        p += wcslen(p)+1;

        CoTaskMemFree( GuidString );

    }

    //
    // add in one more character for the double-null terminator
    //
    Size += sizeof(WCHAR);

    //
    // now set the data
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)RegData,
                    Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;        
    }

    RetVal = TRUE;

e3:
    FREE( RegData );
e2:
    RegCloseKey( hKey );
e1:
    if (cel.ComponentVector) {
        FREE( cel.ComponentVector );
    }
e0:
    return(RetVal);
}



BOOL
WINAPI
SetupSetRegisteredOsComponentsOrder(
     IN  DWORD    ComponentCount,
     IN  const LPGUID   ComponentList
    )
/*++

Routine Description:

    Allows the caller to specify the order in which components should be applied.
    
Arguments:

    ComponentCount - specifies the component order (by string GUID) in a NULL 
                     separated list
    ComponentList - specifies the number of registered components
    
    
Return Value:

    TRUE if the component order is successfully changed.

--*/
{
    return(_SetupSetRegisteredOsComponentsOrder(
                                    ComponentCount,
                                    ComponentList,
                                    TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\excppkg\test3\test.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    Simple wrapper test that executes the gui setup exception migration code.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (AndrewR) 21-Oct-1999

--*/


#include "setupp.h"
#include "setuplog.h"

BOOL
MigrateExceptionPackages(
    IN HWND hProgress,
    IN DWORD StartAtPercent,
    IN DWORD StopAtPercent
    );


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    SETUPLOG_CONTEXT lc;
    BOOL RetVal;

    InitializeSetupLog(&lc);

    RetVal = MigrateExceptionPackages(NULL,0,10);

    TerminateSetupLog(&lc);

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\makefile.inc ===
$(O)\setupreg.hiv : makefile.inc ..\mkhives.cmd ..\mkhive1.cmd ..\setupreg.ini
    cd..
    set HIVE_OUTPUT_DIR=$(HIVEDIR)\$(O)
    set MPC_VALUE=$(_MPC_VALUE)
    mkhives $(TARGET_DIRECTORY) $(HIVE_VERSION)
    cd $(MAKEDIR)

$(O)\setupupg.hiv  : $(O)\setupreg.hiv

$(O)\setupret.hiv : $(O)\setupreg.hiv

$(O)\setupret.hiv  : $(O)\setupreg.hiv

$(O)\setup2p.hiv  : $(O)\setupreg.hiv

$(O)\setup4p.hiv  : $(O)\setupreg.hiv

$(O)\setup8p.hiv  : $(O)\setupreg.hiv

$(O)\setup16p.hiv  : $(O)\setupreg.hiv

$(O)\setup32p.hiv : $(O)\setupreg.hiv

$(O)\tbomb5.hiv  : $(O)\setupreg.hiv

$(O)\tbomb15.hiv  : $(O)\setupreg.hiv

$(O)\tbomb30.hiv  : $(O)\setupreg.hiv

$(O)\tbomb60.hiv  : $(O)\setupreg.hiv

$(O)\tbomb90.hiv  : $(O)\setupreg.hiv

$(O)\tbomb120.hiv  : $(O)\setupreg.hiv

$(O)\tbomb180.hiv  : $(O)\setupreg.hiv

$(O)\tbomb240.hiv  : $(O)\setupreg.hiv

$(O)\tbomb444.hiv  : $(O)\setupreg.hiv

$(O)\tb32p444.hiv : $(O)\setupreg.hiv

$(O)\setuppupg.ini  : $(O)\setupreg.hiv

$(O)\setuppret.ini  : $(O)\setupreg.hiv

$(O)\setuppreg.ini : $(O)\setupreg.hiv

$(O)\setupp2p.ini  : $(O)\setupreg.hiv

$(O)\setupp4p.ini  : $(O)\setupreg.hiv

$(O)\setupp8p.ini  : $(O)\setupreg.hiv

$(O)\setupp16p.ini  : $(O)\setupreg.hiv

$(O)\setupp32p.ini : $(O)\setupreg.hiv

$(O)\setupptb5.ini  : $(O)\setupreg.hiv

$(O)\setupptb15.ini  : $(O)\setupreg.hiv

$(O)\setupptb30.ini  : $(O)\setupreg.hiv

$(O)\setupptb60.ini  : $(O)\setupreg.hiv

$(O)\setupptb90.ini  : $(O)\setupreg.hiv

$(O)\setupptb120.ini  : $(O)\setupreg.hiv

$(O)\setupptb150.ini  : $(O)\setupreg.hiv

$(O)\setupptb180.ini  : $(O)\setupreg.hiv

$(O)\setupptb240.ini  : $(O)\setupreg.hiv

$(O)\setupptb444.ini  : $(O)\setupreg.hiv

$(O)\setupp32ptb444.ini: $(O)\setupreg.hiv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\blade\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\enterprise\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\personal\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\retail\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\server\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\excppkg\test\test.c ===
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ole2.h>
#include <excppkg.h>

#define MYPACKAGE_GUID       L"{0e25c565-2fcc-4dcb-8e3e-4378a024c50e}"
#define PACKAGE_DIRECTORY    L"%windir%\\RegisteredPackages\\"

#define PACKAGE_CAT          L"exception.cat"
#define PACKAGE_INF          L"exception.inf"
#define PACKAGE_CAB          L"exception.cab"
        


BOOL
CALLBACK
pComponentLister(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PDWORD Count = (PDWORD) Context;
    PWSTR GuidString;

    StringFromIID(&SetupOsComponentData->ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    *Count += 1;

    CoTaskMemFree( GuidString );

    return(TRUE);
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    WCHAR Path[MAX_PATH];
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    PWSTR s,t;
    GUID MyGuid;
    PWSTR GuidString;

    WCHAR SourcePath[MAX_PATH];
    PCWSTR FileList[] = {PACKAGE_INF,PACKAGE_CAT,PACKAGE_CAB};
    #define FileListCount (sizeof(FileList)/sizeof(PCWSTR))
    DWORD i;




    
    //
    // 1. Make sure my package isn't already installed.
    //
    ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    IIDFromString( MYPACKAGE_GUID, &MyGuid);
    if (SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &ComponentData,
                                &ExceptionData)) {
        wprintf(L"My component is already registered with the OS, removing it!\n");
        if (!SetupUnRegisterOsComponent(&MyGuid)) {
            wprintf(L"couldn't remove my component, ec = %d\n", GetLastError());
            return 1;

        }        
    }
        
    //
    // 2. unregister any packages that are superceded by my package
    //

    //
    // 3. Install my package
    //
    //
    // 3a. copy my exception package to the appropriate location
    //

    //
    // 3a.1 make sure the main package directory exists
    // 
    ExpandEnvironmentStrings(
                    PACKAGE_DIRECTORY,
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

    CreateDirectory( Path, NULL );

    //
    // 3a.2 now create my package directory
    //
    wcscat( Path, MYPACKAGE_GUID );

    CreateDirectory( Path, NULL );

    
    //
    // 3a.3 now copy the bits to this location
    //
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;

    ExpandEnvironmentStrings(
                        L"%temp%\\mypackagesource\\",
                        SourcePath,
                        sizeof(SourcePath)/sizeof(WCHAR));

    s = wcsrchr( SourcePath, L'\\' );
    s += 1;
    

    for (i = 0; i < FileListCount; i++) {
        *s = '\0';
        *t = '\0';
        wcscat(s,FileList[i]);
        wcscat(t,FileList[i]);
        CopyFile(SourcePath, Path ,FALSE);
    }


    //
    // 3b. register the package
    //
    ComponentData.VersionMajor = 2;
    ComponentData.VersionMinor = 5;
    RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));
    wcscpy(ComponentData.FriendlyName, L"My Exception Package");

    wcscpy( Path, PACKAGE_DIRECTORY  );
    wcscat( Path, MYPACKAGE_GUID );
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;
    *t = '\0';
    wcscat( t, PACKAGE_INF );
    wcscpy(ExceptionData.ExceptionInfName, Path);

    *t = '\0';
    wcscat( t, PACKAGE_CAT );
    wcscpy(ExceptionData.CatalogFileName, Path);

    if (!SetupRegisterOsComponent(&ComponentData, &ExceptionData)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        return 1;
    }

    //
    // 4. retrieve my package
    //
    cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &cd,
                                &ed)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        return 1;
    }

    StringFromIID(&cd.ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             cd.FriendlyName,GuidString,cd.VersionMajor,cd.VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             ed.ExceptionInfName,ed.CatalogFileName);

    CoTaskMemFree( GuidString );

    //
    // enumerate packages
    //
    i = 0;
    if (!SetupEnumerateRegisteredOsComponents( pComponentLister, (DWORD_PTR)&i)) {
        wprintf( L"Failed to enumerate components, ec = %d\n", GetLastError() );
        return 1;
    }

    wprintf( L"Done (%d enumerated components)!!!\n", i );
    return 0;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\excppkg\test2\test.c ===
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ole2.h>
#include <excppkg.h>

#define PACKAGE_DIRECTORY    L"%windir%\\RegisteredPackages\\"

       
BOOL
CALLBACK
pComponentLister(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PDWORD Count = (PDWORD) Context;
    PWSTR GuidString;

    StringFromIID(&SetupOsComponentData->ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    *Count += 1;

    CoTaskMemFree( GuidString );

    return(TRUE);
}

VOID
Usage(
    VOID
    )
{
    wprintf(L"test <infname>\n");
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    WCHAR Path[MAX_PATH];
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    PWSTR s,t;
    GUID MyGuid;
    PCWSTR GuidString;
    PWSTR AGuidString;
    DWORD VersionInInf, RegisteredVersion;
    BOOL ForcePackageUninstall;

    WCHAR SourcePath[MAX_PATH];
    DWORD i;
    PCSTR InfName;
    PCWSTR InfSrcPath,FriendlyName;
    PCWSTR PackageCatName, PackageInfName;
    HINF hInf;
    INFCONTEXT Context;
    HSPFILEQ hFileQueue;
    PVOID QueueContext;
    
    if (argc < 2)  {
        wprintf(L"Missing arguments!\n");
        Usage();
        return 1;
    }

    InfName = argv[1];

    ForcePackageUninstall = (argc == 3);

    hInf = SetupOpenInfFileA( InfName, NULL, INF_STYLE_WIN4, NULL );
    if (hInf == INVALID_HANDLE_VALUE) {
        wprintf(L"Couldn't open inf, ec = %x\n", GetLastError());
        Usage();
        return 1;
    }

    if (!SetupFindFirstLine(hInf, 
                       L"Version", 
                       L"ComponentId",
                       &Context)) {
        wprintf(L"Couldn't find ComponentId in inf, ec = %x\n", GetLastError());
        SetupCloseInfFile( hInf );
        Usage();
        return 1;
    }

    GuidString = pSetupGetField( &Context, 1);

    if (!SetupFindFirstLine(hInf, 
                       L"Version", 
                       L"ComponentVersion",
                       &Context)) {
        wprintf(L"Couldn't find ComponentVersion in inf, ec = %x\n", GetLastError());
        SetupCloseInfFile( hInf );
        Usage();
        return 1;
    }

    SetupGetIntField( &Context, 1, &VersionInInf);

    SetupFindFirstLine(hInf, L"DefaultInstall", L"InfName", &Context);
    PackageInfName = pSetupGetField( &Context, 1);
    SetupFindFirstLine(hInf, L"DefaultInstall", L"CatalogName", &Context);
    PackageCatName = pSetupGetField( &Context, 1);
    
    
    //
    // 1. Make sure my package isn't already installed.
    //
    ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    IIDFromString( (PWSTR)GuidString, &MyGuid);
    if (SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &ComponentData,
                                &ExceptionData)) {
        wprintf(L"My component is already registered with the OS, removing it!\n");
        //
        // 2. unregister any packages that are superceded by my package
        //
        RegisteredVersion = MAKELONG( 
                                ComponentData.VersionMajor, 
                                ComponentData.VersionMinor );

        if (RegisteredVersion < VersionInInf || ForcePackageUninstall) {

            if (!SetupUnRegisterOsComponent(&MyGuid)) {
                SetupCloseInfFile( hInf );
                wprintf(L"couldn't remove my component, ec = %d\n", GetLastError());
                return 1;
    
            }        

        }
    }
        
    

    //
    // 3. Install my package
    //
    //
    // 3a. copy my exception package to the appropriate location
    //

    //
    // 3a.1 make sure the main package directory exists
    // 
    ExpandEnvironmentStrings(
                    PACKAGE_DIRECTORY,
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

    CreateDirectory( Path, NULL );

    //
    // 3a.2 now create my package directory
    //
    wcscat( Path, GuidString );

    CreateDirectory( Path, NULL );

    if (!SetupFindFirstLine(hInf, L"DefaultInstall", L"InstallSource", &Context)) {
        wprintf(L"Couldn't find InstallSource in INF\n");
        SetupCloseInfFile( hInf );
        return 1;
    }

    InfSrcPath = pSetupGetField( &Context, 1);
    ExpandEnvironmentStrings(InfSrcPath,SourcePath,sizeof(SourcePath)/sizeof(WCHAR));


    hFileQueue = SetupOpenFileQueue();
    QueueContext = SetupInitDefaultQueueCallbackEx( NULL, INVALID_HANDLE_VALUE, 0, 0, NULL);
    SetupSetDirectoryId(hInf, DIRID_USER, Path);

    if (!SetupInstallFilesFromInfSection( 
                            hInf, 
                            NULL, 
                            hFileQueue, 
                            L"DefaultInstall",
                            SourcePath,
                            SP_COPY_NEWER)) {
        wprintf(L"failed to SetupInstallFilesFromInfSection, ec = %x\n", GetLastError()); 
        SetupCloseFileQueue(hFileQueue);
        SetupTermDefaultQueueCallback( QueueContext );
        SetupCloseInfFile( hInf );
        return 1;
    }

    if (!SetupCommitFileQueue(NULL, hFileQueue, SetupDefaultQueueCallback, QueueContext)) {
        wprintf(L"failed to SetupCommitFileQueue, ec = %x\n", GetLastError());
        SetupCloseFileQueue(hFileQueue);
        SetupTermDefaultQueueCallback( QueueContext );
        SetupCloseInfFile( hInf );
        return 1;
    }

    SetupCloseFileQueue(hFileQueue);
    SetupTermDefaultQueueCallback( QueueContext );

    SetupFindFirstLine(hInf, L"Version", L"FriendlyName", &Context);
    FriendlyName = pSetupGetField( &Context, 1);

    
    //
    // 3b. register the package
    //
    ComponentData.VersionMajor = HIWORD(VersionInInf);
    ComponentData.VersionMinor = LOWORD(VersionInInf);
    RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));
    wcscpy(ComponentData.FriendlyName, FriendlyName);

    wcscpy( Path, PACKAGE_DIRECTORY  );
    wcscat( Path, GuidString );
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;
    *t = '\0';
    wcscat( t, PackageInfName );
    wcscpy(ExceptionData.ExceptionInfName, Path);

    *t = '\0';
    wcscat( t, PackageCatName );
    wcscpy(ExceptionData.CatalogFileName, Path);

    if (!SetupRegisterOsComponent(&ComponentData, &ExceptionData)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    //
    // 4. retrieve my package
    //
    cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &cd,
                                &ed)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    StringFromIID(&cd.ComponentGuid, &AGuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             cd.FriendlyName,AGuidString,cd.VersionMajor,cd.VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             ed.ExceptionInfName,ed.CatalogFileName);

    CoTaskMemFree( AGuidString );

    //
    // enumerate packages
    //
    i = 0;
    if (!SetupEnumerateRegisteredOsComponents( pComponentLister, (DWORD_PTR)&i)) {
        wprintf( L"Failed to enumerate components, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    wprintf( L"Done (%d enumerated components)!!!\n", i );
    SetupCloseInfFile( hInf );
    return 0;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\smallbiz\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\datacenter\makefile.inc ===
!include ..\makefile.inc

$(O)\setup64p.hiv : $(O)\setupreg.hiv

$(O)\tb64p444.hiv : $(O)\setupreg.hiv

$(O)\setupp64p.ini : $(O)\setupreg.hiv

$(O)\setupp64ptb444.ini: $(O)\setupreg.hiv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hives\sources.inc ===
# Each hive dir has to serialize on the prior one since only one instance
# of hiveini can run at a time
SYNCHRONIZE_BLOCK=1

NTTARGETFILE0=$(O)\setupreg.hiv

HIVE_FILES= \
    $(O)\setupreg.hiv  \
    $(O)\setupupg.hiv  \
    $(O)\setupret.hiv \
    $(O)\setupret.hiv  \
    $(O)\setup2p.hiv  \
    $(O)\setup4p.hiv  \
    $(O)\setup8p.hiv  \
    $(O)\setup16p.hiv  \
    $(O)\setup32p.hiv \
    $(O)\tbomb5.hiv  \
    $(O)\tbomb15.hiv  \
    $(O)\tbomb30.hiv  \
    $(O)\tbomb60.hiv  \
    $(O)\tbomb90.hiv  \
    $(O)\tbomb120.hiv  \
    $(O)\tbomb180.hiv  \
    $(O)\tbomb240.hiv  \
    $(O)\tbomb444.hiv  \
    $(O)\tb32p444.hiv \
    $(O)\setupp.ini  \
    $(O)\setuppv.ini  \
    $(O)\setuppupg.ini  \
    $(O)\setuppret.ini  \
    $(O)\setuppreg.ini \
    $(O)\setupp2p.ini  \
    $(O)\setupp4p.ini  \
    $(O)\setupp8p.ini  \
    $(O)\setupp16p.ini  \
    $(O)\setupp32p.ini \
    $(O)\setupptb5.ini  \
    $(O)\setupptb15.ini  \
    $(O)\setupptb30.ini  \
    $(O)\setupptb60.ini  \
    $(O)\setupptb90.ini  \
    $(O)\setupptb120.ini  \
    $(O)\setupptb150.ini  \
    $(O)\setupptb180.ini  \
    $(O)\setupptb240.ini  \
    $(O)\setupptb444.ini  \
    $(O)\setupp32ptb444.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\dllentry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    Module's entry points.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/

#include "pch.h"


//
// Implementation
//

//static CRITICAL_SECTION g_csHw;


BOOL
WINAPI
HwdbInitializeA (
    IN      PCSTR TempDir
    )
{
    BOOL b;

    DEBUGMSG ((DBG_VERBOSE, "HwdbInitializeA(%s): entering (TID=%u)", TempDir, GetCurrentThreadId ()));
//  EnterCriticalSection (&g_csHw);

    b = HwdbpInitialize (TempDir);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbInitializeA: leaving (b=%u, rc=%u)", b, GetLastError ()));

    return b;
}


BOOL
WINAPI
HwdbInitializeW (
    IN      PCWSTR TempDir
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiSz (TempDir);

    DEBUGMSG ((DBG_VERBOSE, "HwdbInitializeW(%s): entering (TID=%u)", TempDir, GetCurrentThreadId ()));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpInitialize (ansi);

//  LeaveCriticalSection (&g_csHw);

    FreeString (ansi);
    DEBUGMSG ((DBG_VERBOSE, "HwdbInitializeW: leaving (b=%u, rc=%u)", b, GetLastError ()));

    return b;
}


VOID
WINAPI
HwdbTerminate (
    VOID
    )
{
//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((DBG_VERBOSE, "HwdbTerminate(): entering (TID=%u)", GetCurrentThreadId ()));
    HwdbpTerminate ();
    DEBUGMSG ((DBG_VERBOSE, "HwdbTerminate(): leaving"));

//  LeaveCriticalSection (&g_csHw);
}


HANDLE
WINAPI
HwdbOpenA (
    IN      PCSTR DatabaseFile     OPTIONAL
    )
{
    PHWDB p;

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((DBG_VERBOSE, "HwdbOpenA(%s): entering (TID=%u)", DatabaseFile, GetCurrentThreadId ()));
    p = HwdbpOpen (DatabaseFile);
    DEBUGMSG ((DBG_VERBOSE, "HwdbOpenA: leaving (p=%p, rc=%u)", p, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);

    return (HANDLE)p;
}


HANDLE
WINAPI
HwdbOpenW (
    IN      PCWSTR DatabaseFile     OPTIONAL
    )
{
    PHWDB p;
    PCSTR ansi = ConvertToAnsiSz (DatabaseFile);

    DEBUGMSG ((DBG_VERBOSE, "HwdbInitializeW(%s): entering (TID=%u)", DatabaseFile, GetCurrentThreadId ()));

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((DBG_VERBOSE, "HwdbOpenW(%s): entering (TID=%u)", DatabaseFile, GetCurrentThreadId ()));
    p = HwdbpOpen (ansi);
    DEBUGMSG ((DBG_VERBOSE, "HwdbOpenW: leaving (p=%p, rc=%u)", p, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);
    FreeString (ansi);

    return (HANDLE)p;
}


VOID
WINAPI
HwdbClose (
    IN      HANDLE Hwdb
    )
{
//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((DBG_VERBOSE, "HwdbClose(%p): entering (TID=%u)", Hwdb, GetCurrentThreadId ()));
    HwdbpClose ((PHWDB)Hwdb);
    DEBUGMSG ((DBG_VERBOSE, "HwdbClose: leaving (rc=%u)", GetLastError ()));

//  LeaveCriticalSection (&g_csHw);
}


BOOL
WINAPI
HwdbAppendInfsA (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    )
{
    BOOL b;

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbAppendInfsA(%p,%s): entering (TID=%u)",
        Hwdb,
        SourceDirectory,
        GetCurrentThreadId ()
        ));
    b = HwdbpAppendInfs ((PHWDB)Hwdb, SourceDirectory, Callback, CallbackContext, FALSE);
    DEBUGMSG ((DBG_VERBOSE, "HwdbAppendInfsA: leaving (b=%u,rc=%u)", b, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);

    return b;
}

BOOL
WINAPI
HwdbAppendInfsW (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiSz (SourceDirectory);

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbAppendInfsW(%p,%s): entering (TID=%u)",
        Hwdb,
        SourceDirectory,
        GetCurrentThreadId ()
        ));
    b = HwdbpAppendInfs ((PHWDB)Hwdb, ansi, (HWDBAPPENDINFSCALLBACKA)Callback, CallbackContext, TRUE);
    DEBUGMSG ((DBG_VERBOSE, "HwdbAppendInfsW: leaving (b=%u,rc=%u)", b, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);
    FreeString (ansi);

    return b;
}

BOOL
WINAPI
HwdbAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    )
{
    BOOL b;

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbAppendDatabase(%p,%p): entering (TID=%u)",
        HwdbTarget,
        HwdbSource
        ));
    b = HwdbpAppendDatabase ((PHWDB)HwdbTarget, (PHWDB)HwdbSource);
    DEBUGMSG ((DBG_VERBOSE, "HwdbAppendDatabase: leaving (b=%u,rc=%u)", b, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);

    return b;
}

BOOL
WINAPI
HwdbFlushA (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    )
{
    BOOL b;

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbFlushA(%p,%s): entering (TID=%u)",
        Hwdb,
        OutputFile,
        GetCurrentThreadId ()
        ));
    b = HwdbpFlush ((PHWDB)Hwdb, OutputFile);
    DEBUGMSG ((DBG_VERBOSE, "HwdbFlushA: leaving (b=%u,rc=%u)", b, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);

    return b;
}

BOOL
WINAPI
HwdbFlushW (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiSz (OutputFile);

//  EnterCriticalSection (&g_csHw);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbFlushW(%p,%s): entering (TID=%u)",
        Hwdb,
        OutputFile,
        GetCurrentThreadId ()
        ));
    b = HwdbpFlush ((PHWDB)Hwdb, ansi);
    DEBUGMSG ((DBG_VERBOSE, "HwdbFlushW: leaving (b=%u,rc=%u)", b, GetLastError ()));

//  LeaveCriticalSection (&g_csHw);
    FreeString (ansi);

    return b;
}


BOOL
WINAPI
HwdbHasDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbHasDriverA(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpId,
        Unsupported,
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpHasDriver ((PHWDB)Hwdb, PnpId, Unsupported);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbHasDriverA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbHasDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiSz (PnpId);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbHasDriverW(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpId,
        Unsupported,
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpHasDriver ((PHWDB)Hwdb, ansi, Unsupported);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbHasDriverW: leaving (b=%u,rc=%u)", b, GetLastError ()));
    FreeString (ansi);

    return b;
}


BOOL
WINAPI
HwdbHasAnyDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbHasAnyDriverA(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpIds,
        Unsupported,
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpHasAnyDriver ((PHWDB)Hwdb, PnpIds, Unsupported);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbHasAnyDriverA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbHasAnyDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpIds,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiMultiSz (PnpIds);

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbHasAnyDriverW(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpIds,
        Unsupported,
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpHasAnyDriver ((PHWDB)Hwdb, ansi, Unsupported);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbHasAnyDriverW: leaving (b=%u,rc=%u)", b, GetLastError ()));
    FreeString (ansi);

    return b;
}

#if 0

BOOL
HwdbEnumeratePnpIdA (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    )
{
    BOOL b;

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbEnumeratePnpIdA: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpEnumeratePnpIdA ((PHWDB)Hwdb, EnumCallback, UserContext);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbEnumeratePnpIdA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
HwdbEnumeratePnpIdW (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    )
{
    BOOL b;

    DEBUGMSG ((
        DBG_VERBOSE,
        "HwdbEnumeratePnpIdW: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

//  EnterCriticalSection (&g_csHw);

    b = HwdbpEnumeratePnpIdW ((PHWDB)Hwdb, EnumCallback, UserContext);

//  LeaveCriticalSection (&g_csHw);
    DEBUGMSG ((DBG_VERBOSE, "HwdbEnumeratePnpIdW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}
#endif

BOOL
HwdbEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    BOOL b;

    b = HwdbpEnumFirstInfA (EnumPtr, DatabaseFile);

    return b;
}

BOOL
HwdbEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCWSTR DatabaseFile
    )
{
    BOOL b;
    PCSTR ansi = ConvertToAnsiSz (DatabaseFile);

    b = HwdbpEnumFirstInfW (EnumPtr, ansi);

    FreeString (ansi);

    return b;
}

BOOL
HwdbEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    BOOL b;
    b = HwdbpEnumNextInfA (EnumPtr);
    return b;
}

BOOL
HwdbEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    BOOL b;
    b = HwdbpEnumNextInfW (EnumPtr);
    return b;
}

VOID
HwdbAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    HwdbpAbortEnumInfA (EnumPtr);
}

VOID
HwdbAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    HwdbpAbortEnumInfW (EnumPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\pch.h ===
#include "baseinc.h"
#include "hwdb.h"
#include "hwdbp.h"
#include "util.h"
#include <infstr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\hwdb.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwdb.c

Abstract:

    PNP device manipulation routines.
    Adapted from the win95upg project.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/


#include "pch.h"

#define DBG_HWDB    "Hwdb"

static HANDLE g_hHeap = NULL;
static PCSTR g_TempDir = NULL;

#define HWCOMPDAT_SIGNATURE     "HwCompDat-v2"
#define MAX_PNPID               1024

#ifdef DEBUG
extern BOOL g_DoLog;
extern BOOL g_ResetLog;
#endif

typedef struct {
    HANDLE File;
    HASHITEM InfFileOffset;
    BOOL UnsupportedDevice;
    PHWDB Hwbd;
} SAVE_ENUM_PARAMS, *PSAVE_ENUM_PARAMS;


//
// REM - g_ExcludedInfs was removed because hwdb will be used for any 3rd party driver files
// and we need to make suer ALL infs are scanned
//

//
// Implementation
//

BOOL
HwdbpInitialize (
    IN      PCSTR TempDir
    )
{
    BOOL b = TRUE;

    //
    // only initialize data once
    //
    if (g_hHeap) {
        DEBUGMSG ((
            DBG_WARNING,
            "HwdbpInitialize: called when the module was already initialized - this call will be ignored"
            ));
        return TRUE;
    }

    g_hHeap = HeapCreate (0, 65536, 0);
    if (!g_hHeap) {
        b = FALSE;
    }

    if (b) {
#ifdef DEBUG
        g_DoLog = TRUE;
        g_ResetLog = TRUE;
#endif
        UtInitialize (g_hHeap);
        if (TempDir) {
            g_TempDir = DuplicateText (TempDir);
            if (g_TempDir == NULL) {
                b = FALSE;
            }
        }
    }

    if (!b) {
        HwdbpTerminate ();
    }

    return b;
}


VOID
HwdbpTerminate (
    VOID
    )
{
    if (g_TempDir) {
        FreeText (g_TempDir);
        g_TempDir = NULL;
    }

    UtTerminate ();

    if (g_hHeap) {
        HeapDestroy (g_hHeap);
        g_hHeap = NULL;
    }
}


BOOL
pReadDword (
    IN      HANDLE File,
    OUT     PDWORD Data
    )

/*++

Routine Description:

  pReadDword reads the next DWORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receives the DWORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesRead;

    return ReadFile (File, Data, sizeof (DWORD), &BytesRead, NULL) &&
           BytesRead == sizeof (DWORD);
}


BOOL
pReadWord (
    IN      HANDLE File,
    OUT     PWORD Data
    )

/*++

Routine Description:

  pReadWord reads the next WORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receive s the WORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;

    return ReadFile (File, Data, sizeof (WORD), &BytesRead, NULL) &&
           BytesRead == sizeof (WORD);
}


BOOL
pReadString (
    IN      HANDLE File,
    OUT     PTSTR Buf,
    IN      DWORD BufSizeInBytes
    )

/*++

Routine Description:

  pReadString reads a WORD length from File, and then reads in the
  string from File.

Arguments:

  File - Specifies file to read

  Buf - Receives the zero-terminated string

  BufSizeInBytes - Specifies the size of Buf in bytes

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  This function will fail if the string is larger than Buf.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;
    WORD Length;

    MYASSERT (BufSizeInBytes);
    if (!BufSizeInBytes) {
        return FALSE;
    }

    if (!pReadWord (File, &Length)) {
        return FALSE;
    }

    if ((Length + 1 ) * sizeof (CHAR) > BufSizeInBytes) {
        return FALSE;
    }

    if (Length) {
        if (!ReadFile (File, Buf, Length, &BytesRead, NULL) ||
            Length != BytesRead
            ) {
            return FALSE;
        }
    }

    Buf[Length] = 0;

    return TRUE;
}


BOOL
pWriteDword (
    IN      HANDLE File,
    IN      DWORD Val
    )

/*++

Routine Description:

  pWriteDword writes the specified DWORD value to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD bytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &bytesWritten, NULL) &&
           bytesWritten == sizeof (Val);
}


BOOL
pWriteWord (
    IN      HANDLE File,
    IN      WORD Val
    )

/*++

Routine Description:

  pWriteWord writes the specified WORD vlue to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD bytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &bytesWritten, NULL) &&
           bytesWritten == sizeof (Val);
}


BOOL
pWriteString (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  pWriteString writes a string to a File

Arguments:

  File - Specifies file to write to

  String - Specifies the zero-terminated string

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/
{
    DWORD bytesWritten;
    DWORD Length;
    PCSTR End;
    BOOL b = TRUE;

    Length = lstrlen (String);

    if (Length > 0xffff) {
        SetLastError (ERROR_INTERNAL_ERROR);
        DEBUGMSG ((DBG_ERROR, "pWriteString: string too long!"));
        return FALSE;
    }

    b = pWriteWord (File, (WORD)Length);

    if (b && Length) {
        b = WriteFile (File, String, Length, &bytesWritten, NULL) &&
            Length == bytesWritten;
    }

    return b;
}


PHWDB
HwdbpOpen (
    IN      PCSTR DatabaseFile     OPTIONAL
    )
{
    CHAR buffer[MAX_PATH];
    CHAR infFile[MAX_MBCHAR_PATH];
    CHAR pnpId[1024];
    CHAR sig[sizeof (HWCOMPDAT_SIGNATURE)];
    DWORD rc;
    HANDLE file = INVALID_HANDLE_VALUE;
    PHWDB phwdb;
    DWORD BytesRead;
    HASHITEM infOffset, result;
    BOOL b = FALSE;

	__try {

        phwdb = (PHWDB) MemAlloc (g_hHeap, 0, sizeof (*phwdb));
        if (!phwdb) {
			SetLastError (ERROR_NOT_ENOUGH_MEMORY);
			__leave;
        }
        ZeroMemory (phwdb, sizeof (*phwdb));

        //
        // Create hash tables
        //
        phwdb->InfFileTable = HtAlloc ();
        phwdb->PnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
        phwdb->UnsupPnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
        if (!phwdb->InfFileTable || !phwdb->PnpIdTable || !phwdb->UnsupPnpIdTable) {
            __leave;
        }

		if (DatabaseFile) {

		    if (!GetFullPathNameA (DatabaseFile, MAX_PATH, buffer, NULL)) {
			    __leave;
		    }

            //
            // Try to open the file
            //
            file = CreateFileA (
                        buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,            // share for read access
                        NULL,                       // no security attribs
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL                        // no template
                        );
            if (file == INVALID_HANDLE_VALUE) {
                __leave;
            }
            //
            // Look at the signature
            //
            ZeroMemory (sig, sizeof(sig));
            if (!ReadFile (file, sig, sizeof (HWCOMPDAT_SIGNATURE) - 1, &BytesRead, NULL) ||
                lstrcmpA (HWCOMPDAT_SIGNATURE, sig)
                ) {
                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }
            //
            // Get INF checksum
            //
            if (!pReadDword (file, &phwdb->Checksum)) {
                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }
            //
            // Read in all PNP IDs
            //
            for (;;) {
                //
                // Get INF file name.  If empty, we are done.
                //
                if (!pReadString (file, infFile, sizeof (infFile))) {
                    SetLastError (ERROR_BAD_FORMAT);
                    __leave;
                }
                if (*infFile == 0) {
                    break;
                }
                infOffset = HtAddString (phwdb->InfFileTable, infFile);

                //
                // Read in all PNP IDs for the INF
                //
                for (;;) {
                    //
                    // Get the PNP ID.  If empty, we are done.
                    //
                    if (!pReadString (file, pnpId, sizeof (pnpId))) {
                        SetLastError (ERROR_BAD_FORMAT);
                        __leave;
                    }
                    if (*pnpId == 0) {
                        break;
                    }
                    //
                    // Add to hash table
                    //
                    if (*pnpId == '!') {
                        result = HtAddStringEx (phwdb->UnsupPnpIdTable, pnpId + 1, &infOffset, CASE_INSENSITIVE);
                    } else {
                        result = HtAddStringEx (phwdb->PnpIdTable, pnpId, &infOffset, CASE_INSENSITIVE);
                    }
                    if (!result) {
                        __leave;
                    }
                }
            }
        }

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();

        if (file != INVALID_HANDLE_VALUE) {
            CloseHandle (file);
        }
        if (!b && phwdb) {
            if (phwdb->InfFileTable) {
                HtFree (phwdb->InfFileTable);
            }
            if (phwdb->PnpIdTable) {
                HtFree (phwdb->PnpIdTable);
            }
            if (phwdb->UnsupPnpIdTable) {
                HtFree (phwdb->UnsupPnpIdTable);
            }
            MemFree (g_hHeap, 0, phwdb);
        }

        SetLastError (rc);
    }

    return phwdb;
}

/*
BOOL
pWriteHashTableString (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    MYASSERT (String && *String);
    return pWriteString ((HANDLE)lParam, String);
}
*/

BOOL
pSavePnpID (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pSavePnpID is a string table callback function that writes a PNP
  ID to the file indicated in the params struct (the lParam argument).

  This function only writes PNP IDs for a specific INF file (indicated
  by the ExtraData arg).

Arguments:

  Table - Specifies table being enumerated

  StringId - Specifies offset of string in Table

  String - Specifies string being enumerated

  ExtraData - Specifies a pointer to a LONG that holds the INF ID
              to enumerate.  The PNP ID's INF ID must match this
              parameter.

  lParam - Specifies a pointer to a SAVE_ENUM_PARAMS struct

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS params;
    CHAR bangString[MAX_PNPID + 2];
    BOOL b = TRUE;

    params = (PSAVE_ENUM_PARAMS) lParam;

    if (*(HASHITEM UNALIGNED*)ExtraData == params->InfFileOffset) {
        //
        // Write this PNP ID to the file
        //
        if (params->UnsupportedDevice) {

            bangString[0] = '!';
            lstrcpy (bangString + 1, String);
            b = pWriteString (params->File, bangString);

        } else {

            b = pWriteString (params->File, String);

        }
    }

    return b;
}


BOOL
pSaveInfWithPnpIDList (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pSaveInfWithPnpIDList is a string table callback function and is called for
  each INF in g_InfFileTable.

  This routine writes the name of the INF to disk, and then enumerates
  the PNP IDs for the INF, writing them to disk.

  The PNP ID list is terminated with an empty string.

Arguments:

  Table - Specifies g_InfFileTable

  StringId - Specifies offset of String in g_InfFileTable

  String - Specifies current INF file being enumerated

  ExtraData - unused

  ExtraDataSize - unused

  lParam - Specifies a pointer to SAVE_ENUM_PARAMS struct.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS params;

    params = (PSAVE_ENUM_PARAMS) lParam;
    params->InfFileOffset = StringId;

    //
    // Save the file name
    //

    if (!pWriteString (params->File, String)) {
        return FALSE;
    }

    //
    // Enumerate all PNP IDs
    //

    params->UnsupportedDevice = FALSE;

    if (!EnumHashTableWithCallback (params->Hwbd->PnpIdTable, pSavePnpID, lParam)) {
        LOG ((LOG_ERROR, "Error while saving device list."));
        return FALSE;
    }

    params->UnsupportedDevice = TRUE;

    if (!EnumHashTableWithCallback (params->Hwbd->UnsupPnpIdTable, pSavePnpID, lParam)) {
        LOG ((LOG_ERROR, "Error while saving device list. (2)"));
        return FALSE;
    }

    //
    // Terminate the PNP ID list
    //

    if (!pWriteString (params->File, "")) {
        return FALSE;
    }

    return TRUE;
}


BOOL
HwdbpFlush (
    IN      PHWDB Hwdb,
    IN      PCSTR OutputFile
    )
{
    CHAR buffer[MAX_PATH];
    DWORD rc;
    HANDLE file = INVALID_HANDLE_VALUE;
    DWORD bytesWritten;
    SAVE_ENUM_PARAMS params;
    BOOL b = FALSE;

	__try {
		if (!OutputFile) {
			SetLastError (ERROR_INVALID_PARAMETER);
			__leave;
		}

		if (!GetFullPathNameA (OutputFile, MAX_PATH, buffer, NULL)) {
			__leave;
		}

        //
        // Try to open the file
        //
        file = CreateFileA (
                    OutputFile,
                    GENERIC_WRITE,
                    0,                          // no sharing
                    NULL,                       // no security attribs
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL                        // no template
                    );
        if (file == INVALID_HANDLE_VALUE) {
            __leave;
        }
        //
        // Write the signature
        //
        if (!WriteFile (file, HWCOMPDAT_SIGNATURE, sizeof (HWCOMPDAT_SIGNATURE) - 1, &bytesWritten, NULL)) {
            __leave;
        }
        //
        // Store INF checksum
        //
        if (!pWriteDword (file, Hwdb->Checksum)) {
            __leave;
        }

        //
        // Enumerate the INF table, writing the INF file name and all PNP IDs
        //

        params.File = file;
        params.Hwbd = Hwdb;

        if (!EnumHashTableWithCallback (
                Hwdb->InfFileTable,
                pSaveInfWithPnpIDList,
                (LPARAM) (&params)
                )) {
            DEBUGMSG ((DBG_WARNING, "SaveDeviceList: EnumHashTableWithCallback returned FALSE"));
            __leave;
        }
        //
        // end with an empty string
        //
        pWriteString (file, "");

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();

        if (file != INVALID_HANDLE_VALUE) {
            CloseHandle (file);
        }
        if (!b) {
            DeleteFile (OutputFile);
        }

        SetLastError (rc);
    }

    return b;
}


BOOL
HwdbpClose (
    IN      PHWDB Hwdb
    )
{
    BOOL b = FALSE;

    __try {
        if (Hwdb) {
            if (Hwdb->InfFileTable) {
                HtFree (Hwdb->InfFileTable);
            }
            if (Hwdb->PnpIdTable) {
                HtFree (Hwdb->PnpIdTable);
            }
            if (Hwdb->UnsupPnpIdTable) {
                HtFree (Hwdb->UnsupPnpIdTable);
            }

            MemFree (g_hHeap, 0, Hwdb);

            b = TRUE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return b;
}


BOOL
HwpIsValidInfName (
    IN      PCSTR FileName,
    OUT     PTSTR UncompressedFileName,
    IN      DWORD BufferSizeInChars
    )
{
    PTSTR p;
    PCSTR* q;
    PCSTR comparationName;

    if (!FileName || *FileName == 0 || (DWORD)lstrlen (FileName) >= BufferSizeInChars) {
        MYASSERT (FALSE);
        return FALSE;
    }

    lstrcpyn (UncompressedFileName, FileName, BufferSizeInChars);
    p = _tcsdec2 (UncompressedFileName, GetEndOfString (UncompressedFileName));
    if (!p) {
        return FALSE;
    }

    if (*p == '_') {
        *p = 'f';
        comparationName = UncompressedFileName;
    } else {
        if (tolower (*p) != 'f') {
            return FALSE;
        }
        *UncompressedFileName = 0;
        comparationName = FileName;
    }

    return TRUE;
}


BOOL
HwpAddPnpIdsInInf (
    IN      PCSTR InfPath,
    IN OUT  PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      PCSTR InfFilename,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    )

/*++

Routine Description:

  HwpAddPnpIdsInInf scans an NT INF and places all hardware device
  IDs in the PNP string table.

Arguments:

  InfPath - The path to an INF file
  Hwdb - Database to append PNPIDs to

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    HINF inf;
    INFCONTEXT is;
    INFCONTEXT isMfg;
    INFCONTEXT isDev;
    CHAR Manufacturer[2048];
    CHAR DevSection[2048];
    CHAR pnpId[2048];
    BOOL UnsupportedDevice;
    PTSTR AppendPos;
    CHAR TrimmedPnpId[512];
    CHAR field[12];
    PCSTR p;
    LONG rc;
    BOOL b;
    PCTSTR fileName;
    PWSTR uInfPath = NULL;
    PWSTR uSourceDirectory = NULL;
    PWSTR uInfFilename = NULL;
    HASHITEM infOffset = NULL, result;
    BOOL Result = FALSE;

    //
    // Determine if this is an NT4 INF
    //
    inf = SetupOpenInfFile (InfPath, NULL, INF_STYLE_WIN4, NULL);
    if (inf == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "HwpAddPnpIdsInInf: SetupOpenInfFile (%s) failed", InfPath));
        return FALSE;
    }

    DEBUGMSG ((DBG_HWDB, "HwpAddPnpIdsInInf: analyzing %s", InfPath));

    __try {
        //
        // Enumerate [Manufacturer] section
        //
        if (SetupFindFirstLine (inf, "Manufacturer", NULL, &is)) {

            do  {
                //
                // Get the manufacturer name
                //
                if (!SetupGetLineText (&is, NULL, NULL, NULL, Manufacturer, 2048, NULL)) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "HwpAddPnpIdsInInf: SetupGetLineText failed at line %u in [Manufacturer]",
                        is.Line
                        ));
                    __leave;
                }
                //
                // Enumerate the devices listed in the manufacturer's section,
                // looking for PnpId
                //
                if (!SetupFindFirstLine (inf, Manufacturer, NULL, &isMfg)) {
                    rc = GetLastError();
                    //
                    // if section not found, move on to next manufacturer
                    //
                    if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                        DEBUGMSG ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: Manufacturer %s section does not exist",
                            Manufacturer
                            ));
                        continue;
                    }
                    DEBUGMSG ((
                        DBG_ERROR,
                        "HwpAddPnpIdsInInf: error searching for lines in [%s]",
                        Manufacturer
                        ));
                    __leave;
                }

                do  {
                    if (!SetupGetStringField (&isMfg, 1, DevSection, 2048, NULL)) {
                        DEBUGMSG ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: error retrieving first field in line %u in [%s]",
                            isMfg.Line,
                            DevSection
                            ));
                        continue;
                    }

                    //
                    // Try platform-specific section first, then section.NT, then section
                    //
                    AppendPos = GetEndOfString (DevSection);
#if defined _IA64_
                    wsprintf (AppendPos, TEXT(".%s"), INFSTR_PLATFORM_NTIA64);
#elif defined _X86_
                    wsprintf (AppendPos, TEXT(".%s"), INFSTR_PLATFORM_NTX86);
#endif
                    b = SetupFindFirstLine (inf, DevSection, NULL, &isDev);
                    if (!b) {
                        wsprintf (AppendPos, TEXT(".%s"), INFSTR_PLATFORM_NT);
                        b = SetupFindFirstLine (inf, DevSection, NULL, &isDev);
                        if (!b) {
                            *AppendPos = 0;
                            b = SetupFindFirstLine (inf, DevSection, NULL, &isDev);
                        }
                    }

                    UnsupportedDevice = FALSE;
                    if (b) {
                        if (SetupFindFirstLine (inf, DevSection, "DeviceUpgradeUnsupported", &isDev)) {
                            if (SetupGetStringField (&isDev, 1, field, 12, NULL)) {
                                if (_ttoi (field)) {
                                    UnsupportedDevice = TRUE;
                                }
                            }
                        }
                    } else {
                        DEBUGMSG ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: no device section [%s] for [%s]",
                            DevSection,
                            Manufacturer
                            ));
                    }

                    //
                    // Get the device id
                    //
                    if (!SetupGetMultiSzField (&isMfg, 2, pnpId, 2048, NULL)) {
                        DEBUGMSG ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: error retrieving PNPID field(s) in line %u in [%s]",
                            isMfg.Line,
                            Manufacturer
                            ));
                        continue;
                    }

                    //
                    // Add each device id to the hash table
                    //
                    p = pnpId;
                    while (*p) {
                        BOOL b = TRUE;
                        //
                        // first invoke the callback (if specified)
                        //
                        if (Callback) {
                            if (CallbackIsUnicode) {
                                PWSTR uPnpid = ConvertToUnicodeSz (p);
                                if (!uPnpid) {
                                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                                    __leave;
                                }
                                if (!uInfPath) {
                                    uInfPath = ConvertToUnicodeSz (InfPath);
                                }
                                if (!uSourceDirectory) {
                                    uSourceDirectory = ConvertToUnicodeSz (SourceDirectory);
                                }
                                if (!uInfFilename) {
                                    uInfFilename = ConvertToUnicodeSz (InfFilename);
                                }
                                b = (*(HWDBAPPENDINFSCALLBACKW)Callback) (CallbackContext, uPnpid, uInfFilename, uSourceDirectory, uInfPath);
                                FreeString (uPnpid);
                            } else {
                                b = (*Callback) (CallbackContext, p, InfFilename, SourceDirectory, InfPath);
                            }
                        }
                        if (b) {
                            //
                            // First time through add the INF file name to string table
                            //
                            if (!infOffset) {
                                if (Hwdb->InfFileTable) {
                                    fileName = _tcsrchr (InfPath, TEXT('\\')) + 1;
                                    infOffset = HtAddString (Hwdb->InfFileTable, fileName);
                                    if (!infOffset) {
                                        DEBUGMSG ((DBG_ERROR, "Cannot add %s to table of INFs.", fileName));
                                        __leave;
                                    }
                                }
                            }

                            StringCopy (TrimmedPnpId, SkipSpace (p));
                            TruncateTrailingSpace (TrimmedPnpId);

                            result = HtAddStringEx (
                                        UnsupportedDevice ? Hwdb->UnsupPnpIdTable : Hwdb->PnpIdTable,
                                        TrimmedPnpId,
                                        (PVOID)&infOffset,
                                        CASE_INSENSITIVE
                                        );

                            if (!result) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "HwpAddPnpIdsInInf: cannot add %s to table of PNP IDs",
                                    TrimmedPnpId
                                    ));
                                __leave;
                            }
                        }

                        p = GetEndOfString (p) + 1;
                    }

                } while (SetupFindNextLine (&isMfg, &isMfg));

            } while (SetupFindNextLine (&is, &is));

        } else {

            rc = GetLastError();
            //
            // If section not found, return success
            //
            if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                SetLastError (ERROR_SUCCESS);
                DEBUGMSG ((
                    DBG_HWDB,
                    "HwpAddPnpIdsInInf: %s has no [Manufacturer] section or it's empty",
                    InfPath
                    ));
            } else {
                DEBUGMSG ((
                    DBG_ERROR,
                    "HwpAddPnpIdsInInf: error trying to find the [Manufacturer] section",
                    InfPath
                    ));
                __leave;
            }
        }

        Result = TRUE;
    }
    __finally {
        PushError();
        SetupCloseInfFile (inf);
        FreeString (uInfPath);
        FreeString (uSourceDirectory);
        FreeString (uInfFilename);
        PopError();
        DEBUGMSG ((DBG_HWDB, "HwpAddPnpIdsInInf: done parsing %s", InfPath));
    }

    return Result;
}


BOOL
HwdbpAppendInfs (
    IN      PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    )
{
    HANDLE h;
    WIN32_FIND_DATA fd;
    CHAR buffer[MAX_PATH];
    CHAR uncompressedFile[MAX_PATH];
    CHAR fullPath[MAX_PATH];
    DWORD rc;

    if (_sntprintf (buffer, MAX_PATH, "%s\\*.in?", SourceDirectory) < 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((
            DBG_ERROR,
            "HwdbpAppendInfs: file name too long: %s\\*.in?",
            SourceDirectory
            ));
        return FALSE;
    }

    h = FindFirstFile (buffer, &fd);
    if (h != INVALID_HANDLE_VALUE) {
        do {
            if (!HwpIsValidInfName (fd.cFileName, buffer, MAX_PATH)) {
                continue;
            }
            if (*buffer) {
                if (_snprintf (uncompressedFile, MAX_PATH, "%s\\%s", g_TempDir, buffer) < 0) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSG ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        g_TempDir,
                        buffer
                        ));
                    continue;
                }
                if (_snprintf (fullPath, MAX_PATH, "%s\\%s", SourceDirectory, fd.cFileName) < 0) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSG ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        SourceDirectory,
                        fd.cFileName
                        ));
                    continue;
                }

                SetFileAttributes (uncompressedFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (uncompressedFile);

                rc = SetupDecompressOrCopyFile (fullPath, uncompressedFile, 0);

                if (rc != ERROR_SUCCESS) {
                    LOG ((
                        LOG_ERROR,
                        "HwdbpAppendInfs: Could not decompress %s to %s",
                        fullPath,
                        uncompressedFile
                        ));
                    continue;
                } else {
                }
            } else {
                if (_snprintf (uncompressedFile, MAX_PATH, "%s\\%s", SourceDirectory, fd.cFileName) < 0) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSG ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        g_TempDir,
                        buffer
                        ));
                    continue;
                }
            }

            if (!HwpAddPnpIdsInInf (
                    uncompressedFile,
                    Hwdb,
                    SourceDirectory,
                    *buffer ? buffer : fd.cFileName,
                    Callback,
                    CallbackContext,
                    CallbackIsUnicode
                    )) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "HwdbpAppendInfs: HwpAddPnpIdsInInf(%s) failed",
                    *buffer ? fullPath : uncompressedFile
                    ));
                continue;
            }

            if (*buffer) {
                SetFileAttributes (uncompressedFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (uncompressedFile);
            }
        } while (FindNextFile (h, &fd));

        FindClose (h);
    }

    return TRUE;
}


BOOL
pAppendToHashTable (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    MYASSERT (lParam);
    return HtAddString ((HASHTABLE)lParam, String) != NULL;
}


BOOL
HwdbpAppendDatabase (
    IN      PHWDB HwdbTarget,
    IN      PHWDB HwdbSource
    )
{
#if 0
    BOOL b = TRUE;

    if (HwdbSource->PnpIdTable) {
        if (!HwdbTarget->PnpIdTable) {
            HwdbTarget->PnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
            if (!HwdbTarget->PnpIdTable) {
                b = FALSE;
            }
        }
        if (b) {
            b = EnumHashTableWithCallback (
                    HwdbSource->PnpIdTable,
                    pAppendToHashTable,
                    HwdbTarget->PnpIdTable
                    );
        }
    }
    if (b && HwdbSource->UnsupPnpIdTable) {
        if (!HwdbTarget->UnsupPnpIdTable) {
            HwdbTarget->UnsupPnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
            if (!HwdbTarget->UnsupPnpIdTable) {
                b = FALSE;
            }
        }
        if (b) {
            b = EnumHashTableWithCallback (
                    HwdbSource->UnsupPnpIdTable,
                    pAppendToHashTable,
                    HwdbTarget->UnsupPnpIdTable
                    );
        }
    }

    return b;
#endif
    //
    // not implemented
    //
    return FALSE;
}


BOOL
HwdbpHasDriver (
    IN      PHWDB Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    )

/*++

Routine Description:

  HwdbpHasDriver determines if the PnpId is in the database

Arguments:

  Hwdb - Specifies the database to search

  PnpId - Specifies the PNPID to look for

  Unsupported - Receives TRUE if the PNPID is unsupported

Return Value:

  TRUE if the database has the PNPID

--*/

{
    if (!Hwdb || !PnpId || !Unsupported) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's unsupported first
    //
    if (HtFindString (Hwdb->UnsupPnpIdTable, PnpId)) {
        *Unsupported = TRUE;
        return TRUE;
    }

    if (!HtFindString (Hwdb->PnpIdTable, PnpId)) {
        return FALSE;
    }

    //
    // fill out info
    //
    *Unsupported = FALSE;

    return TRUE;
}


BOOL
HwdbpHasAnyDriver (
    IN      PHWDB Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    )

/*++

Routine Description:

  HwdbpHasAnyDriver determines if any PNPID from the PnpIds multisz is in the database

Arguments:

  Hwdb - Specifies the database to search

  PnpIds - Specifies the list (multisz) of PNPIDs to look for

  Unsupported - Receives TRUE if any PNPID in this list is unsupported

Return Value:

  TRUE if the database has at least one of the PNPIDs in the list

--*/

{
    BOOL bFound = FALSE;
    PCSTR pnpID;

    if (!Hwdb || !PnpIds || !Unsupported) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (pnpID = PnpIds; *pnpID; pnpID = strchr (pnpID, 0) + 1) {
        //
        // check if it's unsupported first
        //
        if (HtFindString (Hwdb->UnsupPnpIdTable, pnpID)) {
            *Unsupported = TRUE;
            return TRUE;
        }

        if (HtFindString (Hwdb->PnpIdTable, pnpID)) {
            bFound = TRUE;
        }
    }

    //
    // fill out info
    //
    *Unsupported = FALSE;

    return bFound;
}

#if 0

typedef struct {
    PHWDB Hwdb;
    PHWDBENUM_CALLBACKA EnumCallback;
    PVOID UserContext;
} HWDBENUM_DATAA, *PHWDBENUM_DATAA;

typedef struct {
    PHWDB Hwdb;
    PHWDBENUM_CALLBACKW EnumCallback;
    PVOID UserContext;
} HWDBENUM_DATAW, *PHWDBENUM_DATAW;


BOOL
pCallbackEnumA (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR PnpId,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    PHWDBENUM_DATAA ped = (PHWDBENUM_DATAA)lParam;
/*
    PPNPID_DATA data = (PPNPID_DATA)ExtraData;

    MYASSERT (ExtraDataSize == sizeof (PNPID_DATA);

    return (*ped->EnumCallback) (
                ped->UserContext,
                PnpId,
                pGetInfPath (ped->Hwdb, data->InfOffset),
                data->Flags
                );
*/
    return FALSE;
}

BOOL
HwdbpEnumeratePnpIdA (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    )
{
    HWDBENUM_DATAA ed;

    if (!Hwdb || !EnumCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ed.Hwdb = Hwdb;
    ed.EnumCallback = EnumCallback;
    ed.UserContext = UserContext;
    return EnumHashTableWithCallback (Hwdb->PnpIdTable, pCallbackEnumA, (LPARAM)&ed);
}

BOOL
pCallbackEnumW (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR PnpId,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    PHWDBENUM_DATAW ped = (PHWDBENUM_DATAW)lParam;
/*
    PPNPID_DATA data = (PPNPID_DATA)ExtraData;

    MYASSERT (ExtraDataSize == sizeof (PNPID_DATA);

    return (*ped->EnumCallback) (
                ped->UserContext,
                PnpId,
                pGetInfPath (ped->Hwdb, data->InfOffset),
                data->Flags
                );
*/
    return FALSE;
}

BOOL
HwdbpEnumeratePnpIdW (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    )
{
    HWDBENUM_DATAW ed;

    if (!Hwdb || !EnumCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ed.Hwdb = Hwdb;
    ed.EnumCallback = EnumCallback;
    ed.UserContext = UserContext;
    return EnumHashTableWithCallback (Hwdb->PnpIdTable, pCallbackEnumW, (LPARAM)&ed);
}

#endif


BOOL
HwdbpEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    CHAR buffer[MAX_PATH];
    CHAR sig[sizeof (HWCOMPDAT_SIGNATURE)];
    DWORD checksum;
    DWORD rc;
    DWORD BytesRead;
    HASHITEM infOffset;
    PHWDBINF_ENUM_INTERNAL pei;

	if (!DatabaseFile || !EnumPtr) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	if (!GetFullPathNameA (DatabaseFile, MAX_PATH, buffer, NULL)) {
        return FALSE;
	}

    EnumPtr->Internal = (PHWDBINF_ENUM_INTERNAL) MemAlloc (g_hHeap, 0, sizeof (HWDBINF_ENUM_INTERNAL));
    if (!EnumPtr->Internal) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
    ZeroMemory (EnumPtr->Internal, sizeof (HWDBINF_ENUM_INTERNAL));
    pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;

    //
    // Try to open the file
    //
    pei->File = CreateFileA (
                        buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,            // share for read access
                        NULL,                       // no security attribs
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL                        // no template
                        );
    if (pei->File == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Look at the signature
    //
    ZeroMemory (sig, sizeof(sig));
    if (!ReadFile (pei->File, sig, sizeof (HWCOMPDAT_SIGNATURE) - 1, &BytesRead, NULL) ||
        lstrcmpA (HWCOMPDAT_SIGNATURE, sig)
        ) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }

    //
    // Get INF checksum
    //
    if (!pReadDword (pei->File, &checksum)) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }
    //
    // Read in all PNP IDs
    //
    return HwdbpEnumNextInfA (EnumPtr);

exit:
    HwdbpAbortEnumInfA (EnumPtr);
    return FALSE;
}


BOOL
HwdbpEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    HWDBINF_ENUMA ea;

    if (!HwdbpEnumFirstInfA (&ea, DatabaseFile)) {
        return FALSE;
    }
    EnumPtr->Internal = ea.Internal;
    EnumPtr->InfFile = ConvertToUnicodeSz (ea.InfFile);
    EnumPtr->PnpIds = ConvertToUnicodeMultiSz (ea.PnpIds);
    if (EnumPtr->InfFile && EnumPtr->PnpIds) {
        return TRUE;
    }
    HwdbpAbortEnumInfW (EnumPtr);
    return FALSE;
}


BOOL
HwdbpEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    CHAR pnpId[1024];
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;

    //
    // Get next INF file name.  If empty, we are done.
    //
    if (!pReadString (pei->File, EnumPtr->InfFile, sizeof (EnumPtr->InfFile))) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }
    if (EnumPtr->InfFile[0] == 0) {
        SetLastError (ERROR_SUCCESS);
        goto exit;
    }

    //
    // Read in all PNP IDs for the INF
    //
    for (;;) {
        //
        // Get the PNP ID.  If empty, we are done.
        //
        if (!pReadString (pei->File, pnpId, sizeof (pnpId))) {
            SetLastError (ERROR_BAD_FORMAT);
            goto exit;
        }
        if (*pnpId == 0) {
            break;
        }

        if (!GbMultiSzAppendA (&pei->GrowBuf, pnpId)) {
            SetLastError (ERROR_OUTOFMEMORY);
            goto exit;
        }
    }

    EnumPtr->PnpIds = (PCSTR)pei->GrowBuf.Buf;

    return TRUE;

exit:
    HwdbpAbortEnumInfA (EnumPtr);
    return FALSE;
}

BOOL
HwdbpEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    HWDBINF_ENUMA ea;

    ea.Internal = EnumPtr->Internal;

    if (!HwdbpEnumNextInfA (&ea)) {
        return FALSE;
    }
    EnumPtr->InfFile = ConvertToUnicodeSz (ea.InfFile);
    EnumPtr->PnpIds = ConvertToUnicodeMultiSz (ea.PnpIds);
    if (EnumPtr->InfFile && EnumPtr->PnpIds) {
        return TRUE;
    }
    HwdbpAbortEnumInfW (EnumPtr);
    return FALSE;
}

VOID
HwdbpAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;
    DWORD rc = GetLastError ();

    if (pei) {
        if (pei->File != INVALID_HANDLE_VALUE) {
            CloseHandle (pei->File);
            pei->File = INVALID_HANDLE_VALUE;
        }
        GbFree (&pei->GrowBuf);
    }

    SetLastError (rc);
}


VOID
HwdbpAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;
    DWORD rc = GetLastError ();

    if (EnumPtr->InfFile) {
        FreeString (EnumPtr->InfFile);
        EnumPtr->InfFile = NULL;
    }
    if (EnumPtr->PnpIds) {
        FreeString (EnumPtr->PnpIds);
        EnumPtr->PnpIds = NULL;
    }
    if (pei) {
        if (pei->File != INVALID_HANDLE_VALUE) {
            CloseHandle (pei->File);
            pei->File = INVALID_HANDLE_VALUE;
        }
        GbFree (&pei->GrowBuf);
    }

    SetLastError (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\util.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Utility functions.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/


VOID
FreeString (
    IN      PCVOID String
    );

PSTR
ConvertToAnsiSz (
    IN      PCWSTR Unicode
    );

PSTR
ConvertToAnsiMultiSz (
    IN      PCWSTR MultiSzUnicode
    );


PWSTR
ConvertToUnicodeSz (
    IN      PCSTR Ansi
    );

PWSTR
ConvertToUnicodeMultiSz (
    IN      PCSTR MultiSzAnsi
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\util.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/

#include "pch.h"


VOID
FreeString (
    IN      PVOID String
    )
{
    if (String) {
        HeapFree (GetProcessHeap (), 0, String);
    }
}

PSTR
pAllocAndConvertToAnsi (
    IN      PCWSTR Unicode,
    IN      DWORD Size
    )
{
    PSTR ansi;

    ansi = (PSTR) HeapAlloc (GetProcessHeap (), 0, Size);
    if (!ansi) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            Unicode,
            Size,
            ansi,
            Size * sizeof (WCHAR),
            NULL,
            NULL
            )) {
        FreeString (ansi);
        return NULL;
    }

    return ansi;
}


PSTR
ConvertToAnsiSz (
    IN      PCWSTR Unicode
    )
{
    DWORD size;

    if (!Unicode) {
        SetLastError (ERROR_SUCCESS);
        return NULL;
    }

    size = lstrlenW (Unicode) + 1;

    return pAllocAndConvertToAnsi (Unicode, size);
}

PSTR
ConvertToAnsiMultiSz (
    IN      PCWSTR MultiSzUnicode
    )
{
    DWORD size;
    PCWSTR p;

    if (!MultiSzUnicode) {
        SetLastError (ERROR_SUCCESS);
        return NULL;
    }

    for (size = 1, p = MultiSzUnicode; *p; p = wcschr (p, 0) + 1) {
        size += lstrlenW (p) + 1;
    }

    return pAllocAndConvertToAnsi (MultiSzUnicode, size);
}


PWSTR
pAllocAndConvertToUnicode (
    IN      PCSTR Ansi,
    IN      DWORD Size
    )
{
    PWSTR unicode;

    unicode = (PWSTR) HeapAlloc (GetProcessHeap (), 0, Size * sizeof (WCHAR));
    if (!unicode) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    if (!MultiByteToWideChar (
            CP_ACP,
            0,
            Ansi,
            Size,
            unicode,
            Size
            )) {
        FreeString (unicode);
        unicode = NULL;
    }

    return unicode;
}


PWSTR
ConvertToUnicodeSz (
    IN      PCSTR Ansi
    )
{
    DWORD size;

    if (!Ansi) {
        SetLastError (ERROR_SUCCESS);
        return NULL;
    }

    size = lstrlenA (Ansi) + 1;

    return pAllocAndConvertToUnicode (Ansi, size);
}

PWSTR
ConvertToUnicodeMultiSz (
    IN      PCSTR MultiSzAnsi
    )
{
    DWORD size;
    PCSTR p;

    if (!MultiSzAnsi) {
        SetLastError (ERROR_SUCCESS);
        return NULL;
    }

    for (size = 1, p = MultiSzAnsi; *p; p = _mbschr (p, 0) + 1) {
        size += lstrlenA (p) + 1;
    }

    return pAllocAndConvertToUnicode (MultiSzAnsi, size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\hwdbp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwdbp.h

Abstract:

    Module's private definitions.

Author:

    Ovidiu Temereanca (ovidiut) 11-Jul-2000  Initial implementation

Revision History:

--*/

typedef struct {
    HASHTABLE InfFileTable;
    HASHTABLE PnpIdTable;
    HASHTABLE UnsupPnpIdTable;
    DWORD Checksum;
} HWDB, *PHWDB;


BOOL
HwdbpInitialize (
    IN      PCSTR TempDir
    );

VOID
HwdbpTerminate (
    VOID
    );

PHWDB
HwdbpOpen (
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpClose (
    IN      HANDLE Hwdb
    );

BOOL
HwdbpAppendInfs (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    );

BOOL
HwdbpAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

BOOL
HwdbpFlush (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

BOOL
HwdbpHasDriver (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
HwdbpHasAnyDriver (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    );

BOOL
HwpAddPnpIdsInInf (
    IN      PCSTR InfPath,
    IN OUT  PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      PCSTR InfFilename,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    );

#if 0

BOOL
HwdbpEnumeratePnpIdA (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

BOOL
HwdbpEnumeratePnpIdW (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

#endif

typedef struct {
    HANDLE File;
    GROWBUFFER GrowBuf;
} HWDBINF_ENUM_INTERNAL, *PHWDBINF_ENUM_INTERNAL;


BOOL
HwdbpEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

BOOL
HwdbpEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

VOID
HwdbpAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

VOID
HwdbpAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\inc\allutils.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    allutils.h

Abstract:

    Includes all header files necessary to use the libraries generated under the
    utils directory. Declares many macros and MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    marcw 2-Sep-1999 Ported over from win95upg project (migutil.h) Needs lots of cleanup.

--*/

#pragma once

//
// Includes
//

#include "utiltypes.h"
#include "main.h"
#include "dbgtrack.h"
#include "basemem.h"
#include "log.h"
#include "growbuf.h"
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "version.h"
#include "unicode.h"
#include "hash.h"
#include "basefile.h"
#include "memdb.h"
#include "inf.h"
#include "ini.h"
#include "blobs.h"
#include "objstr.h"
#include "exclist.h"
#include "reg.h"
#include "regenum.h"
#include "fileenum.h"
#include "wnd.h"

//
// Strings
//

// None

//
// Constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW                1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE                 MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE                 MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif


//
// Macros
//


//
// OSVERSION macros...
//
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) > 1000)
#define ISWIN95()           (ISWIN9X() && !ISMEMPHIS())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define BUILDNUMBER()       (g_OsInfo.dwBuildNumber)

//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION



//
// Types
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

//
// String Mapping
//

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct _tagCHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;
    struct _tagCHARNODE *NextLevel;
    struct _tagCHARNODE *NextPeer;
    REG_REPLACE_FILTER Filter;
} CHARNODE, *PCHARNODE;

typedef struct {
    PMHANDLE Pool;
    PCHARNODE FirstLevelRoot;
} MAPSTRUCT, *PMAPSTRUCT;


//
// Globals
//

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;


extern BOOL g_IsPc98;

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;


//
// Macro expansion list
//

// None

//
// Public function prototypes
//

//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//


BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

//
// Includes of util modules
//


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );

VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );


PMAPSTRUCT
CreateStringMapping (
    VOID
    );

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter       OPTIONAL
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter       OPTIONAL
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      BOOL CompleteMatchOnly
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,FALSE)


BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      BOOL CompleteMatchOnly
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,FALSE)


HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

//
// Macro expansion definition
//

// None

//
// Unicode/Ansi mappings.
//
#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#define VERSION_STRUCT                  VERSION_STRUCTW
#define PVERSION_STRUCT                 PVERSION_STRUCTW
#define CreateVersionStruct             CreateVersionStructW
#define DestroyVersionStruct            DestroyVersionStructW
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationW
#define EnumNextVersionTranslation      EnumNextVersionTranslationW
#define EnumFirstVersionValue           EnumFirstVersionValueW
#define EnumNextVersionValue            EnumNextVersionValueW
#define AddStringMappingPair            AddStringMappingPairW
#define AddStringMappingPairEx          AddStringMappingPairExW
#define MappingSearchAndReplace         MappingSearchAndReplaceW
#define MappingSearchAndReplaceEx       MappingSearchAndReplaceExW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#define VERSION_STRUCT                  VERSION_STRUCTA
#define PVERSION_STRUCT                 PVERSION_STRUCTA
#define CreateVersionStruct             CreateVersionStructA
#define DestroyVersionStruct            DestroyVersionStructA
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationA
#define EnumNextVersionTranslation      EnumNextVersionTranslationA
#define EnumFirstVersionValue           EnumFirstVersionValueA
#define EnumNextVersionValue            EnumNextVersionValueA
#define AddStringMappingPair            AddStringMappingPairA
#define AddStringMappingPairEx          AddStringMappingPairExA
#define MappingSearchAndReplace         MappingSearchAndReplaceA
#define MappingSearchAndReplaceEx       MappingSearchAndReplaceExA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\inc\basetypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE
    - Define non-standard types PCTCHAR and PTCHAR for spapip.h

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifndef PCUINT
typedef const unsigned int  *PCUINT;
#endif

#ifndef PCUINT64
typedef const unsigned _int64  *PCUINT64;
#endif

#if defined(_WIN64)

#define BINT    INT64
#define UBINT   UINT64
#define PBINT   PINT64
#define PUBINT  PUINT64
#define PCUBINT PCUINT64

#else

#define BINT    INT
#define UBINT   UINT
#define PBINT   PINT
#define PUBINT  PUINT
#define PCUBINT PCUINT

#endif

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif

//
// Pointer to a constant byte sequence
//

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif


//
// use the result of sizeof operator as a DWORD
//
#define DWSIZEOF(x) ((DWORD)sizeof(x))



// PORTBUG!!  We want to eliminate setupapi.h
//
// Types for Setup API
//

#ifndef PCTCHAR
#define PCTCHAR const TCHAR *
#endif

#ifndef PTCHAR
#define PTCHAR TCHAR *
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\basefile.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#define INVALID_ATTRIBUTES      0xFFFFFFFF

BOOL
DoesFileExistExA (
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW (
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

BOOL
PathIsDirectoryA (
    IN      PCSTR PathSpec
    );

BOOL
PathIsDirectoryW (
    IN      PCWSTR PathSpec
    );

BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );

BOOL
BfGetTempFileNameA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    );

BOOL
BfGetTempFileNameW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars
    );

HANDLE
BfGetTempFile (
    VOID
    );

BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    );

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    );

BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    );

BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    );

BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    );

BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    );

BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    );


BOOL
BfCreateDirectoryA (
    IN      PCSTR FullPath
    );

BOOL
BfCreateDirectoryW (
    IN      PCWSTR FullPath
    );

LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    );

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    );

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    );

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    );

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

#ifdef UNICODE

#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define PathIsDirectory                 PathIsDirectoryW
#define WriteFileString                 WriteFileStringW
#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW
#define BfGetTempFileName               BfGetTempFileNameW
#define BfOpenFile                      BfOpenFileW
#define BfCreateFile                    BfCreateFileW
#define BfCreateSharedFile              BfCreateSharedFileW
#define BfCreateDirectory               BfCreateDirectoryW
#define BfGetFileSize                   BfGetFileSizeW
#define BfGetLongFileName               BfGetLongFileNameW
#define BfGetLongFileNameEx             BfGetLongFileNameExW

#else

#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define PathIsDirectory                 PathIsDirectoryA
#define WriteFileString                 WriteFileStringA
#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA
#define BfGetTempFileName               BfGetTempFileNameA
#define BfOpenFile                      BfOpenFileA
#define BfCreateFile                    BfCreateFileA
#define BfCreateSharedFile              BfCreateSharedFileA
#define BfCreateDirectory               BfCreateDirectoryA
#define BfGetFileSize                   BfGetFileSizeA
#define BfGetLongFileName               BfGetLongFileNameA
#define BfGetLongFileNameEx             BfGetLongFileNameExA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\basemem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    basemem.h

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.h and allutils.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:


--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

#define INVALID_PTR             ((PVOID)-1)


//
// Fail-proof memory allocators
//

PVOID SafeHeapAlloc (HANDLE g_hHeap, DWORD Flags, SIZE_T Size);
PVOID SafeHeapReAlloc (HANDLE g_hHeap, DWORD Flags, PVOID OldBlock, SIZE_T Size);

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID ReuseAlloc (HANDLE Heap, PVOID OldPtr, DWORD SizeNeeded);
VOID ReuseFree (HANDLE Heap,PVOID Ptr);





#ifdef DEBUG

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(x) DebugHeapCheck(__FILE__,__LINE__,heap)
#define Free(ptr) DebugHeapFree(__FILE__,__LINE__,g_hHeap,0,ptr)
#define MemAllocUninit(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,0,size)
#define MemAllocZeroed(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,HEAP_ZERO_MEMORY,size)


LPVOID DebugHeapAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, SIZE_T dwSize);
LPVOID DebugHeapReAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem, SIZE_T dwSize);
BOOL DebugHeapFree (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);
void DebugHeapCheck (LPCSTR File, DWORD Line, HANDLE hHeap);

VOID DumpHeapStats (VOID);

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );

#define MemCheckPtr(heap,ptr)       (DebugHeapValidatePtr(heap,ptr,__FILE__,__LINE__) != INVALID_PTR)


#else

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(LPVOID) z)
#define MemCheck(x)
#define Free(ptr) HeapFree(g_hHeap,0,ptr)
#define MemAllocUninit(size) SafeHeapAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size) SafeHeapAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()

#define MemCheckPtr(heap,ptr)       (1)

#endif


#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\inc\baseinc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    baseinc.h

Abstract:

    Includes SDK headers needed for the project, and allutils.h.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// basetypes.h creates better types for managing DBCS and UNICODE
// with the C runtime, and defines other types that should be defined
// by the Win32 headers but aren't.
//

#include "basetypes.h"

//
// COBJMACROS turns on the C-style macros for COM.  We don't use C++!
//

#define COBJMACROS

//
// Windows
//

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <spapip.h>

//
// PORTBUG -- I had to uncomment shlobj.h just to get the #define DOUBLE working...
//
#include <shlobj.h>
//#include <objidl.h>
//#include <mmsystem.h>
//

//
// Private utilities
//

#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\blobs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    blobs.h

Abstract:

    Declares the interface functions to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef enum {
    BDT_NONE        = 0,
    BDT_SZW,
    BDT_SZA,
    BDT_MULTISZW,
    BDT_MULTISZA,
    BDT_DWORD,
    BDT_QWORD,
    BDT_BINARY,
    BDT_LAST
} BLOB_DATA_TYPE;

typedef enum {
    BF_RECORDDATATYPE   = 0x0001,
    BF_RECORDDATASIZE   = 0x0002,
    BF_UNICODESTRINGS   = 0x0004,
} BLOB_FLAGS;

typedef struct {
    PBYTE       Data;
    DWORD       End;
    DWORD       AllocSize;
    DWORD       GrowSize;
    DWORD       Index;
    DWORD       Flags;
    DWORD       UserIndex;
} OURBLOB, *POURBLOB;

typedef struct {
    DWORD       Signature;
    POURBLOB*   Blobs;
    DWORD       BlobsCount;
    DWORD       BlobsAllocated;
    DWORD       BlobsGrowCount;
} BLOBS, *PBLOBS;


typedef struct {
    POURBLOB    CurrentBlob;
    PBLOBS      Array;
    DWORD       Index;
} BLOB_ENUM, *PBLOB_ENUM;


//
// Macros
//

#define OURBLOB_INIT    { NULL, 0, 0, 0, 0, 0, 0 }
#define BLOBS_INIT      { 0, NULL, 0, 0, 0 }


//
// Blob APIs
//

__inline
BOOL
BlobRecordsDataType (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATATYPE;
}

__inline
BOOL
BlobRecordsDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATASIZE;
}

__inline
BOOL
BlobRecordsUnicodeStrings (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_UNICODESTRINGS;
}

__inline
BOOL
BlobIsEOF (
    IN      POURBLOB Blob
    )
{
    return !Blob->Data || Blob->Index == Blob->End;
}

__inline
PBYTE
BlobGetPointer (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->Index : NULL;
}

__inline
PBYTE
BlobGetEOF (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->End : NULL;
}

__inline
DWORD
BlobGetIndex (
    IN      POURBLOB Blob
    )
{
    return Blob->Index;
}


__inline
DWORD
BlobGetDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->End;
}

POURBLOB
BlobCreate (
    VOID
    );

POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    );

VOID
BlobClear (
    IN OUT  POURBLOB Blob
    );

VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    );

BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    );

DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    );

BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    );

PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    );

BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    );

BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    );

BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    );

BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    );

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteBinary (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size
    );

BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool
    );

BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    );

BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    );

//
// Blob Array APIs
//

__inline
DWORD
BlobsGetCount (
    IN      PBLOBS BlobsArray
    )
{
    return BlobsArray->BlobsCount;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    );


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    );

BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    );

BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    );

BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    );

BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    );

//
// Macros
//

#ifdef UNICODE

#define BlobWriteString         BlobWriteStringW
#define BlobReadString          BlobReadStringW
#define BlobWriteMultiSz        BlobWriteMultiSzW
#define BlobReadMultiSz         BlobReadMultiSzW

#else

#define BlobWriteString         BlobWriteStringA
#define BlobReadString          BlobReadStringA
#define BlobWriteMultiSz        BlobWriteMultiSzA
#define BlobReadMultiSz         BlobReadMultiSzA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\dbgtrack.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dbgtrack.h

Abstract:

    Implements macros and declares functions for resource tracking apis.
    Split from old debug.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:



--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif



//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
#define MEMORY_TRACKING

#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_TRACKING_INLINE_CALL ,File,Line


#endif



//
// Macros
//

#ifdef DEBUG

#define DISABLETRACKCOMMENT()               DisableTrackComment()
#define ENABLETRACKCOMMENT()                EnableTrackComment()

#define TRACK_BEGIN(type,name)              Track##type(TrackPush(#name,__FILE__,__LINE__) ? (type) 0 : (
#define TRACK_END()                         ))

#define INVALID_POINTER(x)                  x=NULL

#else

#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define TRACK_BEGIN(type,name)
#define TRACK_END()

#define INVALID_POINTER(x)

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_TRACKING_INLINE_CALL

#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

//
// Types
//

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;



//
// Globals
//

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;

//
// Macro expansion list
//

#define TRACK_WRAPPERS          \
        DEFMAC(PBYTE)           \
        DEFMAC(DWORD)           \
        DEFMAC(BOOL)            \
        DEFMAC(UINT)            \
        DEFMAC(PCSTR)           \
        DEFMAC(PCWSTR)          \
        DEFMAC(UBINT)           \
        DEFMAC(PVOID)           \
        DEFMAC(PSTR)            \
        DEFMAC(PWSTR)           \
        DEFMAC(HINF)            \
        DEFMAC(PMHANDLE)        \
        DEFMAC(PGROWBUFFER)     \

//
// Public function prototypes
//

#ifdef DEBUG

VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
VOID DisableTrackComment (VOID);
VOID EnableTrackComment (VOID);

INT TrackPush (PCSTR Name, PCSTR File, UINT Line);
INT TrackPop (VOID);

#define TRACKPUSH(n,f,l)        TrackPush(n,f,l)
#define TRACKPOP()              TrackPop()

//
// Macro expansion definition
//

#define DEFMAC(type)    __inline type Track##type (type Arg) {TrackPop(); return Arg;}

TRACK_WRAPPERS

#undef DEFMAC


#else       // i.e., if !DEBUG

#define TRACKPUSH(n,f,l)
#define TRACKPOP()

#endif

#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\fileenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

//
// Drive enumeration structures
//

#define DRIVEENUM_UNKNOWN   DRIVE_UNKNOWN
#define DRIVEENUM_NOROOTDIR DRIVE_NO_ROOT_DIR
#define DRIVEENUM_REMOVABLE DRIVE_REMOVABLE
#define DRIVEENUM_FIXED     DRIVE_FIXED
#define DRIVEENUM_REMOTE    DRIVE_REMOTE
#define DRIVEENUM_CDROM     DRIVE_CDROM
#define DRIVEENUM_RAMDISK   DRIVE_RAMDISK
#define DRIVEENUM_NONE      0
#define DRIVEENUM_ALL       (DRIVE_UNKNOWN|DRIVE_NO_ROOT_DIR|DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK)
#define DRIVEENUM_ALLVALID  (DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK)

typedef struct {
    PCSTR           DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PSTR            AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMA, *PDRIVE_ENUMA;

typedef struct {
    PCWSTR          DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PWSTR           AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMW, *PDRIVE_ENUMW;

//
// File enumeration structures
//

#define FILEENUM_ALL_SUBLEVELS  0xFFFFFFFF

typedef enum {
    FECF_SKIPDIR                = 0x0001,
    FECF_SKIPSUBDIRS            = 0x0002,
    FECF_SKIPFILES              = 0x0004,
} FILEENUM_CONTROLFLAGS;

typedef enum {
    FEIF_RETURN_DIRS            = 0x0001,
    FEIF_FILES_FIRST            = 0x0002,
    FEIF_DEPTH_FIRST            = 0x0004,
    FEIF_USE_EXCLUSIONS         = 0x0008,
    FEIF_CONTAINERS_FIRST       = 0x0010,
} FILEENUM_INFOFLAGS;

typedef enum {
    DNS_ENUM_INIT,
    DNS_FILE_FIRST,
    DNS_FILE_NEXT,
    DNS_FILE_DONE,
    DNS_SUBDIR_FIRST,
    DNS_SUBDIR_NEXT,
    DNS_SUBDIR_DONE,
    DNS_ENUM_DONE
} DNS_ENUM_STATE;

typedef enum {
    FES_ROOT_FIRST,
    FES_ROOT_NEXT,
    FES_ROOT_DONE
} FES_ROOT_STATE;

typedef enum {
    DNF_RETURN_DIRNAME      = 0x0001,
    DNF_DIRNAME_MATCHES     = 0x0002,
} DIRNODE_FLAGS;

typedef struct {
    PCSTR               DirName;
    DWORD               DirAttributes;
    PSTR                FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAA    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEA, *PDIRNODEA;

typedef struct {
    PCWSTR              DirName;
    DWORD               DirAttributes;
    PWSTR               FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAW    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEW, *PDIRNODEW;

typedef BOOL (*FPE_ERROR_CALLBACKA)(PDIRNODEA);

typedef struct {
    POBSPARSEDPATTERNA      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKA     CallbackOnError;
} FILEENUMINFOA, *PFILEENUMINFOA;

typedef BOOL (*FPE_ERROR_CALLBACKW)(PDIRNODEW);

typedef struct {
    POBSPARSEDPATTERNW      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKW     CallbackOnError;
} FILEENUMINFOW, *PFILEENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOA   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMA    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEA       LastNode;
    PSTR            FileNameAppendPos;
    PSTR            LastWackPtr;
} FILETREE_ENUMA, *PFILETREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOW   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMW    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEW       LastNode;
    PWSTR           FileNameAppendPos;
    PWSTR           LastWackPtr;
} FILETREE_ENUMW, *PFILETREE_ENUMW;


//
// API
//

BOOL
FileEnumInitialize (
    VOID
    );

VOID
FileEnumTerminate (
    VOID
    );

//
// File enumeration APIs
//

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeA(e,p)  EnumFirstFileInTreeExA(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeW(e,p)  EnumFirstFileInTreeExW(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

//
// Drive enumeration APIs
//

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );


//
// Routines built on enum
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeW (
    IN      PCWSTR Dir
    );

//
// Macros
//

#ifdef UNICODE

#define DIRNODE                     DIRNODEW
#define PDIRNODE                    PDIRNODEW
#define FILENODE                    FILENODEW
#define PFILENODE                   PFILENODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define FILEENUMINFO                FILEENUMINFOW
#define PFILEENUMINFO               PFILEENUMINFOW
#define FILETREE_ENUM               FILETREE_ENUMW
#define PFILETREE_ENUM              PFILETREE_ENUMW
#define EnumFirstFileInTree         EnumFirstFileInTreeW
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExW
#define EnumNextFileInTree          EnumNextFileInTreeW
#define AbortEnumFileInTree         AbortEnumFileInTreeW

#define DRIVE_ENUM                  DRIVE_ENUMW
#define EnumFirstDrive              EnumFirstDriveW
#define EnumNextDrive               EnumNextDriveW
#define AbortEnumDrive              AbortEnumDriveW
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirW
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeW

#else

#define DIRNODE                     DIRNODEA
#define PDIRNODE                    PDIRNODEA
#define FILENODE                    FILENODEA
#define PFILENODE                   PFILENODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define FILEENUMINFO                FILEENUMINFOA
#define PFILEENUMINFO               PFILEENUMINFOA
#define FILETREE_ENUM               FILETREE_ENUMA
#define PFILETREE_ENUM              PFILETREE_ENUMA
#define EnumFirstFileInTree         EnumFirstFileInTreeA
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExA
#define EnumNextFileInTree          EnumNextFileInTreeA
#define AbortEnumFileInTree         AbortEnumFileInTreeA

#define DRIVE_ENUM                  DRIVE_ENUMA
#define EnumFirstDrive              EnumFirstDriveA
#define EnumNextDrive               EnumNextDriveA
#define AbortEnumDrive              AbortEnumDriveA
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirA
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\exclist.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    exclist.h

Abstract:

    Set of APIs to manage exclusion lists of objects of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Macro expansion list
//

#define EXCLUSIONLIST_TYPES                                     \
            DEFMAC(ELT_PATH,            "Path",         TRUE)   \
            DEFMAC(ELT_FILE,            "File",         FALSE)  \
            DEFMAC(ELT_REGKEY,          "RegKey",       TRUE)   \
            DEFMAC(ELT_REGVALUE,        "RegValue",     FALSE)  \

//
// Types
//

#define DEFMAC(TypeId,TypeName,Compound)    TypeId,

typedef enum {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_UNKNOWN
} EL_TYPE;

#undef DEFMAC


//
// API
//

BOOL
ElInitialize (
    VOID
    );

VOID
ElTerminate (
    VOID
    );

EL_TYPE
ElGetTypeId (
    IN      PCSTR TypeName
    );

PCSTR
ElGetTypeName (
    IN      EL_TYPE TypeId
    );

BOOL
ElAddA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR ObjectName
    );

BOOL
ElAddW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR ObjectName
    );

VOID
ElRemoveAllA (
    VOID
    );

VOID
ElRemoveAllW (
    VOID
    );

BOOL
ElIsExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Object
    );

BOOL
ElIsExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Object
    );

BOOL
ElIsExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Node,
    IN      PCSTR Leaf              OPTIONAL
    );

BOOL
ElIsExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsTreeExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR TreePattern
    );

BOOL
ElIsTreeExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR TreePattern
    );

BOOL
ElIsTreeExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    );

BOOL
ElIsTreeExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsObsPatternExcludedA (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    );

BOOL
ElIsObsPatternExcludedW (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    );

//
// Macros
//

#ifdef UNICODE

#define ElAdd                   ElAddW
#define ElRemoveAll             ElRemoveAllW
#define ElIsExcluded            ElIsExcludedW
#define ElIsExcluded2           ElIsExcluded2W
#define ElIsTreeExcluded        ElIsTreeExcludedW
#define ElIsTreeExcluded2       ElIsTreeExcluded2W
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedW

#else

#define ElAdd                   ElAddA
#define ElRemoveAll             ElRemoveAllA
#define ElIsExcluded            ElIsExcludedA
#define ElIsExcluded2           ElIsExcluded2A
#define ElIsTreeExcluded        ElIsTreeExcludedA
#define ElIsTreeExcluded2       ElIsTreeExcluded2A
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct TAG_GROWBUFFER {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
} GROWBUFFER;

#define INIT_GROWBUFFER {NULL,0,0,0,0}

PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD SpaceNeeded
    );

#define GbGrow(buf,size)    TRACK_BEGIN(PBYTE, GbGrow)\
                            RealGbGrow(buf,size)\
                            TRACK_END()

VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    );


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbMultiSzAppendA(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendA)\
                                    RealGbMultiSzAppendA(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbMultiSzAppendW(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendW)\
                                    RealGbMultiSzAppendW(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValA(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValA)\
                                        RealGbMultiSzAppendValA(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValW(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValW)\
                                        RealGbMultiSzAppendValW(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define GbMultiSzAppendStringA(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringA)\
                                            RealGbMultiSzAppendStringA(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define GbMultiSzAppendStringW(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringW)\
                                            RealGbMultiSzAppendStringW(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GbAppendDword(buf,d)        TRACK_BEGIN(BOOL, GbAppendDword)\
                                    RealGbAppendDword(buf,d)\
                                    TRACK_END()

BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID p
    );

#define GbAppendPvoid(buf,p)        TRACK_BEGIN(BOOL, GbAppendPvoid)\
                                    RealGbAppendPvoid(buf,p)\
                                    TRACK_END()


BOOL
RealGbAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbAppendStringA(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringA)\
                                    RealGbAppendStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbAppendStringW(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringW)\
                                    RealGbAppendStringW(buf,str)\
                                    TRACK_END()


BOOL
RealGbAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GbAppendStringABA(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABA)\
                                        RealGbAppendStringABA(buf,a,b)\
                                        TRACK_END()

BOOL
RealGbAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GbAppendStringABW(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABW)\
                                        RealGbAppendStringABW(buf,a,b)\
                                        TRACK_END()



BOOL
RealGbCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyStringA(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringA)\
                                    RealGbCopyStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyStringW(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringW)\
                                    RealGbCopyStringW(buf,str)\
                                    TRACK_END()

#ifdef UNICODE

#define GbMultiSzAppend             GbMultiSzAppendW
#define GbMultiSzAppendVal          GbMultiSzAppendValW
#define GbMultiSzAppendString       GbMultiSzAppendStringW
#define GbAppendString              GbAppendStringW
#define GbAppendStringAB            GbAppendStringABW
#define GbCopyString                GbCopyStringW

#else

#define GbMultiSzAppend             GbMultiSzAppendA
#define GbMultiSzAppendVal          GbMultiSzAppendValA
#define GbMultiSzAppendString       GbMultiSzAppendStringA
#define GbAppendString              GbAppendStringA
#define GbAppendStringAB            GbAppendStringABA
#define GbCopyString                GbCopyStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
HtAllocExAW (
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocA()                              HtAllocExAW(FALSE,FALSE,0,0)
#define HtAllocW()                              HtAllocExAW(TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                  HtAllocExAW(FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                  HtAllocExAW(TRUE,FALSE,size,0)

#define HtAllocExA(datasize,bucketcount)        HtAllocExAW(FALSE,FALSE,size,bucketcount)
#define HtAllocExW(datasize,bucketcount)        HtAllocExAW(TRUE,FALSE,size,bucketcount)

#define HtAllocExternStrA()                     HtAllocExAW(FALSE,TRUE,0,0)
#define HtAllocExternStrW()                     HtAllocExAW(TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)         HtAllocExAW(FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)         HtAllocExAW(TRUE,TRUE,0,0)

#define HtAllocExternStrExA(size,bucketcount)   HtAllocExAW(FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(size,bucketcount)   HtAllocExAW(TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtAddStringA(table,string)       HtAddStringExA(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtAddStringW(table,string)       HtAddStringExW(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindStringA(table,string)       HtFindStringExA(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindStringW(table,string)       HtFindStringExW(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,CASE_INSENSITIVE)

BOOL
HtGetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringEx               HtAddStringExW
#define HtFindString                HtFindStringW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringEx               HtAddStringExA
#define HtFindString                HtFindStringA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    PMHANDLE ListData;
} GROWLIST, *PGROWLIST;

#define INIT_GROWLIST {NULL,0,0,0,0, NULL}

#define GlGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppend(list,data,size)    TRACK_BEGIN(PBYTE, GlAppend)\
                                    RealGlAppend (list,data,size)   \
                                    TRACK_END()

PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppendAddNul(list,data,size)    TRACK_BEGIN(PBYTE, GlAppendAddNul)         \
                                          RealGlAppendAddNul (list,data,size)       \
                                          TRACK_END()

VOID
GlFree (
    IN  PGROWLIST GrowList
    );

PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GlGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsert(list,index,data,size)      TRACK_BEGIN(PBYTE,GlInsert)   \
                                            RealGlInsert (list,index,data,size)             \
                                            TRACK_END()


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsertAddNul(list,index,data,size)    TRACK_BEGIN(PBYTE, GlInsertAddNul)           \
                                                RealGlInsertAddNul (list,index,data,size)   \
                                                TRACK_END()


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToSet,           OPTIONAL
    IN      UINT SizeOfData
    );

#define GlSetItem(list,index,data,size)     TRACK_BEGIN(PBYTE, GlSetItem)        \
                                            RealGlSetItem(list,index,data,size) \
                                            TRACK_END()

__inline
PCSTR
RealGlAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCSTR
RealGlInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

#define GlAppendStringABA(list,a,b)         TRACK_BEGIN(PCSTR, GrowListAppendStringABA)          \
                                            RealGlAppendStringABA(list,a,b)\
                                            TRACK_END()

#define GlAppendStringABW(list,a,b)         TRACK_BEGIN(PCWSTR, GrowListAppendStringABW)         \
                                            RealGlAppendStringABW(list,a,b)\
                                            TRACK_END()

#define GlInsertStringABA(list,index,a,b)   TRACK_BEGIN(PCSTR, GrowListInsertStringABA)            \
                                            RealGlInsertStringABA(list,index,a,b)\
                                            TRACK_END()

#define GlInsertStringABW(list,index,a,b)   TRACK_BEGIN(PCWSTR, GrowListInsertStringABW)           \
                                            RealGlInsertStringABW(list,index,a,b)\
                                            TRACK_END()



#define GlAppendStringA(list,str) GlAppendStringABA(list,str,GetEndOfStringA(str))
#define GlAppendStringW(list,str) GlAppendStringABW(list,str,GetEndOfStringW(str))

#define GlInsertStringA(list,index,str) GlInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GlInsertStringW(list,index,str) GlInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GlAppendStringNA(list,str,len) GlAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GlAppendStringNW(list,str,len) GlAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GlInsertStringNA(list,index,str,len) GlInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GlInsertStringNW(list,index,str,len) GlInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GlGetStringA(list,index) (PCSTR)(GlGetItem(list,index))
#define GlGetStringW(list,index) (PCWSTR)(GlGetItem(list,index))

#define GlAppendEmptyItem(list)           GlAppend (list,NULL,0)
#define GlInsertEmptyItem(list,index)     GlInsert (list,index,NULL,0)

#ifdef UNICODE

#define GlAppendString GlAppendStringW
#define GlInsertString GlInsertStringW
#define GlAppendStringAB GlAppendStringABW
#define GlInsertStringAB GlInsertStringABW
#define GlAppendStringN GlAppendStringNW
#define GlInsertStringN GlInsertStringNW
#define GlGetString GlGetStringW
#define GlGetStringPtrArray GlGetStringPtrArrayW

#else

#define GlAppendString GlAppendStringA
#define GlInsertString GlInsertStringA
#define GlAppendStringAB GlAppendStringABA
#define GlInsertStringAB GlInsertStringABA
#define GlAppendStringN GlAppendStringNA
#define GlInsertStringN GlInsertStringNA
#define GlGetString GlGetStringA
#define GlGetStringPtrArray GlGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)      LogIfA(                                     \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR   "Fatal Error"
#define LOG_ERROR         "Error"
#define LOG_WARNING       "Warning"
#define LOG_INFORMATION   "Info"
#define LOG_ACCOUNTS      "Accounts"
#define LOG_CONFIG        "Configuration"

BOOL
Init_Log (
    IN      HWND LogPopupParentWnd
    );

VOID
Exit_Log (
    VOID
    );

BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    );

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    );

#endif

// Define W symbols

#define LOGW(x) LogW x
#define LOGW_IF(x) LogIfW x
#define ELSE_LOGW(x) else{LogW x;}
#define ELSE_LOGW_IF(x) else{LogIfW x;}
#define LOGTITLEW(type,title) LogTitleW (type,title)
#define LOGLINEW(title) LogLineW (title)
#define LOGDIRECTW(type,text) LogDirectW (type,text)

// Define A symbols

#define LOGA(x) LogA x
#define LOGA_IF(x) LogIfA x
#define ELSE_LOGA(x) else{LogA x;}
#define ELSE_LOGA_IF(x) else{LogIfA x;}
#define LOGTITLEA(type,title) LogTitleA (type,title)
#define LOGLINEA(line) LogLineA (line)
#define LOGDIRECTA(type,text) LogDirectA (type,text)

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"

extern CHAR g_DebugInfPathBufA[];
extern WCHAR g_DebugInfPathBufW[];
#define g_DebugInfPath  g_DebugInfPathBufA
#define g_DebugInfPathA g_DebugInfPathBufA
#define g_DebugInfPathW g_DebugInfPathBufW

extern BOOL g_ResetLog;             // Defined in log.c
#define SET_RESETLOG()   g_ResetLog = TRUE
#define CLR_RESETLOG()   g_ResetLog = FALSE
#define RESETLOG()       (g_ResetLog)

extern BOOL g_DoLog;                // Defined in log.c
#define SET_DOLOG()     g_DoLog = TRUE
#define CLR_DOLOG()     g_DoLog = FALSE
#define DOLOG()         (g_DoLog)


#ifndef PROGRESS_BAR

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

#endif


// Define W symbols

#define DEBUGMSGW(x) LogW x
#define DEBUGMSGW_IF(x) LogIfW x
#define ELSE_DEBUGMSGW(x) else LogW x
#define ELSE_DEBUGMSGW_IF(x) else LogW x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEW(x) LogTime x
#else
#define DEBUGLOGTIMEW(x) DebugLogTimeW x
#endif


// Define A symbols

#define DEBUGMSGA(x) LogA x
#define DEBUGMSGA_IF(x) LogIfA x
#define ELSE_DEBUGMSGA(x) else LogA x
#define ELSE_DEBUGMSGA_IF(x) else LogIfA x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEA(x) LogTime x
#else
#define DEBUGLOGTIMEA(x) DebugLogTimeA x
#endif

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define SET_RESETLOG()
#define CLR_RESETLOG()
#define RESETLOG()

#define SET_DOLOG()
#define CLR_DOLOG()
#define DOLOG()

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#ifdef PROGRESS_BAR
#define DEBUGLOGTIME(x) LogTime x
#else
#define DEBUGLOGTIME(x)
#endif

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\main.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    main.h

Abstract:

    Declares the interface to utils\main

Author:

    Jim Schmidt (jimschm) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/


//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

//
// Prototypes
//

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    );

VOID
UtTerminate (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_PMHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_PMHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    PMHANDLE        PoolHandle;
    ALLOCATORTYPES  Allocator;
} INFSTRUCT, *PINFSTRUCT;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_GROWBUFFER}
#define INITINFSTRUCT_PMHANDLE {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_PMHANDLE}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile



VOID
InfCleanUpInfStruct (
    PINFSTRUCT Context
    );

VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()

#define InfOpenInfFileW(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCT
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntField (
    IN PINFSTRUCT       Context,
    IN UINT            FieldIndex,
    IN PINT             Value
    );

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT      Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT   Context
    );

UINT
InfGetFieldCount (
    IN PINFSTRUCT       Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    );



//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW


#else

#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\ini.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.h

Abstract:

    Declares interface for INI wrapper routines. These routines simplify
    access of INIs by wrapping the Win32 APIs with routines that use pools.

Author:

    04-Nov-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef struct {
    PCSTR   IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEA, *PINIFILEA;

typedef struct {
    PCWSTR  IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEW, *PINIFILEW;


typedef struct {
    PCSTR   CurrentSection;
    PCSTR   Sections;
} INISECT_ENUMA, *PINISECT_ENUMA;

typedef struct {
    PCWSTR  CurrentSection;
    PCWSTR  Sections;
} INISECT_ENUMW, *PINISECT_ENUMW;


typedef struct {
    PCSTR   CurrentKeyValuePair;
    PCSTR   KeyValuePairs;
    PCSTR   CurrentKey;
    PCSTR   CurrentValue;
    PSTR    Private;
} INIKEYVALUE_ENUMA, *PINIKEYVALUE_ENUMA;

typedef struct {
    PCWSTR  CurrentKeyValuePair;
    PCWSTR  KeyValuePairs;
    PCWSTR  CurrentKey;
    PCWSTR  CurrentValue;
    PWSTR   Private;
} INIKEYVALUE_ENUMW, *PINIKEYVALUE_ENUMW;

//
// Public function prototypes
//

BOOL
Ini_Init (
    VOID
    );

VOID
Ini_Exit (
    VOID
    );


BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenA(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenA)\
                                RealIniFileOpenA((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()

BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenW(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenW)\
                                RealIniFileOpenW((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()


VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    );

VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    );

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    );

BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    );

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    );

BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    );

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    );

VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    );

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    );

BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#define INIFILE                         INIFILEW
#define INISECT_ENUM                    INISECT_ENUMW
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMW

#define IniFileOpen                     IniFileOpenW
#define IniFileClose                    IniFileCloseW
#define EnumFirstIniSection             EnumFirstIniSectionW
#define EnumNextIniSection              EnumNextIniSectionW
#define AbortIniSectionEnum             AbortIniSectionEnumW
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueW
#define EnumNextIniKeyValue             EnumNextIniKeyValueW
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumW
#define IniReadValue                    IniReadValueW
#define IniFreeReadValue                IniFreeReadValueW
#define IniWriteValue                   IniWriteValueW

#else

#define INIFILE                         INIFILEA
#define INISECT_ENUM                    INISECT_ENUMA
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMA

#define IniFileOpen                     IniFileOpenA
#define IniFileClose                    IniFileCloseA
#define EnumFirstIniSection             EnumFirstIniSectionA
#define EnumNextIniSection              EnumNextIniSectionA
#define AbortIniSectionEnum             AbortIniSectionEnumA
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueA
#define EnumNextIniKeyValue             EnumNextIniKeyValueA
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumA
#define IniReadValue                    IniReadValueA
#define IniFreeReadValue                IniFreeReadValueA
#define IniWriteValue                   IniWriteValueA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\ipc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ipc.h

Abstract:

    Implements IPC interface to allow setup to talk with migisol.exe,
    in order to run migration DLLs in separate processes.

Author:

    Jim Schmidt (jimschm)   28-Mar-1997

Revision History:

    jimschm 23-Sep-1998     Changed from mailslots to memory mapped files

--*/


#pragma once

BOOL
IpcOpenW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR MigrationDllPath,        OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    );

BOOL
IpcOpenA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR MigrationDllPath,         OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    );

DWORD
IpcCheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    );

BOOL
IpcProcessAlive (
    VOID
    );

VOID
IpcKillProcess (
    VOID
    );

BOOL
IpcSendCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

BOOL
IpcGetCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    );

BOOL
IpcGetCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    );

BOOL
IpcSendCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

#define IPC_GET_RESULTS_WIN9X       1000
#define IPC_GET_RESULTS_NT          7500
#define IPC_GET_COMMAND_WIN9X       10000
#define IPC_GET_COMMAND_NT          10000




#ifdef UNICODE
#define IpcOpen IpcOpenW
#else
#define IpcOpen IpcOpenA
#endif

VOID
IpcClose (
    VOID
    );

typedef LONG (WINAPI WINVERIFYTRUST_PROTOTYPE)(HWND hwnd, GUID *ActionId, PVOID Data);
typedef WINVERIFYTRUST_PROTOTYPE * WINVERIFYTRUST;



BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    );

BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    );


#ifdef UNICODE
#define IsDllSigned IsDllSignedW
#else
#define IsDllSigned IsDllSignedA
#endif

//
// Remote commands
//

#define IPC_QUERY           1
#define IPC_INITIALIZE      2
#define IPC_MIGRATEUSER     3
#define IPC_MIGRATESYSTEM   4
#define IPC_TERMINATE       5
#define IPC_DVDCHECK        6

//
// APIs implemented in IPC
//

BOOL
IsolatedIsDvdPresentA (
    PCSTR ExePath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    mvander     13-Aug-1999     many changes
    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define INVALID_OFFSET      (~((UINT)0))

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000


//
// Dataflags for enuming key data
//

#define DATAFLAG_INSTANCEMASK   0x03
#define DATAFLAG_UNORDERED      0x04
#define DATAFLAG_SINGLELINK     0x08
#define DATAFLAG_DOUBLELINK     0x10
#define DATAFLAG_BINARYMASK     0x1C
#define DATAFLAG_VALUE          0x20
#define DATAFLAG_FLAGS          0x40
#define DATAFLAG_ALL            (DATAFLAG_INSTANCEMASK|DATAFLAG_UNORDERED|DATAFLAG_SINGLELINK|DATAFLAG_DOUBLELINK|DATAFLAG_VALUE|DATAFLAG_FLAGS)

//
// Constant for MemDbKeyFromHandle
//

#define MEMDB_LAST_LEVEL        0xFFFFFFFF

//
// Types
//


typedef UINT KEYHANDLE;
typedef UINT DATAHANDLE;

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Flags for enumeration routines
//
#define ENUMFLAG_INSTANCEMASK       0x0003
#define ENUMFLAG_UNORDERED          0x0004
#define ENUMFLAG_SINGLELINK         0x0008
#define ENUMFLAG_DOUBLELINK         0x0010
#define ENUMFLAG_BINARYMASK         0x001C
#define ENUMFLAG_VALUE              0x0020
#define ENUMFLAG_FLAGS              0x0040
#define ENUMFLAG_EMPTY              0x0080
#define ENUMFLAG_ENDPOINTS          0x0100
#define ENUMFLAG_NONENDPOINTS       0x0200

#define ENUMFLAG_ALLDATA        ENUMFLAG_BINARYMASK|ENUMFLAG_VALUE|ENUMFLAG_FLAGS|ENUMFLAG_EMPTY
#define ENUMFLAG_ALLSEGMENTS    ENUMFLAG_ENDPOINTS|ENUMFLAG_NONENDPOINTS

#define ENUMFLAG_ALL            ENUMFLAG_ALLDATA|ENUMFLAG_ALLSEGMENTS

#define ENUMLEVEL_LASTLEVEL         0xFFFFFFFF
#define ENUMLEVEL_ALLLEVELS         0xFFFFFFFF

typedef struct {
    WCHAR FullKeyName[MEMDB_MAX];
    WCHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    BYTE CurrentDatabaseIndex;
    BOOL EnumerationMode;
    UINT EnumFlags;
    PWSTR KeyNameCopy;
    PWSTR PatternCopy;
    PWSTR PatternPtr;
    PWSTR PatternEndPtr;
    UINT CurrentIndex;
    UINT BeginLevel;                   // 0-based first level of keys
    UINT EndLevel;                     // 0-based last level of keys
    UINT CurrentLevel;                 // 1-based level of keys
    GROWBUFFER TreeEnumBuffer;
    UINT TreeEnumLevel;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    CHAR FullKeyName[MEMDB_MAX];
    CHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    MEMDB_ENUMW UnicodeEnum;
} MEMDB_ENUMA, *PMEMDB_ENUMA;


//
// Function prototypes
//

BOOL
MemDbInitialize (
    VOID
    );

VOID
MemDbTerminate (
    VOID
    );

PVOID
MemDbGetMemory (
    IN      UINT Size
    );

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    );

KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteTreeW (
    IN      PCWSTR KeyName
    );

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer
    );

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer
    );

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsW (
    IN      PCWSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsByHandle (
    IN      KEYHANDLE KeyHandle,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

#define MemDbSetValueAndFlagsA(k,v,s,c) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsW(k,v,s,c) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsByHandle(h,v,s,c) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,s,c)

#define MemDbSetValueA(k,v) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueW(k,v) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueByHandle(h,v) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,0,0)
#define MemDbGetValueA(k,v) MemDbGetValueAndFlagsA(k,v,NULL)
#define MemDbGetValueW(k,v) MemDbGetValueAndFlagsW(k,v,NULL)
#define MemDbGetValueByHandle(h,v) MemDbGetValueAndFlagsByHandle(h,v,NULL)

#define MemDbTestKeyA(k)  MemDbGetValueAndFlagsA(k,NULL,NULL)
#define MemDbTestKeyW(k)  MemDbGetValueAndFlagsW(k,NULL,NULL)
#define MemDbTestKeyByHandle(h) MemDbGetValueAndFlagsByHandle(h,NULL,NULL)

#define MemDbSetFlagsA(k,s,c) MemDbSetValueAndFlagsExA(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsW(k,s,c) MemDbSetValueAndFlagsExW(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsByHandle(h,s,c) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,FALSE,s,c)
#define MemDbReplaceFlagsA(k,f) MemDbSetValueAndFlagsExA(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsW(k,f) MemDbSetValueAndFlagsExW(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsByHandle(h,f) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,TRUE,f,0)
#define MemDbGetFlagsA(k,f) MemDbGetValueAndFlagsA(k,NULL,f)
#define MemDbGetFlagsW(k,f) MemDbGetValueAndFlagsW(k,NULL,f)
#define MemDbGetFlagsByHandle(h,f) MemDbGetValueAndFlagsByHandle(h,NULL,f)

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    );

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    );

//
// High-level BLOB functions
//
#define MemDbAddUnorderedBlobA(k,i,d,s)  MemDbAddDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobW(k,i,d,s)  MemDbAddDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobByKeyHandle(h,i,d,s) MemDbAddDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobA(k,i,d,s)  MemDbSetDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobW(k,i,d,s)  MemDbSetDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,d,s)
#define MemDbSetUnorderedBlobByKeyHandle(h,i,d,s) MemDbSetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobA(k,i,d,s)  MemDbGrowDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobW(k,i,d,s)  MemDbGrowDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobByDataHandle(h,d,s) MemDbGrowDataByDataHandle(h,d,s)
#define MemDbGrowUnorderedBlobByKeyHandle(h,i,d,s) MemDbGrowDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGetUnorderedBlobHandleA(k,i) MemDbGetDataHandleA(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobHandleW(k,i) MemDbGetDataHandleW(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobA(k,i,s) MemDbGetDataA(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobW(k,i,s) MemDbGetDataW(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobExA(k,i,b,s) MemDbGetDataExA(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobExW(k,i,b,s) MemDbGetDataExW(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobByDataHandle(h,s) MemDbGetDataByDataHandle(h,s)
#define MemDbGetUnorderedBlobByDataHandleEx(h,b,s) MemDbGetDataByDataHandle(h,b,s)
#define MemDbGetUnorderedBlobByKeyHandle(h,i,s) MemDbGetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobByKeyHandleEx(h,i,b,s) MemDbGetDataByKeyHandleEx(h,DATAFLAG_UNORDERED,i,b,s)
#define MemDbDeleteUnorderedBlobA(k,i) MemDbDeleteDataA(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobW(k,i) MemDbDeleteDataW(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobByDataHandle(h) MemDbDeleteDataByDataHandle(h)
#define MemDbDeleteUnorderedBlobByKeyHandle(h,i) MemDbDeleteDataByKeyHandle(h,DATAFLAG_UNORDERED,i)

//
// low-level linkage functions
//
DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

#define MemDbSetLinkageArrayA(k,t,i,d,s) MemDbSetDataA(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayW(k,t,i,d,s) MemDbSetDataW(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByKeyHandle(h,t,i,d,s) MemDbSetDataByKeyHandle(h,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,(PCBYTE)d,s)
#define MemDbGetLinkageArrayA(k,t,i,s) (PUINT)MemDbGetDataA(k,t,i,s)
#define MemDbGetLinkageArrayW(k,t,i,s) (PUINT)MemDbGetDataW(k,t,i,s)
#define MemDbGetLinkageArrayByKeyHandle(h,t,i,s) (PUINT)MemDbGetDataByKeyHandle(h,t,i,s)
#define MemDbGetLinkageArrayByKeyHandleEx(h,t,i,b,s) (PUINT)MemDbGetDataByKeyHandleEx(h,t,i,b,s)
#define MemDbGetLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetDataByDataHandle(h,s)
#define MemDbGetLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetDataByDataHandleEx(h,b,s)

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

// high-level linkage functions
#define MemDbAddSingleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteSingleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetSingleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetSingleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_SINGLELINK,i,b,s)
#define MemDbGetSingleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetSingleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestSingleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddDoubleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteDoubleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetDoubleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetDoubleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_DOUBLELINK,i,b,s)
#define MemDbGetDoubleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetDoubleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestDoubleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddSingleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbGetSingleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)

#define MemDbAddDoubleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbGetDoubleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)

// enumeration functions
BOOL
MemDbEnumFirstA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    );

BOOL
MemDbEnumFirstW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    );

BOOL
MemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbEnumAbortA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbEnumAbortW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    );

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    );

BOOL
MemDbSaveA (
    IN      PCSTR szFile
    );

BOOL
MemDbSaveW (
    IN      PCWSTR szFile
    );

BOOL
MemDbLoadA (
    IN      PCSTR szFile
    );

BOOL
MemDbLoadW (
    IN      PCWSTR szFile
    );

BOOL
MemDbValidateDatabase (
    VOID
    );

BOOL
MemDbQueryVersionA (
    IN      PCSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbQueryVersionW (
    IN      PCWSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );


#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, UINT Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, UINT Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);


#ifdef DEBUG
extern UINT g_DatabaseCheckLevel;
#define MEMDB_CHECKLEVEL1      0x000001
#define MEMDB_CHECKLEVEL2      0x000002
#define MEMDB_CHECKLEVEL3      0x000003

BOOL MemDbCheckDatabase(UINT Level);
UINT MemDbGetDatabaseSize();
#else
#define MemDbCheckDatabase()
#define MemDbGetDatabaseSize()
#endif

//
// A & W
//

#ifdef UNICODE

#define MEMDB_ENUM MEMDB_ENUMW

#define MemDbAddKey MemDbAddKeyW
#define MemDbSetKey MemDbSetKeyW
#define MemDbTestKey MemDbTestKeyW
#define MemDbDeleteKey MemDbDeleteKeyW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleW
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExW
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyW
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetValue MemDbSetValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbSetFlags MemDbSetFlagsW
#define MemDbReplaceFlags MemDbReplaceFlagsW
#define MemDbGetFlags MemDbGetFlagsW
#define MemDbAddData MemDbAddDataW
#define MemDbSetData MemDbSetDataW
#define MemDbGrowData MemDbGrowDataW
#define MemDbGetDataHandle MemDbGetDataHandleW
#define MemDbGetData MemDbGetDataW
#define MemDbGetDataEx MemDbGetDataExW
#define MemDbDeleteData MemDbDeleteDataW
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobW
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobW
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobW
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobW
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExW
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobW
#define MemDbAddLinkageValue MemDbAddLinkageValueW
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueW
#define MemDbSetLinkageArray MemDbSetLinkageArrayW
#define MemDbGetLinkageArray MemDbGetLinkageArrayW
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueW
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueW
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayW
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayW
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueW
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueW
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayW
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayW
#define MemDbTestLinkageValue MemDbTestLinkageValueW
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueW
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueW
#define MemDbAddLinkage MemDbAddLinkageW
#define MemDbGetLinkage MemDbGetLinkageW
#define MemDbTestLinkage MemDbTestLinkageW
#define MemDbAddSingleLinkage MemDbAddSingleLinkageW
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageW
#define MemDbGetSingleLinkage MemDbGetSingleLinkageW
#define MemDbTestSingleLinkage MemDbTestSingleLinkageW
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageW
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageW
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageW
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageW
#define MemDbEnumFirst MemDbEnumFirstW
#define MemDbEnumNext MemDbEnumNextW
#define MemDbEnumAbort MemDbEnumAbortW
#define MEMDB_ENUM MEMDB_ENUMW

#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedW


#else

#define MEMDB_ENUM MEMDB_ENUMA

#define MemDbAddKey MemDbAddKeyA
#define MemDbSetKey MemDbSetKeyA
#define MemDbTestKey MemDbTestKeyA
#define MemDbDeleteKey MemDbDeleteKeyA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleA
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExA
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyA
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetValue MemDbSetValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbSetFlags MemDbSetFlagsA
#define MemDbReplaceFlags MemDbReplaceFlagsA
#define MemDbGetFlags MemDbGetFlagsA
#define MemDbAddData MemDbAddDataA
#define MemDbSetData MemDbSetDataA
#define MemDbGrowData MemDbGrowDataA
#define MemDbGetDataHandle MemDbGetDataHandleA
#define MemDbGetData MemDbGetDataA
#define MemDbGetDataEx MemDbGetDataExA
#define MemDbDeleteData MemDbDeleteDataA
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobA
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobA
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobA
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobA
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExA
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobA
#define MemDbAddLinkageValue MemDbAddLinkageValueA
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueA
#define MemDbSetLinkageArray MemDbSetLinkageArrayA
#define MemDbGetLinkageArray MemDbGetLinkageArrayA
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueA
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueA
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayA
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayA
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueA
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueA
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayA
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayA
#define MemDbTestLinkageValue MemDbTestLinkageValueA
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueA
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueA
#define MemDbAddLinkage MemDbAddLinkageA
#define MemDbGetLinkage MemDbGetLinkageA
#define MemDbTestLinkage MemDbTestLinkageA
#define MemDbAddSingleLinkage MemDbAddSingleLinkageA
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageA
#define MemDbGetSingleLinkage MemDbGetSingleLinkageA
#define MemDbTestSingleLinkage MemDbTestSingleLinkageA
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageA
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageA
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageA
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageA
#define MemDbEnumFirst MemDbEnumFirstA
#define MemDbEnumNext MemDbEnumNextA
#define MemDbEnumAbort MemDbEnumAbortA
#define MEMDB_ENUM MEMDB_ENUMA

#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\objstr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.h

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/


//
// Types
//

typedef enum {
    OBSPF_EXACTNODE             = 0x0001,
    OBSPF_NODEISROOTPLUSSTAR    = 0x0002,
    OBSPF_OPTIONALNODE          = 0x0004,
    OBSPF_NOLEAF                = 0x0008,
    OBSPF_EXACTLEAF             = 0x0010,
    OBSPF_OPTIONALLEAF          = 0x0020,
} OBSP_FLAGS;

typedef struct {
    PPARSEDPATTERNA     NodePattern;
    PPARSEDPATTERNA     LeafPattern;
    PSTR                ExactRoot;
    DWORD               ExactRootBytes;
    PCSTR               Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
} OBSPARSEDPATTERNA, *POBSPARSEDPATTERNA;

typedef struct {
    PPARSEDPATTERNW     NodePattern;
    PPARSEDPATTERNW     LeafPattern;
    PWSTR               ExactRoot;
    DWORD               ExactRootBytes;
    PCWSTR              Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
} OBSPARSEDPATTERNW, *POBSPARSEDPATTERNW;

//
// APIs
//

BOOL
ObsInitialize (
    VOID
    );

VOID
ObsTerminate (
    VOID
    );

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    );

VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    );

BOOL
ObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PSTR* DecodedNode,          OPTIONAL
    OUT     PSTR* DecodedLeaf,          OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringA(o,n,l)    ObsSplitObjectStringExA(o,n,l,NULL,TRUE)

BOOL
ObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PWSTR* DecodedNode,         OPTIONAL
    OUT     PWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringW(o,n,l)    ObsSplitObjectStringExW(o,n,l,NULL,TRUE)

PSTR
ObsBuildEncodedObjectStringFromPatternA (
    IN      POBSPARSEDPATTERNA Pattern
    );

PWSTR
ObsBuildEncodedObjectStringFromPatternW (
    IN      POBSPARSEDPATTERNW Pattern
    );

PSTR
ObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringA(node,leaf) ObsBuildEncodedObjectStringExA(node,leaf,FALSE)

PWSTR
ObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringW(node,leaf) ObsBuildEncodedObjectStringExW(node,leaf,FALSE)

POBSPARSEDPATTERNA
ObsCreateParsedPatternExA (
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternA(obj)        ObsCreateParsedPatternExA (obj,FALSE)

POBSPARSEDPATTERNW
ObsCreateParsedPatternExW (
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternW(obj)        ObsCreateParsedPatternExW (obj,FALSE)

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    );

VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    );

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    );

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf                         OPTIONAL
    );

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    );

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    );

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    );

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    );

//
// Macros
//

#ifdef UNICODE

#define ObsFree                                 ObsFreeW
#define ObsSplitObjectString                    ObsSplitObjectStringW
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExW
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternW
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExW
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringW
#define ObsCreateParsedPattern                  ObsCreateParsedPatternW
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExW
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternW
#define ObsParsedPatternMatch                   ObsParsedPatternMatchW
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExW
#define ObsPatternMatch                         ObsPatternMatchW
#define ObsIsPatternContained                   ObsIsPatternContainedW
#define ObsGetPatternLevels                     ObsGetPatternLevelsW
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternW

#else

#define ObsFree                                 ObsFreeA
#define ObsSplitObjectString                    ObsSplitObjectStringA
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExA
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternA
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExA
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringA
#define ObsCreateParsedPattern                  ObsCreateParsedPatternA
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExA
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternA
#define ObsParsedPatternMatch                   ObsParsedPatternMatchA
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExA
#define ObsPatternMatch                         ObsPatternMatchA
#define ObsIsPatternContained                   ObsIsPatternContainedA
#define ObsGetPatternLevels                     ObsGetPatternLevelsA
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

/*++

  Create and destroy routines:

    PMHANDLE
    PmCreatePool (
        VOID
        );

    PMHANDLE
    PmCreateNamedPool (
        IN      PCSTR Name
        );

    VOID
    PmDestroyPool (
        IN      PMHANDLE Handle
        );

  Primitive routines:

    PVOID
    PmGetMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PmGetAlignedMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PmReleaseMemory (
        IN      PMHANDLE Handle,
        IN      PCVOID Memory
        );

  Performance and debugging control:

    VOID
    PmSetMinimumGrowthSize (
        IN      PMHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PmEmptyPool (
        IN      PMHANDLE Handle
        );

    VOID
    PmDisableTracking (
        IN      PMHANDLE Handle
        );

  Allocation and duplication of data types:

    PCTSTR
    PmCreateString (
        IN      PMHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PmCreateDword (
        IN      PMHANDLE Handle
        );

    PBYTE
    PmDuplicateMemory (
        IN      PMHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PmDuplciateDword (
        IN      PMHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PmDuplicateString (
        IN      PMHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PmDuplicateMultiSz (
        IN      PMHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PmSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PmReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

PMHANDLE
RealPmCreatePool (
    VOID
    );

#define PmCreatePool()              TRACK_BEGIN(PMHANDLE, PmCreatePool)\
                                    RealPmCreatePool()\
                                    TRACK_END()

#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPool (
    IN      PCSTR Name
    );

#define PmCreateNamedPool(n)        TRACK_BEGIN(PMHANDLE, PmCreateNamedPool)\
                                    RealPmCreateNamedPool(n)\
                                    TRACK_END()
#else

#define PmCreateNamedPool(x) PmCreatePool()

#endif

VOID
PmDestroyPool (
    IN PMHANDLE Handle
    );


//
// Callers should use PmGetMemory or PmGetAlignedMemory. These each decay into
// RealPmGetMemory.
//

PVOID
RealPmGetMemory (
    IN      PMHANDLE Handle,
    IN      SIZE_T Size,
    IN      DWORD AlignSize
    );

#define PmGetMemory(h,s)           TRACK_BEGIN(PVOID, PmGetMemory)\
                                   RealPmGetMemory((h),(s),sizeof(DWORD_PTR))\
                                   TRACK_END()

#define PmGetAlignedMemory(h,s)    TRACK_BEGIN(PVOID, PmGetAlignedMemory)\
                                   RealPmGetMemory((h),(s),sizeof(DWORD_PTR))\
                                   TRACK_END()

VOID PmReleaseMemory (IN PMHANDLE Handle, IN PCVOID Memory);
VOID PmSetMinimumGrowthSize(IN PMHANDLE Handle, IN SIZE_T Size);


VOID
PmEmptyPool (
    IN      PMHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PmCreateString(h,x) ((LPTSTR) PmGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PmCreateDword(h)    ((PDWORD) PmGetMemory((h),sizeof(DWORD_PTR)))


__inline
PBYTE
PmDuplicateMemory (
    IN PMHANDLE Handle,
    IN PCBYTE DataToCopy,
    IN UINT SizeOfData
    )
{
    PBYTE Data;

    Data = (PBYTE) PmGetAlignedMemory (Handle, SizeOfData);
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD
PmDuplicateDword (
    IN PMHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PmGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPmDuplicateStringA (
    IN PMHANDLE Handle,
    IN PCSTR StringToCopy
    )

{
    PSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringA (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyA (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringA(h,s)    TRACK_BEGIN(PSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringA(h,s)\
                                   TRACK_END()


__inline
PWSTR
RealPmDuplicateStringW (
    IN PMHANDLE Handle,
    IN PCWSTR StringToCopy
    )

{
    PWSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringW (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyW (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringW(h,s)    TRACK_BEGIN(PWSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringW(h,s)\
                                   TRACK_END()


__inline
PSTR
RealPmDuplicateStringABA (
    IN PMHANDLE Handle,
    IN PCSTR StringStart,
    IN PCSTR End
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    // cast is OK, we don't expenct pointers to be far away from each other
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (CHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABA (rString, StringStart, End);
    }

    return rString;
}

#define PmDuplicateStringABA(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABA)\
                                        RealPmDuplicateStringABA(h,s,e)\
                                        TRACK_END()



__inline
PWSTR
RealPmDuplicateStringABW (
    IN PMHANDLE Handle,
    IN PCWSTR StringStart,
    IN PCWSTR End
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (WCHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABW (rString,StringStart,End);
    }

    return rString;
}

#define PmDuplicateStringABW(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABW)\
                                        RealPmDuplicateStringABW(h,s,e)\
                                        TRACK_END()


PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    );

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    );

#ifdef UNICODE
#define PmDuplicateString  PmDuplicateStringW
#define PmDuplicateMultiSz PmDuplicateMultiSzW
#else
#define PmDuplicateString  PmDuplicateStringA
#define PmDuplicateMultiSz PmDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    );

#else

#define PmDisableTracking(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\sandbox.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sandbox.h

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

#define SB_CLOSE        0x0100

//
// Macros
//

// None

//
// Types
//

typedef void * SBHANDLE;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

// None

//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <mbstring.h>
#include <wchar.h>

typedef PVOID PMHANDLE;

#pragma once

#define MAX_ENCODED_RULE    (256*6)
#define NODE_LEVEL_MAX      ((DWORD)-1)

#define SHIFTRIGHT8(l)  (/*lint --e(506)*/sizeof(l)<=1?0:l>>8)
#define SHIFTRIGHT16(l) (/*lint --e(506)*/sizeof(l)<=2?0:l>>16)
#define SHIFTRIGHT32(l) (/*lint --e(506)*/sizeof(l)<=4?0:l>>32)

extern CHAR EscapedCharsA[];
extern WCHAR EscapedCharsW[];

//
// String sizing routines and unit conversion
//

#define CharCountA(x)   ((DWORD)_mbslen(x))
#define CharCountW(x)   ((DWORD)wcslen(x))

#define SIZEOF(x)       ((DWORD)sizeof(x))

__inline
PSTR
CharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = _mbsinc (String);
    }

    return (PSTR) String;
}

__inline
PWSTR
CharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
CharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
CharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((UBINT) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((UBINT) Start + Bytes);

    if (Start < EndPlusOne) {
        //cast is OK, we don't expect pointers to be that far
        return (UINT)(EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
CharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT CharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = CharCountToPointerA (Start, CharCount);
    //cast is OK, we don't expect pointers to be that far
    return (UINT)(EndPlusOne - Start);
}

__inline
UINT
CharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount * SIZEOF (WCHAR);
}

#define CharCountToTcharsA   CharCountToBytesA

__inline
UINT
CharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount;
}


#define ByteCountA(x)       ((DWORD)strlen(x))
#define ByteCountW(x)       ((DWORD)wcslen(x)*SIZEOF(WCHAR))

#define SizeOfStringA(str)  ((DWORD)ByteCountA(str) + SIZEOF (CHAR))
#define SizeOfStringW(str)  ((DWORD)ByteCountW(str) + SIZEOF (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((UBINT) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((UBINT) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * SIZEOF (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return CharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((UBINT) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / SIZEOF (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * SIZEOF (WCHAR);
}

VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    );

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    );

#define StackStringCopyA(stackbuf,src)                  StringCopyByteCountA(stackbuf,src,SIZEOF(stackbuf))
#define StackStringCopyW(stackbuf,src)                  StringCopyByteCountW(stackbuf,src,SIZEOF(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    );

#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountA(str1,str2,bytes)        _mbsncmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          StringMatchABA(str1,str2,(PCSTR)((PBYTE)(str2) + bytes))
#define StringMatchByteCountW(str1,str2,bytes)          (wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringICompareByteCountA(str1,str2,bytes)       _mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (_mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareCharCountA(str1,str2,chars)        _mbsncmp(str1,str2,chars)
#define StringCompareCharCountW(str1,str2,chars)        wcsncmp(str1,str2,chars)

#define StringMatchCharCountA(str1,str2,chars)          (_mbsncmp(str1,str2,chars)==0)
#define StringMatchCharCountW(str1,str2,chars)          (wcsncmp(str1,str2,chars)==0)

#define StringICompareCharCountA(str1,str2,chars)       _mbsnicmp(str1,str2,chars)
#define StringICompareCharCountW(str1,str2,chars)       _wcsnicmp(str1,str2,chars)

#define StringIMatchCharCountA(str1,str2,chars)         (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchCharCountW(str1,str2,chars)         (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      StringMatchByteCountA(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringMatchTcharCountA(str1,str2,tchars)        (_mbsncmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringICompareTcharCountA(str1,str2,tchars)     _mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringIMatchTcharCountA(str1,str2,tchars)       (_mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

BOOL
StringMatchABA (
    IN      PCSTR String1,
    IN      PCSTR Start,
    IN      PCSTR End
    );

#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines
//

VOID
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

VOID
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );

VOID
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

#define StringCopyCharCountA(str1,str2,chars)           StringCopyByteCountA(str1,str2,CharCountToBytesA(str2,chars))
#define StringCopyCharCountW(str1,str2,chars)           StringCopyByteCountW(str1,str2,CharCountToBytesW(str2,chars))

#define StringCopyTcharCountA(str1,str2,tchars)         StringCopyByteCountA(str1,str2,TcharCountToBytesA(str2,tchars))
#define StringCopyTcharCountW(str1,str2,tchars)         StringCopyByteCountW(str1,str2,TcharCountToBytesW(str2,tchars))

#define StringCopyABA(dest,stra,strb)                   StringCopyByteCountA((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(CHAR)))
#define StringCopyABW(dest,stra,strb)                   StringCopyByteCountW((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(WCHAR)))

//
// String cat routines
//

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );


//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = _mbsinc (MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/SIZEOF(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   TRACK_BEGIN(PSTR, AllocTextExA)\
                            RealAllocTextExA(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextExW(p,s)   TRACK_BEGIN(PWSTR, AllocTextExW)\
                            RealAllocTextExW(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextA(s)       AllocTextExA(NULL,(UINT)(s))
#define AllocTextW(s)       AllocTextExW(NULL,(UINT)(s))



VOID
FreeTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   TRACK_BEGIN(PSTR, DuplicateTextExA)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextExW(p,t,c,n)   TRACK_BEGIN(PWSTR, DuplicateTextExW)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PSTR, JoinTextExA)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextExW(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PWSTR, JoinTextExW)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    TRACK_BEGIN(PSTR, ExpandEnvironmentTextExA)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextExW(str,ev)    TRACK_BEGIN(PWSTR, ExpandEnvironmentTextExW)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)

//
// Function wraps IsDBCSLeadByte(), which tests ACP. Do not use
// isleadbyte().
//
#define IsLeadByte(b)   IsDBCSLeadByte(b)

//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version checks for wacks at the begin/end of each segment so they are properly joined
//
PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define JoinPathsInPoolExA(x)   TRACK_BEGIN(PSTR, JoinPathsInPoolExA)\
                                RealJoinPathsInPoolExA x\
                                TRACK_END()

#define JoinPathsInPoolExW(x)   TRACK_BEGIN(PWSTR, JoinPathsInPoolExW)\
                                RealJoinPathsInPoolExW x\
                                TRACK_END()

//
// for backwards compatibility, JoinPaths expands to JoinPathsInPoolEx
// and NOT to JoinPathsEx which uses a growbuffer instead
//
#define JoinPathsA(p1,p2)               JoinPathsInPoolExA((NULL,p1,p2,NULL))
#define JoinPathsW(p1,p2)               JoinPathsInPoolExW((NULL,p1,p2,NULL))


BOOL
_cdecl
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version does NOT check for wacks at the begin/end of each segment
//
PSTR
_cdecl
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define BuildPathInPoolA(x)   TRACK_BEGIN(PSTR, BuildPathInPoolA)\
                              RealBuildPathInPoolA x\
                              TRACK_END()

#define BuildPathInPoolW(x)   TRACK_BEGIN(PWSTR, BuildPathInPoolW)\
                              RealBuildPathInPoolW x\
                              TRACK_END()


DWORD
_cdecl
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

DWORD
_cdecl
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

BOOL
_cdecl
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    );


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Tchars);
PWSTR   RealAllocPathStringW (IN DWORD Tchars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     TRACK_BEGIN(PSTR, AllocPathStringA)\
                                    RealAllocPathStringA(chars)\
                                    TRACK_END()

#define AllocPathStringW(chars)     TRACK_BEGIN(PWSTR, AllocPathStringW)\
                                    RealAllocPathStringW(chars)\
                                    TRACK_END()

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathA)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    TRACK_END()

#define SplitPathW(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathW)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    TRACK_END()

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   TRACK_BEGIN(PSTR, DuplicatePathStringA)\
                                        RealDuplicatePathStringA(path,eb)\
                                        TRACK_END()

#define DuplicatePathStringW(path,eb)   TRACK_BEGIN(PWSTR, DuplicatePathStringW)\
                                        RealDuplicatePathStringW(path,eb)\
                                        TRACK_END()

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

PCSTR
FindLastWackA (
    IN      PCSTR Str
    );

PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    );

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );


// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR   EncodeRuleCharsA (PSTR szEncRule, PCSTR szRule);
PWSTR  EncodeRuleCharsW (PWSTR szEncRule, PCWSTR szRule);

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

BOOL IsPatternContainedA (PCSTR Container, PCSTR Contained);
BOOL IsPatternContainedW (PCWSTR Container, PCWSTR Contained);


//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct {
    UINT PatternCount;
    PMHANDLE Pool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct {
    UINT PatternCount;
    PMHANDLE Pool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    );

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
ExplodeParsedPatternA (
    IN      PPARSEDPATTERNA Pattern
    );

PPARSEDPATTERNW
ExplodeParsedPatternW (
    IN      PPARSEDPATTERNW Pattern
    );

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    );

PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    );

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    );

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    );

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

__inline
BOOL
ParsedPatternIsExactMatchA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternIsExactMatchW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalA (
    IN      PSEGMENTA ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalW (
    IN      PSEGMENTW ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternIsOptionalA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsOptionalW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsRootPlusStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternIsRootPlusStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternHasRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternHasRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
PCSTR
ParsedPatternGetRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
PCWSTR
ParsedPatternGetRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
BOOL
ParsedPatternEndsWithStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalA (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

__inline
BOOL
ParsedPatternEndsWithStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalW (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    );

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    );


// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER RealCreateAllocTable (VOID);

#define CreateAllocTable()      TRACK_BEGIN(PGROWBUFFER, CreateAllocTable)\
                                RealCreateAllocTable()\
                                TRACK_END()


VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) _mbsnextc(CharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *CharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (CharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *CharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return _mbsdec(base,p);
}


// Routine that checks string for a prefix
#define _mbsprefixcmp(str,prefix) _mbsncmp(str,prefix,_mbslen(prefix))
#define _mbsprefixicmp(str,prefix) _mbsnicmp(str,prefix,_mbslen(prefix))
#define _wcsprefixcmp(str,prefix) _wcsncmp(str,prefix,_mbslen(prefix))
#define _wcsprefixicmp(str,prefix) _wcsnicmp(str,prefix,_mbslen(prefix))

//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

BOOL AddInfSectionToHashTableA (PVOID, HINF, PCSTR, DWORD, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToHashTableW (PVOID, HINF, PCWSTR, DWORD, ADDINFSECTION_PROCW, PVOID);


UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );


VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToU64(str)     StringToUint64A(str,NULL)

ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToU64(str)     StringToUint64W(str,NULL)

LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToI64(str)     StringToInt64A(str,NULL)

LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToI64(str)     StringToInt64W(str,NULL)

//
// TCHAR mappings
//

#ifdef UNICODE

#define EscapedChars                EscapedCharsW
#define CharCount                   CharCountW
#define CharCountToPointer          CharCountToPointerW
#define CharCountAB                 CharCountABW
#define CharCountInByteRange        CharCountInByteRangeW
#define CharCountToBytes            CharCountToBytesW
#define CharCountToTchars           CharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareCharCount      StringCompareCharCountW
#define StringMatchCharCount        StringMatchCharCountW
#define StringICompareCharCount     StringICompareCharCountW
#define StringIMatchCharCount       StringIMatchCharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyCharCount         StringCopyCharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define _tcsprefixcmp               _wcsprefixcmp
#define _tcsprefixicmp              _wcsprefixicmp
#define _tcsctrim                   _wcsctrim

#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPaths                   JoinPathsW
#define JoinPathsInPoolEx           JoinPathsInPoolExW
#define JoinPathsEx                 JoinPathsExW
#define BuildPathInPool             BuildPathInPoolW
#define BuildPath                   BuildPathW
#define BuildPathEx                 BuildPathExW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW
#define FindLastWack                FindLastWackW
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW
#define IsPatternContained          IsPatternContainedW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define CreateParsedPattern         CreateParsedPatternW
#define WildCharsPattern            WildCharsPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define IsPatternMatchExAB          IsPatternMatchExABW
#define ExplodeParsedPattern        ExplodeParsedPatternW
#define IsPatternContainedEx        IsPatternContainedExW
#define IsParsedPatternContainedEx  IsParsedPatternContainedExW
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DecodeParsedPattern         DecodeParsedPatternW
#define PatternIncludesPattern      PatternIncludesPatternW
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeW
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchW
#define ParsedPatternIsOptional     ParsedPatternIsOptionalW
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarW
#define ParsedPatternHasRoot        ParsedPatternHasRootW
#define ParsedPatternGetRoot        ParsedPatternGetRootW
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalW
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarW
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#define AddInfSectionToHashTable    AddInfSectionToHashTableW
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#define StringToUint64              StringToUint64W
#define TToU64                      WToU64
#define StringToInt64               StringToInt64W
#define TToI64                      WToI64

#else

#define EscapedChars                EscapedCharsA
#define CharCount                   CharCountA
#define CharCountToPointer          CharCountToPointerA
#define CharCountAB                 CharCountABA
#define CharCountInByteRange        CharCountInByteRangeA
#define CharCountToBytes            CharCountToBytesA
#define CharCountToTchars           CharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareCharCount      StringCompareCharCountA
#define StringMatchCharCount        StringMatchCharCountA
#define StringICompareCharCount     StringICompareCharCountA
#define StringIMatchCharCount       StringIMatchCharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyCharCount         StringCopyCharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    _mbsdec2
#define _copytchar                  _copymbchar
#define _settchar                   _setmbchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define _tcsprefixcmp               _mbsprefixcmp
#define _tcsprefixicmp              _mbsprefixicmp
#define _tcsctrim                   _mbsctrim

#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPaths                   JoinPathsA
#define JoinPathsInPoolEx           JoinPathsInPoolExA
#define JoinPathsEx                 JoinPathsExA
#define BuildPathInPool             BuildPathInPoolA
#define BuildPath                   BuildPathA
#define BuildPathEx                 BuildPathExA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA
#define FindLastWack                FindLastWackA
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define EnumPathAbort               EnumPathAbortA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA
#define IsPatternContained          IsPatternContainedA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define CreateParsedPattern         CreateParsedPatternA
#define WildCharsPattern            WildCharsPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define IsPatternMatchExAB          IsPatternMatchExABA
#define ExplodeParsedPattern        ExplodeParsedPatternA
#define IsPatternContainedEx        IsPatternContainedExA
#define IsParsedPatternContainedEx  IsParsedPatternContainedExA
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA
#define DecodeParsedPattern         DecodeParsedPatternA
#define PatternIncludesPattern      PatternIncludesPatternA
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeA
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchA
#define ParsedPatternIsOptional     ParsedPatternIsOptionalA
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarA
#define ParsedPatternHasRoot        ParsedPatternHasRootA
#define ParsedPatternGetRoot        ParsedPatternGetRootA
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalA
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarA
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#define AddInfSectionToHashTable    AddInfSectionToHashTableA
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#define StringToUint64              StringToUint64A
#define TToU64                      AToU64
#define StringToInt64               StringToInt64A
#define TToI64                      AToI64

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\regenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.h

Abstract:

    Set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

#define REGENUM_ALL_SUBLEVELS   0xFFFFFFFF

#define REG_ATTRIBUTE_KEY       0x00000001
#define REG_ATTRIBUTE_VALUE     0x00000002

//
// Root enumeration structures
//

typedef struct {
    PCSTR   RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMA, *PREGROOT_ENUMA;

typedef struct {
    PCWSTR  RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMW, *PREGROOT_ENUMW;

//
// Key/Values enumeration structures
//

typedef enum {
    RECF_SKIPKEY                = 0x0001,
    RECF_SKIPSUBKEYS            = 0x0002,
    RECF_SKIPVALUES             = 0x0004,
} REGENUM_CONTROLFLAGS;

typedef enum {
    REIF_RETURN_KEYS            = 0x0001,
    REIF_VALUES_FIRST           = 0x0002,
    REIF_DEPTH_FIRST            = 0x0004,
    REIF_USE_EXCLUSIONS         = 0x0008,
} REGENUMINFOFLAGS;

typedef enum {
    RNS_ENUM_INIT,
    RNS_VALUE_FIRST,
    RNS_VALUE_NEXT,
    RNS_VALUE_DONE,
    RNS_SUBKEY_FIRST,
    RNS_SUBKEY_NEXT,
    RNS_SUBKEY_DONE,
    RNS_ENUM_DONE
} RNS_ENUM_STATE;

typedef enum {
    RES_ROOT_FIRST,
    RES_ROOT_NEXT,
    RES_ROOT_DONE
} RES_ROOT_STATE;


typedef enum {
    RNF_RETURN_KEYS         = 0x0001,
    RNF_KEYNAME_MATCHES     = 0x0002,
    RNF_VALUENAME_INVALID   = 0x0004,
    RNF_VALUEDATA_INVALID   = 0x0008,
} REGNODE_FLAGS;

typedef struct {
    PCSTR   KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PSTR    ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PSTR    SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEA, *PREGNODEA;

typedef struct {
    PCWSTR  KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PWSTR   ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PWSTR   SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEW, *PREGNODEW;

typedef BOOL (*RPE_ERROR_CALLBACKA)(PREGNODEA);

typedef struct {
    POBSPARSEDPATTERNA      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKA     CallbackOnError;
} REGENUMINFOA, *PREGENUMINFOA;

typedef BOOL (*RPE_ERROR_CALLBACKW)(PREGNODEW);

typedef struct {
    POBSPARSEDPATTERNW      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKW     CallbackOnError;
} REGENUMINFOW, *PREGENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    PBYTE           CurrentValueData;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOA    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMA  RootEnum;
    PREGNODEA       LastNode;
    PSTR            RegNameAppendPos;
    PSTR            LastWackPtr;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    PBYTE           CurrentValueData;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOW    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMW  RootEnum;
    PREGNODEW       LastNode;
    PWSTR           RegNameAppendPos;
    PWSTR           LastWackPtr;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// API
//

BOOL
RegEnumInitialize (
    VOID
    );

VOID
RegEnumTerminate (
    VOID
    );

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    );

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    );

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeA(e,p)  EnumFirstRegObjectInTreeExA(e,p,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,RegEnumDefaultCallbackA)

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedKeyPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeW(e,p)  EnumFirstRegObjectInTreeExW(e,p,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,RegEnumDefaultCallbackW)

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

VOID
AbortEnumRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

VOID
AbortEnumRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );


//
// Macros
//

#ifdef UNICODE

#define RegEnumDefaultCallback      RegEnumDefaultCallbackW
#define REGROOT_ENUM                REGROOT_ENUMW
#define EnumFirstRegRoot            EnumFirstRegRootW
#define EnumNextRegRoot             EnumNextRegRootW
#define REGNODE                     REGNODEW
#define PREGNODE                    PREGNODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define REGENUMINFO                 REGENUMINFOW
#define PREGENUMINFO                PREGENUMINFOW
#define REGTREE_ENUM                REGTREE_ENUMW
#define PREGTREE_ENUM               PREGTREE_ENUMW
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeW
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExW
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeW
#define AbortEnumRegObjectInTree    AbortEnumRegObjectInTreeW

#else

#define RegEnumDefaultCallback      RegEnumDefaultCallbackA
#define REGROOT_ENUM                REGROOT_ENUMA
#define EnumFirstRegRoot            EnumFirstRegRootA
#define EnumNextRegRoot             EnumNextRegRootA
#define REGNODE                     REGNODEA
#define PREGNODE                    PREGNODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define REGENUMINFO                 REGENUMINFOA
#define PREGENUMINFO                PREGENUMINFOA
#define REGTREE_ENUM                REGTREE_ENUMA
#define PREGTREE_ENUM               PREGTREE_ENUMA
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeA
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExA
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeA
#define AbortEnumRegObjectInTree    AbortEnumRegObjectInTreeA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)


//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) TRACK_BEGIN(PBYTE, GetRegValueDataA)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) TRACK_BEGIN(PBYTE,GetRegValueDataW)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeA)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeW)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataA)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataW)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) TRACK_BEGIN(PBYTE, GetRegDataA)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  TRACK_END()

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   TRACK_BEGIN(PBYTE, GetRegDataW)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );


#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    When specific conversion is needed, use:

        unicode = ConvertAtoW (ansi) / FreeConvertedStr (unicode)
        ansi = ConvertWtoA (unicode) / FreeConvertedStr (ansi)

        KnownSizeAtoW (ansi,unicode)
        KnownSizeWtoA (unicode,ansi)

    When TCHAR conversion is needed, use:

        ansi = CreateDbcs (tchar) / DestroyDbcs (ansi)
        unicode = CreateUnicode (tchar) / DestroyUnicode (unicode)
        tchar = ConvertAtoT (ansi) / FreeAtoT (tchar)
        tchar = ConvertWtoT (ansi) / FreeWtoT (tchar)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );


#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    );

#define UnicodeToDbcsN(p,s,c)       TRACK_BEGIN(PCSTR, UnicodeToDbcsN)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    TRACK_END()

#define DbcsToUnicodeN(p,s,c)       TRACK_BEGIN(PCWSTR, DbcsToUnicodeN)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    TRACK_END()

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,(DWORD)wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,CharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,(DWORD)wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,CharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD CharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD CharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#ifdef UNICODE

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW
#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA
#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\utiltypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    utiltypes.h

Abstract:

    Defines types used by utilities

Author:

    Jim Schmidt (jimschm) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef PVOID PMHANDLE;
typedef struct TAG_GROWBUFFER *PGROWBUFFER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\version.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.h

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MAX_TRANSLATION             32

//
// Macros
//

// None

//
// Types
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VRVALUE_ENUMA, *PVRVALUE_ENUMA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VRVALUE_ENUMW, *PVRVALUE_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    );

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    );

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    );

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    );

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileVersionW(VrValueEnum)    VrGetBinaryFileVersionA((PVRVALUE_ENUMW)VrValueEnum)

ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryProductVersionW(VrValueEnum) VrGetBinaryProductVersionA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileDateLoW(VrValueEnum) VrGetBinaryFileDateLoA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileDateHiW(VrValueEnum) VrGetBinaryFileDateHiA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryOsVersionW(VrValueEnum)      VrGetBinaryOsVersionA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileTypeW(VrValueEnum)   VrGetBinaryFileTypeA((PVRVALUE_ENUMW)VrValueEnum)

#ifndef UNICODE

#define VRVALUE_ENUM                    VRVALUE_ENUMA
#define PVRVALUE_ENUM                   PVRVALUE_ENUMA
#define VrCreateEnumStruct              VrCreateEnumStructA
#define VrDestroyEnumStruct             VrDestroyEnumStructA
#define VrEnumFirstValue                VrEnumFirstValueA
#define VrEnumNextValue                 VrEnumNextValueA
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionA
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionA
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoA
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiA
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionA
#define VrGetBinaryFileType             VrGetBinaryFileTypeA

#else

#define VRVALUE_ENUM                    VRVALUE_ENUMW
#define PVRVALUE_ENUM                   PVRVALUE_ENUMW
#define VrCreateEnumStruct              VrCreateEnumStructW
#define VrDestroyEnumStruct             VrDestroyEnumStructW
#define VrEnumFirstValue                VrEnumFirstValueW
#define VrEnumNextValue                 VrEnumNextValueW
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionW
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionW
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoW
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiW
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionW
#define VrGetBinaryFileType             VrGetBinaryFileTypeW

#endif

//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\basereg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    <filename>

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\inc\wnd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.h

Abstract:

    The header file for Window utility routines.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

HWND
FindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle           OPTIONAL
    );

HWND
FindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    );


//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\basemem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    basemem.c

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.c and main.c

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

--*/


#include "pch.h"


//
// Includes
//

#include "utilsp.h"


//
// Constants
//

#ifdef DEBUG

#define TRAIL_SIG               0x708aa210
#define TRACK_SIGNATURE         0x30405060

#endif

//
// Macros
//

#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))


//
// Types
//

#ifdef DEBUG

typedef struct _tagTRACKSTRUCT {

    DWORD Signature;
    PCSTR File;
    DWORD Line;
    SIZE_T Size;
    PSTR Comment;
    PCSTR CallerFile;
    DWORD CallerLine;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;

} TRACKSTRUCT, *PTRACKSTRUCT;

#endif

//
// Globals
//

#ifdef DEBUG

PTRACKSTRUCT g_TrackHead = NULL;

#endif

//
// Heap debug statistics
//

static SIZE_T g_TotalBytesAllocated = 0;
static SIZE_T g_MaxBytesInUse = 0;
static SIZE_T g_HeapAllocs = 0;
static SIZE_T g_HeapReAllocs = 0;
static SIZE_T g_HeapFrees = 0;
static SIZE_T g_HeapAllocFails = 0;
static SIZE_T g_HeapReAllocFails = 0;
static SIZE_T g_HeapFreeFails = 0;

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
HWND g_OutOfMemoryParentWnd;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

#ifdef DEBUG

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );



VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    );

VOID
pTrackDelete (
    PTRACKSTRUCT p
    );

VOID
pWriteTrackLog (
    VOID
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//



void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    strcat (Msg2, Msg);
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}

#ifdef DEBUG

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T rc;

    EnterOurCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveOurCriticalSection (&g_MemAllocCs);

    return rc;
}

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  This address is not valid.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    size = HeapSize (hHeap, 0, RealPtr);
    if (size == (SIZE_T)-1) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  "
                "This address is not the start of a memory block.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    return size;
}

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD TrackStructSize;
    DWORD OrgError;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapAllocFails++;
            __leave;
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_HeapAllocs++;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    UBINT lastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD OrgError;
    DWORD TrackStructSize;
    SIZE_T OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapReAllocFails++;
            __leave;
        }

        lastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (lastSize == (UBINT)INVALID_PTR) {
            g_HeapReAllocFails++;
            __leave;
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_HeapReAllocs++;
            g_TotalBytesAllocated -= lastSize;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    UBINT size;
    PCVOID RealPtr;
    DWORD SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (size == (UBINT)INVALID_PTR) {
            g_HeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            wsprintf (BadPtrMsg,
                      "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                      "HeapFree() failed.",
                      CallerPtr, Flags);

            HeapCallFailed (BadPtrMsg, File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        g_HeapFrees++;
        if (g_TotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_TotalBytesAllocated = 0;
        } else {
            g_TotalBytesAllocated -= size;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return Result;

}

VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    pWriteTrackLog();

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_TotalBytesAllocated,
               g_MaxBytesInUse,
               g_HeapAllocs,
               g_HeapReAllocs,
               g_HeapFrees
               );

    if (g_HeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_HeapAllocFails);
    }
    if (g_HeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_HeapReAllocFails);
    }
    if (g_HeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_HeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterOurCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveOurCriticalSection (&g_MemAllocCs);
}

#endif

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is a bad thing, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    MessageBox (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        NULL,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    //
    // Not needed, will never get here
    //
    // TerminateProcess (GetModuleHandle (NULL), 0);
}

VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBox (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    NULL,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    }
}

PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

#ifdef DEBUG

VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    p->File      = File;
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = g_TrackHead;
    p->CallerFile = g_TrackFile;
    p->CallerLine = g_TrackLine;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (g_TrackHead) {
        g_TrackHead->PrevAlloc = p;
    }

    g_TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        g_TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
}

VOID
pWriteTrackLog (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "?:\\memtrack.log";

    if (!g_TrackHead) {
        return;
    }

    GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
    memtrackLogPath[0] = TempPath[0];

    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {
        Count = 0;
        __try {
            for (p = g_TrackHead ; p ; p = p->NextAlloc) {
                Count++;
                __try {
                    if (p->Comment) {
                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\r\n"
                                    "  %s\r\n"
                                    "  Caller: %s line %u\r\n"
                                    "\r\n",
                                p->File,
                                p->Line,
                                p->Comment,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                        }
                    } else {
                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\r\n"
                                    "  Caller: %s line %u\r\n"
                                    "\r\n",
                                p->File,
                                p->Line,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "(direct alloc) %s line %u\r\n\r\n", p->File, p->Line);
                        }
                    }

                }
                __except (TRUE) {
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", p);
                    BadMem = TRUE;
                }
                WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

                //lint --e(774)
                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }

        wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n", Count, Count == 1 ? "":"s");
        WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\basefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BASEFILE     "File Utils"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}

BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        return GetFileAttributesA (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        return GetFileAttributesW (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileW(FileName,&ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


/*++

Routine Description:

    PathIsDirectory determines if a path identifies an accessible directory.

Arguments:

    PathSpec - Specifies the full path.

Return Value:

    TRUE if the path identifies a directory.
    FALSE if not. GetLastError() returns extended error info.

--*/

BOOL
PathIsDirectoryA (
    IN      PCSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesA (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
PathIsDirectoryW (
    IN      PCWSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesW (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingA (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingW (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}

#if 0
BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - image of the mapped file as returned by MapFileIntoMemory
  MapHandle - handle of the mapping object as returned by MapFileIntoMemory
  FileHandle - handle of the file as returned by MapFileIntoMemory

Return Value:

  TRUE if successfull, FALSE if not

--*/

{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}
#endif

BOOL
BfGetTempFileNameA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    )
{
    CHAR tempPath[MAX_MBCHAR_PATH];
    CHAR tempFile[MAX_MBCHAR_PATH];
    UINT tchars;

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameA (tempPath, "tmp", 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameA (tempPath, "tmp", 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountA (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (CHAR));
    }

    return TRUE;
}


BOOL
BfGetTempFileNameW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars
    )
{
    WCHAR tempPath[MAX_WCHAR_PATH];
    WCHAR tempFile[MAX_WCHAR_PATH];
    UINT tchars;

    if (!GetTempPathW (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameW (tempPath, L"tmp", 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameW (tempPath, L"tmp", 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountW (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (WCHAR));
    }

    return TRUE;
}


HANDLE
BfGetTempFile (
    VOID
    )
{
    CHAR tempFile[MAX_MBCHAR_PATH];
    HANDLE file;

    if (!BfGetTempFileNameA (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }

    file = CreateFile (
                tempFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_DELETE_ON_CLOSE,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        file = NULL;
    }

    return file;
}


BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Offset;

    li.LowPart = SetFilePointer (File, li.LowPart, &li.HighPart, FILE_BEGIN);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    }

    return li.QuadPart != -1;
}


HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle =  CreateFileA (
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;

}

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    )
{
    if (!BfSetFilePointer (File, Size)) {
        return FALSE;
    }

    return SetEndOfFile (File);
}


BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_END);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FileSize) {
        *FileSize = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_CURRENT);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FilePointer) {
        *FilePointer = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    )
{
    DWORD bytesRead;

    if (!ReadFile (File, Buffer, BytesToRead, &bytesRead, NULL)) {
        return FALSE;
    }

    return bytesRead == BytesToRead;
}


BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    )
{
    DWORD bytesWritten;

    if (!WriteFile (File, Buffer, BytesToWrite, &bytesWritten, NULL)) {
        return FALSE;
    }

    return bytesWritten == BytesToWrite;
}


BOOL
BfCreateDirectoryA (
    IN      PCSTR FullPath
    )
{
    PSTR pathCopy;
    PSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringA (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == ':' && pathCopy[2] == '\\') {
        //
        // <drive>:\ case
        //

        p = _mbschr (&pathCopy[3], '\\');

    } else if (pathCopy[0] == '\\' && pathCopy[1] == '\\') {

        //
        // UNC case
        //

        p = _mbschr (pathCopy + 2, '\\');
        if (p) {
            p = _mbschr (p + 1, '\\');
            if (p) {
                p++;
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _mbschr (pathCopy, '\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = '\\';
        p = _mbschr (p + 1, '\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringA (pathCopy);

    return b;
}


BOOL
BfCreateDirectoryW (
    IN      PCWSTR FullPath
    )
{
    PWSTR pathCopy;
    PWSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringW (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == L':' && pathCopy[2] == L'\\') {
        //
        // <drive>:\ case
        //

        p = wcschr (&pathCopy[3], L'\\');

    } else if (pathCopy[0] == L'\\' && pathCopy[1] == L'\\') {

        //
        // UNC case
        //

        p = wcschr (pathCopy + 2, L'\\');
        if (p) {
            p = wcschr (p + 1, L'\\');
            if (p) {
                p++;
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = wcschr (pathCopy, L'\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = L'\\';
        p = wcschr (p + 1, L'\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringW (pathCopy);

    return b;
}


LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    )
{
    WIN32_FIND_DATAA fd;
    LONGLONG l;

    if (!DoesFileExistExA (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

PSTR
pGetFirstSegA (
    IN      PCSTR SrcFileName
    )
{
    if (SrcFileName [0] == '\\') {
        SrcFileName ++;
        if (SrcFileName [0] == '\\') {
            SrcFileName ++;
        }
        return (_mbschr (SrcFileName, '\\'));
    } else {
        return (_mbschr (SrcFileName, '\\'));
    }
}

BOOL
pGetLongFileNameWorkerA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PSTR beginSegPtr;
    PSTR endSegPtr;
    WIN32_FIND_DATAA findData;
    CHAR savedChar;

    beginSegPtr = pGetFirstSegA (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringA (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr = _mbsinc (beginSegPtr);

    GbAppendStringABA (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = _mbschr (beginSegPtr, '\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringA (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExA (SrcFileName, &findData)) {
            GbAppendStringA (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABA (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = _mbsinc (endSegPtr);
            GbAppendStringABA (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PSTR srcFileName;
    PCSTR result = NULL;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    if (pGetLongFileNameWorkerA (srcFileName, &growBuf)) {
        result = DuplicatePathStringA (growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringA (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PSTR srcFileName;
    BOOL result;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    result = pGetLongFileNameWorkerA (srcFileName, GrowBuff);
    FreePathStringA (srcFileName);

    return result;
}

PWSTR
pGetFirstSegW (
    IN      PCWSTR SrcFileName
    )
{
    if (SrcFileName [0] == L'\\') {
        SrcFileName ++;
        if (SrcFileName [0] == L'\\') {
            SrcFileName ++;
        }
        return (wcschr (SrcFileName, L'\\'));
    } else {
        return (wcschr (SrcFileName, L'\\'));
    }
}

BOOL
pGetLongFileNameWorkerW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PWSTR beginSegPtr;
    PWSTR endSegPtr;
    WIN32_FIND_DATAW findData;
    WCHAR savedChar;

    beginSegPtr = pGetFirstSegW (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringW (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr ++;

    GbAppendStringABW (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = wcschr (beginSegPtr, L'\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringW (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExW (SrcFileName, &findData)) {
            GbAppendStringW (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABW (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = endSegPtr + 1;
            GbAppendStringABW (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PWSTR srcFileName;
    PCWSTR result = NULL;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    if (pGetLongFileNameWorkerW (srcFileName, &growBuf)) {
        result = DuplicatePathStringW ((PCWSTR)growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringW (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PWSTR srcFileName;
    BOOL result;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    result = pGetLongFileNameWorkerW (srcFileName, GrowBuff);
    FreePathStringW (srcFileName);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\blobs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    blobs.c

Abstract:

    Implements a set of APIs to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BLOBS       "Blobs"

//
// Strings
//

// None

//
// Constants
//

#define BLOB_SIGNATURE              0x79563442
#define BLOB_GROWDATASIZE_DEFAULT   1024
#define BLOBS_GROWCOUNT_DEFAULT     64
#define BLOBS_SIGNATURE             0x12567841

//
// Macros
//

// None

//
// Types
//

typedef struct {
    DWORD       BlobSignature;
    DWORD       DataSize;
    DWORD       Flags;
} BLOBHDR, *PBLOBHDR;

typedef struct {
    DWORD       BlobsArraySignature;
    DWORD       BlobsCount;
} BLOBSARRAYHDR, *PBLOBSARRAYHDR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


#ifdef DEBUG

#define ASSERT_VALID_BLOB(b)            MYASSERT (pIsValidBlob (b))
#define ASSERT_VALID_BLOBS_ARRAY(a)     MYASSERT (pIsValidBlobsArray (a))

BOOL
pIsValidBlob (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    pIsValidBlob checks if the passed-in blob points to a valid OURBLOB blob structure

Arguments:

    Blob - Specifies a pointer to the blob to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!Blob) {
        return FALSE;
    }

    __try {
        b = !Blob->Data && !Blob->End && !Blob->Index && !Blob->AllocSize ||
            Blob->Data && Blob->AllocSize && Blob->End <= Blob->AllocSize && Blob->Index <= Blob->AllocSize;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

BOOL
pIsValidBlobsArray (
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    pIsValidBlobsArray checks if the passed-in bloba array points to a valid BLOBS array structure

Arguments:

    BlobsArray - Specifies a pointer to the blobs array to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!BlobsArray) {
        return FALSE;
    }

    __try {
        b = !BlobsArray->Blobs && !BlobsArray->BlobsCount && !BlobsArray->BlobsAllocated ||
            BlobsArray->Signature == BLOBS_SIGNATURE &&
            BlobsArray->Blobs &&
            BlobsArray->BlobsAllocated &&
            BlobsArray->BlobsGrowCount &&
            BlobsArray->BlobsCount <= BlobsArray->BlobsAllocated;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#else

#define ASSERT_VALID_BLOB(b)
#define ASSERT_VALID_BLOBS_ARRAY(a)

#endif


PVOID
pBlobAllocateMemory (
    IN      DWORD Size
    )

/*++

Routine Description:

    pBlobAllocateMemory is a private function that allocates space from the process heap

Arguments:

    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (Size);
    return HeapAlloc (g_hHeap, 0, Size);
}


static
PVOID
pReAllocateMemory (
    IN      PVOID OldBuffer,
    IN      DWORD NewSize
    )

/*++

Routine Description:

    pReAllocateMemory is a private function that re-allocates space from the process heap

Arguments:

    OldBuffer - Specifies the buffer to be re-allocated
    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully re-allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (OldBuffer);
    MYASSERT (NewSize);
    return HeapReAlloc (g_hHeap, 0, OldBuffer, NewSize);
}


VOID
pBlobFreeMemory (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pBlobFreeMemory is a private function that frees space allocated from the process heap

Arguments:

    Buffer - Specifies a pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (Buffer);
    HeapFree (g_hHeap, 0, Buffer);
}


POURBLOB
BlobCreate (
    VOID
    )
{
    POURBLOB newBlob;

    newBlob = pBlobAllocateMemory (DWSIZEOF (OURBLOB));
    if (newBlob) {
        ZeroMemory (newBlob, DWSIZEOF (OURBLOB));
    }
    return newBlob;
}


POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    )

/*++

Routine Description:

    BlobDuplicate duplicates the data in the source blob, so the resulting blob will
    have an identical copy of data

Arguments:

    SourceBlob - Specifies the blob source of data

Return Value:

    Pointer to the new blob if duplicate was successful; NULL if not enough memory

--*/

{
    POURBLOB newBlob;
    DWORD dataSize;

    newBlob = BlobCreate ();
    if (newBlob && SourceBlob->Data) {
        dataSize = BlobGetDataSize (SourceBlob);
        newBlob->Data = pBlobAllocateMemory (dataSize);
        if (!newBlob->Data) {
            BlobDestroy (newBlob);
            return NULL;
        }
        newBlob->AllocSize = dataSize;
        newBlob->End = dataSize;
        CopyMemory (newBlob->Data, SourceBlob->Data, dataSize);
        newBlob->Flags = SourceBlob->Flags;
    }
    return newBlob;
}


VOID
BlobClear (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobClear clears the specified blob (frees its associated data)

Arguments:

    Blob - Specifies the blob to clear

Return Value:

    none

--*/

{
    if (Blob && Blob->Data) {
        pBlobFreeMemory (Blob->Data);
        ZeroMemory (Blob, DWSIZEOF (OURBLOB));
    }
}


VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobDestroy destroys the specified blob (frees its associated data and the blob itself)

Arguments:

    Blob - Specifies the blob to destroy

Return Value:

    none

--*/

{
    if (Blob) {
        BlobClear (Blob);
        pBlobFreeMemory (Blob);
    }
}


BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    )

/*++

Routine Description:

    BlobSetIndex sets the current read/write pointer

Arguments:

    Blob - Specifies the blob
    Index - Specifies the new index value

Return Value:

    TRUE if the index move was successful

--*/

{
    ASSERT_VALID_BLOB (Blob);

    if (Index > Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobSetIndex: invalid Index specified (%lu)", Index));
        MYASSERT (FALSE);   //lint !e506
        return FALSE;
    }

    Blob->Index = Index;
    return TRUE;
}


DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobGetRecordedDataType returns the data type recorded at current read position

Arguments:

    Blob - Specifies the blob

Return Value:

    The current data type if the blob records data type and the read position is valid;
    BDT_NONE otherwise

--*/

{
    PBYTE p;

    if (BlobRecordsDataType (Blob)) {
        p = BlobGetPointer (Blob);
        if (p) {
            return *(DWORD*)p;
        }
    }
    return BDT_NONE;
}


BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    )

/*++

Routine Description:

    BlobWriteEx writes data at the current index position, growing the blob if necessary
    and adjusting it's size.

Arguments:

    Blob - Specifies the blob
    DataType - Specifies the type of data to be stored; can be zero only if the blob
               doesn't record data types
    RecordDataSize - Specifies TRUE if this size has to be recorded in the blob
    DataSize - Specifies the size, in bytes, of the data to be stored
    Data - Specifies the data

Return Value:

    TRUE if write was successful; FALSE if not enough memory

--*/

{
    PBYTE p;
    DWORD totalDataSize;
    DWORD growTo;
    DWORD d;

    ASSERT_VALID_BLOB (Blob);
    MYASSERT (DataSize);

    MYASSERT (DataType || !BlobRecordsDataType (Blob));
    if (!DataType && BlobRecordsDataType (Blob)) {
        return FALSE;
    }

    if (!Blob->GrowSize) {
        Blob->GrowSize = BLOB_GROWDATASIZE_DEFAULT;
    }

    totalDataSize = Blob->Index + DataSize;
    if (BlobRecordsDataType (Blob)) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (totalDataSize > Blob->AllocSize) {
        d = totalDataSize + Blob->GrowSize - 1;
        growTo = d - d % Blob->GrowSize;
    } else {
        growTo = 0;
    }

    if (!Blob->Data) {
        Blob->Data = (PBYTE) pBlobAllocateMemory (growTo);
        if (!Blob->Data) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pBlobAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
    } else if (growTo) {
        p = pReAllocateMemory (Blob->Data, growTo);
        if (!p) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pReAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
        Blob->Data = p;
    }

    p = BlobGetPointer (Blob);

    if (BlobRecordsDataType (Blob)) {
        *(PDWORD)p = DataType;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        *(PDWORD)p = DataSize;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }

    CopyMemory (p, Data, DataSize);
    Blob->Index += DataSize;

    //
    // adjust EOF
    //
    if (Blob->Index > Blob->End) {
        Blob->End = Blob->Index;
    }

    return TRUE;
}


PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    )

/*++

Routine Description:

    BlobReadEx reads data from the specified blob, at the current index position

Arguments:

    Blob - Specifies the blob to read from
    ExpectedDataType - Specifies the expected data type; optional
    ExpectedDataSize - Specifies the expected data size; optional
    RecordedDataSize - Specifies TRUE if the data size was recorded in the blob
    ActualDataSize - Receives the actual data size; optional
    Data - Receives the actual data; optional; if NULL, a buffer will be allocated
    Pool - Specifies the pool to use for memory allocations; optional;
           if NULL, the process heap will be used

Return Value:

    A pointer to the buffer containing the data; NULL if an error occured
    or some data conditions don't match

--*/

{
    DWORD initialIndex;
    PBYTE readPtr;
    DWORD actualDataType;
    DWORD actualDataSize = 0;

    ASSERT_VALID_BLOB (Blob);

    readPtr = BlobGetPointer (Blob);
    if (!readPtr) {
        return NULL;
    }

    //
    // data size must be available some way
    //
    MYASSERT (BlobRecordsDataSize (Blob) || RecordedDataSize || ExpectedDataSize);

    initialIndex = BlobGetIndex (Blob);

    if (BlobRecordsDataType (Blob)) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            return NULL;
        }
        //
        // check actual data type
        //
        actualDataType = *(DWORD*)readPtr;

        if (ExpectedDataType && ExpectedDataType != actualDataType) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data type (%lu) different than expected data type (%lu)",
                actualDataType,
                ExpectedDataType
                ));

            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);
    }

    if (BlobRecordsDataSize (Blob) || RecordedDataSize) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
        //
        // read actual data size
        //
        actualDataSize = *(DWORD*)readPtr;

        if (ExpectedDataSize && ExpectedDataSize != actualDataSize) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data size (%lu) different than expected data size (%lu)",
                actualDataSize,
                ExpectedDataSize
                ));

            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);

    } else {
        actualDataSize = ExpectedDataSize;
    }

    if (!actualDataSize) {
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (ActualDataSize) {
        *ActualDataSize = actualDataSize;
    }

    //
    // don't read over end of file
    //
    if (readPtr + actualDataSize > BlobGetEOF (Blob)) {
        //
        // corrupt blob; undo anyway
        //
        MYASSERT (FALSE);   //lint !e506
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (!Data) {

        if (Pool) {
            Data = PmGetMemory (Pool, actualDataSize);
        } else {
            Data = pBlobAllocateMemory (actualDataSize);
        }

        if (!Data) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
    }

    CopyMemory (Data, readPtr, actualDataSize);

    Blob->Index += actualDataSize;

    return Data;
}


BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    )

/*++

Routine Description:

    BlobWriteDword writes a DWORD at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORD

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_DWORD, FALSE, DWSIZEOF (DWORD), &Data);
}


BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    )

/*++

Routine Description:

    BlobReadDword reads a DWORD from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORD

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_DWORD, DWSIZEOF (DWORD), FALSE, NULL, Data, NULL) != NULL;
}


BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    )

/*++

Routine Description:

    BlobWriteQword writes a DWORDLONG at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORDLONG

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_QWORD, FALSE, DWSIZEOF (DWORDLONG), &Data);
}


BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    )

/*++

Routine Description:

    BlobReadQword reads a DWORDLONG from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORDLONG

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_QWORD, DWSIZEOF (DWORDLONG), FALSE, NULL, Data, NULL) != NULL;
}


/*++

Routine Description:

    BlobWriteString writes a string at the current writing position in the specified blob;
    the string is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the string

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PCWSTR unicodeString;
    BOOL b;

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = ConvertAtoW (Data);
        b = BlobWriteStringW (Blob, unicodeString);
        FreeConvertedStr (unicodeString);
        return b;
    }
    return BlobWriteEx (Blob, BDT_SZA, TRUE, SizeOfStringA (Data), Data);
}


BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_SZW, TRUE, SizeOfStringW (Data), Data);
}


/*++

Routine Description:

    BlobReadString reads a string from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_SZA for the ANSI version
    and BDT_SZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated string
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {

        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);

            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }
            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);
                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


/*++

Routine Description:

    BlobWriteMultiSz writes a multisz at the current writing position in the specified blob;
    the multisz is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the multisz

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PWSTR unicodeString;
    BOOL b;
    DWORD stringSize = SizeOfMultiSzA (Data);

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = AllocTextW (stringSize);
        DirectDbcsToUnicodeN (unicodeString, Data, stringSize);
        b = BlobWriteMultiSzW (Blob, unicodeString);
        FreeTextW (unicodeString);
        return b;
    }

    return BlobWriteEx (Blob, BDT_MULTISZA, TRUE, stringSize, Data);
}

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_MULTISZW, TRUE, SizeOfMultiSzW (Data), Data);
}



/*++

Routine Description:

    BlobReadMultiSz reads a multisz from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_MULTISZA for the ANSI version
    and BDT_MULTISZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated multisz
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {
        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);
            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }

            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);

                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


BOOL
BlobWriteBinaryEx (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      BOOL RecordDataSize
    )

/*++

Routine Description:

    BlobWriteBinary writes a buffer at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the source buffer
    Size - Specifies the size of the buffer
    RecordDataSize - Specifies TRUE if data size should be recorded, too

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_BINARY, RecordDataSize, Size, Data);
}


BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool       OPTIONAL
    )

/*++

Routine Description:

    BlobReadBinary reads a buffer from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated buffer
    Size - Receives the size of the buffer
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    *Data = BlobReadEx (Blob, BDT_BINARY, 0, TRUE, Size, NULL, Pool);
    return *Data != NULL;
}


BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobWriteToFile writes the specified blob to the given file

Arguments:

    Blob - Specifies the blob to save
    File - Specifies the handle of the file to write the blob to

Return Value:

    TRUE if blob was successfully written to the file

--*/

{
    BLOBHDR header;
    DWORD d;

    if (!Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobWriteToFile: Did not write empty blob to file"));
        return FALSE;
    }

    //
    // save blob's Flags and End position
    //
    header.BlobSignature = BLOB_SIGNATURE;
    header.DataSize = Blob->End;
    header.Flags = Blob->Flags;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob header!"));
        return FALSE;
    }
    if (!WriteFile (File, Blob->Data, Blob->End, &d, NULL) || d != Blob->End) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob data!"));
        return FALSE;
    }
    return TRUE;
}


BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobReadFromFile reads data from the given file in the specified blob

Arguments:

    Blob - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if blob was successfully read from the file

--*/

{
    BLOBHDR header;
    DWORD d;

    //
    // read blob's Flags and End position
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob header!"));
        return FALSE;
    }

    if (header.BlobSignature != BLOB_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Not a valid blob signature!"));
        return FALSE;
    }

    Blob->Data = pBlobAllocateMemory (header.DataSize);
    if (!Blob->Data) {
        return FALSE;
    }

    if (!ReadFile (File, Blob->Data, header.DataSize, &d, NULL) || d != header.DataSize) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob data!"));
        pBlobFreeMemory (Blob->Data);
        Blob->Data = NULL;
        return FALSE;
    }

    Blob->AllocSize = header.DataSize;
    Blob->End = header.DataSize;
    Blob->Flags = header.Flags;
    Blob->Index = 0;
    return TRUE;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobsAdd adds the specified Blob to a blobs array

Arguments:

    BlobsArray - Specifies the array to add to
    Blob - Specifies the blob to add

Return Value:

    TRUE if the new blob pointer was added successfully

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (!BlobsArray->BlobsGrowCount) {
        BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;
    }

    if (!BlobsArray->Blobs) {

        BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (
                                        BlobsArray->BlobsGrowCount * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            DEBUGMSG ((DBG_ERROR, "BlobsAddE: Initial alloc failed"));
            return FALSE;
        }
        BlobsArray->Signature = BLOBS_SIGNATURE;
        BlobsArray->BlobsAllocated = BlobsArray->BlobsGrowCount;
        BlobsArray->BlobsCount = 0;

    } else if (BlobsArray->BlobsCount == BlobsArray->BlobsAllocated) {

        BlobsArray->BlobsAllocated += BlobsArray->BlobsGrowCount;
        BlobsArray->Blobs = (POURBLOB*)pReAllocateMemory (
                                        BlobsArray->Blobs,
                                        BlobsArray->BlobsAllocated * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            BlobsArray->BlobsAllocated -= BlobsArray->BlobsGrowCount;
            DEBUGMSG ((DBG_ERROR, "BlobsAdd: Realloc failed"));
            return FALSE;
        }
    }

    *(BlobsArray->Blobs + BlobsArray->BlobsCount) = Blob;
    BlobsArray->BlobsCount++;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);
    return TRUE;
}


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    )

/*++

Routine Description:

    BlobsFree destroys the array and optionally destroys all blobs in it

Arguments:

    BlobsArray - Specifies the array to delete
    DestroyBlobs - Specifies TRUE if the component blobs are to be deleted, too

Return Value:

    none

--*/

{
    BLOB_ENUM e;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (DestroyBlobs) {
        if (EnumFirstBlob (&e, BlobsArray)) {
            do {
                BlobDestroy (e.CurrentBlob);
            } while (EnumNextBlob (&e));
        }
    }

    pBlobFreeMemory (BlobsArray->Blobs);
    ZeroMemory (BlobsArray, DWSIZEOF (BLOBS));
}


BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    EnumFirstBlob enumerates the first blob in the given array

Arguments:

    BlobEnum - Receives enum info
    BlobsArray - Specifies the array to enum from

Return Value:

    TRUE if a first blob was found; FALSE if array is empty

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    BlobEnum->Index = 0;
    BlobEnum->Array = BlobsArray;
    return EnumNextBlob (BlobEnum);
}


BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    )

/*++

Routine Description:

    EnumNextBlob enumerates the next blob in the given array

Arguments:

    BlobEnum - Specifies/receives enum info

Return Value:

    TRUE if a next blob was found; FALSE if no more blobs

--*/

{
    if (BlobEnum->Index >= BlobEnum->Array->BlobsCount) {
        return FALSE;
    }

    BlobEnum->CurrentBlob = *(BlobEnum->Array->Blobs + BlobEnum->Index);
    BlobEnum->Index++;
    return TRUE;
}


BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsWriteToFile writes the specified blobs array to the given file

Arguments:

    BlobsArray - Specifies the blobs array to save
    File - Specifies the handle of the file to write the array to

Return Value:

    TRUE if array was successfully written to the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    POURBLOB* blob;

    if (!BlobsArray->BlobsCount) {
        DEBUGMSG ((DBG_BLOBS, "BlobsWriteToFile: Did not write empty blobs array to file"));
        return FALSE;
    }

    //
    // save blobs count
    //
    header.BlobsArraySignature = BLOBS_SIGNATURE;
    header.BlobsCount = BlobsArray->BlobsCount;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsWriteToFile: Error writing blobs array header!"));
        return FALSE;
    }
    for (blob = BlobsArray->Blobs; blob < BlobsArray->Blobs + BlobsArray->BlobsCount; blob++) {
        if (!BlobWriteToFile (*blob, File)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsWriteToFile: Error writing blob # %lu to file",
                blob - BlobsArray->Blobs
                ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsReadFromFile reads data from the given file in the specified blobs array

Arguments:

    BlobsArray - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if array was successfully read from the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    UINT u;
    POURBLOB blob;

    //
    // read blobs count
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Error reading blobs array header!"));
        return FALSE;
    }

    if (header.BlobsArraySignature != BLOBS_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Not a valid blobs array signature!"));
        return FALSE;
    }

    BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (header.BlobsCount * DWSIZEOF (POURBLOB*));
    if (!BlobsArray->Blobs) {
        return FALSE;
    }

    ZeroMemory (BlobsArray->Blobs, header.BlobsCount * DWSIZEOF (POURBLOB));

    BlobsArray->Signature = BLOBS_SIGNATURE;
    BlobsArray->BlobsAllocated = header.BlobsCount;
    BlobsArray->BlobsCount = 0;
    BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;

    for (u = 0; u < header.BlobsCount; u++) {

        blob = BlobCreate ();
        if (!blob) {
            return FALSE;
        }

        if (!BlobReadFromFile (blob, File)) {

            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error reading blob # %lu from file",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }

        if (!BlobsAdd (BlobsArray, blob)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error adding blob # %lu to array",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\dbgtrack.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgtrack.c

Abstract:

    Allocation tracking implementation. From old debug.c

Author:

    Marc R. Whitten  (marcw) 09-Sept-1999

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")



//
// Strings
//

// None

//
// Constants
//

#define TRACK_BUCKETS           1501
#define BUCKET_ITEMS_PER_POOL   8192




//
// Macros
//

// None

//
// Types
//

typedef UBINT ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;


typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;




//
// Globals
//

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];
PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//
PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
INT g_UseCount;
UINT g_DisableTrackComment = 0;
GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}



PBYTE
pOurTrackedGbGrow (
    IN      PGROWBUFFER Buffer,
    IN      UINT Bytes
    )
{
    PBYTE p;
    BOOL trackMsg = FALSE;

    //
    // Because grow buffers themselves cause tracking, we have to
    // call the untracked version.  To eliminate confusion, we
    // give a helpful note.
    //

    if (!g_TrackFile) {
        trackMsg = TRUE;
        g_TrackFile = TEXT("<allocation tracking in dbgtrack.c, not a real leak>");
        g_TrackLine = __LINE__;
    }

    p = (PSTR) RealGbGrow (Buffer, Bytes);

    if (trackMsg) {
        g_TrackFile = NULL;
    }

    return p;
}


INT
TrackPush (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];
    static CHAR FileCopy[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s", Msg);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    StringCopyA (FileCopy, File);
    g_TrackFile = FileCopy;
    g_TrackLine = Line;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}


INT
TrackPop (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment = NULL;
        g_TrackFile = NULL;
    }

    return 0;
}


VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}


VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = INIT_GROWBUFFER;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = (UINT) wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);
        p = (PSTR) pOurTrackedGbGrow (&Msg, Bytes);

        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) pOurTrackedGbGrow (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        GbFree (&Msg);
    }

    GbFree (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    DWORD Hash;

    Hash = (DWORD) ((DWORD)Type << 16) ^ (DWORD)(UBINT)Ptr;
    return Hash % TRACK_BUCKETS;
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        Item->FileName = NULL;
        Item->Type = (ALLOCTYPE) -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\exclist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    exclist.c

Abstract:

    Implements a set of APIs to manage exclusion lists of objects
    of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_EXCLIST         "ExcList"

//
// Strings
//

#define S_EXCLUSIONLIST     "ExcList"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_ElPool,Size)

#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_ElPool, (PVOID)Buffer)


//
// Types
//

typedef struct {
    EL_TYPE TypeId;
    PCSTR   TypeName;
    BOOL    Compound;
} EXCLISTPROPS, *PEXCLISTPROPS;


//
// Globals
//

PMHANDLE    g_ElPool;
GROWLIST*   g_ElTypeLists;

//
// Macro expansion list
//

// Defined in exclist.h

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(TypeId,TypeName,Compound)     TypeId, TypeName, Compound,

EXCLISTPROPS g_ExcListProps [] = {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_UNKNOWN, NULL, FALSE
};

#undef DEFMAC


//
// Code
//


BOOL
ElInitialize (
    VOID
    )

/*++

Routine Description:

    ElInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (!g_ElPool);
    g_ElPool = PmCreateNamedPool (S_EXCLUSIONLIST);
    if (!g_ElPool) {
        return FALSE;
    }

    MYASSERT (!g_ElTypeLists);
    g_ElTypeLists = pAllocateMemory (ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    MYASSERT (g_ElTypeLists);
    ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));

    return TRUE;
}


VOID
ElTerminate (
    VOID
    )

/*++

Routine Description:

    ElTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    UINT u;

    //
    // did you forget to call ElRemoveAllA/W ?
    //
    for (u = 0; u < ELT_UNKNOWN; u++) {
        MYASSERT (g_ElTypeLists[u].ListArray.Buf == NULL && g_ElTypeLists[u].ListData == NULL);
    }

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}


/*++

Routine Description:

    ElGetTypeId returns the TypeId of a type given by name

Arguments:

    TypeName - Specifies the name

Return Value:

    One of EL_TYPE enumeration values

--*/

EL_TYPE
ElGetTypeId (
    IN      PCSTR TypeName
    )
{
    UINT u;

    if (TypeName) {
        for (u = 0; g_ExcListProps[u].TypeName; u++) {
            if (StringIMatchA (g_ExcListProps[u].TypeName, TypeName)) {
                return g_ExcListProps[u].TypeId;
            }
        }
    }

    return ELT_UNKNOWN;
}


/*++

Routine Description:

    ElGetTypeName returns the type name of a type given by TypeId

Arguments:

    TypeId - Specifies the ID

Return Value:

    A pointer to one of the known type names or NULL if TypeId is unknown

--*/

PCSTR
ElGetTypeName (
    IN      EL_TYPE TypeId
    )
{
    MYASSERT (TypeId < ELT_UNKNOWN);
    if (TypeId >= ELT_UNKNOWN) {
        return NULL;
    }
    return g_ExcListProps[TypeId].TypeName;
}


/*++

Routine Description:

    ElAdd adds the given object of the given type to the exclusion list. The object
    is first parsed so that the decision if a given string matches this pattern is faster.

Arguments:

    ObjectType - Specifies the object type
    ObjectName - Specifies the object pattern string

Return Value:

    TRUE if the string pattern was successfully parsed and added to the list

--*/

BOOL
ElAddA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR ObjectName
    )
{
    PPARSEDPATTERNA pp1;
    POBSPARSEDPATTERNA pp2;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    if (g_ExcListProps[ObjectType].Compound) {
        pp2 = ObsCreateParsedPatternExA (ObjectName, ObjectType == ELT_PATH);
        if (!pp2) {
            DEBUGMSGA ((
                DBG_EXCLIST,
                "ElAddA: Bad ObjectName: %s (type %s)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp2, DWSIZEOF (pp2));
    } else {
        pp1 = CreateParsedPatternA (ObjectName);
        if (!pp1) {
            DEBUGMSGA ((
                DBG_EXCLIST,
                "ElAddA: Bad ObjectName: %s (type %s)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp1, DWSIZEOF (pp1));
    }

    DEBUGMSGA ((
        DBG_EXCLIST,
        "ElAddA: Added excluded %s as type %s",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));
    return TRUE;
}


BOOL
ElAddW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR ObjectName
    )
{
    PPARSEDPATTERNW pp1;
    POBSPARSEDPATTERNW pp2;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    if (g_ExcListProps[ObjectType].Compound) {
        pp2 = ObsCreateParsedPatternExW (ObjectName, ObjectType == ELT_PATH);
        if (!pp2) {
            DEBUGMSGW ((
                DBG_EXCLIST,
                "ElAddW: Bad ObjectName: %s (type %hs)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp2, DWSIZEOF (pp2));
    } else {
        pp1 = CreateParsedPatternW (ObjectName);
        if (!pp1) {
            DEBUGMSGW ((
                DBG_EXCLIST,
                "ElAddW: Bad ObjectName: %s (type %hs)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp1, DWSIZEOF (pp1));
    }

    DEBUGMSGW ((
        DBG_EXCLIST,
        "ElAddW: Added excluded %s as type %hs",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));
    return TRUE;
}


/*++

Routine Description:

    ElRemoveAll removes all object patterns from the exclusion list.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElRemoveAllA (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_UNKNOWN; u++) {
            gl = &g_ElTypeLists[u];

            if (g_ExcListProps[u].Compound) {
                for (i = GlGetSize (gl); i > 0; i--) {
                    ObsDestroyParsedPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            } else {
                for (i = GlGetSize (gl); i > 0; i--) {
                    DestroyParsedPatternA (*(PPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    }
}

VOID
ElRemoveAllW (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_UNKNOWN; u++) {
            gl = &g_ElTypeLists[u];
            if (g_ExcListProps[u].Compound) {
                for (i = GlGetSize (gl); i > 0; i--) {
                    ObsDestroyParsedPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            } else {
                for (i = GlGetSize (gl); i > 0; i--) {
                    DestroyParsedPatternW (*(PPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    }
}


/*++

Routine Description:

    ElIsExcluded decides if the given object string is excluded (if it matches one of the
    patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Object - Specifies the object string

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;
    PSTR node;
    PSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (g_ExcListProps[ObjectType].Compound) {

        if (!ObsSplitObjectStringExA (Object, &node, &leaf, g_ElPool, FALSE)) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsExcludedA: invalid Object: \"%s\"", Object));
            return FALSE;
        }
        MYASSERT (node);

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
                continue;
            }
            if (leaf) {
                MYASSERT (pp->LeafPattern);
                if (!TestParsedPatternA (pp->LeafPattern, leaf)) {
                    continue;
                }
            }
            if (!TestParsedPatternA (pp->NodePattern, node)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        pFreeMemory (node);
        pFreeMemory (leaf);

    } else {

        for (i = GlGetSize (gl); i > 0; i--) {
            if (TestParsedPatternA (*(PPARSEDPATTERNA*) GlGetItem (gl, i - 1), Object)) {
                return TRUE;
            }
        }
    }

    return b;
}

BOOL
ElIsExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;
    PWSTR node;
    PWSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (g_ExcListProps[ObjectType].Compound) {

        if (!ObsSplitObjectStringExW (Object, &node, &leaf, g_ElPool, FALSE)) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsExcludedW: invalid Object: \"%s\"", Object));
            return FALSE;
        }
        MYASSERT (node);

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
                continue;
            }
            if (leaf) {
                MYASSERT (pp->LeafPattern);
                if (!TestParsedPatternW (pp->LeafPattern, leaf)) {
                    continue;
                }
            }
            if (!TestParsedPatternW (pp->NodePattern, node)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        pFreeMemory (node);
        pFreeMemory (leaf);

    } else {

        for (i = GlGetSize (gl); i > 0; i--) {
            if (TestParsedPatternW (*(PPARSEDPATTERNW*) GlGetItem (gl, i - 1), Object)) {
                return TRUE;
            }
        }
    }

    return b;
}


/*++

Routine Description:

    ElIsExcluded2 decides if the object given by its 2 components is excluded
    (if it matches one of the patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Node - Specifies the node part of the object
    Leaf - Specifies the leaf part of the object; optional

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Node,
    IN      PCSTR Leaf              OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    if (!g_ExcListProps[ObjectType].Compound) {
        DEBUGMSGA ((
            DBG_EXCLIST,
            "ElIsExcluded2A: Invalid ObjectType (%s=%d), must use a type that has a node spec",
            ElGetTypeName (ObjectType),
            (INT)ObjectType
            ));
        return FALSE;
    }

    MYASSERT (Node);
    if (!Node) {
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (!TestParsedPatternA (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}

BOOL
ElIsExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf             OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    if (!g_ExcListProps[ObjectType].Compound) {
        DEBUGMSGW ((
            DBG_EXCLIST,
            "ElIsExcluded2W: Invalid ObjectType (%hs=%d), must use a type that has a node spec",
            ElGetTypeName (ObjectType),
            (INT)ObjectType
            ));
        return FALSE;
    }

    MYASSERT (Node);
    if (!Node) {
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (!TestParsedPatternW (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    ElIsTreeExcluded2 decides if the object given by its 2 components and representing the
    whole tree beneath it (as a root) is excluded; i.e. if any child of the given object
    is excluded

Arguments:

    ObjectType - Specifies the object type
    Root - Specifies the root of the tree
    LeafPattern - Specifies the leaf pattern to be used for this decision; optional;
                  if NULL, no leaf pattern matching will be attempted

Return Value:

    TRUE if the tree is excluded, given the leaf pattern

--*/

BOOL
ElIsTreeExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNA pp;
    PCSTR subTreePattern;
    PPARSEDPATTERNA stpp;
    PPARSEDPATTERNA lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternA (LeafPattern);
        if (!lpp) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackA (Root);
    if (!subTreePattern || subTreePattern[1] != '*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExA ((g_ElPool, Root, "*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternA (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternA (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternA (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternA (stpp);
    }
    ELSE_DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternA (lpp);
    }

    return b;
}

BOOL
ElIsTreeExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR LeafPattern          OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNW pp;
    PCWSTR subTreePattern;
    PPARSEDPATTERNW stpp;
    PPARSEDPATTERNW lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternW (LeafPattern);
        if (!lpp) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackW (Root);
    if (!subTreePattern || subTreePattern[1] != L'*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExW ((g_ElPool, Root, L"*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternW (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternW (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternW (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternW (stpp);
    }
    ELSE_DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternW (lpp);
    }

    return b;
}


/*++

Routine Description:

    ElIsObsPatternExcluded decides if the object given by its parsed pattern is excluded;
    i.e. if any object matching this pattern is excluded

Arguments:

    ObjectType - Specifies the object type
    Pattern - Specifies the parsed pattern to be used for this decision

Return Value:

    TRUE if the object is excluded

--*/

BOOL
ElIsObsPatternExcludedA (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
ElIsObsPatternExcludedW (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_GROWBUF     "GrowBuffer"

//
// Strings
//

// None

//
// Constants
//

#define DEFAULT_GROW_SIZE 8192

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Realloc failed"));
            return NULL;
        }
        DEBUGMSG_IF ((
            GrowBuf->Buf != NewBuffer,
            DBG_WARNING,
            "GbGrow: Realloc caused growbuffer to move location; "
            "any pointers inside old buffer are now invalid!"
            ));

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return NewBuffer;
}


VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GbGrow (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GbGrow (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GbGrow (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID Ptr
    )
{
    PCVOID *p;

    p = (PVOID *) GbGrow (GrowBuf, sizeof (PVOID));
    if (!p) {
        return FALSE;
    }

    *p = Ptr;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGbAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGbAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGbCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGbCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "utilsp.h"
#include "locale.h"

//#define DEBUG_ALL_FILES

HINSTANCE g_hInst;
HANDLE g_hHeap;

OSVERSIONINFOA g_OsInfo;
OUR_CRITICAL_SECTION g_MemDbCs;

#define TEXT_GROWTH_SIZE    65536


//
// OS-dependent flags for MultiByteToWideChar
//

DWORD g_MigutilWCToMBFlags = 0;


//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;

//
// The PoolMem routines must also be thread-safe
//

OUR_CRITICAL_SECTION g_PmCs;

//
// MemAlloc critical section
//

OUR_CRITICAL_SECTION g_MemAllocCs;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//
PMHANDLE g_RegistryApiPool;
PMHANDLE g_PathsPool;
PMHANDLE g_TextPool;

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    )
{
    //
    // Set globals
    //

    if (Heap) {
        g_hHeap = Heap;
    } else {
        g_hHeap = GetProcessHeap();
    }

    g_hInst = GetModuleHandle (NULL);

    //
    // Load in OSVERSION info.
    //
    g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA (&g_OsInfo);

    //
    // Initialize log
    //

    Init_Log (NULL);

    //
    // Create critical sections
    //

    InitializeOurCriticalSection (&g_MemAllocCs);
    InitializeOurCriticalSection (&g_MemDbCs);
    InitializeOurCriticalSection (&g_PmCs);
    InitializeOurCriticalSection (&g_MessageCs);

    //
    // Now that MemAlloc will work, initialize allocation tracking
    //

    InitAllocationTracking();

    //
    // Create the short-term alloc table for string resource utils
    //

    g_ShortTermAllocTable = CreateAllocTable();

    //
    // MultiByteToWideChar has desirable flags that only function on NT
    //
    g_MigutilWCToMBFlags = (ISNT()) ? WC_NO_BEST_FIT_CHARS : 0;

#ifdef _lint

    g_MigutilWCToMBFlags = g_MigutilWCToMBFlags;

#endif


    //
    // Create pools used by utils.lib code
    //

    g_RegistryApiPool = PmCreateNamedPool ("Registry API");
    g_PathsPool = PmCreateNamedPool ("Paths");
    g_TextPool = PmCreateNamedPool ("Text");

    PmSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

    ObsInitialize ();
    ElInitialize ();

    //
    // The "out of memory" message
    //

    g_OutOfMemoryTable = CreateAllocTable();

    g_OutOfMemoryRetry  = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10001 /* MSG_OUT_OF_MEMORY_RETRY */
                                );

    g_OutOfMemoryString = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10002 /* MSG_OUT_OF_MEMORY */
                                );

    if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
        DEBUGMSG ((
            DBG_WARNING,
            "Cannot load out of memory messages; resources 10001 and 10002 do not exist"
            ));
    }

    //
    // set the locale to the system locale. Not doing this can cause isspace
    // to AV in certain MBSCHR circumstances.
    //
    setlocale(LC_ALL,"");
}


VOID
UtTerminate (
    VOID
    )
{
    //
    // Free utility pools
    //

    ElTerminate ();
    ObsTerminate ();

    if (g_RegistryApiPool) {
        PmDestroyPool (g_RegistryApiPool);
    }

    if (g_PathsPool) {
        PmDestroyPool (g_PathsPool);
    }

    if (g_TextPool) {
        PmDestroyPool (g_TextPool);
    }

    if (g_ShortTermAllocTable) {
        DestroyAllocTable (g_ShortTermAllocTable);
    }

    if (g_OutOfMemoryTable) {
        DestroyAllocTable (g_OutOfMemoryTable);
    }

    FreeAllocationTracking();

    //
    // Clean up handles used by critical sections
    //

    DeleteOurCriticalSection (&g_MemAllocCs);
    DeleteOurCriticalSection (&g_MemDbCs);
    DeleteOurCriticalSection (&g_PmCs);
    DeleteOurCriticalSection (&g_MessageCs);

    //
    // MUST BE VERY LAST CODE TO RUN
    //

    DumpHeapStats();
    Exit_Log ();
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}




HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    ovidiut     08-Oct-1999 Updated for new coding conventions and Win64 compliance
    ovidiut     23-Oct-1998 Implemented a new log mechanism and added new logging capabilities
    marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"

//
// Includes
//

// None

//
// Strings
//

#define S_COLUMNDOUBLELINEA     ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW     L":\r\n\r\n"
#define S_NEWLINEA              "\r\n"
#define S_NEWLINEW              L"\r\n"
#define DEBUG_SECTION           "Debug"
#define ENTRY_ALL               "All"
#define ENTRY_DEFAULTOVERRIDE   "DefaultOverride"

//
// Constants
//

#define OUTPUT_BUFSIZE_LARGE    8192
#define OUTPUT_BUFSIZE_SMALL    128
#define MAX_MSGTITLE_LEN        14
#define MSGBODY_INDENT          12
#define SCREEN_WIDTH            80
#define MAX_TYPE                64

//
// Macros
//

#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)
#define OUT_CONFIG(OutDest)         ((OutDest & OD_CONFIG) != 0)

#define LOGSEVERITY             LogSeverity

#define LOGSEV_FATAL_ERROR      LogSevFatalError
#define LOGSEV_ERROR            LogSevError
#define LOGSEV_WARNING          LogSevWarning
#define LOGSEV_INFORMATION      LogSevInformation

#ifdef DEBUG
    #define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#else
    #define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)      ((buf) + (sizeof(buf) / sizeof(buf[0])) - 1)

// This constant sets the default output
#ifndef DEBUG
    #define NORMAL_DEFAULT      OD_LOGFILE
#else
    #define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

#ifdef DEBUG
    #define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);
#else
    #define PRIVATE_ASSERT(expr)
#endif // DEBUG

#define NEWLINE_CHAR_COUNTA  (sizeof (S_NEWLINEA) / sizeof (CHAR) - 1)
#define NEWLINE_CHAR_COUNTW  (sizeof (S_NEWLINEW) / sizeof (WCHAR) - 1)

//
// Types
//

typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
    OD_CONFIG = 0x1000              // output to config.dmp
} OUTPUT_DESTINATION;

typedef DWORD   OUTPUTDEST;

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;


//
// Globals
//

const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};

const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

// a window handle for popup parent
HWND g_LogPopupParentWnd = NULL;
// thread id that set this window handle
DWORD g_InitThreadId = 0;


OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
PVOID g_TypeSt = NULL;
BOOL g_HasTitle = FALSE;
CHAR g_LastType [MAX_TYPE];
BOOL g_SuppressAllPopups = FALSE;
CHAR g_ConfigDmpPathBufA[MAX_MBCHAR_PATH];
BOOL g_ResetLog = FALSE;
#ifdef PROGRESS_BAR
    HANDLE g_ProgressBarLog = INVALID_HANDLE_VALUE;
#endif //PROGRESS_BAR

#ifdef DEBUG
    CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
    WCHAR g_DebugInfPathBufW[] = L"C:\\debug.inf";
    CHAR g_Debug9xLogPathBufA[] = "C:\\hwdb9x.log";
    CHAR g_DebugNtLogPathBufA[] = "C:\\hwdbnt.log";
    PCSTR g_DebugLogPathA = NULL;
    // If g_DoLog is TRUE, then, debug logging is enabled in the
    // checked build even if there is no debug.inf.
    // This variable can be enabled via the /#U:DOLOG command line directive...
    BOOL g_DoLog = FALSE;
#endif // DEBUG

#if defined(PROGRESS_BAR) || defined(DEBUG)
DWORD g_FirstTickCount = 0;
DWORD g_LastTickCount  = 0;
#endif

//
// Macro expansion list
//

#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG)                                           \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_LOGFILE|OD_DEBUGGER)                             \
        DEFMAC(DBG_ASSERT,DEFAULT_ERROR_FLAGS|OD_FORCE_POPUP|OD_UNATTEND_POPUP) \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG)                                           \

#endif


//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/

#define DEFMAC(typestr, flags)      {typestr, (flags)},

DEFAULT_DESTINATION g_DefaultDest[] = {TYPE_DEFAULTS /* , */ {NULL, 0}};

#undef DEFMAC


//
// Code
//


#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBox (NULL, buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_IgnoreKeys) / sizeof (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_String2Binary) / sizeof (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    OUTPUTDEST outDest;

    if (g_TypeSt == NULL) {
        //
        // sorry, log is closed
        //
        return OD_UNDEFINED;
    }

    if(ISNT()) {
        // convert the ASCII string to UNICODE on NT platforms
        KnownSizeAtoW (typeW, Type);
    } else {
        StringCopyA ((PSTR)typeW, Type);
    }
#if 0
    if (-1 != StringTableLookUpStringEx (
                    g_TypeSt,
                    (PSTR)typeW,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                    &outDest,
                    sizeof (outDest)
                    )) {

#ifdef DEBUG
        if (g_DoLog) {
            outDest |= OD_DEBUGLOG;
        }
#endif
        return outDest;

    }
#endif

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        outDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        outDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (outDest)) {

            //
            // just return the default
            //

            outDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        outDest |= OD_DEBUGLOG;
    }
#endif


    return outDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST outDest;

#ifdef DEBUG
    //
    // if this is an ASSERT, always show it to developer
    //
    if (!_stricmp (Type, DBG_ASSERT)) {
        return TRUE;
    }
#endif

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    outDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (outDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LOGSEV_INFORMATION.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LOGSEV_ERROR;
    }

    return LOGSEV_INFORMATION;
}


BOOL
pTableAddType (
    IN      PCSTR Type,
    IN      OUTPUTDEST OutDest
    )

/*++

Routine Description:

  pTableAddType adds a <Type, OutDest> association
  to the table g_TypeSt. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    if(ISNT()) {
        // convert the ASCII string to UNICODE on NT platforms
        KnownSizeAtoW (typeW, Type);
    } else {
        StringCopyA ((PSTR)typeW, Type);
    }

    PRIVATE_ASSERT (g_TypeSt != NULL);
#if 0
    return -1 != StringTableAddStringEx(
                    g_TypeSt,
                    (PSTR)typeW,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE | STRTAB_NEW_EXTRADATA,
                    &OutDest,
                    sizeof(OutDest)
                    );
#else
    return TRUE;

#endif

}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST outDest = OD_UNDEFINED;
    CHAR value[OUTPUT_BUFSIZE_SMALL];
    UINT field;

#if 0
    for (field = SetupGetFieldCount (InfContext); field > 0; field--) {
        if (SetupGetStringFieldA (
                InfContext,
                field,
                value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            outDest |= pConvertToOutputType(value);
        }
    }
#endif
    return outDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_TypeSt table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT infContext;
    OUTPUTDEST outDest;
    CHAR key[OUTPUT_BUFSIZE_SMALL];
/*
    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &infContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &infContext,
                    0,
                    key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }
            if (pIgnoreKey (key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&infContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&infContext);
                } else {
                    outDest = pGetAttributes(&infContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (outDest)) {
                        if (!pTableAddType (key, outDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&infContext, &infContext));
    }
*/
    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      UINT Indent
    )

{
    UINT i;
    PSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' '; //lint !e613 !e794
    }

    *p = 0; //lint !e613 !e794
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      UINT  Indent
    )
{
    UINT i;
    PWSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = CharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';    //lint !e613
    }

    *p = 0; //lint !e613
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCSTR lastSpace = NULL;
    PCSTR prevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && column < columnMax) {

        if (ch == '\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
            column++;
        } else {
            if (_ismbcspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        lastSpace = prevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (lastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCWSTR lastSpace = NULL;
    PCWSTR prevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && column < columnMax) {

        if (ch == L'\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
        } else {
            if (iswspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space was found
        lastSpace = prevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return lastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in buffer, which is no larger than Size.

Arguments:

  buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    CHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR nextLine;
    PCSTR s;
    PSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 3;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PSTR)pFindNextLineA (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (isleadbyte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (buffer, indentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    WCHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR nextLine;
    PCWSTR s;
    PWSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCWSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 1;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PWSTR)pFindNextLineW (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyCharCountW (buffer, indentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      DWORD LastError
    )
{
    PSTR append;
    DWORD errMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    append = GetEndOfStringA (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + BufferSize - append);  //lint !e613

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (append, errMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (append, errMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      DWORD LastError
    )
{
    PWSTR append;
    DWORD errMsgLen;

    StringCopyCharCountW (MsgWithErr, Message, BufferSize / sizeof(WCHAR));
    append = GetEndOfStringW (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + (BufferSize / sizeof(WCHAR)) - append);

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  formattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR myMsgBody;
    PSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorA (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    StringCopyByteCountA (formattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyByteCountA (currentPos, myMsgBody, remaining);
    pHangingIndentA (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringA (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTA + 1 < formattedMsg + BufferSize) { //lint !e613
        *currentPos++ = '\r';   //lint !e613
        *currentPos++ = '\n';   //lint !e613
        *currentPos = 0;        //lint !e613
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR myMsgBody;
    PWSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorW (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (typeW, Type);

    StringCopyCharCountW (formattedMsg, typeW, MAX_MSGTITLE_LEN);
    pPadTitleW (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyCharCountW (currentPos, myMsgBody, remaining);
    pHangingIndentW (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringW (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTW + 1 < formattedMsg + BufferSize) {
        *currentPos++ = L'\r';
        *currentPos++ = L'\n';
        *currentPos = 0;
    }
}


/*++

Routine Description:

  pWriteToSetupLogA and pWriteToSetupLogW log the specified message
  to the setup log using Setup API functions.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  formattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToSetupLogA (
    IN      LOGSEVERITY Severity,
    IN      PCSTR formattedMsg
    )
{
/*
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }
    if (!SetupLogErrorA (formattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    //SetupCloseLog();
*/
}


VOID
pWriteToSetupLogW (
    IN      LOGSEVERITY Severity,
    IN      PCWSTR formattedMsg
    )
{
/*
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }

    if (!SetupLogErrorW (formattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    //SetupCloseLog();
*/
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR currentPos = buffer;
#endif
    UINT mbStyle;
    LONG rc;
    OUTPUTDEST outDest;
    HWND parentWnd;
    PCSTR displayMessage = Msg;
    LOGSEVERITY severity = pGetSeverityFromType (Type);

    outDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                currentPos += wsprintfA (buffer, " [ERROR=%u]", LastError);
            } else {
                currentPos += wsprintfA (buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (outDest)) {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (currentPos > buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            displayMessage = formattedMsg;
            StringCopyByteCountA (
                formattedMsg,
                Msg,
                (UINT) (sizeof (formattedMsg) / sizeof (CHAR) - ((UBINT)currentPos - (UBINT)buffer))
                );
            StringCatA (formattedMsg, buffer);
        }
#endif

        switch (severity) {

        case LOGSEV_FATAL_ERROR:
            mbStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            mbStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            mbStyle = MB_ICONEXCLAMATION;
            break;

        default:
            mbStyle = MB_ICONINFORMATION;

        }
        mbStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (outDest)) {
            mbStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            mbStyle |= MB_OKCANCEL;
        }
#else
        mbStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            parentWnd = g_LogPopupParentWnd;

        } else {

            parentWnd = NULL;

        }

        rc = MessageBoxA (parentWnd, displayMessage, Type, mbStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            pTableAddType (Type, outDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
    PCSTR msgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    msgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, msgA, LastError, Forced);
    FreeConvertedStr (msgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR formattedMsg
    )
{
    OUTPUTDEST outDest;
    HANDLE handle;
    DWORD lastError;
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR logMessage;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (OUT_LOGFILE (outDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (outDest)) {

            if (Message) {

                logMessage = Message;

                lastError = GetLastError ();

                if (lastError != ERROR_SUCCESS) {

                    pAppendLastErrorA (bodyWithErr, sizeof (bodyWithErr), Message, lastError);

                    logMessage = bodyWithErr;
                }

                pWriteToSetupLogA (LOGSEV_INFORMATION, "Error:\r\n");
                pWriteToSetupLogA (LOGSEV_ERROR, logMessage);
                pWriteToSetupLogA (LOGSEV_INFORMATION, "\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogA (LOGSEV_INFORMATION, formattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringA (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fprintf (stderr, "%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                            g_DebugLogPathA,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif

    if (OUT_CONFIG (outDest)) {

        handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR formattedMsg
    )
{
    OUTPUTDEST outDest;
    HANDLE handle;
    DWORD lastError;
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR logMessage;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (OUT_LOGFILE (outDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (outDest)) {

            if (Message) {

                logMessage = Message;

                lastError = GetLastError ();

                if (lastError != ERROR_SUCCESS) {

                    pAppendLastErrorW (bodyWithErr, sizeof (bodyWithErr), Message, lastError);

                    logMessage = bodyWithErr;
                }
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"Error:\r\n");
                pWriteToSetupLogW (LOGSEV_ERROR, logMessage);
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogW (LOGSEV_INFORMATION, formattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringW (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fwprintf (stderr, L"%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                        g_DebugLogPathA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif

    if (OUT_CONFIG (outDest)) {

        handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(output, OUTPUT_BUFSIZE_LARGE, Format, args);
    }

    pIndentMessageA (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputA (Type, output, formattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR formatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {
        KnownSizeAtoW (formatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(output, OUTPUT_BUFSIZE_LARGE, formatW, args);
    }

    pIndentMessageW (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputW (Type, output, formattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


BOOL
pInitLog (
    IN      HWND *LogPopupParentWnd,    OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      BOOL FirstTimeInit
    )

/*++

Routine Description:

  pInitLog actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is optional only if FirstTimeInit
                       is FALSE.

  OrgPopupParentWnd  - Receives the original parent window.

  FirstTimeInit  - Specifies TRUE for the first log initialization,
                   or FALSE for reinitialization

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;
    PDEFAULT_DESTINATION dest;
#ifdef DEBUG
    CHAR tempPath[MAX_MBCHAR_PATH];
#endif

    PRIVATE_ASSERT (!FirstTimeInit || LogPopupParentWnd);

    __try {

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_TypeSt);
/*
            g_TypeSt = StringTableInitializeEx(sizeof (OUTPUTDEST), 0);

            if (!g_TypeSt) {
                __leave;
            }

            dest = g_DefaultDest;

            while (dest->Type) {
                pTableAddType (dest->Type, dest->Flags);
                dest++;
            }
*/
            GetWindowsDirectoryA (g_ConfigDmpPathBufA, MAX_MBCHAR_PATH);
            StringCopyA (AppendWackA (g_ConfigDmpPathBufA), TEXT("config.dmp"));

#ifdef PROGRESS_BAR
            PRIVATE_ASSERT (g_ProgressBarLog == INVALID_HANDLE_VALUE);
            g_ProgressBarLog = CreateFile (
                                ISNT() ? TEXT("C:\\pbnt.txt") : TEXT("C:\\pb9x.txt"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                SetFilePointer (g_ProgressBarLog, 0, NULL, FILE_END);
            }
#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_ConfigDmpPathBufA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_ConfigDmpPathBufA);
        }

#ifdef DEBUG
        if (FirstTimeInit) {
            GetSystemDirectoryA (tempPath, ARRAYSIZE (tempPath));

            // replace C with the actual sys drive letter
            g_DebugNtLogPathBufA[0] = g_Debug9xLogPathBufA[0] = tempPath[0];
            g_DebugInfPathBufA[0] = tempPath[0];

            //
            // only the first byte is important because drive letters are not double-byte chars
            //
            g_DebugInfPathBufW[0] = (WCHAR)tempPath[0];

            //
            // now get user's preferences
            //

            //hInf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            //if (INVALID_HANDLE_VALUE != hInf && pGetUserPreferences(hInf)) {
            //    g_DoLog = TRUE;
            //}
        }

        if (g_DebugLogPathA == NULL) {

            g_DebugLogPathA = ISNT() ? g_DebugNtLogPathBufA : g_Debug9xLogPathBufA;
        }

        if (g_ResetLog) {

            SetFileAttributesA (g_DebugLogPathA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogPathA);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = *LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        result = TRUE;
    }
    __finally {

        if (hInf != INVALID_HANDLE_VALUE) {
            //SetupCloseInfFile (hInf);
        }

        if (!result) {  //lint !e774

            if (g_TypeSt) {
                //StringTableDestroy(g_TypeSt);
                g_TypeSt = NULL;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif

#ifdef PROGRESS_BAR
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                CloseHandle (g_ProgressBarLog);
                g_ProgressBarLog = INVALID_HANDLE_VALUE;
            }
#endif
        }
    }

    return result;
}


BOOL
Init_Log (
    HWND Parent
    )

/*++

Routine Description:

  Init_Log initializes the log system calling the worker pInitLog. This function
  should be only called once

Arguments:

  Parent  - Specifies the initial parent window for all popups.  If NULL,
            the popups are suppressed.  Callers can use LogReInit to change
            the parent window handle at any time.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    return pInitLog (&Parent, NULL, TRUE);
}


BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    )

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pInitLog.
  This function may be called any number of times, but only after Init_Log

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

Return Value:

  TRUE if log system was successfully re-initialized

--*/

{
    return pInitLog (NewParent, OrgParent, FALSE);
}


VOID
Exit_Log (
    VOID
    )

/*++

Routine Description:

  Exit_Log cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{

#ifdef DEBUG

    if (g_DebugLogPathA) {
        g_DebugLogPathA = NULL;
    }

#endif

#ifdef PROGRESS_BAR
    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        CloseHandle (g_ProgressBarLog);
        g_ProgressBarLog = INVALID_HANDLE_VALUE;
    }
#endif

    if (g_TypeSt) {
        //StringTableDestroy(g_TypeSt);
        g_TypeSt = NULL;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCopyByteCountA (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEA));
    StringCatA (formattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, formattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    StringCopyCharCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        KnownSizeAtoW (typeW, Type);
        Title = typeW;
    }

    StringCopyCharCountW (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEW));
    StringCatW (formattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, formattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (output, Line, sizeof (output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNTA, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNTA] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatA (output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, output);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCWSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyCharCountW (output, Line, sizeof (output) / sizeof (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNTW, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNTW] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatW (output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, output);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text);
}


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    )
{
    DWORD currentTickCount;
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    PSTR appendPos;
    va_list args;

    PushError();

    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + vsprintf (msg, Format, args);
    va_end (args);
    sprintf (
        appendPos,
        "\t%lu\t%lu\r\n",
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        WriteFileStringA (g_ProgressBarLog, msg);
    }

    g_LastTickCount = currentTickCount;

    PopError();
}

#else // !PROGRESS_BAR

#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    CHAR date[OUTPUT_BUFSIZE_SMALL];
    CHAR ttime[OUTPUT_BUFSIZE_SMALL];
    PSTR appendPos, end;
    DWORD currentTickCount;
    va_list args;

    if (!g_DoLog) {
        return;
    }

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            ttime,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (ttime,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + _vsnprintf (msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    end = msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        appendPos,
        ((UBINT)end - (UBINT)appendPos) / (sizeof (CHAR)),
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        date,
        ttime,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", msg);

    PopError();
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    WCHAR msgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR dateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR timeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR formatW;
    PWSTR appendPosW, endW;
    DWORD currentTickCount;
    va_list args;

    if (!g_DoLog) {
        return;
    }

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            dateW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (dateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            timeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (timeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    formatW = ConvertAtoW (Format);
    appendPosW = msgW + _vsnwprintf (msgW, OUTPUT_BUFSIZE_LARGE, formatW, args);
    FreeConvertedStr (formatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    endW = msgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        appendPosW,
        ((UBINT)endW - (UBINT)appendPosW) / (sizeof (WCHAR)),
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        dateW,
        timeW,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", msgW);

    PopError();
}

#endif // DEBUG

#endif // PROGRESS_BAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    PMHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
HtAllocExAW (
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    PMHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PmCreateNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    hashTable = (PHASHTABLESTRUCT) PmGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PmDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable     - Specifies the handle to the hash table
  String        - Specifies the string to find.  If this string is
                  case-insensitive but has already been lowercased, then make
                  sure to pass TRUE in the CaseSensitive argument.
  ExtraData     - Specifies the bytes to be copied to the hash table entry.
  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  otherwise.
  OutHashValue  - Receives the hash value.  This is non optional for
                  efficiency.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!CaseSensitive) {
        dupStr = DuplicateTextA (String);
        (void) _mbslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        item = item->Next;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!CaseSensitive) {
        dupStr = DuplicateTextW (String);
        (void) _wcslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        item = item->Next;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable     - Specifies the handle to the hash table
  String        - Specifies the string to find.  If this string is
                  case-insensitive but has already been lowercased, then make
                  sure to pass TRUE in the CaseSensitive argument.
  BufferEnd     - Specifies the end of the string buffer, which may be longer
                  than all entries in the hash table, or it may be shorter.
  ExtraData     - Specifies the bytes to be copied to the hash table entry.
  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  otherwise.
  OutHashValue  - Receives the hash value.  This is non optional for
                  efficiency.  If pHtFindPrefix does not find a match,
                  this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!CaseSensitive) {
        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        if (dupStr) {
            StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
            _mbslwr (dupStr);
            String = dupStr;
        }
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = _mbsdec2 (String, BufferEnd);
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!CaseSensitive) {
        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        if (dupStr) {
            StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
            _wcslwr (dupStr);
            String = dupStr;
        }
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL CaseSensitive
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable     - Specifies the handle to the hash table, as returned from
                  AllocateHashTable.
  String        - Specifies the string to add to the table
  ExtraData     - Specifies the source binary data to be copied to the hash
                  table entry
  CaseSensitive - Specifies TRUE if the string compares are case-sensitive,
                  or FALSE if they are case-insensitive.

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!CaseSensitive) {
        dupStr = DuplicateTextA (String);
        _mbslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }
            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetStringData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!CaseSensitive) {
        dupStr = DuplicateTextW (String);
        _wcslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR)  PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetStringData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable     - Specifies the hash table handle, as returned by
                  AllocateHashTable.
  String        - Specifies the string to find
  ExtraData     - Receives the extra data associated with the found item
  CaseSensitive - Specifies TRUE if the find should be case-sensitive, FALSE
                  if it should be case-insensitive.

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindStringA (HashTable, String, ExtraData, CaseSensitive, &dontCare);
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindStringW (HashTable, String, ExtraData, CaseSensitive, &dontCare);
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable     - Specifies the hash table handle, as returned by
                  AllocateHashTable.
  String        - Specifies the string to find
  BufferEnd     - Specifies the end of the buffer for String
  ExtraData     - Receives the extra data associated with the found item
  CaseSensitive - Specifies TRUE if the find should be case-sensitive, FALSE
                  if it should be case-insensitive.

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraData,
                            CaseSensitive,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraData,
                            CaseSensitive,
                            &dontCare
                            );
}


BOOL
HtGetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetStringData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data

Return Value:

  TRUE if ExtraData was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetStringData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraData,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetStringData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetStringData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetStringData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\objstr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.c

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_OBJSTR      "ObjStr"

//
// Strings
//

#define S_OBJSTR        "ObjStr"

//
// Constants
//

#define OBJSTR_LEAF_HEADA           '<'
#define OBJSTR_LEAF_HEADW           L'<'

#define OBJSTR_LEAF_TAILA           '>'
#define OBJSTR_LEAF_TAILW           L'>'

#define OBJSTR_SEPARATORA           ' '
#define OBJSTR_SEPARATORW           L' '


//
// Macros
//

#define pObjStrAllocateMemory(Size)   PmGetMemory (g_ObjStrPool, Size)

#define pObjStrFreeMemory(Buffer)     if (/*lint --e(774)*/Buffer) PmReleaseMemory (g_ObjStrPool, Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_ObjStrPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
ObsInitialize (
    VOID
    )

/*++

Routine Description:

    ObsInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_ObjStrPool = PmCreateNamedPool (S_OBJSTR);
    return g_ObjStrPool != NULL;
}


VOID
ObsTerminate (
    VOID
    )

/*++

Routine Description:

    ObsTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_ObjStrPool) {
        PmDestroyPool (g_ObjStrPool);
        g_ObjStrPool = NULL;
    }
}


/*++

Routine Description:

    pExtractStringAB is a private function that creates a new string in the given pool,
    using a source string and a limit to copy up to.

Arguments:

    Start - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

PSTR
pExtractStringABA (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      PMHANDLE Pool
    )
{
    PSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (CHAR));
    StringCopyABA (p, Start, End);
    return p;
}


PWSTR
pExtractStringABW (
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      PMHANDLE Pool
    )
{
    PWSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (WCHAR));
    StringCopyABW (p, Start, End);
    return p;
}


/*++

Routine Description:

    ObsFree frees the given object from the private pool

Arguments:

    EncodedObject - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}


VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}

BOOL
ObsEncodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    MBCHAR ch;

    while (*Source) {
        ch = _mbsnextc (Source);
        if (_mbschr (EscapedCharsA, ch)) {
            *Destination = '^';
            Destination ++;
        }
        // now copy the multibyte character
        if (IsLeadByte (*Source)) {
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsEncodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    while (*Source) {
        if (wcschr (EscapedCharsW, *Source)) {
            *Destination = L'^';
            Destination ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((_mbsnextc (Source) == '^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            // now copy the multibyte character
            if (IsLeadByte (*Source)) {
                *Destination = *Source;
                Destination ++;
                Source ++;
            }
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((*Source == L'^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}


/*++

Routine Description:

    ObsSplitObjectStringEx splits the given encoded object into components: node and
    leaf. Strings are allocated from the given pool

Arguments:

    EncodedObject - Specifies the source object string
    DecodedNode - Receives the decoded node part; optional
    DecodedLeaf - Receives the decoded leaf part; optional
    Pool - Specifies the pool to use for allocation; optional; if not specified,
           the module pool will be used and ObsFree needs to be called for them
           to be freed

Return Value:

    TRUE if the source object has a legal format and it has been split into components

--*/

BOOL
ObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PSTR* DecodedNode,          OPTIONAL
    OUT     PSTR* DecodedLeaf,          OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCSTR p;
    PCSTR q;
    PCSTR nodeTerm;
    PSTR leaf = NULL;
    PCSTR lastWack = NULL;
    PCSTR lastStar = NULL;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    p = EncodedObject;

    if (*p == '\\') {
        //
        // must be UNC format; check for syntax
        //
        p++;
        if (*p != '\\') {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: relative paths not supported: %s",
                EncodedObject
                ));
            return FALSE;
        }
    }

    while (*p && *p != OBJSTR_LEAF_HEADA) {
        if (*p == OBJSTR_SEPARATORA) {
            q = p + 1;
            while (*q == OBJSTR_SEPARATORA) {
                q++;
            }
            if (*q == 0 || *q == OBJSTR_LEAF_HEADA) {
                break;
            }
            p = q;
        }
        if (*p == '\\') {
            if ((UBINT)p == (UBINT)lastWack + 1) {
                //
                // two wacks in a row? no way
                //
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            lastWack = p;
        } else if (*p == '*') {
            lastStar = p;
        }
        p = CharNextA (p);
    }

    if (p == EncodedObject) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsSplitObjectStringExA: Bad EncodedObject: %s",
            EncodedObject
            ));
        return FALSE;
    }

    if (lastWack && lastWack + 1 == p && lastStar && lastStar + 1 != lastWack) {
        nodeTerm = lastWack;
    } else {
        nodeTerm = p;
    }

    while (*p == OBJSTR_SEPARATORA) {
        //
        // *p is one byte wide
        //
        p++;
    }

    if (*p) {

        if (*p != OBJSTR_LEAF_HEADA) {
            //
            // wrong start
            //
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                EncodedObject
                ));
            return FALSE;
        }

        q = p + 1;
        while (*q != OBJSTR_LEAF_TAILA) {
            if (*q == 0) {
                //
                // incorrectly terminated
                //
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            q = CharNextA (q);
        }

        if (*(q + 1) != 0) {
            //
            // must end after the terminating char
            //
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: Bad EncodedObject: \"%s\"; chars after the leaf",
                EncodedObject
                ));
            return FALSE;
        }

        if (DecodedLeaf) {
            leaf = pExtractStringABA (p + 1, q, Pool);
            if (DecodeStrings) {
                //
                // decode chars
                //
                ObsDecodeStringA (leaf, leaf);
            }
        }
    }

    if (DecodedLeaf) {
        *DecodedLeaf = leaf;
    }

    if (DecodedNode) {
        *DecodedNode = pExtractStringABA (EncodedObject, nodeTerm, Pool);
        if (DecodeStrings) {
            //
            // decode chars
            //
            ObsDecodeStringA (*DecodedNode, *DecodedNode);
        }
    }

    return TRUE;
}


BOOL
ObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PWSTR* DecodedNode,         OPTIONAL
    OUT     PWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCWSTR p;
    PCWSTR q;
    PCWSTR nodeTerm;
    PWSTR leaf = NULL;
    PCWSTR lastWack = NULL;
    PCWSTR lastStar = NULL;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    p = EncodedObject;

    if (*p == L'\\') {
        //
        // must be UNC format; check for syntax
        //
        p++;
        if (*p != L'\\') {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: relative paths not supported: %s",
                EncodedObject
                ));
            return FALSE;
        }
    }

    while (*p && *p != OBJSTR_LEAF_HEADW) {
        if (*p == OBJSTR_SEPARATORW) {
            q = p + 1;
            while (*q == OBJSTR_SEPARATORW) {
                q++;
            }
            if (*q == 0 || *q == OBJSTR_LEAF_HEADW) {
                break;
            }
            p = q;
        }
        if (*p == L'\\') {
            if ((UBINT)p == (UBINT)lastWack + 1) {
                //
                // two wacks in a row? no way
                //
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            lastWack = p;
        } else if (*p == L'*') {
            lastStar = p;
        }
        p++;
    }

    if (p == EncodedObject) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsSplitObjectStringExW: Bad EncodedObject: %s",
            EncodedObject
            ));
        return FALSE;
    }

    if (lastWack && lastWack + 1 == p && lastStar && lastStar + 1 != lastWack) {
        nodeTerm = lastWack;
    } else {
        nodeTerm = p;
    }

    while (*p == OBJSTR_SEPARATORW) {
        //
        // *p is one WCHAR wide
        //
        p++;
    }

    if (*p) {

        if (*p != OBJSTR_LEAF_HEADW) {
            //
            // wrong start
            //
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                EncodedObject
                ));
            return FALSE;
        }

        q = p + 1;
        while (*q != OBJSTR_LEAF_TAILW) {
            if (*q == 0) {
                //
                // incorrectly terminated
                //
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            q++;
        }

        if (*(q + 1) != 0) {
            //
            // must end after the terminating char
            //
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: Bad EncodedObject: \"%s\"; chars after the leaf",
                EncodedObject
                ));
            return FALSE;
        }

        if (DecodedLeaf) {
            leaf = pExtractStringABW (p + 1, q, Pool);
            if (DecodeStrings) {
                //
                // decode chars
                //
                ObsDecodeStringW (leaf, leaf);
            }
        }
    }

    if (DecodedLeaf) {
        *DecodedLeaf = leaf;
    }

    if (DecodedNode) {
        *DecodedNode = pExtractStringABW (EncodedObject, nodeTerm, Pool);
        if (DecodeStrings) {
            //
            // decode chars
            //
            ObsDecodeStringW (*DecodedNode, *DecodedNode);

        }
    }
    return TRUE;
}


/*++

Routine Description:

    ObsBuildEncodedObjectStringEx builds an encoded object from components: node and
    leaf. The string is allocated from the module's pool

Arguments:

    DecodedNode - Specifies the decoded node part
    DecodedLeaf - Specifies the decoded leaf part; optional
    EncodeObject - Specifies TRUE if the resulting object needs to be encoded using
                   encoding rules

Return Value:

    Pointer to the newly created object string

--*/

PSTR
ObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,      OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PSTR encodedNode;
    PSTR encodedLeaf;
    PSTR encodedString;

    MYASSERT (DecodedNode);
    if (!DecodedNode) {
        return NULL;
    }
    //
    // at most, one byte char will be expanded to 4 bytes (4 times)
    //
    if (EncodeObject) {
        encodedNode = pObjStrAllocateMemory (4 * ByteCountA (DecodedNode) + DWSIZEOF(CHAR));
        ObsEncodeStringA (encodedNode, DecodedNode);
    } else {
        encodedNode = DuplicateTextExA (g_ObjStrPool, DecodedNode, 0, NULL);
    }

    if (!DecodedLeaf) {
        return encodedNode;
    }

    if (EncodeObject) {
        encodedLeaf = pObjStrAllocateMemory (4 * ByteCountA (DecodedLeaf) + DWSIZEOF(CHAR));
        ObsEncodeStringA (encodedLeaf, DecodedLeaf);
    } else {
        encodedLeaf = DuplicateTextExA (g_ObjStrPool, DecodedLeaf, 0, NULL);
    }

    //
    // preferred format: %1 <%2>    %1 - Node, %2 - Leaf
    //
    encodedString = pObjStrAllocateMemory (
                        ByteCountA (encodedNode) +
                        DWSIZEOF (" <>") +
                        ByteCountA (encodedLeaf)
                        );
    wsprintfA (
        encodedString,
        "%s %c%s%c",
        encodedNode,
        OBJSTR_LEAF_HEADA,
        encodedLeaf,
        OBJSTR_LEAF_TAILA
        );

    pObjStrFreeMemory (encodedNode);
    pObjStrFreeMemory (encodedLeaf);

    return encodedString;
}


PWSTR
ObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,     OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PWSTR encodedNode;
    PWSTR encodedLeaf;
    PWSTR encodedString;

    MYASSERT (DecodedNode);
    if (!DecodedNode) {
        return NULL;
    }
    //
    // at most, one wide char will be expanded to 4 wide chars (4 times)
    //
    if (EncodeObject) {
        encodedNode = pObjStrAllocateMemory (4 * ByteCountW (DecodedNode) + DWSIZEOF(WCHAR));
        ObsEncodeStringW (encodedNode, DecodedNode);
    } else {
        encodedNode = DuplicateTextExW (g_ObjStrPool, DecodedNode, 0, NULL);
    }

    if (!DecodedLeaf) {
        return encodedNode;
    }

    if (EncodeObject) {
        encodedLeaf = pObjStrAllocateMemory (4 * ByteCountW (DecodedLeaf) + DWSIZEOF(WCHAR));
        ObsEncodeStringW (encodedLeaf, DecodedLeaf);
    } else {
        encodedLeaf = DuplicateTextExW (g_ObjStrPool, DecodedLeaf, 0, NULL);
    }

    //
    // preferred format: %1 <%2>    %1 - Node, %2 - Leaf
    //
    encodedString = pObjStrAllocateMemory (
                        ByteCountW (encodedNode) +
                        DWSIZEOF (L" <>") +
                        ByteCountW (encodedLeaf)
                        );
    wsprintfW (
        encodedString,
        L"%s %c%s%c",
        encodedNode,
        OBJSTR_LEAF_HEADW,
        encodedLeaf,
        OBJSTR_LEAF_TAILW
        );

    pObjStrFreeMemory (encodedNode);
    pObjStrFreeMemory (encodedLeaf);

    return encodedString;
}


/*++

Routine Description:

    ObsCreateParsedPatternEx parses the given object into an internal format for quick
    pattern matching

Arguments:

    EncodedObject - Specifies the source object string

Return Value:

    A pointer to the newly created structure or NULL if the object was invalid

--*/

POBSPARSEDPATTERNA
ObsCreateParsedPatternExA (
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    POBSPARSEDPATTERNA ospp;
    PSTR decodedNode;
    PSTR decodedLeaf;
    PCSTR p;
    PCSTR root;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    ospp = pObjStrAllocateMemory (DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNA));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;

    MYASSERT (decodedNode);
    if (!GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    ospp->NodePattern = CreateParsedPatternA (decodedNode);
    if (!ospp->NodePattern) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
            EncodedObject
            ));
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }
    if (ospp->NodePattern->PatternCount > 1) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
            EncodedObject
            ));
        DestroyParsedPatternA (ospp->NodePattern);
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    root = ParsedPatternGetRootA (ospp->NodePattern);
    if (root) {
        //
        // extract the real root part
        //
        if (ParsedPatternIsExactMatchA (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_EXACTNODE;
            ospp->ExactRoot = DuplicateTextExA (g_ObjStrPool, root, 0, NULL);
            ospp->ExactRootBytes = ByteCountA (root);
            ospp->MaxSubLevel = 0;
        } else {
            p = FindLastWackA (root);
            if (p) {
                //
                // exact root specified
                // if the last wack is actually the last character or is followed by star(s),
                // optimize the matching by setting some flags
                //
                if (*(p + 1) == 0) {
                    if (ParsedPatternIsRootPlusStarA (ospp->NodePattern)) {
                        ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                    }
                }
                if (MakePrimaryRootEndWithWack && *root != '\\') {
                    //
                    // see if this is really the primary root
                    //
                    if (p == _mbschr (root, '\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                }
                ospp->ExactRoot = pExtractStringABA (root, p, g_ObjStrPool);
                ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
            }
        }
    } else if (ParsedPatternIsOptionalA (ospp->NodePattern)) {
        ospp->Flags |= OBSPF_OPTIONALNODE;
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternA (decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                DestroyParsedPatternA (ospp->LeafPattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = DuplicateTextExA (g_ObjStrPool, decodedLeaf, 0, NULL);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


POBSPARSEDPATTERNW
ObsCreateParsedPatternExW (
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    POBSPARSEDPATTERNW ospp;
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    PCWSTR p;
    PCWSTR root;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    ospp = pObjStrAllocateMemory (DWSIZEOF(OBSPARSEDPATTERNW));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNW));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;

    MYASSERT (decodedNode);
    if (!GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    ospp->NodePattern = CreateParsedPatternW (decodedNode);
    if (!ospp->NodePattern) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
            EncodedObject
            ));
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }
    if (ospp->NodePattern->PatternCount > 1) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
            EncodedObject
            ));
        DestroyParsedPatternW (ospp->NodePattern);
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    root = ParsedPatternGetRootW (ospp->NodePattern);
    if (root) {
        //
        // extract the real root part
        //
        if (ParsedPatternIsExactMatchW (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_EXACTNODE;
            ospp->ExactRoot = DuplicateTextExW (g_ObjStrPool, root, 0, NULL);
            ospp->ExactRootBytes = ByteCountW (root);
            ospp->MaxSubLevel = 0;
        } else {
            p = FindLastWackW (root);
            if (p) {
                //
                // exact root specified
                // if the last wack is actually the last character or is followed by star(s),
                // optimize the matching by setting some flags
                //
                if (*(p + 1) == 0) {
                    if (ParsedPatternIsRootPlusStarW (ospp->NodePattern)) {
                        ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                    }
                }
                if (MakePrimaryRootEndWithWack && *root != L'\\') {
                    //
                    // see if this is really the primary root
                    //
                    if (p == wcschr (root, L'\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                }
                ospp->ExactRoot = pExtractStringABW (root, p, g_ObjStrPool);
                ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
            }
        }
    } else if (ParsedPatternIsOptionalW (ospp->NodePattern)) {
        ospp->Flags |= OBSPF_OPTIONALNODE;
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternW (decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                DestroyParsedPatternW (ospp->LeafPattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = DuplicateTextExW (g_ObjStrPool, decodedLeaf, 0, NULL);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


/*++

Routine Description:

    ObsDestroyParsedPattern destroys the given structure, freeing resources

Arguments:

    ParsedPattern - Specifies the parsed pattern structure

Return Value:

    none

--*/

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternA (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternA (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            FreeTextExA (g_ObjStrPool, ParsedPattern->Leaf);
        }
        pObjStrFreeMemory (ParsedPattern->ExactRoot);
        pObjStrFreeMemory (ParsedPattern);
    }
}


VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternW (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternW (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            FreeTextExW (g_ObjStrPool, ParsedPattern->Leaf);
        }
        pObjStrFreeMemory (ParsedPattern->ExactRoot);
        pObjStrFreeMemory (ParsedPattern);
    }
}


/*++

Routine Description:

    ObsParsedPatternMatch tests the given object against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    EncodedObject - Specifies the object string to test against the pattern

Return Value:

    TRUE if the string matches the pattern

--*/

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExA (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExW (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsParsedPatternMatchEx tests the given object, given by its components,
    against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if ((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf ||
        !(ParsedPattern->Flags & OBSPF_NOLEAF) && !Leaf
        ) {
        return FALSE;
    }

    if (!TestParsedPatternA (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternA (ParsedPattern->LeafPattern, Leaf);
}

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,                        OPTIONAL
    IN      PCWSTR Leaf                         OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if ((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf ||
        !(ParsedPattern->Flags & OBSPF_NOLEAF) && !Leaf
        ) {
        return FALSE;
    }

    if (!TestParsedPatternW (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternW (ParsedPattern->LeafPattern, Leaf);
}


/*++

Routine Description:

    ObsPatternMatch tests an object string against a pattern object string

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExA (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABA (opNode, osNode, GetEndOfStringA (osNode));
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABA (opLeaf, osLeaf, GetEndOfStringA (osLeaf));
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExW (ObjectStr, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABW (opNode, osNode, GetEndOfStringW (osNode));
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABW (opLeaf, osLeaf, GetEndOfStringW (osLeaf));
                    } else {
                        b = FALSE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

/*++

Routine Description:

    ObsIsPatternContained compares two patterns to see if one of them is
    included in the other. Both patterns may contain any of the following
    expressions:

Arguments:

    Container - Specifies the container pattern
    Contained - Specifies the contained pattern

Return Value:

    TRUE if Contained is contained in Container

--*/

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExA (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExA (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExA (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Container string: %s", Container));

    return b;
}

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExW (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExW (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExW (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Container string: %s", Container));

    return b;
}


/*++

Routine Description:

    ObsGetPatternLevels gets the minimum and maximum levels of a string that would
    match the given pattern.

Arguments:

    ObjectPattern - Specifies the pattern
    MinLevel - Receives the minimum possible level; the root has level 1
    MaxLevel - Receives the maximum possible level; the root has level 1

Return Value:

    TRUE if the pattern was correct and computing was done; FALSE otherwise

--*/

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,
    OUT     PDWORD MaxLevel
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsPatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternA (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternA (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternW (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternW (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of
    binary objects.

Author:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    08-Aug-1997   jimschm     Created

Revision History:

--*/

#include "pch.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGlAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGlAdd allocates memory for a binary block by using a pool, and
  then expands an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PmCreateNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PmDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GbGrow (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PmGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GlGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
GlFree (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlFree frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GbFree (&GrowList->ListArray);
    if (GrowList->ListData) {
        PmDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlGetItem returns a pointer to the block of data
  for item specified by Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);


    return ItemPtr ? ItemPtr[Index] : NULL;
}


UINT
GlGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GlGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item and
  appends two zero bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a black of data as a new list item,
  before the specified Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a block of data as a new list item,
  before the specified Index.  Two zero bytes are appended to
  the block of data (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    if (Size) {
        GrowList->ListArray.End = Size * sizeof (PBYTE);
    } else {
        GlFree (GrowList);
    }

    return TRUE;
}


BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlResetItem sets the list pointer of the specified item
  to NULL, freeing the memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GlSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PmGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\utilsp.h ===
#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

//lint -save -e757

extern PCSTR g_OutOfMemoryString;
extern PCSTR g_OutOfMemoryRetry;

extern PMHANDLE g_RegistryApiPool;
extern PMHANDLE g_PathsPool;
extern OUR_CRITICAL_SECTION g_PmCs;
extern OUR_CRITICAL_SECTION g_MemAllocCs;

//lint -restore
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include <locale.h>

extern PMHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
}


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD) GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

  BUGBUG: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Chars - Specifies the number of characters, excluding the nul, to
          convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    Size = (Chars + 1) * sizeof (WCHAR);

    DbcsStr = (PSTR) PmGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,           // wc input count
                     DbcsStr,
                     (INT) Size,
                     NULL,
                     NULL
                     );

    // Report error returns from WideCharToMultiByte
    if (!rc && Chars) {
        PushError();
        PmReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    *CharCountToPointerA (DbcsStr, Chars) = 0;

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

  BUGBUG: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Chars     - Specifies the number of multibyte characters, excluding the nul,
              to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = (DWORD)(CharCountToPointerA(StrIn, Chars) - StrIn);

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Chars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PmGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = (DWORD) MultiByteToWideChar (
                                 g_GlobalCodePage,
                                 0,
                                 StrIn,
                                 (INT) StrInBytesToConvert,
                                 UnicodeStr,
                                 (INT) UnicodeStrBufLenBytes
                                 );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Chars) {
        PushError();
        PmReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless	 warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PmReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,               // wc input count
                     StrOut,
                     (INT) Chars * 2,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Chars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = (DWORD)(CharCountToPointerA (StrIn, Chars) - StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) StrInBytesToConvert,
                     StrOut,
                     (INT) StrInBytesToConvert * 2
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) (Bytes / sizeof (WCHAR)),
                     StrOut,
                     (INT) Bytes,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut + rc;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) Bytes,
                     StrOut,
                     (INT) Bytes * 2
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut + rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:

  marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"
#include "utilsp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = GROWLIST_INIT;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
pAddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
pAddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    pAddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif


//
// Includes
//

#include "utilsp.h"

#define DBG_POOLMEM "Poolmem"

//
// Strings
//

// None

//
// Constants
//

//
// Tree Memory Allocation structure.
//

#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32

//
// Macros
//

// None

//
// Types
//

typedef struct _PMBLOCK PMBLOCK, *PPMBLOCK;

struct _PMBLOCK {
    UINT_PTR Index;         // Tracks into RawMemory.
    SIZE_T Size;            // the size in bytes of RawMemory.
    PPMBLOCK NextBlock;     // A pointer to the next block in the pool chain.
    PPMBLOCK PrevBlock;     // A pointer to the prev block in the pool chain.
    DWORD UseCount;         // The number of allocations currently referring
                            // to this block.
    PBYTE RawMemory;        // The actual bytes of allocable memory in this block.
};
typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD DogTag;           // A signature to ensure validity.
    PALLOCATION Next;       // The next allocation in the list.
    PALLOCATION Prev;       // The previous allocation in the list.
#endif

    PPMBLOCK ParentBlock;   // A reference to the block from which this allocation
                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPMBLOCK PoolHead;                  // The active memory block in this pool.
    SIZE_T MinimumBlockSize;            // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR Name[MAX_POOL_NAME];
    SIZE_T TotalAllocationRequestBytes;
    SIZE_T MaxAllocationSize;
    SIZE_T CurrentlyAllocatedMemory;
    SIZE_T MaximumAllocatedMemory;
    UINT NumAllocationRequests;
    UINT NumFreeRequests;
    UINT NumBlockFrees;
    UINT NumBlockClears;
    UINT NumBlockAllocations;

    PALLOCATION AllocationList;         // A linked list of all of the allocations active in the
                                        // pool.
    FREESTATE FreeCalled;               // A state variable indicating that PoolMemReleaseMemory()
                                        // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;

//
// Globals
//

#ifdef DEBUG
DWORD g_PmDisplayed;
DWORD g_PmNotDisplayed;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



BOOL
pPmAddMemory (
    IN  PMHANDLE Handle,
    IN  SIZE_T Size
    )
/*++

Routine Description:

    pPmAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PmCreatePool and PmGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE allocedMemory;
    PPMBLOCK newBlock;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    SIZE_T sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(PMBLOCK) > poolHeader->MinimumBlockSize) {
        sizeNeeded = Size + sizeof(PMBLOCK);
    }
    else {
        sizeNeeded = poolHeader->MinimumBlockSize;
    }
    MYASSERT (g_TrackFile);
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock = (PPMBLOCK) allocedMemory;
        newBlock->Size = sizeNeeded - sizeof(PMBLOCK);
        newBlock->RawMemory = allocedMemory + sizeof(PMBLOCK);
        newBlock->Index = 0;
        newBlock->UseCount = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader->PoolHead) {
            poolHeader->PoolHead->PrevBlock = newBlock;
        }
        newBlock->NextBlock = poolHeader->PoolHead;
        newBlock->PrevBlock = NULL;
        poolHeader->PoolHead = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader->CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader->MaximumAllocatedMemory =
            max(poolHeader->MaximumAllocatedMemory,poolHeader->CurrentlyAllocatedMemory);

        poolHeader->NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


PMHANDLE
RealPmCreatePool (
    VOID
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid PMHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header->MinimumBlockSize = POOLMEMORYBLOCKSIZE;
        header->PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header->TotalAllocationRequestBytes = 0;
        header->MaxAllocationSize = 0;
        header->CurrentlyAllocatedMemory = 0;
        header->MaximumAllocatedMemory = 0;
        header->NumAllocationRequests = 0;
        header->NumFreeRequests = 0;
        header->NumBlockFrees = 0;
        header->NumBlockClears = 0;
        header->NumBlockAllocations = 0;
        header->Name[0] = 0;


#endif
        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPmAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);
            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PmNotDisplayed =  12;
        g_PmDisplayed =     24;

        if (ableToAddMemory) {
            header->AllocationList = NULL;  //lint !e613
            header->FreeCalled = FREE_NOT_CALLED;   //lint !e613
        }
#endif

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

    return (PMHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION p,cur;

    if (PoolHeader->FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader->AllocationList;

    while (p) {

        cur = p;
        p = p->Next;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader->AllocationList = NULL;
#endif
}


VOID
PmEmptyPool (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        poolHeader->PoolHead->UseCount = 0;
        poolHeader->PoolHead->Index = 0;

#ifdef DEBUG
        poolHeader->NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

}



VOID
PmSetMinimumGrowthSize (
    IN PMHANDLE Handle,
    IN SIZE_T Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader->MinimumBlockSize = max(Size,0);
}


VOID
PmDestroyPool (
    PMHANDLE Handle
    )
/*++

Routine Description:

    PmDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid PMHANDLE.

Return Value:

    None.

--*/
{
    PPMBLOCK nextBlock;
    PPMBLOCK blockToFree;
    PPOOLHEADER poolHeader;


    MYASSERT(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader->TotalAllocationRequestBytes)) / poolHeader->NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader->Name[0] ? poolHeader->Name : TEXT("[Unnamed Pool]"),
            FloatWorkaround,
            poolHeader->MaxAllocationSize,
            poolHeader->CurrentlyAllocatedMemory,
            poolHeader->MaximumAllocatedMemory,
            poolHeader->NumAllocationRequests,
            poolHeader->NumBlockAllocations,
            poolHeader->NumFreeRequests,
            poolHeader->NumBlockFrees,
            poolHeader->NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }


    //
    // Free all allocations that have not yet been freed.
    //

    pDeregisterPoolAllocations(poolHeader);

#endif


    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader-> PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;
        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    MemFree(g_hHeap,0,poolHeader);

}

PVOID
RealPmGetMemory (
    IN PMHANDLE Handle,
    IN SIZE_T Size,
    IN DWORD AlignSize
    )

/*++

Routine Description:

    RealPmGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL haveEnoughMemory = TRUE;
    PVOID rMemory = NULL;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    PPMBLOCK currentBlock;
    PALLOCATION allocation;
    SIZE_T sizeNeeded;
    UINT_PTR padLength;

    MYASSERT(poolHeader != NULL);
    MYASSERT(Size);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader->PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader->MaxAllocationSize = max(poolHeader->MaxAllocationSize,Size);
        poolHeader->NumAllocationRequests++;
        poolHeader->TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock->Size - currentBlock->Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPmAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader->PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (UINT_PTR) currentBlock + sizeof(PMBLOCK)
                    + currentBlock->Index + sizeof(ALLOCATION);
                currentBlock->Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            (PBYTE) allocation = &(currentBlock->RawMemory[currentBlock->Index]);
            allocation->ParentBlock = currentBlock;


#ifdef DEBUG

            //
            // Track this memory.
            //
            allocation->DogTag = VALIDDOGTAG;
            allocation->Next = poolHeader->AllocationList;
            allocation->Prev = NULL;

            if (poolHeader->AllocationList) {
                poolHeader->AllocationList->Prev = allocation;
            }

            poolHeader->AllocationList = allocation;

            if (poolHeader->FreeCalled != WHO_CARES) {

                DebugRegisterAllocation(POOLMEM_POINTER, allocation, g_TrackFile, g_TrackLine);

            }


#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock->Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

    return rMemory;
}

VOID
PmReleaseMemory (
    IN PMHANDLE Handle,
    IN PCVOID Memory
    )
/*++

Routine Description:

    PmReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION allocation;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader->NumFreeRequests++;  //lint !e613

#endif




#ifdef DEBUG

        if (poolHeader->FreeCalled == FREE_NOT_CALLED) {    //lint !e613
            poolHeader->FreeCalled = FREE_CALLED;   //lint !e613
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation->DogTag != VALIDDOGTAG) {
            if (allocation->DogTag == FREEDOGTAG) {
                DEBUGMSG((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);   //lint !e506
            }

            __leave;

        } else {
            allocation->DogTag = FREEDOGTAG;
        }

        if (allocation->Next) {
            allocation->Next->Prev = allocation->Prev;
        }

        if (poolHeader->AllocationList == allocation) { //lint !e613
            poolHeader->AllocationList = allocation->Next;  //lint !e613
        } else {

            allocation->Prev->Next = allocation->Next;
        }


        if (poolHeader->FreeCalled != WHO_CARES) {  //lint !e613
            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation->ParentBlock == NULL) {
            DEBUGMSG((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation->ParentBlock->UseCount--;




        if (allocation->ParentBlock->UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation->ParentBlock != poolHeader->PoolHead) {  //lint !e613
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader->NumBlockFrees++;    //lint !e613
                poolHeader->CurrentlyAllocatedMemory -=
                    allocation->ParentBlock->Size + sizeof(PMBLOCK);    //lint !e613


#endif

                if (allocation->ParentBlock->NextBlock) {
                    allocation->ParentBlock->NextBlock->PrevBlock =
                        allocation->ParentBlock->PrevBlock;
                }
                allocation->ParentBlock->PrevBlock->NextBlock =
                    allocation->ParentBlock->NextBlock;
                MemFree(g_hHeap,0,allocation->ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation->ParentBlock->Index = 0;
                allocation->ParentBlock = NULL;

#ifdef DEBUG
                poolHeader->NumBlockClears++;   //lint !e613
#endif

            }
        }
        else {
            allocation->ParentBlock = NULL;

        }

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

}


#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPool (
    IN PCSTR Name
    )
{
    PMHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = RealPmCreatePool();
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        StringCopyByteCountA (poolHeader->Name, Name, MAX_POOL_NAME);
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    )
{
    PSTR rString = (PSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringA (rString) + 1;    //lint !e613
    }
    size = (UINT_PTR) rString -  (UINT_PTR) MultiSzToCopy + 1;
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    )
{
    PWSTR rString = (PWSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringW (rString) + 1;
    }
    size = ((UINT_PTR) rString - (UINT_PTR) MultiSzToCopy + 1) * sizeof(WCHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}



#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);
    poolHeader->FreeCalled = WHO_CARES;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    ovidiut     12-Jan-2000 Added GetNodePatternMinMaxLevels,PatternIncludesPattern
    ovidiut     14-Sep-1999 Updated for new coding conventions and Win64 compliance
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"

//
// Includes
//

#include "utilsp.h"

#define DBG_STRINGS     "Strings"

//
// Strings
//

// None

//
// Constants
//

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK           32
#define WACK_REPLACE_CHAR   0x02
#define DWORD_MAX           0xFFFFFFFFu

//
// Macros
//

// None

//
// Types
//

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

//
// Globals
//

CHAR EscapedCharsA[] = "?*\020<>,^";
WCHAR EscapedCharsW[] = L"?*\020<>,^";

DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;
DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};
extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PMHANDLE g_TextPool;                     // in main.c
PGROWBUFFER g_LastAllocTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    );

BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

Routine Description:

  StringCopy implements lstrcpyA and a UNICODE version. We don't use the Win32
  api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy

Return Value:

  None.

--*/

VOID
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    while (*current) {
        *Destination++ = *current++;
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (*current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;
    }

    *Destination = 0;
}


VOID
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
}


/*++

Routine Description:

  StringCopyByteCount implements lstrcpynA and a UNICODE version. We don't
  use the Win32 api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy
  Count       - Specifies the maximum number of bytes to copy, including the
                nul terminator. If Count is zero, then not even a nul
                terminator is written.

Return Value:

  None.

--*/

VOID
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT Count
    )
{
    PCSTR end;
    PCSTR current;
    PSTR destEnd;

    if (Count >= sizeof (CHAR)) {

        current = Source;
        destEnd = Destination;

        end = (PCSTR) ((PBYTE) Source + Count - sizeof (CHAR));

        while (*current && current < end) {
            *destEnd++ = *current++;
        }

        //
        // If current has data left, we need to make sure a DBCS string
        // is properly terminated.
        //

        if (*current) {

            end = current;
            current--;

            while (current >= Source) {

                if (!IsLeadByte (*current)) {
                    //
                    // destEnd is correct
                    //
                    break;
                }

                current--;
            }

            if (!((end - current) & 1)) {
                destEnd--;
            }
        }

        *destEnd = 0;
    }
}


VOID
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT Count
    )
{
    PCWSTR end;

    if (Count < sizeof (WCHAR)) {
        DEBUGMSG_IF ((
            Count != 0,
            DBG_WHOOPS,
            "Buffer passed to StringCopyByteCountW is a fraction of one character"
            ));

        return;
    }

    end = (PCWSTR) ((PBYTE) Source + Count - sizeof (WCHAR));

    while (Source < end) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
}


VOID
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )

/*++

Routine Description:

  StringCopyByteCountAB copies a string segment into a destination buffer,
  and limits the copy to a maximum buffer size.  The return string is always
  nul-terminated, unless the buffer is too small to even hold a nul character.

Arguments:

  Destination          - Receives the string starting at Start and ending one
                         character before End.
  Start                - Specifies the start of the string.
  End                  - Specifies the first character not to copy.  If End
                         is equal or less than Start, then Destination is set
                         to an empty string (assuming the buffer can hold at
                         least one character)
  MaxBytesToCopyIncNul - Specifies the size of Destination, in bytes, and
                         including the nul terminator.

Return Value:

  None.

--*/

{
    INT width;

#ifdef DEBUG
    PCSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABA: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) (End - Start) + sizeof (CHAR);

    if (width > sizeof (CHAR)) {
        StringCopyByteCountA (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (CHAR)) {
        *Destination = 0;
    }
}

VOID
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    INT width;

#ifdef DEBUG
    PCWSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABW: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) (End - Start) + sizeof (WCHAR);

    if (width > sizeof (WCHAR)) {
        StringCopyByteCountW (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (WCHAR)) {
        *Destination = 0;
    }
}



/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    text [0] = 0;

    return text;
}

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    text [0] = 0;

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR buf;
    PSTR d;
    PCSTR s;

    buf = AllocTextExA (Pool, CharCountA (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR buf;
    PWSTR d;
    PCWSTR s;

    buf = AllocTextExW (Pool, CharCountW (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR buf;
    PSTR end;
    PSTR d;
    PCSTR s;

    buf = DuplicateTextExA (
              Pool,
              String1,
              CharCountA (String2) + ExtraChars + (CenterString ? CharCountA (CenterString) : 0),
              &end
              );

    if (buf) {

        d = end;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                if (IsLeadByte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
            }
        }

        s = String2;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR buf;
    PWSTR end;
    PCWSTR s;
    PWSTR d;

    buf = DuplicateTextExW (
              Pool,
              String1,
              CharCountW (String2) + ExtraChars + (CenterString ? CharCountW(CenterString) : 0),
              &end
              );

    if (buf) {
        d = end;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                *d++ = *s++;
            }
        }

        s = String2;

        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN      PCWSTR InString,
    IN      PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    UINT    maxSize             = 0;
    UINT    curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpandEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    //lint -e(671)
                    CopyMemory (newString, rString, (SIZE_T) ((UINT)curSize * sizeof(WCHAR)));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW(nextPercent - source);

                        StringCopyByteCountABW (
                            envName,
                            source + 1,
                            nextPercent,
                            (UINT) ((UBINT)nextPercent - (UBINT)source)
                            );


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PWSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableW(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            } else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextW(size);


                                if ((size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }

                                freeValue = TRUE;
                            }
                        }


                        if (foundValue) {
                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;
                        }
                        else {
                            DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;
                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextW(envName);
                        envName = NULL;
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //

            rString[curSize++] = *source++; //lint !e613

            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}


PSTR
RealExpandEnvironmentTextExA (
    IN      PCSTR InString,
    IN      PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    UINT   maxSize             = 0;
    UINT   curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (rString) {
                    CopyMemory (newString, rString, curSize * sizeof(CHAR));    //lint !e671
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (!IsLeadByte(*source) && *source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA(nextPercent - source);
                        StringCopyABA (envName, source+1, nextPercent);


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatch(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableA(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            }
                            else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextA(size);
                                freeValue = TRUE;

                                if ((size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }
                            }
                        }




                        if (foundValue) {

                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;



                        }
                        else {
                            DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;

                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextA(envName);
                        envName = NULL;


                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(*source)) {  //lint !e613
                rString[curSize++] = *source++; //lint !e613
            }
            rString[curSize++] = *source++; //lint !e613


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}



/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  Str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str)
        return Str;

    last = Str;

    while (*Str) {
        last = Str;
        Str = _mbsinc (Str);
    }

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendWackW (
    IN      PWSTR Str
    )
{
    PCWSTR last;

    if (!Str)
        return Str;

    if (*Str) {
        Str = GetEndOfStringW (Str);
        last = Str - 1;
    } else {
        last = Str;
    }

    if (*last != '\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendDosWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\' && *last != ':') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendDosWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\' && *last != L':') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendUncWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendUncWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendPathWackA (
    IN      PSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == '\\' && Str[1] == '\\') {
        return AppendUncWackA (Str);
    }

    return AppendDosWackA (Str);
}


PWSTR
AppendPathWackW (
    IN      PWSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == L'\\' && Str[1] == L'\\') {
        return AppendUncWackW (Str);
    }

    return AppendDosWackW (Str);
}


DWORD
pGetStringsTotalSizeA (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCSTR source;

    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        size += ByteCountA (source) + DWSIZEOF(CHAR);
    }

    return size;
}

DWORD
pGetStringsTotalSizeW (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCWSTR source;

    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        size += ByteCountW (source) + DWSIZEOF(WCHAR);
    }

    return size;
}


PSTR
pJoinPathsInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PSTR end;
    PSTR endMinusOne;
    PCSTR source;
    PCSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            endMinusOne = _mbsdec2 (p, end);
            if (endMinusOne) {
                if (_mbsnextc (source) == '\\') {
                    if (_mbsnextc (endMinusOne) == '\\') {
                        source++;
                    }
                } else {
                    if (_mbsnextc (endMinusOne) != '\\') {
                        *end = '\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatA (end, source);
        }
        counter++;
    }

    return end;
}

PWSTR
pJoinPathsInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    PCWSTR source;
    PCWSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            endMinusOne = end > p ? end - 1 : NULL;
            if (endMinusOne) {
                if (*source == L'\\') {
                    if (*endMinusOne == L'\\') {
                        source++;
                    }
                } else {
                    if (*endMinusOne != L'\\') {
                        *end = L'\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatW (end, source);
        }
        counter++;
    }

    return end;
}


PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pJoinPathsInBufferA (dest, args);
    va_end (args);

    return dest;
}


PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PWSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);
    va_start (args, Pool);
    pJoinPathsInBufferW (dest, args);
    va_end (args);

    return dest;
}


BOOL
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferA (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}

BOOL
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferW (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}


PSTR
pBuildPathInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PCSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            *Buffer++ = '\\';
            *Buffer = 0;
        }
        Buffer = StringCatA (Buffer, source);
        counter++;
    }

    return Buffer;
}

PWSTR
pBuildPathInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PCWSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            *Buffer++ = L'\\';
            *Buffer = 0;
        }
        Buffer = StringCatW (Buffer, source);
        counter++;
    }

    return Buffer;
}


DWORD
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferA (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}

DWORD
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferW (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}


BOOL
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferA (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}

BOOL
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferW (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}


PSTR
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferA (dest, args);
    va_end (args);

    return dest;
}

PWSTR
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PWSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferW (dest, args);
    va_end (args);

    return dest;
}


PSTR
RealAllocPathStringA (
    IN      DWORD Tchars
    )
{
    PSTR str;

    if (Tchars == 0) {
        Tchars = MAX_MBCHAR_PATH;
    }

    str = (PSTR) PmGetAlignedMemory (g_PathsPool, Tchars);

    str [0] = 0;

    return str;
}


PWSTR
RealAllocPathStringW (
    IN      DWORD Tchars
    )
{
    PWSTR str;

    if (Tchars == 0) {
        Tchars = MAX_WCHAR_PATH;
    }

    str = (PWSTR) PmGetAlignedMemory (g_PathsPool, Tchars * sizeof (WCHAR));

    str [0] = 0;

    return str;
}

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR drive[_MAX_DRIVE];
    CHAR dir[_MAX_DIR];
    CHAR fileName[_MAX_FNAME];
    CHAR ext[_MAX_EXT];

    _splitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringA (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringA (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringA (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringA (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fileName[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    _wsplitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringW (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringW (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringW (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringW (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


PSTR
RealDuplicatePathStringA (
    IN      PCSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}


PWSTR
RealDuplicatePathStringW (
    IN      PCWSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariable (TEXT("PATH"), NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyA (PathEnum->BufferPtr, AdditionalPath);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (SysDir != NULL) {
        StringCatA (PathEnum->BufferPtr, SysDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (WinDir != NULL) {
        StringCatA (PathEnum->BufferPtr, WinDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringA (PathEnum->BufferPtr);
        GetEnvironmentVariable (TEXT("PATH"), currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}


BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    PSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumA (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath = _mbsinc (PathEnum->PtrNextPath);
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathA (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


VOID
FreePathStringExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PSTR) Path);
    }
}


VOID
FreePathStringExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


VOID
PushNewError (DWORD dwError)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

VOID
PushError (VOID)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (VOID)
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

int
GetHexDigit (IN  int c)

{
    if (c >= '0' && c <= '9')
        return (c - '0');

    c = towlower ((wint_t) c);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, or 0 if a syntax error was found.

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, or zero if a syntax error was
  found.

--*/

DWORD
_mbsnum (IN PCSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == '0' && tolower (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD
_wcsnum (
    IN PCWSTR szNum
    )

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  StringCat is a lstrcat-type routine. It returns the pointer to the end
  of a string instead of the beginning, is faster, and has the proper types
  to keep lint happy.

Arguments:

  Destination - A pointer to a caller-allocated buffer that may point
                anywhere within the string to append to
  Source      - A pointer to a string that is appended to Destination

Return Value:

  A pointer to the NULL terminator within the Destination string.

--*/

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringA (Destination);

    while (*current) {
        *Destination++ = *current++;    //lint !e613
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (*current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;  //lint !e794
    }

    *Destination = 0;   //lint !e794

    return Destination;
}


PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )

{
    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringW (Destination);

    //
    // Copy string
    //

    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (PCSTR mbstrStr, PCSTR mbstrSubStr)

{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               _mbctolower ((MBCHAR) _mbsnextc (mbstrSubStrPos)) == _mbctolower ((MBCHAR) _mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (PCWSTR wstrStr, PCWSTR wstrSubStr)

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  StringCompareAB compares a string against a string between to string
  pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  end - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and
                  End

  Zero: String matches the string between Start and End identically

  Greater than zero: String is numerically greater than the string between
                     Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbsnextc (String) != _mbsnextc (Start)) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (INT) (_mbsnextc (Start) - _mbsnextc (String));
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    )

/*++

Routine Description:

  StringMatchA is an optimized string compare.  Usually a comparison is used to
  see if two strings are identical, and the numeric releationships aren't
  important. This routine exploits that fact and does a byte-by-byte compare.

Arguments:

  String1 - Specifies the first string to compare
  String2 - Specifies the second string to compare

Return Value:

  TRUE if the strings match identically, FALSE otherwise.

--*/

{
    while (*String1) {
        if (*String1 != *String2) {
            return FALSE;
        }

        String1++;
        String2++;
    }

    if (*String2) {
        return FALSE;
    }

    return TRUE;
}


BOOL
StringMatchABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )

/*++

Routine Description:

  StringMatchABA is an optimized string compare.  Usually a comparison is
  used to see if two strings are identical, and the numeric releationships
  aren't important. This routine exploits that fact and does a byte-by-byte
  compare.

Arguments:

  String - Specifies the first string to compare
  Start  - Specifies the beginning of the second string to compare
  End    - Specifies the end of the second string to compare (points to one
           character beyond the last valid character of the second string)

Return Value:

  TRUE if the strings match identically, FALSE otherwise.  If End is equal
  or less than Start, the return value is always TRUE.

--*/

{
    while (*String && Start < End) {
        if (*String != *Start) {
            return FALSE;
        }

        String++;
        Start++;
    }

    if (Start < End && *Start) {
        return FALSE;
    }

    return TRUE;
}


INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (tolower ((INT)(_mbsnextc (String))) != tolower ((INT)(_mbsnextc (Start)))) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (tolower ((INT)(_mbsnextc (Start))) - tolower ((INT)(_mbsnextc (String))));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



VOID
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (*Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR) c;
    } else {
        if (!IsLeadByte (*Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *p_szRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  p_szRule   - A pointer to a pointer; a caller-allocated buffer that
               holds the rule string.
  p_bFromHex - A pointer to a caller-allocated BOOL that receives TRUE
               when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *p_bFromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = _mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = _mbsinc (StartPtr);
    return _mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )

{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (szRule), possibly
  encoded with hex-specified character values (~xx~).  The output

  string contains unencoded characters.

Arguments:

  szRule    - A caller-allocated buffer, big enough to hold an
              unencoded rule.  szRule can be equal to szEncRule.
  szEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to szRule.

--*/


PSTR
DecodeRuleCharsA (PSTR mbstrRule, PCSTR mbstrEncRule)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    } while (c);

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (PWSTR wstrRule, PCWSTR wstrEncRule)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    } while (c);

    return wstrOrgRule;
}


PSTR
DecodeRuleCharsABA (PSTR mbstrRule, PCSTR mbstrEncRule, PCSTR End)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (PWSTR wstrRule, PCWSTR wstrEncRule, PCWSTR End)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  szEncRule - A caller-allocated buffer, big enough to hold an
              encoded rule.  szEncRule CAN NOT be equal to szRule.
              One way to calculate a max buffer size for szEncRule
              is to use the following code:

                  allocsize = SizeOfString (szRule) * 6;

              In the worst case, each character in szRule will take
              six single-byte characters in szEncRule.  In the normal
              case, szEncRule will only be a few bytes bigger than
              szRule.

  szRule    - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsA (PSTR mbstrEncRule, PCSTR mbstrRule)

{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;

    mbstrOrgRule = mbstrEncRule;

    while (*mbstrRule)  {
        c = _mbsnextc (mbstrRule);

        if (!_ismbcprint (c) || _mbschr (mbstrExclusions, c)) {

            // Escape unprintable or excluded character
            wsprintfA (mbstrEncRule, "~%X~", c);
            mbstrEncRule = GetEndOfStringA (mbstrEncRule);
            mbstrRule = _mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (*mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;  //lint !e613

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsW (PWSTR wstrEncRule, PCWSTR wstrRule)

{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;

    wstrOrgRule = wstrEncRule;

    while (c = *wstrRule)   {   //lint !e720
        if (!iswprint (c) || wcschr (wstrExclusions, c)) {
            wsprintfW (wstrEncRule, L"~%X~", c);
            wstrEncRule = GetEndOfStringW (wstrEncRule);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


int
_mbsisprint (PCSTR mbstrStr)

{
    while (*mbstrStr && _ismbcprint ((MBCHAR) _mbsnextc (mbstrStr))) {
        mbstrStr = _mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


int
_wcsisprint (PCWSTR wstrStr)

{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (PCSTR mbstrStr)

{
    while (_ismbcspace ((MBCHAR) _mbsnextc (mbstrStr)))
        mbstrStr = _mbsinc (mbstrStr);

    return mbstrStr;
}


PCWSTR
SkipSpaceW (PCWSTR wstrStr)

{
    while (iswspace (*wstrStr))
        wstrStr++;

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {    //lint !e613
        Str = _mbsdec2 (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) _mbsnextc(Str))) {
            return Str;
        }

    } while (Str = _mbsdec2(StrBase, Str)); //lint !e720

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses isspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) _mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = _mbsinc (Str);
    }

    if (LastNonSpace) {
        *_mbsinc (LastNonSpace) = 0;
    } else {
        *OrgStr = 0;
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        *(LastNonSpace + 1) = 0;
    } else {
        *OrgStr = 0;
    }
}



/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}

BOOL
IsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    MBCHAR chSrc, chPat;

    while (*Contained) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (Contained));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (Container));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Container)) == '*') {
                Container = _mbsinc (Container);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Container))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedA (_mbsinc (Container), Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained = _mbsinc (Contained);
            continue;
        } else if (chPat == '?') {
            if (chSrc == '*') {
                return FALSE;
            }
        } else {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Contained = _mbsinc (Contained);
        Container = _mbsinc (Container);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Container) == '*') {
        Container = _mbsinc (Container);
    }
    if (_mbsnextc (Container)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    while (*Contained) {

        if (*Container == L'*') {

            // Skip all asterisks that are grouped together
            while (Container[1] == L'*') {
                Container++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!Container[1]) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedW (Container + 1, Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained++;
            continue;
        } else if (*Container == L'?') {
            if (*Contained == L'*') {
                return FALSE;
            }
        } else {
            if (*Container != *Contained) {
                return FALSE;
            }
        }
        Contained++;
        Container++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (*Container == '*') {
        Container++;
    }
    if (*Container) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (Start));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Start)) == '*') {
                Start = _mbsinc (Start);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = _mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = _mbsinc (Start);
        Pattern = _mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Pattern) == '*') {
        Pattern = _mbsinc (Pattern);
    }

    if (_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternA (Handle, String);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternW (Handle, String);

    DestroyParsedPatternW (Handle);

    return b;
}

/*++

Routine Description:

  IsPatternMatchExAB compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}

BOOL
pTestSetsA (
    IN      PCSTR Container,
    IN      PCSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    MBCHAR ch;

    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        ch = _mbsnextc (Contained);
        if (!pTestSetA (ch, Container, NULL)) {
            return FALSE;
        }
        Contained = _mbsinc (Contained);
    }
    return TRUE;
}

BOOL
pTestSetsW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        if (!pTestSetW (*Contained, Container, NULL)) {
            return FALSE;
        }
        Contained ++;
    }
    return TRUE;
}

BOOL
pMatchSegmentA (
    IN      PSEGMENTA Source,
    IN      PSEGMENTA Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (_mbsnextc (Destination->Exact.LowerCasePhrase) != _mbsnextc (Source->Exact.LowerCasePhrase)) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

BOOL
pMatchSegmentW (
    IN      PSEGMENTW Source,
    IN      PSEGMENTW Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (*Destination->Exact.LowerCasePhrase != *Source->Exact.LowerCasePhrase) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

BOOL
pIsOneParsedPatternContainedA (
    IN      PPATTERNPROPSA Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSA Contained,
    IN      UINT StartContained
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTA containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedA (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
pIsOneParsedPatternContainedW (
    IN      PPATTERNPROPSW Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSW Contained,
    IN      UINT StartContained
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTW containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedW (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedA (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedW (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

PPARSEDPATTERNA
ExplodeParsedPatternA (
    IN      PPARSEDPATTERNA Pattern
    )
{
    PMHANDLE pool;
    PPARSEDPATTERNA pattern;
    PPATTERNPROPSA oldProps, newProps;
    PSEGMENTA oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex, byteIndex;
    BOOL result = TRUE;

    pool = PmCreateNamedPool ("Parsed Pattern");

    __try {

        pattern = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNA));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSA)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSA));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    newPropsSize ++;
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTA)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTA));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    byteIndex = oldSeg->Exact.PhraseBytes;
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(CHAR)
                                                                        );
                            ((PSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, 3 * sizeof(CHAR)
                                                                        );
                            if (IsLeadByte (oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex])) {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[2] = 0;
                                newSeg->Exact.PhraseBytes = 2;
                            } else {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                                newSeg->Exact.PhraseBytes = 1;
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    ZeroMemory (newSeg, sizeof (SEGMENTA));
                    newSeg->Type = oldSeg->Type;
                    newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                    if (oldSeg->Wildcard.IncludeSet) {
                        newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                    }
                    if (oldSeg->Wildcard.ExcludeSet) {
                        newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                    }
                    k++;
                    newSeg = &newProps->Segment[k];
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

PPARSEDPATTERNW
ExplodeParsedPatternW (
    IN      PPARSEDPATTERNW Pattern
    )
{
    PMHANDLE pool;
    PPARSEDPATTERNW pattern;
    PPATTERNPROPSW oldProps, newProps;
    PSEGMENTW oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex;
    BOOL result = TRUE;

    pool = PmCreateNamedPool ("Parsed Pattern");

    __try {

        pattern = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNW));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSW)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSW));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    newPropsSize ++;
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTW)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTW));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, 2 * sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [(oldSeg->Exact.PhraseBytes / sizeof(WCHAR)) - oldSegIndex];
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    ZeroMemory (newSeg, sizeof (SEGMENTW));
                    newSeg->Type = oldSeg->Type;
                    newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                    if (oldSeg->Wildcard.IncludeSet) {
                        newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                    }
                    if (oldSeg->Wildcard.ExcludeSet) {
                        newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                    }
                    k++;
                    newSeg = &newProps->Segment[k];
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

/*++

Routine Description:

  IsPatternContainedEx compares two patterns to see if one of them is
  included in the other. Both patterns may contain any of the following
  expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Container - A container pattern possibly containing wildcards
  Contained - A contained pattern possibly containing wildcards

Return Value:

  TRUE when the second pattern is contained in the first one, FALSE if not.

--*/

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PPARSEDPATTERNA container = NULL, contained = NULL;
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternA (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternA (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternA (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (contained) {
            DestroyParsedPatternA (contained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
        if (container) {
            DestroyParsedPatternA (container);
        }
    }

    return result;
}

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PPARSEDPATTERNW container = NULL, contained = NULL;
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternW (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternW (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternW (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (contained) {
            DestroyParsedPatternW (contained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
        if (container) {
            DestroyParsedPatternW (container);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternA (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternW (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
    }

    return result;
}

/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  buf       - Specifies the grow buffer to add the character to, receives the
 