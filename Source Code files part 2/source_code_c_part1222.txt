****************************/

int
CountFtrs(int cStrokes);		// I: Number of strokes


/***************************************************************************\
*	GrouseReco:																*
*		Main function for the Shrimp Recognizer.							*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
GrouseReco(GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
		   int cAlts,					// I: Max # of alternates needed
		   GLYPH *pGlyph,				// I: One character ink
		   DWORD *pdwEnabledGestures);	// I: Bit array of enabled gestures


/***************************************************************************\
*	GrouseMatch:															*
*																			*
*	Given featurized ink, compute the altlist (with scores).				*
*																			*
*	History:																*
*		21-September-2001 -by- Petr Slavik pslavik							*
*			Wrote it.														*
\***************************************************************************/

int
GrouseMatch(WORD *awFtrs,				// I: Feature vector
			int	cStrokes,				// I: Number of strokes
			DWORD *pdwEnabledGestures,	// I: Bit array of enabled gestures
			GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
		   	int cMaxReturn);			// I: Max # of choices to return



#define MAX_STROKES		 2
#define X_CHEBYS		10		// Number of Chebyshev's
#define Y_CHEBYS		10		// coefficients to compute
#define	FRAME_FTRS	   ((X_CHEBYS-1) + (Y_CHEBYS-1) + 1 + 3)
#define	EPSILON		    15		// 16.16 threshold for Chebys

#define MAX_OUTPUT		36
#define MAX_HIDDEN		30

typedef int WEIGHT;		// WEIGHT is either "short" or "int"

typedef struct tagGROUSE_DB
{
	DWORD adwGrouseGestures[MAX_GESTURE_DWORD_COUNT];	// Gestures supported by Grouse
	wchar_t	*node2gID[MAX_STROKES];			// Node-to-gestureID mappings
	int		cInputs[MAX_STROKES];			// # of inputs (for each net)
	int		cHiddens[MAX_STROKES];			// # of hidden nodes (for each net)
	int		cOutputs[MAX_STROKES];			// # of outputs (for each net)
	WEIGHT	*aprgWeightHidden[MAX_STROKES];	// Weights to hidden nodes
	WEIGHT	*aprgWeightOutput[MAX_STROKES];	// Weights to output nodes
	WEIGHT	*aprgBiasHidden[MAX_STROKES];	// Bias values for hidden nodes
	WEIGHT	*aprgBiasOutput[MAX_STROKES];	// Bias values for output nodes
} GROUSE_DB;


extern GROUSE_DB	gGrouseDb;	// Grouse lib external variable!

#ifdef __cplusplus
};
#endif

#endif // __INCLUDE_GROUSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\inc\grouse_table1.h ===
wchar_t node2gID_1[] =
{0xf000,0xf001,0xf002,0xf003,0xf004,0xf005,0xf010,0xf011,0xf020,0xf021,0xf028,0xf029,0xf030,0xf031,0xf032,0xf033,0xf038,0xf039,0xf03a,0xf03b,};
int cNodes_1 = 20;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\inc\grouse_table2.h ===
wchar_t node2gID_2[] =
{0xf000,0xf002,0xf003,0xf038,0xf039,0xf03a,0xf03b,0xf0a4,};
int cNodes_2 = 8;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\inc\grouse_net1.h ===
// layer 0
const int c_1_Input = 19;
// layer 1
const int c_1_Hidden = 30;
const int rg_1_WeightHidden[30*19] = {
	// rgWeightHidden+0*19
	-612, 1813, -1267, 3545, -2257,
	1367, 5231, 5795, -5067, 524,
	11959, 519, 9529, 7326, -8104,
	-10675, 3373, 6656, 9134,	// rgWeightHidden+1*19
 4429,
	3126, -3641, -3523, -331, -355,
	-1455, -1824, -435, -218, -2117,
	-3914, -62, 1425, -219, -1048,
	431, 2122, -3201,	// rgWeightHidden+2*19
 -946, 3693,
	-1355, -3639, 1395, -411, -284,
	-1043, -2160, -1805, -780, 1367,
	3640, -1780, -2016, 729, -1411,
	-851, -462,	// rgWeightHidden+3*19
 -250, 3073, -3162,
	2601, -2776, -25, 6310, 4311,
	-1056, -2878, -891, 2002, -669,
	159, 199, 2407, -1304, 169,
	525,	// rgWeightHidden+4*19
 -388, 35624, 1164, 3193,
	1607, 1210, -2690, -2104, -12533,
	-4873, 832, 2243, 6728, 5496,
	-5089, -4747, -3326, 988, 4435,
	// rgWeightHidden+5*19
	-1901, -1319, -1987, -4270, 238,
	67, -219, 928, -956, 130,
	-1795, 201, 2578, 728, -811,
	-2081, -464, -70, -1598,	// rgWeightHidden+6*19
 -917,
	-2245, -302, -915, -590, 2606,
	749, 3387, 229, 162, 158,
	-4691, 1081, -7472, 1558, -4713,
	6219, -937, -1439,	// rgWeightHidden+7*19
 3472, -92,
	-2590, -2519, 2199, -1659, 1309,
	-1984, -2804, 833, -1928, -5258,
	-3245, -2668, -179, -699, -1106,
	2691, 2060,	// rgWeightHidden+8*19
 -2879, 1780, -2450,
	-3946, 3119, 62, 0, 387,
	-789, -516, 3289, -2827, -2498,
	-1210, -1520, -596, 186, -339,
	-542,	// rgWeightHidden+9*19
 6411, 154, -3129, 14423,
	372, -13654, 15185, 14420, 1152,
	-1266, 1106, -10190, 5352, 8374,
	-2258, 2279, -3837, -8857, -195,
	// rgWeightHidden+10*19
	227, -5288, 674, -3531, -1578,
	872, -2430, 6088, -345, -2422,
	3670, -1523, 857, -2997, 210,
	-71, -2456, 225, -1970,	// rgWeightHidden+11*19
 -12,
	174, -1481, 1770, -4778, 184,
	4535, -562, 1510, 2179, 1763,
	3261, 859, 6521, 1312, -13997,
	2163, 422, -4811,	// rgWeightHidden+12*19
 620, 1399,
	-5, -3233, 254, -602, 609,
	-472, -226, -401, -1178, -4546,
	-53, -806, -1940, -3327, -1444,
	5716, 1251,	// rgWeightHidden+13*19
 3170, 1675, 694,
	1349, 267, 1535, 1025, 3250,
	726, -423, 672, 56, 572,
	103, 716, 167, 1339, 1539,
	464,	// rgWeightHidden+14*19
 -131, 2461, -127, 1247,
	-402, 3848, -162, 5512, 689,
	-124, -5917, -254, -4660, -928,
	-5802, -1148, -7299, 812, 5533,
	// rgWeightHidden+15*19
	-2274, 1806, 251, -3496, 1133,
	-114, -1189, 2488, -2489, -2015,
	-876, -5282, -3187, 2735, 831,
	-1302, -4696, 1947, 1409,	// rgWeightHidden+16*19
 -613,
	2171, 394, -5328, 397, 1773,
	-3216, 910, -2169, -2424, 557,
	-5989, 485, -4046, -1064, 215,
	411, 3743, 3534,	// rgWeightHidden+17*19
 -1246, 6727,
	-820, -9064, -1555, 273, -3453,
	-1190, -4075, -58, -4287, -4421,
	-5476, -1569, -2190, -9772, -3364,
	-454, 1508,	// rgWeightHidden+18*19
 -472, -5334, 424,
	3980, -1138, -1393, 1002, -8023,
	1956, 3808, -1116, 60, -915,
	1814, -2123, -2328, 281, 741,
	-282,	// rgWeightHidden+19*19
 283, 8929, 243, 7487,
	479, 2989, -336, 5287, 11047,
	-3547, -1083, -6246, -7038, -8295,
	-8506, 24566, 8010, 24455, 3636,
	// rgWeightHidden+20*19
	-2047, 406, 696, 659, 2344,
	-957, -4464, 1280, -4085, -709,
	323, -564, 607, -822, -1591,
	1581, -1073, -352, 821,	// rgWeightHidden+21*19
 0,
	-3176, 396, -1517, -598, -33,
	-427, 1053, -553, -130, 1610,
	-113, 1170, -1015, 1831, 572,
	717, -211, 163,	// rgWeightHidden+22*19
 -12558, 2942,
	1426, 9825, 6603, -11068, -8112,
	-7308, -2996, 7578, 1158, -2406,
	827, -1503, -974, -315, 494,
	4017, 6657,	// rgWeightHidden+23*19
 -508, 385, 3171,
	-157, 490, -841, -3636, 1483,
	-2476, -190, -161, 10, 216,
	-1778, 525, 811, 898, -2369,
	-2004,	// rgWeightHidden+24*19
 -3443, 698, -11950, 645,
	-8686, -159, -13372, 1868, -2272,
	-1395, 1923, -251, 2615, 1364,
	3079, -1242, 4437, -3410, -423,
	// rgWeightHidden+25*19
	-1383, 263, -1631, 132, 4457,
	1858, -1418, 387, 3447, 1220,
	-145, 5848, -1142, 6683, -2631,
	-5861, -2405, 5063, 4529,	// rgWeightHidden+26*19
 1363,
	569, -303, 478, -952, -269,
	-2348, -600, -272, 535, -3063,
	871, -1175, 763, -206, -5261,
	-1288, -2231, -1715,	// rgWeightHidden+27*19
 -999, -216,
	-801, 2319, 2945, 160, -5817,
	3577, -4154, -2955, -724, -2420,
	2496, 150, -1581, 3477, -2797,
	3, 2368,	// rgWeightHidden+28*19
 -4147, 378, -5404,
	-3924, -260, -980, 296, 1131,
	-124, 590, -1493, -4921, -3399,
	840, -89, 362, 780, 791,
	1634,	// rgWeightHidden+29*19
 -3230, 1425, -4912, -1502,
	-58, -970, -1918, -2071, 1565,
	-473, -2678, 1235, -568, 526,
	-1907, 1306, -1679, -3597, 2030
};  // rgWeightHidden[30*19]

const int rg_1_BiasHidden[30] = {
	-24568, -3402, -3405, -6621, -30661,
	-1455, 2128, -2170, -1696, -17314,
	912, -1980, -1955, -9763, 2266,
	-343, -373, 17418, 2514, -36798,
	3245, -1397, -6608, 2185, 11697,
	-9607, 5966, 631, -21, 432
};  // rgBiasHidden[30]

// layer 2
const int c_1_Output = 20;
const int rg_1_WeightOutput[20*30] = {
	// rgWeightOutput+0*30
	-1570, -14738, -4054, -2097, -1641,
	-16514, -889, -16002, -12887, -743,
	-9625, 1461, -5948, 2910, 1396,
	-12264, -10377, -2230, -1428, -1594,
	4780, 249, -8441, -4042, -903,
	-1886, -3018, -2995, -12056, -13605,
	// rgWeightOutput+1*30
	714, -11182, -2527, 1895, -49855,
	-178, 707, -11177, 548, -188,
	-7839, 356, -191, -62222, 235,
	2503, -2354, 91, -5663, -3621,
	-27, 918, 34673, -640, -1303,
	545, -353, -56, 7068, 1538,
	// rgWeightOutput+2*30
	-61030, -2290, 3015, 2098, -2875,
	-930, 3529, 928, 2162, 803,
	1236, 765, 299, -1281, -1809,
	2089, 9903, 905, 867, -29482,
	-4791, -15015, -5024, 4075, 553,
	2879, -17816, 2607, -2678, -2027,
	// rgWeightOutput+3*30
	-53862, -4223, 802, -3077, -35933,
	-4374, 461, 1586, -3052, -183,
	2972, -2089, 8396, -497, 696,
	-811, -3026, 1084, 2792, -18744,
	-2801, -38689, -6889, 3443, 3121,
	128, -26063, 606, -3519, 1779,
	// rgWeightOutput+4*30
	-165, 4128, -3487, 1745, -51148,
	1854, 5040, -8941, 1552, 720,
	3720, 3341, 4816, 79, -204,
	-292, -69, -28120, 2240, 2303,
	-1164, -17028, -6538, 2505, 1243,
	1918, -24, 851, 1195, -4484,
	// rgWeightOutput+5*30
	-16870, -1046, 1840, 1307, 8896,
	3566, 205, -1770, 1070, -268,
	2872, -26991, 1087, -4388, 16716,
	507, 3205, 2877, 7388, 2714,
	-4887, 25001, -6295, 3975, -63410,
	-29122, 5321, 2397, -1817, 328,
	// rgWeightOutput+6*30
	389, 26, -4086, 3383, -1091,
	-1332, 959, 1768, -1713, -31268,
	-4922, -307, 475, -868, 53493,
	-2715, -526, -384, -2345, -1286,
	477, 56956, -6185, -1568, -47154,
	-3279, 1776, -19165, 283, -919,
	// rgWeightOutput+7*30
	452, 322, -2189, -501, 1840,
	1092, -1408, -87, -2599, -32126,
	6389, 1013, -2141, -3159, 23102,
	799, -825, 1601, 1412, 3288,
	793, 28286, -5869, 2995, -18844,
	373, 7130, -15014, 666, 1159,
	// rgWeightOutput+8*30
	-218, -293, 1920, -1869, -48524,
	-5162, -10225, 2963, -1486, 81,
	1248, -2244, -4045, -1651, -2457,
	-3610, 2984, 668, 29, -355,
	-2720, -24654, -595, 297, -1014,
	293, -1434, 1626, -1321, -3411,
	// rgWeightOutput+9*30
	156, 1582, -2678, 1728, -53399,
	-1770, -742, 2179, 2107, 255,
	-3678, 152, -2615, -3257, -4069,
	-218, 449, -84, -746, 1766,
	-672, -1833, -10105, 536, -2756,
	265, 3476, 1291, -1072, 2056,
	// rgWeightOutput+10*30
	-56988, -15287, -5044, -19063, -49246,
	-3234, -23816, -7377, -7639, -40603,
	2301, -4886, -6338, -111072, -44538,
	-13647, -16971, -28321, 82067, -46525,
	-26337, 11645, -11278, -36066, -56201,
	39250, 1831, -30830, -12459, -133,
	// rgWeightOutput+11*30
	-54285, -5084, 5240, -8919, 51340,
	-2564, -23621, -5765, -4612, -39902,
	-7831, -4490, -6379, -24812, -188,
	-9514, -6479, -19118, 20948, -48134,
	-29495, 5744, -11706, -16815, -55929,
	73699, -9367, -31386, -11429, 571,
	// rgWeightOutput+12*30
	-59572, 185, 2314, 3235, 2019,
	-2209, -907, 2990, 1845, 90,
	-17490, -18470, 3530, 224, -1001,
	524, -3714, -30061, 2552, 217,
	-8835, 3860, -2800, 2596, -32119,
	2782, 584, -19327, -4027, -3622,
	// rgWeightOutput+13*30
	-47260, -1790, 664, -15969, 1490,
	-4723, 1340, 1199, -3713, 1676,
	-11130, -32882, 1038, -1642, -539,
	2883, -6013, 2890, 2086, 1270,
	-2127, 757, -1996, 226, -33540,
	-58968, -590, -3789, 494, -402,
	// rgWeightOutput+14*30
	3336, -100, -1753, -18484, -47173,
	2928, -17891, 393, -5238, -45718,
	-6269, -3824, 201, -2610, 839,
	-326, 267, 232, -650, -33572,
	-4463, 1848, -1933, 4994, 1395,
	-1560, 581, -9293, -3327, -711,
	// rgWeightOutput+15*30
	3652, -418, -1435, -7177, -2742,
	1508, -9523, 497, -3386, 582,
	-4968, -3082, -1352, -2711, 1592,
	388, -1298, 1483, 232, -1244,
	-4405, 91, -4900, 2016, 2435,
	2026, 1415, -528, 758, -4416,
	// rgWeightOutput+16*30
	-61256, 6623, -1243, 883, -47457,
	-576, -17038, 3810, -12439, -242,
	-3747, -1399, -6241, -735, -447,
	-5542, -2950, -19275, -829, -18622,
	-3320, -12515, -5073, 1118, -1827,
	891, 4166, 4171, -2177, 2173,
	// rgWeightOutput+17*30
	640, 3225, -4791, -39338, -40309,
	-6765, 1284, 393, 2880, 1294,
	-6995, -2311, 4871, -146, -48945,
	-2745, 47, -28748, -4800, 1427,
	-1551, 1317, -1060, 911, 1177,
	-49852, -9242, -12904, -4231, -5201,
	// rgWeightOutput+18*30
	1810, -14387, -3023, -18559, -49273,
	-4916, 1402, -430, -3135, -28658,
	-3058, -438, 806, -44486, 693,
	419, -8411, -28738, 7280, -39228,
	-1584, 2883, -2202, 10115, -58593,
	913, -20875, -16145, -1376, -5204,
	// rgWeightOutput+19*30
	863, 1715, 4286, 2662, 1844,
	-7694, -4479, -6185, 2210, -1309,
	-5437, 623, 869, 747, 521,
	719, -1173, 5543, 2859, 937,
	2906, 2149, -6562, -2969, 4872,
	528, -7391, -20825, -3666, 4686
};  // rgWeightOutput[20*30]

const int rg_1_BiasOutput[20] = {
	1295, -683, -3430, -2662, -7903,
	-26874, -53784, -30152, 864, -304,
	-115900, -95142, -5202, -3823, -3574,
	-4351, -2529, -2607, -10164, -9368
};  // rgBiasOutput[20]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\grouse_db.c ===
/************************ ...\grouse\src\grouse_db.c ***********************\
*																			*
*		Functions for handling Grouse database.								*
*																			*
*	Created:	September 19, 2001											*
*	Author:		Petr Slavik, pslavik										*
*																			*
\***************************************************************************/

#include "grouse.h"
#include "grouse_net1.h"		// Created by dumpwts _1_ ...
#include "grouse_net2.h"		// Created by dumpwts _2_ ...
#include "grouse_table1.h"		// Created by extract _1 ...
#include "grouse_table2.h"		// Created by extract _2 ...


GROUSE_DB	gGrouseDb;

//
// List of gestures supported by Grouse

static WCHAR g_awcGrouseGestures[] =
{
	GESTURE_NULL,			// Anything that is not a gesture
	GESTURE_SCRATCHOUT,
	GESTURE_TRIANGLE,
	GESTURE_SQUARE,
	GESTURE_STAR,
	GESTURE_CHECK,
	GESTURE_CURLICUE,
	GESTURE_DOUBLE_CURLICUE,
	GESTURE_CIRCLE,
	GESTURE_DOUBLE_CIRCLE,
	GESTURE_SEMICIRCLE_LEFT,
	GESTURE_SEMICIRCLE_RIGHT,
	GESTURE_CHEVRON_UP,
	GESTURE_CHEVRON_DOWN,
	GESTURE_CHEVRON_LEFT,
	GESTURE_CHEVRON_RIGHT,
	GESTURE_ARROW_UP,
	GESTURE_ARROW_DOWN,
	GESTURE_ARROW_LEFT,
	GESTURE_ARROW_RIGHT,
//	GESTURE_UP,
//	GESTURE_DOWN,
//	GESTURE_LEFT,
//	GESTURE_RIGHT,
//	GESTURE_UP_DOWN,
//	GESTURE_DOWN_UP,
//	GESTURE_LEFT_RIGHT,
//	GESTURE_RIGHT_LEFT,
//	GESTURE_UP_LEFT_LONG,
//	GESTURE_UP_RIGHT_LONG,
//	GESTURE_DOWN_LEFT_LONG,
//	GESTURE_DOWN_RIGHT_LONG,
//	GESTURE_UP_LEFT,
//	GESTURE_UP_RIGHT,
//	GESTURE_DOWN_LEFT,
//	GESTURE_DOWN_RIGHT,
//	GESTURE_LEFT_UP,
//	GESTURE_LEFT_DOWN,
//	GESTURE_RIGHT_UP,
//	GESTURE_RIGHT_DOWN,
	GESTURE_EXCLAMATION,
//	GESTURE_TAP,
//	GESTURE_DOUBLE_TAP,
};

#define MAX_GROUSE_GESTURES  sizeof(g_awcGrouseGestures) / sizeof(g_awcGrouseGestures[0])


/***************************************************************************\
*	InitGrouseDB:															*
*		Initialize Grouse database using the header files obtained from		*
*		TrnTRex and dumpwts.												*
\***************************************************************************/

void
InitGrouseDB(void)
{
	int i;

	ZeroMemory( gGrouseDb.adwGrouseGestures, MAX_GESTURE_DWORD_COUNT * sizeof(DWORD) );
	for (i = 0; i < MAX_GROUSE_GESTURES; i++)
	{
		DWORD index = (DWORD) (g_awcGrouseGestures[i] - GESTURE_NULL);
		Set(index, gGrouseDb.adwGrouseGestures);
	}

	gGrouseDb.node2gID[0] = node2gID_1;		// Arrays of node labels for each
	gGrouseDb.node2gID[1] = node2gID_2;		// neural net

	gGrouseDb.cInputs[0] = c_1_Input;		// # of ftrs for 1-stroke characters
	gGrouseDb.cInputs[1] = c_2_Input;		// # of ftrs for 2-stroke characters

	gGrouseDb.cHiddens[0] = c_1_Hidden;		// # of hidden nodes for 1-stroke NN
	gGrouseDb.cHiddens[1] = c_2_Hidden;		// # of hidden nodes for 2-stroke NN

	gGrouseDb.cOutputs[0] = c_1_Output;		// # of outputs (= supported code points)
	gGrouseDb.cOutputs[1] = c_2_Output;

	ASSERT(c_1_Output == cNodes_1);		// # of nodes (from grouse_table) must
	ASSERT(c_2_Output == cNodes_2);		// equal to # of NN outputs!

	gGrouseDb.aprgWeightHidden[0]	= (WEIGHT *)rg_1_WeightHidden;	// Arrays of wts
	gGrouseDb.aprgWeightHidden[1]	= (WEIGHT *)rg_2_WeightHidden;	// to hidden nodes

	gGrouseDb.aprgBiasHidden[0]	= (WEIGHT *)rg_1_BiasHidden;	// Bias values
	gGrouseDb.aprgBiasHidden[1]	= (WEIGHT *)rg_2_BiasHidden;	// for hidden nodes

	gGrouseDb.aprgWeightOutput[0]	= (WEIGHT *)rg_1_WeightOutput;	// Arrays of wts
	gGrouseDb.aprgWeightOutput[1]	= (WEIGHT *)rg_2_WeightOutput;	// to output nodes

	gGrouseDb.aprgBiasOutput[0]	= (WEIGHT *)rg_1_BiasOutput;	// Bias values
	gGrouseDb.aprgBiasOutput[1]	= (WEIGHT *)rg_2_BiasOutput;	// for output nodes
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\grouse.c ===
/***************************************************************************\
*																			*
*			Main file for the grouse recognizer.							*
*																			*
\***************************************************************************/

#include "common.h"
#include "grouse.h"

extern GROUSE_DB  gGrouseDb;

/***************************************************************************\
*	GrouseReco:																*
*		Main function for the Grouse Recognizer.							*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
GrouseReco(GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
		   int cAlts,					// I: Max # of alternates needed
		   GLYPH *pGlyph,				// I: One character ink
		   DWORD *pdwEnabledGestures)	// I: Bit array of enabled gestures
{
	DWORD adwGestures[MAX_GESTURE_DWORD_COUNT];	// Bit array of enabled grouse gestures
	WORD awFtrs[MAX_STROKES * FRAME_FTRS];	// Array of features
	int cStrokes;							// # of strokes
	int i;

	for (i = 0; i < MAX_GESTURE_DWORD_COUNT; i++)
	{
		adwGestures[i] = pdwEnabledGestures[i] & gGrouseDb.adwGrouseGestures[i];
	}

	cStrokes = FeaturizeInk(pGlyph, awFtrs);
	
	//
	// If no features extracted, exit

	if (cStrokes <= 0)
	{
		return 0;
	}

	// Compute the list of best matching code points

	ASSERT(0 <= cAlts);
	ASSERT(cAlts <= MAX_GESTURE_ALTS);
	cAlts = GrouseMatch(awFtrs,
						cStrokes,
						adwGestures,
						pGestAlt,
						cAlts);
	return cAlts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\inc\grouse_net2.h ===
// layer 0
const int c_2_Input = 44;
// layer 1
const int c_2_Hidden = 25;
const int rg_2_WeightHidden[25*44] = {
	// rgWeightHidden+0*44
	3296, -2320, -1376, -1101, 854,
	1482, -1641, 646, -817, -259,
	445, -1476, -2, -111, -260,
	-570, -156, -124, -346, -5290,
	-4290, -6066, -3925, 853, -4490,
	-60, -173, -530, 335, -434,
	-2585, -1474, -981, -42, 2960,
	60, 2439, -1463, -732, 412,
	-939, -872, 7124, 644,	// rgWeightHidden+1*44
 -4545,
	718, -2521, 309, 1967, -582,
	1076, -661, -1820, -1763, 9761,
	-8148, 2394, 8120, 4984, -11304,
	-13535, -2246, -2103, 8157, -6168,
	-2215, 4196, 566, 1085, -1,
	-177, 3927, 2437, -1033, 2857,
	-937, 852, 3671, 1880, 1384,
	-909, -9100, -4718, 2527, 1271,
	2397, 195, 659,	// rgWeightHidden+2*44
 -2198, -129,
	-7382, 815, 6918, 3272, 704,
	-832, -1098, -1342, 207, 2052,
	3395, -3093, 1139, 941, -754,
	1672, -832, 8004, 250, 1432,
	-620, -881, -6427, -2478, 364,
	-3068, 3122, -1657, -2636, 904,
	-168, 168, -865, -784, -1919,
	-1502, 973, -1350, -2130, 10192,
	-4481, 1315,	// rgWeightHidden+3*44
 3361, -149, 219,
	-329, 1659, 2728, -585, 234,
	-1195, -1645, 1699, -133, -182,
	689, 375, -2637, 91, -105,
	-1119, 133, -1184, -1957, 1971,
	-61, -1343, 66, 66, -2481,
	-1262, -784, -1321, -1698, 1395,
	-6596, -2132, 1063, 2379, -2677,
	-2073, -520, 70, -223, 6476,
	-1442,	// rgWeightHidden+4*44
 -11337, 2453, -2686, -550,
	736, 958, 1665, -1916, -1327,
	1502, -479, 611, 112, 577,
	-1148, -833, 1594, 893, -704,
	2981, -1074, 989, -4278, 2327,
	-1996, 3209, -2365, -2120, 290,
	451, 991, -588, -1742, -2087,
	-2799, 4406, -847, 2336, -492,
	-428, 758, -2983, 96, -237,
	// rgWeightHidden+5*44
	1357, -254, 1428, -1182, 1643,
	50, -581, -768, 206, -638,
	-8329, -2320, 4752, -345, -1822,
	5003, 1158, -2836, -239, 4395,
	-1637, 2484, -206, -1816, -2875,
	143, 704, -907, -2777, 1717,
	1865, 228, -570, 899, 2045,
	2578, -3571, -3441, -172, 967,
	907, -1334, -13303, 2590,	// rgWeightHidden+6*44
 5269,
	560, -324, -861, -1271, -663,
	1817, -1012, -1196, 1352, 1616,
	-4225, 1602, -1979, -506, -5217,
	-171, 1445, -3299, -3760, -3241,
	-4046, 6882, -13, 3717, 1967,
	8452, -3490, -2850, -5967, 6385,
	1016, -216, 6681, 5620, -2176,
	-2815, 1583, -2043, -5002, -3527,
	-1410, 5548, 89,	// rgWeightHidden+7*44
 7930, -282,
	1326, -662, -3142, 1739, 326,
	-4594, -380, 735, -275, 887,
	951, 113, -2368, 516, -529,
	-465, -931, -2116, -9190, 955,
	910, -1285, -1460, -338, -352,
	-1534, 1021, -965, -773, 403,
	-2355, 3683, -682, -805, 616,
	-222, -1107, -281, -1134, -2109,
	6080, -4936,	// rgWeightHidden+8*44
 -6744, -280, -577,
	-287, 2878, 1058, 2297, -393,
	212, 149, -2970, 1678, 1171,
	1801, -11, -4236, 989, -1879,
	1538, 341, -2003, 48, 2748,
	-2737, -6208, -7660, -140, 5849,
	-4221, 7172, -7532, -6969, -1812,
	2323, -559, 4350, 11302, -943,
	-3320, 2371, -2250, -133, 6177,
	6390,	// rgWeightHidden+9*44
 7909, -101, -1411, -891,
	254, -1903, 1465, 1, 1688,
	-3843, -1253, -771, -822, -917,
	-2101, -1420, -1475, -1189, -1501,
	2801, -1500, -2986, 2601, 7066,
	-1065, -910, -1907, -2221, -1951,
	-1623, 39, -1542, -1582, 6122,
	2783, -2687, -285, -1794, -1262,
	-2026, 287, 1212, -2106, -2054,
	// rgWeightHidden+10*44
	7991, 49, -128, -685, 436,
	-914, -525, -1508, -2657, 2072,
	385, -7982, -2849, -1690, 838,
	1314, -1035, -64, -1281, 665,
	367, -3746, 2978, -1920, -2000,
	5508, -2701, -3692, -3574, -1170,
	3323, -894, -597, -5222, -4817,
	-2493, -1412, -1850, 760, 2171,
	2760, -1520, 7701, -5143,	// rgWeightHidden+11*44
 -8036,
	-1249, 5777, 2693, 515, -7199,
	7625, 4079, -3118, -2045, -430,
	260, 1458, 3555, -2761, -1277,
	1425, -1142, 2093, -8747, -724,
	1289, -2186, 415, 3299, -757,
	3115, -2582, -1020, 2282, -3556,
	-3248, 804, 790, 20, 172,
	-1574, 510, 3636, -60, 2175,
	-7709, 1786, 764,	// rgWeightHidden+12*44
 8438, 1246,
	-1546, -3066, -576, -779, 111,
	-3071, 2, 1422, -371, -3083,
	1235, -1735, -1213, 338, -1254,
	-1251, -980, 3256, -6278, -821,
	-304, 981, -2155, -514, -852,
	-473, 1051, -1739, -1731, -811,
	-253, 1473, -1151, 438, 139,
	-724, -808, -1182, -1040, 2306,
	7692, -6689,	// rgWeightHidden+13*44
 -6911, -816, -619,
	-1576, -72, 399, 540, -552,
	-413, 87, 97, 2477, -1275,
	-1171, -1981, 781, -273, -2840,
	1822, 1109, 600, -308, -2386,
	873, 4381, -2392, 1562, -1921,
	525, 2086, -3048, -646, 1177,
	2033, 152, -3042, -1205, 3833,
	1173, -2993, -629, -3588, 5722,
	-611,	// rgWeightHidden+14*44
 390, -1777, -1961, 676,
	144, -372, -469, -308, 165,
	-84, -1948, 1039, 997, -594,
	-703, 43, -69, -457, -256,
	224, -988, 477, 191, -816,
	-2183, 608, 355, -642, -594,
	-277, -223, 39, 321, 641,
	-568, -1305, 360, 772, -82,
	-1324, -171, 194, 867, -394,
	// rgWeightHidden+15*44
	-1746, -1502, -1850, 1136, -170,
	-3064, 296, 1281, -301, -121,
	-181, 427, 727, 111, -533,
	-1440, 394, -362, -850, 1276,
	-1315, -42, -1922, -5545, 2558,
	349, -154, -782, 223, 964,
	-188, 103, 405, 683, 712,
	-4, -1633, -827, 99, 930,
	-786, 2050, -44, 1375,	// rgWeightHidden+16*44
 3474,
	-919, -408, -2486, 727, 95,
	2510, -4589, -2683, -1754, -5116,
	6198, 1312, -2714, -6423, -1493,
	231, -2254, 3688, -1463, -1902,
	2303, 966, 2596, 2432, 537,
	-4870, 1215, 2501, -177, -1197,
	-1860, 2389, 1546, 3984, 466,
	-8888, 1452, 1433, -7759, 4688,
	-762, -5096, -1788,	// rgWeightHidden+17*44
 -603, -493,
	-231, -151, -176, -211, -56,
	-76, -76, -123, 73, -784,
	-395, 12, -37, -145, -123,
	-103, -131, -855, -1942, 991,
	-1566, 1008, 148, -373, -374,
	-248, -463, 188, 26, -199,
	-54, -736, -355, -550, -118,
	86, 51, -148, -127, -428,
	621, 525,	// rgWeightHidden+18*44
 537, -2962, 3268,
	421, -1090, -884, -131, 52,
	-272, -456, -2820, -190, -940,
	127, -496, -834, 99, 306,
	-451, 14, -1381, -1700, 242,
	-394, 1869, 116, -265, -352,
	239, -674, -179, -223, -752,
	1300, 321, 1183, -358, -1944,
	-428, 917, -454, -536, -1198,
	-790,	// rgWeightHidden+19*44
 -2737, 44, -37, -412,
	-710, 1250, -893, 98, 436,
	-1508, 619, -1287, -1600, 1062,
	-3906, -5548, 4123, 3872, -312,
	440, -2485, -1528, 2217, -215,
	436, -1077, -334, 3985, -2488,
	1002, -504, 1264, 692, 812,
	28, 423, -1386, -1025, -1826,
	-2899, 320, 362, 8576, 2037,
	// rgWeightHidden+20*44
	-1892, -4103, 341, -1259, 510,
	207, -705, -1014, -504, -7,
	-311, -1511, -12, -150, -307,
	51, -214, -581, -213, -1408,
	-99, -2024, 490, 515, 1236,
	-707, -471, -587, -179, 3,
	-257, -328, -486, -2111, -1305,
	-475, 465, -19, 212, -76,
	107, -2584, 5713, -733,	// rgWeightHidden+21*44
 2468,
	78, -364, -1157, -306, -435,
	969, 319, 866, -3928, 8949,
	-6652, 3017, 6719, 3042, -5344,
	-7495, -2163, 3894, 2085, -2979,
	-3490, 5101, 1570, -911, -4123,
	7, -4080, 4815, -3097, -2564,
	-1615, -1406, -1812, -16, 2644,
	1660, -4524, -2953, -3510, -1990,
	-466, 10502, -1417,	// rgWeightHidden+22*44
 -6778, -7675,
	2588, -2857, -761, -1468, 3551,
	1968, -1914, 2113, -4613, -1225,
	2646, -1209, -2876, 473, -458,
	-1628, 915, -1611, 1981, -307,
	-5150, 1176, 1918, -3177, 3103,
	4194, 647, -1773, 1438, 2330,
	792, -19, 49, 526, -2425,
	-4123, 2607, 1864, -339, -5917,
	3098, -4107,	// rgWeightHidden+23*44
 1096, -658, -92,
	-280, -1357, 145, 1917, -2518,
	46, 321, 8043, -2314, 637,
	-2962, -2902, 1150, -1397, -2090,
	-1647, 2170, -9687, 153, -151,
	70, 2065, -3377, -4223, 3365,
	3967, -3395, -4431, 842, 3902,
	-3082, -740, 3696, -973, -3349,
	-717, -443, -5951, 1223, 8918,
	-8714,	// rgWeightHidden+24*44
 -11917, 7150, -8564, -4021,
	-1101, 5486, 4346, -3526, 821,
	1996, -674, -661, -2497, 215,
	2837, 2069, 803, -2606, -1822,
	-9317, 897, -1451, -3841, -1103,
	-2245, -644, 4986, 3976, -1419,
	2063, 1344, -2402, 49, 2595,
	-660, 1469, -1204, 2176, -1737,
	-4025, 14, 4029, 1566, -4488
};  // rgWeightHidden[25*44]

const int rg_2_BiasHidden[25] = {
	-520, -2811, -2073, -2357, 223,
	811, -2497, -965, 835, -2841,
	-227, -796, -1488, -479, -411,
	122, -573, -223, -636, -1566,
	-560, -3891, 1241, -2391, 299
};  // rgBiasHidden[25]

// layer 2
const int c_2_Output = 8;
const int rg_2_WeightOutput[8*25] = {
	// rgWeightOutput+0*25
	-10117, -1949, 2410, -7357, -13268,
	-1368, -212, -6260, -1461, -9803,
	-6956, -1425, -3080, -6160, -5095,
	-5673, -11134, -9168, -4622, 6239,
	-9804, -3088, -13831, -5877, -13358,
	// rgWeightOutput+1*25
	-9584, 3396, -18075, 5081, -9303,
	-8296, -2567, -9494, 2293, -12286,
	-16320, -12932, -10196, 10248, 4088,
	-2348, 3374, 562, -5801, -10083,
	-1587, -19764, -9560, -10794, 8167,
	// rgWeightOutput+2*25
	7793, 1282, -6130, -5317, 9507,
	926, 689, -8350, 1082, -14803,
	-15471, -17524, -10365, -4889, -3654,
	5674, -11141, 55, 2872, -4507,
	-5954, -17770, 8304, -9767, -8587,
	// rgWeightOutput+3*25
	-5792, -9833, -889, -2577, -10612,
	2055, 1305, -9827, -12, 8223,
	-12374, -7858, -10577, -7888, -197,
	-971, 8976, -3081, 1386, -7746,
	-11523, -18045, -5109, -10506, -10716,
	// rgWeightOutput+4*25
	-2357, 646, -6387, 8306, -8251,
	-10437, 853, -13096, 743, -4159,
	9879, -2250, -15354, -1926, -3445,
	-6888, -7231, -348, -1231, -5550,
	-320, 4214, -4776, -14025, -8499,
	// rgWeightOutput+5*25
	-7949, 12467, -3956, -10007, 5231,
	-10525, -9876, -10227, -2432, -13200,
	-14846, 14622, -10654, 9952, -3175,
	3697, -2308, -2293, 3051, -8136,
	-389, -14768, 9405, -10243, -9874,
	// rgWeightOutput+6*25
	-8576, 2802, 22284, -8411, 2732,
	-817, -10494, -10428, -575, -13368,
	-13447, -11373, -10502, -1232, -139,
	2086, -6268, -3128, -4664, -3736,
	-6236, -17884, -8591, -10471, 13240,
	// rgWeightOutput+7*25
	-760, -3658, -2836, 5684, -9597,
	-10235, 8204, 11923, 363, -3038,
	-1573, -8323, 6067, -1904, -46,
	-5572, -5562, -4452, 1106, -5627,
	-1672, -142, -2271, 11147, -5973
};  // rgWeightOutput[8*25]

const int rg_2_BiasOutput[8] = {
	1111, -1732, -1523, -1993, -2243,
	-13126, -25033, -9471
};  // rgBiasOutput[8]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\grouse_ftr.c ===
/********************** ...\grouse\src\grouse_ftr.c ************************\
*																			*
*					Functions for the Grouse featurizer.					*
*																			*
*	History:																*
*		May-08-2001	--- created												*
*		-by- Petr Slavik pslavik											*
*																			*
*		Oct-22-2001 --- added stroke-end features
*																			*
\***************************************************************************/

#include <math.h>
#include "common.h"
#include "math16.h"
#include "cowmath.h"
#include "cheby.h"

#include "grouse.h"

/***************************************************************************\
*	STROKE_INFO:															*
*																			*
*		Structure for keeping stroke-related info.							*
\***************************************************************************/

typedef struct tagSTROKE_INFO {
	int *aiXYs;		// Resampled x and y coordinates
	int cPoints;	// Count of resampled points
	int iStep;		// Resampling step	(must be at least 2!)
	int iStep2;		// Resampling step squared	
} STROKE_INFO;


/***************************************************************************\
*	StrokeLength:															*
*																			*
*		Compute a total legth of one frame (=stroke).						*
*																			*
\***************************************************************************/

static int
StrokeLength(FRAME *pFrame)		// I: Pointer to the stroke data
{
	long x, y;
	int dx, dy;
	XY *pPoint;
	int i;
	int iLength;
	
	pPoint = RgrawxyFRAME(pFrame);		// Get the starting point
	iLength = 0;
	for (i = CrawxyFRAME(pFrame) - 1; i > 0; i--)
	{
		x = pPoint->x;
		y = pPoint->y;
		pPoint++;
		dx = (int)(pPoint->x - x);
		dy = (int)(pPoint->y - y);
		iLength += ISqrt(dx*dx + dy*dy);
	}
	return iLength;
}


/***************************************************************************\
*	AddPoint:																*
*																			*
*		Based on function "AddPoint()" in "hwx\holycow\src\nfeature.c".		*
*																			*
*		Function to re-sample ink for a stroke.  It is called once for each	*
*		raw point.															*
*																			*
*		Returns TRUE on success.											*
*																			*
*	History:																*
*		03-Nov-1997 -by- Angshuman Guha aguha								*
*			Wrote it.														*
*		08-May-2001 -by- Petr Slavik; pslavik								*
*			Modified for use in Shrimp.										*
\***************************************************************************/

static int
AddPoint(STROKE_INFO *pStrokeInfo,	// I/O: Stroke related info
		 long x,					//  I:  X-coordinate of a raw point
		 long y)					//  I:  Y-coordinate of a raw point
{
	int dx, dy, dist2, dist;
	int x0, y0;

	x0 = pStrokeInfo->aiXYs[2*pStrokeInfo->cPoints-2];		// Previously
	y0 = pStrokeInfo->aiXYs[2*pStrokeInfo->cPoints-1];		// resampled point

	for (;;)
	{
		dx = (int)x - x0;
		dy = (int)y - y0;

		// CAUTION:  TabletPC DEPENDENT !!!
		// This is to avoid ink that has too large a gap between consecutive points
		// caused most likely by hardware issues!!!

		if ( dx > 0x4fff  || dy > 0x4fff || dx < -0x4fff || dy < -0x4fff)
		{
			return FALSE;
		}

		dist2 = dx*dx + dy*dy;
		if (dist2 < pStrokeInfo->iStep2)		// Raw point is too
			break;								// close--ignore it!

		// It is always guaranteed that iStep2 >= 4.
		// That implies that dist2 >= 4 here.
		// That in turn implies that dist = ISqrt(dist2) >= 2

		// Add a point at given step size

		dist = ISqrt(dist2);
		ASSERT(dist >= 2);
		x0 += pStrokeInfo->iStep * dx / dist;
		y0 += pStrokeInfo->iStep * dy / dist;

		// A minimum iStep of 2 and the fact that at least one of dx/dist and  dy/dist
		// must be bigger than 1/2, guarantees that the previous two assignments change
		// at least one of x0 and y0. Hence we cannot have an infinite loop!

		pStrokeInfo->aiXYs[2*pStrokeInfo->cPoints] = x0;
		pStrokeInfo->aiXYs[2*pStrokeInfo->cPoints+1] = y0;
		pStrokeInfo->cPoints++;
	}
	return TRUE;
}


/***************************************************************************\
*	NormalizePoints:														*
*																			*
*		Normalize the resampled points; i.e. shift them so that their mean	*
*		is 0 (X and Y independently), and scale them so that their			*
*		"average deviation" is LSHFT(1).									*
*																			*
\***************************************************************************/

BOOL
NormalizePoints(STROKE_INFO *pStrokeInfo)	// I/O: Stroke related info
{
	int *xy;
	int iSumX, iSumY, x0, y0, iVar;
	int i;

	//
    // Compute X-mean and Y-mean

	xy = pStrokeInfo->aiXYs;
	x0 = *xy++;
	y0 = *xy++;

    iSumX = iSumY = 0;
	for (i = pStrokeInfo->cPoints - 1; i > 0; i--)
	{
		iSumX += (*xy++) - x0;		// To prevent overflow,
		iSumY += (*xy++) - y0;		// make all values smaller
	}
	x0 += iSumX / pStrokeInfo->cPoints;
	y0 += iSumY / pStrokeInfo->cPoints;

	//
    // Shift points by means and compute the "variance"

	xy = pStrokeInfo->aiXYs;
	iVar = 0;
	for (i = pStrokeInfo->cPoints; i > 0; i--)
	{
		*xy -= x0;
		if (*xy < 0)
			iVar -= *xy;
		else
			iVar += *xy;
		xy++;

		*xy -= y0;
		if (*xy < 0)
			iVar -= *xy;
		else
			iVar += *xy;
		xy++;
		if (iVar < 0)		// Overflow!
		{
			return FALSE;
		}
	}

	iVar /= 2 * pStrokeInfo->cPoints;
	if (iVar < 1)
		iVar = 1;

	//
    // Scale points by the average "deviation"
	// (the average value is now roughly 1 = 2^16 in 16.16
	// float representation

	xy = pStrokeInfo->aiXYs;
	for (i = pStrokeInfo->cPoints; i > 0; i--)
	{
		*xy = LSHFT(*xy)/iVar;
		xy++;
		*xy = LSHFT(*xy)/iVar;
		xy++;
	}
	return TRUE;
}


/***************************************************************************\
*	AddNormalizedChebys:													*
*																			*
*		Add (cChebys-1) of normalized Chebyshev's coefficients to the		*
*		feature vector.														*
*																			*
*		Return a pointer to the first un-asigned feature.					*
*																			*
\***************************************************************************/

WORD *
AddNormalizedChebys(WORD *awFtrs,		// O: Feature vector
					int *aiChebys,		// I: Array of Chebyshev's coefficients
					int cChebys)		// I: Number of Chebys
{
	int iNorm;
	int iTemp, i;

	iNorm = 0;
	for (i = 1; i < cChebys; i++)		// 1st coeff skipped
	{
		if ( (aiChebys[i] < EPSILON) &&		// Zero out small coefficients
			 (aiChebys[i] > -EPSILON) )
		{
			aiChebys[i] = 0;
			continue;
		}
		else if (aiChebys[i] > +0x00800000)
		{
			aiChebys[i] = +0x00800000;	// 2^23 = 1 << 23;
		}
		else if (aiChebys[i] < -0x00800000)
		{
			aiChebys[i] = -0x00800000;
		}
		Mul16(aiChebys[i], aiChebys[i], iTemp)	// <= 2^30
        iNorm += iTemp;
		if (iNorm < 0)					// Check for overflow
			iNorm = 0x7FFFFFFF;
	}
	if (iNorm < 1)		// In case all Chebys were too small !!!!!!!!!!
	{
		iNorm = 1;
	}
	else
	{
		iNorm = ISqrt(iNorm);				// < 2^16
	}
	iNorm <<= 8; 

	for (i = 1; i < cChebys; i++)
	{
		iTemp = Div16(aiChebys[i], iNorm);		// Now between -1 and 1
		iTemp +=  LSHFT(1);						// Now between 0 and 2
		iTemp >>= 1;							// Now between 0 and 1
		if (iTemp >= 0x10000)
			iTemp = 0xFFFF;
		else if (iTemp < 0)
			iTemp = 0;
		*awFtrs++ = (WORD)iTemp;
	}
	return awFtrs;
}


/***************************************************************************\
*	FeaturizeFrame:															*
*																			*
*		Compute features of 1 frame (=stroke), i.e. 1 aspect ratio plus		*
*		normalized positions of end-points plus								*
*		(X_CHEBYS-1)+(Y_CHEBYS-1) of Chebyshev's coefficients.				*
*																			*
*		Return a pointer to the first un-asigned feature or NULL if			*
*		something goes wrong.												*
*																			*
\***************************************************************************/

WORD *
FeaturizeFrame(FRAME *frame,				// I: Data from a single stroke
			   STROKE_INFO *pStrokeInfo,	// I: Stroke related info
			   RECT *pRect,					// I: Bounding box of the whole ink
			   WORD *awFtrs)				// O: Stroke features
{
	int cRawPts = CrawxyFRAME(frame);		// # of points in the stroke
	XY *pPoint = RgrawxyFRAME(frame);		// Starting point of the stroke
	int chebyX[X_CHEBYS], chebyY[Y_CHEBYS];

	//
	// Aspect ratio feature

	*awFtrs++ = (WORD)(LSHFT(frame->rect.bottom - frame->rect.top)
					/ 
					(frame->rect.bottom - frame->rect.top + frame->rect.right - frame->rect.left));

#if 0
	//
	// Position of end-points inside the bounding box of the entire glyph

	*awFtrs++ = (WORD)(LSHFT(pStrokeInfo->aiXYs[0] - pRect->left)
					/
					(pRect->right - pRect->left));

	*awFtrs++ = (WORD)(LSHFT(pStrokeInfo->aiXYs[1] - pRect->top)
					/
					(pRect->bottom - pRect->top));

	*awFtrs++ = (WORD)(LSHFT(pStrokeInfo->aiXYs[2*cRawPts-2] - pRect->left)
					/
					(pRect->right - pRect->left));

	*awFtrs++ = (WORD)(LSHFT(pStrokeInfo->aiXYs[2*cRawPts-1] - pRect->top)
					/
					(pRect->bottom - pRect->top));

#endif
	//
	// Resample the raw points

	pStrokeInfo->aiXYs[0] = (int)pPoint->x;
	pStrokeInfo->aiXYs[1] = (int)pPoint->y;
	pStrokeInfo->cPoints = 1;
	for (cRawPts--,	pPoint++; cRawPts > 0; cRawPts--, pPoint++)
	{
		if ( !AddPoint(pStrokeInfo, pPoint->x, pPoint->y) )
		{
			return (WORD *)NULL;
		}
	}
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// Deal with the last point somehow?
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	//
	// Normalize points
	
	NormalizePoints(pStrokeInfo);

	//
    // X Chebyshev

	ASSERT(X_CHEBYS <= IMAXCHB);  // May have to adjust IMAXCHB in "cheby.h"
	if ( !LSCheby(pStrokeInfo->aiXYs, pStrokeInfo->cPoints, chebyX, X_CHEBYS) )
	{
		return (WORD *)NULL;
	}

	awFtrs = AddNormalizedChebys(awFtrs, chebyX, X_CHEBYS);

	//
    // Y chebyshev

	ASSERT(Y_CHEBYS <= IMAXCHB);  // May have to adjust IMAXCHB in "cheby.h"
	if ( !LSCheby(pStrokeInfo->aiXYs + 1, pStrokeInfo->cPoints, chebyY, Y_CHEBYS) )
	{
		return (WORD *)NULL;
	}
	awFtrs = AddNormalizedChebys(awFtrs, chebyY, Y_CHEBYS);


	return awFtrs;
}


/***************************************************************************\
*	FeaturizeInk:															*
*																			*
*		Given a glyph for one character, compute a vector of features.		*
*		Return # of strokes in the glyph or -1 if something goes wrong.		*
*																			*
*	Features used:															*
*		Aspect ratio of the entire glyph (width/width+height)				*
*		For each stroke:													*
*			Chebyshev's coefficients (9 from X's, 9 from Y's)				*
*			Aspect ratio of the stroke										*
*			Proportion of the stroke length w.r.t. glyph length.			*
*																			*
*		For one-stroke glyphs, only the global aspect ratio and the Chebys	*
*		are used, because the stroke aspect ratio and length proportion		*
*		are redundant or constant.											*
*																			*
\***************************************************************************/

int
FeaturizeInk(GLYPH *pGlyph,		// I: Glyph of one character
			 WORD *awFtrs)		// O: Array of features
{
	GLYPH	*pGl;
	RECT	rectGlyph, rectFrame;
	int aiStrokeLength[MAX_STROKES];
	int iHeight, iWidth;
	int cPoints;
	int iTotalLength;
	int cFrames, iFrame;
	STROKE_INFO strokeInfo;
//	WORD *pwEndFtrs = awFtrs + MAX_STROKES * FRAME_FTRS;

	GetRectGLYPH(pGlyph, &rectGlyph);
	iHeight = (int)(rectGlyph.bottom - rectGlyph.top);
	iWidth = (int)(rectGlyph.right - rectGlyph.left);

	//
	// Compute the total count of raw data points and the # of strokes

	cPoints = 0;
	cFrames = 0;
	iTotalLength = 0;
	for (pGl = pGlyph; pGl != (GLYPH *)NULL; pGl = pGl->next)
	{
		if (IsVisibleFRAME(pGl->frame))
		{
			if (cFrames >= MAX_STROKES)
				return -1;
			cPoints += pGl->frame->info.cPnt;
			iTotalLength += aiStrokeLength[cFrames] = StrokeLength(pGl->frame);
			cFrames++;
		}
	}
	ASSERT(cFrames <= MAX_STROKES);

	//
	// Allocate memory for the resampled stroke
	
	strokeInfo.aiXYs = (int *)ExternAlloc(2 * cPoints * sizeof(int));
	if (strokeInfo.aiXYs == (int *)NULL)
		return -1;

	//
	// Compute resampling step

	cPoints -= cFrames;
	strokeInfo.iStep = (cPoints > 0 ? 2 * iTotalLength / cPoints : 0) + 1;
	if (strokeInfo.iStep < 2)
	{
		strokeInfo.iStep = 2;
	}
	strokeInfo.iStep2 = strokeInfo.iStep * strokeInfo.iStep;

	//
	// Featurize each stroke

	iFrame = 0;
	for (pGl = pGlyph; pGl != (GLYPH *)NULL; pGl = pGl->next)
	{
		if ( ! IsVisibleFRAME(pGl->frame) )
		{
			continue;
		}
		//
		// Compute "local" features of each frame (chebys+aspect ratio)

		awFtrs = FeaturizeFrame(pGl->frame,				// Frame
								&strokeInfo,			// Stroke info
								&rectGlyph,				// Bounding box of the ink
								awFtrs);				// Stroke ftrs
		if (awFtrs == (WORD *)NULL)
		{
			ExternFree( (void *)strokeInfo.aiXYs );
			return -1;
		}

		if (cFrames <= 1)	// for 1-stroke chars, don't need global ftrs
			goto cleanup;
		//
		// Compute "global" features of each frame (position, relative size)

		// Horizontal position
		rectFrame = pGl->frame->rect;
		*awFtrs++ =						// Between 0 and 1
			(WORD)( LSHFT( rectFrame.left + rectFrame.right - 2 * rectGlyph.left ) 
					/
				  ( (rectGlyph.right - rectGlyph.left) * 2) );

		// Vertical position
		*awFtrs++ = 
			(WORD)( LSHFT( rectFrame.top + rectFrame.bottom - 2 * rectGlyph.top ) 
					/
				  ( (rectGlyph.bottom - rectGlyph.top) * 2) );


		// Length proportion
		*awFtrs++ =  (WORD)(iTotalLength > 0 ? 
						(LSHFT(aiStrokeLength[iFrame]) / iTotalLength) : 0);

		iFrame++;
	}
	ASSERT(iFrame == cFrames);
cleanup:
	ExternFree((void *)strokeInfo.aiXYs);
	return cFrames;
}


/***************************************************************************\
*	CountFtrs:																*
*																			*
*		Given the number of strokes in a character, return the number of	*
*		features output by "ShrinkFeaturize()".								*
*																			*
\***************************************************************************/

int
CountFtrs(int cStrokes)		// I: Number of strokes
{
	if (cStrokes == 1)
		return FRAME_FTRS - 3;
	else
		return cStrokes * FRAME_FTRS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\grouse_nn.c ===
#include <common.h>
#include <limits.h>

#include "math16.h"
#include "grouse.h"


/***************************************************************************\
*	ForwardFeedLayer:														*
*																			*
*	Simulate a computation of NN between two layers.						*
*																			*
\***************************************************************************/

static void
ForwardFeedLayer(int cLayer0,				// I: # nodes in the "from" layer
				 WORD *rgLayer0,			// I: Node values in the "from" layer
				 int cLayer1,				// I: # nodes in the "to" layer
				 WORD *rgLayer1,			// O: Node values in the "to" layer
				 const WEIGHT *rgWeight,	// I: Weights between "from" and "to" nodes
				 const WEIGHT *rgBias)		// I: Bias values for "to" layer
{
	int i, j;
	__int64 sum;
	__int64 iVal;
	unsigned short *pInput;

	for (i=cLayer1; i; i--)
	{
		sum = ((__int64)(*rgBias++)) << 16;
		pInput = rgLayer0;
		for ( j = cLayer0; j > 0; j--)
		{
			iVal = (__int64)(*rgWeight++) * (*pInput++);
			sum	 += iVal;			
		}

		sum	= (sum >> 8);

		sum	=	max (INT_MIN + 1, min(INT_MAX - 1, sum));
		
		j = Sigmoid16((int)sum);
		if (j > 0xFFFF)
			j = 0xFFFF;

		*rgLayer1++ = (WORD)j;
	}
}


/***************************************************************************\
*	ForwardFeed:															*
*																			*
*	Given neural net ID and an array of features, compute output values.	*
*																			*
*	Return the number of output nodes.										*
*																			*
\***************************************************************************/
 
void
ForwardFeed(int	cStrokes,		// I: Number of strokes (=ID of the net)
			WORD *awFtrs,		// I: Array of features
			WORD *awOutput)		// O: Array of output values
{
	WORD awHidden[MAX_HIDDEN];

	cStrokes--;

	ForwardFeedLayer(gGrouseDb.cInputs[cStrokes],		// Input to hidden
					 awFtrs,
					 gGrouseDb.cHiddens[cStrokes], 
					 awHidden,
					 gGrouseDb.aprgWeightHidden[cStrokes],
					 gGrouseDb.aprgBiasHidden[cStrokes]);

	ForwardFeedLayer(gGrouseDb.cHiddens[cStrokes],	// Hidden to output
					 awHidden,
					 gGrouseDb.cOutputs[cStrokes],
					 awOutput,
					 gGrouseDb.aprgWeightOutput[cStrokes],
					 gGrouseDb.aprgBiasOutput[cStrokes]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\validate.c ===
/***************************************************************************\
*	This file contains a list of gestures and a list of ASCII characters	*
*	that should be used for training and testing the grouse and twister		*
*	recognizers.															*
\***************************************************************************/

#include "common.h"
#include "grouse.h"
#include "recdefs.h"


//
// List of gestures that must be written in 1 stroke

static WCHAR g_awcSingles[] =
{
	GESTURE_SCRATCHOUT,
	GESTURE_STAR,
	GESTURE_CHECK,
	GESTURE_CURLICUE,
	GESTURE_DOUBLE_CURLICUE,
	GESTURE_CIRCLE,
	GESTURE_DOUBLE_CIRCLE,
	GESTURE_SEMICIRCLE_LEFT,
	GESTURE_SEMICIRCLE_RIGHT,
	GESTURE_CHEVRON_UP,
	GESTURE_CHEVRON_DOWN,
	GESTURE_CHEVRON_LEFT,
	GESTURE_CHEVRON_RIGHT,
	GESTURE_UP,
	GESTURE_DOWN,
	GESTURE_LEFT,
	GESTURE_RIGHT,
	GESTURE_UP_DOWN,
	GESTURE_DOWN_UP,
	GESTURE_LEFT_RIGHT,
	GESTURE_RIGHT_LEFT,
	GESTURE_UP_LEFT_LONG,
	GESTURE_UP_RIGHT_LONG,
	GESTURE_DOWN_LEFT_LONG,
	GESTURE_DOWN_RIGHT_LONG,
	GESTURE_UP_LEFT,
	GESTURE_UP_RIGHT,
	GESTURE_DOWN_LEFT,
	GESTURE_DOWN_RIGHT,
	GESTURE_LEFT_UP,
	GESTURE_LEFT_DOWN,
	GESTURE_RIGHT_UP,
	GESTURE_RIGHT_DOWN,
	GESTURE_TAP,
};

//
// List of gestures that must be written in 2 strokes

static WCHAR g_awcDoubles[] =
{
	GESTURE_EXCLAMATION,
	GESTURE_DOUBLE_TAP,
};

static const int MAX_SINGLES = sizeof(g_awcSingles) / sizeof(g_awcSingles[0]);
static const int MAX_DOUBLES = sizeof(g_awcDoubles) / sizeof(g_awcDoubles[0]);

/***************************************************************************\
*	IsInTheList:															*
*		Check if a (unicode) character/gesture is in the (ordered) list.	*
\***************************************************************************/

BOOL
IsInTheList(WCHAR wcLabel,	// I: Label of the item
			WCHAR *awcList,	// I: List of items
			int	iSize)		// I: Size of the list
{
	int i = 0, j = iSize - 1;
	int k;

	while ( i < j )
	{
		k = (i + j) / 2;
		if (wcLabel > awcList[k] )
		{
			i = k + 1;
		}
		else
		{
			j = k;
		}
	}

	//
	// We should have i = j = k

	if (wcLabel == awcList[j])
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



/***************************************************************************\
*	IsValidGesture:															*
*		Function used for training and testing Grouse and Twister.			*
*		Check if given glyph could be wcLabel.								*
\***************************************************************************/

BOOL
IsValidGesture(GLYPH *pGlyph,			// I: Gesture's ink
			   WCHAR wcLabel)			// I: Gesture's label
{
	int cFrames;

	cFrames = CframeGLYPH(pGlyph);
	if ( (cFrames > MAX_STROKES) || (cFrames <= 0) )		// Skip glyphs with more 
	{														// than MAX_STROKES strokes
		return FALSE;
	}

	if ( (cFrames == 2)		&& 
		 IsInTheList(wcLabel, g_awcSingles, MAX_SINGLES) )
	{
		return FALSE;
	}
	if ( (cFrames == 1)		&& 
		 IsInTheList(wcLabel, g_awcDoubles, MAX_DOUBLES) )
	{
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\sources.inc ===
TARGETNAME=grouse
TARGETTYPE=LIBRARY

INCLUDES= $(INCLUDES) \
          $(_TPG_COMMON_INC); \
          $(_TPG_ROOT)\Wisp\public\sdk\inc; \
          $(_TPG_ROOT)\hwx\twister\grouse\inc; \
          $(_TPG_ROOT)\hwx\twister\inc; \
          $(_TPG_ROOT)\hwx\common\inc;  \
          $(_TPG_ROOT)\hwx\inferno\src; \
          $(_TPG_ROOT)\hwx\holycow\src; \

OBJLIBFILES= $(OBJLIBFILES) \
            $(_TPG_ROOT)\hwx\holycow\src\$(O)\holycow.lib		\


TARGETLIBS= $(TARGETLIBS) \
            $(_TPG_ROOT)\Common\TabAssert\$(PLAT_DIR)\$(O)\TabAssert.lib \
            $(_TPG_ROOT)\hwx\common\src\Win2kUnicode\$(O)\common.lib	\


SOURCES= \
         ..\grouse.c		\
         ..\grouse_db.c		\
         ..\grouse_ftr.c	\
         ..\grouse_match.c	\
         ..\grouse_NN.c		\
         ..\validate.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\grouse\src\grouse_match.c ===
#include "limits.h"
#include "common.h"
#include "rectypes.h"
#include "grouse.h"


// #define GEST_THRESHOLD		64880		// 0.99 * 0xfff = 0.99 * 65,535
// #define GEST_THRESHOLD		58981		// 0.9 * 0xfff = 0.9 * 65,535
#define GEST_THRESHOLD		52428		// 0.8 * 0xfff = 0.8 * 65,535
// #define GEST_THRESHOLD		39321		// 0.6 * 0xfff = 0.6 * 65,535
// #define GEST_THRESHOLD		32767		// 0.5 * 0xfff = 0.5 * 65,535


extern void 
ForwardFeed(int	cStrokes,		// I: Number of strokes (=ID of the net)
			WORD *awFtrs,		// I: Array of features
			WORD *awOutput);	// O: Array of output values



void
InsertAlternate(WORD awBestScores[MAX_GESTURE_ALTS],	// I/O: Best scores
				WCHAR awcBestChoices[MAX_GESTURE_ALTS],	// I/O: Best choices
				int cAlts,					//  I:  Length of the altlist
				DWORD *pdwEnabledGestures,	//  I:  Bit array of enabled gestures
				wchar_t wcLabel,			//  I:  Label of the alternate
				WORD wScore)				//  I:  score of the alternate
{
	int iAlt, iLoop;

	//
	// Insert this character into its correct place in the altlist

	if (wScore <= awBestScores[cAlts - 1])
	{
		return;
	}

	if ( !IsSet(wcLabel-GESTURE_NULL, pdwEnabledGestures) )
	{
		wcLabel = GESTURE_NULL;
	}

	if (wcLabel == GESTURE_NULL)
	{
		for (iAlt = 0; iAlt < cAlts; iAlt++)
		{
			if (awcBestChoices[iAlt] == GESTURE_NULL)
			{
				if (wScore <= awBestScores[iAlt])	// If old alternate better
				{
					return;
				}
				for (iLoop = iAlt + 1; iLoop < cAlts; iLoop++)
				{
					awcBestChoices[iLoop - 1] = awcBestChoices[iLoop];
					awBestScores[iLoop - 1] = awBestScores[iLoop];
				}
				break;
			}
		}
	}
	
	for (iAlt = 0; iAlt < cAlts; iAlt++)
	{
		if (wScore <= awBestScores[iAlt])
		{
			continue;
		}

		//
		// Shift all the old values down by one so we can add our new
		// entry to the return list.

		for (iLoop = cAlts - 1; iLoop > iAlt; iLoop--)
		{
			awcBestChoices[iLoop] = awcBestChoices[iLoop - 1];
			awBestScores[iLoop] = awBestScores[iLoop - 1];
		}

		//
		// Write in our new choice

		awBestScores[iAlt] = wScore;
		awcBestChoices[iAlt] = wcLabel;
		break;
	}
}
							
								
								
/***************************************************************************\
*	GrouseMatch:															*
*																			*
*	Given featurized ink, compute the altlist (with scores).				*
*																			*
*	History:																*
*		21-September-2001 -by- Petr Slavik pslavik							*
*			Wrote it.														*
\***************************************************************************/

int
GrouseMatch(WORD *awFtrs,				// I: Feature vector
			int	cStrokes,				// I: Number of strokes
			DWORD *pdwEnabledGestures,	// I: Bit array of enabled gestures
			GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
			int cMaxReturn)				// I: Max # of choices to return
{
	WORD awOutput[MAX_OUTPUT];						// Output scores
	WORD awBestScores[MAX_GESTURE_ALTS] = {0};		// Best scores
	WCHAR awcBestChoices[MAX_GESTURE_ALTS] = {0};	// Best choices

	int iAlt, iLoop;
	int iNode;
    wchar_t wcLabel;
	WORD	wScore;

	if (cMaxReturn <= 0)		// If no alt list needed
		return 0;
	if (cMaxReturn > MAX_GESTURE_ALTS)	// If list too long
		cMaxReturn = MAX_GESTURE_ALTS;

	ForwardFeed(cStrokes, awFtrs, awOutput);

	//
	// Initialize the first element of best scores and best choices

	awBestScores[0] = (WORD) GEST_THRESHOLD;
	awcBestChoices[0] = GESTURE_NULL;

    //
    // Loop through the nodes and find the best matches

    for (iNode = gGrouseDb.cOutputs[cStrokes-1] - 1; iNode >= 0; iNode--)
    {

		wcLabel = gGrouseDb.node2gID[cStrokes-1][iNode];
		wScore = awOutput[iNode];

		InsertAlternate(awBestScores, awcBestChoices, cMaxReturn,
						pdwEnabledGestures, wcLabel, wScore);
    }

    //
    // Compute the scores and count the number of non-zero best choices

    for (iAlt = 0; (iAlt < cMaxReturn) && (awBestScores[iAlt] > 0); iAlt++)
    {
        pGestAlt[iAlt].eScore = (float) awBestScores[iAlt] / (float)(0xFFFF);
		pGestAlt[iAlt].wcGestID = awcBestChoices[iAlt];
		pGestAlt[iAlt].hotPoint.x = LONG_MIN;		// Hot point is undefined
		pGestAlt[iAlt].hotPoint.y = LONG_MIN;
    }

    return iAlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\inc\twister.h ===
/************************ ...\twister\inc\twister.h ************************\
*																			*
*		Functions and data structures for the Twister recognizer.			*
*																			*
*	Created:	December 6, 2001											*
*	Author:		Petr Slavik, pslavik										*
*																			*
\***************************************************************************/

#ifndef __INCLUDE_TWISTER_H
#define __INCLUDE_TWISTER_H

#include "RecTypes.h"

#ifdef __cplusplus
extern "C" 
{
#endif

#include "common.h"
#include "twisterdefs.h"


/***************************************************************************\
*	TwisterReco:															*
*		Main function for the Twister Recognizer.							*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
TwisterReco(GEST_ALTERNATE *pGestAlt,		// O: Array of alternates
			int cAlts,						// I: Max # of alternates needed
			GLYPH *pGlyph,					// I: One character ink
			DWORD *pdwEnabledGestures,		// I: Bit array of enabled gestures
			LONG lPPI);					// I: Number of pts per inch



#ifdef __cplusplus
};
#endif

#endif	// __INCLUDE_TWISTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\inc\mothp.h ===
/************************ moth\inc\mothp.h *********************************\
*																			*
*				Private Include File for Moth Project						*
*																			*
\***************************************************************************/

#ifndef __INCLUDE_MOTHP_H
#define __INCLUDE_MOTHP_H

#include "common.h"
#include "twisterdefs.h"

#ifdef __cplusplus
extern "C" {
#endif

#define XRECO_ALT_MAX	1
#define PPI_CONVERSION	254	// Count of 0.1mm in 1 inch

#define  THREE_HALF(X)	 ( (X) + ((X)/2) )

#define abs(x)	((x) < 0 ? -(x) : (x))

typedef struct _STROKE {
	int cPoints;
	POINT *pPoints;
	struct _STROKE *pStrokeNext;
} STROKE;

typedef struct tagMOTH_DB
{
	DWORD	adwMothGestures[MAX_GESTURE_DWORD_COUNT];	// Gestures supported by Moth
	UINT	uDoubleDist;		// Max distance between starting poins of a DOUBLE_TAP
	UINT	uMaxTapLength;		// Max length of a tap stroke
	UINT	uMaxTapDist;		// Max distance from the start of a tap
} MOTH_DB;


extern MOTH_DB	gMothDb;	// Moth lib external variable!


/***************************************************************************\
*	ReadRegistryValues:														*
*		Read values from the registry and assign them to the database.		*
\***************************************************************************/

void
ReadRegistryValues(void);

/***************************************************************************\
*	TapGestureReco:															*
*		Recognize a single-tap gesture (and output a list of alternates).	*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
TapGestureReco(GLYPH *pGlyph,				//  I:  Input ink
			   GEST_ALTERNATE *pGestAlt,	// I/O: List of alternates
			   int cAlts,					//  I:  Length of the list
			   DWORD *pdwEnabledGestures,	//  I:  Bit array of enabled gestures
			   LONG lPPI);					//  I:  Points per inch


/***************************************************************************\
*	DoubleTapGestureReco:													*
*		Recognize a double-tap gesture (and output a list of alternates).	*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
DoubleTapGestureReco(GLYPH *pGlyph,				//  I:  Input ink
					 GEST_ALTERNATE *pGestAlt,	// I/O: List of alternates
					 int cAlts,					//  I:  Length of the list
					 DWORD *pdwEnabledGestures,	//  I:  Bit array of enabled gestures
					 LONG lPPI);				//  I:  Points per inch

					 
/***************************************************************************\
*	ScratchoutGestureReco:													*
*		Recognize scratchout gesture (and output a list of alternates).		*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
ScratchoutGestureReco(POINT *pPts,					// I: Array of points (single stroke)
					  int cPts,						// I: Number of points in stroke
					  GEST_ALTERNATE *pGestAlt,		// O: Array to contain alternates
					  int cMaxAlts,					// I: Max alternates to return 
					  DWORD *pdwEnabledGestures);	// I: Currently enabled gestures


/***************************************************************************\
*	CalligrapherGestureReco:												*
*		Recognize all "straight" gestures (and output a list of alternates).*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
CalligrapherGestureReco(POINT *pPts,				// I: Array of points (single stroke)
						int cPts,					// I: Number of points in stroke
						GEST_ALTERNATE *pGestAlt,	// O: Array to contain alternates
						int cMaxAlts,				// I: Max alternates to return 
						DWORD *pdwEnabledGestures);	// I: Currently enabled gestures


/***************************************************************************\
*	GestureATan2:															*
*		Compute the arctangent (in degrees) of y/x.							*
\***************************************************************************/

int
GestureATan2(int x,	int y);


/***************************************************************************\
*	GestureInteriorAngle:													*
*		Compute the interior angle (in degrees) between three points.		*
*		0 <= theta <= 180													*
\***************************************************************************/

int
GestureInteriorAngle(POINT *p1,		// I: End-point
					 POINT *p2,		// I: Vertex
					 POINT *p3);	// I: End-point


/***************************************************************************\
*	GestureIsStraight:														*
*		Given a sequence of points, determine if it's straight.				*
\***************************************************************************/

BOOL
GestureIsStraight(POINT *pt,		// I: Array of points
				  int iFirst,		// I: Index of the first point
				  int iLast,		// I: Index of the last point
				  UINT tolerance);	// I: Fraction of total length points are 


/***************************************************************************\
*	GestureDistance:														*
*		Compute the distance between two points.							*
\***************************************************************************/

UINT
GestureDistance(POINT *p1,	// I: Point 1
				POINT *p2);	// I: Point 2


#if 0
/* Given an input star, polygon, or circle, identify and return */

HRESULT WINAPI PolygonGestureReco(
	POINT *ppt,					// Array of points (single stroke)
	int cpt,					// Number of points in stroke
	GEST_ALTERNATE *pGestAlts,	// Array to contain alternates
	int *pcAlts,				// max alternates to return/alternates left
	DWORD *pdwEnabledGestures	// Currently enabled gestures
);
#endif // 0

#ifdef __cplusplus
}
#endif

#endif // __INCLUDE_MOTHP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\inc\twisterdefs.h ===
/********************** ...\twister\inc\twisterdefs.h **********************\
*																			*
*			Macros and data structures for the Twister recognizer			*
*		(used by Twister, Moth, Grouse, and potentially other modules)		*
*																			*
*	Created:	December 6, 2001											*
*	Author:		Petr Slavik, pslavik										*
*																			*
\***************************************************************************/

#ifndef __INCLUDE_TWISTERDEFS_H
#define __INCLUDE_TWISTERDEFS_H

#include "RecTypes.h"

#define MAX_GESTURE_COUNT		256
#define	MAX_GESTURE_DWORD_COUNT	MAX_GESTURE_COUNT / ( 8*sizeof(DWORD) )

#define MAX_GESTURE_ALTS			5

#define IsSet(index, adw)	\
	( adw[(index) >> 5] & (0x0001 << ((index) & 0x001f) ) )
#define Set(index, adw)		\
	( adw[(index) >> 5] |= (0x0001 << ((index) & 0x001f) ) )


typedef struct tagGEST_ALTERNATE
{
	WCHAR	wcGestID;
	float	eScore;
	CONFIDENCE_LEVEL confidence; // CFL_STRONG, CFL_INTERMEDIATE, CFL_POOR
	POINT	hotPoint;
} GEST_ALTERNATE;


#endif	// __INCLUDE_TWISTERDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\inc\moth.h ===
/************************ moth\inc\moth.h **********************************\
*																			*
*	Header file to be included by programs that need to call Moth.			*
*																			*
\***************************************************************************/

#ifndef __INCLUDE_MOTH_H
#define __INCLUDE_MOTH_H

#include "common.h"
#include "twisterdefs.h"


#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************\
*	InitMothDB:																*
*		Initialize Grouse database using the values from the registry.		*
\***************************************************************************/

void
InitMothDB(void);


/***************************************************************************\
*	MothReco:																*
*		Main function for the Moth Recognizer.								*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
MothReco(GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
		 int cAlts,					// I: Max # of alternates needed
		 GLYPH *pGlyph,				// I: One character ink
		 DWORD *pdwEnabledGestures,	// I: Bit array of enabled gestures
		 LONG	lPPI);				// I: Number of pts per inch

#ifdef __cplusplus
}
#endif


#endif // __INCLUDE_MOTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\moth.c ===
/************************ moth\src\moth.c **********************************\
*																			*
*					Main file for the Moth recognizer.						*
*																			*
\***************************************************************************/

#include "mothp.h"

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************\
*	MothReco:																*
*		Main function for the Moth Recognizer.								*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
MothReco(GEST_ALTERNATE *pGestAlt,	// O: Array of alternates
		 int cMaxAlts,				// I: Max # of alternates needed
		 GLYPH *pGlyph,				// I: One character ink
		 DWORD *pdwEnabledGestures,	// I: Bit array of enabled gestures
		 LONG	lPPI)				// I: Number of pts per inch
{
	DWORD adwGestures[MAX_GESTURE_DWORD_COUNT];	// Bit array of enabled Moth gestures
	int cStrokes = CframeGLYPH(pGlyph);
	int iGesture, cAlts = 0;
	int tmp, i;

	//
	// If no ink or no alternates needed,  exit

	if ( (cStrokes <= 0) || (cMaxAlts <= 0) )
	{
		return 0;
	}

	for (i = 0; i < MAX_GESTURE_DWORD_COUNT; i++)
	{
		adwGestures[i] = pdwEnabledGestures[i] & gMothDb.adwMothGestures[i];
	}

	// Compute the list of best matching code points

	ASSERT(cMaxAlts <= MAX_GESTURE_ALTS);

	if (cStrokes == 1)
	{
		cAlts = TapGestureReco(pGlyph, pGestAlt, cMaxAlts, pdwEnabledGestures, lPPI);
		if (cAlts > 0)
		{
			return cAlts;
		}


#if 1 // MOTH_SCRATCHOUT
		cAlts += ScratchoutGestureReco(pGlyph->frame->rgrawxy,
									(int)pGlyph->frame->info.cPnt,
									pGestAlt + cAlts, cMaxAlts - cAlts, adwGestures);
#endif
		cAlts += CalligrapherGestureReco(pGlyph->frame->rgrawxy,
									(int)pGlyph->frame->info.cPnt,
									pGestAlt + cAlts, cMaxAlts - cAlts, adwGestures);
#if 0 // MOTH_POLYGONS
		cAlts += PolygonGestureReco(pGlyph->frame->rgrawxy,
									(int)pGlyph->frame->info.cPnt,
									pGestAlt + cAlts, cMaxAlts - cAlts, adwGestures);
#endif
	}

	else if (cStrokes == 2)
	{
		cAlts = DoubleTapGestureReco(pGlyph, pGestAlt, cMaxAlts, pdwEnabledGestures, lPPI);
		if (cAlts > 0)
		{
			return cAlts;
		}
	}

	return cAlts;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\caligest.c ===
/************************** moth\src\caligest.c ****************************\
*																			*
*	Functions for recognizing "straight" gestures, i.e. consisting of 1-2	*
*	straight lines (like corners, chevrons, etc.)							*
*																			*
*	Originally calligrapher code, modified by Greg.							*
*	Complete overhaul by Petr (March 2002).									*
*																			*
\***************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include <limits.h>
#include "mothp.h"

/***************************************************************************\
*	GetFarFromIndex:														*
*		Find the point that is the furthest from the line connecting iLeft	*
*		and iRight.	If there are more than one points, return the center of *
*		the first "plateau".												*
*                                                                           *
*                                O <-iRight             iMostFar            *
*                               . O                       |                 *
*                              .   O                      |                 *
*                             .    O                      V                 *
*                            .    O                   OOOOOOOOO  OOO        *
*                           .     O                  O         OO   OO      *
*                          . ..   O                 O                 OO    *
*                         .    .. O                O....................O   *
*                    OOO .       .O                                         *
*                   O   O   O    OO <-iMostFar                              *
*                  O   . OOO O  O                                           *
*                  O  .       OO                                            *
*                 O  .                                                      *
*                 O .                                                       *
*                  O <-iLeft                                                *
*                                                                           *
*             <Distance> ~ <dY> = y - yStraight(x) =                        *
*                                                                           *
*                                                  x-xLeft                  *
*                 = y - yLeft - (yRight-yLeft) * ------------               *
*                                                xRight-xLeft               *
*                                                                           *
*                 ~ y*(xR-xL) - x*(yR-yL) + xL*(yR-yL) - yL*(xR-xL)         *
*                                                                           *
*              And no problems with zero divide!                            *
*																			*
*		This function might not work correctly when the end-points are		*
*		close to each other (for spikes).  That's why we need to deal with	*
*		special cases.														*
\***************************************************************************/

struct Constants
{
	long dxRL, dyRL, ldConst;
};

static long
LineDist(POINT *pPoint, struct Constants *pCons)
{
	long lDist = pPoint->y * pCons->dxRL - pPoint->x * pCons->dyRL + pCons->ldConst;
	if (lDist < 0)
	{
		return -lDist;
	}
	return lDist;
}

static long RightDist(POINT *pPoint, struct Constants *pCons) { return pPoint->x; }
static long LeftDist(POINT *pPoint, struct Constants *pCons) { return -pPoint->x; }
static long TopDist(POINT *pPoint, struct Constants *pCons) { return -pPoint->y; }
static long BottomDist(POINT *pPoint, struct Constants *pCons) {	return pPoint->y; }

static int
GetFarFromChordIndex(POINT *pTrace,
					 int iLeft,
					 int iRight,
					 RECT *pBox)
{
	int    i;
	int    iMostFar;
	long dxBox, dyBox;
	long   ldMostFar, ldCur;
	BOOL   bIncrEqual;
	BOOL   bFlatPlato;
	long (* Distance)(POINT *pPoint, struct Constants *pCons) = LineDist;
	struct Constants constants;

	constants.dxRL = pTrace[iRight].x - pTrace[iLeft].x;
	constants.dyRL = pTrace[iRight].y - pTrace[iLeft].y;
	constants.ldConst = pTrace[iLeft].x * constants.dyRL - pTrace[iLeft].y * constants.dxRL;
	bFlatPlato = TRUE;
	bIncrEqual = FALSE;

	dxBox = pBox->right - pBox->left;
	dyBox = pBox->bottom - pBox->top;

	if (dxBox < dyBox / 2)			// Bounding box vertical
	{
		if ( (pTrace[iLeft].y  > pBox->bottom - dyBox/2) &&		// End-points
			 (pTrace[iRight].y > pBox->bottom - dyBox/2) )		// near bottom
		{
			Distance = TopDist;
		}
		else if ( (pTrace[iLeft].y  < pBox->top + dyBox/2) &&	// End-points
				  (pTrace[iRight].y < pBox->top + dyBox/2) )	// near top
		{
			Distance = BottomDist;
		}
	}
	else if (dyBox < dxBox / 2)		// Bounding box horizontal
	{
		if ( (pTrace[iLeft].x  > pBox->right - dxBox/2) &&		// End-points
			 (pTrace[iRight].x > pBox->right - dxBox/2) )		// near right
		{
			Distance = LeftDist;
		}
		else if ( (pTrace[iLeft].x  < pBox->left + dxBox/2) &&	// End-points
				  (pTrace[iRight].x < pBox->left + dxBox/2) )	// near left
		{
			Distance = RightDist;
		}
	}

	iMostFar = iLeft;
	ldMostFar = Distance(pTrace+iLeft, &constants);
	for (i = iLeft + 1; i <= iRight; i++)
	{
		ldCur = Distance(pTrace+i, &constants);
		
		if (ldCur > ldMostFar)
		{
			ldMostFar  = ldCur;
			iMostFar   = i;
			bIncrEqual = FALSE;
			bFlatPlato = TRUE;
		}
		else if (bFlatPlato	&&	(ldCur == ldMostFar) )
		{
			if	( bIncrEqual )
				iMostFar++;
			bIncrEqual = !bIncrEqual;
		}
		else
		{
			bFlatPlato = FALSE;
		}
		
	}
	
	return	iMostFar;
	
} // GetFarFromChordIndex


/***************************************************************************\
*	GestureCheck:															*
*		Try to recognize a "straight" gesture.								*
*		Return recognized gesture ID or GESTURE_NULL if not confident.		*
\***************************************************************************/

static WCHAR
GestureCheck(POINT *pTrace,
			 int nPoints,
			 POINT *pHotPoint)
{
	RECT	box;
	RECT	rcBeg, rcEnd;
//	int	iTop, iBottom, iLeft, iRight;
	int	dxBox, dyBox, i;
	int	dxRun, dyRun;
	int	y1, y2, iFirstExtr = 0, iLastExtr = 0;
	int	x1, x2;
	int	xFirst, yFirst, xLast, yLast;
	int	iFirst, iLast, iFar;
	int	dxBeg, dyBeg, dxEnd, dyEnd;
	int	len, lenBeg, lenEnd;
	int	cornerAngle, cornerAngle2;
	POINT	p4;
	int	direction;
	BOOL	bIsLong;
	BOOL	bVH = FALSE;		// Is corner vertical-horizontal?
	BOOL	bHV = FALSE;		// Is corner horizontal-vertical?

	iFirst = 0;				// Index of the first point
	iLast = nPoints - 1;	// Index of the last point

	//
	// FoolProofing

	if (nPoints <= 4)
	{
		return GESTURE_NULL;
	}

	*pHotPoint = pTrace[iFirst];	// Default Hotpoint is the start-point

	//
	// Find the bounding box and the points that touch the bounding box

	xFirst = pTrace[iFirst].x;
	yFirst = pTrace[iFirst].y;
	xLast  = pTrace[iLast].x;
	yLast  = pTrace[iLast].y;

	box.top = box.bottom = yFirst;
	box.left = box.right = xFirst;
//	iTop = iBottom = iLeft = iRight = iFirst;

	for (i = iFirst + 1; i <= iLast; i++)
	{
		if (pTrace[i].x < box.left)
		{
			box.left = pTrace[i].x;
//			iLeft = i;
		}
		else if (pTrace[i].x > box.right)
		{
			box.right = pTrace[i].x;
//			iRight = i;
		}
		if (pTrace[i].y < box.top)
		{
			box.top = pTrace[i].y;
//			iTop = i;
		}
		else if (pTrace[i].y > box.bottom)
		{
			box.bottom = pTrace[i].y;
//			iBottom = i;
		}
	}

	dxBox = box.right - box.left + 1;
	dyBox = box.bottom - box.top + 1;

	//
	// Count |dx| and |dy| accumulated changes:

	dxRun = dyRun = 0;
	for  (i = iFirst; i < iLast; i++)
	{
		dxRun += abs( pTrace[i+1].x - pTrace[i].x );
		dyRun += abs( pTrace[i+1].y - pTrace[i].y );
	}

	//
	// Check first for UP, DOWN, LEFT, and RIGHT gestures

	if ( GestureIsStraight(pTrace, iFirst, iLast, 11) )
	{
		*pHotPoint = pTrace[iFirst];	// Hotpoint is the starting point

		if ( dxBox <= dyBox/4		&&				// UP and DOWN gestures
			 dxRun/4 <= dxBox		&&
			 dyRun < THREE_HALF(dyBox) )
		{
			// GEST_CAPITAL == GESTURE_UP
			if ( box.bottom - yFirst <= dyBox/5	&&
				 yLast - box.top     <= dyBox/5 )
			{
				return GESTURE_UP;
			}
			// GEST_DOWN == GESTURE_DOWN
			if ( box.bottom - yLast <= dyBox/5	&&
				 yFirst - box.top   <= dyBox/5 )
			{
				return GESTURE_DOWN;
			}
			return GESTURE_NULL;
		}

		if ( dyBox <= dxBox/3		&&				// LEFT and RIGHT gestures
			 dyRun/4 <= dyBox		&&
			 dxRun < THREE_HALF(dxBox) )
		{
			// GEST_ERASE == GESTURE_RIGHT
			if ( xFirst - box.left <= dxBox/5	&&
				 box.right - xLast <= dxBox/5 )
			{
				return GESTURE_RIGHT;
			}	
			// GEST_BACK == GESTURE_LEFT
			if ( xLast - box.left   <= dxBox/5	&&
				 box.right - xFirst <= dxBox/5 )
			{
				return GESTURE_LEFT;
			}
		}
		return GESTURE_NULL;
	}

	//
	// Find the point furthest from the line connecting the end-points

	iFar = GetFarFromChordIndex(pTrace, iFirst, iLast, &box);

	//
	// Get the lengths of all the interesting pieces

	len = (int)GestureDistance(pTrace+iFirst, pTrace+iLast);
	lenBeg = (int)GestureDistance(pTrace+iFirst, pTrace+iFar);
	lenEnd = (int)GestureDistance(pTrace+iFar, pTrace+iLast);

	if (lenBeg < 2 || lenEnd < 2)		// Lengths of the two halves
	{									// have to be non-trivial
		return GESTURE_NULL;
	}

	//
	// If one of the pieces is not straight we don't have a Moth gesture.

	if ( !GestureIsStraight(pTrace, iFirst, iFar, 5) ||
		 !GestureIsStraight(pTrace, iFar, iLast, 5) )
	{
		return GESTURE_NULL;
	}

	//
	// From here down, the hotpoint is the point furthest from the line
	// connecting the endpoints.

	*pHotPoint = pTrace[iFar];

	//
	// Find the bounding boxes of the beginning and end halves of the stroke

	rcBeg.top = rcBeg.bottom = yFirst;
	rcBeg.left = rcBeg.right = xFirst; 
	for (i = iFirst + 1; i <= iFar; i++)
	{
		if (pTrace[i].x < rcBeg.left)
			rcBeg.left = pTrace[i].x;
		else if (pTrace[i].x > rcBeg.right)
			rcBeg.right = pTrace[i].x;
		if (pTrace[i].y < rcBeg.top)
			rcBeg.top = pTrace[i].y;
		else if (pTrace[i].y > rcBeg.bottom)
			rcBeg.bottom = pTrace[i].y;
	}

	rcEnd.top  = rcEnd.bottom = pTrace[iFar].y;
	rcEnd.left = rcEnd.right = pTrace[iFar].x; 
	for (i = iFar + 1; i <= iLast; i++)
	{
		if (pTrace[i].x < rcEnd.left)
			rcEnd.left = pTrace[i].x;
		else if (pTrace[i].x > rcEnd.right)
			rcEnd.right = pTrace[i].x;
		if (pTrace[i].y < rcEnd.top)
			rcEnd.top = pTrace[i].y;
		else if (pTrace[i].y > rcEnd.bottom)
			rcEnd.bottom = pTrace[i].y;
	}

	dxBeg = rcBeg.right - rcBeg.left + 1;
	dyBeg = rcBeg.bottom - rcBeg.top + 1;
	dxEnd = rcEnd.right - rcEnd.left + 1;
	dyEnd = rcEnd.bottom - rcEnd.top + 1;

	//
	// Find the interior angles

	cornerAngle = GestureInteriorAngle(pTrace + iFirst, pTrace + iFar, pTrace + iLast);
	cornerAngle2 = GestureInteriorAngle(pTrace + (iFirst + iFar)/2, pTrace + iFar, pTrace + (iLast + iFar)/2);

	//
	// Now figure out which way it is pointing

	// Complete the rhombus for three-cornered gestures (have to check for overflow)

	if ( lenBeg <= SHRT_MAX && lenEnd <= SHRT_MAX )
	{
		p4.x = (pTrace[iFirst].x-pTrace[iFar].x)*lenEnd + (pTrace[iLast].x-pTrace[iFar].x)*lenBeg;
		p4.y = (pTrace[iFirst].y-pTrace[iFar].y)*lenEnd + (pTrace[iLast].y-pTrace[iFar].y)*lenBeg;
	}
	else if (lenBeg < lenEnd)
	{
		double dTemp = (double)lenEnd/(double)lenBeg;
		p4.x = (LONG)(dTemp*(double)(pTrace[iFirst].x-pTrace[iFar].x)) + (pTrace[iLast].x-pTrace[iFar].x);
		p4.x = (LONG)(dTemp*(double)(pTrace[iFirst].y-pTrace[iFar].y)) + (pTrace[iLast].y-pTrace[iFar].y);
	}
	else	// lenBeg >= lenEnd
	{
		double dTemp = (double)lenBeg/(double)lenEnd;
		p4.x = (pTrace[iFirst].x-pTrace[iFar].x) + (LONG)(dTemp*(double)(pTrace[iLast].x-pTrace[iFar].x));
		p4.x = (pTrace[iFirst].y-pTrace[iFar].y) + (LONG)(dTemp*(double)(pTrace[iLast].y-pTrace[iFar].y));
	}
	
	direction = GestureATan2(-p4.x,-p4.y);	// p4 points the opposite direction than the corner

	//
	// Corners

	if ( cornerAngle < 105	 &&
		 cornerAngle > 75 )
	{
		if (2 * dxBeg <= dyBeg) 		// First part vertical
		{
			if (2 * dyEnd <= dxEnd) 		// Second part horizontal
			{
				bVH = TRUE;
			}
		}
		else if (2 * dyBeg <= dxBeg)	// First part horizontal
		{
			if (2 * dxEnd <= dyEnd) 		// Second vertical
			{
				bHV = TRUE;
			}
		}

		if ( (lenEnd > 9 * lenBeg) ||
			 (lenBeg > 9 * lenEnd) )
		{
			return GESTURE_NULL;
		}

		if (3*lenBeg > 5*lenEnd)			// Long-short corners
		{									// not allowed!!!
			return GESTURE_NULL;
		}
		bIsLong = (3*lenEnd > 5*lenBeg);
		
		if (direction >= 300 && direction <= 330) 	// NE Corner
		{
			if (bHV)
			{
				if (bIsLong)				// Short-long allowed
				{							// only for V-H corners
					return GESTURE_NULL;
				}
				return GESTURE_RIGHT_DOWN;
			} 
			if (bVH)		// UP_LEFT or UP_LEFT_LONG
			{
				if (bIsLong)
				{
					return GESTURE_UP_LEFT_LONG;
				}				
				return GESTURE_UP_LEFT;
			}
		}

		if (direction >= 210 && direction <= 240)	// NW Corner
		{
			if (bHV)
			{
				if (bIsLong)				// Short-long allowed
				{							// only for V-H corners
					return GESTURE_NULL;
				}
				return GESTURE_LEFT_DOWN;
			}
			if (bVH)
			{
				if (bIsLong)
				{
					return GESTURE_UP_RIGHT_LONG;
				}
				return GESTURE_UP_RIGHT;
			}			
		}

		if (direction >= 120 && direction <= 150)	// SW Corner
		{
			if (bHV)
			{
				if (bIsLong)				// Short-long allowed
				{							// only for V-H corners
					return GESTURE_NULL;
				}
				return GESTURE_LEFT_UP;
			}
			if (bVH)
			{
				if (bIsLong)
				{
					return GESTURE_DOWN_RIGHT_LONG;
				}
				return GESTURE_DOWN_RIGHT;
			}
		}

		if (direction >= 30 && direction <= 60)	// SE Corner
		{
			if (bHV)
			{
				if (bIsLong)				// Short-long allowed
				{							// only for V-H corners
					return GESTURE_NULL;
				}
				return GESTURE_RIGHT_UP;
			}
			if (bVH)
			{
				if (bIsLong)
				{
					return GESTURE_DOWN_LEFT_LONG;
				}
				return GESTURE_DOWN_LEFT;
			}
		}
	}

	if ( 3*lenBeg < 5*lenEnd	&&		// Both "halves" have
		 3*lenEnd < 5*lenBeg )			// about same length
	{
		//
		// Spikes

		if ( cornerAngle < 10	&&
			 cornerAngle2 < 15 )
		{
			if (direction <= 15 || direction >= 345)
			{
				return GESTURE_RIGHT_LEFT;
			}
			if (direction >= 255 && direction <= 285)
			{
				return GESTURE_UP_DOWN;
			}
			if (direction >= 165 && direction <= 195)
			{
				return GESTURE_LEFT_RIGHT;
			}
			if (direction >= 75 && direction <= 105)
			{
				return GESTURE_DOWN_UP;
			}
		}

		//
		// Chevrons

		if ( cornerAngle > 25	&&
			 cornerAngle < 90	&&
			 cornerAngle2 > cornerAngle - 10  &&
			 cornerAngle2 < cornerAngle + 10 )
		{
			if (direction <= 15 || direction >= 345)
			{
				return GESTURE_CHEVRON_RIGHT;
			}
			if (direction >= 255 && direction <= 285)
			{
				return GESTURE_CHEVRON_UP;
			}
			if (direction >= 165 && direction <= 195)
			{
				return GESTURE_CHEVRON_LEFT;
			}
			if (direction >= 75 && direction <= 105)
			{
				return GESTURE_CHEVRON_DOWN;
			}
		}
	}
	else		// One side is much longer than the other
	{
		//
		// Check

		if ( cornerAngle > 45	&&
			 cornerAngle < 100	&&
			 cornerAngle2 > cornerAngle - 10  &&
			 cornerAngle2 < cornerAngle + 10  &&
			 direction >= 70	&&
			 direction <= 110 )
		{
			return GESTURE_CHECK;
		}
	}

/*
#if 0
		// GEST_UNDO == GESTURE_UP_DOWN
		if( dyBox!=0							 &&
			dxBox*4<=dyBox					 &&
			(box.bottom-yFirst)*4<=dyBox		 &&
			(box.bottom-yLast)*4<=dyBox 	 &&
			dxRun/6 < dxBox 				 &&
			dyRun/3 < dyBox
			)
		{
			//find maximum from begin
			y1 = box.top;
			iFirstExtr = iTop; //CHE: was unassigned
			for(i=iFirst; i<iTop; i++)
				if(pTrace[i].y>y1)
				{
					y1 = pTrace[i].y;
					iFirstExtr = i;
				}
				if((box.bottom-y1)*6 > dyBox*5)
					goto bypass_undo;
				y2 = box.top;
				iLastExtr = iTop; //CHE: was unassigned
				for(i=iTop+1; i<=iLast; i++)
					if(pTrace[i].y>y2)
					{
						y2 = pTrace[i].y;
						iLastExtr = i;
					}
					if((box.bottom-y2)*6 > dyBox*5)
						goto bypass_undo;
					
					if(!IsMonotonous( pTrace, iFirstExtr, iTop, 0, 6))
						goto bypass_undo;
					if(!IsMonotonous( pTrace, iTop, iLastExtr, 0, 6))
						goto bypass_undo;
					*pHotPoint = pTrace[iTop];
					return GEST_UNDO; 
		}  
bypass_undo:
		
		// GEST_SELECTALL == GESTURE_DOWN_UP (the quick correct gesture, which gets converted to the menu gesture by MouseUp)
		if( dyBox!=0							 &&
			dxBox<=dyBox/4					 &&
			(yLast-box.top)*4<=dyBox			 &&
			(yFirst-box.top)*4<=dyBox			 &&
			dxRun/6 < dxBox 				 &&
			dyRun/3 < dyBox
			)
		{
			
			//find minimum from begin
			y1 = box.bottom;
			iFirstExtr = iBottom; //CHE: was unassigned
			for(i=iFirst; i<iBottom; i++)
				if(pTrace[i].y<y1)
				{
					y1 = pTrace[i].y;
					iFirstExtr = i;
				}
				if((y1-box.top)*6 > dyBox*5)
					goto bypass_selectall;
				y2 = box.bottom;
				iLastExtr = iBottom; //CHE: was unassigned
				for(i=iBottom+1; i<=iLast; i++)
					if(pTrace[i].y<y2)
					{
						y2 = pTrace[i].y;
						iLastExtr = i;
					}
					if((y2-box.top)*6 > dyBox*5)
						goto bypass_selectall;
					
					if(!IsMonotonous( pTrace, iFirstExtr, iBottom, 0, 6))
						goto bypass_selectall;
					if(!IsMonotonous( pTrace, iBottom, iLastExtr, 0, 6))
						goto bypass_selectall;
					*pHotPoint = pTrace[iBottom];
					return GEST_SELECTALL;
		}  
bypass_selectall:
		
		// GEST_RETURN == GESTURE_DOWN_LEFT_LONG
		// GEST_SPACE  == GESTURE_DOWN_RIGHT_LONG
		// GEST_TAB    == GESTURE_UP_RIGHT_LONG
		// GEST_MENU   == GESTURE_UP_LEFT_LONG
		
		if( dyBox!=0							&&
			dxBeg*3<dyBeg						  &&
			dxEnd>dyEnd*4						  &&
			IsMonotonous(pTrace, iFirst, iFar, 0, 6)	 &&
			IsMonotonous(pTrace, iFar, iLast, 8, 0)  &&
			//	   dxBox/6<dyBox					 &&
#ifndef FOR_CE
			//	   MayBeHorizLine( pTrace, iFar, iLast, 4 ) &&
#endif //FOR_CE
			dxEnd>dyBeg 					 &&
			dxRun/3 < dxBox 				 &&
			dyRun/3 < dyBox &&
			dyBeg<=dxEnd*3/4
			)
		{
			if(pTrace[iFar].x>xLast)   
			{
				if	( pTrace[iFar].y > yFirst )  //CHE
					return GEST_RETURN;
				if	( pTrace[iFar].y < yFirst )
					return GEST_MENU;
			}
			else
			{  
				if	( dyBeg<=dxEnd*3/4 && pTrace[iFar].y > yFirst )
					return GEST_SPACE;
				if	( pTrace[iFar].y < yFirst )
					return GEST_TAB;
			}
		}	
		
		// GEST_DL == GESTURE_DOWN_LEFT
		// GEST_DR	== GESTURE_DOWN_RIGHT
		// GEST_UR	  == GESTURE_UP_RIGHT
		// GEST_UL	 == GESTURE_UP_LEFT
		
		if( dyBox!=0							&&
			dxBeg*3<dyBeg						  &&
			dxEnd>dyEnd*4						  &&
			IsMonotonous(pTrace, iFirst, iFar, 0, 6)	 &&
			IsMonotonous(pTrace, iFar, iLast, 8, 0)  &&
			//	   dxBox/6<dyBox					 &&
#ifndef FOR_CE
			//	   MayBeHorizLine( pTrace, iFar, iLast, 4 ) &&
#endif //FOR_CE
			//	   dxEnd*4>dyBeg*3						   &&
			//	   dxEnd*3<dyBeg*4						   &&
			dxRun/3 < dxBox 				 &&
			dyRun/3 < dyBox
			)
		{
			if(pTrace[iFar].x>xLast)   
			{
				if	( pTrace[iFar].y > yFirst )  //CHE
					return GEST_DL;
				if	( pTrace[iFar].y < yFirst )
					return GEST_UL;
			}
			else
			{  
				if	(pTrace[iFar].y > yFirst )
					return GEST_DR;
				if	( pTrace[iFar].y < yFirst )
					return GEST_UR;
			}
		}	
		// GEST_LU == GESTURE_LEFT_UP
		// GEST_LD	== GESTURE_LEFT_DOWN
		// GEST_RU	  == GESTURE_RIGHT_UP
		// GEST_RD	 == GESTURE_RIGHT_DOWN
		
		if( dyBox!=0							&&
			dyBeg*3<dxBeg						  &&
			dyEnd>dxEnd*4						  &&
			IsMonotonous(pTrace, iFirst, iFar, 6, 0)	 &&
			IsMonotonous(pTrace, iFar, iLast, 0, 8)  &&
			//	   dxBox/6<dyBox					 &&
#ifndef FOR_CE
			//	   MayBeHorizLine( pTrace, iFar, iLast, 4 ) &&
#endif //FOR_CE
			//	  dyEnd*4>dxBeg*3						   &&
			//	  dyEnd*3<dxBeg*4						   &&
			dxRun/3 < dxBox 				 &&
			dyRun/3 < dyBox
			)
		{
			if(pTrace[iFar].y>yLast)   // If yes, this is an UP
			{
				if	( pTrace[iFar].x > xFirst )  //If yes, this is a Right
					return GEST_RU;
				if	( pTrace[iFar].x < xFirst )
					return GEST_LU;
			}
			else
			{  
				if	(pTrace[iFar].x > xFirst )
					return GEST_RD;
				if	( pTrace[iFar].x < xFirst )
					return GEST_LD;
			}
		}	

		// GEST_CORRECT == GESTURE_CHECK
		if(
			dyBox!=0							&&
			pTrace[iFar].y - yFirst>0			  &&
			pTrace[iFar].y - yLast>0	  &&
			xLast - pTrace[iFar].x>0	  &&
			dyBeg<dyEnd*2/3 				  &&
			dyEnd>=dyBox*4/5					&&
			dxBeg<2*dyBeg						  &&
			dxEnd<2*dyEnd						  &&
			dxEnd>dxBox/4						 &&
			dxBeg<dxBox*2/3 				 &&
			pTrace[iFar].x - xFirst>-dyBeg	&&
			IsMonotonous(pTrace, iFirst, iFar, 0, 8)	 &&
			IsMonotonous(pTrace, iFar, iLast, 6, 8)  )
		{
			int CtgBegMin = -113, CtgBegMax = 15;
			int CtgEndMin = 31, CtgEndMax = 113;
			//int CtgBetweenMin = 0, CtgBetweenMax = 133;
			int iCtgBeg, iCtgEnd;
			if((pTrace[iFar].x - xFirst)>0 &&
				dyEnd>dyBeg*2)
			{
				CtgBegMin = -161, CtgBegMax = 17;
				CtgEndMin = 20, CtgEndMax = 133;
				//CtgBetweenMin = -7, CtgBetweenMax = 206;
			}
			
			iCtgBeg = (xFirst-pTrace[iFar].x)*100/dyBeg;
			iCtgEnd = dxEnd*100/dyEnd;
			if(iCtgBeg>=CtgBegMin && iCtgBeg<=CtgBegMax &&
				iCtgEnd>=CtgEndMin && iCtgEnd<=CtgEndMax) {
				*pHotPoint = pTrace[iFar];
				return GEST_CORRECT;
			}
		}	
		
		
		// GEST_COPY == GESTURE_RIGHT_LEFT
		if(
			dxBox!=0							 &&
			dyBox<=dxBox/4					 &&
			(xLast-box.left)*5<=dxBox			 &&
			(xFirst-box.left)*5<=dxBox		 &&
			dxRun/3 < dxBox 				 &&
			dyRun/4 < dyBox
			)
		{
			
			//find x-minimum from begin
			x1 = xFirst;
			iFirstExtr = iFirst; //CHE: was unassigned
			for(i=iFirst; i<iRight; i++)
				if(pTrace[i].x<x1)
				{
					x1 = pTrace[i].x;
					iFirstExtr = i;
				}
				if((x1-box.left)*6 > dxBox*5) //??? CHE - ask KRAV
					goto bypass_copy;
				x2 = box.right;
				iLastExtr = iRight; //CHE: was unassigned
				for(i=iRight+1; i<=iLast; i++)
					if(pTrace[i].x<x2)
					{
						x2 = pTrace[i].x;
						iLastExtr = i;
					}
					if((x2-box.left)*6 > dxBox*5)
						goto bypass_copy;
					
					if(!IsMonotonous( pTrace, iFirstExtr, iRight, 6, 0))
						goto bypass_copy;
					if(!IsMonotonous( pTrace, iRight, iLastExtr, 6, 0))
						goto bypass_copy;
					*pHotPoint = pTrace[iRight];
					return GEST_COPY;
		}  
bypass_copy:
		
		// GEST_CUT == GESTURE_LEFT_RIGHT
		if(
			dxBox!=0							 &&
			dyBox<=dxBox/4					 &&
			(box.right-xLast)*5<=dxBox		 &&
			(box.right-xFirst)*5<=dxBox 	 &&
			dxRun/3 < dxBox 				 &&
			dyRun/4 < dyBox
			)
		{
			
			//find x-maximum from begin
			x1 = xFirst;
			iFirstExtr = iFirst;
			for(i=iFirst; i<iLeft; i++)
				if(pTrace[i].x>x1)
				{
					x1 = pTrace[i].x;
					iFirstExtr = i;
				}
				if((box.right-x1)*6 > dxBox*5)
					goto bypass_cut;
				x2 = box.left;
				iLastExtr = iLeft;
				for(i=iLeft+1; i<=iLast; i++)
					if(pTrace[i].x>x2)
					{
						x2 = pTrace[i].x;
						iLastExtr = i;
					}
					if((box.right-x2)*6 > dxBox*5)
						goto bypass_cut;
					
					if(!IsMonotonous( pTrace, iFirstExtr, iLeft, 6, 0))
						goto bypass_cut;
					if(!IsMonotonous( pTrace, iLeft, iLastExtr, 6, 0))
						goto bypass_cut;
					*pHotPoint = pTrace[iLeft];
					return GEST_CUT;
		}  
bypass_cut:
		
		// From here down, the hotpoint is the point furthest from the line connecting the endpoints.
		
		*pHotPoint = pTrace[iFar];
		
		// GEST_PASTE == GESTURE_CHEVRON_UP
		if(
			dyBox!=0				 &&
			pTrace[iFar].y - yFirst<0	  &&
			pTrace[iFar].y - yLast<0	  &&
			xLast - pTrace[iFar].x>0	  &&
			pTrace[iFar].x - xFirst>0	  &&
			dxRun/3 < dxBox 				 &&
			dyRun/4 < dyBox 				 &&
			dxBeg<dxEnd*2						&&
			dxEnd<dxBeg*2						&&
			dyBeg<dyEnd*3/2 				  &&
			dyEnd<dyBeg*3/2 				  &&
			
			(	 (dyBeg>=dyBox*4/5 && dyEnd>=dyBox*2/3) 
			|| (dyEnd>=dyBox*4/5 && dyBeg>=dyBox*2/3)
			)
			
			&&
			
			dxBeg<dyBeg*3/2 				  &&
			dyBeg<dxBeg*3						  &&
			dxEnd<dyEnd*3/2 				  &&
			dyEnd<dxEnd*3						  &&
			
			IsMonotonous(pTrace, iFirst, iFar, 6, 8)	 &&
			IsMonotonous(pTrace, iFar, iLast, 6, 8)  )
		{
			return GEST_PASTE;
		}	
		
		// GEST_SPELL == GESTURE_CHEVRON_DOWN
		if( dyBox!=0				 &&
			pTrace[iFar].y - yFirst>0	  &&
			pTrace[iFar].y - yLast>0	  &&
			xLast - pTrace[iFar].x>0	  &&
			pTrace[iFar].x - xFirst>0	  &&
			dxRun/3 < dxBox 				 &&
			dyRun/4 < dyBox 				 &&
			dxBeg<dxEnd*2						&&
			dxEnd<dxBeg*2						&&
			dyBeg<dyEnd*3/2 				  &&
			dyEnd<dyBeg*3/2 				  &&
			
			(	 (dyBeg>=dyBox*4/5 && dyEnd>=dyBox*2/3) 
			|| (dyEnd>=dyBox*4/5 && dyBeg>=dyBox*2/3)
			)
			
			&&
			
			dxBeg<dyBeg*3/2 				  &&
			dyBeg<dxBeg*3						  &&
			dxEnd<dyEnd*3/2 				  &&
			dyEnd<dxEnd*3						  &&
			
			IsMonotonous(pTrace, iFirst, iFar, 6, 8)	 &&
			IsMonotonous(pTrace, iFar, iLast, 6, 8)  )
		{
			return GEST_SPELL;
		}	
		
		// GEST_GT == GESTURE_CHEVRON_RIGHT
		if( dxBox!=0				 &&
			pTrace[iFar].x - xFirst>0	  &&
			pTrace[iFar].x - xLast>0	  &&
			yLast - pTrace[iFar].y>0	  &&
			pTrace[iFar].y - yFirst>0	  &&
			dyRun/3 < dyBox 				 &&
			dxRun/4 < dxBox 				 &&
			dyBeg<dyEnd*2						&&
			dyEnd<dyBeg*2						&&
			dxBeg<dxEnd*3/2 				  &&
			dxEnd<dxBeg*3/2 				  &&
			
			(	 (dxBeg>=dxBox*4/5 && dxEnd>=dxBox*2/3) 
			|| (dxEnd>=dxBox*4/5 && dxBeg>=dxBox*2/3)
			)
			
			&&
			
			dyBeg<dxBeg*3/2 				  &&
			dxBeg<dyBeg*3						  &&
			dyEnd<dxEnd*3/2 				  &&
			dxEnd<dyEnd*3						  &&
			
			IsMonotonous(pTrace, iFirst, iFar, 6, 8)	 &&
			IsMonotonous(pTrace, iFar, iLast, 6, 8)  )
		{
			return GEST_GT;
		}	
		
		// GEST_LT == GESTURE_CHEVRON_LEFT
		if( dxBox!=0				 &&
			xFirst - pTrace[iFar].x >0	  &&
			xLast - pTrace[iFar].x >0	   &&
			yLast - pTrace[iFar].y>0	  &&
			pTrace[iFar].y - yFirst>0	  &&
			dyRun/3 < dyBox 				 &&
			dxRun/4 < dxBox 				 &&
			dyBeg<dyEnd*2						&&
			dyEnd<dyBeg*2						&&
			dxBeg<dxEnd*3/2 				  &&
			dxEnd<dxBeg*3/2 				  &&
			
			(	 (dxBeg>=dxBox*4/5 && dxEnd>=dxBox*2/3) 
			|| (dxEnd>=dxBox*4/5 && dxBeg>=dxBox*2/3)
			)
			
			&&
			
			dyBeg<dxBeg*3/2 				  &&
			dxBeg<dyBeg*3						  &&
			dyEnd<dxEnd*3/2 				  &&
			dxEnd<dyEnd*3						  &&
			
			IsMonotonous(pTrace, iFirst, iFar, 6, 8)	 &&
			IsMonotonous(pTrace, iFar, iLast, 6, 8)  )
		{
			return GEST_LT;
		}	
		
		// GEST_LOOP == GESTURE_NULL (Simple closed loop isn't a Microsoft Gesture
		if( dxBox!=0							 &&
			dyBox!=0
			)
		{
			LONG lSquare, lBoxSquare = dxBox*dyBox;
			if(GestClosedSquare( &pTrace[iFirst], iLast-iFirst-1, &lSquare))
			{
				if(lSquare<0)
					lSquare = -lSquare;
				//MyDebugPrintf("lSquare=%d lBoxSquare=%d lSquare/lBoxSquare*100=%d dxRun=%d dyRun=%d dxBox=%d dyBox=%d\n", (int)lSquare, (int)lBoxSquare, (int)(lSquare*100/lBoxSquare), (int)dxRun, (int)dyRun, (int)dxBox, (int)dyBox);
				if(8*dxBox<5*dxRun &&
					8*dyBox<5*dyRun &&
					3*lSquare>lBoxSquare)
					return GEST_LOOP;
			}
		}  
#endif // if 0
*/
		return GESTURE_NULL;
}

/*
BOOL IsMonotonous( POINT *  pTrace, int iLeft, int iRight , int iXth, int iYth)
{
 int iDX;
 int iDY;
 int kxIncrease, kyIncrease;
 int i, xCurr, yCurr, dx, dy;

	// If left doesn't preceed right, swap them around

   if(iLeft>iRight)
      {
         i = iLeft;
         iLeft = iRight;
         iRight = i;
      }

	// Compute total rise and total run across the whole segment

   iDX = pTrace[iRight].x - pTrace[iLeft].x;
   iDY = pTrace[iRight].y - pTrace[iLeft].y;


	// Separate the sign of rise and run from the magnitude

   kxIncrease = (iDX>=0)?1:-1;
   kyIncrease = (iDY>=0)?1:-1;;
   if(iDX<0)
     iDX = -iDX;
   if(iDY<0)
     iDY = -iDY;

   // Initialize with the first point and then loop across all the other points, in order

   xCurr = pTrace[iLeft].x;
   yCurr = pTrace[iLeft].y;
   for(i=iLeft+1; i<=iRight; i++)
      {

	   //
		// See if the point-to-point change is in the right direction; 
	   // if so, advance ot the next point, and count no cost.


         if((pTrace[i].x - xCurr)*kxIncrease>0)
            {
               xCurr = pTrace[i].x;
               dx = 0;
            }
         else	// Otherwise, measure the absolute backwards movement
            dx=(xCurr - pTrace[i].x)*kxIncrease;

		 //
		 // Compute the same thing for y

         if((pTrace[i].y - yCurr)*kyIncrease>0)
            {
               yCurr = pTrace[i].y;
               dy = 0;
            }
         else
            dy=(yCurr - pTrace[i].y)*kyIncrease;

		//
		 // Tolerances are fractions of total X/Y distance.  So if a reverse move of 
		 // 1/10 the total movement is acceptable, then iXth and iYth would be 10

         if(dx*iXth>iDX || dy*iYth>iDY)
            return FALSE;
      }
   return TRUE;
}
*/


/********************************************************************/

/*   The following function calculates the area within
 * the trajectory part.  Clockwise path gives positive area,
 * counterclockwise - negative.
 *   At the following example, if "A" is the starting point
 * and "B" - ending one, then the "1" area will give
 * negative square, "2" area - positive square:
 *
 *                             ooo<ooo
 *                       oo<ooo       ooooo
 *                      o                  oo
 *                     o                     oo
 *                   oo          1             o
 *                  o                          o
 *                 o                        ooo
 *                 o                    oooo
 *   A ooooo>oooooooooooo>ooooooo>oooooo
 *      |        oo
 *       |  2   o
 *        |    o
 *         ooo
 *        B
 */
/*
BOOL
GestClosedSquare(POINT *pTrace, 
				 int cTrace,
				 LONG *plSquare)
{
	INT    i, ip1;
	LONG   lSum;
	
	
	if ( plSquare == NULL || pTrace == NULL )
	{
		return  FALSE;
	}
	if ( cTrace <= 2 )
	{
		return FALSE;
	}
	
	//
	// Regular case, count integral:
	// First, get the square under the chord connecting
	// the ends and then the rest of the loop:
	
	lSum = (pTrace[cTrace-1].y + pTrace[0].y) * (pTrace[cTrace-1].x - pTrace[0].x);
	
	//  Then count the square under the trajectory:
	for  ( i = 0, ip1 = i + 1; i < cTrace - 1; i++, ip1++ )  
	{
		lSum += (pTrace[i].y + pTrace[ip1].y) * (pTrace[i].x - pTrace[ip1].x);
	}
	
	*plSquare = lSum / 2;
	return TRUE;
} // GetClosedSquare
*/

/***************************************************************************\
*	CalligrapherGestureReco:												*
*		Recognize all "straight" gestures (and output a list of alternates).*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
CalligrapherGestureReco(POINT *pPts,				// I: Array of points (single stroke)
						int cPts,					// I: Number of points in stroke
						GEST_ALTERNATE *pGestAlt,	// O: Array to contain alternates
						int cMaxAlts,				// I: Max alternates to return 
						DWORD *pdwEnabledGestures)	// I: Currently enabled gestures
{
	WCHAR wcCalliGesture;	// Calligrapher Gesture
	POINT hotPoint;

	//
	// Nothing to do if there's no place to put the result

	if (cMaxAlts <= 0)
	{
		return 0;
	}

	//
	// Now try all the Calligrapher Gestures

	wcCalliGesture = GestureCheck(pPts, cPts, &hotPoint);


	//
	// Insert it into the alt list

	if (wcCalliGesture == GESTURE_NULL)
	{
		return 0;
	}
	if (IsSet(wcCalliGesture-GESTURE_NULL, pdwEnabledGestures))
	{
		pGestAlt->wcGestID = wcCalliGesture;
		pGestAlt->hotPoint = hotPoint;
	}
	else
	{
		pGestAlt->wcGestID = GESTURE_NULL;
		pGestAlt->hotPoint.x = pGestAlt->hotPoint.y = 0;
	}
	pGestAlt->eScore = 1.0;
	pGestAlt->confidence = CFL_STRONG;
	return 1;
}	// CalligrapherGestureReco
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\moth_db.c ===
/************************** ...\moth\src\moth_db.c *************************\
*																			*
*		Functions for handling Moth database.								*
*																			*
*	Created:	January 18, 2002											*
*	Author:		Petr Slavik, pslavik										*
*																			*
\***************************************************************************/

#include "mothp.h"

MOTH_DB	gMothDb;

//
// List of gestures supported by Moth

static WCHAR g_awcMothGestures[] =
{
	GESTURE_NULL,			// Anything that is not a gesture
	GESTURE_SCRATCHOUT,
//	GESTURE_TRIANGLE,
//	GESTURE_SQUARE,
//	GESTURE_STAR,
	GESTURE_CHECK,
//	GESTURE_CURLICUE,
//	GESTURE_DOUBLE_CURLICUE,
//	GESTURE_CIRCLE,
//	GESTURE_DOUBLE_CIRCLE,
//	GESTURE_SEMICIRCLE_LEFT,
//	GESTURE_SEMICIRCLE_RIGHT,
	GESTURE_CHEVRON_UP,
	GESTURE_CHEVRON_DOWN,
	GESTURE_CHEVRON_LEFT,
	GESTURE_CHEVRON_RIGHT,
//	GESTURE_ARROW_UP,
//	GESTURE_ARROW_DOWN,
//	GESTURE_ARROW_LEFT,
//	GESTURE_ARROW_RIGHT,
	GESTURE_UP,
	GESTURE_DOWN,
	GESTURE_LEFT,
	GESTURE_RIGHT,
	GESTURE_UP_DOWN,
	GESTURE_DOWN_UP,
	GESTURE_LEFT_RIGHT,
	GESTURE_RIGHT_LEFT,
	GESTURE_UP_LEFT_LONG,
	GESTURE_UP_RIGHT_LONG,
	GESTURE_DOWN_LEFT_LONG,
	GESTURE_DOWN_RIGHT_LONG,
	GESTURE_UP_LEFT,
	GESTURE_UP_RIGHT,
	GESTURE_DOWN_LEFT,
	GESTURE_DOWN_RIGHT,
	GESTURE_LEFT_UP,
	GESTURE_LEFT_DOWN,
	GESTURE_RIGHT_UP,
	GESTURE_RIGHT_DOWN,
//	GESTURE_EXCLAMATION,
	GESTURE_TAP,
	GESTURE_DOUBLE_TAP,
};


static const int MAX_MOTH_GESTURES = sizeof(g_awcMothGestures) / sizeof(g_awcMothGestures[0]);


/***************************************************************************\
*	InitMothDB:																*
*		Initialize Grouse database using the values from the registry.		*
\***************************************************************************/

void
InitMothDB(void)
{
	int i;

	ZeroMemory( gMothDb.adwMothGestures, MAX_GESTURE_DWORD_COUNT * sizeof(DWORD) );
	for (i = 0; i < MAX_MOTH_GESTURES; i++)
	{
		DWORD index = (DWORD) (g_awcMothGestures[i] - GESTURE_NULL);
		Set(index, gMothDb.adwMothGestures);
	}

	ReadRegistryValues();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\polygon.c ===
#include "mothp.h"
#include <limits.h>


/***************************************************************************\
*	SqrtSumSquares:															*
*		Return the square root of x^2 + y^2.								*
*																			*
*		Adapted from an integer sqrt function by Gareth H. Loudon, who		*
*		adapted it from Introduction to Numerical Methods, by Peter A.		*
*		Stark. New York: Macmillan Publishing Co., 1970, page 20.			*
*																			*
*		This is a binary search for the value that divides into the square	*
*		to yield itself.													*
\***************************************************************************/

#define SQRT_MAX _I32_MAX

UINT
SqrtSumSquares(int x,  int y)
{
	UINT64 square, guess, quotient, ux, uy, x2, y2;

	ux = (UINT64) abs(x);
	uy = (UINT64) abs(y);
	
	ASSERT(ux <= SQRT_MAX);
	ASSERT(uy <= SQRT_MAX);

	if (uy < ux)
	{
		guess = ux + (uy >> 1);
	}
	else	// uy >= ux
	{
		guess = uy + (ux >> 1);
	}
	if (guess == 0)		// If x = y = 0
	{
		return 0;
	}

	x2 = ux * ux;
	y2 = uy * uy;
	ASSERT(x2 <= (_UI64_MAX - y2));

	square = x2 + y2;
	do
	{
		quotient = square / guess;
		guess = (quotient + guess) >> 1;
	} while (!((quotient == guess) || (quotient == (guess + 1))));

	return (UINT)guess;
}

/***************************************************************************\
*	SumSquares:																*
*		Return the square of x^2 + y^2.										*
\***************************************************************************/

UINT64
SumSquares(int x, int y)
{
	INT64 ix, iy;
	UINT64 square;

	ix = (INT64) x;
	iy = (INT64) y;
	square = ix*ix + iy*iy;
	return square;
}


/***************************************************************************\
*	GestureATan2:															*
*		Compute the arctangent (in degrees) of y/x.							*
\***************************************************************************/

int
GestureATan2(int x,	int y)
{
	int index, theta;
	unsigned int ux, uy;
	static unsigned char rgAtan[] = 
	{
		 0,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9, 10, 11, 
		11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 21, 
		22, 23, 24, 24, 25, 26, 27, 27, 28, 29, 29, 30, 31, 
		31, 32, 33, 33, 34, 35, 35, 36, 36, 37, 37, 38, 39, 
		39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 
	};

	ux = abs(x);		// Map the point to the first quadrant
	uy = abs(y);

	if (ux >= uy)		// Angle less than 45
	{
		if (ux == 0)
		{
			return 0;
		}
		if (uy >= (UINT_MAX >> 6))
		{
			index = uy / (ux >> 6);
		}
		else
		{
			index = (uy << 6) / ux;
		}
		ASSERT(0 <= index && index <= 64);
		theta = rgAtan[index];
	}
	else
	{
		if (ux >= (UINT_MAX >> 6))
		{
			index = ux / (uy >> 6);
		}
		else
		{
			index = (ux << 6) / uy;
		}
		ASSERT(0 <= index && index <= 64);
		theta = 90 - rgAtan[index];
	}

	if (x >= 0)		// Right Half-Plane
	{
		if (y >= 0)		// First Quadrant
		{
			;			// Do nothing
		}
		else			// Fourth Quadrant (y < 0)
		{
			theta = 360 - theta;
			if (theta == 360)			// This can happen if x
			{							// is much greater than -y
				theta = 0;
			}
		}
	}
	else			// Left Half-Plane
	{
		if (y >= 0)		// Second Quadrant
		{
			theta = 180 - theta;
		}
		else			// Third Quadrant
		{
			theta = 180 + theta;
		}
	}

	ASSERT(0 <= theta && theta < 360);

	return (theta);

} // GestureATan2


/***************************************************************************\
*	GestureAngle:															*
*		Compute the angle from the positive x-axis to a line from p1 to p2. *
*		0 <= theta < 360													*
\***************************************************************************/

int
GestureAngle(POINT *p1,
			 POINT *p2)
{
	int x, y;
	int theta;
	x =  p2->x - p1->x;
	y =  p2->y - p1->y;
	theta = GestureATan2(x,y);

	return (theta);
} // GestureAngle


/***************************************************************************\
*	GestureAngleChange:														*
*		Compute the angle change (in signed degrees) as we move through P2	*
*		toward P3.															*
*		Straight ahead will be zero degress.  If x-axis points to the left	*
*		and y-axis points down, a 10-degree clock-wise turn is +10, a		*
*		10-degree counter-clockwise turn is -10.							*
*		-180 < theta <= 180													*
\***************************************************************************/

int
GestureAngleChange(POINT *p1,		// I: Starting point
				   POINT *p2,		// I: Mid point
				   POINT *p3)		// I: End-point
{
	int theta1, theta2, theta;
	theta1 = GestureAngle(p1, p2);
	theta2 = GestureAngle(p2, p3);

	theta = theta2 - theta1;
	if (theta > 180)
	{
		theta -= 360;
	}
	else if (theta <= -180)
	{
		theta += 360;
	}
	ASSERT(theta > -180 && theta <= 180);

	return (theta);
} // GestureAngleChange


/***************************************************************************\
*	GestureInteriorAngle:													*
*		Compute the interior angle (in degrees) between three points.		*
*		0 <= theta <= 180													*
\***************************************************************************/

int
GestureInteriorAngle(POINT *p1,		// I: End-point
					 POINT *p2,		// I: Vertex
					 POINT *p3)		// I: End-point
{
	int theta1, theta2, theta;

	theta1 = GestureAngle(p2, p1);
	theta2 = GestureAngle(p2, p3);

	theta = theta2 - theta1;	// -360 < theta < 360
	if (theta < 0)
	{
		theta = -theta;			// 0 <= theta < 360
	}

	if (theta > 180)
	{
		theta = 360 - theta;	// 0 <= theta <= 180
	}
	
	ASSERT(theta >= 0 && theta <= 180);

	return (theta);

} // GestureInteriorAngle


/***************************************************************************\
*	GestureIsStraight:														*
*		Given a sequence of points, determine if it's straight.				*
\***************************************************************************/

BOOL
GestureIsStraight(POINT *pt,		// I: Array of points
				  int iFirst,		// I: Index of the first point
				  int iLast,		// I: Index of the last point
				  UINT tolerance)	// I: Fraction of total length points are 
{									//    allowed to deviate from straight line
	int A, B, C, dx, dy; 
	UINT totalDist, limit;
	UINT uExtent;
	int dist, prevDist;
	int direction; // +1 = UP, -1 = DOWN, 0 = steady
	int iMin, iMax, prevMin, prevMax;
	UINT64 length2;
	int i;
	int shift = 3;		// 2^shift = fraction of the max allowed distance for variation to be significant

	dx = pt[iLast].x - pt[iFirst].x;
	dy = pt[iLast].y - pt[iFirst].y;

	//
	// If there is no space between the endpoints, this thing is definitely
	// curved, since we are supposed to have already established that the line
	// is of nontrivial length.

	if (dx == 0 && dy == 0)
	{
		return FALSE;
	}

	//
	// Compute the equation of the line connecting the endpoints 
	// in the Ax + By + C = 0 form.

	A = -dy;
	B = dx;
	C = dy*pt[iFirst].x - dx*pt[iFirst].y;

	//
	// First, make sure that the ink does not go back an forth on the same line.
	// To make our life easier, just use the dominant direction:

	uExtent = 0;
	if (dx < 0)
		dx = -dx;
	if (dy < 0)
		dy = -dy;
	if ( dx > dy )
	{
		for (i = iFirst; i < iLast; i++)
		{
			uExtent += abs(pt[i+1].x - pt[i].x);
		}
		if (uExtent > (UINT)dx * 2)
		{
			return FALSE;
		}
	}
	else
	{
		for (i = iFirst; i < iLast; i++)
		{
			uExtent += abs(pt[i+1].y - pt[i].y);
		}
		if (uExtent  > (UINT)dy * 2)
		{
			return FALSE;
		}
	}

	//
	// Now walk the line and find the total deviation

	direction = 0;
	length2 = SumSquares(dx, dy);
	limit = (UINT)( (length2>>shift) / (UINT64)tolerance );
	totalDist = 0;
	iMin = iMax = prevMin = prevMax = 0;
	prevDist = 0;
	for (i = iFirst + 1; i <= iLast; i++)
	{
		dist = A * pt[i].x + B * pt[i].y + C; 	// Distance from pt to line
		if (dist == prevDist)
			continue;
		if (dist > prevDist)		// Going up
		{
			iMax = dist;
			if (direction < 0)		// Previously going down, local min
			{
				if ((UINT)(prevMax - iMin) > limit)		// Significant variation
				{
					totalDist += (UINT)(prevMax - iMin);
					prevMax = prevMin = iMin;
				}
				else if (iMin < prevMin)
				{
					prevMin = iMin;
				}
			}
			direction = +1;		// Going up
		}
		else	// dist < prevDist; i.e. going down
		{
			iMin = dist;
			if (direction > 0)		// previously going up, local max
			{
				if ((UINT)(iMax - prevMin) > limit)		// Significant variation
				{
					totalDist += (UINT)(iMax - prevMin);
					prevMin = prevMax = iMax;
				}
				else if (iMax > prevMax)
				{
					prevMax = iMax;
				}
			}
			direction = -1;
		}
		prevDist = dist;
	}

	if (direction < 0)		// At the end, we were going down
	{						// hence iMin == 0!
		if ((UINT)prevMax > limit)
		{
			totalDist += prevMax;
		}
	}
	else								// At the end, we were going up
	{									// hence iMax == 0!
		if ((UINT)(-prevMin) > limit)
		{
			totalDist += -prevMin;
		}
	}

	//
	// If it's less than the tolerance (as a fraction of line length) return ok.
	// What we really want is 
	//							(totalDist/2)/sqrt(A^2+B^2) > sqrt(dx^2+dy^2)/tolerance
	//
	// but the expression below is equivalent and more integer-friendly
	
	totalDist >>= (shift+1);
	if (totalDist >= limit)
	{
		return FALSE;
	}

	return TRUE;

} // GestureIsStraight


/***************************************************************************\
*	GestureDistance:														*
*		Compute the squared distance between two points.					*
\***************************************************************************/

static UINT64
GestureDistance2(POINT *p1,	// I: Point 1
				 POINT *p2)	// I: Point 2
{
	INT64  tmp;
	UINT64 dist2;

	tmp = p1->x - p2->x;
	dist2 = (UINT64)(tmp*tmp);
	tmp = p1->y - p2->y;
	dist2 += (UINT64)(tmp*tmp);

	return dist2;
} // GestureDistance2


/***************************************************************************\
*	GestureDistance:														*
*		Compute the distance between two points.							*
\***************************************************************************/

UINT
GestureDistance(POINT *p1,	// I: Point 1
				POINT *p2)	// I: Point 2
{
	LONG dx, dy;

	dx = p1->x - p2->x;
	dy = p1->y - p2->y;

	return SqrtSumSquares(dx, dy);
} // GestureDistance


/* Where p2 is the vertex of the angle, figure the dot product */

int
GestureDotProduct(POINT *p1,
				  POINT *p2,
				  POINT *p3)
{
	int dot;

	dot = (p2->x-p1->x)*(p3->x-p2->x) + (p2->y-p1->y)*(p3->y-p2->y);

	return dot;
	
} // GestureDotProduct


/***************************************************************************\
*	GestureSmoothPoint:														*
*		Given an index into an array of points, compute a smoothed point.	*
\***************************************************************************/

POINT
GestureSmoothPoint(POINT *aPts,		// I: Array of points
				   int iPt)			// I: Index into the array
{
	POINT pt, *pPt;
	ASSERT(iPt > 1);

	pPt = aPts + iPt;
	pt.x = pPt[-2].x + pPt[-1].x*4 + pPt[0].x*6 + pPt[1].x*4 + pPt[2].x;
	pt.x /= 16;
	pt.y = pPt[-2].y + pPt[-1].y*4 + pPt[0].y*6 + pPt[1].y*4 + pPt[2].y;
	pt.y /= 16;

	return (pt);

} // GestureSmoothPoint


#if 0

#define MAXAPICES	100

/* Given an input star or square, identify and return */

HRESULT WINAPI PolygonGestureReco(
	POINT *pPt,					// Array of points (single stroke)
	int cpt,					// Number of points in stroke
	GEST_ALTERNATE *pGestAlt,	// Array to contain alternates
	int *pcAlts,				// max alternates to return/alternates left
	DWORD *pdwEnabledGestures	// Currently enabled gestures
) 
{
	POINT *ptCopy = new POINT[cpt + 4];
	POINT *ptSmooth = new POINT[cpt+2];
	int *rgAngles = new int[cpt];
	int netAngle, grossAngle;
	POINT ptMid, ptBoxMid;
	int i, j, cAngles, cApices, cApices2, distLast, dist, distNext;
	int boxHeight, boxWidth;
	int apices[MAXAPICES+2], apices2[MAXAPICES+2];
	RECT box;
	bool bFirst = true;
	bool bPositive = true;
	int cCorners, cHardCorners;
	int distMean = 0, distMin = -1, distMax = 0;
	int theta, direction;
	bool bSquare;
	POINT hotPoint;

	/* Can't recognize anything if there's no space to put the results */

	if (*pcAlts <= 0) {
		goto cleanup;
	}

	/* For all these gestures, the start point is the hotpoint (that is, there is no real hotpoint */

	hotPoint = pPt[0];

	/* Simultaneously make a copy of the points and compute the centroid and bounding box */

	memset(&ptMid,0,sizeof(ptMid));
	box.left = box.right = pPt[0].x;
	box.bottom = box.top = pPt[0].y;
	for (i = 0; i < cpt; ++i) {
		ptCopy[i] = pPt[i];

		// Accumulate the midpoint

		ptMid.x += pPt[i].x;
		ptMid.y += pPt[i].y;

		// Figure the bounding box

		if (pPt[i].x < box.left) {
			box.left = pPt[i].x;
		}
		if (pPt[i].x > box.right) {
			box.right = pPt[i].x;
		}
		if (pPt[i].y < box.top) {
			box.top = pPt[i].y;
		}
		if (pPt[i].y > box.bottom) {
			box.bottom = pPt[i].y;
		}
	}

	ptMid.x /= cpt;	
	ptMid.y /= cpt;	
	ptBoxMid.x = (box.right + box.left)/2;
	ptBoxMid.y = (box.bottom + box.top)/2;
	
	boxHeight = box.bottom - box.top;
	boxWidth = box.right - box.left;

	/* Wrap the first four points around to make computing the moving average easier.*/

	for (i = 0; i < 4; ++i) {
		ptCopy[i+cpt] = pPt[i];
	}

	/* Now construct an array of smoothed points; remember that every index in ptSmooth corresponds to the same index in ptCopy plus two. */

	for (i = 0; i < cpt; ++i) {
		ptSmooth[i] = GestureSmoothPoint(ptCopy,i+2);
	}

	/* Wrap the first two points around to make looping back easier */

	for (i = 0; i < 2; ++i) {
		ptSmooth[i+cpt] = ptSmooth[i];
	}

	/* Now test for Circle */

	/* Divide the loop into segments at least 10 degrees wide */

	i = 0;
	cAngles = 0;
	rgAngles[cAngles++] = 0;	// be sure to include the start point
	netAngle = 0;
	grossAngle = 0;
	while (i < cpt) {

		theta = 0;
		for (j = i+1; j < cpt; ++j) {
			theta = GestureInteriorAngle(&ptCopy[i],&ptBoxMid,&ptCopy[j]);
			if (theta >= 10) {
				break;
			}
		}
		if (theta < 10) {
			break;
		}

		netAngle += theta;
		grossAngle += abs(theta);
		rgAngles[cAngles++] = j;
		i = j;
	}

	/* Now walk along those segments looking for sharp changes in the derivative */	

	cCorners = cHardCorners = 0;
	for (i = 2; i < cAngles; ++i) {
		theta = GestureAngleChange(&ptCopy[rgAngles[i-2]],&ptCopy[rgAngles[i-1]],&ptCopy[rgAngles[i]]);
		if (abs(theta) > 30) {
			++cCorners;
			if (abs(theta) > 50) {
				++cHardCorners;
			}
		}
	}

	netAngle = abs(netAngle);
	if (IsSet(GESTURE_CIRCLE-GESTURE_NULL, pdwEnabledGestures) && netAngle > 300 && netAngle < 420 && cHardCorners < 2 && cCorners < 4) {
		pGestAlt->wcGestID = GESTURE_CIRCLE;
		pGestAlt->eScore = 1.0;
		pGestAlt->confidence = CFL_STRONG;
		pGestAlt->hotPoint = hotPoint;
		--(*pcAlts);
		++pGestAlt;
		if (*pcAlts <= 0) {
			goto cleanup;
		}
	}
	if (IsSet(GESTURE_DOUBLE_CIRCLE-GESTURE_NULL, pdwEnabledGestures) && netAngle > 660 && netAngle < 1000 && cHardCorners < 4 && cCorners < 8) {
		pGestAlt->wcGestID = GESTURE_DOUBLE_CIRCLE;
		pGestAlt->eScore = 1.0;
		pGestAlt->confidence = CFL_STRONG;
		pGestAlt->hotPoint = hotPoint;
		--(*pcAlts);
		++pGestAlt;
		if (*pcAlts <= 0) {
			goto cleanup;
		}
	}

	if (IsSet(GESTURE_BULLET-GESTURE_NULL, pdwEnabledGestures) && netAngle > 1000 && cCorners > 10) {
		pGestAlt->wcGestID = GESTURE_BULLET;
		pGestAlt->eScore = 1.0;
		pGestAlt->confidence = CFL_STRONG;
		pGestAlt->hotPoint = hotPoint;
		--(*pcAlts);
		++pGestAlt;
		if (*pcAlts <= 0) {
			goto cleanup;
		}
	}

	/* Not a circle, test for polygon */

	/* Verify that the polygon is closed */

	dist = GestureDistance2(ptCopy,ptCopy+cpt-1);

	if (dist*9 > boxHeight*boxHeight && dist*9 > boxWidth*boxWidth) {
		goto cleanup;
	}

	/* Get the squared distances to the first two (smoothed) points. */

	distLast = GestureDistance2(&ptBoxMid,ptSmooth);
	dist     = GestureDistance2(&ptBoxMid,ptSmooth+1);
	
	/* We have an apex wherever a point is further from the centroid than the ones on either side.  Find them all. */

	cApices = 0;
	for (i = 2; i < cpt+2; ++i) {
		distNext = GestureDistance2(&ptBoxMid,ptSmooth+i);
		if (distLast <= dist && distNext <= dist) {
			apices[cApices] = i+1;	// Because this tells us the LAST point was an apex, but we want ptCopy indices, so 2-1 = 1
			++cApices;
			if (cApices == MAXAPICES) {	// too irregular; fail now
				goto cleanup;
			}
		}
		if (dist != distNext) {
			distLast = dist;
		}
		dist = distNext;
	}

	/* Duplicate the first two points -- it makes circular tests easier */

	if (cApices < MAXAPICES) {
		apices[cApices] = apices[0];
		apices[cApices+1] = apices[1];
	}

	/* Remove points that are too colinear.  */

	cApices2 = 0;
	for (i = 0; i < cApices; ++i) {
		theta = GestureInteriorAngle(&ptCopy[apices[i]],&ptCopy[apices[i+1]],&ptCopy[apices[i+2]]);
		/* Save anything more than 10 degrees away from linear */

		if (abs(theta) < 170) {
			apices2[cApices2] = apices[i+1];
			cApices2++;
		}
	}

	/* Wrap the last two points around, as usual */

	for (i = 0; i < 2; ++i) {
		apices2[cApices2+i] = apices2[i];
	}

	/* Now coalesce any sides that are too short, which means both x and y less than 1/3 the box width.  We have to pick a point to start from, but
	we will drop that point if it's not picked up on the far side */

	apices[0] = apices2[0];
	cApices = 1;
	for (i = 1; i <= cApices2; ++i) {
		POINT pt1 = ptCopy[apices[cApices-1]];
		POINT pt2 = ptCopy[apices2[i]];

		if (abs(pt1.x-pt2.x)*3 > box.right-box.left || abs(pt1.y-pt2.y)*3 > box.bottom-box.top) {
			apices[cApices] = apices2[i];
			++cApices;
		}
	}

	/* Delete the first point */

	--cApices;
	for (i = 0; i < cApices; ++i) {
		apices[i] = apices[i+1];
	}

	/* Wrap the last two points around, as usual */

	for (i = 0; i < 2; ++i) {
		apices[cApices+i] = apices[i];
	}
	

	/* Check for triangle */

	direction = 0;
	if (IsSet(GESTURE_TRIANGLE-GESTURE_NULL, pdwEnabledGestures) && cApices == 3) {
		for (i = 1; i <= 3; ++i) {
			theta = GestureInteriorAngle(&ptCopy[apices[i-1]],&ptCopy[apices[i]],&ptCopy[apices[i+1]]);

			/* Polygons must go in the same direction */

			if (direction == 0) {
				direction = theta >= 0 ? 1 : -1;
			} else {
				if ((theta >= 0) != (direction >= 0)) {
					goto cleanup;
				}
			}

			/* We want a mostly equilateral triangle */

			if (theta > 86 || theta < 35) {
				goto cleanup;
			}
			/* Lines must be straight */

			if (!GestureIsStraight(ptCopy,apices[i-1],apices[i],10)) {
				goto cleanup;
			}
		}

		pGestAlt->wcGestID = GESTURE_TRIANGLE;
		pGestAlt->eScore = 1.0;
		pGestAlt->confidence = CFL_STRONG;
		pGestAlt->hotPoint = hotPoint;
		--(*pcAlts);
		++pGestAlt;
		if (*pcAlts <= 0) {
			goto cleanup;
		}
	}
	/* Check for Rectangle */

	direction = 0;
	if ((IsSet(GESTURE_SQUARE-GESTURE_NULL, pdwEnabledGestures) || IsSet(GESTURE_RECTANGLE-GESTURE_NULL, pdwEnabledGestures)) && cApices == 4) {
		for (i = 1; i <= 4; ++i) {
			theta = GestureInteriorAngle(&ptCopy[apices[i-1]],&ptCopy[apices[i]],&ptCopy[apices[i+1]]);

			/* Polygons must go in the same direction */

			if (direction == 0) {
				direction = theta >= 0 ? 1 : -1;
			} else {
				if ((theta >= 0) != (direction >= 0)) {
					goto cleanup;
				}
			}

			/* We want rectangles, not parallelograms */

			if (theta < 70 || theta > 109) {
				goto cleanup;
			}

			/* Lines must be straight */

			if (!GestureIsStraight(ptCopy,apices[i-1],apices[i],5)) {
				goto cleanup;
			}

		}

		/* Now we know we definitely have a rectangle and maybe a square. */

		if (IsSet(GESTURE_RECTANGLE-GESTURE_NULL, pdwEnabledGestures)) {
			pGestAlt->wcGestID = GESTURE_RECTANGLE;
			pGestAlt->eScore = 1.0;
			pGestAlt->confidence = CFL_STRONG;
			pGestAlt->hotPoint = hotPoint;
			--(*pcAlts);
			++pGestAlt;
			if (*pcAlts <= 0) {
				goto cleanup;
			}
		}

		if (IsSet(GESTURE_SQUARE-GESTURE_NULL, pdwEnabledGestures)) {
			bSquare = true;

			for (i = 1; i <= 4; ++i) {
				dist = GestureDistance2(&ptCopy[apices[i-1]],&ptCopy[apices[i]]);
				distNext = GestureDistance2(&ptCopy[apices[i]],&ptCopy[apices[i+1]]);
				if (dist*11 > distNext*19 || distNext*11 > dist*19) {
					bSquare = false;
					break;
				}
			}
			if (bSquare) {
				pGestAlt->wcGestID = GESTURE_SQUARE;
				pGestAlt->eScore = 1.0;
				pGestAlt->confidence = CFL_STRONG;
				pGestAlt->hotPoint = hotPoint;
				--(*pcAlts);
				++pGestAlt;
				if (*pcAlts <= 0) {
					goto cleanup;
				}
			}
		}
	}

	/* Now check for 5-pointed Star*/

	direction = 0;
	if (IsSet(GESTURE_STAR-GESTURE_NULL, pdwEnabledGestures) && cApices == 5) {
		for (i = 1; i <= 5; ++i) {

			/* Angles must be 36 degrees -- give or take */

			theta = GestureInteriorAngle(&ptCopy[apices[i-1]],&ptCopy[apices[i]],&ptCopy[apices[i+1]]);

			/* Polygons must go in the same direction */

			if (direction == 0) {
				direction = theta >= 0 ? 1 : -1;
			} else {
				if ((theta >= 0) != (direction >= 0)) {
					goto cleanup;
				}
			}

			if (theta > 62 || theta < 21) {
				goto cleanup;
			}

			/* Lines must be straight */

			if (!GestureIsStraight(ptCopy,apices[i-1],apices[i],5)) {
				goto cleanup;
			}			
		}
		pGestAlt->wcGestID = GESTURE_STAR;
		pGestAlt->eScore = 1.0;
		pGestAlt->confidence = CFL_STRONG;
		pGestAlt->hotPoint = hotPoint;
		--(*pcAlts);
		++pGestAlt;
		if (*pcAlts <= 0) {
			goto cleanup;
		}
	}

cleanup:

	delete [] ptCopy;
	delete [] ptSmooth;
	delete [] rgAngles;

	return S_OK;

} // PolygonGestureReco

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\sources.inc ===
TARGETNAME=moth
TARGETTYPE=LIBRARY

INCLUDES= $(INCLUDES) \
          $(_TPG_COMMON_INC); \
          $(_TPG_ROOT)\Wisp\public\sdk\inc; \
          $(_TPG_ROOT)\hwx\twister\moth\inc; \
          $(_TPG_ROOT)\hwx\twister\inc; \
          $(_TPG_ROOT)\hwx\common\inc;  \


TARGETLIBS= $(TARGETLIBS) \
            $(_TPG_ROOT)\Common\TabAssert\$(PLAT_DIR)\$(O)\TabAssert.lib \
            $(_TPG_ROOT)\hwx\common\src\Win2kUnicode\$(O)\common.lib	\


SOURCES= \
         ..\caligest.c		\
         ..\moth.c			\
         ..\polygon.c		\
         ..\scratchout.c	\
		 ..\moth_db.c		\
		 ..\taps.c			\
		 ..\regread.c		\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\regread.c ===
/************************ moth\src\regread.c *******************************\
*																			*
*	Functions for reading values from the registry into the Moth database.	*
*																			*
\***************************************************************************/

#include "mothp.h"
#include "regsafe.h"

/***************************************************************************\
*	RANGEDW:																*
*		Structure to easily haul around groups of related registry values.	*
\***************************************************************************/

typedef struct	tagRANGEDW
{
	DWORD	min;		// Minimum
	DWORD	max;		// Maximum
	DWORD	def;		// Default
} RANGEDW;


//
// Names of registry keys (to avoid typos)

#define REG_VAL_CANCEL			L"Cancel"		// HKLM, HKCU
#define REG_VAL_CANCEL_MIN		L"Cancel.min"	// HKLM
#define REG_VAL_CANCEL_MAX		L"Cancel.max"	// HKLM
#define REG_VAL_MOVE			L"Move" 		// HKLM, HKCU
#define REG_VAL_MOVE_MIN		L"Move.min" 	// HKLM
#define REG_VAL_MOVE_MAX		L"Move.max" 	// HKLM
#define REG_VAL_DOUBLE			L"DblDist"		// HKLM, HKCU
#define REG_VAL_DOUBLE_MIN		L"DblDist.min"	// HKLM
#define REG_VAL_DOUBLE_MAX		L"DblDist.max"	// HKLM
#define REG_PATH				L"Software\\Microsoft\\Wisp\\Pen\\SysEventParameters"


//
// Default values for Move, Cancel, and DoubleDist values in HKLM
//
//							   {min,max,def}
static RANGEDW rgdwMoveDef =   { 10, 50, 20};
static RANGEDW rgdwCancelDef = {  5, 25,  5};
static RANGEDW rgdwDoubleDef = {  2, 20,  4};

//
// Default registry values (from Wacom Tablet)

// #define TAP_DBL_DIST 17
// #define TAP_CANCEL	11
// #define TAP_MOVE 	55


/***************************************************************************\
*	ReadRegistryValues: 													*
*		Read values from the registry and assign them to the database.		*
\***************************************************************************/

void
ReadRegistryValues(void)
{
	HKEY	hkey;
	DWORD	dwDouble, dwCancel, dwMove;
	DWORD	cb; 		// Count of bytes
	DWORD	dwType; 	// Type of the registry value
	RANGEDW rgdwMove, rgdwCancel, rgdwDouble;

	//
	// Open the HKLM subkey for min, max, and default values

	if ( RegOpenKey(HKEY_LOCAL_MACHINE, REG_PATH, &hkey) != ERROR_SUCCESS )
	{
		rgdwMove = rgdwMoveDef;
		rgdwCancel = rgdwCancelDef;
		rgdwDouble = rgdwDoubleDef;
	}
	else
	{
		if ( (RegQueryValueDWORD(hkey, REG_VAL_CANCEL_MIN, &rgdwCancel.min, 
								 0, ~0, 0) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_CANCEL_MAX, &rgdwCancel.max, 
								 rgdwCancel.min, ~0, rgdwCancel.min) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_CANCEL, &rgdwCancel.def, 
								 rgdwCancel.min, rgdwCancel.max, rgdwCancel.min) != S_OK ) )
		{
			rgdwCancel = rgdwCancelDef;
		}
		if ( (RegQueryValueDWORD(hkey, REG_VAL_MOVE_MIN, &rgdwMove.min, 
								 0, ~0, 0) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_MOVE_MAX, &rgdwMove.max, 
								 rgdwMove.min, ~0, rgdwMove.min) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_MOVE, &rgdwMove.def, 
								 rgdwMove.min, rgdwMove.max, rgdwMove.min) != S_OK ) )
		{
			rgdwMove = rgdwMoveDef;
		}
		if ( (RegQueryValueDWORD(hkey, REG_VAL_DOUBLE_MIN, &rgdwDouble.min, 
								 0, ~0, 0) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_DOUBLE_MAX, &rgdwDouble.max, 
								 rgdwDouble.min, ~0, rgdwDouble.min) != S_OK ) ||
			 (RegQueryValueDWORD(hkey, REG_VAL_DOUBLE, &rgdwDouble.def, 
								 rgdwDouble.min, rgdwDouble.max, rgdwDouble.min) != S_OK ) )
		{
			rgdwDouble = rgdwDoubleDef;
		}
		RegCloseKey(hkey);
	}

	//
	// Open the HKCU subkey

	if ( RegOpenKey(HKEY_CURRENT_USER, REG_PATH, &hkey) != ERROR_SUCCESS )
	{
		gMothDb.uMaxTapDist = (ULONG)rgdwCancel.def;
		gMothDb.uMaxTapLength = (ULONG)rgdwMove.def;
		gMothDb.uDoubleDist = (ULONG)rgdwDouble.def;
		return;
	}
	if ( FAILED(RegQueryValueDWORD(hkey, REG_VAL_CANCEL, &dwCancel,
								   rgdwCancel.min, rgdwCancel.max, rgdwCancel.def)) )
	{
		dwCancel = rgdwCancel.def;
	}
	if ( FAILED(RegQueryValueDWORD(hkey, REG_VAL_MOVE, &dwMove,
								   rgdwMove.min, rgdwMove.max, rgdwMove.def)) )
	{
		dwMove = rgdwMove.def;
	}
	if ( FAILED(RegQueryValueDWORD(hkey, REG_VAL_DOUBLE, &dwDouble,
								   rgdwDouble.min, rgdwDouble.max, rgdwDouble.def)) )
	{
		dwDouble = rgdwDouble.def;
	}
	RegCloseKey(hkey);

	//
	// The values are in multiples of 0.1mm

	gMothDb.uDoubleDist = (ULONG)dwDouble;
	gMothDb.uMaxTapDist = (ULONG)dwCancel;
	gMothDb.uMaxTapLength = (ULONG)dwMove;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\dllmain.c ===
#include "common.h"

#include "grouse.h"
#include "moth.h"
#include "tpgHandle.h"

HINSTANCE g_hInstanceDll;


#ifdef DBG
#include <crtdbg.h>
	//extern void initMemMgr();
	extern void destroyMemMgr();
#endif


BOOL WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hInstanceDll = hDll;

#ifdef DBG
		// initMemMgr(); // Called automatically on first ExternAlloc();
#endif
		InitGrouseDB();
		InitMothDB();
		if (FALSE == initTpgHandleManager())
		{
			return FALSE;
		}
    }
    
    if (dwReason == DLL_PROCESS_DETACH)
    {
        // CloseRecognition();
		closeTpgHandleManager();
#ifdef DBG
		destroyMemMgr();
#endif

	}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\res.h ===
// res.h: defines for resources

#ifndef __INCLUDE_RES
#define __INCLUDE_RES

#define RESID_WISP_DATA 	8000
#define RESID_WISP_FRIENDLYNAME 8001
#define RESID_WISP_VENDORNAME   8002

#endif   // _H_RES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\taps.c ===
/************************ moth\src\taps.c **********************************\
*																			*
*			Functions for recognizing tap and double-tap.					*
*																			*
\***************************************************************************/

#include "common.h"
#include "mothp.h"

typedef enum {
	SIZE_LARGE,
	SIZE_SMALL,
	SIZE_TAP
}	SIZE_VALUE;


#define S2T_RATIO	2		// Small to tap ratio

/***************************************************************************\
*	IsTap:																	*
*		Decide if a given stroke is a tap.									*
\***************************************************************************/

SIZE_VALUE
GetSize(FRAME *pFrame,			// I: One stroke of the ink
		LONG	lPPI)			// I: Resolution of the coordinates
{
	RECT *pBBox;
	LONG x, y, xPrev, yPrev;
	ULONG dx, dy, dMax, xDist, yDist, uTotalDist;
	ULONG uMaxTapDist = lPPI * gMothDb.uMaxTapDist / PPI_CONVERSION;
	ULONG uMaxTapLength = lPPI * gMothDb.uMaxTapLength / PPI_CONVERSION;
	POINT *pPoint;

	ASSERT(pFrame);

	//
	// Get the bounding box

	pBBox = RectFRAME(pFrame);

	//
	// Instead of checking the distance of every single point from
	// the starting point of the ink, we just check the size of the
	// bounding box --- not so accurate but good enough.

	dx = pBBox->right - pBBox->left;
	dy = pBBox->bottom - pBBox->top;
	dMax = (dx > dy ? dx : dy);

	ASSERT(uMaxTapDist <= uMaxTapLength);

	if (dMax > S2T_RATIO * uMaxTapLength)	// This is an early out:
	{										// If dMax > LengthBound then
		return SIZE_LARGE;					// uTotalDist > LengthBound and
	}										// dMax > SizeBound

	pPoint = pFrame->rgrawxy + pFrame->info.cPnt - 1;
	xPrev = pPoint->x;
	yPrev = pPoint->y;
	xDist = yDist = 0;
		
	for (pPoint--; pPoint >= pFrame->rgrawxy; pPoint--)
	{
		if (pPoint->x > xPrev)
			xDist += pPoint->x - xPrev;
		else
			xDist += xPrev - pPoint->x;

		if (pPoint->y > yPrev)
			yDist += pPoint->y - yPrev;
		else
			yDist += yPrev - pPoint->y;
		xPrev = pPoint->x;
		yPrev = pPoint->y;
	}

	//
	// At this point we know that the total (euclidean) length
	// of the stroke is small, bounded above by xDist + yDist,
	// bounded below by sqrt(xDist^2+yDist^2).  It seems as a 
	// good guess to use  longer_dist + shorter_dist/2 for an
	// estimated length of the stroke:

	if (xDist > yDist)
		uTotalDist = xDist + yDist / 2;
	else
		uTotalDist = xDist / 2 + yDist;
	
	if ( (uTotalDist > S2T_RATIO * uMaxTapLength) &&
		 (dMax > S2T_RATIO * uMaxTapDist) )
	{
		return SIZE_LARGE;
	}
	if ( (uTotalDist <= uMaxTapLength) &&
		 (dMax <= uMaxTapDist) )
	{
		return SIZE_TAP;
	}
	return SIZE_SMALL;
}


/***************************************************************************\
*	TapGestureReco:															*
*		Recognize a single-tap gesture (and output a list of alternates).	*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
TapGestureReco(GLYPH *pGlyph,				//  I:  Input ink
			   GEST_ALTERNATE *pGestAlt,	// I/O: List of alternates
			   int cAlts,					//  I:  Length of the list
			   DWORD *pdwEnabledGestures,	//  I:  Bit array of enabled gestures
			   LONG lPPI)					//  I:  Points per inch
{
	SIZE_VALUE size;

	ASSERT(pGlyph);

	size = GetSize(pGlyph->frame, lPPI);

	if (size == SIZE_LARGE)
	{
		return 0;
	}

	//
	// Ink is a TAP gesture or is too small to be recognized

	ASSERT(pGlyph->frame);
	ASSERT(pGlyph->frame->rgrawxy);

	pGestAlt->confidence = CFL_STRONG;
	pGestAlt->eScore = 1.0;
	pGestAlt->hotPoint = pGlyph->frame->rgrawxy[0];

	if ( IsSet(GESTURE_TAP - GESTURE_NULL, pdwEnabledGestures) &&
		 size == SIZE_TAP )
	{
		pGestAlt->wcGestID = GESTURE_TAP;
	}
	else
	{
		pGestAlt->wcGestID = GESTURE_NULL;
	}

	return 1;
}


/***************************************************************************\
*	DoubleTapGestureReco:													*
*		Recognize a double-tap gesture (and output a list of alternates).	*
*		Return the number of alternates computed (either 0 or 1).			*
\***************************************************************************/

int
DoubleTapGestureReco(GLYPH *pGlyph,				//  I:  Input ink
					 GEST_ALTERNATE *pGestAlt,	// I/O: List of alternates
					 int cAlts,					//  I:  Length of the list
					 DWORD *pdwEnabledGestures,	//  I:  Bit array of enabled gestures
					 LONG lPPI)					//  I:  Points per inch
{
	ULONG dx, dy, dTotal;
	POINT *pFirst, *pSecond;
	ULONG uDoubleDist = gMothDb.uDoubleDist * lPPI / PPI_CONVERSION;
	SIZE_VALUE size1, size2;

	//
	// Make sure that the ink has 2 strokes and both have valid data

	ASSERT(pGlyph);
	ASSERT(pGlyph->frame);
	ASSERT(pGlyph->frame->rgrawxy);
	ASSERT(pGlyph->next);
	ASSERT(pGlyph->next->frame);
	ASSERT(pGlyph->next->frame->rgrawxy);
	ASSERT(pGlyph->next->next == NULL);

	//
	// Check if the first stroke is a tap

	size1 = GetSize(pGlyph->frame, lPPI); 
	if ( size1 == SIZE_LARGE )
	{
		return 0;
	}

	//
	// Check if the second stroke is a tap

	size2 = GetSize(pGlyph->next->frame, lPPI); 
	if ( size2 == SIZE_LARGE )
	{
		return 0;
	}

	//
	// Gesture is a DOUBLE_TAP gesture or "double-blob"

	pGestAlt->confidence = CFL_STRONG;
	pGestAlt->eScore = 1.0;
	pGestAlt->hotPoint = pGlyph->frame->rgrawxy[0];

	if ( IsSet(GESTURE_DOUBLE_TAP - GESTURE_NULL, pdwEnabledGestures) &&
		 size1 == SIZE_TAP &&
		 size2 == SIZE_TAP )
	{
		//
		// Compute the distance between starting points

		pFirst = pGlyph->frame->rgrawxy;
		pSecond = pGlyph->next->frame->rgrawxy;

		if (pFirst->x > pSecond->x)
			dx = pFirst->x - pSecond->x;
		else
			dx = pSecond->x - pFirst->x;

		if (pFirst->y > pSecond->y)
			dy = pFirst->y - pSecond->y;
		else
			dy = pSecond->y - pFirst->y;

		// Use again longer_d + shorter_d/2 as an estimate for sqrt(dx^2 + dy^2).

		if (dy > dx)
		{
			dTotal = dy + dx / 2;
		}
		else
		{
			dTotal = dx + dy / 2;
		}
		if (dTotal <= uDoubleDist)
		{
			pGestAlt->wcGestID = GESTURE_DOUBLE_TAP;
			return 1;
		}

	}
	pGestAlt->wcGestID = GESTURE_NULL;
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\moth\src\scratchout.c ===
/************************ moth\src\scratchout.c ****************************\
*																			*
*			Function for recognizing scratch-out gesture.					*
*																			*
*	Originally written by Tom Wick and modified by Greg and later by Petr.	*
*																			*
\***************************************************************************/


#include "mothp.h"

/////////////////////////////////////////////////////////
//
// %%Function: CSingleChar.ScratchOut
//
// %%Description:
// These algorigthms were tested by me (twick) running:
// > D:\TabletPC\tpg\hwx\Debug\fff2nni.exe -ap \\tpg\reco\test\usa\alltst03.ste d:\s\junk.nni 
//
// Total count of strokes: 3530495
// Hit percentage ONE: 596/3530495 = 0.016881%
// Hit percentage TWO: 511/3530495 = 0.014474%
// Hit percentage THREE: 2862/3530495 = 0.081065%
// Hit percentage FOUR: 535/3530495 = 0.015154%
// Hit percentage FIVE: 135/3530495 = 0.003824%
//
// The descriptions of the algorithms I tested here are below.  By xDistance I mean total linear absolute distance
// traveled in the x direction.  By xExtent I mean total x span of the bounding rectangle of the stroke.  (Same for y).
//  
//      ONE: xDistance > 4 xExtent, yExtent must be < 4/5 xExtent
// Everything below here must have xExtent > 500, so a tiny stroke won't fire (period, comma)
//      TWO: same as ONE, but with xExtent > 500
//      THREE: Tom + Greg's ((s - a) / (b - s)) > (y / x) algorithm, with a = 96/35, b = 39/7 (this is similar to algorithm 1)
//      FOUR: Tom + Greg's ((s - a) / (b - s)) > (y / x) algorithm, with a = 23/9, b = 67/9 (1/10 at 3, square at 5)
//      FIVE: Tom + Greg's ((s - a) / (b - s)) > (y / x) algorithm, with a = 7/3, b = 29/3 (1/10 at 3, square at 6)
//  
// Unfortunately, we're actually using "algorithm SIX", which I never ran tests on.  It is a softer test than FIVE or FOUR,
// but a bit more strict than THREE.
//      SIX: Tom + Greg's ((s - a) / (b - s)) > (y / x) algorithm, with a = 31/18, b = 185/18 (1/10 at 2.5, square at 6)
//  
// Let me explain the algorithm a bit.  This allows us to get less strict for flatness of the scratch-out gesture as we get
// more and more total x distance traveled.  You pick two reference points:
//     First, you decide a minimum flatness you want to enforce.  We typically chose yExtent/xExtent of 1/10, because it's
//          tough to get much flatter than that.  Then you decide the ratio of xDistance to xExtent you want to fire as a
//          scratch out at this flatness.
//          (For THREE and FOUR and FIVE, we chose 3 (xDistance/xExtent), so you'd have to draw (at least) a flat Z to get
//          these to fire.  For SIX, we chose 2.5, so you'd have to only cross the extent of the stroke 2.5 times, not a full 3.)
//     Second, you decide a maximum flatness you want to enforce.  Mostly it makes sense (and easier math) to make this
//          yExtent/xExtent of 1, so the stroke is square.  Then you decide the ratio of xDistance to xExtent you want to
//          fire as a scratch out at this flatness.
//          (For THREE, we chose yExtent/xExtent of 4/5 at xDistance/xExtent = 4, because ONE and TWO were our model.
//          For FOUR, we chose yExtent/xExtent of 1 at xDistance/xExtent = 5.
//          For FIVE and for SIX, we chose yExtent/xExtent of 1 at xDistance/xExtent = 6.)
//  
// So now you need to solve two equations for what we called a and b.  Here s means (xDistance / xExtent).
// The equations are yExtent/xExtent = (s - a) / (b - s).
//  
// The stroke is recognized as a scratch out if:
//     b is less or equal to s (this happens if you _really_ blacken an area with ink)
// OR
//     (s - a) / (b - s) > yExtent / xExtent
//
//
/////////////////////////////////////////////////////////

int
ScratchoutGestureReco(POINT *pPts,					// I: Array of points (single stroke)
					  int cPts,						// I: Number of points in stroke
					  GEST_ALTERNATE *pGestAlt,		// O: Array to contain alternates
					  int cMaxAlts,					// I: Max alternates to return 
					  DWORD *pdwEnabledGestures)	// I: Currently enabled gestures
{
	LONG		xMin, xMax, xExtent, xDistance = 0, xCur, xPrev;
	LONG		yMin, yMax, yExtent, yDistance = 0, yCur, yPrev;
	INT 		iPoint;
	int 		cAlts = 0;
	double		a, b, r, s, fx;

	/* If there's no room in the alt list, we're done. */

	if (cMaxAlts <= 0)
	{
		return 0;
	}

	// Calculate the x and y extents of the stroke.
	// Calculate the x and y distances traveled by the stroke.

	xMin = xMax = xPrev = pPts[0].x;
	yMin = yMax = yPrev = pPts[0].y;

	for (iPoint = 1; iPoint < cPts; iPoint++)
	{
		xCur = pPts[iPoint].x;
		yCur = pPts[iPoint].y;
		xMin = min(xMin, xCur);
		xMax = max(xMax, xCur);
		yMin = min(yMin, yCur);
		yMax = max(yMax, yCur);
		xDistance += abs(xCur - xPrev);
		yDistance += abs(yCur - yPrev);
		xPrev = xCur;
		yPrev = yCur;
	}

	xExtent = (xMax - xMin);
	yExtent = (yMax - yMin);


	if (5 * yDistance > xDistance)		// Petr added this to emphasize that the
	{									// distance traveled in the x-direction
		return 0;						// must be significantly bigger than the 
	}									// distance traveled in the y-direction

	if (xExtent <= 0)			// This could happen only if xExtent = yExtent = 0;
	{							// i.e. the stroke is an array of identical points
		return 0;				// which is already taken care of by TAP recognition.
	}							// So this check is really not needed (but makes PREFIX happy)

	r = (double) yExtent / xExtent;		// Aspect ratio
	s = (double) xDistance / xExtent;	// Number of times we went back and forth

	// ALGORITHM THREE: Tom + Greg's:  a = 96/35, b = 39/7

	// ALGORITHM FOUR:	Tom + Greg's:  a = 23/9,  b = 67/9 (square at 5)

	// ALGORITHM FIVE:  Tom + Greg's:  a = 7/3,   b = 29/3

	// ALGORITHM SIX:   Tom + Greg's:  a = 31/18, b = 185/18

	// Algorithm SEVEN: a = 2, b = 10
	
	// Each algorithm requires "a" passes at zero height and "(a+b)/2" passes 
	// when the aspect ratio of the bounding box is 1:1. If s >= b, pretty
	// much anything will work.

	a = (double)2;
	b = (double)10;
	if (b > s)
	{
		fx = ((s - a) / (b - s));
		if (fx <= r)
		{
			return 0;
		}
	}

	//
	// We recognized it; add it to the alt list
	// If SCRATCHOUT isn't enabled, return gesture NULL

	if (IsSet(GESTURE_SCRATCHOUT-GESTURE_NULL, pdwEnabledGestures))
	{
		pGestAlt->wcGestID = GESTURE_SCRATCHOUT;
	}
	else
	{
		pGestAlt->wcGestID = GESTURE_NULL;
	}
	pGestAlt->eScore = 1.0;
	pGestAlt->confidence = CFL_STRONG;
	pGestAlt->hotPoint = pPts[0];	// No hotpoint for this one, of course
	
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\twister.c ===
/***************************************************************************\
*																			*
*			Main file for the Twister recognizer.							*
*																			*
\***************************************************************************/

#include "common.h"
#include "moth.h"
#include "grouse.h"
#include "twisterdefs.h"


/***************************************************************************\
*	TwisterReco:															*
*		Main function for the Twister Recognizer.							*
*																			*
*		Returns the number of alternates actually computed or 0 if			*
*		something goes wrong.												*
\***************************************************************************/

int
TwisterReco(GEST_ALTERNATE *pGestAlt,		// O: Array of alternates
			int cAlts,						// I: Max # of alternates needed
			GLYPH *pGlyph,					// I: One character ink
			DWORD *pdwEnabledGestures,		// I: Bit array of enabled gestures
			LONG lPPI)						// I: Number of pts per inch
{
	int cMothAlts = 0;
	int cGrouseAlts = 0;

	ASSERT(cAlts <= MAX_GESTURE_ALTS);
	
	cMothAlts = MothReco(pGestAlt, cAlts, pGlyph, pdwEnabledGestures, lPPI);

	if (cMothAlts == 0)
	{
		cGrouseAlts = GrouseReco(pGestAlt, cAlts, pGlyph, pdwEnabledGestures);
		if (cGrouseAlts == 0)
		{
			pGestAlt[0].wcGestID = GESTURE_NULL;
			pGestAlt[0].eScore = 1.0;
			pGestAlt[0].confidence = CFL_STRONG;
			pGestAlt[0].hotPoint.x = 0;
			pGestAlt[0].hotPoint.y = 0;
			cGrouseAlts = 1;
		}
		return cGrouseAlts;
	}
	else
	{
		return cMothAlts;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\sources.inc ===
TARGETNAME=mshwgst
TARGETTYPE=DYNLINK

DLLDEF=..\mshwgst.def
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

NTTARGETFILES=$(TARGETNAME).cpy

INCLUDES= $(INCLUDES)                          \
          $(_TPG_COMMON_INC);                  \
          $(_TPG_ROOT)\Wisp\public\sdk\inc;    \
          $(_TPG_ROOT)\hwx\common\inc;         \
          $(_TPG_ROOT)\hwx\twister\inc;        \
          $(_TPG_ROOT)\hwx\twister\moth\inc;   \
          $(_TPG_ROOT)\hwx\twister\grouse\inc; \
		  $(_TPG_ROOT)\hwx\common\src\api;     \


TARGETLIBS= $(TARGETLIBS) \
            $(_TPG_ROOT)\Common\TabAssert\$(PLAT_DIR)\$(O)\TabAssert.lib     \
            $(_TPG_ROOT)\hwx\common\src\Win2kUnicode\$(O)\common.lib         \
            $(_TPG_ROOT)\hwx\twister\moth\src\Win2kUnicode\$(O)\moth.lib     \
            $(_TPG_ROOT)\hwx\twister\grouse\src\Win2kUnicode\$(O)\grouse.lib \
            $(_TPG_ROOT)\hwx\common\src\api\Win2kUnicode\$(O)\commonAPI.lib  \
            $(SDK_LIB_PATH)\oldnames.lib    \
            $(SDK_LIB_PATH)\user32.lib      \
            $(SDK_LIB_PATH)\Version.lib     \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\gdi32.lib       \
            $(SDK_LIB_PATH)\winspool.lib    \
            $(SDK_LIB_PATH)\comdlg32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\shell32.lib     \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(SDK_LIB_PATH)\odbc32.lib      \
            $(SDK_LIB_PATH)\odbccp32.lib    \

ZZBROWSERFILE = twister.bsc

ZZOTHER_SBR_FILES=\
			$(_TPG_ROOT)\hwx\twister\moth\src\Win2kUnicode\$(O)\*.sbr	\
			$(_TPG_ROOT)\hwx\twister\grouse\src\Win2kUnicode\$(O)\*.sbr	\

SOURCES= \
         ..\DLLMain.c	\
		 ..\twister.c	\
         ..\wispapis.c	\
         ..\twister.rc	\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\bboxfeat.c ===
#include <stdlib.h>
#include <stdio.h>
#include <wtypes.h>
#include <ASSERT.h>
#include <math.h>

#include "common.h"
#include "memmgr.h"
#include "bboxfeat.h"

#define OverlapBins 1
//#define OverlapBins 2
#define RatioBins 11
#define StrokeBins 8
#define SpaceBins 1
//#define SpaceBins 5

// All unary feature bins should fall in the range 0<=bin<UnaryFeatureRange
#define UnaryFeatureRange (RatioBins*StrokeBins*SpaceBins)

// All binary feature bins should fall in the range 0<=bin<BinaryFeatureRange
#define BinaryFeatureRange (OverlapBins*RatioBins*StrokeBins*StrokeBins*RatioBins*SpaceBins)

// Convert a ratio (for example, aspect ratio) to a feature number in the range 0 to 10 (inclusive)
int RatioToFeature(float num, float denom)
{
	ASSERT(num>=0);
	ASSERT(denom>=0);

	if (denom>num*8) return 0;
	if (denom>num*4) return 1;
	if (denom>num*3) return 2;
	if (denom>num*2) return 3;
	if (denom*2>num*3) return 4;

	if (num>denom*8) return 10;
	if (num>denom*4) return 9;
	if (num>denom*3) return 8;
	if (num>denom*2) return 7;
	if (num*2>denom*3) return 6;

	return 5;
}

/*
int ScoreToFeature(FLOAT score)
{
	int iScore=(int)floor(-score);
	if (iScore<0) iScore=0;
	if (iScore>=ScoreBins) iScore=ScoreBins-1;
	return iScore;
}
*/

// Convert a stroke count to a feature number from 0 to 6 (inclusive)
int StrokeCountToFeature(int nStrokes)
{
	ASSERT(nStrokes>=1);
	if (nStrokes==1) return 0;
	if (nStrokes==2) return 1;
	if (nStrokes==3) return 2;
	if (nStrokes==4) return 3;
	if (nStrokes<=8) return 4;
	if (nStrokes<=16) return 5;
	if (nStrokes<=32) return 6;
	return 7;
}

// Convert an aspect ratio to a feature number
int AspectRatioToFeature(RECT r)
{
	ASSERT(r.left<=r.right);
	ASSERT(r.top<=r.bottom);
	return RatioToFeature((float)r.right-r.left+1,(float)r.bottom-r.top+1);
}

// Convert a ratio which has the range 0 to 1 to a feature number of 0 to 4 inclusive
int FractionToFeature(int num, int denom)
{
	return 0;
	if (5*num<=1*denom) return 0;
	if (5*num<=2*denom) return 1;
	if (5*num<=3*denom) return 2;
	if (5*num<=4*denom) return 3;
	return 4;
}

// A binary overlap feature: 1 if overlapped, 0 otherwise
int OverlapRatioToFeature(RECT r1, RECT r2)
{
	return 0;
	if (r1.left>r2.right || r1.right<r2.left || r1.top>r2.bottom || r1.bottom<r2.top)
		return 0;
	return 1;
}

// Convert an area ratio to a feature number
int SizeRatioToFeature(RECT r1, RECT r2)
{
	ASSERT(r1.left<=r1.right);
	ASSERT(r1.top<=r1.bottom);
	ASSERT(r2.left<=r2.right);
	ASSERT(r2.top<=r2.bottom);
	return RatioToFeature(((float)r1.right-r1.left+1)*((float)r1.bottom-r1.top+1),((float)r2.right-r2.left+1)*((float)r2.bottom-r2.top+1));
}

// Convert a matching space with associated score to a feature number
int MatchSpaceScoreToFeature(int nStrokes, FLOAT score, int matchSpace)
{
	int iScore=(int)floor(-score);
	ASSERT(matchSpace>=0 && matchSpace<32);
	if (iScore<0) iScore=0;
	if (nStrokes<3) iScore/=10;
	if (iScore>=ScoreBins) iScore=ScoreBins-1;
	if (nStrokes<3) return matchSpace*ScoreBins+iScore; else
		return (matchSpace+32)*ScoreBins+iScore;
}

// Returns the unary feature bin of one range of the ink, from index iStart<=index<iEnd
// The returned bin should be in the range 0<=bin<UnaryFeatureRange
int ComputeUnaryFeatures(STROKE_SET_STATS *stats, int nStrokes)
{
	int bin;
	ASSERT(nStrokes>0);
	bin=StrokeBins*RatioBins*FractionToFeature(stats->space,stats->area)+StrokeBins*AspectRatioToFeature(stats->rect)+StrokeCountToFeature(nStrokes);
	ASSERT(bin>=0 && bin<UnaryFeatureRange);
	return bin;
}

// Returns the unary feature bin of one range of the ink, from index iStart1<=index<iStart2
// and iStart2<=index<iEnd
// The returned bin should be in the range 0<=bin<BinaryFeatureRange
int ComputeBinaryFeatures(STROKE_SET_STATS *stats1, STROKE_SET_STATS *stats2, int nStrokes1, int nStrokes2)
{
	int bin;
	ASSERT(nStrokes1>0);
	ASSERT(nStrokes2>0);
	bin=
		RatioBins*StrokeBins*StrokeBins*OverlapBins*RatioBins*FractionToFeature(stats2->space,stats2->area)+
		RatioBins*StrokeBins*StrokeBins*OverlapBins*AspectRatioToFeature(stats2->rect)+
		RatioBins*StrokeBins*StrokeBins*OverlapRatioToFeature(stats1->rect,stats2->rect)+
		StrokeBins*StrokeBins*SizeRatioToFeature(stats1->rect,stats2->rect)+
		StrokeBins*StrokeCountToFeature(nStrokes1)+
		StrokeCountToFeature(nStrokes2);
	ASSERT(bin>=0 && bin<BinaryFeatureRange);
	return bin;
}

// The following functions will be replaced by Greg's code

// Compute the log base 2 of the ratio of the two arguments.  There are several special
// cases to consider: If denom is zero, then the returned value is zero.  If the numerator
// is zero (it should never be negative), then the value returned is Log2Range.  All other
// values are clipped to the range Log2Range<=val<=0
PROB ClippedLog2(COUNTER num, COUNTER denom)
{
	double ratio, val;
	ASSERT(num>=0);
	ASSERT(denom>=0);
	if (denom==0) return Log2Range;
	if (num==0) return Log2Range;
	ratio=(double)num/(double)denom;
	val=log(ratio)/log(2.0);
	if (val<Log2Range) val=Log2Range;
	if (val>0) val=0;
	return (int)floor(val+0.5);
}

PROB ClippedLog2Threshold(COUNTER num, COUNTER denom, COUNTER threshold)
{
	ASSERT(num>=0);
	ASSERT(denom>=0);
	if (num<threshold) return ClippedLog2(0,denom);
	if (denom-num<threshold) return 0;
	return ClippedLog2(num,denom);
}

// Interval management code: Given a range of numbers, and many ranges within it which are removed,
// keeps track of the remaining free space.  This is used to compute how much white space there is in
// a proposed character, once it is projected on to the X and Y axes.

// Initialize the interval structure
void EmptyIntervals(INTERVALS *intervals, int min, int max)
{
	ASSERT(intervals!=NULL);
	ASSERT(min<=max);
	intervals->numIntervals=0;
	intervals->minRange=min;
	intervals->maxRange=max;
}

// Add a given range of ink to the interval structure.  
void ExpandIntervalsRange(INTERVALS *intervals, int min, int max)
{
	int i;
	ASSERT(intervals!=NULL);
	ASSERT(min<=max);

	// If the added range extends beyond the minimum of the current range, then
	// extend.
	if (min<intervals->minRange) {
		// Find the free interval that touches the current minimum
		BOOL minFound=FALSE;
		for (i=0; i<intervals->numIntervals; i++) {
			if (intervals->min[i]==intervals->minRange) {
				// When found, extend it.
				intervals->min[i]=min;
				minFound=TRUE;
			}
		}
		// If there wasn't a free interval touching the boundary, then
		// make one to account for the extra space
		if (!minFound) {
			intervals->min[intervals->numIntervals]=min;
			intervals->max[intervals->numIntervals]=intervals->minRange-1;
			intervals->numIntervals++;
		}
		// Extend the range of the interval set.
		intervals->minRange=min;
	}
	// If the added range extends beyond the maximum of the current range,
	// then extend.
	if (max>intervals->maxRange) {
		// Find the free interval that touches the current maximum
		BOOL maxFound=FALSE;
		for (i=0; i<intervals->numIntervals; i++) {
			if (intervals->max[i]==intervals->maxRange) {
				// When found, extend it.
				intervals->max[i]=max;
				maxFound=TRUE;
			}
		}
		// If there wasnt' a free interval touching the boundary, then
		// make one to accoutn for the extra space.
		if (!maxFound) {
			intervals->min[intervals->numIntervals]=intervals->maxRange+1;
			intervals->max[intervals->numIntervals]=max;
			intervals->numIntervals++;
		}
		// Extend the range of the interval set.
		intervals->maxRange=max;
	}
}

// Remove a given range of ink from the interval structure.  
void RemoveInterval(INTERVALS *intervals, int min, int max)
{
	int i;
	ASSERT(intervals!=NULL);
	ASSERT(min<=max);
	// Scan through all the free intervals currently in the set.
	for (i=0; i<intervals->numIntervals; i++) {
		// No overlap case
		if (min>intervals->max[i] || max<intervals->min[i]) {
			continue;
		}
		// Complete overlap case: delete interval
		if (min<=intervals->min[i] && max>=intervals->max[i]) {
			int nMove=intervals->numIntervals-i-1;
			if (nMove>0) {
				memmove(intervals->min+i,intervals->min+i+1,nMove*sizeof(int));
				memmove(intervals->max+i,intervals->max+i+1,nMove*sizeof(int));
			}				
			intervals->numIntervals--;
			i--;
			continue;
		}
		// Complete overlap case: break free interval in two
		if (min>intervals->min[i] && max<intervals->max[i]) {
			intervals->min[intervals->numIntervals]=max+1;
			intervals->max[intervals->numIntervals]=intervals->max[i];
			intervals->max[i]=min-1;
			intervals->numIntervals++;
			continue;
		}
		// Min side overlapped
		if (min<=intervals->min[i] && max<intervals->max[i]) {
			intervals->min[i]=max+1;
			continue;
		}
		// Max side overlapped
		if (min>intervals->min[i] && max>=intervals->max[i]) {
			intervals->max[i]=min-1;
			continue;
		}
	}
#ifdef DBG
	for (i=0; i<intervals->numIntervals; i++) {
		ASSERT(min>intervals->max[i] || max<intervals->min[i]);
	}
#endif
}

// Get the total range of the interval set
int TotalRange(INTERVALS *intervals)
{
	ASSERT(intervals!=NULL);
	return intervals->maxRange-intervals->minRange+1;
}

// Get the total amount of free space in the interval set
int TotalPresent(INTERVALS *intervals)
{
	int i, total;
	ASSERT(intervals!=NULL);
	total=0;
	for (i=0; i<intervals->numIntervals; i++) {
		total += intervals->max[i]-intervals->min[i]+1;
	}
	return total;
}

// Test two rectangles for overlap (duplicates a system provided function)
BOOL Overlapping(RECT r1, RECT r2)
{
	if (r1.left>r2.right || r1.right<r2.left ||
		r1.top>r2.bottom || r1.bottom<r2.top) 
		return 0;
	return 1;
}

// Get the area of a rectangle (may duplicate a system provided function)
int Area(RECT r)
{
	return (r.right-r.left)*(r.bottom-r.top);
}

// Compute the convex hull of the two rectangles (may duplicate a system provided function)
RECT Union(RECT r1, RECT r2)
{
	RECT result;
	result.left=__min(r1.left,r2.left);
	result.right=__max(r1.right,r2.right);
	result.top=__min(r1.top,r2.top);
	result.bottom=__max(r1.bottom,r2.bottom);
	return result;
}

#ifndef USE_RESOURCES

// Load a bbox probability table from a file with the given name
BBOX_PROB_TABLE *LoadBBoxProbTableFile(wchar_t *pRecogDir, LOAD_INFO *pInfo)
{
	wchar_t wszFile[_MAX_PATH];
	BYTE *pByte;
	FormatPath(wszFile, pRecogDir, NULL, NULL, NULL, L"free.dat");
	pByte = DoOpenFile(pInfo, wszFile);
	if (!pByte) return NULL;
	return (BBOX_PROB_TABLE*)pByte;
}

BOOL UnLoadBBoxProbTableFile(LOAD_INFO *pInfo)
{
	return DoCloseFile(pInfo);
}

#else // USE_RESOURCES

// Load a bbox probability table from a resource (actually, just point at the 
// resource).
BBOX_PROB_TABLE *LoadBBoxProbTableRes(HINSTANCE hInst, int nResID, int nType)
{
	return (BBOX_PROB_TABLE *)DoLoadResource(NULL, hInst, nResID, nType);
}

#endif // USE_RESOURCES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\brk.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/brknet.c
//
// Description:
//	    Functions to implement the functionality of managing breakpoint structures.
//
// Author:
// ahmadab 11/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"
#include "brknet.h"


// free an element list
void FreeElemList (ELEMLIST *pList)
{
	if (pList->pElem)
	{
		ExternFree (pList->pElem);
	}
}

// reverses the order of entries in an element list
void ReverseElementList (ELEMLIST *pElemList)
{
	LATTICE_PATH_ELEMENT	Elem;
	int						iElemFor, iElemBack;

	for (	iElemFor = 0, iElemBack = pElemList->cElem -1; 
			iElemFor < pElemList->cElem && iElemBack >= 0 && iElemFor < iElemBack; 
			iElemFor++, iElemBack--
		)
	{
		Elem						=	pElemList->pElem[iElemFor];
		pElemList->pElem[iElemFor]	=	pElemList->pElem[iElemBack];
		pElemList->pElem[iElemBack]	=	Elem;
	}
}

// frees a break point array
void	FreeBreaks (int cBrk, BRKPT *pBrk)
{
	int	i;

	for (i = 0; i < cBrk; i++)
	{
		FreeElemList (&pBrk[i].Starting);
		FreeElemList (&pBrk[i].Ending);
		FreeElemList (&pBrk[i].Crossing);
	}

	ExternFree (pBrk);
}

// insert an element into an element list
BOOL InsertListElement (ELEMLIST *pList, int iStrk, int iAlt, LATTICE_ELEMENT *pLatElem)
{
	LATTICE_PATH_ELEMENT	*pElem;

	// expand the element list
	pList->pElem	=	(LATTICE_PATH_ELEMENT *) ExternRealloc (pList->pElem, 
		(pList->cElem + 1) * sizeof (*pList->pElem));

	if (!pList->pElem)
	{
		return FALSE;
	}

	pElem			=	pList->pElem + pList->cElem;
	pElem->iAlt		=	iAlt;
	pElem->iStroke	=	iStrk;
	pElem->nStrokes	=	pLatElem->nStrokes;
	pElem->wChar	=	pLatElem->wChar;
	pElem->iBoxNum	=	-1;

	pList->cElem++;

	return TRUE;
}

// makes the break point list
BRKPT *CreateBrkPtList (LATTICE *pLat)
{
	BRKPT				*pBrk	=	NULL;
	int					cStrk	=	pLat->nStrokes;
	BOOL				bRet	=	FALSE;
	int					i,
						iStrk, 
						iAlt, 
						cAlt,
						iStrtStrk,
						iPrevAlt;
	LATTICE_ALT_LIST	*pAlt;

	// allocate and init buffer
	pBrk	=	(BRKPT *) ExternAlloc (cStrk * sizeof (BRKPT));
	if (!pBrk)
	{
		goto exit;
	}

	memset (pBrk, 0, cStrk * sizeof (BRKPT));

	// all strokes are candidate break points
	for (iStrk = 0; iStrk < cStrk; iStrk++)
	{
		// look at the alt list of words ending at this stroke
		pAlt	=	pLat->pAltList + iStrk;
		cAlt	=	pAlt->nUsed;

		// for all alts
		for (iAlt = 0; iAlt < cAlt; iAlt++)
		{
			// did it occur before
			for (iPrevAlt = 0; iPrevAlt < iAlt; iPrevAlt++)
			{
				if (pAlt->alts[iAlt].nStrokes == pAlt->alts[iPrevAlt].nStrokes)
				{
					break;
				}
			}

			// there was no previous alt with the same # of strokes
			if (iPrevAlt == iAlt)
			{
				// update the starting list
				iStrtStrk	=	iStrk - pAlt->alts[iAlt].nStrokes + 1;

				// This shouldn't happen, but there is enough code involved in
				// building up the lattice that it is probably a good idea to check.
				if (iStrtStrk < 0) 
				{
					ASSERT(("Malformed lattice in CreateBrkPtList()", 0));
					goto exit;
				}

				if (iStrtStrk > 0)
				{
					if	(	!InsertListElement (&pBrk[iStrtStrk - 1].Starting, iStrk,
								iAlt, pAlt->alts + iAlt)
						)
					{
						goto exit;
					}
				}

				// update the ending list
				if	(	!InsertListElement (&pBrk[iStrk].Ending, iStrk,
							iAlt, pAlt->alts + iAlt)
					)
				{
					goto exit;
				}

				// update the crossing list
				for (i = iStrtStrk; i < iStrk; i++)
				{
					if	(	!InsertListElement (&pBrk[i].Crossing, iStrk,
								iAlt, pAlt->alts + iAlt)
						)
					{
						goto exit;
					}
				}
			}
		}
	}

	bRet	=	TRUE;

exit:
	if (!bRet)
	{
		if (pBrk)
		{
			FreeBreaks (cStrk, pBrk);
		}

		return NULL;
	}
	else
	{
		return pBrk;
	}
}


// find the element with the best probablity in the element list
LATTICE_ELEMENT *FindBestInList		(	LATTICE					*pLat, 
										ELEMLIST				*pList, 
										LATTICE_PATH_ELEMENT	**ppBestElem
									)
{
	int					i, iAlt;
	LATTICE_ELEMENT		*pBest	=	NULL;
	LATTICE_ALT_LIST	*pAlt;

	// go thru all elements
	for (i = 0; i < pList->cElem; i++)
	{
		pAlt	=	pLat->pAltList + pList->pElem[i].iStroke;
		iAlt	=	pList->pElem[i].iAlt;

		// exclude fake elements
		if (pAlt->alts[iAlt].wChar == SYM_UNKNOWN)
			continue;

		// update the best
		if (!pBest || pBest->logProb < pAlt->alts[iAlt].logProb)
		{
			(*ppBestElem)	=	pList->pElem + i;
			pBest			=	pAlt->alts + iAlt;
		}
	}

	return pBest;
}

float FuguSegScore(int cStrokes, STROKE *pStrokes, LOCRUN_INFO *pLocRunInfo);

// compute the set of features for a given break point
// returns the number of features computed
int FeaturizeBrkPt (LATTICE *pLat, BRKPT *pBrk, int *pFeat)
{
	int						xDist, 
							iHgt;

	int						cFeat			=	0;

	LATTICE_ELEMENT			*pBestStart		=	NULL,
							*pBestEnd		=	NULL,
							*pBestCross		=	NULL;

	LATTICE_PATH_ELEMENT	*pBestStartPathElem	=	NULL,
							*pBestEndPathElem	=	NULL,
							*pBestCrossPathElem	=	NULL;
							

	ASSERT (cFeat < MAX_BRK_NET_FEAT);
	pFeat[cFeat++]	=	pBrk->Starting.cElem * 1000;
	

	ASSERT (cFeat < MAX_BRK_NET_FEAT);
	pFeat[cFeat++]	=	pBrk->Ending.cElem * 1000;
	
	ASSERT (cFeat < MAX_BRK_NET_FEAT);
	pFeat[cFeat++]	=	pBrk->Crossing.cElem * 500;

			
	// find the best chars
	pBestStart	=	FindBestInList (pLat, &pBrk->Starting, &pBestStartPathElem);
	pBestEnd	=	FindBestInList (pLat, &pBrk->Ending, &pBestEndPathElem);
	pBestCross	=	FindBestInList (pLat, &pBrk->Crossing, &pBestCrossPathElem);
	
	// do we have a starting best
	if (pBestStart)
	{
		// a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (-1.0 * pBestStart->logProb * 1000));

		// space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (65535 * (double) pBestStart->space / (pBestStart->area + 1)));
        ASSERT (pFeat[cFeat - 1] >= 0);

		// # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	pBestStart->nStrokes * 1000;

		// char unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, pBestStart->wChar)));
		
		// Fugu Char Detector score, compute if did not doo it before
		if (pBestStart->iCharDetectorScore == -1)
		{
			pBestStart->iCharDetectorScore	=	
				min (65535, (int) (65535.0 * FuguSegScore (pBestStart->nStrokes, 
						pLat->pStroke + pBestStartPathElem->iStroke -  pBestStart->nStrokes + 1,
						&g_locRunInfo)));
		}

		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	max (0, min (65535, pBestStart->iCharDetectorScore));
			
	}
	else
	{
		// not a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// fake space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, 0xFFFE)));

		// fake fugu score
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;
	}

	if (pBestEnd)
	{
		// a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (-1.0 * pBestEnd->logProb * 1000));

		// space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (65535 * (double) pBestEnd->space / (pBestEnd->area + 1)));
        ASSERT (pFeat[cFeat - 1] >= 0);

		// # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	pBestEnd->nStrokes * 1000;

		// char unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, pBestEnd->wChar)));
		
		// Fugu Char Detector score
		if (pBestEnd->iCharDetectorScore == -1)
		{
			pBestEnd->iCharDetectorScore	=	
				min (65535, (int) (65535.0 * FuguSegScore (pBestEnd->nStrokes, 
						pLat->pStroke + pBestEndPathElem->iStroke -  pBestEnd->nStrokes + 1,
						&g_locRunInfo)));
		}

		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	max (0, min (65535, pBestEnd->iCharDetectorScore));
	}
	else
	{
		// not a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// fake space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, 0xFFFE)));

		// fake fugu score
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;
	}

	if (pBestCross)
	{
		// a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (-1.0 * pBestCross->logProb * 1000));

		// space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535, (int) (65535 * (double) pBestCross->space / (pBestCross->area + 1)));
        ASSERT (pFeat[cFeat - 1] >= 0);

		// # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	pBestCross->nStrokes * 1000;

		// char unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, pBestCross->wChar)));
		
		// Fugu Char Detector score
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		if (pBestCross->iCharDetectorScore == -1)
		{
			pBestCross->iCharDetectorScore	=	
				min (65535, (int) (65535.0 * FuguSegScore (pBestCross->nStrokes, 
						pLat->pStroke + pBestCrossPathElem->iStroke -  pBestCross->nStrokes + 1,
						&g_locRunInfo)));
		}

		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	max (0, min (65535, pBestCross->iCharDetectorScore));
	}
	else
	{
		// not a real char
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake log prob
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;

		// fake space / area
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake # of strokes
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		// fake unigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, (int) (-255 * UnigramCost (&g_unigramInfo, 0xFFFE)));

		// fake fugu score
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;
	}

	if (pBestStart && pBestEnd)
	{
		xDist	=	pBestStart->bbox.left - pBestEnd->bbox.right;
		iHgt	=	1 + (	(pBestStart->bbox.bottom - pBestStart->bbox.top) +
							(pBestEnd->bbox.bottom - pBestEnd->bbox.top)
						) / 2;

		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	
			min (65535, 32768 + (int)(32768.0 * xDist / (abs(xDist) + iHgt)));

		// bigram
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	min (65535,
			(int) (-1.0 * BigramTransitionCost (&g_locRunInfo, &g_bigramInfo, 
				pBestEnd->wChar, pBestStart->wChar) * 65535));
	}
	else
	{
		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	0;

		ASSERT (cFeat < MAX_BRK_NET_FEAT);
		pFeat[cFeat++]	=	65535;
	}

	return cFeat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\brknet.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/brknet.c
//
// Description:
//	    Functions to implement the functionality of the break Neural net that 
// modifies the lattice structure to correct segmentation errors.
//
// Author:
// ahmadab 11/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"
#include "brknet.h"
#include "segm.h"
#include "nnet.h"

// the size and structure representing the Breaking net used in Free mode
// if the is not available for a particular configuration, s_iBrkNetSize will be zero
static int			s_iBrkNetSize	=	0; 
static LOCAL_NET	s_BrkNet;

// validates the header of the brknet
BOOL CheckBrkNetHeader (void *pData)
{
	NNET_HEADER		*pHeader	=	(NNET_HEADER *)pData;

	// wrong magic number
	ASSERT (pHeader->dwFileType == BRKNET_FILE_TYPE);

	if (pHeader->dwFileType != BRKNET_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= BRKNET_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= BRKNET_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

	ASSERT (pHeader->cSpace == 1);

    if	(	pHeader->iFileVer >= BRKNET_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= BRKNET_CUR_FILE_VERSION &&
			!memcmp (	pHeader->adwSignature, 
						g_locRunInfo.adwSignature, 
						sizeof (pHeader->adwSignature)
					) &&
			pHeader->cSpace == 1
		)
    {
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

// does the necessary preparations for a net to be used later
static LOCAL_NET *PrepareBrkNet(BYTE *pData, int *piNetSize, LOCAL_NET *pNet)
{
	NNET_SPACE_HEADER	*pSpaceHeader;

	if (!pData)
	{
		return FALSE;
	}

	// check the header info
	if (!CheckBrkNetHeader (pData))
	{
		return NULL;
	}

	// point to the one and only space that we have
	pSpaceHeader	=	(NNET_SPACE_HEADER *)(pData + sizeof (NNET_HEADER));

	// point to the actual data
	pData	=	pData + pSpaceHeader->iDataOffset;

	// restore the connections
	if (!(pNet = restoreLocalConnectNet(pData, 0, pNet)) )
	{
		return NULL;
	}

	// compute the run time memory requirements of the net
	(*piNetSize) = getRunTimeNetMemoryRequirements(pData);

	if ((*piNetSize) <= 0)
	{
		return NULL;
	}

	return pNet;
}

// load the brk net from resources
BOOL LoadBrkNetFromFile(wchar_t *pwszRecogDir, LOAD_INFO *pLoadInfo)
{
	BYTE		*pData;
	wchar_t		awszFileName[MAX_PATH];
	
	// init the size to zero, in case we fail
	s_iBrkNetSize	=	0;

	swprintf (awszFileName, L"%s\\brknet.bin", pwszRecogDir);
	
	// memory map the file
	pData	=	DoOpenFile (pLoadInfo, awszFileName);
	if (!pData)
	{
		return FALSE;
	}

	// prepare Brk net
	if (!PrepareBrkNet(pData, &s_iBrkNetSize, &s_BrkNet))
	{
		return FALSE;
	}
	
	return TRUE;
}

// load the brk net from resources
BOOL LoadBrkNetFromResource (HINSTANCE hInst, int nResID, int nType)
{
	BYTE		*pData;
	LOAD_INFO	LoadInfo;
	
	// init the size to zero, in case we fail
	s_iBrkNetSize	=	0;

	pData	=	DoLoadResource (&LoadInfo, hInst, nResID, nType);
	if (!pData)
	{
		return FALSE;
	}

	// prepare the net
	if (!PrepareBrkNet(pData, &s_iBrkNetSize, &s_BrkNet))
	{
		return FALSE;
	}
	
	return TRUE;
}

// update the lattice by running the BRK-NET on all the possible break points.
// Currently only one segmentation survives which is the one suggested by the BRK-NET
// returns the number of charcaters in the updated lattice on success, -1 upon failure
int UpdateLattice (LATTICE *pLat)
{
	int		iPos,
			iStrk, 
			cStrk,
			iWinner,
			cOut,
			cBrk;

	BOOL	*pIsBreak	=	NULL;

	BRKPT	*pBrk		=	NULL;

	RREAL	*pNetMem	=	NULL, 
			*pNetOut;

	int		iRet		=	-1,
			iBrk;

	// if the net has not been successfully loaded, we'll fail
	if (s_iBrkNetSize <= 0)
	{
		goto exit;
	}

	// alloc memory for the Net's running buffer
	pNetMem	=	(RREAL *) ExternAlloc (s_iBrkNetSize * sizeof (*pNetMem));
	if (!pNetMem)
	{
		goto exit;
	}
	
	// create the break pts structure
	cStrk	=	pLat->nStrokes;
	pBrk	=	CreateBrkPtList (pLat);

	// if we have succeeded, lets process these break points
	if (pBrk)
	{
		// allocate a boolean struct to mark ON break points
		pIsBreak	=	(BOOL *) ExternAlloc (cStrk * sizeof (*pIsBreak));
		if (!pIsBreak)
		{
			goto exit;
		}

		// for all break points
		for (iStrk = 0, cBrk = 0; iStrk < cStrk; iStrk++)
		{
			int	iFeat, cFeat, aFeat[MAX_BRK_NET_FEAT];

			// featurize for this break point
			cFeat	=	FeaturizeBrkPt (pLat, pBrk + iStrk, aFeat);
			ASSERT (cFeat <= MAX_BRK_NET_FEAT);

			// prepare the nets input
			for (iFeat = 0; iFeat < cFeat; iFeat++)
			{
				pNetMem[iFeat]	=	aFeat[iFeat];
			}

			// run the net
			pNetOut = runLocalConnectNet (&s_BrkNet, pNetMem, &iWinner, &cOut);
			ASSERT (cOut == 2);

			// this is considered a hard break point if the net's output is higher than the threshold
			pIsBreak[iStrk]	=	pNetOut[1] >= (BREAKING_THRESHOLD);

			// mark it a as a breakpoint
			if (pIsBreak[iStrk])
			{
				cBrk++;
			}

			// copy the score in the lattice
			pLat->pAltList[iStrk].iBrkNetScore	=	pNetOut[1];
		}

		ASSERT (cBrk <= cStrk);

		// make sure there is a break point always at the end,
		if (!pIsBreak[cStrk - 1])
		{
			pIsBreak[cStrk - 1]	=	TRUE;
			cBrk++;
		}

		// clear out all the existing alternate lists at every stroke
		for (iStrk = 0; iStrk < cStrk; iStrk++)
		{
			ClearAltList (pLat->pAltList + iStrk);
		}
	
		// change the lattice to reflect the new segmentation
		for (iBrk = iStrk = 0; iBrk < cBrk; iBrk++)
		{
			iPos	=	iStrk;

			// find the next break point
			while (!pIsBreak[iStrk] && iStrk < cStrk)
			{
				iStrk++;
			}

			// build the alt list at the the ending stroke with the 
			// current stroke being the starting one
			//BuildStrokeCountRecogAlts(pLat, iStrk, iStrk - iPos + 1);

			if (!ProcessLatticeRange (pLat, iPos, iStrk))
			{
				goto exit;
			}

			UpdateSegmentations (pLat, iPos, iStrk);
			
			iStrk++;
		}

		// Mark the best path through the lattice
		//iRet	=	FindFullPath (pLat);
		FixupBackPointers (pLat);
	}

exit:

	// free the local buffers if had been allocated
	if (pBrk)
	{
		FreeBreaks (cStrk, pBrk);
	}

	if (pIsBreak)
	{
		ExternFree (pIsBreak);
	}

	if (pNetMem)
	{
		ExternFree (pNetMem);
	}

	return iRet;
}


void BrkNetUnloadfile (LOAD_INFO *pLoadInfo)
{
	if (s_iBrkNetSize != 0)
	{
		DoCloseFile (pLoadInfo);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\twister\src\wispapis.c ===
/*********************** ...\twister\src\wispapis.c ************************\
*																			*
*		WISP APIs for accessing the Twister gesture recognizer.				*
*																			*
*	Created:	September 20, 2001											*
*	Author:		Petr Slavik, pslavik										*
*																			*
\***************************************************************************/

#include <limits.h>

#include "RecTypes.h"
#include "recapis.h"
#include "TpcError.h"

#include "common.h"
#include "twister.h"
#include <strsafe.h>
#include "TpgHandle.h"
#include "res.h"

#define POINTS_PER_INCH_DFLT	2540		// High metric default for resolution

extern HINSTANCE g_hInstanceDll;

//
// List of supported gestures

static WCHAR g_awcSupportedGestures[] =
{
	// GESTURE_NULL,		// Not really supported
	GESTURE_SCRATCHOUT,
	GESTURE_TRIANGLE,
	GESTURE_SQUARE,
	GESTURE_STAR,
	GESTURE_CHECK,
	GESTURE_CURLICUE,
	GESTURE_DOUBLE_CURLICUE,
	GESTURE_CIRCLE,
	GESTURE_DOUBLE_CIRCLE,
	GESTURE_SEMICIRCLE_LEFT,
	GESTURE_SEMICIRCLE_RIGHT,
	GESTURE_CHEVRON_UP,
	GESTURE_CHEVRON_DOWN,
	GESTURE_CHEVRON_LEFT,
	GESTURE_CHEVRON_RIGHT,
	GESTURE_ARROW_UP,
	GESTURE_ARROW_DOWN,
	GESTURE_ARROW_LEFT,
	GESTURE_ARROW_RIGHT,
	GESTURE_UP,
	GESTURE_DOWN,
	GESTURE_LEFT,
	GESTURE_RIGHT,
	GESTURE_UP_DOWN,
	GESTURE_DOWN_UP,
	GESTURE_LEFT_RIGHT,
	GESTURE_RIGHT_LEFT,
	GESTURE_UP_LEFT_LONG,
	GESTURE_UP_RIGHT_LONG,
	GESTURE_DOWN_LEFT_LONG,
	GESTURE_DOWN_RIGHT_LONG,
	GESTURE_UP_LEFT,
	GESTURE_UP_RIGHT,
	GESTURE_DOWN_LEFT,
	GESTURE_DOWN_RIGHT,
	GESTURE_LEFT_UP,
	GESTURE_LEFT_DOWN,
	GESTURE_RIGHT_UP,
	GESTURE_RIGHT_DOWN,
	GESTURE_EXCLAMATION,
	GESTURE_TAP,
	GESTURE_DOUBLE_TAP,
};

#define MAX_SUPPORTED_GESTURES  sizeof(g_awcSupportedGestures) / sizeof(g_awcSupportedGestures[0])

/***************************************************************************\
*	CountRanges:															*
*		Count the number of ranges (runs of contiguous ON bits) in the		*
*		bit array of enabled/supported gestures.							*
\***************************************************************************/

static ULONG
CountRanges(DWORD *adw)		// I: Bit array of enabled/supported gestures
{
	ULONG	count = 0;
	BOOL	bPreviousOn = FALSE;
	int		index;

	for (index = 1; index < MAX_GESTURE_COUNT; index++)
	{
		if ( IsSet(index, adw) )
		{
			if (!bPreviousOn)
			{
				count++;
				bPreviousOn = TRUE;
			}
		}
		else
		{
			if (bPreviousOn)
			{
				bPreviousOn = FALSE;
			}
		}
	}
	return count;
}


/***************************************************************************\
*	GetRanges:																*
*		Get an array of ranges (runs of contiguous ON bits) from the bit 	*
*		array of enabled/supported gestures.								*
\***************************************************************************/

static HRESULT
GetRanges(DWORD	*adw,				//  I:  Bit array of enabled/supported gestures
		  ULONG	*pulCount,			// I/O: Number of ranges
		  CHARACTER_RANGE *pcr)		//  O:  Array of ranges
{
	ULONG	count = 0;
	BOOL	bPreviousOn = FALSE;
	int		index;

	for (index = 1; index < MAX_GESTURE_COUNT; index++)
	{
		if ( IsSet(index, adw) )
		{
			if (!bPreviousOn)	// New range
			{
				if (count >= *pulCount)
					return TPC_E_INSUFFICIENT_BUFFER;
				count++;
				bPreviousOn = TRUE;
				pcr->wcLow = (WCHAR)(GESTURE_NULL + index);
				pcr->cChars = 1;
			}
			else
			{
				pcr->cChars++;
			}
		}
		else
		{
			if (bPreviousOn)
			{
				bPreviousOn = FALSE;
				pcr++;				// Get ready for the next range
			}
		}
	}
	*pulCount = count;
	return S_OK;
}


/***************************************************************************\
*	GetHotPoint:															*
*		Given ink and our guess for a gesture, compute the hot point.		*
\***************************************************************************/

static POINT
GetHotPoint(WCHAR wcID,			// I: Our "guess" of the ink ID
			GLYPH *glyph)		// I: Ink of the gesture
{
	POINT hotPoint, *pPoint;
	FRAME *frame;
	ULONG ulXSum = 0, ulYSum = 0, ulCount = 0;
	LONG x, y, min, max, temp;
	RECT rect;

	ASSERT(glyph);					// At least one stroke
	ASSERT(glyph->frame);
	ASSERT(glyph->frame->rgrawxy);

	switch (wcID)
	{
	case GESTURE_CHEVRON_UP:		// Hot point for these gestures
	case GESTURE_ARROW_UP:			// is the average of x-coordinates
	case GESTURE_UP_DOWN:			// of the top-most points
		GetRectGLYPH(glyph, &rect);
		x = rect.left;
		y = rect.top;
		for ( ; glyph; glyph = glyph->next)
		{
			frame = glyph->frame;
			if ( RectFRAME(frame)->top > y )
				continue;
			for (pPoint = frame->rgrawxy + frame->info.cPnt - 1;
				 pPoint >= frame->rgrawxy;
				 pPoint--)
			{
				if (pPoint->y == y)
				{
					ulXSum += pPoint->x - x;
 					ulCount++;
				}
			}
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = y;
		break;

	case GESTURE_CHECK:
	case GESTURE_CHEVRON_DOWN:		// Hot point for these gestures
	case GESTURE_ARROW_DOWN:		// is the average of x-coordinates
	case GESTURE_DOWN_UP:			// of the bottom-most points
		GetRectGLYPH(glyph, &rect);
		x = rect.left;
		y = rect.bottom - 1;
		for ( ; glyph; glyph = glyph->next)
		{
			frame = glyph->frame;
			if ( RectFRAME(frame)->bottom <= y )
				continue;
			for (pPoint = frame->rgrawxy + frame->info.cPnt - 1;
				 pPoint >= frame->rgrawxy;
				 pPoint--)
			{
				if (pPoint->y == y)
				{
					ulXSum += pPoint->x - x;
					ulCount++;
				}
			}
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = y;
		break;

	case GESTURE_CHEVRON_LEFT:		// Hot point for these gestures
	case GESTURE_ARROW_LEFT:		// is the average of y-coordinates
	case GESTURE_LEFT_RIGHT:		// of the left-most points
		GetRectGLYPH(glyph, &rect);
		x = rect.left;
		y = rect.top;
		for ( ; glyph; glyph = glyph->next)
		{
			frame = glyph->frame;
			if ( RectFRAME(frame)->left > x )
				continue;
			for (pPoint = frame->rgrawxy + frame->info.cPnt - 1;
				 pPoint >= frame->rgrawxy;
				 pPoint--)
			{
				if (pPoint->x == x)
				{
					ulYSum += pPoint->y - y;
					ulCount++;
				}
			}
		}
		hotPoint.x = x;
		hotPoint.y = ulYSum / ulCount + y;
		break;
	case GESTURE_CHEVRON_RIGHT:		// Hot point for these gestures
	case GESTURE_ARROW_RIGHT:		// is the average of y-coordinates
	case GESTURE_RIGHT_LEFT:		// of the right-most points
		GetRectGLYPH(glyph, &rect);
		x = rect.right - 1;
		y = rect.top;
		for ( ; glyph; glyph = glyph->next)
		{
			frame = glyph->frame;
			if ( RectFRAME(frame)->right <= x )
				continue;
			for (pPoint = frame->rgrawxy + frame->info.cPnt - 1;
				 pPoint >= frame->rgrawxy;
				 pPoint--)
			{
				if (pPoint->x == x)
				{
					ulYSum += pPoint->y - y;
					ulCount++;
				}
			}
		}
		hotPoint.x = x;
		hotPoint.y = ulYSum / ulCount + y;
		break;

	case GESTURE_UP_LEFT:			// Hot point is the average of x- and y-
	case GESTURE_UP_LEFT_LONG:		// coordinates of the right-top-most points
	case GESTURE_RIGHT_DOWN:
		frame = glyph->frame;			// Only one-stroke gestures
		x = RectFRAME(frame)->left;
		y = RectFRAME(frame)->top;

		pPoint = frame->rgrawxy + frame->info.cPnt - 1;
		min = pPoint->y - pPoint->x;
		ulXSum = pPoint->x - x;
		ulYSum = pPoint->y - y;
		ulCount = 1;
		for (pPoint--;
			 pPoint >= frame->rgrawxy;
			 pPoint--)
		{
			temp = pPoint->y - pPoint->x;
			if (temp > min)
				continue;
			if (temp == min)
			{
				ulXSum += pPoint->x - x;
				ulYSum += pPoint->y - y;
				ulCount++;
			}
			else	// temp < min
			{
				min = temp;
				ulXSum = pPoint->x - x;
				ulYSum = pPoint->y - y;
				ulCount = 1;
			}				
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = ulYSum / ulCount + y;
		break;

	case GESTURE_UP_RIGHT:		// Hot point is the average of x- and y-
	case GESTURE_UP_RIGHT_LONG:	// coordinates of the left-top-most points
	case GESTURE_LEFT_DOWN:
		frame = glyph->frame;			// Only one-stroke gestures
		x = RectFRAME(frame)->left;
		y = RectFRAME(frame)->top;

		pPoint = frame->rgrawxy + frame->info.cPnt - 1;
		min = pPoint->y + pPoint->x;
		ulXSum = pPoint->x - x;
		ulYSum = pPoint->y - y;
		ulCount = 1;
		for (pPoint--;
			 pPoint >= frame->rgrawxy;
			 pPoint--)
		{
			temp = pPoint->y + pPoint->x;
			if (temp > min)
				continue;
			if (temp == min)
			{
				ulXSum += pPoint->x - x;
				ulYSum += pPoint->y - y;
				ulCount++;
			}
			else	// temp < min
			{
				min = temp;
				ulXSum = pPoint->x - x;
				ulYSum = pPoint->y - y;
				ulCount = 1;
			}			
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = ulYSum / ulCount + y;
		break;

	case GESTURE_DOWN_LEFT:			// Hot point is the average of x- and y-
	case GESTURE_DOWN_LEFT_LONG:	// coordinates of the right-bottom-most points
	case GESTURE_RIGHT_UP:
		frame = glyph->frame;			// Only one-stroke gestures
		x = RectFRAME(frame)->left;
		y = RectFRAME(frame)->top;

		pPoint = frame->rgrawxy + frame->info.cPnt - 1;
		max = pPoint->y + pPoint->x;
		ulXSum = pPoint->x - x;
		ulYSum = pPoint->y - y;
		ulCount = 1;
		for (pPoint--;
			 pPoint >= frame->rgrawxy;
			 pPoint--)
		{
			temp = pPoint->y + pPoint->x;
			if (temp < max)
				continue;
			if (temp == max)
			{
				ulXSum += pPoint->x - x;
				ulYSum += pPoint->y - y;
				ulCount++;
			}
			else	// temp > max
			{
				max = temp;
				ulXSum = pPoint->x - x;
				ulYSum = pPoint->y - y;
				ulCount = 1;
			}				
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = ulYSum / ulCount + y;
		break;

	case GESTURE_DOWN_RIGHT:		// Hot point is the average of x- and y-
	case GESTURE_DOWN_RIGHT_LONG:	// coordinates of the left-bottom-most point
	case GESTURE_LEFT_UP:
		frame = glyph->frame;			// Only one-stroke gestures
		x = RectFRAME(frame)->left;
		y = RectFRAME(frame)->top;

		pPoint = frame->rgrawxy + frame->info.cPnt - 1;
		max = pPoint->y - pPoint->x;
		ulXSum = pPoint->x - x;
		ulYSum = pPoint->y - y;
		ulCount = 1;
		for (pPoint--;
			 pPoint >= frame->rgrawxy;
			 pPoint--)
		{
			temp = pPoint->y - pPoint->x;
			if (temp < max)
				continue;
			if (temp == max)
			{
				ulXSum += pPoint->x - x;
				ulYSum += pPoint->y - y;
				ulCount++;
			}
			else	// temp > max
			{
				max = temp;
				ulXSum = pPoint->x - x;
				ulYSum = pPoint->y - y;
				ulCount = 1;
			}				
		}
		hotPoint.x = ulXSum / ulCount + x;
		hotPoint.y = ulYSum / ulCount + y;
		break;

	case GESTURE_EXCLAMATION:			// Hot point is the center of the
		GetRectGLYPH(glyph, &rect);		// bounding box of the upper stroke
		y = rect.top;
		for ( ; glyph; glyph = glyph->next)		// Find the top frame
		{
			rect = *RectFRAME(glyph->frame);
			if ( rect.top == y )
				break;
		}
		hotPoint.x = (rect.left + rect.right) / 2;
		hotPoint.y = (rect.top + rect.bottom) / 2;
		break;

	default:
		hotPoint.x = glyph->frame->rgrawxy->x;		// Hot point is the 
		hotPoint.y = glyph->frame->rgrawxy->y;		// starting point of the glyph
		break;
	}		
	return hotPoint;
}

/***************************************************************************\
*	GetMaxStrokeCount:														*
*		Get maximum number of strokes an enabled gesture can possibly have.	*
\***************************************************************************/

LONG
GetMaxStrokeCount(DWORD *adw)
{
	if (IsSet(GESTURE_TRIANGLE    - GESTURE_NULL, adw) ||
		IsSet(GESTURE_SQUARE      - GESTURE_NULL, adw) ||
		IsSet(GESTURE_ARROW_UP    - GESTURE_NULL, adw) ||
		IsSet(GESTURE_ARROW_DOWN  - GESTURE_NULL, adw) ||
		IsSet(GESTURE_ARROW_LEFT  - GESTURE_NULL, adw) ||
		IsSet(GESTURE_ARROW_RIGHT - GESTURE_NULL, adw) ||
		IsSet(GESTURE_EXCLAMATION - GESTURE_NULL, adw) ||
		IsSet(GESTURE_DOUBLE_TAP  - GESTURE_NULL, adw) )
	{
		return (LONG)2;
	}
	else
	{
		return (LONG)1;
	}
}



/***************************************************************************\
*	struct GestureRec:														*
*		Structure for gesture recognizer.  For now, it contains only the	*
*		bit array of supported gestures.									*
\***************************************************************************/

struct GestureRec
{
    DWORD	adwSupportedGestures[MAX_GESTURE_DWORD_COUNT];
};

/***************************************************************************\
*	LATTICE_DATA:															*
*		Structure that contains all data needed by RECO_LATTICE.			*
\***************************************************************************/

typedef struct tagLATTICE_DATA
{
	RECO_LATTICE_COLUMN rlc;
	ULONG	aulResultColumns[1];
	ULONG	aulResultIndices[1];
	ULONG	*pulStrokes;
	RECO_LATTICE_ELEMENT aRLElements[MAX_GESTURE_ALTS];
	GUID	aGuidProperties[1];
	RECO_LATTICE_PROPERTY *apRLPs[MAX_GESTURE_ALTS];	// Array of ptrs to RECO_LATTICE_PROPERTY
	RECO_LATTICE_PROPERTY aRLPs[MAX_GESTURE_ALTS];
} LATTICE_DATA;


/***************************************************************************\
*	GRC:																	*
*		Gesture Recognition Context											*
\***************************************************************************/

typedef struct tagGRC
{
	DWORD	*pdwSupportedGestures;
    DWORD	adwEnabledGestures[MAX_GESTURE_DWORD_COUNT];
	LONG	lPointsPerInch;
	int cFrames;
	GLYPH *pGlyph;
	BOOL bIsDirty;	// Flag: RecoContext contains some ink
	BOOL bInkDone;	// Flag: EndInkInput() has been called
	BOOL bRecoDone;	// Flag: Process() has already been called on this ink

	GEST_ALTERNATE	answers[MAX_GESTURE_ALTS];		// Array of alternates
	int	cAlts;		// Count of alternates
	RECO_LATTICE *pRecoLattice;
	LATTICE_DATA *pLatticeData;
	XFORM	xform;
} GRC, *PGRC;


/***************************************************************************\
*	GestureAlternate:														*
*		Structure for keeping information about best recognition results.	*
\***************************************************************************/

typedef struct tagGestureAlternate
{
    GRC		*pgrc;			// Pointer to Gesture Recognition Context
	WCHAR	wcID;			// Gesture ID
	float	eScore;			// Gesture score
	POINT	hotPoint;		// Hot point of the gesture
} GestureAlternate;


/***************************************************************************\
*	GUIDs needed by the APIs:												*
*		g_guidx, g_guidy		- needed for the packet description.		*
*		GUID_HOTPOINT			- property of alternates					*
*		GUID_MAX_STROKE_COUNT	- property of the recognition context.		*
\***************************************************************************/

const GUID g_guidx = { 0x598a6a8f, 0x52c0, 0x4ba0, { 0x93, 0xaf, 0xaf, 0x35, 0x74, 0x11, 0xa5, 0x61 } };
const GUID g_guidy = { 0xb53f9f75, 0x04e0, 0x4498, { 0xa7, 0xee, 0xc3, 0x0d, 0xbb, 0x5a, 0x90, 0x11 } };
const GUID GUID_HOTPOINT =			{ 0xca6f40dc, 0x5292, 0x452a, { 0x91, 0xfb, 0x21, 0x81, 0xc0, 0xbe, 0xc0, 0xde } };
const GUID GUID_MAX_STROKE_COUNT =	{ 0xbf0eec4e, 0x4b7d, 0x47a9, { 0x8c, 0xfa, 0x23, 0x4d, 0xd2, 0x4b, 0xd2, 0x2a } };
// const GUID GUID_POINTS_PER_INCH =	{ 0x7ed16b76, 0x889c, 0x468e, { 0x82, 0x76, 0x00, 0x21, 0xb7, 0x70, 0x18, 0x7e } };


//
//	Default property metrics for preferred PACKET_DESCRIPTION.				

const PROPERTY_METRICS g_DefaultPropMetrics = { LONG_MIN, LONG_MAX, PROPERTY_UNITS_CENTIMETERS, 1000.0 };


//
// Handle definitions

#define TPG_HRECOGNIZER			(1)
#define TPG_HRECOCONTEXT		(2)
#define TPG_HRECOALT			(3)

/***************************************************************************\
*	validateTpgHandle:														*
*		Generic function to validate a pointer obtained from a WISP-style	*
*		handle. Needed by "FindTpgHandle()". For now function checks that	*
*		the memory is writable.												*
*																			*
*	RETURNS:																*
*		TRUE if the pointer passes a minimal validation.					*
\***************************************************************************/

BOOL
validateTpgHandle(void *pPtr, int type)
{
	BOOL	bRet = FALSE;

	switch (type)
	{
		case TPG_HRECOGNIZER:
		{
			if (!IsBadWritePtr(pPtr, sizeof(struct GestureRec)))
			{
				bRet = TRUE;
			}		
			break;
		}
		case TPG_HRECOCONTEXT:
		{
			if (!IsBadWritePtr(pPtr, sizeof(GRC)))
			{
				bRet = TRUE;
			}
			break;
		}
		case TPG_HRECOALT:
		{
			if (!IsBadWritePtr(pPtr, sizeof(GestureAlternate)))
			{
				bRet = TRUE;
			}
			break;
		}
		default:
			break;
	}

	return bRet;
}

/***************************************************************************\
*	GetAltList:																*
*		Generic function that contains the common functionality of			*
*		GetSegmentAlternateList() and GetAlternateList().					*
\***************************************************************************/

HRESULT
GetAltList(GRC *pgrc,
		   RECO_RANGE *pRecoRange,
		   ULONG *pcAlts,
		   HRECOALT *pAlts)
{

    GestureAlternate *pGestAlt;
	UINT index;

    if ( IsBadWritePtr(pcAlts, sizeof(ULONG)) ) 
        return E_POINTER;
	if ( !pgrc->bRecoDone )
		return E_UNEXPECTED;
	if ( pgrc->cAlts <= 0 )
		return TPC_E_NOT_RELEVANT;

    if (pRecoRange)
    {
		if ( IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)) )
		{
			return E_POINTER;
		}
	    // Check the validity of the reco range
		if ( (pRecoRange->cCount != 1) ||
			 (pRecoRange->iwcBegin != 0) )
		{
			return E_INVALIDARG;
		}
	}
 
	// Looking for size only
	if (!pAlts)
	{
		*pcAlts = (ULONG)(pgrc->cAlts);
		return S_OK;
	}

	if (*pcAlts == 0)
		return S_OK;
	if (*pcAlts > (ULONG)(pgrc->cAlts) )
	{
		*pcAlts = (ULONG)(pgrc->cAlts);
	}

    if (IsBadWritePtr(pAlts, *pcAlts * sizeof(HRECOALT)) )
		return E_POINTER;

	for (index = 0; index < *pcAlts; index++)
	{
		pGestAlt = (GestureAlternate *)ExternAlloc(sizeof(GestureAlternate));
		if (!pGestAlt)
		{
			ULONG j;
			for ( j = 0; j < index; j++)
				DestroyAlternate(pAlts[j]);
			return E_OUTOFMEMORY;
		}
		pGestAlt->pgrc = pgrc;
		pGestAlt->wcID = pgrc->answers[index].wcGestID;
		pGestAlt->eScore = pgrc->answers[index].eScore;
		pGestAlt->hotPoint = pgrc->answers[index].hotPoint;
		pAlts[index] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pGestAlt);
		if (0 == pAlts[index])
		{
			ULONG j;
			for ( j = 0; j < index; j++)
				DestroyAlternate(pAlts[j]);
			ExternFree(pGestAlt);
			return E_OUTOFMEMORY;
		}

	}
	return S_OK;
}

/***************************************************************************\
*	Implementation of the Gesture Reco Apis.								*
\***************************************************************************/


/*******************************\
*		IRecognizer				*
\*******************************/

// CreateRecognizer
//      Returns a recognizer handle to the recognizer 
//      corresponding to the passed CLSID. In the case
//      of this dll, we only support one CLSID so we will
//      not even check for the value of the clsid
//      (even if the clsid is null)
//
// Parameter:
//      pCLSID [in] : The pointer to the CLSID 
//                    that determines what recognizer we want
//      phrec [out] : The address of the returned recognizer
//                    handle.
//////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CreateRecognizer(CLSID *pCLSID,
				 HRECOGNIZER *phrec)
{
	struct GestureRec *pgr;
	int i, count;
	DWORD index;

    if ( IsBadReadPtr(pCLSID, sizeof(CLSID)) )
        return E_POINTER;
    if ( IsBadWritePtr(phrec, sizeof(HRECOGNIZER)) )
        return E_POINTER;

    //
	// We only have one CLSID per recognizer so always return an hrec...

    pgr = (struct GestureRec *)ExternAlloc(sizeof(struct GestureRec));
    if (!pgr)
        return E_OUTOFMEMORY;
	ZeroMemory(pgr, sizeof(struct GestureRec));
	for (i = 0; i < MAX_SUPPORTED_GESTURES; i++)
	{
		index = (DWORD) (g_awcSupportedGestures[i] - GESTURE_NULL);
		Set(index, pgr->adwSupportedGestures);
	}

	*phrec = (HRECOGNIZER)CreateTpgHandle(TPG_HRECOGNIZER, pgr);
	if (0 == *phrec)
	{
		ExternFree(pgr);
        return E_OUTOFMEMORY;
	}
	return S_OK;
}


// DestroyRecognizer
//      Destroys a recognizer handle. Free the associate memory
//
// Parameter:
//      hrec [in] : handle to the recognizer
/////////////////////////////////////////////////////////////

HRESULT WINAPI 
DestroyRecognizer(HRECOGNIZER hrec)
{
	struct GestureRec *pgr;

	if ( NULL == (pgr = (struct GestureRec *)DestroyTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER)) )
	{
        return E_POINTER;
	}

    ExternFree(pgr);
    return S_OK;
}



// GetRecoAttributes
//      This function returns the reco attributes corresponding 
//      to a given recognizer. Since we only have one recognizer 
//      type we always return the same things.
//
// Parameters:
//      hrc [in] :         The handle to the recognizer we want the
//                         the attributes for.
//      pRecoAttrs [out] : Address of the user allocated buffer
//                         to hold the reco attributes.
///////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetRecoAttributes(HRECOGNIZER hrec,
				  RECO_ATTRS* pRecoAttrs)
{
    HRESULT                 hr = S_OK;
    HRSRC                   hrsrc = NULL;
    HGLOBAL                 hg = NULL;
    LPBYTE                  pv = NULL;
    WORD                    wCurrentCount = 0;
    WORD                    wRecognizerCount = 0;
    DWORD                   dwRecoCapa;
    WORD                    wLanguageCount;
    WORD                    *aLanguages;
    WORD                    iLang;
    struct WispRec          *pRec;	

    if (IsBadWritePtr(pRecoAttrs, sizeof(RECO_ATTRS))) 
        return E_POINTER;

    ZeroMemory(pRecoAttrs, sizeof(RECO_ATTRS));

    // Update the global structure is necessary
    // Load the recognizer friendly name
    if (0 == LoadStringW(g_hInstanceDll,                            // handle to resource module
                RESID_WISP_FRIENDLYNAME,                            // resource identifier
                pRecoAttrs->awcFriendlyName,                        // resource buffer
                sizeof(pRecoAttrs->awcFriendlyName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    // Load the recognizer vendor name
    if (0 == LoadStringW(g_hInstanceDll,                           // handle to resource module
                RESID_WISP_VENDORNAME,                            // resource identifier
                pRecoAttrs->awcVendorName,                        // resource buffer
                sizeof(pRecoAttrs->awcVendorName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    if (SUCCEEDED(hr))
    {
        // Load the resources
        hrsrc = FindResource(g_hInstanceDll, // module handle
                    (LPCTSTR)RESID_WISP_DATA,  // resource name
                    (LPCTSTR)RT_RCDATA   // resource type
                    );
        if (NULL == hrsrc)
        {
            // The resource is not found!
            ASSERT(NULL != hrsrc);
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        hg = LoadResource(
                g_hInstanceDll, // module handle
                hrsrc   // resource handle
                );
        if (NULL == hg)
        {
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        pv = (LPBYTE)LockResource(
            hg   // handle to resource
            );
        if (NULL == pv)
        {
            hr = E_FAIL;
        }
    }
    dwRecoCapa = *((DWORD*)pv);
    pv += sizeof(dwRecoCapa);
    wLanguageCount = *((WORD*)pv);
    pv += sizeof(wLanguageCount);
    aLanguages = (WORD*)pv;
    pv += wLanguageCount * sizeof(WORD);


    // Fill the reco attricute structure for this recognizer
    // Add the languages
    ASSERT(wLanguageCount < 64);
    for (iLang = 0; iLang < wLanguageCount; iLang++)
    {
        pRecoAttrs->awLanguageId[iLang] = aLanguages[iLang];
    }
    // End the list with a NULL
    pRecoAttrs->awLanguageId[wLanguageCount] = 0;
    // Add the recocapability flag
    pRecoAttrs->dwRecoCapabilityFlags = dwRecoCapa;

    return hr;
}


// CreateContext
//      This function creates a reco context for a given recognizer
//      Since we only have one type of recognizers in this dll, 
//      always return the same kind of reco context.
//
// Parameters:
//      hrec [in] :  Handle to the recognizer we want to create a
//                   reco context for.
//      phrc [out] : Pointer to the returned reco context's handle
////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CreateContext(HRECOGNIZER hrec,
			  HRECOCONTEXT *phrc)
{
	struct GestureRec *pgr;
    GRC *pgrc;
	int j;
    
	if (NULL == (pgr = (struct GestureRec *)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(phrc, sizeof(HRECOCONTEXT)) )
        return E_POINTER;

    pgrc = (GRC *)ExternAlloc( sizeof(GRC) );
    if (!pgrc)
        return E_OUTOFMEMORY;
	pgrc->pdwSupportedGestures = pgr->adwSupportedGestures;
	
#if 0	// Default now is to have all gestures disabled
	for (j = 0; j < MAX_GESTURE_DWORD_COUNT; j++)
		pgrc->adwEnabledGestures[j] = pgr->adwSupportedGestures[j];
#else
	ZeroMemory(pgrc->adwEnabledGestures, MAX_GESTURE_DWORD_COUNT * sizeof(DWORD) );
#endif

	pgrc->lPointsPerInch = POINTS_PER_INCH_DFLT;	// DEFAULT at this point
	pgrc->bIsDirty = FALSE;
	pgrc->bInkDone = FALSE;
	pgrc->bRecoDone = FALSE;
    pgrc->cFrames = 0;
	pgrc->pGlyph = NULL;
	pgrc->cAlts = 0;
	pgrc->pRecoLattice = NULL;
	pgrc->pLatticeData = NULL;

	*phrc = (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pgrc);
	if (0 == *phrc)
	{
		ExternFree(pgrc);
        return E_OUTOFMEMORY;
	}
    return S_OK;
}


// DestroyContext
//      Destroy a reco context and free the associated memory.
//
// Parameters:
//      hrc [in] : handle to the reco context to destroy
//////////////////////////////////////////////////////////////

HRESULT WINAPI
DestroyContext(HRECOCONTEXT hrc)
{
    GRC	*pgrc;

	if ( NULL == (pgrc = (GRC *)DestroyTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

	if (pgrc->pGlyph)
	{
		DestroyFramesGLYPH(pgrc->pGlyph);
		DestroyGLYPH(pgrc->pGlyph);
	}
	if (pgrc->pRecoLattice)
	{
		ExternFree(pgrc->pRecoLattice);
	}
    ExternFree(pgrc);
    return S_OK;
}


//	GetResultPropertyList
//		Return a list of properties supported on the alternates
//		(currently only hot point)
//
//	Parameters:
//		hrec [in]	:				Recognizer handle
//		pPropertyCount [in/out]	:	Number of properties supported
//		pPropertyGuid [out]	:		List of properties supported

static const ULONG RES_PROPERTIES_COUNT = 1;

HRESULT WINAPI
GetResultPropertyList(HRECOGNIZER hrec,
					  ULONG* pPropertyCount,
					  GUID* pPropertyGuid)
{
	//
	// Verify the recognizer handle (not really needed)

	if (NULL == (struct GestureRec *)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER))
	{
        return E_POINTER;
	}
	if ( IsBadWritePtr(pPropertyCount, sizeof(ULONG)) )
		return E_POINTER;

	if (pPropertyGuid == NULL)		// Need only the count
	{
		*pPropertyCount = RES_PROPERTIES_COUNT;
		return S_OK;
	}

	if (*pPropertyCount < RES_PROPERTIES_COUNT)
		return TPC_E_INSUFFICIENT_BUFFER;

	*pPropertyCount = RES_PROPERTIES_COUNT;
	if ( IsBadWritePtr(pPropertyGuid, RES_PROPERTIES_COUNT * sizeof(GUID)) )
		return E_POINTER;
	pPropertyGuid[0] = GUID_HOTPOINT;
	return S_OK;
}


// GetPreferredPacketDescription
//      Returns the preferred packet description for the recognizer
//      This is going to be x, y only for this recognizer
//
// Parameters:
//      hrec [in]                : The recognizer we want the preferred 
//                                 packet description for
//      pPacketDescription [out] : The packet description
/////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetPreferredPacketDescription(HRECOGNIZER hrec,
							  PACKET_DESCRIPTION* pPacketDescription)
{
	//
	// Verify the recognizer handle (not really needed)

	if (NULL == (struct GestureRec *)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER))
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pPacketDescription, sizeof(PACKET_DESCRIPTION)) )
        return E_POINTER;

    //
    // We can be called the first time with pPacketProperies
    // equal to NULL, just to get the size of those buffer
    // The second time we get called thoses buffers are allocated, so 
    // we can fill them with the data.

    if (pPacketDescription->pPacketProperties)
    {
        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2 * sizeof(LONG);
        
        // We are only setting 2 properties (X and Y)
		if (pPacketDescription->cPacketProperties < 2)
			return TPC_E_INSUFFICIENT_BUFFER;
        pPacketDescription->cPacketProperties = 2;
        
        // We are not setting buttons
        pPacketDescription->cButtons = 0;
        
		// Make sure that the pPacketProperties is of a valid size
        if ( IsBadWritePtr(pPacketDescription->pPacketProperties, 2 * sizeof(PACKET_PROPERTY)) )
            return E_POINTER;
        
        // Fill in pPacketProperies
        // Add the GUID_X
        pPacketDescription->pPacketProperties[0].guid = g_guidx;
        pPacketDescription->pPacketProperties[0].PropertyMetrics = g_DefaultPropMetrics;
        
        // Add the GUID_Y
        pPacketDescription->pPacketProperties[1].guid = g_guidy;
        pPacketDescription->pPacketProperties[1].PropertyMetrics = g_DefaultPropMetrics;
    }
    else
    {
        // Just fill in the PacketDescription structure leavin NULL
        // pointers for the pguidButtons and pPacketProperies
        
        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2 * sizeof(LONG);
        
        // We are only setting 2 properties (X and Y)
        pPacketDescription->cPacketProperties = 2;
        
        // We are not setting buttons
        pPacketDescription->cButtons = 0;
        
        // There are not guid buttons
        pPacketDescription->pguidButtons = NULL;
    }
    return S_OK;
}


// GetUnicodeRanges
//		Output ranges of gestures supported by the recognizer
//
// Parameters:
//		hrec [in]			:	Handle to the recognizer
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetUnicodeRanges(HRECOGNIZER hrec,
				 ULONG	*pcRanges,
				 CHARACTER_RANGE *pcr)
{

	struct GestureRec *pgr;
	int index;
	BOOL bPreviousOn;

	if (NULL == (pgr = (struct GestureRec *)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pcRanges, sizeof(ULONG)) )
        return E_POINTER;

	if (!pcr)	// Need only a count of ranges
	{
		*pcRanges = CountRanges(pgr->adwSupportedGestures);
		return S_OK;
	}
	
	if ( IsBadWritePtr(pcr, *pcRanges * sizeof(CHARACTER_RANGE)) )
		return E_POINTER;

	return GetRanges(pgr->adwSupportedGestures, pcRanges, pcr);
}




/*******************************\
*		IRecoContext			*
\*******************************/

// GetEnabledUnicodeRanges
//		Output ranges of gestures enabled in this recognition context
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetEnabledUnicodeRanges(HRECOCONTEXT hrc,
						ULONG	*pcRanges,
						CHARACTER_RANGE *pcr)
{
	GRC *pgrc;

	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pgrc, sizeof(GRC)) )
		return E_POINTER;
    if ( IsBadWritePtr(pcRanges, sizeof(ULONG)) )
        return E_POINTER;

	if (!pcr)	// Need only a count of ranges
	{
		*pcRanges = CountRanges(pgrc->adwEnabledGestures);
		return S_OK;
	}
	
	if ( IsBadWritePtr(pcr, *pcRanges * sizeof(CHARACTER_RANGE)) )
		return E_POINTER;

	return GetRanges(pgrc->adwEnabledGestures, pcRanges, pcr);
}


// SetEnabledUnicodeRanges
//		Set ranges of gestures enabled in this recognition context
//		The behavior of this function is the following:
//			(a) (A part of) One of the requested ranges lies outside
//				gesture interval---currently  [GESTURE_NULL, GESTURE_NULL + 255)
//				return E_UNEXPECTED and keep the previously set ranges
//			(b) All requested ranges are within the gesture interval but
//				some of them are not supported:
//				return S_TRUNCATED and set those requested gestures that are
//				supported (possibly an empty set)
//			(c) All requested gestures are supported
//				return S_OK and set all requested gestures.
//		Note:  An easy way to set all supported gestures as enabled is to use
//				SetEnabledUnicodeRanges() with one range=(GESTURE_NULL,255).
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [in]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
SetEnabledUnicodeRanges(HRECOCONTEXT hrc,
						ULONG	cRanges,
						CHARACTER_RANGE *pcr)
{
	GRC *pgrc;
	int index, i;
	ULONG ulRange;
	HRESULT hres = S_OK;

	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pcr, cRanges * sizeof(CHARACTER_RANGE)) )
		return E_POINTER;

	for (ulRange = 0; ulRange < cRanges; ulRange++)
	{
		if (pcr[ulRange].wcLow < GESTURE_NULL)
			return E_INVALIDARG;
		if (pcr[ulRange].wcLow + pcr[ulRange].cChars > GESTURE_NULL + MAX_GESTURE_COUNT)
			return E_INVALIDARG;
	}
	//
	// Zero out enabled gestures

	ZeroMemory(pgrc->adwEnabledGestures, MAX_GESTURE_DWORD_COUNT * sizeof(DWORD));

	//
	// Set new enabled list

	for (ulRange = 0; ulRange < cRanges; ulRange++)
	{
		for (i = pcr[ulRange].cChars - 1; i >= 0; i--)
		{
			index = pcr[ulRange].wcLow - GESTURE_NULL + i;
			if ( IsSet(index, pgrc->pdwSupportedGestures) )
			{
				Set(index, pgrc->adwEnabledGestures);
			}
			else
			{
				hres = TPC_S_TRUNCATED;
			}
		}
	}
	return hres;
}

//	GetContextPropertyList
//		Return a list of properties supported on the context
//		(currently only max-stroke-count and points-per-inch)
//
//	Parameters:
//		hrc [in]	:				Handle to the recognition context
//		pcProperties [in/out]	:	Number of properties supported
//		pPropertyGUIDS [out]	:	List of properties supported

static const ULONG CONTEXT_PROPERTIES_COUNT = 1;

HRESULT WINAPI
GetContextPropertyList(HRECOCONTEXT hrc,
					   ULONG* pcProperties,
					   GUID* pPropertyGUIDS)
{
	if (NULL == (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT) )
	{
        return E_POINTER;
	}
	if ( IsBadWritePtr(pcProperties, sizeof(ULONG)) )
		return E_POINTER;
	if (pPropertyGUIDS == NULL)		// Need only the count
	{
		*pcProperties = CONTEXT_PROPERTIES_COUNT;
		return S_OK;
	}

	if (*pcProperties < CONTEXT_PROPERTIES_COUNT)
		return TPC_E_INSUFFICIENT_BUFFER;

	*pcProperties = CONTEXT_PROPERTIES_COUNT;
	if ( IsBadWritePtr(pPropertyGUIDS, CONTEXT_PROPERTIES_COUNT * sizeof(GUID)) )
		return E_POINTER;

	pPropertyGUIDS[0] = GUID_MAX_STROKE_COUNT;
//	pPropertyGUIDS[1] = GUID_POINTS_PER_INCH;
	return S_OK;
}

		
//	GetContextPropertyValue
//		Return a property of the context
//
//	Parameters:
//		hrc [in] :			Handle to the recognition context
//		pGuid [in]	:		Property GUID
//		pcbSize [in/out] :	Size of the property buffer (in BYTEs)
//		pProperty [out]  :	Value of the desired property

HRESULT WINAPI
GetContextPropertyValue(HRECOCONTEXT hrc,
						GUID *pGuid,
						ULONG *pcbSize,
						BYTE *pProperty)
{
    GRC	*pgrc;

	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pGuid, sizeof(GUID)) )
		return E_POINTER;
	if ( IsBadWritePtr(pcbSize, sizeof(ULONG)) )
		return E_POINTER;

	if (pProperty == NULL)		// Need only the size
	{
		if ( IsEqualGUID(pGuid, &GUID_MAX_STROKE_COUNT) )
		{
			*pcbSize = sizeof(LONG);
			return S_OK;
		}
		return TPC_E_INVALID_PROPERTY;
	}

	if ( IsEqualGUID(pGuid, &GUID_MAX_STROKE_COUNT) )
	{
		LONG *pcMaxStrokes = (LONG *)pProperty;
		if ( *pcbSize < sizeof(LONG) )
			return TPC_E_INSUFFICIENT_BUFFER;
		*pcbSize = sizeof(LONG);
		if ( IsBadWritePtr(pcMaxStrokes, sizeof(LONG)) )
			return E_POINTER;

		*pcMaxStrokes = GetMaxStrokeCount(pgrc->adwEnabledGestures);
		return S_OK;
	}
	/*	No longer valid
	if ( IsEqualGUID(pGuid, &GUID_POINTS_PER_INCH) )
	{
		LONG *plPointsPerInch = (LONG *)pProperty;
		if ( *pcbSize < sizeof(LONG) )
			return TPC_E_INSUFFICIENT_BUFFER;
		*pcbSize = sizeof(LONG);
		if ( IsBadWritePtr(plPointsPerInch, sizeof(LONG)) )
			return E_POINTER;

//		if (pgrc->lPointsPerInch <= 0)			// Property not set
//			return TPC_E_UNINITIALIZED_PROPERTY;
		*plPointsPerInch = pgrc->lPointsPerInch;
		return S_OK;
	}
	*/
	return TPC_E_INVALID_PROPERTY;
}


//	SetContextPropertyValue
//		Set a property of the context  (currently only POINTS_PER_INCH)
//
//	Parameters:
//		hrc [in] :			Handle to the recognition context
//		pGuid [in]	:		Property GUID
//		pcbSize [in] :		Size of the property buffer (in BYTEs)
//		pProperty [in]  :	Value of the desired property

HRESULT WINAPI
SetContextPropertyValue(HRECOCONTEXT hrc,
						GUID *pGuid,
						ULONG cbSize,
						BYTE *pProperty)
{
    GRC	*pgrc;

	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pGuid, sizeof(GUID)) )
		return E_POINTER;
	/*
	if ( IsEqualGUID(pGuid, &GUID_POINTS_PER_INCH) )
	{
		LONG *plPointsPerInch;
		if ( cbSize != sizeof(LONG) )
			return E_INVALIDARG;
		plPointsPerInch = (LONG *)pProperty;
		if ( IsBadReadPtr(plPointsPerInch, sizeof(LONG)) )
			return E_POINTER;

		pgrc->lPointsPerInch = *plPointsPerInch;
		return S_OK;
	}
	*/
	return TPC_E_INVALID_PROPERTY;
}


/**********************************************************************/
// Convert double to int
#define FUZZ_GEN	(1e-9)		// general fuzz - nine decimal digits
int RealToInt(
	double dbl
	){
	/* Add in the rounding threshold.  
	 *
	 * NOTE: The MAXWORD bias used in the floor function
	 * below must not be combined with this line. If it
	 * is combined the effect of FUZZ_GEN will be lost.
	 */
	dbl += 0.5 + FUZZ_GEN;
	
	/* Truncate
	 *
	 * The UINT_MAX bias in the floor function will cause
	 * truncation (rounding toward minus infinity) within
	 * the range of a short.
	 */
	dbl = floor(dbl + UINT_MAX) - UINT_MAX;
	
	/* Clip the result.
	 */
	return 	dbl > INT_MAX - 7 ? INT_MAX - 7 :
			dbl < INT_MIN + 7 ? INT_MIN + 7 :
			(int)dbl;
	}
/**********************************************************************/
// Transform POINT array in place
void Transform(const XFORM *pXf, POINT * pPoints, ULONG cPoints)
{
    ULONG iPoint = 0;
    LONG xp = 0;

    if(NULL != pXf)
    {
        for(iPoint = 0; iPoint < cPoints; ++iPoint)
        {
	        xp =  RealToInt(pPoints[iPoint].x * pXf->eM11 + pPoints[iPoint].y * pXf->eM21 + pXf->eDx);
	        pPoints[iPoint].y = RealToInt(pPoints[iPoint].x * pXf->eM12 + pPoints[iPoint].y * pXf->eM22 + pXf->eDy);
	        pPoints[iPoint].x = xp;
        }
    }
}

// AddStroke
//      Add additional stroke (frame) to gesture recognition context
//
// Parameters:
//      hrc [in/out]			: Handle to the recognition context
//      pPacketDesc [in]		: Description of the contents of packets
//									(if NULL, use the preferred packet description,
//									 i.e. only long X and long Y are sent)
//		cbPacket [in]			: Size (in BYTEs) of the pPacket buffer
//		pPacket [in]			: Array of packets
/////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
AddStroke(HRECOCONTEXT hrc,
		  const PACKET_DESCRIPTION *pPacketDesc,
		  ULONG cbPacket,						// I: Size of packet array (in BYTEs)
		  const BYTE *pPacket,					// I: Array of packets
          const XFORM *pXForm)                  // I: Transform to apply to each point
{
    ULONG			ulPointCount;
//    ULONG			ulTotalPointCount;
	ULONG			ulPacketSize;		// Size of one packet (in LONGs)
    STROKEINFO		stInfo;
    ULONG			ulIndex, ulXIndex, ulYIndex;
    BOOL			bXFound, bYFound;
	XY				*rgXY;
	FRAME			*frame;
	float			fResolution;	// Resolution of the digitizer
	PROPERTY_UNITS	units;		// Units of the digitizer  (PROPERTY_UNITS_INCHES, PROPERTY_UNITS_CENTIMETERS)
	LONG			lPPI;		// Points per inch
	const XFORM		xfIdentity = {1.0, 0.0, 0.0, 1.0, 0.0, 0.0};
	const XFORM		*pValidXForm;

    GRC			*pgrc;
    const LONG	*pLongs = (const LONG *)pPacket;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    if ( IsBadReadPtr(pPacket, cbPacket) )
        return E_POINTER;

	if (pgrc->bInkDone == TRUE)		// If ink has been recognized before
		return E_FAIL;				// (or there is no ink)
    
	if (pXForm == NULL)				// If no transform specified, use identity.
	{
		pValidXForm = &xfIdentity;
	}
	else
	{
		if ( IsBadReadPtr(pXForm, sizeof(XFORM)) )
			return E_POINTER;
		pValidXForm = pXForm;
	}
		
	//
    // Get the number of packets

    if (pPacketDesc)
    {
		if ( IsBadReadPtr(pPacketDesc, sizeof(PACKET_DESCRIPTION)) )
			return E_POINTER;
		if ( pPacketDesc->cbPacketSize == 0 )
			return TPC_E_INVALID_PACKET_DESCRIPTION;
		ASSERT( pPacketDesc->cbPacketSize % sizeof(LONG) == 0 );
        ASSERT( cbPacket % pPacketDesc->cbPacketSize == 0 );
		ulPacketSize = pPacketDesc->cbPacketSize / sizeof(LONG);
        ulPointCount = cbPacket / pPacketDesc->cbPacketSize;
    }
    else  // Preferred packet description
    {
        ASSERT( cbPacket % (2 * sizeof(LONG)) == 0 );
		ulPacketSize = 2;
        ulPointCount = cbPacket / (2 * sizeof(LONG));
    }

    if (ulPointCount == 0)			// Don't add strokes with 0 points
		return E_INVALIDARG;

	//
    // Fill in the stroke info stucture

    stInfo.cPnt = ulPointCount;
    stInfo.dwTick = pgrc->cFrames * 60 * 1000;
    stInfo.wPdk = 0x0001;
    stInfo.cbPnts = ulPointCount * sizeof(POINT);

	//
    // Find the index of GUID_X and GUID_Y

    if (pPacketDesc)
    {
		bXFound = bYFound = FALSE;
        for (ulIndex = 0; ulIndex < pPacketDesc->cPacketProperties; ulIndex++)
        {
            if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulIndex].guid), &g_guidx))
            {
                bXFound = TRUE;
                ulXIndex = ulIndex;
            }
            else if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulIndex].guid), &g_guidy))
            {
                bYFound = TRUE;
                ulYIndex = ulIndex;
            }
            if (bXFound && bYFound) 
                break;
        }
        if (!bXFound || !bYFound)				// X- or Y-coordinates are
        {										// not part of the packet!
            return TPC_E_INVALID_PACKET_DESCRIPTION;
        }
	}
	else	// Preferred packet description
	{
		ulXIndex = 0;
		ulYIndex = 1;
	}


	//
	// Compute the resolution of the device in points per inch (might switch to 1dm = 0.1m = 100mm)

    if (pPacketDesc)
    {
		fResolution = pPacketDesc->pPacketProperties[ulXIndex].PropertyMetrics.fResolution;
		units = pPacketDesc->pPacketProperties[ulXIndex].PropertyMetrics.Units;
		if (units == PROPERTY_UNITS_INCHES)
		{
			lPPI = (LONG)fResolution;
		}
		else if (units == PROPERTY_UNITS_CENTIMETERS)
		{
			lPPI = (LONG)(fResolution * 2.54);
		}
		else
		{
			return TPC_E_INVALID_PACKET_DESCRIPTION;
		}
		if (lPPI <= 0)
		{
			return TPC_E_INVALID_PACKET_DESCRIPTION;
		}
	}
	else
	{
		lPPI = POINTS_PER_INCH_DFLT;	// Use DEFAULT PPI!!!
	}

	//
	// Allocate space for array of points

	rgXY = (XY *)ExternAlloc(ulPointCount * sizeof(XY));
	if (!rgXY)
	{
		return E_OUTOFMEMORY;
	}

	// make new frame
	if ( !(frame = NewFRAME()) )
	{
		ExternFree(rgXY);
		return E_OUTOFMEMORY;
	}
	RgrawxyFRAME(frame) = rgXY;


	//
	// Check if transform and PPI make sense (for 2+ strokes) or 
	// save the transform & PPI (for first stroke)

	if ( pgrc->bIsDirty )		// Second stroke (or more)
	{
		if ( (lPPI != pgrc->lPointsPerInch) ||			// Something's wrong with the resolution
			 (memcmp(pValidXForm, &(pgrc->xform), sizeof(XFORM)) ) )	// Different transformation
		{
			pgrc->bInkDone = TRUE;
			return E_FAIL;
		}
	}
	else
	{
		pgrc->lPointsPerInch = lPPI;
		pgrc->xform = *pValidXForm;
		pgrc->bIsDirty = TRUE;
	}

	
	
	if (!pgrc->pGlyph)				// If first stroke
		pgrc->pGlyph = NewGLYPH();	// create new glyph

	if ( ( !pgrc->pGlyph ) ||
		 ( !AddFrameGLYPH(pgrc->pGlyph, frame) ) )
	{
		pgrc->bInkDone = TRUE;
		DestroyFRAME(frame);  // This also takes care of rgXY
		return E_OUTOFMEMORY;
	}

	frame->info = stInfo;
	frame->iframe = pgrc->cFrames;
    pgrc->cFrames++;

	//        ulTotalPointCount = ulPointCount;   // Need for the transform

	//
	// Copy X- and Y-coordinates from packet array to frame

	for ( ; ulPointCount > 0; ulPointCount--)
	{
		rgXY->x = *(pLongs+ulXIndex);
		rgXY->y = *(pLongs+ulYIndex);
		rgXY++;
		pLongs += ulPacketSize;
	}

    // TO DO, for now I transform the points so they
    // they are in the ink coordinates. It is up to
    // the recognizer team to decide what they should
    // use: raw ink or transformed ink
    // Transform(pXForm, RgrawxyFRAME(frame), ulTotalPointCount);

    return S_OK;
}


//	GetBestResultString
//		Get the best result string.
//		In the case of gestures, the string has length 1
//		(1 WCHARs = 2 BYTEs) and contains the gesture ID.
//
//		If pszBestResult is NULL, pcSize is set to the number of
//		WCHARs needed to store the result.
//
//	Parameters:
//		hrc [in]:			Handle to the reco context
//		pcSize [in/out]:	Size of the best string
//		pwcBestResult[out]:	Best string

HRESULT WINAPI
GetBestResultString(HRECOCONTEXT hrc,
					ULONG *pcSize, 
					WCHAR* pwcBestResult)
{
    GRC	*pgrc;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pcSize, sizeof(ULONG)) )
        return E_POINTER;
	if ( !pgrc->bRecoDone )
		return E_UNEXPECTED;
    if ( pgrc->cAlts <= 0 )
		return TPC_E_NOT_RELEVANT;

    if (!pwcBestResult)			// If looking for size only
    {
        *pcSize = 1;
        return S_OK;
    }

	if (*pcSize == 0)
		return TPC_S_TRUNCATED;    
	*pcSize = 1;
	if ( IsBadWritePtr(pwcBestResult, *pcSize * sizeof (WCHAR)) )
		return E_POINTER;

	pwcBestResult[0] = pgrc->answers[0].wcGestID;

    return S_OK;
}

// This recognizer is always in FreeInput mode.  Attempts to set it to another mode result in E_INVALIDARG

HRESULT WINAPI
SetGuide(HRECOCONTEXT hrc,
		 const RECO_GUIDE* pGuide,
		 ULONG iIndex)
{
	if (!pGuide)
		return S_OK;
	else
	{
		if (IsBadReadPtr(pGuide, sizeof(RECO_GUIDE))) 
			return E_POINTER;
		else if ((pGuide->cHorzBox == 0) && (pGuide->cVertBox == 0))
			return S_OK;
		else
			return E_INVALIDARG;
	}
}

// We are always in FreeInput mode

HRESULT WINAPI
GetGuide(HRECOCONTEXT hrc,
		 RECO_GUIDE* pGuide,
		 ULONG *piIndex)
{
    if (IsBadWritePtr(pGuide, sizeof(RECO_GUIDE))) 
        return E_POINTER;
    if (IsBadWritePtr(piIndex, sizeof(ULONG))) 
        return E_POINTER;

    ZeroMemory(pGuide, sizeof(RECO_GUIDE));
	*piIndex = 0;

	return S_FALSE;
}

HRESULT WINAPI
AdviseInkChange(HRECOCONTEXT hrc,
				BOOL bNewStroke)
{
    return S_OK;
}

HRESULT WINAPI
SetCACMode(HRECOCONTEXT hrc, int iMode)
{
    return E_NOTIMPL;
}

HRESULT WINAPI
EndInkInput(HRECOCONTEXT hrc)
{
    GRC	*pgrc;

	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

	pgrc->bInkDone = TRUE;

	return S_OK;
}


//	CloneContext
//		Create a new gesture recognition context that contains the
//		same settings as the original, but does not include the ink
//		or recognition results.
//
//	Parameters:
//		hrc [in]:		Original gesture recognition context
//		pCloneHrc[out]:	New (cloned) gesture reco context
////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc)
{
    GRC	*pgrcCloned;
    GRC	*pgrc;
	int j;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pCloneHrc, sizeof(HRECOCONTEXT))) 
        return E_POINTER;
    
    pgrcCloned = (GRC*)ExternAlloc(sizeof(GRC));
    if (!pgrcCloned) 
        return E_OUTOFMEMORY;
    
	pgrcCloned->pdwSupportedGestures = pgrc->pdwSupportedGestures;
	for (j = 0; j < MAX_GESTURE_DWORD_COUNT; j++)
		pgrcCloned->adwEnabledGestures[j] = pgrc->adwEnabledGestures[j];
	pgrcCloned->lPointsPerInch = POINTS_PER_INCH_DFLT;
	pgrcCloned->bIsDirty = FALSE;
	pgrcCloned->bInkDone = FALSE;
	pgrcCloned->bRecoDone = FALSE;
    pgrcCloned->cFrames = 0;
	pgrcCloned->pGlyph = NULL;
	pgrcCloned->cAlts = 0;
	pgrcCloned->pRecoLattice = NULL;
	pgrcCloned->pLatticeData = NULL;

	*pCloneHrc = (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pgrcCloned);
	if (0 == *pCloneHrc)
	{
		ExternFree(pCloneHrc);
        return E_OUTOFMEMORY;
	}
    return S_OK;
}


//	ResetContext:
//		Delete current ink and recognition results from the context. 
//
//	Parameters:
//		hrc [in]:	Handle to gesture recognition context
////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
ResetContext(HRECOCONTEXT hrc)
{
    GRC	*pgrc;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    
	if (pgrc->pGlyph)
	{
		DestroyFramesGLYPH(pgrc->pGlyph);
		DestroyGLYPH(pgrc->pGlyph);
	}

	pgrc->lPointsPerInch = POINTS_PER_INCH_DFLT;	// DEFAULT at this point
	pgrc->bIsDirty = FALSE;
	pgrc->bInkDone = FALSE;
	pgrc->bRecoDone = FALSE;
    pgrc->cFrames = 0;
	pgrc->pGlyph = NULL;
	pgrc->cAlts = 0;
	if (pgrc->pRecoLattice)
	{
		ExternFree(pgrc->pRecoLattice);
	}
	pgrc->pRecoLattice = NULL;
	pgrc->pLatticeData = NULL;

    return S_OK;
}



HRESULT WINAPI 
SetTextContext(HRECOCONTEXT hrc, ULONG cBefore, const WCHAR*pszBefore, ULONG cAfter, const WCHAR*pszAfter)
{
    return E_NOTIMPL;
}


//	Process
//		Recognize ink (synchronously)
//
//	Parameters:
//		hrc	[in]:					Handle to the reco context
//		pbPartialProcessing [out]:	Flag for partial processing

HRESULT WINAPI
Process(HRECOCONTEXT hrc,
		BOOL *pbPartialProcessing)
{
    GRC		*pgrc;
	int		cAlts, i;
	RECT	rect;
	LONG	lPtsPerInch;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pbPartialProcessing, sizeof(BOOL)) )
        return E_POINTER;
    
    if ( !pgrc->bInkDone )	// No partial reco
        return S_FALSE;
    if ( pgrc->bRecoDone )	// No need to redo recognition
        return S_FALSE;
    
    *pbPartialProcessing = FALSE;

    if (!pgrc->pGlyph)			// There is no ink
        return S_OK;

	lPtsPerInch = pgrc->lPointsPerInch;

    pgrc->bIsDirty = FALSE;
	pgrc->bRecoDone = TRUE;

	//
	// Do the recognition

	//	GetRectGLYPH(pgrc->pGlyph, &rect); (for debugging)
	cAlts = TwisterReco(pgrc->answers, MAX_GESTURE_ALTS, pgrc->pGlyph,
						pgrc->adwEnabledGestures, lPtsPerInch);

	if (cAlts <= 0)
	    return E_UNEXPECTED;

	for (i = 0; i < cAlts; i++)
	{
		if (pgrc->answers[i].hotPoint.x != LONG_MIN)		// Hot point have
		{													// been computed
			Transform(&pgrc->xform, &(pgrc->answers[i].hotPoint), 1);
		}
	}

	pgrc->cAlts = cAlts;
    return S_OK;
}



HRESULT WINAPI
GetGuideIndex(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *piIndex)
{
	return TPC_E_NOT_RELEVANT;
}


//	GetPropertyRanges
//		Return an array of ranges of different values for a given property
//		so far only HOT_POINT is supported, and only for the whole range
//
//	Parameters:
//		hrcalt [in]	:			Handle to the alternate structure
//		pPropertyGuid [in]	:	Pointer to property GUID
//		pcRanges [in/out]   :	Count of RECO_RANGEs
//		pRecoRange [out]	:	Array of RECO_RANGEs to be filled in

HRESULT WINAPI
GetPropertyRanges(HRECOALT hrcalt,
				  const GUID *pPropertyGuid,
				  ULONG *pcRanges,
				  RECO_RANGE *pRecoRange)
{
    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
        return E_POINTER;

    if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
        return E_POINTER;

    if (!IsEqualGUID(pPropertyGuid, &GUID_HOTPOINT))
		return TPC_E_INVALID_PROPERTY;

	if (pRecoRange)
	{
		if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
			return E_POINTER;

        if (*pcRanges < 1)
            return TPC_E_INSUFFICIENT_BUFFER;

		pRecoRange->iwcBegin = 0;
		pRecoRange->cCount = 1;
		*pcRanges = 1;
	}
	else
	{
		*pcRanges = 1;
	}

	return S_OK;
}

//	GetRangePropertyValue
//		Return given property (so far only HOT_POINT is supported)
//
//	Parameters:
//		hrcalt [in]	:			Handle to the alternate structure
//		pPropertyGuid [in]	:	Pointer to property GUID
//		pRecoRange [in/out]	:	Pointer to a RECO_RANGE to be filled
//								with the range that was asked when the alternate was created
//		pcbSize [in/out]	:	Number of BYTEs needed to return this property
//		pProperty [out]	:		If NULL, return # of bytes needed, if not NULL,
//								return the HOT POINT


HRESULT WINAPI
GetRangePropertyValue(HRECOALT hrcalt,
					  const GUID *pPropertyGuid,
					  RECO_RANGE *pRecoRange,
					  ULONG *pcbSize,
					  BYTE *pProperty)
{
    GestureAlternate 	*pGestAlt;
    POINT* pHotPoint = (POINT *)pProperty;

	if (NULL == (pGestAlt = (GestureAlternate *)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}
    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
        return E_POINTER;
    if ( IsBadWritePtr(pcbSize, sizeof(ULONG)) )
        return E_POINTER;

	if (pRecoRange)		// If query range is provided
	{
		if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
			return E_POINTER;
		if (pRecoRange->iwcBegin != 0)
			return E_INVALIDARG;
		if (pRecoRange->cCount != 1)
			return E_INVALIDARG;
	}

    if ( !IsEqualGUID(pPropertyGuid, &GUID_HOTPOINT) )
		return TPC_E_INVALID_PROPERTY;

	if (pHotPoint == NULL)
	{
		// We just want the size
		*pcbSize = sizeof(POINT);
		return S_OK;
	}

	if ( *pcbSize < sizeof(POINT) )
		return TPC_E_INSUFFICIENT_BUFFER;
    
	*pcbSize = sizeof(POINT);
	if ( IsBadWritePtr(pHotPoint, sizeof(POINT)) )
		return E_POINTER;

	if (pGestAlt->hotPoint.x == LONG_MIN)		// If hot point not yet computed
	{
		pGestAlt->hotPoint = GetHotPoint(pGestAlt->wcID, pGestAlt->pgrc->pGlyph);
		Transform(&pGestAlt->pgrc->xform, &pGestAlt->hotPoint, 1);
	}
	*pHotPoint = pGestAlt->hotPoint;
    return S_OK;
}

HRESULT WINAPI
SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR* pwcFactoid)
{
	return E_NOTIMPL;
}

HRESULT WINAPI
SetFlags(HRECOCONTEXT hrc, DWORD dwFlags)
{
	return E_NOTIMPL;
}


HRESULT WINAPI
GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice)
{
	GRC	*pgrc;
	RECO_LATTICE *pRL;
	LATTICE_DATA *pLD;
	RECO_LATTICE_ELEMENT *pRLE;
	GEST_ALTERNATE *pGA;

	int i;

	// Test the parameters.
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
	if (IsBadWritePtr(ppLattice, sizeof(RECO_LATTICE*))) 
		return E_POINTER;
	if (!pgrc->bRecoDone)
		return E_UNEXPECTED;

	if (pgrc->pRecoLattice)		// Lattice has been allocated, which also means
	{							// that it has been filled with the current results
		ASSERT(pgrc->pLatticeData);
		ASSERT(pgrc->pLatticeData->pulStrokes);

		*ppLattice = pgrc->pRecoLattice;
		return S_OK;
	}

	//
	// Lattice not allocated (typical)

	ASSERT(pgrc->pLatticeData == NULL);  // Data also not allocated
		
	pRL =  (RECO_LATTICE *)ExternAlloc(sizeof(RECO_LATTICE) + sizeof(LATTICE_DATA) +
										pgrc->cFrames * sizeof(ULONG) );
	if (!pRL)
	{
		return E_OUTOFMEMORY;
	}

	ZeroMemory(pRL, sizeof(RECO_LATTICE) + sizeof(LATTICE_DATA));

	pgrc->pRecoLattice = pRL;
	pgrc->pLatticeData = pLD = (LATTICE_DATA*)(pRL + 1);

	//
	// Fill in RECO_LATTICE
	
	pRL->ulColumnCount = 1;
	pRL->pLatticeColumns = &(pLD->rlc);
	pRL->ulPropertyCount = 1;
	pRL->pGuidProperties = pLD->aGuidProperties;
	pRL->ulBestResultColumnCount = 1;
	pRL->pulBestResultColumns = pLD->aulResultColumns;
	pRL->pulBestResultIndexes = pLD->aulResultIndices;

	pLD->aGuidProperties[0] = GUID_HOTPOINT;
	pLD->aulResultColumns[0] = 0;
	pLD->aulResultIndices[0] = 0;

	//
	// Fill in RECO_LATTICE_COLUMN

	pLD->rlc.key = 0;
	pLD->rlc.cpProp.cProperties = 0;
	pLD->rlc.cpProp.apProps = (RECO_LATTICE_PROPERTY **) NULL;
	pLD->rlc.cStrokes = pgrc->cFrames;				// Depends on the ink!
	pLD->pulStrokes = (ULONG *)(pLD + 1);			// Depends on the ink!
	pLD->rlc.pStrokes = pLD->pulStrokes;
	for (i = 0; i < pgrc->cFrames; i++)
	{
		pLD->pulStrokes[i] = i;
	}
	pLD->rlc.cLatticeElements = pgrc->cAlts;		// Depends on the ink!
	pLD->rlc.pLatticeElements = pLD->aRLElements;

	//
	// Fill in array of RECO_LATTICE_ELEMENTs

	for (i = 0, pRLE = pLD->aRLElements, pGA = pgrc->answers;
		 i < pgrc->cAlts;
		 i++, pRLE++, pGA++)
	{
		pRLE->score = i;
		pRLE->type = RECO_TYPE_WCHAR;
		pRLE->pData = (BYTE *)pGA->wcGestID;		// Depends on the ink!
		pRLE->ulNextColumn = 1;
		pRLE->ulStrokeNumber = pgrc->cFrames;
		pRLE->epProp.cProperties = 1;
		pRLE->epProp.apProps = pLD->apRLPs + i;
		pRLE->epProp.apProps[0] = pLD->aRLPs + i;
		pLD->aRLPs[i].guidProperty = GUID_HOTPOINT;
		pLD->aRLPs[i].cbPropertyValue = sizeof(POINT);
		if (pGA->hotPoint.x == LONG_MIN)	// If hot point not computed
		{
			pGA->hotPoint = GetHotPoint(pGA->wcGestID, pgrc->pGlyph);
			Transform(&pgrc->xform, &pGA->hotPoint, 1);

		}
		pLD->aRLPs[i].pPropertyValue = (BYTE *) &(pGA->hotPoint);
	}

	*ppLattice = pRL;
	return S_OK;
}


// DestroyAlternate
//
// This function destroys an alternate, freeing the allocated memory
//
// Parameters:
//		hrcalt [in] : handle of the alternate to be destroyed
/////////////////

HRESULT WINAPI
DestroyAlternate(HRECOALT hrcalt)
{
    GestureAlternate	*pGestAlt;

	if (NULL == (pGestAlt = (GestureAlternate *)DestroyTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}

	ExternFree(pGestAlt);
    return S_OK;
}


// GetBestAlternate
//
// This function creates the best alternate from the best segmentation
//
// Parameters:
//		hrc [in] :		the reco context
//		pHrcAlt [out] : pointer to the handle of the alternate
/////////////////

HRESULT WINAPI
GetBestAlternate(HRECOCONTEXT hrc,
				 HRECOALT *pHrcAlt)
{
    GestureAlternate	*pGestAlt;
    GRC					*pgrc;
    
    // Check the parameters
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pHrcAlt, sizeof(HRECOALT)) )
        return E_POINTER;
	if ( !pgrc->bRecoDone )
		return E_UNEXPECTED;
    if ( pgrc->cAlts <= 0 )
		return TPC_E_NOT_RELEVANT;

    // Create the alternate
    pGestAlt = (GestureAlternate *)ExternAlloc(sizeof(GestureAlternate));
    if (!pGestAlt)
        return E_OUTOFMEMORY;
    ZeroMemory(pGestAlt, sizeof(GestureAlternate));
    
    // Initialize the alternate with a pointer to the grc
    pGestAlt->pgrc = pgrc;

	// Set the ID and score of the best answer
    pGestAlt->wcID = pgrc->answers[0].wcGestID;
	pGestAlt->eScore = pgrc->answers[0].eScore;
	pGestAlt->hotPoint = pgrc->answers[0].hotPoint;
    
    // Return the alternate
	*pHrcAlt = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pGestAlt);
	if (0 == *pHrcAlt)
	{
		ExternFree(pGestAlt);
        return E_OUTOFMEMORY;
	}
    return S_OK;
}


// GetString
//
// This function returns the string corresponding to the given alternate
//
// Parameters:
//		hrcalt [in] :		the handle to the alternate
//		pRecoRange [out] :	pointer to a RECO_RANGE that will be filled with
//							the range that was asked when the alternate was created
//		pcSize [in, out] :	The size of the string (or the size of the provided buffer)
//		szString [out] :	If NULL we return the character count in *pcSize, if not this is a
//							string of size *pcSize where we copy the alternate string (no ending \0)
/////////////////

HRESULT WINAPI
GetString(HRECOALT hrcalt,
		  RECO_RANGE *pRecoRange,
		  ULONG* pcSize,
		  WCHAR* pwcString)
{
    GestureAlternate *pGestAlt;
    
	if (NULL == (pGestAlt = (GestureAlternate *)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}
    if ( IsBadWritePtr(pcSize, sizeof(ULONG)) )
        return E_POINTER;

	if (pRecoRange)		// If query range is requested
	{
		if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
			return E_POINTER;
		pRecoRange->iwcBegin = 0;
		pRecoRange->cCount = 1;
	}

    if (!pwcString)			// If looking for size only
    {
        *pcSize = 1;
        return S_OK;
    }

	if (*pcSize == 0)
		return TPC_S_TRUNCATED;    
	*pcSize = 1;
	if ( IsBadWritePtr(pwcString, sizeof(WCHAR)) )
		return E_POINTER;

	pwcString[0] = pGestAlt->wcID;

    return S_OK;
}


// GetStrokeRanges
//
// This function returns the stroke ranges in the ink corresponding 
// to the selected range within the alternate
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the stroke ranges for, it comes back with the real REC_RANGE
//								used to get the stroke ranges.
//		pcRanges [in, out] :	The number of STROKE_RANGES (or the number of it in the provided buffer)
//		pStrokeRanges [out] :	If NULL we return the number in *pcRanges, if not this is an
//								array of size *pcRanges where we copy the stroke ranges
/////////////////
HRESULT WINAPI
GetStrokeRanges(HRECOALT hrcalt,
				RECO_RANGE* pRecoRange,
				ULONG* pcRanges,
				STROKE_RANGE* pStrokeRange)
{
    GestureAlternate *pGestAlt;

	if (NULL == (pGestAlt = (GestureAlternate *)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}

	if (IsBadReadPtr(pRecoRange, sizeof(RECO_RANGE)))
        return E_POINTER;

	if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
        return E_POINTER;

	// Check the validity of the reco range
	if ((pRecoRange->cCount != 1) ||
		(pRecoRange->iwcBegin != 0))
	{
		return E_INVALIDARG;
	}

	if (!pStrokeRange)
	{
		*pcRanges = 1;
		return S_OK;
	}

	if (*pcRanges < 1)
		return TPC_E_INSUFFICIENT_BUFFER;
	*pcRanges = 1;

	if (IsBadWritePtr(pStrokeRange, sizeof(STROKE_RANGE)))
		return E_POINTER;

	pStrokeRange->iStrokeBegin = 0;
	pStrokeRange->iStrokeEnd = pGestAlt->pgrc->cFrames - 1;
	return S_OK;
}


// GetSegmentAlternateList
//
// This function returns alternates of the left most (or starting)
// segment in the Reco Range for this alternate
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the segment alternates for, it comes back with the real REC_RANGE
//								used to get the segment alternates.
//		pcAlts [in, out] :		The number of alternates(or the number of them to put in the provided buffer)
//		pAlts [out] :			If NULL we return the number in *pcAlts, if not this is an
//								array of size *pcAlts where we copy the alternate handles
/////////////////

HRESULT WINAPI
GetSegmentAlternateList(HRECOALT hrcalt,
						RECO_RANGE *pRecoRange,
						ULONG *pcAlts,
						HRECOALT *pAlts)
{
	GestureAlternate *pGestAlt;

	if (NULL == (pGestAlt = (GestureAlternate *)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}
    if ( IsBadReadPtr(pRecoRange, sizeof(RECO_RANGE)) )
    {
        return E_POINTER;
    }

	return GetAltList(pGestAlt->pgrc,
					  pRecoRange,
					  pcAlts,
					  pAlts);
}


// GetMetrics
//
// This function alternate of the left most segment passed in the Reco Range
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the metrics for
//		lm [in] :				What metrics we want (midline, baseline, ...)
//		pls [out] :				Pointer to the line segment corresponding to the metrics
//								we want.
/////////////////

HRESULT WINAPI
GetMetrics(HRECOALT hrcalt,
		   RECO_RANGE* pRecoRange,
		   LINE_METRICS lm,
		   LINE_SEGMENT* pls)
{
	return TPC_E_NOT_RELEVANT;
}


// GetAlternateList
//
// This function returns alternates of the best result
//
// Parameters:
//		hrc [in] :				The handle to the reco context
//		pRecoRange [in, out] :	Pointer to a RECO_RANGE that contains the range we want to get
//								the alternates for. This range comes bck modified to
//								reflect the range we actually used.
//		pcAlts [in, out] :		The number of alternates. If pAlts is NULL then this function returns
//								the number of alternates it can return - Note we may return an arbitrary
//								number with an HRESULT S_FALSE if we think that the number of alternate
//								is too long to compute.
//		pAlts [out] :			Array of alternates used to return the alternate list
//		iBreak [in] :			Mode for querying alternates: ALT_BREAKS_SAME, ALT_BREAKS_FULL or ALT_BREAKS_UNIQUE
/////////////////

HRESULT WINAPI
GetAlternateList(HRECOCONTEXT hrc,
				 RECO_RANGE	*pRecoRange,
				 ULONG		*pcAlts,
				 HRECOALT	*pAlts,
				 ALT_BREAKS iBreak)
{
	GRC	*pgrc;
    
	if (NULL == (pgrc = (GRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

	return GetAltList(pgrc, pRecoRange, pcAlts, pAlts);
}


// GetConfidenceLevel
//
// Function returning the confidence level for this alternate
// The confidence level is currently set to CFL_INTERMEDIATE
// for any answer.
//
// Parameters:
//		hrcalt      [in]        : The wisp alternate handle
//      pRecoRange  [in, out]   : The range we want the confidence level for
//                                This is modified to return the effective range used
//		pcl         [out]       : The pointer to the returned confidence level value
/////////////////

HRESULT WINAPI
GetConfidenceLevel(HRECOALT hrcalt,
				   RECO_RANGE* pRecoRange,
				   CONFIDENCE_LEVEL* pcl)
{
	GestureAlternate *pGestAlt;
	if (NULL == (pGestAlt = (GestureAlternate *)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}
	if ( IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)) )
		return E_POINTER;
	if ( IsBadWritePtr(pcl, sizeof(CONFIDENCE_LEVEL)) )
		return E_POINTER;
    
	// Check the validity of the reco range
	if ( (pRecoRange->cCount != 1) ||
		 (pRecoRange->iwcBegin != 0) )
	{
		return E_INVALIDARG;
	}

	if (pGestAlt->eScore > 0.9)
		*pcl = CFL_STRONG;
	else if (pGestAlt->eScore > 0.6)
		*pcl = CFL_INTERMEDIATE;
	else
		*pcl = CFL_POOR;
        
    return S_OK;
}

//
// This is not needed anymore
//

/////////////////////////////////////////////////////////////////
// Registration information
//
//

#define RECO_SUBKEY			L"Software\\Microsoft\\TPG\\System Recognizers\\{BED9A940-7D48-48e3-9A68-F4887A5A1B2E}"
#define FULL_PATH_VALUE 	L"Recognizer dll"
#define RECO_MANAGER_KEY	L"CLSID\\{DE815B00-9460-4F6E-9471-892ED2275EA5}\\InprocServer32"
#define RECOGNIZER_SUBKEY	L"CLSID\\{BED9A940-7D48-48e3-9A68-F4887A5A1B2E}\\InprocServer32"
#define RECOPROC_SUBKEY		L"{BED9A940-7D48-48e3-9A68-F4887A5A1B2E}\\InprocServer32"
#define CLSID_KEY			L"CLSID"
#define RECOCLSID_SUBKEY	L"{BED9A940-7D48-48e3-9A68-F4887A5A1B2E}"
#define RECO_LANGUAGES      L"Recognized Languages"
#define RECO_CAPABILITIES   L"Recognizer Capability Flags"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

// This recognizer GUID is going to be
// {BED9A940-7D48-48e3-9A68-F4887A5A1B2E}
// Each recognizer HAS to have a different GUID

STDAPI 
DllRegisterServer(void)
{
	HKEY		hKeyReco = NULL;
	HKEY		hKeyRecoManager = NULL;
	LONG 		lRes = 0;	
	HKEY		hkeyMyReco;
	DWORD		dwLength = 0, dwType = 0, dwSize = 0;
	DWORD		dwDisposition;
	WCHAR		szRecognizerPath[MAX_PATH];
	WCHAR		szRecoComPath[MAX_PATH];
    RECO_ATTRS  recoAttr;
    HRESULT     hr = S_OK;

	// Write the path to this dll in the registry under
	// the recognizer subkey

	// Get the current path
	// Try to get the path of the RecoObj.dll
	// It should be the same as the one for the RecoCom.dll
	dwLength = GetModuleFileNameW((HMODULE)g_hInstanceDll, szRecognizerPath, MAX_PATH);
	if (MAX_PATH == dwLength && L'\0' != szRecognizerPath[MAX_PATH-1])
	{
		// Truncated path
		return E_UNEXPECTED;
	}
	// Wipe out the previous values
	lRes = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);
	// Create the new key
	lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE, RECO_SUBKEY, 0, NULL,
		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyMyReco, &dwDisposition);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_UNEXPECTED;
	}
	// Write the path to the dll as a value
	lRes = RegSetValueExW(hkeyMyReco, FULL_PATH_VALUE, 0, REG_SZ, 
		(BYTE*)szRecognizerPath, sizeof(WCHAR)*(wcslen(szRecognizerPath)+1));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_UNEXPECTED;
	}
    // We get the reco attributes
    // Here we pass NULL for the hrec because we only have one recognizer
    // we would need to loop through all the recognizer and register each
    // of them if there were more than one.
    hr = GetRecoAttributes(NULL, &recoAttr);
    if (FAILED(hr))
	{
		RegCloseKey(hkeyMyReco);
		return E_UNEXPECTED;
	}
	lRes = RegSetValueExW(hkeyMyReco, RECO_LANGUAGES, 0, REG_BINARY, 
		(BYTE*)recoAttr.awLanguageId, 64 * sizeof(WORD));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_UNEXPECTED;
	}
	lRes = RegSetValueExW(hkeyMyReco, RECO_CAPABILITIES, 0, REG_DWORD, 
		(BYTE*)&(recoAttr.dwRecoCapabilityFlags), sizeof(DWORD));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_UNEXPECTED;
	}  
	RegCloseKey(hkeyMyReco);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
	LONG 		lRes1 = 0;

    // Wipe out the registry information
	lRes1 = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);
	if (lRes1 != ERROR_SUCCESS && lRes1 != ERROR_FILE_NOT_FOUND)
	{
		return E_UNEXPECTED;
	}
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\brknet.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/brknet.c
//
// Description:
//	    Functions to implement the functionality of the break Neural net that 
// modifies the lattice structure to correct segmentation errors.
//
// Author:
// ahmadab 11/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"

#ifndef __BRKNET_H__

#define	__BRKNET_H__

// maximum number of brk net features
#define	MAX_BRK_NET_FEAT	32

// Magic key the identifies the NN bin file
#define	BRKNET_FILE_TYPE	0xFEFEABD0

// Version information for file.
#define	BRKNET_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	BRKNET_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define BRKNET_CUR_FILE_VERSION		0		// Current version of code.

// the threshold above which the output of the break net is regarded as a breaking point
#define BREAKING_THRESHOLD		(90 * SOFT_MAX_UNITY / 100)
//#define BREAKING_THRESHOLD	(SOFT_MAX_UNITY / 2)

// local data structure used by the BRKNET
// a lattice element list structure
typedef struct tagELEMLIST
{
	int						cElem;
	LATTICE_PATH_ELEMENT	*pElem;
}
ELEMLIST;

// structure representing a break point
typedef struct tagBRKPT
{
	ELEMLIST	Starting;
	ELEMLIST	Ending;
	ELEMLIST	Crossing;
}
BRKPT;


// NN data block resource type
int UpdateLattice (LATTICE *pLat);

BOOL LoadBrkNetFromResource (HINSTANCE hInst, int nResID, int nType);
BOOL LoadBrkNetFromFile(wchar_t *pwszRecogDir, LOAD_INFO *pLoadInfo);
void BrkNetUnloadfile (LOAD_INFO *pLoadInfo);

// private functions, prototyped here because the training program will use them
BRKPT	*CreateBrkPtList (LATTICE *pLat);
int		FeaturizeBrkPt (LATTICE *pLat, BRKPT *pBrk, int *pFeat);
void	FreeBreaks (int cStrk, BRKPT *pBrk);
BOOL	InsertListElement (ELEMLIST *pList, int iStrk, int iAlt, LATTICE_ELEMENT *pLatElem);
void	FreeElemList (ELEMLIST *pList);
void	ReverseElementList (ELEMLIST *pElemList);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\charrec.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/CharRec.c
//
// Description:
//	    Main sequencing code to recognize one character ignoring
//	    size and position.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "volcanop.h"
#include "frame.h"
#include "glyph.h"
#if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
#	include "math16.h"
#	include "hound.h"
#	include "zillatool.h"
#endif
#ifndef USE_OLD_DATABASES
#	include "hawk.h"
#endif

#ifdef USE_RESOURCES
#	include "res.h"
#endif

//#define OPTIMAL_OTTER_ZILLA

// Uncomment this to enable use of the old tsunami-style computation
// (using OtterMatch & ZillaMatch instead of OtterMatch2 & ZillaMatch2,
// and index the prob table by codepoint instead of prototype number).
//#define USE_OLD_DATABASES

/////////////////////////////////////////////////////////////////////////
// Hack code for probabilities, this will go away once Hawk works.

#include "probHack.h"

PROB_HEADER		*g_pProbHeader	= 0;

#define	EntryPtr(i)	\
	(PROB_ENTRY *)(((BYTE *)g_pProbHeader) + g_pProbHeader->aEntryOffset[i])
#define	AltPtr(i)	\
	(PROB_ALT *)(((BYTE *)g_pProbHeader) + g_pProbHeader->aAltOffset[i])

void ProbLoadPointer(void * pData)
{
	BYTE       *pScan = (BYTE *)pData;

	g_pProbHeader	= (PROB_HEADER *)pScan;
	pScan			+= sizeof(PROB_HEADER);
}

#ifdef USE_RESOURCES

BOOL ProbLoadRes(
	HINSTANCE	hInst, 
	int			resNumber, 
	int			resType
) {
	BYTE		*pByte;

	// Load the prob database
	pByte	= DoLoadResource(NULL, hInst, resNumber, resType);
	if (!pByte) {
		return FALSE;
	}
	ProbLoadPointer(pByte);

	return TRUE;
}

#else

BOOL ProbLoadFile(wchar_t *pPath, LOAD_INFO *pInfo) 
{
	HANDLE			hFile, hMap;
	BYTE			*pByte;
	wchar_t			aFile[128];

	pInfo->hFile = INVALID_HANDLE_VALUE;
	pInfo->hMap = INVALID_HANDLE_VALUE;
	pInfo->pbMapping = INVALID_HANDLE_VALUE;

	// Generate path to file.
	FormatPath(aFile, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"prob.bin");

	// Map the file
	hFile = CreateMappingCall(
		aFile, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		ASSERT(("Error in CreateMappingCall - prob", FALSE));
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		ASSERT(("Error in CreateFileMapping - prob", FALSE));
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		ASSERT(("Error in MapViewOfFile - prob", FALSE));
		goto error3;
	}

	// Extract info from mapped data.
	ProbLoadPointer((void *)pByte);

	// Save away the pointers so we can close up cleanly later
	pInfo->hFile = hFile;
	pInfo->hMap = hMap;
	pInfo->pbMapping = pByte;

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:

	return FALSE;
}

BOOL ProbUnLoadFile(LOAD_INFO *pInfo)
{
	if (pInfo->hFile == INVALID_HANDLE_VALUE ||
		pInfo->hMap == INVALID_HANDLE_VALUE ||
		pInfo->pbMapping == INVALID_HANDLE_VALUE) {
		return FALSE;
	}

	UnmapViewOfFile(pInfo->pbMapping);
	CloseHandle(pInfo->hMap);
	CloseHandle(pInfo->hFile);

	pInfo->pbMapping = INVALID_HANDLE_VALUE;
	pInfo->hMap = INVALID_HANDLE_VALUE;
	pInfo->hFile = INVALID_HANDLE_VALUE;

	return TRUE;
}

#endif

// Given an alt list with dense and possibly folded codes in it, run through it
// and expand the folded lists.  The unfolded alt list is returned in place.
// This function assumes that the list begins with better alternates, as those
// later in the list will get dropped if we run out of space.
void UnfoldCodes(ALT_LIST *pAltList, CHARSET *cs)
{
	int i, cOut=0;
	ALT_LIST newAltList;	// This will be where the new alt list is constructed.

	// For each alternate in the input list and while we have space in the output list
	for (i=0; i<(int)pAltList->cAlt && (int)cOut<MAX_ALT_LIST; i++) {

		// Check if the alternate is a folded coded
		if (LocRunIsFoldedCode(&g_locRunInfo,pAltList->awchList[i])) {
			int kndex;
			// If it is a folded code, look up the folding set
			wchar_t *pFoldingSet = LocRunFolded2FoldingSet(&g_locRunInfo, pAltList->awchList[i]);

			// Run through the folding set, adding non-NUL items to the output list
			// (until the output list is full)
			for (kndex = 0; 
				kndex < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[kndex] != 0 && (int)cOut<MAX_ALT_LIST; 
				kndex++) {
				if (IsAllowedChar(&g_locRunInfo, cs, pFoldingSet[kndex])) 
				{
					newAltList.awchList[cOut]=pFoldingSet[kndex];
					newAltList.aeScore[cOut]=pAltList->aeScore[i];
					cOut++;
#ifdef DISABLE_UNFOLDING
					// If unfolding is disabled, then stop after producing one unfolded code.
					// This way we don't push results later in the alt list out of the alt
					// list, while still allowing the recognizer to return unicodes for each
					// alternate.  
					break;
#endif
				}
			}
		} else {
			// Dense codes that are not folded get added directly
			newAltList.awchList[cOut]=pAltList->awchList[i];
			newAltList.aeScore[cOut]=pAltList->aeScore[i];
			cOut++;
		}
	}	
	// Store the length of the output list
	newAltList.cAlt=cOut;

	// Copy the output list over the input.
	*pAltList=newAltList;
}

#ifdef USE_OLD_DATABASES

// Used for WinCE
// Given a feature space (cFrame), an alt list, and a requested number of alts, this 
// function returns a new alt list with probabilities for each alternate.  It uses a
// fixed prob distribution.
int GetProbsTsunamiFixedTable(
	int			cFrame,
	ALT_LIST	*pAltList,
	int			maxAlts,
	RECOG_ALT	*pRAlts,
    CHARSET     *pCS
) {
	int rank = 0;
	FLOAT rankScore = pAltList->aeScore[0];
	int cAlt;
    int iDest = 0;

	for (cAlt = 0; cAlt < (int) pAltList->cAlt && iDest < maxAlts; ++cAlt) 
    {
		if (pAltList->aeScore[cAlt] != rankScore) 
        {
			rank ++;
			rankScore = pAltList->aeScore[cAlt];
		}

        if (IsAllowedChar(&g_locRunInfo, pCS, pAltList->awchList[cAlt]))
        {
		    int count;
		    switch (rank) {
		    case 0:
			    count = 141125;
			    break;
		    case 1:
			    count = 6090;
			    break;
		    case 2:
			    count = 957;
			    break;
		    case 3:
			    count = 362;
			    break;
		    case 4:
			    count = 161;
			    break;
		    case 5:
			    count = 82;
			    break;
		    case 6:
			    count = 66;
			    break;
		    case 7:
			    count = 49;
			    break;
		    case 8:
			    count = 36;
			    break;
		    case 9:
			    count = 34;
			    break;
		    default:
			    count = 10;
			    break;
		    }
		    pRAlts[iDest].wch = pAltList->awchList[cAlt];
		    pRAlts[iDest].prob = 65535*(float)count/(float)149903;
            iDest++;
        }
	}
	return iDest;
}

// Desktop
// Given a feature space (cFrame), an alt list, and a requested number of alts, this 
// function returns a new alt list with probabilities for each alternate.  The version
// called GetProbs in this file does the lookup by prototype number, whereas this version
// does lookups by code point (like the code in Tsunami).  Note that the alt list passed
// in will get modified.
int GetProbsTsunami(
	int			cFrame,
	ALT_LIST	*pAltList,
	int			maxAlts,
	RECOG_ALT	*pRAlts,
    CHARSET     *pCS
) {
	unsigned int cAlt;
	int			ii;
    int         iDest = 0;
	PROB_ENTRY	*pEntries, *pEntriesStart, *pEntriesEnd;
	PROB_ALT	*pAlts, *pAltsStart, *pAltsEnd;

	// If we didn't get any alternates, return an empty list.
	if (pAltList->cAlt == 0) {
		return 0;
	}

	// If the probability table was not loaded, just return the top one candidate.
	// This is useful for training the prob table.
	if (g_pProbHeader==NULL) {
		pRAlts[0].wch=pAltList->awchList[0];
		pRAlts[0].prob=MAX_PROB;
		return 1;
	}

//	ASSERT(1 <= cFrame && cFrame < 30);
	ASSERT(1 <= cFrame);
	if (cFrame >= 30) {
		// Can't handle this many strokes.
		goto fakeIt;
	}

	// Hack for U+307A/U+30DA, which probably haven't had their probs set up right
/*	if (LocRunDense2Unicode(&g_locRunInfo,pAltList->awchList[0])==0x307A ||
		LocRunDense2Unicode(&g_locRunInfo,pAltList->awchList[0])==0x30DA) {
		pRAlts[0].wch	= LocRunUnicode2Dense(&g_locRunInfo,0x30DA);
		pRAlts[0].prob	= MAX_PROB;
		pRAlts[1].wch	= LocRunUnicode2Dense(&g_locRunInfo,0x307A);
		pRAlts[1].prob	= MAX_PROB;
		return 2;
	} */

	pEntriesStart	= EntryPtr(cFrame - 1);
	pEntriesEnd		= EntryPtr(cFrame);
	pAltsStart		= AltPtr(cFrame - 1);
	pAltsEnd		= AltPtr(cFrame);

	// Scan until we find an alt that has a prob list.
	// Normally we stop on the first one, but sometimes
	// We had no train data to cause a prototype to come
	// up top one.
	for (cAlt = 0; cAlt < pAltList->cAlt; ++cAlt) {
		// Get char to look up.
//		wchar_t		wch		= LocRunDense2Unicode(&g_locRunInfo,pAltList->awchList[cAlt]);
		wchar_t		wch		= pAltList->awchList[cAlt];

		pAlts	= pAltsStart;
		for (pEntries = pEntriesStart; pEntries < pEntriesEnd; ++pEntries) {
			if (pEntries->wch == wch) {
				// copy results out.
				for (ii = 0; ii < pEntries->cAlts && iDest < maxAlts; ++ii) {
                    if (IsAllowedChar(&g_locRunInfo, pCS, pAlts->wchAlt))
                    {
					    pRAlts[iDest].wch	= pAlts->wchAlt;
					    pRAlts[iDest].prob = pAlts->prob;
                        iDest++;
                    }
					++pAlts;
				}
                return iDest;
			}
			pAlts	+= pEntries->cAlts;
		}
	}
fakeIt:
	// Fake something up.
	pRAlts[0].wch	= pAltList->awchList[0];
	pRAlts[0].prob	= MAX_PROB;
//	fprintf(stderr,"Returning no alts\n");
//	exit(1);
	return 1;
}

#endif
// USE_OLD_DATABASES

// End of hacked Prob code.
////////////////////////////////////////////////////////////////////////

BOOL g_fUseJaws;
JAWS_LOAD_INFO g_JawsLoadInfo;
FUGU_LOAD_INFO g_FuguLoadInfo;
SOLE_LOAD_INFO g_SoleLoadInfo;
BOOL g_fUseZillaHound;

#ifdef USE_RESOURCES

#include "res.h"

//  Code to load and initialize the databases used.
//  They are loaded in this order: otter, zilla, crane/prob or hawk, 
BOOL LoadCharRec(HINSTANCE hInstanceDll)
{
	BOOL			fError	= FALSE;

    if (JawsLoadRes(&g_JawsLoadInfo, hInstanceDll, RESID_JAWS, VOLCANO_RES)) 
    {
        // Now we need to load the databases that will be combined by this combiner

        // Load the Fugu database
	    if (!fError && !FuguLoadRes(&g_FuguLoadInfo, hInstanceDll, RESID_FUGU, VOLCANO_RES, &g_locRunInfo))
        {
		    fError	= TRUE;
		    ASSERT(("Error in FuguLoadRes", FALSE));
	    }

        // Load the Sole database
        if (!fError && !SoleLoadRes(&g_SoleLoadInfo, hInstanceDll, RESID_SOLE, VOLCANO_RES, &g_locRunInfo)) 
        {
            fError = TRUE;
            ASSERT(("Error loading sole", FALSE));
        }
        g_fUseJaws = TRUE;
    }
    else
    {
    	// Load the Otter database
	    if (!fError && !OtterLoadRes(hInstanceDll, RESID_OTTER, VOLCANO_RES, &g_locRunInfo)) 
        {
		    fError	= TRUE;
		    ASSERT(("Error in OtterLoadRes", FALSE));
	    }
        g_fUseJaws = FALSE;
    }

#if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
	// Load the Zilla database
	if (!fError && !ZillaLoadResource(
			hInstanceDll, RESID_ZILLA, VOLCANO_RES, RESID_COSTCALC,
			VOLCANO_RES, RESID_GEOSTAT, VOLCANO_RES, &g_locRunInfo
	)) {
		fError	= TRUE;
		ASSERT(("Error in ZillaLoadResource", FALSE));
	}
#endif

#if defined(USE_HOUND)
	// Load the Hound database (Hound only, require it to load)
	if (!fError && !HoundLoadRes(hInstanceDll, RESID_HOUND, VOLCANO_RES, &g_locRunInfo)) {
		fError	= TRUE;
		ASSERT(("Error in HoundLoadRes", FALSE));
	}
#endif

	g_fUseZillaHound	= FALSE;
#if defined(USE_ZILLAHOUND)
	if (!fError) {
		// Load the Hound & Hound-Zilla databases (This is optional).
		if (HoundLoadRes(hInstanceDll, RESID_HOUND, VOLCANO_RES, &g_locRunInfo)) {
			if (ZillaHoundLoadRes(hInstanceDll, RESID_ZILLA_HOUND, VOLCANO_RES)) {
				g_fUseZillaHound	= TRUE;
			}
		}
	}
#endif

	// Load the Hawk database.
#ifndef USE_OLD_DATABASES
	if (!fError && !HawkLoadRes(
		hInstanceDll, RESID_HAWK, VOLCANO_RES, &g_locRunInfo
	)) {
		fError	= TRUE;
		ASSERT(("Error in HawkLoadRes", FALSE));
	}
#else
	if (!fError && !CraneLoadRes(hInstanceDll,RESID_CRANE,VOLCANO_RES,&g_locRunInfo)) {
		fError=TRUE;
		ASSERT(("Error in CraneLoadRes", FALSE));
	}

    // Load hack probability code until we switch over to hawk.
	// Use hawks resID so we don't have to create an extra one.
#if !defined(WINCE) && !defined(FAKE_WINCE)
	if (!fError && !ProbLoadRes(
		hInstanceDll, RESID_HAWK, VOLCANO_RES
	)) {
		// Failing to load this is no longer an error,
		// just fall back on the WinCE method.
//		fError	= TRUE;
//		ASSERT(("Error in ProbLoadRes", FALSE));
	}
#endif
#endif

	// Did everything load correctly?
	if (fError) {
		// JBENN: If the databases can ever be unloaded, this is
		// a place the need to.

		// JBENN: FIXME: Set correct error code base on what really went wrong.
		SetLastError(ERROR_RESOURCE_NAME_NOT_FOUND);
		//SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
		//SetLastError(ERROR_RESOURCE_TYPE_NOT_FOUND);
		//SetLastError(ERROR_OUTOFMEMORY);

		return FALSE;
	}

	return TRUE;
}

// Code to unload the databases used.
BOOL
UnloadCharRec()
{
	BOOL retVal;

	retVal	= TRUE;

	// Free hound up.
#	if defined(USE_HOUND)
		if (!HoundUnLoadRes())
		{
			retVal	= FALSE;
		}
#	endif

#	if defined(USE_ZILLAHOUND)
		if (g_fUseZillaHound && !HoundUnLoadRes())
		{
			retVal	= FALSE;
		}
#	endif

	if (!ZillaUnloadResource())
	{
		retVal	= FALSE;
	}

	return retVal;
}

#	else

// Global load information specific to loading from files.
#if defined(USE_OTTER) || defined(USE_OTTERFUGU)
	OTTER_LOAD_INFO	g_OtterLoadInfo;
#endif
#if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
	LOAD_INFO	g_HoundLoadInfo;
#endif
#ifdef USE_OLD_DATABASES
	LOAD_INFO g_ProbLoadInfo;
	CRANE_LOAD_INFO g_CraneLoadInfo;
#else
	LOAD_INFO g_HawkLoadInfo;
#endif

//  Code to load and initialize the databases used.
BOOL LoadCharRec(wchar_t	*pPath)
{
	BOOL			fError	= FALSE;

    if (JawsLoadFile(&g_JawsLoadInfo, pPath)) 
    {
        // Load the Fugu database
	    if (!fError && !FuguLoadFile(&g_FuguLoadInfo, pPath, &g_locRunInfo)) {
		    fError	= TRUE;
		    ASSERT(("Error in FuguLoadFile", FALSE));
	    }

        // Load the Sole database
	    if (!fError && !SoleLoadFile(&g_SoleLoadInfo, pPath, &g_locRunInfo)) {
		    fError	= TRUE;
		    ASSERT(("Error in FuguLoadFile", FALSE));
	    }
        g_fUseJaws = TRUE;
    } 
    else
    {
	    // Load the Otter database
	    if (!fError && !OtterLoadFile(&g_locRunInfo, &g_OtterLoadInfo, pPath)) {
		    fError	= TRUE;
		    ASSERT(("Error in OtterLoadFile", FALSE));
	    }
        g_fUseJaws = FALSE;
    }

#if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
	// Load the Zilla database
	if (!fError && !ZillaLoadFile(&g_locRunInfo, pPath, TRUE)) {
		fError	= TRUE;
		ASSERT(("Error in ZillaLoadFile", FALSE));
	}
#endif

#if defined(USE_HOUND)
	// Load the Hound database (Hound only, require it to load)
	if (!fError && !HoundLoadFile(&g_locRunInfo, &g_HoundLoadInfo, pPath)) {
		fError	= TRUE;
		ASSERT(("Error in HoundLoadFile", FALSE));
	}
#endif

	g_fUseZillaHound	= FALSE;
#if defined(USE_ZILLAHOUND)
	if (!fError) {
		// Load the Hound & Hound-Zilla databases (This is optional).
		if (HoundLoadFile(&g_locRunInfo, &g_HoundLoadInfo, pPath)) {
			if (ZillaHoundLoadFile(pPath)) {
				g_fUseZillaHound	= TRUE;
			}
			else
			{
#				ifndef TRAIN_ZILLA_HOUND_COMBINER
					HoundUnLoadFile(&g_HoundLoadInfo);
#				endif
			}
		}
	}
#endif

#ifndef USE_OLD_DATABASES
	// Load the Hawk database.
	if (!fError && !HawkLoadFile(&g_locRunInfo, &g_HawkLoadInfo, pPath)) {
		fError	= TRUE;
		ASSERT(("Error in HawkLoadFile", FALSE));
	}

#else
#if !defined(WINCE) && !defined(FAKE_WINCE)
	// Load hack probability code until we switch over to hawk.
	if (!fError && !ProbLoadFile(pPath, &g_ProbLoadInfo)) {
		// Failing to load this is no longer an error,
		// just fall back on the WinCE method.
//		fError	= TRUE;
//		ASSERT(("Error in ProbLoadFile", FALSE));
	}
#endif
	if (!fError && !CraneLoadFile(&g_locRunInfo,&g_CraneLoadInfo, pPath)) {
		fError	= TRUE;
		ASSERT(("Error in CraneLoadFile", FALSE));
	}
#endif

	// Did everything load correctly?
	if (fError) {
		// JBENN: If the databases can ever be unloaded, this is
		// a place the need to.

		// JBENN: FIXME: Set correct error code base on what really went wrong.
		SetLastError(ERROR_RESOURCE_NAME_NOT_FOUND);
		//SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
		//SetLastError(ERROR_RESOURCE_TYPE_NOT_FOUND);
		//SetLastError(ERROR_OUTOFMEMORY);

		return FALSE;
	}

	return TRUE;
}

// Code to unload the databases used.
BOOL
UnloadCharRec()
{
	BOOL ok = TRUE;
    if (g_fUseJaws)
    {
        if (!SoleUnloadFile(&g_SoleLoadInfo)) ok = FALSE;
        if (!FuguUnLoadFile(&g_FuguLoadInfo)) ok = FALSE;
        if (!JawsUnloadFile(&g_JawsLoadInfo)) ok = FALSE;
    }
    else
    {
    	if (!OtterUnLoadFile(&g_OtterLoadInfo)) ok = FALSE;
    }

#	if defined(USE_HOUND)
		if (!HoundUnLoadFile(&g_HoundLoadInfo))
		{
			ok = FALSE;
		}
#	endif

#	if defined(USE_ZILLAHOUND)
		if (g_fUseZillaHound)
		{
			if (!ZillaHoundUnloadFile())
			{
				ok = FALSE;
			}
			if (!HoundUnLoadFile(&g_HoundLoadInfo))
			{
				ok = FALSE;
			}
		}
#	endif

	if (!ZillaUnLoadFile()) ok = FALSE;
#	ifdef USE_OLD_DATABASES
		if (!CraneUnLoadFile(&g_CraneLoadInfo)) ok = FALSE;
#		if !defined(WINCE) && !defined(FAKE_WINCE)
			if (g_pProbHeader != NULL && !ProbUnLoadFile(&g_ProbLoadInfo)) ok = FALSE;
#		endif
#	else // USE_OLD_DATABASES
	   if (!HawkUnLoadFile(&g_HawkLoadInfo)) ok = FALSE;
#	endif // USE_OLD_DATABASES
	return ok;
}

#endif

// Limit on strokes that can be processed by a recognizer.  Since
// Zilla ignores anything beyond 29 strokes, it is safe to ignore
// any extra.
#define	MAX_STOKES_PROCESS	30

POINT *DupPoints(POINT *pOldPoints, int nPoints);
GLYPH *GlyphFromStrokes(UINT cStrokes, STROKE *pStrokes);


#ifndef USE_RESOURCES
// Build a copy of the glyph structure.
GLYPH *CopyGlyph(GLYPH *pOldGlyph)
{
	GLYPH	*pGlyph = NULL, *pLastGlyph = NULL;

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.
    while (pOldGlyph != NULL) {
		GLYPH	*pGlyphCur;

		// Alloc glyph.
		pGlyphCur	= NewGLYPH();
		if (!pGlyphCur) {
			goto error;
		}

		// Add to list, and alloc frame
        if (pLastGlyph != NULL) {
            pLastGlyph->next = pGlyphCur;
            pLastGlyph = pGlyphCur;
        } else {
            pGlyph = pGlyphCur;
            pLastGlyph = pGlyphCur;
        }
		pGlyphCur->next		= NULL;
		pGlyphCur->frame	= NewFRAME();
		if (!pGlyphCur->frame) {
			goto error;
		}

		// Fill in frame.  We just fill in what we need, and ignore
		// fields not used by Otter and Zilla, or are set by them.
        pGlyphCur->frame->info.cPnt	= pOldGlyph->frame->info.cPnt;
		pGlyphCur->frame->info.wPdk	= pOldGlyph->frame->info.wPdk;
		pGlyphCur->frame->rgrawxy	= DupPoints(pOldGlyph->frame->rgrawxy, pOldGlyph->frame->info.cPnt);
		pGlyphCur->frame->rect		= pOldGlyph->frame->rect;
		pGlyphCur->frame->iframe	= pOldGlyph->frame->iframe;

		if (pGlyphCur->frame->rgrawxy == NULL) {
			goto error;
		}

        pOldGlyph = pOldGlyph->next;
	}

	return pGlyph;

error:
	// Cleanup glyphs on error.
	if (pGlyph != NULL) {
		DestroyFramesGLYPH(pGlyph);
		DestroyGLYPH(pGlyph);
	}
	return NULL;
}
#endif // !USE_RESOURCES

#ifdef USE_OLD_DATABASES
/******************************Public*Routine******************************\
* AdHocRuleCost
*
* Because of character folding and the inability of the shape matchers
* to distinguish between a cluster a 1000 samples map to versus 1 point
* mapping to it we have a few hard rule we throw in to fix obvious
* problems.
*
* History:
*  11-Jul-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

float AdHocRuleCost(int cStrokes, wchar_t dch, VOLCANO_WEIGHTS *pScores)
{
#ifdef DISABLE_HEURISTICS
	return 0;
#else
    wchar_t wch;
    int		cFrame;

	// Get character and number of strokes. Note we need character in Unicode
	// so that we can compare with constant character codes.
	
	// ASSUMPTION: SYM_UNKNOWN should be the only sym if its present.
	// So there aren't any alternatives that could get a "better" cost
	// so it probably doesn't really matter what cost we return here
	if (dch == SYM_UNKNOWN)
    {
		return 0;
    }

	wch		= LocRunDense2Unicode(&g_locRunInfo, dch);
    cFrame	= cStrokes;

    // Check for 0 (2 strokes), penalize all circle shapes
    // except 0 when 2 strokes occur.
    if (cFrame >= 2) 
    {
        // 0x824f is the 0 that we don't want to penalize.
        // All other circle shapes are penalized.
		if ((wch == 0x006F) ||
			(wch == 0x004F) ||
			(wch == 0x00B0) ||
 			(wch == 0x3002) ||
			(wch == 0x3007)
		) 
        {
            pScores->afl[VTUNE_ADHOC_CIRCLE] = -1;
            return -g_vtuneInfo.pTune->weights.afl[VTUNE_ADHOC_CIRCLE];
		}
    }

    // Check for 1 stroke lower-case i and j.  No dot is a extra penalty.
    if (cFrame == 1) 
    {
        if ((wch == 0x0069) || (wch == 0x006A)) 
        {
            pScores->afl[VTUNE_ADHOC_IJ] = -1;
            return -g_vtuneInfo.pTune->weights.afl[VTUNE_ADHOC_IJ];
        }
    }

    return 0;
#endif
}

BOOL Afterburn(ALT_LIST *pAltList, GLYPH *pGlyph, CHARSET *cs, RECT *rGuide, RECT rc)
{
	DRECTS	drcs;

	if (pGlyph==NULL || rGuide==NULL)
		return FALSE;

// Scale and translate the guide box to compute the 'delta rectangle'

	drcs.x = rGuide->left;
	drcs.y = rGuide->top;
	drcs.w = rGuide->right - rGuide->left;
	drcs.h = rGuide->bottom - rGuide->top;

// Translate, convert to delta form
	rc.left   -= drcs.x;
	rc.top    -= drcs.y;
	rc.right  -= (drcs.x + rc.left);
	rc.bottom -= (drcs.y + rc.top);

// Scale.  We do isotropic scaling and center the shorter dimension.
	if (drcs.w > drcs.h) {
		drcs.x = ((1000 * rc.left) / drcs.w);
		drcs.y = ((1000 * rc.top) / drcs.w) + ((drcs.w - drcs.h) / 2);
		drcs.h = ((1000 * rc.bottom) / drcs.w);
		drcs.w = ((1000 * rc.right) / drcs.w);
	} else {
		drcs.x = ((1000 * rc.left) / drcs.h) + ((drcs.h - drcs.w) / 2);
		drcs.y = ((1000 * rc.top) / drcs.h);
		drcs.w = ((1000 * rc.right) / drcs.h);
		drcs.h = ((1000 * rc.bottom) / drcs.h);
	}

#ifndef DISABLE_HEURISTICS
    return CraneMatch(pAltList, MAX_ALT_LIST, pGlyph, cs, &drcs, 0, &g_locRunInfo);
#else
	return FALSE;
#endif
}

// Hack to get around lack of data for training Crane
BOOL IsFaultyKana(wchar_t wch)
{
	switch (wch) {
//	case 0x3041:
	case 0x3042:
//	case 0x3043:
	case 0x3044:
//	case 0x3045:
	case 0x3046:
//	case 0x3047:
	case 0x3048:
//	case 0x3049:
	case 0x304A:
//	case 0x30E9:
		return TRUE;
	}
	return FALSE;
}
#endif // USE_OLD_DATABASES

// Sort the alternate list.
// We do a bubble sort.  The list is small and we can't use qsort because the data is stored in
// three parallel arrays.
void SortAltListAndTune(ALT_LIST *pAltList, VOLCANO_WEIGHTS *pTuneScore)
{
	int		pos1, pos2;
	int		limit1, limit2;
	FLOAT	* const peScore		= pAltList->aeScore;
	wchar_t	* const pwchList	= pAltList->awchList;

	limit2	= pAltList->cAlt;
	limit1	= limit2 - 1;
	for (pos1 = 0; pos1 < limit1; ++pos1) {
		for (pos2 = pos1 + 1; pos2 < limit2; ++pos2) {
			// Are elements pos1 and pos2 out of order?
			if (peScore[pos1] < peScore[pos2]) {
				FLOAT			eTemp;
				wchar_t			wchTemp;
				VOLCANO_WEIGHTS	weights;

				// Swap scores and swap characters.
				eTemp			= peScore[pos1];
				peScore[pos1]	= peScore[pos2];
				peScore[pos2]	= eTemp;

				wchTemp			= pwchList[pos1];
				pwchList[pos1]	= pwchList[pos2];
				pwchList[pos2]	= wchTemp;

				weights			= pTuneScore[pos1];
				pTuneScore[pos1]= pTuneScore[pos2];
				pTuneScore[pos2]= weights;
			}
		}
	}
}

// Call the core recognizer for the given character.  Returned the 
// number of alternates produced, or -1 if an error occurs.
int CoreRecognizeChar(
                      ALT_LIST *pAltList,				// Alt list to be returned
					  int cAlt,							// Max number of alternates
					  GLYPH **ppGlyph,					// Character to recognize (which may be modified)
					  int nRealStrokes,					// Real stroke count for abort processing
					  RECT *pGuideBox,					// Guide box (for partial mode)
				      RECOG_SETTINGS *pRecogSettings,	// Partial mode, other settings
                      CHARSET *pCS,                     // ALCs
					  int *piRecognizer,				// Returns the VOLCANO_CONFIG_* constant for the recognizer used
					  int *piSpace)						// The space number in that recognizer
{
	int iRet = -1;
	int iRecognizer = VOLCANO_CONFIG_NONE;
    int nStrokes = CframeGLYPH(*ppGlyph);

    if (nStrokes > VOLCANO_CONFIG_MAX_STROKE_COUNT) nStrokes = VOLCANO_CONFIG_MAX_STROKE_COUNT;
    if (pRecogSettings->partialMode) nStrokes = 0;
    iRecognizer = g_latticeConfigInfo.iRecognizers[nStrokes];

	*piRecognizer = iRecognizer;
    *piSpace = -1;

	pAltList->cAlt = 0;

	// Call the selected recognizer
	switch (iRecognizer) 
    {
        case VOLCANO_CONFIG_OTTER: 
            if (g_fUseJaws) 
            {
    	        iRet = JawsMatch(&g_JawsLoadInfo, &g_FuguLoadInfo, &g_SoleLoadInfo, 
                                 pAltList, cAlt, *ppGlyph, pGuideBox, pCS, &g_locRunInfo);
                *piSpace = nStrokes;
            }
            else
            {
    		    iRet = OtterMatch2(pAltList, cAlt, *ppGlyph, pCS, &g_locRunInfo, piSpace);

                // Other experiments
//              iRet = FuguMatch(&g_FuguLoadInfo.fugu, pAltList, cAlt, *ppGlyph, NULL /*pGuideBox*/, pCS, &g_locRunInfo);
//              iRet = SoleMatch(pAltList, cAlt, *ppGlyph, pGuideBox, pCS, &g_locRunInfo);
//   	        *piSpace = nStrokes;
            }
		    break;

        case VOLCANO_CONFIG_ZILLA:
	        iRet = ZillaMatch(pAltList, cAlt, ppGlyph, pCS, g_vtuneInfo.pTune->flZillaGeo,
							  (pRecogSettings->partialMode ? pRecogSettings->pAbort : NULL), 
				              nRealStrokes, pRecogSettings->partialMode, pGuideBox);

            // For Zilla, the space number is the feature count.  To make them disjoint from the
            // Otter spaces, add on the maximum number of Otter spaces.
            *piSpace = CframeGLYPH(*ppGlyph) + OTTER_NUM_SPACES;

            // Here you can change the iRecognizer that is returned to indicate that the Hound/Zilla
            // combiner ran, instead of just Zilla alone.  That way tuning will know to use a different
            // weighting parameter.
	        break;

        default:
	        // No recognizer available for this stroke count
	        iRet = -1;
	        break;
	}

	return iRet;
}

// Allocate a cache for the recognizer results.
void *AllocateRecognizerCache()
{
    CACHE *pCache = (CACHE *) ExternAlloc(sizeof(CACHE));
    if (pCache == NULL)
    {
        return NULL;
    }
    pCache->nStrokes = 0;
    pCache->pStrokes = NULL;
    return pCache;
}

// Free up a cache for the recognizer results.
void FreeRecognizerCache(void *pvCache)
{
    CACHE *pCache = (CACHE *) pvCache;
    CACHE_ENTRY *pEntry;
    int iStroke;
    if (pvCache == NULL)
    {
        return;
    }
    for (iStroke = 0; iStroke < pCache->nStrokes; iStroke++) 
    {
        pEntry = pCache->pStrokes[iStroke];
        while (pEntry != NULL) 
        {
            CACHE_ENTRY *pNext = pEntry->pNext;
            ExternFree(pEntry);
            pEntry = pNext;
        }
    }
    ExternFree(pCache->pStrokes);
    ExternFree(pCache);
}
 
// Look for results for a given range of strokes, return the recognizer and its
// alternate list.
ALT_LIST *LookupRecognizerCache(void *pvCache, int iStroke, int nStrokes, int *piRecognizer)
{
    CACHE *pCache = (CACHE *) pvCache;
    CACHE_ENTRY *pEntry;
    if (pCache == NULL || iStroke >= pCache->nStrokes) 
    {
        return NULL;
    }
    // For the given ending stroke, look for a result for the right number of strokes
    pEntry = pCache->pStrokes[iStroke];
    while (pEntry != NULL && pEntry->nStrokes != nStrokes) 
    {
        pEntry = pEntry->pNext;
    }
    // If not found, return nothing.
    if (pEntry == NULL)
    {
        return NULL;
    }
    // Otherwise return the cached results.
    *piRecognizer = pEntry->iRecognizer;
    return &(pEntry->alts);
}

// Add the alternate list to the cache.
void AddRecognizerCache(void *pvCache, int iStroke, int nStrokes, int iRecognizer, ALT_LIST *pAlts)
{
    CACHE *pCache = (CACHE *) pvCache;
    CACHE_ENTRY *pEntry;
    // If no cache, then exit
    if (pCache == NULL) 
    {
        return;
    }
    // If the cache is currently too small, then allocate more space for it.
    if (iStroke >= pCache->nStrokes) 
    {
        int i;
        int nStrokesNew = max(10, (iStroke + 1) * 2);
        CACHE_ENTRY **pStrokesNew = (CACHE_ENTRY **) ExternRealloc(pCache->pStrokes, sizeof(CACHE_ENTRY *) * nStrokesNew);
        if (pStrokesNew == NULL)
        {
            // If the allocation failed, just continue with the current cache size
            return;
        }
        // Initialize the memory
        for (i = pCache->nStrokes; i < nStrokesNew; i++)
        {
            pStrokesNew[i] = NULL;
        }
        pCache->pStrokes = pStrokesNew;
        pCache->nStrokes = nStrokesNew;
    }
    // If we got here, then add the entry to the cache
    pEntry = (CACHE_ENTRY *) ExternAlloc(sizeof(CACHE_ENTRY));
    if (pEntry == NULL)
    {
        return;
    }
    pEntry->nStrokes = nStrokes;
    pEntry->iRecognizer = iRecognizer;
    pEntry->alts = *pAlts;
    pEntry->pNext = pCache->pStrokes[iStroke];
    pCache->pStrokes[iStroke] = pEntry;
}

#ifdef USE_OLD_DATABASES
// This call is roughly the equivalent of the RecognizeChar call below, but instead of 
// returning probabilities, it returns an alternate list with scores.  It uses the old Tsunami 
// recognition procedure, with otter and zilla returning code points, followed by adhoc rules, 
// language model, baseline/height scores, and crane.  The result of this is used by RecognizeChar 
// to look up the old probability table.
INT RecognizeCharInsurance(
	RECOG_SETTINGS	*pRecogSettings,// In: Setting for recognizers.
	UINT			cStrokes,		// In: Number of strokes to process.
	UINT			cRealStrokes,	// In: Number of strokes before merging
	STROKE			*pStrokes,		// In: Array of strokes to process.
	FLOAT			*pProbIsChar,	// Out: probability of being valid char.
	UINT			maxAlts,		// In: Size of alts array supplied.
	RECOG_ALT		*pProbAlts,		// Out: alternate list matched with probabilities.
	int				*pnProbAlts,
	RECOG_ALT		*pScoreAlts,	// Out: alternate list matched with scores
	int				*pnScoreAlts,
	RECT			*pGuideBox,		// In: Guide box for this ink.
	wchar_t			dchContext,		// In: Context
	int				*pSpace,        // Out: Space number used for matching
	VOLCANO_WEIGHTS	*pTuneScore,    // Out: score components
    BOOL            fStringMode,    // In: Whether or not the recognizer is in string mode
    BOOL            fProbMode,      // In: Whether the recognizer is in probability mode
    void            *pvCache,       // In/Out: Pointer to cache, or NULL if not being used
    int             iStroke         // In: Index of last stroke of character
) {
    ALT_LIST        *pCacheResult = NULL;
	BOXINFO			box;
	RECT			bbox;
	int				iAlt;
	GLYPH			*pGlyph;
	ALT_LIST		altList;
	CHARSET			charSet;            // Mask used for core recognizers
    CHARSET         charSetMask;        // Mask used for probability table lookup
	BOOL			fCraneBonus = FALSE;
	int				iRecognizer;

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.

	pGlyph	= GlyphFromStrokes(cStrokes, pStrokes);
	if (!pGlyph) 
	{
		return -1;
	}

	// Run otter or zilla as needed.
	altList.cAlt			= 0;
	charSetMask.recmask			= pRecogSettings->alcValid;
	charSetMask.recmaskPriority	= pRecogSettings->alcPriority;
    charSetMask.pbAllowedChars  = pRecogSettings->pbAllowedChars;
    charSetMask.pbPriorityChars = pRecogSettings->pbPriorityChars;
    if (fProbMode) 
    {
        // In probability mode, don't mask off the core recognizers
	    charSet.recmask			= 0xFFFFFFFF;
	    charSet.recmaskPriority	= 0;
        charSet.pbAllowedChars  = NULL;
        charSet.pbPriorityChars = NULL;
    } 
    else
    {
        // In score mode, mask off the core recognizers
        charSet = charSetMask;
    }

	// Get the bounding box for the character
	GetRectGLYPH(pGlyph,&bbox);

    // Try going to the cache
    pCacheResult = LookupRecognizerCache(pvCache, iStroke, cStrokes, &iRecognizer);
    if (pCacheResult != NULL)
    {
        // If it was the Zilla recognizer before, we need to run featurization because
        // of its side-effect of fragmenting the strokes, which crane needs.
        if (iRecognizer == VOLCANO_CONFIG_ZILLA)
        {
            BIGPRIM	rgprim[CPRIMMAX];
            BYTE	aSampleVector[29 * 4];
            ZillaFeaturize(&pGlyph, rgprim, aSampleVector);
        }
        altList = *pCacheResult;
    }
    else 
    {
	    // Invoke Otter or Zilla or any other recognizer that has been specified in the configuration
	    CoreRecognizeChar(&altList, MAX_ALT_LIST, &pGlyph, cRealStrokes, pGuideBox, pRecogSettings, &charSet, &iRecognizer, pSpace);

        // Add it to the cache, since it isn't there already.
        AddRecognizerCache(pvCache, iStroke, cStrokes, iRecognizer, &altList);
    }

// If we're doing an experiment to simulate an optimal otter or zilla, 
// replace the real alt list with a fake one.
#ifdef OPTIMAL_OTTER_ZILLA
	{
		wchar_t dch;
		altList.cAlt = 1;
		altList.aeScore[0] = 0;
		{
			FILE *f = fopen("c:/answer.txt", "r");
			fscanf(f, "%hx", &(altList.awchList[0]));
			fclose(f);
		}
		dch = LocRunUnicode2Dense(&g_locRunInfo, altList.awchList[0]);
		if (dch != LOC_TRAIN_NO_DENSE_CODE) {
			wchar_t fdch = LocRunDense2Folded(&g_locRunInfo, dch);
			if (fdch != 0) dch = fdch;
			altList.awchList[0] = dch;
		} else {
			altList.cAlt = 0;
		}
	}
#endif

	// Get our rough approximation of the probability that this is
	// actually a character.  If zero alternates are returned, then
	// set the space number to -1 as an error flag.
	if (altList.cAlt == 0) {
		*pSpace = -1;
		*pProbIsChar = 0;

		*pnProbAlts = 0;
		*pnScoreAlts = 0;
		goto cleanup;
	}

	// Unfold anything in the alt list which needs it.
	UnfoldCodes(&altList, &charSet);

	// If we couldn't load the probability table, then use the
	// WinCE method to get probabilities.
	if (g_pProbHeader == NULL)
	{
		*pnProbAlts	= GetProbsTsunamiFixedTable(cStrokes, &altList, maxAlts, pProbAlts, &charSetMask);
	}

	// Apply crane, if we have a guide for it to use and we are not in partial mode
	if (pRecogSettings->partialMode == HWX_PARTIAL_ALL && pGuideBox != NULL && altList.cAlt > 0) {
		fCraneBonus = Afterburn(&altList, pGlyph, &charSet, pGuideBox, bbox); 
		// Hack to bypass crane if otter a troublesome kana character
		if (IsFaultyKana(LocRunDense2Unicode(&g_locRunInfo,altList.awchList[0]))) {
			fCraneBonus = FALSE;
		}
	}

    // Save away the scores for the alternates, then apply the weight for the particular
    // recognizer used.  Then add in the crane bonus/penalty and the adhoc rules.
	for (iAlt=0; iAlt<(int)altList.cAlt; iAlt++) 
    {
        int iParam = (fStringMode ? VTUNE_STRING_CORE : VTUNE_CHAR_CORE) + iRecognizer; 
        pTuneScore[iAlt].afl[iParam] = altList.aeScore[iAlt];
		altList.aeScore[iAlt] *= g_vtuneInfo.pTune->weights.afl[iParam];

        // Crane is now implemented as a penalty rather than a bonus.  This means
        // all alternates after the first one get a penalty, and even the first one
        // gets a penalty if no crane bonus is applied.
        if (iAlt > 0 || !fCraneBonus) 
        {
            iParam = fStringMode ? VTUNE_STRING_CRANE : VTUNE_CHAR_CRANE;
		    pTuneScore[iAlt].afl[iParam] = -1;
		    altList.aeScore[iAlt] -= g_vtuneInfo.pTune->weights.afl[iParam];
        }

        // Add adhoc penalties for the one stroke i and j and two stroke circle shapes
        if (pRecogSettings->partialMode == HWX_PARTIAL_ALL)
        {
		    altList.aeScore[iAlt] += AdHocRuleCost(cStrokes, altList.awchList[iAlt], pTuneScore + iAlt);
        }
    }

	// Sort the alternates out.
	SortAltListAndTune(&altList, pTuneScore);

	// Copy the score-based alts to the output
	for (iAlt = 0; iAlt < (int)altList.cAlt && iAlt < (int)maxAlts && iAlt < (int)MAX_ALT_LIST; ++iAlt) 
    {
		pScoreAlts[iAlt].wch	= altList.awchList[iAlt];
		pScoreAlts[iAlt].prob	= altList.aeScore[iAlt];
    }
	*pnScoreAlts = altList.cAlt;

    // Re-score the alternates using the old weightings in the 
    // TTune structure, so that prob table lookup will be weighting
    // independent.
	for (iAlt = 0; iAlt < (int)altList.cAlt; ++iAlt) 
    {
        altList.aeScore[iAlt] = 
            g_vtuneInfo.pTune->weights.afl[VTUNE_ADHOC_IJ] * pTuneScore[iAlt].afl[VTUNE_ADHOC_IJ] +
            g_vtuneInfo.pTune->weights.afl[VTUNE_ADHOC_CIRCLE] * pTuneScore[iAlt].afl[VTUNE_ADHOC_CIRCLE] +
            (cStrokes > 2 ? g_ttuneInfo.pTTuneCosts->ZillaChar.CARTAddWeight :
                            g_ttuneInfo.pTTuneCosts->OtterChar.CARTAddWeight) 
                * pTuneScore[iAlt].afl[fStringMode ? VTUNE_STRING_CRANE : VTUNE_CHAR_CRANE] +
            pTuneScore[iAlt].afl[(fStringMode ? VTUNE_STRING_CORE : VTUNE_CHAR_CORE) + iRecognizer];
	}

	// Build up a BOXINFO structure from the guide, for use in the baseline/height scoring
	if (pGuideBox!=NULL) {
		box.size = pGuideBox->bottom - pGuideBox->top;
		box.baseline = pGuideBox->bottom;
		box.xheight = box.size / 2;
		box.midline = box.baseline - box.xheight;
	}

	// For each alternate
	for (iAlt=0; iAlt<(int)altList.cAlt; iAlt++) {
		float cost;
		// Apply baseline/height and language model unigram scores
		if (cStrokes<3) {
			if (pGuideBox!=NULL) {
				cost = BaselineTransitionCost(0,bbox,&box,altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->OtterChar.BaseWeight;
				altList.aeScore[iAlt] += cost;

				cost = BaselineBoxCost(altList.awchList[iAlt],bbox,&box) 
						* g_ttuneInfo.pTTuneCosts->OtterChar.BoxBaselineWeight;
				altList.aeScore[iAlt] += cost;

				cost = HeightTransitionCost(0,bbox,&box,altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->OtterChar.HeightWeight;
				altList.aeScore[iAlt] += cost;

				cost = HeightBoxCost(altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->OtterChar.BoxHeightWeight;
				altList.aeScore[iAlt] += cost;
			}
			cost = UnigramCost(&g_unigramInfo,altList.awchList[iAlt])
					* g_ttuneInfo.pTTuneCosts->OtterChar.UniWeight;
			altList.aeScore[iAlt] += cost;
		} else {
			if (pGuideBox!=NULL) {
				cost = BaselineTransitionCost(0,bbox,&box,altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->ZillaChar.BaseWeight;
				altList.aeScore[iAlt] += cost;

				cost = BaselineBoxCost(altList.awchList[iAlt],bbox,&box) 
						* g_ttuneInfo.pTTuneCosts->ZillaChar.BoxBaselineWeight;
				altList.aeScore[iAlt] += cost;

				cost = HeightTransitionCost(0,bbox,&box,altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->ZillaChar.HeightWeight;
				altList.aeScore[iAlt] += cost;

				cost = HeightBoxCost(altList.awchList[iAlt],bbox,&box)
						* g_ttuneInfo.pTTuneCosts->ZillaChar.BoxHeightWeight;
				altList.aeScore[iAlt] += cost;

			}
			cost = UnigramCost(&g_unigramInfo,altList.awchList[iAlt])
					* g_ttuneInfo.pTTuneCosts->ZillaChar.UniWeight;
			altList.aeScore[iAlt] += cost;

			// Zilla scores get fudged
			altList.aeScore[iAlt] *= g_ttuneInfo.pTTuneCosts->ZillaStrFudge;
		}

		// If context was available for this character, then use the bigram/class bigram scores
		if (dchContext != SYM_UNKNOWN && dchContext != 0) {
#if !defined(WINCE) && !defined(FAKE_WINCE)
			cost = BigramTransitionCost(&g_locRunInfo,&g_bigramInfo,dchContext,altList.awchList[iAlt])
					* g_ttuneInfo.pTTuneCosts->BiWeight;
			altList.aeScore[iAlt] += cost;
#endif

			cost = ClassBigramTransitionCost(&g_locRunInfo,&g_classBigramInfo,dchContext,altList.awchList[iAlt])
					* g_ttuneInfo.pTTuneCosts->BiClassWeight;
			altList.aeScore[iAlt] += cost;
		}
	}

	// Sort the resulting alternates
	SortAltList(&altList);

	// This is a temporary call to get probs directly, until we have Hawk.
	if (g_pProbHeader != NULL)
	{
		*pnProbAlts	= GetProbsTsunami(cStrokes, &altList, maxAlts, pProbAlts, &charSetMask);
	}
#if 0
    {
        FILE *f=fopen("c:/temp/prob.log","a+");
        fprintf(f,"%04X %g -> %04X %g\n", altList.awchList[0], altList.aeScore[0],
            pProbAlts[0].wch, pProbAlts[0].prob);
        fclose(f);
    }
#endif

//#define TEST_FOR_PATRICKH
#ifdef TEST_FOR_PATRICKH
	{
		int i;
		for (i=0; i<*pnProbAlts && i<(int)altList.cAlt; i++) 
			pProbAlts[i].wch = altList.awchList[i];
		*pnProbAlts = i;
	}
#endif

cleanup:
	// Free the glyph structure.
	DestroyFramesGLYPH(pGlyph);
	DestroyGLYPH(pGlyph);

	return *pnProbAlts;
}

#else

// Version of Afterburn to call Hawk.
int Afterburn(
	ALT_LIST	*pAltList,		// Input used to select correct CART tree
	GLYPH		*pGlyph,
	CHARSET		*cs,
	RECT		*rGuide,
	int			otterSpace,
	UINT		maxAlts,		// Size of alts array supplied.
	RECOG_ALT	*pAlts			// Out: alternate list matched.
) {
	UINT		ii;
    UINT iDest;
//    UINT        jj, kk;
	BASICINFO	basicInfo;
	FEATINFO	featInfo;
	HANDLE		hCartTree;
	QALT		aQAlt[MAX_RECOG_ALTS];
	UINT		cQAlt;
#if 0
	double		aWeights[MAX_ALT_LIST];
	double		fSum;
	double		offset;
FILE *pFile;
#endif

	RECT		bbox;
	DRECTS		drcs;

	if (pGlyph == NULL) {
		return -1;
	}

	// Get the bounding box for the character
	GetRectGLYPH(pGlyph, &bbox);

	// Scale and translate the guide box to compute the 'delta rectangle'
	if (rGuide == NULL) {
		// No guide given,  This is the current assumption.
		drcs.x = 0;
		drcs.y = 0;
		drcs.w = 1000;
		drcs.h = 1000;
	} else {
		// Actually got a guide, pass it on.  Current code ignores the
		// guide, but may add it back so don't lose code path.
		drcs.x = rGuide->left;
		drcs.y = rGuide->top;
		drcs.w = rGuide->right - rGuide->left;
		drcs.h = rGuide->bottom - rGuide->top;
	}

	// Translate, convert to delta form
	bbox.left   -= drcs.x;
	bbox.top    -= drcs.y;
	bbox.right  -= (drcs.x + bbox.left);
	bbox.bottom -= (drcs.y + bbox.top);

	// Scale.  We do isotropic scaling and center the shorter dimension.
	if (drcs.w > drcs.h) {
		drcs.x = ((1000 * bbox.left) / drcs.w);
		drcs.y = ((1000 * bbox.top) / drcs.w) + ((drcs.w - drcs.h) / 2);
		drcs.h = ((1000 * bbox.bottom) / drcs.w);
		drcs.w = ((1000 * bbox.right) / drcs.w);
	} else {
		drcs.x = ((1000 * bbox.left) / drcs.h) + ((drcs.h - drcs.w) / 2);
		drcs.y = ((1000 * bbox.top) / drcs.h);
		drcs.w = ((1000 * bbox.right) / drcs.h);
		drcs.h = ((1000 * bbox.bottom) / drcs.h);
	}

	// Fill in basic info.
	//	basicInfo.cStrk -- Filed in by MakeFeatures.
	basicInfo.cSpace	= (short)otterSpace;
	basicInfo.drcs		= drcs;

	// Fill in feature info.
	if (!MakeFeatures(&basicInfo, &featInfo, pGlyph)) {
		return -1;
	}

#if 1
	// Find cart tree
	hCartTree	= (HANDLE)0;
	for (ii = 0; !hCartTree && ii < pAltList->cAlt; ++ii) {
		hCartTree	= HawkFindTree(basicInfo.cStrk, basicInfo.cSpace, pAltList->awchList[ii]);
	}
	if (!hCartTree) {
		// No cart tree for anything in the alt list!?!?!
		return -1;
	}

	// Do the match.
	//HawkMatch(pAltList, MAX_ALT_LIST, pGlyph, cs, &drcs, eCARTWeight, &g_locRunInfo);
	cQAlt	= HawkMatch(&basicInfo, &featInfo, hCartTree, aQAlt);

    // Copy out the alt list, applying the ALC
    iDest = 0;
	for (ii = 0; ii < cQAlt && iDest < maxAlts; ++ii) 
    {
        if (IsAllowedChar(&g_locRunInfo, cs, aQAlt[ii].dch)) 
        {
		    pAlts[iDest].wch	= aQAlt[ii].dch;
		    pAlts[iDest].prob	= aQAlt[ii].prob;
            iDest++;
        }
	}
    cQAlt = iDest;
#elif 0

	// Select stroke dependent offset used to compute weights below.
	switch (basicInfo.cStrk) {
	case 1 :	offset	= .01;	break;
	case 2 :	offset	= .05;	break;
	default :	offset	= .05;	break;
	}

	// Compute wighting to apply to each trees results.
	fSum	= 0.0;
	for (ii = 0; ii < pAltList->cAlt; ++ii) {
		double ratio;
		
		ratio			= offset / (offset + pAltList->aeScore[0] - pAltList->aeScore[ii]);
		aWeights[ii]	= ratio * ratio * ratio;
		fSum			+= aWeights[ii];
	}

	// Normalize to sum to one.
	for (ii = 0; ii < pAltList->cAlt; ++ii) {
		aWeights[ii]	/= fSum;
	}

pFile = fopen("AltList.dump", "a");
fprintf(pFile, "Start Dump:\n");
	// Find each cart tree and add results to list.
	hCartTree	= (HANDLE)0;
	cQAlt		= 0;
	for (ii = 0; ii < pAltList->cAlt && cQAlt < maxAlts; ++ii) {
		hCartTree	= HawkFindTree(basicInfo.cStrk, basicInfo.cSpace, pAltList->awchList[ii]);
		if (hCartTree) {
			UINT	cQAltNew;
			SCORE	penalty;
			int		skipped;

			// Do the match.
			cQAltNew	= HawkMatch(&basicInfo, &featInfo, hCartTree, aQAlt);

			// How much can we add?
			if (cQAltNew > maxAlts - cQAlt) {
				cQAltNew	= maxAlts - cQAlt;
			}

			// Convert our weight (Probability) to a log prob.
			penalty		= ProbToScore(aWeights[ii]);

			// Zilla overgenerates prototypes, so look for different top one from 
			// additional trees.
			if (ii > 0 && basicInfo.cStrk >= 3 && aQAlt[0].dch == pAlts[0].wch) {
				continue;
			}

			// Add to list.
			skipped	= 0;
			for (jj = 0; jj < cQAltNew; ++jj) {
				SCORE	newScore;

				// Check for duplicates in the alternate list.  Each individual list has not
				// dups, so we don't have to check them.
				newScore	= aQAlt[jj].prob + penalty;
fprintf(pFile, "  %04X:%d->%d", LocRunDense2Unicode(&g_locRunInfo,aQAlt[jj].dch),aQAlt[jj].prob,newScore);
				for (kk = 0; kk < cQAlt; ++kk) {
					if (aQAlt[jj].dch == pAlts[kk].wch) {
						ASSERT(pAlts[kk].prob == (float)(int)pAlts[kk].prob);
						pAlts[kk].prob	= ScoreAddProbs((SCORE)pAlts[kk].prob, newScore);
						++skipped;
						goto noAdd;
					}
				}
				pAlts[jj - skipped + cQAlt].wch		= aQAlt[jj].dch;
				pAlts[jj - skipped + cQAlt].prob	= (float)newScore;
noAdd:			;
			}
fprintf(pFile, "\n");

			cQAlt	+= cQAltNew - skipped;
		}
	}
for (kk = 0; kk < cQAlt; ++kk) {
	fprintf(pFile, "  %04X:%g", LocRunDense2Unicode(&g_locRunInfo,pAlts[kk].wch),pAlts[kk].prob);
}
fprintf(pFile, "\n");
fprintf(pFile, "End Dump\n");
fclose(pFile);

#else

	// Select stroke dependent offset used to compute weights below.
	switch (basicInfo.cStrk) {
	case 1 :	offset	= 1.0;	break;
	case 2 :	offset	= 1.0;	break;
	default :	offset	= 1.0;	break;
	}

pFile = fopen("AltList.dump", "a");
fprintf(pFile, "Start Dump:\n");
	// Find each cart tree and add results to list.
	hCartTree	= (HANDLE)0;
	cQAlt		= 0;
	for (ii = 0; ii < pAltList->cAlt && cQAlt < maxAlts; ++ii) {
		hCartTree	= HawkFindTree(basicInfo.cStrk, basicInfo.cSpace, pAltList->awchList[ii]);
		if (hCartTree) {
			UINT	cQAltNew;
			SCORE	penalty;
			int		skipped;

			// Do the match.
			cQAltNew	= HawkMatch(&basicInfo, &featInfo, hCartTree, aQAlt);

			// How much can we add?
			if (cQAltNew > maxAlts - cQAlt) {
				cQAltNew	= maxAlts - cQAlt;
			}

			// Convert our weight (Probability) to a log prob.
			penalty		= (SCORE)((pAltList->aeScore[0] - pAltList->aeScore[ii]) * 2040);

			// Zilla overgenerates prototypes, so look for different top one from 
			// additional trees.
			if (ii > 0 && basicInfo.cStrk >= 3 && aQAlt[0].dch == pAlts[0].wch) {
				continue;
			}

			// Add to list.
			skipped	= 0;
			for (jj = 0; jj < cQAltNew; ++jj) {
				SCORE	newScore;

				// Check for duplicates in the alternate list.  Each individual list has not
				// dups, so we don't have to check them.
				newScore	= aQAlt[jj].prob + penalty;
fprintf(pFile, "  %04X:%d->%d", LocRunDense2Unicode(&g_locRunInfo,aQAlt[jj].dch),aQAlt[jj].prob,newScore);
				for (kk = 0; kk < cQAlt; ++kk) {
					if (aQAlt[jj].dch == pAlts[kk].wch) {
						ASSERT(pAlts[kk].prob == (float)(int)pAlts[kk].prob);
						pAlts[kk].prob	= ScoreAddProbs((SCORE)pAlts[kk].prob, newScore);
						++skipped;
						goto noAdd;
					}
				}
				pAlts[jj - skipped + cQAlt].wch		= aQAlt[jj].dch;
				pAlts[jj - skipped + cQAlt].prob	= (float)newScore;
noAdd:			;
			}
fprintf(pFile, "\n");

			cQAlt	+= cQAltNew - skipped;
		}
	}
for (kk = 0; kk < cQAlt; ++kk) {
	fprintf(pFile, "  %04X:%g", LocRunDense2Unicode(&g_locRunInfo,pAlts[kk].wch),pAlts[kk].prob);
}
fprintf(pFile, "\n");
fprintf(pFile, "End Dump\n");
fclose(pFile);

#endif

    FreeFeatures(&featInfo);

	return cQAlt;
}

#endif

#ifndef USE_OLD_DATABASES
// Do the recognition.
INT
RecognizeChar(
	RECOG_SETTINGS	*pRecogSettings,// Setting for recognizers.
	UINT			cStrokes,		// Number of strokes to process.
	UINT			cRealStrokes,	// Number of strokes before merging
	STROKE			*pStrokes,		// Array of strokes to process.
	FLOAT			*pProbIsChar,	// Out: probability of being valid char.
	UINT			maxAlts,		// Size of alts array supplied.
	RECOG_ALT		*pAlts,			// Out: alternate list matched.
	RECT			*pGuideBox,		// Guide box for this ink.
	int				*pCount
) {
	INT				cAlts;
	GLYPH			*pGlyph;
	ALT_LIST		altList;
	CHARSET			charSet;
    int             iRecognizer;

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.
	pGlyph	= GlyphFromStrokes(cStrokes, pStrokes);
	if (!pGlyph) {
		return -1;
	}

	// Run otter or zilla as needed.
	// a possible optimization would be Switch to proto matching versions of match calls
	altList.cAlt			= 0;

	charSet.recmask			= 0xFFFFFFFF;
	charSet.recmaskPriority	= 0;
    charSet.pbAllowedChars  = NULL;
    charSet.pbPriorityChars = NULL;

    // Invoke Otter or Zilla or any other recognizer that has been specified in the configuration
	CoreRecognizeChar(&altList, MAX_ALT_LIST, &pGlyph, cRealStrokes, pGuideBox, pRecogSettings, &charSet, &iRecognizer, pCount);

	charSet.recmask			= pRecogSettings->alcValid;
	charSet.recmaskPriority	= pRecogSettings->alcPriority;
    charSet.pbAllowedChars  = pRecogSettings->pbAllowedChars;
    charSet.pbPriorityChars = pRecogSettings->pbPriorityChars;

    if (pRecogSettings->partialMode != HWX_PARTIAL_ALL) {
        unsigned int ii;

		// Unfold anything in the alt list which needs it.
		UnfoldCodes(&altList, &charSet);

		// Copy over the alt list.
		// Note that we don't have probabilities, and they don't
		// really make sense anyway.  However the code that
		// follows will discard items with a prob of zero, so 
		// they should be set to something.
		for (ii = 0; ii < maxAlts && ii < altList.cAlt; ++ii) {
			pAlts[ii].wch	= altList.awchList[ii];
			pAlts[ii].prob	= -altList.aeScore[ii];
		}

		// Free the glyph structure.
		DestroyFramesGLYPH(pGlyph);
		DestroyGLYPH(pGlyph);

		return ii;
	}

	// Get our rough approximation of the probability that this is
	// actually a character.
	*pProbIsChar	= altList.aeScore[0];

    // Run Hawk.
#ifndef DISABLE_HEURISTICS
	cAlts	= Afterburn(&altList, pGlyph, &charSet, pGuideBox, *pCount, maxAlts, pAlts);
#else
    {
        unsigned int ii;
		UnfoldCodes(&altList, &charSet);
		for (ii = 0; ii < maxAlts && ii < altList.cAlt; ii++) 
        {
			pAlts[ii].wch	= altList.awchList[ii];
			pAlts[ii].prob	= -altList.aeScore[ii];
		}
        cAlts = ii;
    }
#endif

	// Free the glyph structure.
	DestroyFramesGLYPH(pGlyph);
	DestroyGLYPH(pGlyph);

	return cAlts;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\boxapi.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/BoxApi.c
//
// Description:
//	    Implement external Box input API for DLL.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <stdlib.h>

#include "volcanop.h"
#include "zillap.h"
#include "fugu.h"
#if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
#	include "math16.h"
#	include "hound.h"
#endif

#include "tpgHandle.h"

// Sanity check limits on guide structures.
#define	GUIDE_MIN_COORD	((INT)0xC0000000)
#define	GUIDE_MAX_COORD	((INT)0x3FFFFFFF)
#define	GUIDE_MIN_BOXES	1
#define GUIDE_MAX_BOXES	(32 * 1024)
#define	GUIDE_MIN_SIZE	8
#define	GUIDE_MAX_SIZE	(256 * 1024)

// iUseCount tells if we have successfully loaded and is incremented to 1 when that happens.
static int g_iUseCount = 0;

// COM code for IFELang3
#ifdef USE_IFELANG3
#	include <windows.h>
#	include <ole2.h>
#	include <objbase.h>
	// Make sure the GUIDs defined in imlang.h actually get instantiated
#	define INITGUID
#	include "imlang.h"
#endif

// g_hInstanceDll is refered to to load resources.
HINSTANCE			g_hInstanceDll;

// g_hInstanceDllCode is refered to to find the code DLL..
HINSTANCE			g_hInstanceDllCode;

// Global data loaded by LoadCharRec.
LOCRUN_INFO			g_locRunInfo;

// What language the recognizer is recognizing
wchar_t *g_szRecognizerLanguage=NULL;

//#define DEBUG_LOG_API

#ifdef DEBUG_LOG_API
#include <stdio.h>

static void LogMessage(char *format, ...)
{
	FILE *f=fopen("c:/log.txt","a");
    va_list marker;
    va_start(marker,format);
	vfprintf(f,format,marker);
    va_end(marker);
	fclose(f);
}
#else
static void LogMessage(char *format, ...)
{
    va_list marker;
    va_start(marker,format);
    va_end(marker);
}
#endif

// Forward declaration for function to unload the recognizer
// Unload the recognizer.  The flag indicates whether we should try to unload IFELang3
// as well.  This flag should usually be TRUE, but must be FALSE during a call from DllMain(),
// because it is not safe to do COM operations inside DllMain().
BOOL HwxUnconfig(BOOL fCanUnloadIFELang3);

static CRITICAL_SECTION g_csRecognizer = {0}; 
static BOOL g_bInitializedRecognizerCS = FALSE;

// Capture the dll handle, also handle unloading.
BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH) 
	{
		// If we are using resources and they are in another DLL, we need to load that DLL.
#	if defined(USE_RESOURCES)
		wchar_t		aFileName[_MAX_PATH];
		int			length;

		// Build up name of data DLL from the name of this DLL.  We replace .DLL with R.DLL.
		length	= GetModuleFileName(hDll, aFileName, _MAX_PATH);
		if (length < 5 || _MAX_PATH - 1 < length) 
		{
			ASSERT(length >= 5);
			return FALSE;
		}
		wcscpy(aFileName + length - 4, L"R.DLL");

		// Load the data library.
		g_hInstanceDll	= LoadLibraryEx(aFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
		ASSERT(g_hInstanceDll);

		// If we can't find our resources, just give up. Nothing will work.
		if (!g_hInstanceDll) 
		{
			return FALSE;
		}

		if (!InitializeCriticalSectionAndSpinCount(&g_csRecognizer, 4000)) 
		{
			return FALSE;
		}
		else
		{
			g_bInitializedRecognizerCS = TRUE;
		}
#	else
		g_hInstanceDll	= hDll;
#	endif

		// init the handle manager
		if (FALSE == initTpgHandleManager())
		{
			return FALSE;
		}

		// Always let the Wisp code know where the code DLL is.
		g_hInstanceDllCode	= hDll;
	} 
	else if (dwReason == DLL_PROCESS_DETACH) 
	{
		BOOL	fRet;

		// If we haven't cleaned up.
		// In the future, we should force g_iUseCount to be zero, to make
		// sure the client has cleaned us up properly.  Until everyone is
		// using the WISP API we cannot enforce this, because the old API
		// has no "clean up" call.
		// ASSERT(g_iUseCount == 0);
		if (g_iUseCount > 0) 
		{
			// Set the use count to 1 to force a cleanup
			g_iUseCount = 1;
			// Clean up, but don't do COM calls to discard IFELang3,
			// because we can't make COM calls inside DllMain.
			fRet	= HwxUnconfig(FALSE);
		} 
		else 
		{
			// If we have already cleaned up, return 
			fRet	= TRUE;
		}

#	if defined(USE_RESOURCES)
		if (!FreeLibrary(g_hInstanceDll))
		{
			fRet	= FALSE;
		}
		if (g_bInitializedRecognizerCS)
		{
			DeleteCriticalSection(&g_csRecognizer);
			g_bInitializedRecognizerCS = FALSE;
		}
#	endif

		// close the handle manager
		closeTpgHandleManager();

		return fRet;
	}

	return	TRUE;
}

// HwxConfig
//
// Initialize the recognizer when it loads.
#ifdef USE_RESOURCES

#include "res.h"

BOOL HwxConfig()
{
	const ZILLADB_HEADER *pHeader;

	EnterCriticalSection(&g_csRecognizer);

	LogMessage("HwxConfig()\n");

	if (g_iUseCount > 0) {
		goto exitSuccess;
	}

    // Load the Locale database.
	if (!LocRunLoadRes(
		&g_locRunInfo, g_hInstanceDll, RESID_LOCRUN, VOLCANO_RES
	)) {
		ASSERT(("Error in LocRunLoadRes", FALSE));
		goto exitFailure;
	}

	// Load the recognizer databases.
	if (!LoadCharRec(g_hInstanceDll)) {
		ASSERT(("Error in LoadCharRec", FALSE));
		goto exitFailure;
	}

	pHeader = (ZILLADB_HEADER*)DoLoadResource(NULL, g_hInstanceDll, RESID_ZILLA, VOLCANO_RES);
	if (pHeader == NULL) {
		ASSERT(("Couldn't load zilla database", FALSE));
		goto exitFailure;
	}
	g_szRecognizerLanguage = ExternAlloc(sizeof(wchar_t) * (wcslen(pHeader->locale) + 1));
	if (g_szRecognizerLanguage == NULL) {
		ASSERT(("Couldn't generate recognizer language string", FALSE));
		goto exitFailure;
	}
    wcscpy(g_szRecognizerLanguage, pHeader->locale);

    // Configure the factoid table
    if (!FactoidTableConfig(&g_locRunInfo, g_szRecognizerLanguage))
    {
	    goto exitFailure;
    }

	// Configure the lattice code.
	if (!LatticeConfig(g_hInstanceDll)) {
		ASSERT(("Error in LatticeConfig", FALSE));
		goto exitFailure;
	}

exitSuccess:
	g_iUseCount++;
	LeaveCriticalSection(&g_csRecognizer);
	return TRUE;

exitFailure:
	LeaveCriticalSection(&g_csRecognizer);
	return FALSE;
}

// Unload the recognizer.  The flag indicates whether we should try to unload IFELang3
// as well.  This flag should usually be TRUE, but must be FALSE during a call from DllMain(),
// because it is not safe to do COM operations inside DllMain().
BOOL HwxUnconfig(BOOL fCanUnloadIFELang3)
{
	BOOL ok = TRUE;

	EnterCriticalSection(&g_csRecognizer);

	if (g_iUseCount == 0) {
		ASSERT(("HwxUnconfig() called more times that HwxConfig()\n", 0));
		LeaveCriticalSection(&g_csRecognizer);
		return FALSE;
	}
	g_iUseCount--;
	if (g_iUseCount == 0)
	{
		if (g_szRecognizerLanguage != NULL) 
		{
			ExternFree(g_szRecognizerLanguage);
		}
		if (!UnloadCharRec()) ok = FALSE;
		if (!LatticeUnconfig()) ok = FALSE;
#ifdef USE_IFELANG3
		if (fCanUnloadIFELang3 && !LatticeUnconfigIFELang3()) ok = FALSE;
#endif
		FactoidTableUnconfig();
	}
	LeaveCriticalSection(&g_csRecognizer);
	return ok;
}

#	else

BOOL HwxConfigEx(wchar_t *pLocale, wchar_t *pLocaleDir, wchar_t *pRecogDir)
{
	LogMessage("HwxConfigEx()\n");

	if (g_iUseCount > 0) {
		g_iUseCount++;
		return(TRUE);
	}

	g_szRecognizerLanguage = ExternAlloc(sizeof(wchar_t) * (wcslen(pLocale) + 1));
	if (g_szRecognizerLanguage==NULL) {
        ASSERT(("Out of memory copying recognizer language", FALSE));
		return FALSE;
	}
    wcscpy(g_szRecognizerLanguage, pLocale);

    // Load the Locale database.
	if (!LocRunLoadFile(&g_locRunInfo, pRecogDir)) {
		ASSERT(("Error in LocRunLoadFile", FALSE));
		return FALSE;
	}

    // Configure the factoid table
    if (!FactoidTableConfig(&g_locRunInfo, g_szRecognizerLanguage))
    {
        return FALSE;
    }

    // Load the recognizer databases.
    // They are loaded in this order: otter, zilla, crane/prob or hawk, 
	if (!LoadCharRec(pRecogDir)) {
		ASSERT(("Error in LoadCharRec", FALSE));
		return FALSE;
	}

	// Configure the lattice code.
    // Loads the following databases: unigrams, bigrams, class bigrams, tuning, centipede, free input
	if (!LatticeConfigFile(pRecogDir)) {
		ASSERT(("Error in LatticeConfig", FALSE));
		return FALSE;
	}

	g_iUseCount++;

	return TRUE;
}

// Initialize the recognizer partially.
// When iLevel is set to 0, only the locale database, tuning database, 
// otter and zilla (and other core recognizers) are loaded. 
// When iLevel is set to 1, all the above databases are loaded, as well as 
// unigrams and crane/hawk.
BOOL HwxConfigExPartial(wchar_t *pLocale, wchar_t *pRecogDir, int iLevel)
{
    extern OTTER_LOAD_INFO  g_OtterLoadInfo;
    extern FUGU_LOAD_INFO g_FuguLoadInfo;
    extern JAWS_LOAD_INFO g_JawsLoadInfo;
    extern SOLE_LOAD_INFO g_SoleLoadInfo;
#if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
	extern LOAD_INFO	g_HoundLoadInfo;
#endif
#ifdef USE_OLD_DATABASES
    extern CRANE_LOAD_INFO  g_CraneLoadInfo;
#else
    extern LOAD_INFO        g_HawkLoadInfo;
#endif

	LogMessage("HwxConfigExPartial()\n");

	if (g_iUseCount > 0) {
		g_iUseCount++;
		return(TRUE);
	}

	g_szRecognizerLanguage = ExternAlloc(sizeof(wchar_t) * (wcslen(pLocale) + 1));
	if (g_szRecognizerLanguage==NULL) {
        ASSERT(("Out of memory copying recognizer language", FALSE));
		return FALSE;
	}
    wcscpy(g_szRecognizerLanguage, pLocale);

    LatticeConfigInit();

    if (iLevel >= 0) {
        // Load the Locale database.
	    if (!LocRunLoadFile(&g_locRunInfo, pRecogDir)) {
		    ASSERT(("Error in LocRunLoadFile", FALSE));
		    return FALSE;
	    }

        // Configure the factoid table
        if (!FactoidTableConfig(&g_locRunInfo, g_szRecognizerLanguage))
        {
            return FALSE;
        }

        // Load the tuning info
        if (!VTuneLoadFile(&g_vtuneInfo, pRecogDir)) {
		    ASSERT(("Error in VTuneLoadFile", FALSE));
            return FALSE;
        }

        // Load the tuning info
        if (!TTuneLoadFile(&g_ttuneInfo, pRecogDir)) {
		    ASSERT(("Error in TTuneLoadFile", FALSE));
            return FALSE;
        }

        if (JawsLoadFile(&g_JawsLoadInfo, pRecogDir)) 
        {
            // Load the Fugu database
            if (!FuguLoadFile(&g_FuguLoadInfo, pRecogDir, &g_locRunInfo))
            {
		        ASSERT(("Error in FuguLoadFile", FALSE));
                return FALSE;
            }
            // Load the Sole database
            if (!SoleLoadFile(&g_SoleLoadInfo, pRecogDir, &g_locRunInfo)) 
            {
		        ASSERT(("Error in SoleLoadFile", FALSE));
                return FALSE;
            }
            g_fUseJaws = TRUE;
        }
        else
        {
	        // Load the Otter database
	        if (!OtterLoadFile(&g_locRunInfo, &g_OtterLoadInfo, pRecogDir))
            {
		        ASSERT(("Error in OtterLoadFile", FALSE));
                return FALSE;
	        }
            g_fUseJaws = FALSE;
        }

#if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
	    // Load the Zilla database
	    if (!ZillaLoadFile(&g_locRunInfo, pRecogDir, TRUE)) {
		    ASSERT(("Error in ZillaLoadFile", FALSE));
            return FALSE;
	    }
#endif

#if defined(USE_HOUND)
		// Load the Hound database
		if (!HoundLoadFile(&g_locRunInfo, &g_HoundLoadInfo, pRecogDir)) {
			ASSERT(("Error in HoundLoadFile", FALSE));
            return FALSE;
		}
#endif

	    g_fUseZillaHound	= FALSE;
#if defined(USE_ZILLAHOUND)
		// Load the Hound & Hound-Zilla databases (This is optional).
		if (HoundLoadFile(&g_locRunInfo, &g_HoundLoadInfo, pRecogDir)) {
			if (ZillaHoundLoadFile(pRecogDir)) {
				g_fUseZillaHound	= TRUE;
			}
			else
			{
				HoundUnLoadFile(&g_HoundLoadInfo);
			}
		}
#endif
    }

    if (iLevel >= 1) {
        // Load unigrams
        if (!UnigramLoadFile(&g_locRunInfo, &g_unigramInfo, pRecogDir)) {
            ASSERT(("Error in UnigramLoadFile", FALSE));
            return FALSE;
        }

#ifndef USE_OLD_DATABASES
	    // Load the Hawk database.
	    if (!HawkLoadFile(&g_locRunInfo, &g_HawkLoadInfo, pRecogDir)) {
		    ASSERT(("Error in HawkLoadFile", FALSE));
            return FALSE;
	    }
#else
        // Load Crane
	    if (!CraneLoadFile(&g_locRunInfo,&g_CraneLoadInfo, pRecogDir)) {
		    ASSERT(("Error in CraneLoadFile", FALSE));
            return FALSE;
	    }
#endif
    }

    g_iUseCount++;

	return TRUE;
}

// Unload the recognizer.  The flag indicates whether we should try to unload IFELang3
// as well.  This flag should usually be TRUE, but must be FALSE during a call from DllMain(),
// because it is not safe to do COM operations inside DllMain().
BOOL HwxUnconfig(BOOL fCanUnloadIFELang3)
{
	BOOL ok = TRUE;
	if (g_iUseCount == 0) {
		ASSERT(("HwxUnconfig() called more times that HwxConfig()\n", 0));
		return FALSE;
	}
	g_iUseCount--;
	if (g_iUseCount > 0) return TRUE;
	if (g_szRecognizerLanguage != NULL) 
    {
		ExternFree(g_szRecognizerLanguage);
	}
	if (!LocRunUnloadFile(&g_locRunInfo)) ok = FALSE;
	if (!UnloadCharRec()) ok = FALSE;
	if (!LatticeUnconfigFile()) ok = FALSE;
#ifdef USE_IFELANG3
	if (fCanUnloadIFELang3 && !LatticeUnconfigIFELang3()) ok = FALSE;
#endif
    FactoidTableUnconfig();
	return ok;
}

#	endif

////
//	HwxCreate
//
//	Create an HRC.
////
HRC HwxCreate(HRC hrcTemplate)
{
	VRC		*pVRC;

	LogMessage("HwxCreate(%08X)\n",hrcTemplate);

	// Alloc the VRC.
	pVRC	= ExternAlloc(sizeof(VRC));
	if (!pVRC) {
		SetLastError(ERROR_OUTOFMEMORY);
		goto error1;
	}

	// Initialize it.
	pVRC->fBoxedInput	= TRUE;
	pVRC->fHaveInput	= FALSE;
	pVRC->fEndInput		= FALSE;
	pVRC->fBeginProcess = FALSE;
	pVRC->pLatticePath	= (LATTICE_PATH *)0;

	if (!hrcTemplate) {
		pVRC->pLattice	= AllocateLattice();
		if (!pVRC->pLattice) {
			SetLastError(ERROR_OUTOFMEMORY);
			goto error2;
		}
	} else {
		VRC		*pVRCTemplate	= (VRC *)hrcTemplate;

		if (!pVRCTemplate->pLattice || !pVRCTemplate->fBoxedInput) {
			SetLastError(ERROR_INVALID_HANDLE);
		}

		pVRC->pLattice	= CreateCompatibleLattice(
			pVRCTemplate->pLattice
		);
		if (!pVRC->pLattice) {
			SetLastError(ERROR_OUTOFMEMORY);
			goto error2;
		}
	}

	LogMessage("HwxCreate(%08X) -> %08X\n", hrcTemplate, pVRC);
	// Success, cast to HRC and return it.
    return (HRC)pVRC;

error2:
	ExternFree(pVRC);

error1:
	return (HRC)0;
}

////
//	HwxDestroy
//
//	Destroy an HRC.
////
BOOL HwxDestroy(HRC hrc)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("HwxDestroy(%08X)\n",hrc);

	// Did we get a handle?  Is if a free input handle?
	if (!hrc || !pVRC->fBoxedInput) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	
	// Free the lattice.  Should it be an error if there is not one?
	if (pVRC->pLattice) {
		FreeLattice(pVRC->pLattice);
	} else {
		ASSERT(pVRC->pLattice);
	}

	// Free the lattice path.
	if (pVRC->pLatticePath) {
		FreeLatticePath(pVRC->pLatticePath);
	}

	// Free the VRC itself.
	ExternFree(pVRC);

    return	TRUE;
}

////
//	HwxSetGuide
//
//	Sets the guide structure to use.
////
BOOL HwxSetGuide(HRC hrc, HWXGUIDE *pGuide)
{
	VRC		*pVRC = (VRC *)hrc;

	LogMessage("HwxSetGuide(%08X,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)\n", hrc,
		pGuide->cHorzBox,
		pGuide->cVertBox,
		pGuide->xOrigin,
		pGuide->yOrigin,
		pGuide->cxBox,
		pGuide->cyBox,
		pGuide->cxOffset,
		pGuide->cyOffset,
		pGuide->cxWriting,
		pGuide->cyWriting,
		pGuide->cyMid,
		pGuide->cyBase,
		pGuide->nDir);

	// Did we get a handle?  Does it have a lattice?
	if (!hrc || !pVRC->pLattice || !pVRC->fBoxedInput) 
    {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

    // Make sure that we haven't begun receiving input
    if (pVRC->fHaveInput || pVRC->fEndInput) 
    {
	    SetLastError(ERROR_CAN_NOT_COMPLETE);
	    return FALSE;
    }

	// Validate the individual GUIDE values are not totally out of bounds.
	if ((pGuide == (HWXGUIDE *)NULL)          ||
	    (pGuide->cHorzBox  < GUIDE_MIN_BOXES) || (GUIDE_MAX_BOXES < pGuide->cHorzBox)  ||
	    (pGuide->cVertBox  < GUIDE_MIN_BOXES) || (GUIDE_MAX_BOXES < pGuide->cVertBox)  ||
	    (pGuide->xOrigin   < GUIDE_MIN_COORD) || (GUIDE_MAX_COORD < pGuide->xOrigin)   ||
	    (pGuide->yOrigin   < GUIDE_MIN_COORD) || (GUIDE_MAX_COORD < pGuide->yOrigin)   ||
		                                         (GUIDE_MAX_SIZE  < pGuide->cxOffset)  ||
		                                         (GUIDE_MAX_SIZE  < pGuide->cyOffset)  ||
	    (pGuide->cxBox     < GUIDE_MIN_SIZE)  || (GUIDE_MAX_SIZE  < pGuide->cxBox)     ||
	    (pGuide->cyBox     < GUIDE_MIN_SIZE)  || (GUIDE_MAX_SIZE  < pGuide->cyBox)     ||
	    (pGuide->cxWriting < GUIDE_MIN_SIZE)  || (GUIDE_MAX_SIZE  < pGuide->cxWriting) ||
	    (pGuide->cyWriting < GUIDE_MIN_SIZE)  || (GUIDE_MAX_SIZE  < pGuide->cyWriting) ||
		                                         (GUIDE_MAX_SIZE  < pGuide->cyMid)     ||
		                                         (GUIDE_MAX_SIZE  < pGuide->cyBase)    ||
	    (pGuide->nDir != HWX_HORIZONTAL)
	) {
	    SetLastError(ERROR_CAN_NOT_COMPLETE);
	    return FALSE;
	}

	// Now that we know the values make some sense, we can check for internal consistancy.
	if ((((GUIDE_MAX_COORD - pGuide->xOrigin) / pGuide->cHorzBox) < pGuide->cxBox) ||
		(((GUIDE_MAX_COORD - pGuide->yOrigin) / pGuide->cVertBox) < pGuide->cyBox) ||
		((pGuide->cxOffset + pGuide->cxWriting) > pGuide->cxBox) ||
		((pGuide->cyOffset + pGuide->cyWriting) > pGuide->cyBox) ||
		// By spec. cyMid and cyBase should be zero, but old code still sets them,
		// so we must allow plausable values.
		// (pGuide->cyMid != 0 || pGuide->cyBase != 0)
		(pGuide->cyMid > pGuide->cyBase || pGuide->cyBase > pGuide->cyWriting)
	) {
	    SetLastError(ERROR_CAN_NOT_COMPLETE);
	    return FALSE;
	}

	SetLatticeGuide(pVRC->pLattice, pGuide);

	return TRUE;
}

////
//	HwxALCValid			
//
//	Tells what character sets to select.
////
BOOL HwxALCValid(HRC hrc, ALC alc)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("HwxALCValid(%08X,%08X)\n",hrc,alc);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

	// Pass the ALC on to the lattice.
	SetLatticeALCValid(pVRC->pLattice, alc);

	return TRUE;
}

////
//	HwxALCPriority			
//
//	Tells what character sets to move to the top of the alt list..
////
BOOL HwxALCPriority(HRC hrc, ALC alc)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("HwxALCPriority(%08X,%08X)\n",hrc,alc);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

	// Pass the ALC on to the lattice.
	SetLatticeALCPriority(pVRC->pLattice, alc);

	return TRUE;
}


////
//	HwxProcess
//
//	Process the ink and return the results.
////
BOOL HwxProcess(HRC hrc)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("HwxProcess(%08X)\n",hrc);

	// Did we get a handle?  Is it free input?
	// Does it have a lattice?
	// JBENN: Should it be an error if we have no strokes?
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return	FALSE;
	}

	// Do any processing we can.
	if (!ProcessLattice(pVRC->pLattice, pVRC->fEndInput))
    {
        return FALSE;
    }

#ifdef USE_IFELANG3
	// Do we have all the input?  Also, make sure we are not in separator mode
	if (pVRC->fEndInput && !pVRC->pLattice->fSepMode) 
    {
		// Apply the language model.
#ifdef HWX_TUNE
        // If we have tuning enabled, then never call IFELang3 directly.
        if (g_pTuneFile == NULL) 
#endif
        {
		    ApplyLanguageModel(pVRC->pLattice, NULL);
        }
	}
#endif

	// Free up any previous path
	if (pVRC->pLatticePath != NULL) {
		FreeLatticePath(pVRC->pLatticePath);
	}

	// Get path (which may be partial if we have not reached the end of input)
	if (!GetCurrentPath(pVRC->pLattice,&pVRC->pLatticePath)) {
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

    return TRUE;
}

////
// HwxEndInput
//
//	No more ink is coming (or can be added) once this is called.
////
BOOL HwxEndInput(HRC hrc)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("HwxEndInput(%08X)\n",hrc);

	// Did we get a handle?  Is it free input?
	// Does it have a lattice?
	// JBENN: Should it be an error if we have no strokes?
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	pVRC->fEndInput		= TRUE;

    return TRUE;
}

////
//	HwxInput
//
//	Add Ink to the HRC.
////
BOOL HwxInput(HRC hrc, POINT  *pPnt, UINT cPnt, DWORD dwTick)
{
	VRC		*pVRC	= (VRC *)hrc;

#ifdef DEBUG_LOG_API
	int i;
	LogMessage("HwxInput(%08X,%d,%d)\n",hrc,cPnt,dwTick);
	for (i = 0; i < (int) cPnt; i++) 
		LogMessage("  xy[%i]=%d,%d\n", i, pPnt[i].x, pPnt[i].y);
#endif

	// Did we get a handle?  Does it have a lattice?
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	} else if (pVRC->fEndInput) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	} else if (!cPnt || pPnt==NULL) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

	// Mark as having input.
	pVRC->fHaveInput	= TRUE;

	// Add stroke to the lattice.
	if (AddStrokeToLattice(pVRC->pLattice, cPnt, pPnt, dwTick) >= 0) {
        return TRUE;
    } else {
		// JRB: FIXME: Is this always the correct error code?
		SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

////
//	HwxGetResults
//
//	Returns the results from the recognizer.
////
int HwxGetResults(
	HRC			hrc,			// HRC containing results
	UINT		cAlt,			// number of alternates
	UINT		iFirst,			// index of first character to return
	UINT		cBoxRes,		// number of characters to return
	HWXRESULTS	*rgBoxResults	// array of cBoxRes ranked lists
) {
	UINT			ii, jj;
	VRC				*pVRC	= (VRC *)hrc;
	LATTICE_PATH	*pLP;
	UINT			iBNFirst, iBNLast;
	HWXRESULTS		*pResults;
	int				sizeResults;

	LogMessage("HwxGetResults(%08X,%d,%d,%d)\n",hrc,cAlt,iFirst,cBoxRes);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		LogMessage("  invalid handle\n");
		return -1;
	} else if (!rgBoxResults) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		LogMessage("  bad rgBoxResults\n");
		return -1;
//	} else if (!pVRC->fEndInput) {
//		SetLastError(ERROR_CAN_NOT_COMPLETE);
//		LogMessage("  not at end of input\n");
//		return -1;
	} else if (GetLatticeStrokeCount(pVRC->pLattice) < 1) {
		// No ink to process.
		LogMessage("  no strokes\n");
		return 0;
	} else if (!pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		LogMessage("  no path\n");
		return -1;
	} else if (rgBoxResults == NULL || 0 == cAlt) {
		// Asked for nothing.
		LogMessage("  no results requested\n");
		return 0;
	}

	// JBENN: WARNING: This code assumes that the lattice sorts
	// the strokes by the box order, so that the box numbers are
	// in acending order.

	// Find the first box in the requested range.
	pLP	= pVRC->pLatticePath;
	for (iBNFirst = 0; iBNFirst < (UINT)pLP->nChars; ++iBNFirst) {
		ASSERT(iBNFirst == 0 || pLP->pElem[iBNFirst - 1].iBoxNum < pLP->pElem[iBNFirst].iBoxNum);
		if ((UINT)pLP->pElem[iBNFirst].iBoxNum >= iFirst) {
			break;
		}
	}
	if (iBNFirst >= (UINT)pLP->nChars) {
		// Nothing found.
		LogMessage("  not enough results %d vs %d\n",iBNFirst,pLP->nChars);
		return 0;
	}

	// Compute last box.
	iBNLast	= iBNFirst + cBoxRes;
	if (iBNLast > (UINT)pLP->nChars) {
		iBNLast	= (UINT)pLP->nChars;
	}

	// Copy out the results.
	pResults	= rgBoxResults;
	sizeResults	= sizeof(HWXRESULTS) + (cAlt - 1) * sizeof(pResults->rgChar[0]);
	for (ii = iBNFirst; ii < iBNLast; ++ii) {
		UINT	cAltUsed;
		wchar_t	oldTemp, newTemp;

		// Retyrn what box was this in.
		pResults->indxBox	= (short)pLP->pElem[ii].iBoxNum;

		// Get the alternates.
		cAltUsed	= GetAlternatesForCharacterInCurrentPath(
			pVRC->pLattice, pVRC->pLatticePath, ii, cAlt, pResults->rgChar
		);

		// Move top choice to top of list, if it is not already there.
		// We slide everything above it down.
		oldTemp	= pLP->pElem[ii].wChar;
		for (jj = 0; jj < cAltUsed; ++jj) {
			newTemp					= pResults->rgChar[jj];
			pResults->rgChar[jj]	= oldTemp;
			if (newTemp == pLP->pElem[ii].wChar) {
				break;
			}
			oldTemp					= newTemp;
		}

		// Zero any unused slots.
		for (jj = cAltUsed; jj < cAlt; ++jj) {
			pResults->rgChar[jj]	= L'\0';
		}
#if 0
		{
			/*
			FILE *f=_wfopen(L"c:/box-results.utf",L"ab");
			if (ftell(f)==0) fwprintf(f,L"%c",0xfeff);
			for (jj=0; jj<cAltUsed; jj++)
				fwprintf(f,L"%c U+%04X  ",pResults->rgChar[jj],pResults->rgChar[jj]);
			fwprintf(f,L"\r\n");
			fclose(f);
*/
			FILE *f=fopen("c:/box-results.utf","a");
			for (jj=0; jj<cAltUsed; jj++)
				fprintf(f,"U+%04X ",pResults->rgChar[jj]);
			fprintf(f,"\n");
			fclose(f);
		}
#endif
		for (jj=0; jj<cAlt; jj++) {
			LogMessage("  Box %d alt %d wch U+%04X\n",ii,jj,pResults->rgChar[jj]);
		}

		// Sequence to next results structure.
		pResults	= (HWXRESULTS *)(((BYTE *)pResults) + sizeResults);

	}

	// Return the number of character positions filled in.
	return iBNLast - iBNFirst;
}

////
//	HwxSetContext
//
//	Handwriting recognition performance can be improved if the recognizer has context
//	information available during processing.  Context information is added to an HRC
//	via the HwxSetContext function which provides one character of prior context for
//	the recognizer.  This function should be called prior to using the HwxProcess
//	function.
//
//	Remarks
//	If this function is not called, the recognizer will assume that no prior context
//	is available.  Performance of the recognizer is improved if context can be
//	provided.  Currently this function improves performance only for the first
//	character in the HRC.  If the HRC contains ink for multiple characters,
//	the recognition process itself will provide context information for characters
//	after the first character, but no context information is available for the first
//	character in the HRC unless it is provided via the HwxSetContext function.
//	This is especially important for situations where ink are recognized one
//	character at a time.
////
BOOL HwxSetContext(HRC hrc, WCHAR wchContext)
{
	VRC			*pVRC	= (VRC *)hrc;
	wchar_t wszBefore[2];

	LogMessage("HwxSetContext(%08X,U+%04X)\n",hrc,wchContext);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

    wszBefore[0] = wchContext;
    wszBefore[1] = 0;
    return SetHwxCorrectionContext(hrc, wszBefore, NULL);
}

////
//	HwxResultsAvailable
//
//	FIXME: Make this work for partial results!
//
//	Warnings: This assumes the writer can't go back and touch up previous
//	characters.
//
//	Returns the number of characters that can be gotten and displayed safely
//	because the viterbi search has folded to one path at this point.
//
//	Return the number of characters available in the
//	path that are ready to get.  This API looks at the viterbi search and
//	any characters far enough back in the input that all the paths merge
//	to 1 are done and can be displayed because nothing further out in the
//	input will change the best path back once it's merged to a single path.
////
INT HwxResultsAvailable(HRC hrc)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("HwxResultsAvailable(%08X)\n",hrc);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return -1;
//	} else if (!pVRC->fEndInput) {
//		SetLastError(ERROR_CAN_NOT_COMPLETE);
//		return -1;
	} else if (GetLatticeStrokeCount(pVRC->pLattice) < 1) {
		// No ink to process.
		return 0;
	}

	// Currently, can't actually do partial results, so if we have
	// not finished processing, we return zero!
	if (!pVRC->pLatticePath) {
		return 0;
	}

	// OK, we have results, so return the number available.
	LogMessage("  %d results\n",pVRC->pLatticePath->nChars);
	return pVRC->pLatticePath->nChars;
}

////
//	HwxSetPartial
//
//	Set parameters for recognition
////
BOOL HwxSetPartial(HRC hrc, UINT partialMode)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("HwxSetPartial(%08X,%d)\n",hrc,partialMode);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}
	if (partialMode > HWX_PARTIAL_FREE) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

	pVRC->pLattice->recogSettings.partialMode	= partialMode;

	return TRUE;
}

////
//	HwxSetAbort
//
//	Set address for abort detection
////
BOOL HwxSetAbort(HRC hrc, UINT *pAbort)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("HwxSetAbort(%08X,%08X)\n",hrc,pAbort);

	// Check parameters.
	if (!hrc || !pVRC->fBoxedInput || !pVRC->pLattice) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		SetLastError(ERROR_CAN_NOT_COMPLETE);
		return FALSE;
	}

	pVRC->pLattice->recogSettings.pAbort	= pAbort;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\jaws.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/JAWS.h
//
// Description:
//	    One and two stroke combiner net header
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "runnet.h"
#include "sole.h"
#include "fugu.h"

#pragma once

// Magic key the identifies the NN bin file
#define	JAWS_FILE_TYPE	0xC0EB1212

// Version information for file.
#define	JAWS_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	JAWS_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define JAWS_CUR_FILE_VERSION		0		// Current version of code.

typedef struct JAWS_LOAD_INFO
{
    LOAD_INFO info;
    LOCAL_NET net;
    int iNetSize;
} JAWS_LOAD_INFO;

BOOL JawsLoadRes(JAWS_LOAD_INFO *pJaws, HINSTANCE hInst, int nResID, int nType);
BOOL JawsLoadFile(JAWS_LOAD_INFO *pJaws, wchar_t *wszRecogDir);
BOOL JawsUnloadFile(JAWS_LOAD_INFO *pJaws);

int JawsMatch(JAWS_LOAD_INFO *pJaws, FUGU_LOAD_INFO *pFugu, SOLE_LOAD_INFO *pSole,
              ALT_LIST *pAltList, int cAlt, GLYPH *pGlyph, RECT *pGuide, 
              CHARSET *pCharSet, LOCRUN_INFO *pLocRunInfo);

#define JAWS_NUM_ALTERNATES 10
#define JAWS_NUM_ALT_FEATURES 9
#define JAWS_NUM_MISC_FEATURES 1

#define JAWS_NUM_FEATURES (JAWS_NUM_ALTERNATES * JAWS_NUM_ALT_FEATURES + JAWS_NUM_MISC_FEATURES)

int JawsFeaturize(FUGU_LOAD_INFO *pFugu, SOLE_LOAD_INFO *pSole, LOCRUN_INFO *pLocRunInfo, 
                  GLYPH *pGlyph, RECT *pGuide,
                  CHARSET *pCharSet, RREAL *pFeat, ALT_LIST *pAltList,
                  BOOL *pfAgree);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\fuguseg.c ===
#include "common.h"
#include "glyph.h"
#include "score.h"
#include "fugu.h"
#include "volcanop.h"
#include "nnet.h"

#define FUGU_SEG_MAX_SPACES 32

static  int                     g_cSpaces;
static	FUGU_INTEGER_WEIGHTS	g_aCharDetNet[FUGU_SEG_MAX_SPACES];

POINT *DupPoints(POINT *pOldPoints, int nPoints);
GLYPH *GlyphFromStrokes(UINT cStrokes, STROKE *pStrokes);

// prepare net from pointer
BOOL PrepareCharDetNet (BYTE *pb, FUGU_INTEGER_WEIGHTS *pCharDetNet)
{
	pCharDetNet->pHeader = (FUGU_INTEGER_WEIGHTS_HEADER *) pb;
	pCharDetNet->pfdchMapping = (WCHAR *) (pb + sizeof(FUGU_INTEGER_WEIGHTS_HEADER));
	pCharDetNet->pbWeights = pb + sizeof(FUGU_INTEGER_WEIGHTS_HEADER) + 
		sizeof(WCHAR) * pCharDetNet->pHeader->arch.nOutputs;

	return TRUE;
}

// validates the header of the brknet
int CheckCharDetHeader (void *pData)
{
	NNET_HEADER	*pHeader	=	(NNET_HEADER *)pData;

	// wrong magic number
	ASSERT (pHeader->dwFileType == CHARDET_FILE_TYPE);

	if (pHeader->dwFileType != CHARDET_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= CHARDET_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= CHARDET_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

	ASSERT (pHeader->cSpace <= FUGU_SEG_MAX_SPACES);

    if	(	pHeader->iFileVer >= CHARDET_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= CHARDET_CUR_FILE_VERSION && 
			!memcmp (	pHeader->adwSignature, 
						g_locRunInfo.adwSignature, 
						sizeof (pHeader->adwSignature)
					) &&
			pHeader->cSpace <= FUGU_SEG_MAX_SPACES
		)
    {
        return pHeader->cSpace;
    }
	else
	{
		return 0;
	}
}

// does the necessary preparations for a net to be used later
static BOOL CharDetLoadFromPointer (BYTE *pData)
{
	int					iSpc, cSpc, iSpaceID;
	NNET_SPACE_HEADER	*pSpaceHeader;
	BYTE				*pPtr;

	if (!pData)
	{
		return FALSE;
	}

	// check the header info
	cSpc	=	CheckCharDetHeader (pData);
    g_cSpaces = cSpc;
	if (cSpc <= 0)
	{
		return FALSE;
	}
	
	pPtr	=	pData	+ sizeof (NNET_HEADER);

	for (iSpc = 0; iSpc < cSpc; iSpc++)
	{
		// point to the one and only space that we have
		pSpaceHeader	=	(NNET_SPACE_HEADER *)pPtr;
		pPtr			+=	sizeof (NNET_SPACE_HEADER);

		// point to the actual data
		iSpaceID	=	pSpaceHeader->iSpace;

		ASSERT (iSpaceID >= 1 && iSpaceID <= FUGU_SEG_MAX_SPACES);

		if	(!PrepareCharDetNet	(	pData + pSpaceHeader->iDataOffset, 
									g_aCharDetNet + iSpaceID - 1
								)
			)
        {
            return FALSE;
        }
	}

	return TRUE;
}

BOOL LoadCharDetFromFile(wchar_t *wszPath, LOAD_INFO *pLoadInfo)
{
	wchar_t		awszFileName[MAX_PATH];
	
	// memory map the file
	wsprintf (awszFileName, L"%s\\chardet.bin", wszPath);

    if (!DoOpenFile(pLoadInfo, awszFileName))
    {
        return FALSE;
    }

	return CharDetLoadFromPointer (pLoadInfo->pbMapping);
}

BOOL LoadCharDetFromResource (HINSTANCE hInst, int nResID, int nType)
{
	LOAD_INFO LoadInfo;

    if (!DoLoadResource (&LoadInfo, hInst, nResID, nType))
    {
        return FALSE;
    }

	return CharDetLoadFromPointer (LoadInfo.pbMapping);
}

BOOL CharDetUnloadFile(LOAD_INFO *pInfo)
{
    return DoCloseFile(pInfo);
}

int *ApplyFuguInteger(FUGU_INTEGER_WEIGHTS *pFugu, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

float FuguSegScore(int cStrokes, STROKE *pStrokes, LOCRUN_INFO *pLocRunInfo)
{
    GLYPH *pGlyph = GlyphFromStrokes(cStrokes, pStrokes);
	int i;
	int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT];
	int *piOutput = NULL;
    float flOutput = 0;

    if (cStrokes >= 1 && cStrokes <= g_cSpaces)
    {
        // First convert the ink to 29x29 input region
	    if (!FuguRender(pGlyph, NULL, aiInput)) 
        {
		    return -1;
        }

	    // Apply the recognizer
	    piOutput = ApplyFuguInteger(g_aCharDetNet + cStrokes - 1, aiInput);
	    if (piOutput == NULL)
        {
		    return -1;
        }

	    for (i = 0; i < g_aCharDetNet[cStrokes - 1].pHeader->arch.nOutputs; i++) 
        {
            wchar_t wch = g_aCharDetNet[cStrokes - 1].pfdchMapping[i];
            // I'm assuming every space will have "not a char" samples.  Note that 
            // there are two possible mappings for "not a char", the old one L'0'
            // and the new one which is simply 0.
            if (wch == 0 || wch == L'0')
            {
                int cRight = FUGU_ACTIVATION_SCALE - piOutput[i];
                if (cRight == 0)
                {
                    cRight = 1;
                }

                flOutput = (float) cRight / (float) FUGU_ACTIVATION_SCALE;
			} 
		}
	}
    
	DestroyFramesGLYPH(pGlyph);
	DestroyGLYPH(pGlyph);
	ExternFree(piOutput);
    return flOutput;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\jaws.c ===
#include <stdlib.h>
#include "common.h"
#include "score.h"
#include "runnet.h"
#include "jaws.h"
#include "fugu.h"
#include "sole.h"
#include "nnet.h"

extern LOCRUN_INFO		g_locRunInfo;

// validates the header of the Jaws net
BOOL CheckJawsNetHeader (void *pData)
{
	NNET_HEADER		*pHeader	=	(NNET_HEADER *)pData;

	// wrong magic number
	ASSERT (pHeader->dwFileType == JAWS_FILE_TYPE);

	if (pHeader->dwFileType != JAWS_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= JAWS_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= JAWS_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

	ASSERT (pHeader->cSpace == 1);

    if	(	pHeader->iFileVer >= JAWS_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= JAWS_CUR_FILE_VERSION &&
			!memcmp (	pHeader->adwSignature, 
						g_locRunInfo.adwSignature, 
						sizeof (pHeader->adwSignature)
					) &&
			pHeader->cSpace == 1
		)
    {
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

BOOL JawsLoadPointer(JAWS_LOAD_INFO *pJaws)
{
    NNET_SPACE_HEADER	*pSpaceHeader;

	if (!CheckJawsNetHeader (pJaws->info.pbMapping))
		return FALSE;

	// point to the one and only space header
	pSpaceHeader = (NNET_SPACE_HEADER *)(pJaws->info.pbMapping + sizeof (NNET_HEADER));

    if	(	restoreLocalConnectNet	(	pJaws->info.pbMapping + pSpaceHeader->iDataOffset, 
										0, &pJaws->net
									) == NULL
		)
    {
        return FALSE;
    }

    pJaws->iNetSize = 
		getRunTimeNetMemoryRequirements (pJaws->info.pbMapping + pSpaceHeader->iDataOffset);

    if (pJaws->iNetSize <= 0)
    {
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////
//
// JawsLoadFile
//
// Load otter/fugu/sole combiner from file
//
// Parameters:
//      pInfo: [out] Information about the mapped file
//      wszPath: [in] Path to load from
//
// Return values:
//      TRUE on successful, FALSE otherwise.
//
//////////////////////////////////////
BOOL JawsLoadFile(JAWS_LOAD_INFO *pJaws, wchar_t *wszPath)
{
	wchar_t	wszFile[_MAX_PATH];

	// Generate path to file.
	FormatPath(wszFile, wszPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"jaws.bin");

    if (!DoOpenFile(&pJaws->info, wszFile)) 
    {
        return FALSE;
    }
    return JawsLoadPointer(pJaws);
}

///////////////////////////////////////
//
// JawsUnloadFile
//
// Load otter/fugu/sole combiner from file
//
// Parameters:
//      pInfo: [out] File to unmap
//
// Return values:
//      TRUE on successful, FALSE otherwise.
//
//////////////////////////////////////
BOOL JawsUnloadFile(JAWS_LOAD_INFO *pJaws)
{
    return DoCloseFile(&pJaws->info);
}

BOOL JawsLoadRes(JAWS_LOAD_INFO *pJaws, HINSTANCE hInst, int nResID, int nType)
{
    if (DoLoadResource(&pJaws->info, hInst, nResID, nType) == NULL)
    {
        return FALSE;
    }
    return JawsLoadPointer(pJaws);
}

// describe the codepoint
RREAL *CodePointFlags(ALC alc, RREAL *pFeat)
{
    *(pFeat++) = ((alc & ALC_NUMERIC) ? 65535 : 0);
    *(pFeat++) = ((alc & ALC_ALPHA) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_PUNC | ALC_NUMERIC_PUNC | ALC_OTHER)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_HIRAGANA | ALC_JAMO | ALC_BOPOMOFO)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_KATAKANA | ALC_HANGUL_ALL)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_KANJI_ALL)) ? 65535 : 0);
    return pFeat;
}

// Given an alt list with dense and possibly folded codes in it, run through it
// and expand the folded lists.  The unfolded alt list is returned in place.
// This function assumes that the list begins with better alternates, as those
// later in the list will get dropped if we run out of space.
static void UnfoldCodes(ALT_LIST *pAltList, LOCRUN_INFO *pLocRunInfo, CHARSET *cs)
{
	int i, cOut=0;
	ALT_LIST newAltList;	// This will be where the new alt list is constructed.

	// For each alternate in the input list and while we have space in the output list
	for (i=0; i<(int)pAltList->cAlt && (int)cOut<MAX_ALT_LIST; i++) {

		// Check if the alternate is a folded coded
		if (LocRunIsFoldedCode(pLocRunInfo,pAltList->awchList[i])) {
			int kndex;
			// If it is a folded code, look up the folding set
			wchar_t *pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, pAltList->awchList[i]);

			// Run through the folding set, adding non-NUL items to the output list
			// (until the output list is full)
			for (kndex = 0; 
				kndex < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[kndex] != 0 && (int)cOut<MAX_ALT_LIST; 
				kndex++) {
				if (IsAllowedChar(pLocRunInfo, cs, pFoldingSet[kndex])) 
				{
					newAltList.awchList[cOut]=pFoldingSet[kndex];
					newAltList.aeScore[cOut]=pAltList->aeScore[i];
					cOut++;
#ifdef DISABLE_UNFOLDING
					// If unfolding is disabled, then stop after producing one unfolded code.
					// This way we don't push results later in the alt list out of the alt
					// list, while still allowing the recognizer to return unicodes for each
					// alternate.  
					break;
#endif
				}
			}
		} else {
			// Dense codes that are not folded get added directly
			newAltList.awchList[cOut]=pAltList->awchList[i];
			newAltList.aeScore[cOut]=pAltList->aeScore[i];
			cOut++;
		}
	}	
	// Store the length of the output list
	newAltList.cAlt=cOut;

	// Copy the output list over the input.
	*pAltList=newAltList;
}

int JawsFeaturize(FUGU_LOAD_INFO *pFugu, SOLE_LOAD_INFO *pSole, LOCRUN_INFO *pLocRunInfo, 
                  GLYPH *pGlyph, RECT *pGuide,
                  CHARSET *pCharSet, RREAL *pFeat, ALT_LIST *pAltList,
                  BOOL *pfAgree)
{
	int i;
	ALT_LIST altListFugu;
	ALT_LIST altListSole;

    wchar_t wchSoleTop1;
    float flSoleTop1;
	
    if (FuguMatch(&pFugu->fugu, &altListFugu, MAX_ALT_LIST, pGlyph, NULL, pCharSet, pLocRunInfo) < 0)
    {
        return -1;
    }

    UnfoldCodes(&altListFugu, pLocRunInfo, pCharSet);
    altListSole = altListFugu;

    if (SoleMatchRescore(pSole, &wchSoleTop1, &flSoleTop1, &altListSole, MAX_ALT_LIST, 
                         pGlyph, pGuide, pCharSet, pLocRunInfo) < 0)
    {
        return -1;
    }

    *pAltList = altListSole;

    if (altListFugu.cAlt > 0 && wchSoleTop1 == altListFugu.awchList[0])
    {
        *pfAgree = TRUE;
    }
    else
    {
        *pfAgree = FALSE;
        if (altListFugu.cAlt > JAWS_NUM_ALTERNATES)
        {
            pAltList->cAlt = JAWS_NUM_ALTERNATES;
        }
        for (i = 0; i < JAWS_NUM_ALTERNATES; i++) 
        {
            extern UNIGRAM_INFO g_unigramInfo;
            if (i < (int) altListFugu.cAlt) 
            {
                *(pFeat++) = (int) (altListFugu.aeScore[i] * 65535);
                *(pFeat++) = (int) (altListSole.aeScore[i] * 65535);
                *(pFeat++) = (int) (-UnigramCost(&g_unigramInfo, altListFugu.awchList[i]) * 100 * 256);
                pFeat = CodePointFlags(LocRun2ALC(pLocRunInfo, altListFugu.awchList[i]), pFeat);
            }
            else
            {
                *(pFeat++) = 0;
                *(pFeat++) = 0;
                *(pFeat++) = (int) (-UnigramCost(&g_unigramInfo, 0xFFFE) * 100 * 256);
                pFeat = CodePointFlags(0, pFeat);
            }
        }
        *(pFeat++) = (CframeGLYPH(pGlyph) - 1) * 65535;
    }
    return pAltList->cAlt;
}

///////////////////////////////////////
//
// JawsMatch
//
// Invoke Fugu/Otter/Sole combiner on a character.  
//
// Parameters:
//      pFugu:          [in]  Fugu database to use
//      pAltList:       [in/out] Alt list to rewrite the scores of
//      cAlt:           [in]  The maximum number of alternates to return
//      pGlyph:         [in]  The ink to recognize
//      pGuide:         [in]  Guide to scale ink to
//      pCharSet:       [in]  Filter for the characters to be returned
//      pLocRunInfo:    [in]  Pointer to the locale database
//
// Return values:
//      Returned the number of items in the alt list, or -1 if there is an error
//
//////////////////////////////////////
int JawsMatch(JAWS_LOAD_INFO *pJaws, FUGU_LOAD_INFO *pFugu, SOLE_LOAD_INFO *pSole,
              ALT_LIST *pAltList, int cAlt, GLYPH *pGlyph, RECT *pGuide, 
              CHARSET *pCharSet, LOCRUN_INFO *pLocRunInfo)
{
	int i;
    RREAL *pNetOut;
    int iWinner, cOut;
    BOOL fAgree;
    RREAL *pFeat = (RREAL *) ExternAlloc(pJaws->iNetSize * sizeof(RREAL));
    if (pFeat == NULL)
    {
        return -1;
    }

    if (JawsFeaturize(pFugu, pSole, pLocRunInfo, pGlyph, pGuide, pCharSet, pFeat, pAltList, &fAgree) < 0)
    {
        ExternFree(pFeat);
        return -1;
    }

    if (!fAgree)
    {
        pNetOut = runLocalConnectNet(&pJaws->net, pFeat, &iWinner, &cOut);
        if (cOut < (int) pAltList->cAlt)
        {
            pAltList->cAlt = cOut;
        }
        for (i = 0; i < (int) pAltList->cAlt; i++) 
        {
            pAltList->aeScore[i] = (float) *(pNetOut++) / (float) SOFT_MAX_UNITY;
        }
    }

    for (i = 0; i < (int) pAltList->cAlt; i++) 
    {
        pAltList->aeScore[i] = ((float) -ProbToScore(pAltList->aeScore[i])) / (float) 256.0;
    }

    SortAltList(pAltList);

    ExternFree(pFeat);
    return pAltList->cAlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\eafactoid.c ===
#include <stdlib.h>
#include "common.h"
#include "factoid.h"
#include "volcanop.h"

#define JPN_LANG 1
#define CHS_LANG 2
#define CHT_LANG 4
#define KOR_LANG 8
#define ALL_LANG (JPN_LANG | CHS_LANG | CHT_LANG | KOR_LANG)

typedef struct FACTOID_DEF 
{
    DWORD dwFactoid;
    int iLang;
    ALC alc;
    wchar_t *wszChars;
    wchar_t *wszDense;
} FACTOID_DEF;

#define YEN L"\x00a5"
#define WON L"\x20a9"
#define CURRENCY_SYMBOLS L"\x0024\x00A3\x20AC"
#define CHINESE_ZERO L"\x96f6"
#define IDEOGRAPHIC_ZERO L"\x3007"
#define KANJI_DIGITS L"\x4e00\x4e8c\x4e09\x56db\x4e94\x516d\x4e03\x516b\x4e5d\x5341"
#define JPN_YEARS L"\x660e\x6cbb\x5927\x6b63\x662d\x548c\x5e73\x6210"

static FACTOID_DEF g_factoidTable[] =
{
    { FACTOID_NONE,         ALL_LANG, 0, NULL },
    { FACTOID_EMAIL,        ALL_LANG, ALC_UCALPHA | ALC_LCALPHA, L"0123456789@.-+=_" },
    { FACTOID_WEB,          ALL_LANG, ALC_ASCII, NULL },
    { FACTOID_ONECHAR,      ALL_LANG, ALC_ASCII, NULL },
    { FACTOID_NUMBER,       ALL_LANG, ALC_NUMERIC | ALC_NUMERIC_PUNC | ALC_MATH | ALC_MONETARY , NULL },
    { FACTOID_DIGITCHAR,    ALL_LANG, ALC_NUMERIC, NULL },
    { FACTOID_NUMSIMPLE,    ALL_LANG, ALC_NUMERIC, L",." },

    { FACTOID_NUMCURRENCY,  JPN_LANG, 0, 
#if defined(WINCE) || defined(FAKE_WINCE)
/* Symbols */ L"\x0024\x00A3\x20AC\x00A5" 
#else
/* Symbols */ L"\x0024\x00A3\x20AC\x00A5\x20A9" 
#endif
/* cent "L\x00A2" */
/* Digits */ L"\x002C\x002E\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039\x3007\x4E00\x4E8C\x4E09\x56DB\x4E94\x516D\x4E03\x516B\x4E5D\x5341\x58F1\x5F10\x53C2\x4F0D\x62FE" 
/* Units */ L"\x5341\x767E\x5343\x4E07\x842C\x5104\x5146\x4EDF\x9621" 
/* Kanji */ L"\x5186" 
    },

    { FACTOID_NUMCURRENCY,  CHS_LANG, 0, 
/* Symbols */ L"\x0024\x00A3\x20AC\x00A5"
/* won L"\x20A9" cent L"\x00A2" */
/* Digits */ L"\x002C\x002E\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039\x96F6\x58F9\x8D30\x53C1\x8086\x4F0D\x9646\x67D2\x634C\x7396" 
/* Units */ L"\x62FE\x4F70\x4EDF\x4E07\x4EBF" 
/* Kanji */ L"\x5143\x89D2\x5206" 
    },

    { FACTOID_NUMCURRENCY,  CHT_LANG, 0, 
/* Symbols */ L"\x0024\x00A3\x20AC\x00A5\x20A9" 
/* cent L"\x00A2" */
/* Digits */ L"\x002C\x002E\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039\x96F6\x3007\x4E00\x4E8C\x4E09\x56DB\x4E94\x516D\x4E03\x516B\x4E5D\x5341\x96F6\x58F9\x8CB3\x53C3\x8086\x4F0D\x9678\x67D2\x634C\x7396\x62FE" 
/* Units */ L"\x5341\x767E\x5343\x842C\x5104\x62FE\x4F70\x4EDF" 
/* Kanji */ L"\x89D2\x5143\x5206\x6BDB\x584A\x9322\x5713" 
    },

    { FACTOID_NUMCURRENCY,  KOR_LANG, 0, 
/* Symbols */ L"\x0024\x00A3\x20AC\x20A9\x00A5" 
/* cent L"\x00A2" */
/* Digits */ L"\x002C\x002E\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039\x96F6\x58F9\x8CB3\x53C3\x8086\x4F0D\x9678\x67D2\x634C\x7396\x62FE" 
/* Units */ L"\x5341\x767E\x5343\x842C\x5104" 
/* Kanji */ L"\xC6D0"
    },

    { FACTOID_ZIP,          ALL_LANG, ALC_NUMERIC, L"-" },
    { FACTOID_NUMPERCENT,   ALL_LANG, ALC_NUMERIC, L".%" },

    { FACTOID_NUMDATE,      JPN_LANG, ALC_NUMERIC, 
        L"().'/-\x5e74\x6708\x65e5\x66dc\x706b\x6c34\x6728\x91d1\x571f\x5143\x5eff\x4e17" IDEOGRAPHIC_ZERO KANJI_DIGITS JPN_YEARS },
    { FACTOID_NUMDATE,      CHS_LANG, ALC_NUMERIC, 
        L"().'/-\x5e74\x6708\x65e5\x661f\x671f" CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMDATE,      CHT_LANG, ALC_NUMERIC, 
        L"().'/-\x5e74\x6708\x570b\x65e5\x5143\x6c11\x516c\x897f\x524d\x9031\x83ef\x661f\x671f\x4e2d" CHINESE_ZERO IDEOGRAPHIC_ZERO KANJI_DIGITS },
    { FACTOID_NUMDATE,      KOR_LANG, ALC_NUMERIC, 
        L"'/-\x5e74\x6708\x65e5\xb144\xc6d4\xc77c\xd654\xc218\xbaa9\xae08\xd1a0\xc6d4\xc694" KANJI_DIGITS CHINESE_ZERO },

    { FACTOID_NUMTIME,      JPN_LANG, ALC_NUMERIC, 
        L"apmAPM.:\x5348\x524d\x5f8c\x6642\x5206\x79d2" IDEOGRAPHIC_ZERO CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMTIME,      CHS_LANG, ALC_NUMERIC, 
        L"apmAPM.:\x4e0a\x5348\x4e0b\x65f6\x70b9\x5206\x79d2\x65e9\x591c\x4e2d\x665a" CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMTIME,      CHT_LANG, ALC_NUMERIC, 
        L"apmAPM.:\x4e0a\x5348\x4e0b\x9ede\x5206\x79d2\x65e9\x591c\x4e2d\x665a\x6642" CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMTIME,      KOR_LANG, ALC_NUMERIC, 
        L":apmAPM.\xc624\xc804\xd6c4\xc2dc\xbd84" KANJI_DIGITS CHINESE_ZERO },

    { FACTOID_NUMPHONE,     JPN_LANG, ALC_NUMERIC | ALC_UCALPHA, L"#()-+.\x30fb\x5185\x7dda" },
    { FACTOID_NUMPHONE,     CHS_LANG, ALC_NUMERIC | ALC_UCALPHA, L"()/-+.\x5185\x8f6c" CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMPHONE,     CHT_LANG, ALC_NUMERIC | ALC_UCALPHA, L"()-+.EeXxt\x5206\x6a5f\x8f49" CHINESE_ZERO KANJI_DIGITS },
    { FACTOID_NUMPHONE,     KOR_LANG, ALC_NUMERIC | ALC_UCALPHA, L"()-+.\xad50\xd658:" },

    { FACTOID_FILENAME,     ALL_LANG, 0xFFFFFFFF, NULL },
    { FACTOID_UPPERCHAR,    ALL_LANG, ALC_UCALPHA, NULL },
    { FACTOID_LOWERCHAR,    ALL_LANG, ALC_LCALPHA, NULL },
    { FACTOID_PUNCCHAR,     ALL_LANG, ALC_PUNC | ALC_MATH | ALC_NUMERIC_PUNC | ALC_MONETARY | ALC_OTHER, NULL },
    { FACTOID_JPN_COMMON,   JPN_LANG, ALC_JPN_COMMON | ALC_EXTENDED_SYM, NULL },
    { FACTOID_CHS_COMMON,   CHS_LANG, ALC_CHS_COMMON | ALC_EXTENDED_SYM, NULL },
    { FACTOID_CHT_COMMON,   CHT_LANG, ALC_CHT_COMMON | ALC_EXTENDED_SYM, NULL },
    { FACTOID_KOR_COMMON,   KOR_LANG, ALC_KOR_COMMON | ALC_EXTENDED_SYM, NULL },
    { FACTOID_HIRAGANA,     JPN_LANG, ALC_HIRAGANA, NULL },
    { FACTOID_KATAKANA,     JPN_LANG, ALC_KATAKANA, NULL },
    { FACTOID_KANJI_COMMON, ALL_LANG, ALC_KANJI_COMMON, NULL },
    { FACTOID_KANJI_RARE,   ALL_LANG, ALC_KANJI_RARE, NULL },
    { FACTOID_HANGUL_COMMON,KOR_LANG, ALC_HANGUL_COMMON, NULL },
    { FACTOID_HANGUL_RARE,  KOR_LANG, ALC_HANGUL_RARE, NULL },
    { FACTOID_JAMO,         KOR_LANG, ALC_JAMO, NULL },
    { FACTOID_BOPOMOFO,     CHT_LANG, ALC_BOPOMOFO, NULL },
};

static int g_iFactoidTableSize = sizeof(g_factoidTable) / sizeof(FACTOID_DEF);

static int g_iRecognizerLanguage;

BOOL FactoidTableConfig(LOCRUN_INFO *pLocRunInfo, wchar_t *wszRecognizerLanguage)
{
    int iFactoid;
    if (wcsicmp(wszRecognizerLanguage, L"JPN") == 0) 
    {
        g_iRecognizerLanguage = JPN_LANG;
    }
    else if (wcsicmp(wszRecognizerLanguage, L"CHS") == 0)
    {
        g_iRecognizerLanguage = CHS_LANG;
    }
    else if (wcsicmp(wszRecognizerLanguage, L"CHT") == 0)
    {
        g_iRecognizerLanguage = CHT_LANG;
    }
    else if (wcsicmp(wszRecognizerLanguage, L"KOR") == 0)
    {
        g_iRecognizerLanguage = KOR_LANG;
    }
    else
    {
        return FALSE;
    }
    for (iFactoid = 0; iFactoid < g_iFactoidTableSize; iFactoid++)
    {
        if ((g_factoidTable[iFactoid].iLang & g_iRecognizerLanguage) != 0 &&
            g_factoidTable[iFactoid].wszChars != NULL)
        {
            wchar_t *wsz = Externwcsdup(g_factoidTable[iFactoid].wszChars);
            if (wsz == NULL)
            {
                return FALSE;
            }
            g_factoidTable[iFactoid].wszDense = wsz;
            while (*wsz != 0) 
            {
                wchar_t wch = LocRunUnicode2Dense(pLocRunInfo, *wsz);
                if (wch == LOC_TRAIN_NO_DENSE_CODE) 
                {
                    return FALSE;
                }
                *wsz = wch;
                wsz++;
            }
        } 
        else
        {
            g_factoidTable[iFactoid].wszDense = NULL;
        }
    }
    return TRUE;
}

BOOL FactoidTableUnconfig()
{
    int iFactoid;
    for (iFactoid = 0; iFactoid < g_iFactoidTableSize; iFactoid++)
    {
        ExternFree(g_factoidTable[iFactoid].wszDense);
    }
    return TRUE;
}

BOOL SetFactoidDefaultInternal(LATTICE *pLattice)
{
    // Clear out the ALCs
    pLattice->recogSettings.alcValid = 0xFFFFFFFF;
    ExternFree(pLattice->recogSettings.pbAllowedChars);
    pLattice->recogSettings.pbAllowedChars = NULL;

    pLattice->recogSettings.alcPriority = 0;
    ExternFree(pLattice->recogSettings.pbPriorityChars);
    pLattice->recogSettings.pbPriorityChars = NULL;

    // Clear out any factoid setting to the default
    pLattice->fUseFactoid = TRUE;
    ExternFree(pLattice->pbFactoidChars);
    pLattice->pbFactoidChars = NULL;
    pLattice->alcFactoid = 0xFFFFFFFF;

    return TRUE;
}

BOOL IsSupportedFactoid(DWORD dwFactoid)
{
    int iFactoid;
    for (iFactoid = 0; iFactoid < g_iFactoidTableSize; iFactoid++)
    {
        if (g_factoidTable[iFactoid].dwFactoid == dwFactoid &&
            (g_factoidTable[iFactoid].iLang & g_iRecognizerLanguage) != 0)
        {
            break;
        }
    }
    return (iFactoid < g_iFactoidTableSize);
}

BOOL SetFactoidInternal(LOCRUN_INFO *pLocRunInfo, LATTICE *pLattice, DWORD dwFactoid)
{
    wchar_t *wsz;
    int iFactoid;
    for (iFactoid = 0; iFactoid < g_iFactoidTableSize; iFactoid++)
    {
        if (g_factoidTable[iFactoid].dwFactoid == dwFactoid &&
            (g_factoidTable[iFactoid].iLang & g_iRecognizerLanguage) != 0)
        {
            break;
        }
    }
    if (iFactoid == g_iFactoidTableSize) 
    {
        return FALSE;
    }
    pLattice->alcFactoid |= g_factoidTable[iFactoid].alc;
    wsz = g_factoidTable[iFactoid].wszDense;
    if (wsz != NULL) 
    {
        while (*wsz != 0)
        {
            SetAllowedChar(pLocRunInfo, &(pLattice->pbFactoidChars), *wsz);
            wsz++;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\freeapi.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/FreeApi.c
//
// Description:
//	    Implement external free input API for DLL.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "volcanop.h"
#include "factoid.h"
#include "recdefs.h"
#include "brknet.h"

/*
 * Definitions from penwin.h needed for inksets.  We can't include it because
 * it has conflicts with recog.h
 */

// inkset returns:
#define ISR_ERROR               (-1)    // Memory or other error
#define ISR_BADINKSET           (-2)    // bad source inkset
#define ISR_BADINDEX            (-3)    // bad inkset index

#define IX_END                  0xFFFF  // to or past last available index

#ifdef HWX_TUNE
#include <stdio.h>
#endif

//#define DEBUG_LOG_API

#ifdef DEBUG_LOG_API
#include <stdio.h>
static void LogMessage(char *format, ...)
{
	FILE *f=fopen("c:/log.txt","a");
    va_list marker;
    va_start(marker,format);
	vfprintf(f,format,marker);
    va_end(marker);
	fclose(f);
}
#else
static void LogMessage(char *format, ...)
{
    va_list marker;
    va_start(marker,format);
    va_end(marker);
}
#endif

HRC CreateCompatibleHRC(HRC hrctemplate, HREC hrec)
{
	VRC		*pVRC;

	LogMessage("CreateCompatibleHRC()\n");

    hrec = hrec;

	// Alloc the VRC.
	pVRC	= ExternAlloc(sizeof(VRC));
	if (!pVRC) {
		goto error1;
	}

	// Initialize it.
	pVRC->fBoxedInput	= FALSE;
	pVRC->fHaveInput	= FALSE;
	pVRC->fEndInput		= FALSE;
	pVRC->fBeginProcess = FALSE;
	pVRC->pLatticePath	= (LATTICE_PATH *)0;

	if (!hrctemplate) {
		pVRC->pLattice	= AllocateLattice();
		if (!pVRC->pLattice) {
			goto error2;
		}
	} else {
		VRC		*pVRCTemplate	= (VRC *)hrctemplate;

		pVRC->pLattice	= CreateCompatibleLattice(
			pVRCTemplate->pLattice
		);
		if (!pVRC->pLattice) {
			goto error2;
		}
	}

	// Success, cast to HRC and return it.
    return (HRC)pVRC;

error2:
	ExternFree(pVRC);

error1:
	return (HRC)0;
}

int DestroyHRC(HRC hrc)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("DestroyHRC()\n");

	// Did we get a handle?  Is if a free input handle?
	if (!hrc || pVRC->fBoxedInput) {
		return HRCR_ERROR;
	}

	// Free the lattice.  Should it be an error if there is not one?
	if (pVRC->pLattice) {
		FreeLattice(pVRC->pLattice);
	} else {
		ASSERT(pVRC->pLattice);
	}

	// Free the lattice path.
	if (pVRC->pLatticePath) {
		FreeLatticePath(pVRC->pLatticePath);
	}

	// Free the VRC itself.
	ExternFree(pVRC);

    return	HRCR_OK;
}

int AddPenInputHRC(
	HRC			hrc,
	POINT		*ppnt,
	void		*pvOem,
	UINT		oemdatatype,
	STROKEINFO	*psi
) {
	VRC		*pVRC	= (VRC *)hrc;
	int		retVal;

	LogMessage("AddPenInputHRC()\n");

	pvOem		= pvOem;
	oemdatatype	= oemdatatype;

	// Did we get a handle?  Does it have a lattice?
	if (!hrc || pVRC->fBoxedInput 
		|| !pVRC->pLattice || pVRC->fEndInput
	) {
		return HRCR_ERROR;
	}

	// Do we have valid ink?
	if (psi->cPnt == 0 || !ppnt) {
		return HRCR_ERROR;
	}
	if (!(psi->wPdk & PDK_DOWN)) {
		return HRCR_OK;
	}

	// Add stroke to the lattice.
	retVal	= AddStrokeToLattice(pVRC->pLattice, psi->cPnt, ppnt, psi->dwTick);

	// Mark as having input.
	pVRC->fHaveInput	= TRUE;

	return(retVal ? HRCR_OK : HRCR_MEMERR);
}

int EndPenInputHRC(HRC hrc)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("EndPenInputHRC()\n");

	// Did we get a handle?  Is it free input?
	// Does it have a lattice?
	// JBENN: Should it be an error if we have no strokes?
	if (!hrc || pVRC->fBoxedInput || !pVRC->pLattice) {
		return HRCR_ERROR;
	}

	pVRC->fEndInput		= TRUE;

    return	HRCR_OK;
}

int ProcessHRC(HRC hrc, DWORD timeout)
{
	VRC		*pVRC	= (VRC *)hrc;

	LogMessage("ProcessHRC()\n");

    timeout = timeout;

	// Did we get a handle?  Is it free input?
	// Does it have a lattice?
	// JBENN: Should it be an error if we have no strokes?
	if (!hrc || pVRC->fBoxedInput || !pVRC->pLattice) 
	{
		return HRCR_ERROR;
	}

	// Have we already finished all processing?
//	if (pVRC->pLatticePath) {
//		return	HRCR_OK;
//	}

	// Do any processing we can.
	if (!ProcessLattice(pVRC->pLattice, pVRC->fEndInput))
    {
        return HRCR_ERROR;
    }

	pVRC->fBeginProcess = TRUE;

	// in free mode, run the brknet to update the lattice
	// we only call this if end input had been called
	if (!pVRC->pLattice->fUseGuide && pVRC->fEndInput && !pVRC->pLattice->fSepMode && !pVRC->pLattice->fWordMode
#ifdef HWX_TUNE
        && g_pTuneFile == NULL
#endif
       )
	{
		UpdateLattice(pVRC->pLattice);
	}

#ifdef USE_IFELANG3
	// Do we have all the input?  Also, make sure we are not in separator mode
	if (pVRC->fEndInput && !pVRC->pLattice->fSepMode) 
    {
		// Apply the language model.
#ifdef HWX_TUNE
        // If we have tuning enabled, then never call IFELang3 directly.
        if (g_pTuneFile == NULL) 
#endif
        {
		    ApplyLanguageModel(pVRC->pLattice, NULL);
        }
	}
#endif

	// Free the old path, in case we got called before
	if (pVRC->pLatticePath != NULL) 
	{
		FreeLatticePath(pVRC->pLatticePath);
		pVRC->pLatticePath = NULL;
	}

	// Get our final path.  Note that the path may get changed
	// if ProcessHRC is called again, particularly after 
	// EndPenInputHRC is called, because the language model will
	// be applied.
	if (!GetCurrentPath(pVRC->pLattice, &pVRC->pLatticePath)) 
	{
		return HRCR_ERROR;
	}

	ASSERT(pVRC->pLatticePath!=NULL);

    return	HRCR_OK;
}

// Hacked free input results call.
int GetResultsHRC(
	HRC			hrc,
	UINT		uType,
	HRCRESULT	*pHRCResults,
	UINT		cResults
) {
	VRC			*pVRC	= (VRC *)hrc;
	VRCRESULT	*pVRCResults;

	LogMessage("GetResultsHRC()\n");

	// Check parameters.
	if (!hrc || pVRC->fBoxedInput || !pVRC->pLattice || !pHRCResults) {
		ASSERT(("Bad lattice\n",0));
		return HRCR_ERROR;
	}
	if (!pVRC->pLatticePath) {
		ASSERT(("Haven't processed input\n",0));
		return HRCR_ERROR;
	}
	if (uType == GRH_GESTURE || cResults == 0) {
		ASSERT(("Requested zero alternates\n",0));
		return 0;
	}
//	if (GetLatticeStrokeCount(pVRC->pLattice) < 1) {
//		ASSERT(("No strokes\n",0));
//		return 0;
//	}

	// Allocate space to hold results.
	pVRCResults	= ExternAlloc(sizeof(VRCRESULT));
	if (!pVRCResults) {
		ASSERT(("No memory\n",0));
		return HRCR_ERROR;
	}

	// OK we have results.  We always return a special code to indicate
	// return top one for everything.
	pVRCResults->pVRC	= pVRC;
	pVRCResults->wch	= ALL_TOP_ONE;
	*pHRCResults		= (HRCRESULT)pVRCResults;

	return 1;
}

// The other hacked free input results call.
int  GetAlternateWordsHRCRESULT(
	HRCRESULT	hrcResult,
	UINT		iChar,
	UINT		cChar,
	HRCRESULT	*pHRCResults,
	UINT		cHRCResults
) {
	VRCRESULT	*pVRCResult	= (VRCRESULT *)hrcResult;
	VRC			*pVRC;
	UINT		ii;
	UINT		maxAlts, cAlts;
	UINT		iCorrect;
	HRCRESULT	hCorrect;
	wchar_t		aAlts[MAX_ALTERNATES];

	LogMessage("GetAlternateWordsHRCRESULT()\n");

	// Check parameters.
	if (!hrcResult || !pHRCResults) {
		return HRCR_ERROR;
	}
	pVRC	= pVRCResult->pVRC;
	if (!pVRC || pVRC->fBoxedInput || !pVRC->pLatticePath) {
		ASSERT(("Bad lattice or haven't processed input",0));
		return HRCR_ERROR;
	}
	if (pVRCResult->wch != ALL_TOP_ONE || cChar != 1) {
		return HRCR_UNSUPPORTED;
	}
	if (iChar >= (UINT)pVRC->pLatticePath->nChars) {
		return HRCR_UNSUPPORTED;
	}

	// Compute limit on alternates to return.
	maxAlts	= min(MAX_ALTERNATES, cHRCResults);

	// Get the alternates.
	cAlts	= GetAlternatesForCharacterInCurrentPath(
		pVRC->pLattice, pVRC->pLatticePath, iChar, maxAlts, aAlts
	);

	// Now build up array of results structures.
	iCorrect	= (UINT)-1;
	for (ii = 0; ii < cAlts; ++ii) {
		VRCRESULT	*pNew;

		// Allocate space to hold results.
		pNew	= ExternAlloc(sizeof(VRCRESULT));
		if (!pNew) {
			UINT	jj;

			// Clean up any allocated results
			for (jj = 0 ; jj < ii; ++jj) {
				ExternFree(pHRCResults[jj]);
			}
			return HRCR_ERROR;
		}

		// Fill in this alternate.
		pNew->pVRC		= pVRC;
		pNew->wch		= aAlts[ii];
		pNew->iChar		= (short)iChar;
		pHRCResults[ii]	= (HRCRESULT)pNew;

		if (pVRC->pLatticePath->pElem[iChar].wChar == aAlts[ii]) {
			iCorrect	= ii;
		}
	}

	// If answer in path is not in list, over-write the last entry.
	if (iCorrect == (UINT)-1) {
		iCorrect	= cAlts - 1;
		((VRCRESULT *)(pHRCResults[iCorrect]))->wch		= pVRC->pLatticePath->pElem[iChar].wChar;
	}

	// Now do the reorder as needed.
	hCorrect	= pHRCResults[iCorrect];
	for (ii = iCorrect; ii > 0 ; --ii) {
		pHRCResults[ii]	= pHRCResults[ii - 1];
	}
	pHRCResults[0]	= hCorrect;

	// For debug version, be paranoid, and zero any unused elements in
	// the output array.
#	ifdef DBG
		for (ii = cAlts ; ii < cHRCResults; ++ii) {
			pHRCResults[ii]	= (HRCRESULT)0;
		}
#	endif

	return cAlts;
}

// This does NOT include a null symbol at the end.
int GetSymbolCountHRCRESULT(HRCRESULT hrcResult)
{
	VRCRESULT	*pVRCResult	= (VRCRESULT *)hrcResult;
	VRC			*pVRC;

	LogMessage("GetSymbolCountHRCRESULT()\n");

	if (!hrcResult) {
		return HRCR_ERROR;
	}
	pVRC	= pVRCResult->pVRC;
	if (!pVRC || pVRC->fBoxedInput 
		|| !pVRC->pLatticePath
	) {
		return HRCR_ERROR;
	}

	// Terminal HRCResults reflect only one character.
	if (pVRCResult->wch != ALL_TOP_ONE) {
		return 1;
	}

	// The path tells us how many character there are.
	LogMessage("  %d chars\n",pVRC->pLatticePath->nChars);
	return	pVRC->pLatticePath->nChars;
}

// Convert an HRCRESULT into the correct character(s).
int       GetSymbolsHRCRESULT(
	HRCRESULT	hrcResult,
	UINT		iSyv,
	SYV			*pSyv,
	UINT		cSyv
) {
	VRCRESULT	*pVRCResult	= (VRCRESULT *)hrcResult;
	VRC			*pVRC;

	LogMessage("GetSymbolsHRCRESULT()\n");

	if (!hrcResult) {
		return HRCR_ERROR;
	}
	pVRC	= pVRCResult->pVRC;
	if (!pVRC || pVRC->fBoxedInput || pVRC->fBoxedInput
		|| !pVRC->pLatticePath
	) {
		return HRCR_ERROR;
	}

	// Did they really ask for anything.
	if (cSyv == 0 || iSyv >= (UINT)pVRC->pLatticePath->nChars) {
		return 0;
	}

	// Are we getting the full string, or just an alternate.
	if (pVRCResult->wch != ALL_TOP_ONE) {
		// Just one alternate.
		pSyv[0]	= MAKELONG(pVRCResult->wch, SYVHI_UNICODE);
		LogMessage("  result U+%04X\n",pVRCResult->wch);
		return 1;
	} else {
		// Getting a full string.
		UINT		ii;
		UINT		cValid;

		// Characters available from requested starting position.
		cValid		= pVRC->pLatticePath->nChars - iSyv;

		// Does the caller want fewer than we have available.
		if (cValid > cSyv) {
			cValid	= cSyv;
		}

		// OK, copy over what we have.
		for (ii = 0; ii < cValid; ++ii) {
			wchar_t		wch;

			wch			= pVRC->pLatticePath->pElem[ii + iSyv].wChar;
			//wch			= LocRunDense2Unicode(&g_locRunInfo, wch);
			LogMessage("  char %d is U+%04X\n",ii,wch);
			// Convert to SYV and put in output array.
			pSyv[ii]	= MAKELONG(wch, SYVHI_UNICODE);
		}

		return cValid;
	}


	return 0;
}

// Translates an array of symbols into a Unicode string.
// Code copied from \hwx\common, probably should be shared.
BOOL SymbolToCharacterW(SYV *pSyv, int cSyv, WCHAR *wsz, int *pCount)
{
	int c = 0;
	int ret = 1;

	LogMessage("SymbolToCharacterW()\n");

	for (; cSyv; pSyv++, wsz++, cSyv--, c++) {
		if (HIWORD(*pSyv) == SYVHI_UNICODE) {
			*wsz = LOWORD(*pSyv);
		} else if (HIWORD(*pSyv) == SYVHI_ANSI) {
			// No support for ANSI in EA recognizer.
			ASSERT(0);
			ret = 0;
		} else if (*pSyv == SYV_NULL) {
			*wsz = '\0';
		} else {
			*wsz = '\0';
			ret = 0;
		}

		if (*wsz!=0) LogMessage("  result=U+%04X\n",*wsz);

		// Break on NULL done here rather than at SYV_NULL check above,
		// because an ANSI or UNICODE char might also be NULL.
		if (!*wsz) {
			break;
		}
	}

	if (pCount)
		*pCount = c;

	return ret;
}

// Free memory allocated for hrcResult.
int DestroyHRCRESULT(HRCRESULT hrcResult)
{
	LogMessage("DestroyHRCRESULT()\n");

	if (!hrcResult) {
		return HRCR_ERROR;
	}

	ExternFree(hrcResult);
	return HRCR_OK;
}

int SetGuideHRC(HRC hrc, LPGUIDE lpguide, UINT nFirstVisible)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("SetGuideHRC()\n");

	// Check parameters.
	if (!hrc || pVRC->fBoxedInput || !pVRC->pLattice) {
		ASSERT(("Invalid lattice or boxed mode",0));
		return HRCR_ERROR;
	}

	// The following condition should really be: fHaveInput || fEndInput || pLatticePath
	// but this was remove to get the free input UI working.
	if (pVRC->fBeginProcess || pVRC->pLatticePath) {
		ASSERT(("Already processed some strokes in SetGuideHRC",0));
		return HRCR_ERROR;
	}

	// We only work with no guide.
	if (lpguide!=NULL && (lpguide->cHorzBox != 0 || lpguide->cVertBox != 0)) {
		ASSERT(("Wrong kind of guide",0));
		return HRCR_ERROR;
	}

    return HRCR_OK;
}

int SetAlphabetHRC(HRC hrc, ALC alc, LPBYTE rgbfAlc)
{
	VRC			*pVRC	= (VRC *)hrc;

    rgbfAlc = rgbfAlc;

	// Check parameters.
	if (!hrc || pVRC->fBoxedInput || !pVRC->pLattice) {
		return HRCR_ERROR;
	}

	// The following condition should really be: fHaveInput || fEndInput || pLatticePath
	// but this was remove to get the free input UI working.
	if (pVRC->fBeginProcess || pVRC->pLatticePath) {
		return HRCR_ERROR;
	}

	// Pass the ALC on to the lattice.
	SetLatticeALCValid(pVRC->pLattice, alc);

    return	HRCR_OK;
}

HINKSET CreateInksetHRCRESULT(
	HRCRESULT		hrcResult,
	unsigned int	iChar,
	unsigned int	cChar
) {
	VRCRESULT	*pVRCResult	= (VRCRESULT *)hrcResult;
	VRC			*pVRC;
	VINKSET		*pVInkSet;
	DWORD		begin, end;

	LogMessage("CreateInksetHRCRESULT()\n");

	// Check parameters.
	if (!hrcResult) {
		return NULL;
	}
	pVRC	= pVRCResult->pVRC;
	if (!pVRC || pVRC->fBoxedInput 
		|| !pVRC->pLatticePath
	) {
		return NULL;
	}
	if (pVRCResult->wch != 0xFFFF) {
		return NULL;	// Not top level result.
	}
	if (cChar < 1 || (iChar + cChar)  > (UINT)pVRC->pLatticePath->nChars) {
		return NULL;	// Not one or more characters in valid range.
	}

	// Allocate an inkset structure.
	pVInkSet	= ExternAlloc(sizeof(VINKSET));
	if (!pVInkSet) {
		return NULL;
	}

	// Fill it in.
	pVInkSet->pVRC	= pVRC;
	pVInkSet->cChar	= cChar;
	pVInkSet->iChar	= iChar;

   	// Get the tick counts.
	if (GetCharacterTimeRange(
		    pVRC->pLattice, pVRC->pLatticePath, pVInkSet->iChar,
		    pVInkSet->iChar + pVInkSet->cChar, &begin, &end))
    {
        pVInkSet->cIntervals = 1;
    }
    else
    {
        pVInkSet->cIntervals = 0;
    }

	// Return it.
	return (HINKSET)pVInkSet;
}

BOOL DestroyInkset(HINKSET hInkset)
{
	LogMessage("DestroyInkset()\n");

	if (!hInkset) {
		return FALSE;
	}

	ExternFree(hInkset);
	return TRUE;
}

int GetInksetInterval(
	HINKSET			hInkset,
	unsigned int	uIndex,
	INTERVAL		*pI
) {
	VINKSET		*pVInkSet	= (VINKSET *)hInkset;
	VRC			*pVRC;
	DWORD		begin, end;

	LogMessage("GetInksetInterval()\n");

	// Check parameters
	if (!hInkset || !pVInkSet->pVRC) {
		return ISR_ERROR;
	}
	pVRC	= pVInkSet->pVRC;
	if (!pVRC || pVRC->fBoxedInput 
		|| !pVRC->pLatticePath
	) {
		return ISR_ERROR;
	}

	// Only one range per string.
	if (pVInkSet->cIntervals == 0 || (uIndex != 0 && uIndex != IX_END)) {
		return ISR_BADINDEX;
	}

	// Get the tick counts.
	GetCharacterTimeRange(
		pVRC->pLattice, pVRC->pLatticePath, pVInkSet->iChar,
		pVInkSet->iChar + pVInkSet->cChar, &begin, &end
	);

	// OK convert from ms to ABSTIME.
	MakeAbsTime(&pI->atBegin, 0, begin);
	MakeAbsTime(&pI->atEnd, 0, end);

	LogMessage("  interval %d to %d\n",begin,end);

	return 1;
}

int GetInksetIntervalCount(HINKSET hInkset)
{
	VINKSET		*pVInkSet	= (VINKSET *)hInkset;
	LogMessage("GetInksetIntervalCount()\n");

	if (!hInkset) {
		return ISR_ERROR;
	}

	return pVInkSet->cIntervals;
}

// Given a character, make a guess at what the bounding box around it would have been.
int GetBaselineHRCRESULT(
	HRCRESULT	hrcResult,
	RECT		*pRect,
	BOOL		*pfBaselineValid,
	BOOL		*pfMidlineValid)
{
	VRCRESULT	*pVRCResult	= (VRCRESULT *)hrcResult;
	VRC			*pVRC;

	LogMessage("GetBaselineHRCRESULT(%08X)\n",hrcResult);

	// Check parameters.
	if (!hrcResult) {
		return HRCR_ERROR;
	}
	pVRC	= pVRCResult->pVRC;
	if (!pVRC || pVRC->fBoxedInput || !pVRC->pLatticePath) {
		return HRCR_ERROR;
	}

	if (pVRCResult->wch == ALL_TOP_ONE) {
		// They want a bbox for the whole ink... just 
		// return an error in this case, since it isn't
		// meaningful.
		return HRCR_ERROR;
	} else {
		if (!GetBoxOfAlternateInCurrentPath(pVRC->pLattice, pVRC->pLatticePath, pVRCResult->iChar, pRect)) {
			*pfBaselineValid = FALSE;
			*pfMidlineValid = FALSE;
		} else {
			*pfBaselineValid = TRUE;
			*pfMidlineValid = TRUE;
		}
	}

	LogMessage("  result left,right=%d,%d top,bottom=%d,%d valid=%d,%d\n",
		pRect->left,pRect->right,pRect->top,pRect->bottom,
		*pfBaselineValid,*pfMidlineValid);

	return HRCR_OK;
}

// Set the context for the ink that is being recognized.
// wszBefore and wszAfter can both be NULL.  The function
// return TRUE on success, and FALSE on a memory allocation
// error.
BOOL SetHwxCorrectionContext(HRC hrc, wchar_t *wszBefore, wchar_t *wszAfter)
{
	VRC			*pVRC	= (VRC *)hrc;
    int iDest, i;

    LogMessage("SetHwxCorrectionContext(%d,%d)\n",
        (wszBefore == NULL ? 0 : wcslen(wszBefore)),
        (wszAfter == NULL ? 0 : wcslen(wszAfter)));

	// Check parameters.
	if (!hrc || !pVRC->pLattice) {
		return FALSE;
	}

    // Make sure we do this before any input
	if (pVRC->fHaveInput || pVRC->fEndInput || pVRC->pLatticePath) {
		return FALSE;
	}

    // Free up previous context settings
    ExternFree(pVRC->pLattice->wszBefore);
    ExternFree(pVRC->pLattice->wszAfter);
    pVRC->pLattice->wszBefore = NULL;
    pVRC->pLattice->wszAfter = NULL;

    // If we are given any pre-context
    if (wszBefore != NULL && wcslen(wszBefore) > 0) 
    {
        // Make a space for the context and check for allocation failure
        pVRC->pLattice->wszBefore = ExternAlloc(sizeof(wchar_t) * (wcslen(wszBefore) + 1));
        if (pVRC->pLattice->wszBefore == NULL) 
        {
            return FALSE;
        }
        // Translate the string to dense codes, reversing the order of the
        // characters and stopping at the first one not supported by the recognizer.
        iDest = 0;
        for (i = wcslen(wszBefore) - 1; i >= 0; i--)
        {
            wchar_t dch = LocRunUnicode2Dense(&g_locRunInfo, wszBefore[i]);
            pVRC->pLattice->wszBefore[iDest] = dch;
            if (dch == LOC_TRAIN_NO_DENSE_CODE)
            {
                break;
            }
            iDest++;
        }
        pVRC->pLattice->wszBefore[iDest] = 0;
        // If the context was zero length after translation, set it to NULL.
        if (wcslen(pVRC->pLattice->wszBefore) == 0) 
        {
            ExternFree(pVRC->pLattice->wszBefore);
            pVRC->pLattice->wszBefore = NULL;
        }
    }

    // If we are given any post-context
    if (wszAfter != NULL && wcslen(wszAfter) > 0)
    {
        // Make a space for the context and check for allocation failure
        pVRC->pLattice->wszAfter = ExternAlloc(sizeof(wchar_t) * (wcslen(wszAfter) + 1));
        if (pVRC->pLattice->wszAfter == NULL) 
        {
            ExternFree(pVRC->pLattice->wszBefore);
            pVRC->pLattice->wszBefore = NULL;
            return FALSE;
        }

        // Translate the string to dense codes, stopping at the first character
        // not supported by the recognizer.
        for (i = 0; i < (int) wcslen(wszAfter); i++)
        {
            wchar_t dch = LocRunUnicode2Dense(&g_locRunInfo, wszAfter[i]);
            pVRC->pLattice->wszAfter[i] = dch;
            if (dch == LOC_TRAIN_NO_DENSE_CODE)
                break;
        }
        pVRC->pLattice->wszAfter[i] = 0;
        // If the context was zero length after translation, set it to NULL
        if (wcslen(pVRC->pLattice->wszAfter) == 0) 
        {
            ExternFree(pVRC->pLattice->wszAfter);
            pVRC->pLattice->wszAfter = NULL;
        }
    }

    // Return success
    return TRUE;
}

#ifndef USE_RESOURCES
// The three functions below are private APIs
// They are only defined in the multi-language version of the recognizer,
// not the ones that get shipped.

#ifdef HWX_TUNE
FILE *g_pTuneFile = NULL;
int g_iTuneMode = 0;
#endif

// Configures the lattice to record tuning information.  Must be called before 
// any strokes are added to the lattice.
int RecordTuningInformation(wchar_t *wszTuneFile)
{
	LogMessage("RecordTuningInformation()\n");

#ifdef HWX_TUNE
    if (g_pTuneFile != NULL) 
    {
        g_iTuneMode = 0;
        if (fclose(g_pTuneFile) < 0) 
        {
            g_pTuneFile = NULL;
            return HRCR_ERROR;
        }
        g_pTuneFile = NULL;
    }

    if (wszTuneFile != NULL) 
    {
        BOOL fBinary = FALSE;
        // Get the tuning mode based on a file name component
        if (wcsstr(wszTuneFile, L".lintuneV.") != NULL)
        {
            g_iTuneMode = 1;
            fBinary = TRUE;
        }
        if (wcsstr(wszTuneFile, L".threshold.") != NULL)
        {
            g_iTuneMode = 2;
        }
        if (wcsstr(wszTuneFile, L".lattice.") != NULL)
        {
            g_iTuneMode = 3;
        }
        g_pTuneFile = _wfopen(wszTuneFile, (fBinary ? L"wb" : L"w"));
        if (g_pTuneFile == NULL) 
        {
            g_iTuneMode = 0;
            return HRCR_ERROR;
        }
    }
	return HRCR_OK;
#else
    return HRCR_ERROR;
#endif
}

// Given a lattice and a string of unicode characters, find the best path through the lattice 
// which gives that sequence of characters.  Baring that, it will find the most likely path
// through the lattice with the same number of characters and the minimum number of mismatches
// to the prompt.  In case no such path can be found, the current path becomes empty.  
// The function returns the number of substitutions used, or -1 if there is no path with
// the desired number of characters, -2 if a memory allocation error occurs, or -3 if a 
// file write error occurs.
int SearchForTargetResult(HRC hrc, wchar_t *wsz)
{
	int nSubs = 0;
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("SearchForTargetResult()\n");

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) {
		ASSERT(("Bad lattice\n",0));
		return HRCR_ERROR;
	}

	// Processing done?
	if (!(pVRC->fEndInput && pVRC->pLatticePath != NULL)) {
		ASSERT(("Lattice not processed yet\n",0));
		return HRCR_ERROR;
	}

	// Free the old path, in case we got called before
	if (pVRC->pLatticePath != NULL) {
		FreeLatticePath(pVRC->pLatticePath);
		pVRC->pLatticePath = NULL;
	}

    if (g_iTuneMode == 3) 
    {
        // Tuning mode 3 means dump out the IFELang3 lattices and correct answers.
		ApplyLanguageModel(pVRC->pLattice, wsz);
    }
    else
    {
	    nSubs = SearchForTargetResultInternal(pVRC->pLattice, wsz);
    }

	// Get the final path.  
	if (!GetCurrentPath(pVRC->pLattice, &pVRC->pLatticePath))
    {
        return -2;
    }

	return nSubs;
}

// Accessor macros for the bitmask above
#define SetAllowedChar(bpMask, dch) (bpMask)[(dch) / 8] |= 1 << ((dch) % 8)

BOOL HwxSetAnswerW(HRC hrc, wchar_t *wsz, int iMode)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("HwxSetAnswerW()\n");

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) 
    {
		ASSERT(("Bad lattice\n",0));
		return FALSE;
	}

    pVRC->pLattice->wszAnswer = ExternAlloc((wcslen(wsz) + 1) * sizeof(wchar_t));
    if (pVRC->pLattice->wszAnswer == NULL)
    {
        ASSERT(("Out of memory allocating space.\n", 0));
        return FALSE;
    }
    wcscpy(pVRC->pLattice->wszAnswer, wsz);

    // Mode one means running the separator
    if (iMode == 1) 
    {
        pVRC->pLattice->fSepMode = TRUE;
    }

    // Mode 1 means we limit the characters that can be returned to those
    // in the answer.
    if (iMode == 1)
    {
        int iChar;

        // Allocate a bit mask which holds all the folded and dense codes
        int iMaskSize = (g_locRunInfo.cCodePoints + g_locRunInfo.cFoldingSets + 7) / 8;
        BYTE *pbMask = ExternAlloc(iMaskSize);
        if (pbMask == NULL) 
        {
            ASSERT(("Out of memory allocating space.\n", 0));
            return FALSE;
        }

        // Fill in the mask based on the prompt
        memset(pbMask, 0, iMaskSize);
        for (iChar = 0; iChar < (int) wcslen(wsz); iChar++)
        {
            wchar_t dch = LocRunUnicode2Dense(&g_locRunInfo, wsz[iChar]);
            if (dch != LOC_TRAIN_NO_DENSE_CODE) 
            {
                // Try folding the character
                wchar_t fdch = LocRunDense2Folded(&g_locRunInfo, dch);
                if (fdch != 0) 
                {
                    // Set the mask allowing this folding set
                    SetAllowedChar(pbMask, fdch);
                }
                // Set the mask allowing the unfolded character
                SetAllowedChar(pbMask, dch);
            }
        }

        // Store the mask in the recog settings.
        pVRC->pLattice->recogSettings.pbAllowedChars = pbMask;
        pVRC->pLattice->recogSettings.alcValid = 0;
    }

    return TRUE;
}

#endif // !USE_RESOURCES

BOOL SetHwxFlags(HRC hrc, DWORD dwFlags)
{
	VRC			*pVRC	= (VRC *)hrc;

	LogMessage("SetHwxFlags(%08X,%08X)\n", hrc, dwFlags);

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) 
    {
		ASSERT(("Bad lattice\n",0));
		return FALSE;
	}

    if (pVRC->fBeginProcess) 
    {
//        ASSERT(("Already started processing in SetHwxFlags", 0));
        return FALSE;
    }

    if (dwFlags & ~(RECOFLAG_WORDMODE | RECOFLAG_SINGLESEG | RECOFLAG_COERCE))
    {
//        ASSERT(("Unknown flag set\n",0));
        return FALSE;
    }

    pVRC->pLattice->fWordMode = ((dwFlags & RECOFLAG_WORDMODE) != 0);
    pVRC->pLattice->fCoerceMode = ((dwFlags & RECOFLAG_COERCE) != 0);
    pVRC->pLattice->fSingleSeg = ((dwFlags & RECOFLAG_SINGLESEG) != 0);
    return TRUE;
}

#define MAX_FACTOIDS 10

/******************************Public*Routine******************************\
* SetHwxFactoid
*
* New API for factoids.
*
* Return values:
*    HRCR_OK          success
*    HRCR_ERROR       failure
*    HRCR_CONFLICT    ProcessHRC has already been called, cannot call me now
*    HRCR_UNSUPPORTED don't support this factoid string
\**************************************************************************/
int SetHwxFactoid(HRC hrc, wchar_t *wszFactoid)
{
	VRC			*pVRC	= (VRC *)hrc;
    int nFactoids, i;
    DWORD aFactoids[MAX_FACTOIDS];
    BYTE *pbOldFactoidChars;
    ALC alcOldFactoid;

	LogMessage("SetHwxFactoid(%08X,%S)\n", hrc, wszFactoid);

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) 
    {
		return HRCR_ERROR;
	}

    if (pVRC->fBeginProcess) 
    {
        return HRCR_CONFLICT;
    }

    // Special case to reset back to the default
    if (wszFactoid == NULL)
    {
        // Clear out any previous factoid settings
        SetFactoidDefaultInternal(pVRC->pLattice);
        return HRCR_OK;
    }

    // Parse the string
    nFactoids = ParseFactoidString(wszFactoid, MAX_FACTOIDS, aFactoids);
    if (nFactoids <= 0) 
    {
        return HRCR_UNSUPPORTED;
    }

    // Check to see if all the factoids set are supported
    for (i = 0; i < nFactoids; i++)
    {
        if (!IsSupportedFactoid(aFactoids[i]))
        {
            return HRCR_UNSUPPORTED;
        }
    }

    // Reset to the empty set of chars and clear out any ALCs
    alcOldFactoid = pVRC->pLattice->alcFactoid;
    pbOldFactoidChars = pVRC->pLattice->pbFactoidChars;

    pVRC->pLattice->alcFactoid = 0;
    pVRC->pLattice->pbFactoidChars = NULL;

    // For each factoid set
    for (i = 0; i < nFactoids; i++) 
    {
        if (!SetFactoidInternal(&g_locRunInfo, pVRC->pLattice, aFactoids[i]))
        {
            // Roll back to original settings
            pVRC->pLattice->alcFactoid = alcOldFactoid;
            ExternFree(pVRC->pLattice->pbFactoidChars);
            pVRC->pLattice->pbFactoidChars = pbOldFactoidChars;
            return HRCR_ERROR;
        }
    }

    pVRC->pLattice->fUseFactoid = TRUE;

    // Turn off the default language model if an empty factoid is set.
    // May want to add this to other factoids in the future, or just
    // use a real language model.
    if (nFactoids == 1 && aFactoids[0] == FACTOID_NONE) 
    {
        pVRC->pLattice->fUseLM = FALSE;
    }
    else 
    {
        pVRC->pLattice->fUseLM = TRUE;
    }

    // Clear out the ALCs
    pVRC->pLattice->recogSettings.alcValid = 0xFFFFFFFF;
    ExternFree(pVRC->pLattice->recogSettings.pbAllowedChars);
    pVRC->pLattice->recogSettings.pbAllowedChars = NULL;

    pVRC->pLattice->recogSettings.alcPriority = 0;
    ExternFree(pVRC->pLattice->recogSettings.pbPriorityChars);
    pVRC->pLattice->recogSettings.pbPriorityChars = NULL;
    
    return HRCR_OK;
}

// Note that for now this function only considers the factoid, and ignores
// any ALC settings.
BOOL IsWStringSupportedHRC(HRC hrc, wchar_t *wsz)
{
	VRC			*pVRC	= (VRC *)hrc;
    BOOL        fSupported = TRUE;
    CHARSET charset;

    LogMessage("IsWStringSupportedHRC()\n");

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) 
    {
		ASSERT(("Bad lattice\n",0));
		return FALSE;
	}

    // If no factoid has been set yet, then use the default.
    if (!pVRC->pLattice->fUseFactoid)
    {
        SetFactoidDefaultInternal(pVRC->pLattice);
    }

    charset.recmask = pVRC->pLattice->alcFactoid;
    charset.pbAllowedChars = pVRC->pLattice->pbFactoidChars;

    // Loop over the string
    while (*wsz != 0 && fSupported)
    {
        // First check if it is supported in the dense codes
        wchar_t dch = LocRunUnicode2Dense(&g_locRunInfo, *wsz);
        if (dch == LOC_TRAIN_NO_DENSE_CODE) 
        {
            fSupported = FALSE;
            break;
        }

        // Then check if it is allowed by the factoid
        if (!IsAllowedChar(&g_locRunInfo, &charset, dch))
        {
            fSupported = FALSE;
            break;
        }
        wsz++;
    }
    
    return fSupported;
}

#ifndef USE_RESOURCES
BOOL GetSupportedChars(HRC hrc, wchar_t wsz[65536])
{
	VRC		*pVRC	= (VRC *)hrc;
    CHARSET charset;
    int     i, iDest;

    LogMessage("GetSupportedChars()\n");

	// Check parameters.
	if (hrc == NULL || pVRC->pLattice == NULL) 
    {
		ASSERT(("Bad lattice\n",0));
		return FALSE;
	}

    // If no factoid has been set yet, then use the default.
    if (!pVRC->pLattice->fUseFactoid)
    {
        SetFactoidDefaultInternal(pVRC->pLattice);
    }

    charset.recmask = pVRC->pLattice->alcFactoid;
    charset.pbAllowedChars = pVRC->pLattice->pbFactoidChars;

    iDest = 0;
    for (i = 1; i < g_locRunInfo.cCodePoints; i++) 
    {
        if (IsAllowedChar(&g_locRunInfo, &charset, (wchar_t) i)) 
        {
            wsz[iDest++] = LocRunDense2Unicode(&g_locRunInfo, (wchar_t) i);
        }
    }
    wsz[iDest] = 0;
    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\lattice-lm.cpp ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/lattice-lm.cpp
//
// Description:
//	    Interface between the recognizer and IFELang3.  Unlike the rest of 
//      the recognizer this is written in C++ because IFELang3 uses a COM
//      interface.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

// Conditional define for use of IFELang3, so it can be turned off for WinCE
#ifdef USE_IFELANG3

#include <stdlib.h>
#include <limits.h>

// Make sure the GUIDs defined in imlang.h actually get instantiated
#define INITGUID

// Uncomment to dump out the lattice fed to the language model
//#define DUMP_LM_LATTICE
// Uncomment to append all the lattices into one file rather than overwriting.
//#define DUMP_LM_LATTICE_APPEND
#define LM_LATTICE_FILENAME L"c:/temp/cht-lm-log.txt"
// Uncomment this to get the dumped lattice in the form expected by the CHS test program
//#define LM_LATTICE_UNICODE
//#define LM_LATTICE_CHS
#define LM_LATTICE_CHT

#if defined(HWX_TUNE) || defined(DUMP_LM_LATTICE)
#include <stdio.h>
#endif

#include "volcanop.h"

// Japanese and IFELang3 generic stuff
#include "imlang.h"

// Simplified and traditional Chinese
#include "fel3user.h"

#ifdef USE_IFELANG3_BIGRAMS
#include "lattice-bigram.h"
#endif

// A global pointer to the IIMLanguage interface object
static IIMLanguage *g_pIFELang3=NULL;

// Each language has its own set of GUIDs used as command codes, so that the IIMLanguage interface can direct requests to
// the appropriate language model.
static int SetLanguageModelCommands(IMLANGUAGE_LM aLMITEM[3], IMLANGUAGE_LM_PARAM *sTuneParam, SImeLMParam *sHWTip1Param)
{
	int nLMITEM = 0;

	// Japanese
	if (wcsicmp(g_szRecognizerLanguage,L"JPN")==0) {
/*		aLMITEM[nLMITEM].guid = CLSID_MakeLatticeForChar;
		aLMITEM[nLMITEM].pParam = NULL;
		nLMITEM++;
		aLMITEM[nLMITEM].guid = CLSID_AttachNGram;
		aLMITEM[nLMITEM].pParam = NULL;
		nLMITEM++;
		aLMITEM[nLMITEM].guid = CLSID_SearchBestPath;
		aLMITEM[nLMITEM].pParam = NULL;
		nLMITEM++; */
		aLMITEM[nLMITEM].guid = CLSID_JPN_IMELM_BBO_OS;
		aLMITEM[nLMITEM].pParam = NULL;
		nLMITEM++; 
	}

	// For now, disable the use of the Chinese and Korean language models, since
	// at least the Chinese language models currently are hurting accuracy.

	// Simplified Chinese
	if (wcsicmp(g_szRecognizerLanguage,L"CHS")==0) {
		sHWTip1Param->dwLicenseId = CHINESE_IMELM_LICENSEID;
		sHWTip1Param->flWeight = (float)(1.0);
		sTuneParam->guid = GUID_CHINESE_IMELM_PARAM;
		sTuneParam->dwSize = sizeof(SImeLMParam);
		sTuneParam->pbData = (BYTE*)sHWTip1Param;
		aLMITEM[nLMITEM].guid = CLSID_CHS_IMELM_BBO_OS;
		aLMITEM[nLMITEM].pParam = sTuneParam;
		nLMITEM++;
	}

#if 0
	// Traditional Chinese
	if (wcsicmp(g_szRecognizerLanguage,L"CHT")==0) {
		sHWTip1Param->dwLicenseId = CHINESE_IMELM_LICENSEID;
		sHWTip1Param->flWeight = (float)(1.0);
		sTuneParam->guid = GUID_CHINESE_IMELM_PARAM;
		sTuneParam->dwSize = sizeof(SImeLMParam);
		sTuneParam->pbData = (BYTE*)sHWTip1Param;
		aLMITEM[nLMITEM].guid = CLSID_CHT_IMELM_BBO_OS;
		aLMITEM[nLMITEM].pParam = sTuneParam;
		nLMITEM++;
	}

	// Korean
	if (wcsicmp(g_szRecognizerLanguage,L"KOR")==0) {
		aLMITEM[nLMITEM].guid = CLSID_KOR_IMELM_BBO_OS;
		aLMITEM[nLMITEM].pParam = NULL;
		nLMITEM++;
	}
#endif

	// Return the number of command codes, or 0 if there was no match for the current language
	return nLMITEM;
}

// This function tests the IIMLanguage interface to see if the appropriate language model is
// installed.  
BOOL TryDummyLattice()
{
    IMLANGUAGE_LM_PARAM		sTuneParam;
    SImeLMParam				sHWTip1Param;
	IMLANGUAGE_LM			aLMITEM[3];
	int nLMITEM = 0;
	HRESULT rc;

	// Set return code to look like an error
	rc = E_FAIL;

	// Set up the language specific commands
	nLMITEM = SetLanguageModelCommands(aLMITEM, &sTuneParam, &sHWTip1Param);

	if (nLMITEM>0) {
		// If there are any commands for that language, then apply them to the lattice.
		rc	= g_pIFELang3->GetLatticeMorphResult(nLMITEM, aLMITEM, 0, NULL, 0, NULL);
	}

	return (SUCCEEDED(rc));
}

// Load up IIMLanguage and check if it has a language model for this recognizer's language.
// If successful, returns TRUE, otherwise returns FALSE.
BOOL LatticeConfigIFELang3()
{
	if (g_pIFELang3 != NULL)
	{
		return FALSE;
	}
	HRESULT res = CoCreateInstance(CLSID_IMLanguage_OS, NULL, CLSCTX_INPROC_SERVER, IID_IMLanguage, (void**)&g_pIFELang3);
//	TPDBG_DMSG2("%08X: CoCreate(CLSID_IMLanguage_OS) -> %08X\n", GetCurrentThreadId(), res);
	if (SUCCEEDED(res)) {
		if (TryDummyLattice()) {
//			TPDBG_DMSG1("%08X: TryDummyLattice() -> TRUE\n", GetCurrentThreadId());
			return TRUE;
		}
	}
	// Clean up if things didn't work.
//	TPDBG_DMSG1("%08X: TryDummyLattice() -> FALSE\n", GetCurrentThreadId());
	LatticeUnconfigIFELang3();
	return FALSE;
}

// Check whether IIMLanguage is loaded.
BOOL LatticeIFELang3Available()
{
	return (g_pIFELang3!=NULL);
}

// Unload IIMLanguage if it is loaded.
BOOL LatticeUnconfigIFELang3()
{
	if (g_pIFELang3!=NULL) {
//		TPDBG_DMSG1("%08X: g_pIFELang3->Release()\n", GetCurrentThreadId());
		g_pIFELang3->Release();
		g_pIFELang3=NULL;
	}
	return TRUE;
}

// qsort: compare the start time of element
int __cdecl CompareElemTime(const void *ps1, const void *ps2)
{
    return ((IMLANGUAGE_ELEMENT*)ps1)->dwFrameStart -
        ((IMLANGUAGE_ELEMENT*)ps2)->dwFrameStart;
}

BOOL ProbIsBad(LATTICE *lat, float flProb)
{
    if (lat->fUseGuide) 
    {
        return (flProb < g_vtuneInfo.pTune->flStringHwxThreshold);
    }
    else
    {
        return (flProb < g_vtuneInfo.pTune->flFreeHwxThreshold);
    }
}

// Figure out which strokes are valid end of character in paths that span the
// whole lattice.
static BOOL CheckIfValid(LATTICE *lat, int iStroke, BYTE *pValidEnd)
{
	LATTICE_ALT_LIST	*pAlts;
	int					ii;
	BOOL				fValidPath;

	// Have we already checked this position?
	if (pValidEnd[iStroke] == LCF_INVALID) {
		return FALSE;
	} else if (pValidEnd[iStroke] == LCF_VALID) {
		return TRUE;
	}

	// Assume no valid path, until proved otherwise.
	fValidPath	= FALSE;

	// Process each element ending at this position in lattice.
	pAlts	= lat->pAltList + iStroke;
	for (ii = 0; ii < pAlts->nUsed; ++ii) {
		LATTICE_ELEMENT		*pElem;
		int					prevEnd;

		pElem	= pAlts->alts + ii;
		prevEnd	= iStroke - pElem->nStrokes;
		ASSERT(prevEnd >= -1);
		if (ProbIsBad(lat, pElem->logProb)) {
			// Pretend that the really bad scores don't exist!
			// This test MUST match code building up lattice to use!
		} else if (prevEnd < 0) {
			// Reached start.
			fValidPath	= TRUE;
		} else if (CheckIfValid(lat, prevEnd, pValidEnd)) {
			// Have path to start.
			fValidPath	= TRUE;
		}
	}

	// Did one (or more) paths reach the start?
	if (fValidPath) {
		pValidEnd[iStroke]	= LCF_VALID;
		return TRUE;
	} else {
		pValidEnd[iStroke]	= LCF_INVALID;
		return FALSE;
	}
}

// Apply language model to produce a better current path
void ApplyLanguageModel(LATTICE *lat, wchar_t *wszCorrectAnswer)
{
	DWORD					dwNeutralSize;
	IMLANGUAGE_ELEMENT		*pLattice;
	IMLANGUAGE_INFO			*pDataList;
#ifdef USE_IFELANG3_BIGRAMS
	DWORD					dwBigramSize;
	LATTICE_BIGRAM_INFO_LIST *pBigramInfo;
#endif
	int						cElem, cData;
	int						cLattice;
	DWORD					cElemOut;
	IMLANGUAGE_ELEMENT		*pElemOut;
    IMLANGUAGE_LM_PARAM		sTuneParam;
    SImeLMParam				sHWTip1Param;
	IMLANGUAGE_LM			aLMITEM[3];
	IMLANGUAGE_INFO_NEUTRAL1		*pNeutral;
	BYTE					*pValidEnd;
	int						size;
	int						nLMITEM;

	DWORD					ii, jj;
	HRESULT					rc;
#ifdef DUMP_LM_LATTICE
	FILE *f;
#endif
	int iStroke, iAlt;

	int cPreContext = 0, cPostContext = 0;
//  DebugBreak();
//	return;

//	fprintf(stderr,"ApplyLanguageModel()  fUseIFELang3=%d\n", lat->fUseIFELang3);
	ASSERT(lat!=NULL);
	if (!LatticeIFELang3Available()) return;
	if (!lat->fUseLM || !lat->fUseIFELang3) return;
	if (lat->nStrokes==0) return;

	// Check if there are any alphabetic characters in the best path.  If so, skip IFELang3
	for (iStroke = 0; iStroke < lat->nStrokes; iStroke++) 
	{
		for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++)
		{
			if (lat->pAltList[iStroke].alts[iAlt].fCurrentPath)
			{
				wchar_t dch = lat->pAltList[iStroke].alts[iAlt].wChar;
				if (dch != SYM_UNKNOWN)
				{
					wchar_t wch = LocRunDense2Unicode(&g_locRunInfo, dch);
					if ((wch >= L'a' && wch <= L'z') || (wch >= L'A' && wch <= L'Z'))
					{
						return;
					}
				}
			}
		}
	}

	// Check if we have a character of context that needs to be included in the lattice
    if (lat->wszBefore != NULL)
        cPreContext = wcslen(lat->wszBefore);
    if (lat->wszAfter != NULL)
        cPostContext = wcslen(lat->wszAfter);

	// How big does each lattice element need to be?  The structure includes space for
	// one character, and it needs to be followed by 2 NUL characters.
	dwNeutralSize	= sizeof(IMLANGUAGE_INFO_NEUTRAL1) + sizeof(wchar_t)*2;

	// Figure out valid character transition points by stroke.  We don't wan't to include
	// pieces of lattice that don't actually connect up for the full run.  This uses
	// a recursive algorithm to find valid paths.  Since it marks the paths as it
	// finds them, it can quickly test and not redo work.
	size		= sizeof(BYTE) * lat->nStrokes;
	pValidEnd	= (BYTE *)ExternAlloc(size);
	// If we failed to allocate memory, just return
	if (pValidEnd==NULL) return;

	memset(pValidEnd, 0, size);
	if (!CheckIfValid(lat, lat->nStrokes - 1, pValidEnd)) {
		// No valid paths found?!?!
		// This can happen... so clean up and return.  
		// We'll just get the best path selected by the HWX engine.
		goto allocated_valid;
	}

	// First allocate space to build the lattice up in.
	cElem		= lat->nStrokes * MaxAltsPerStroke + (cPreContext + cPostContext);
	cData		= cElem;
#ifdef USE_IFELANG3_BIGRAMS
	cData		+= lat->nStrokes*MaxAltsPerStroke;
#endif
	pDataList	= (IMLANGUAGE_INFO*)ExternAlloc(sizeof(IMLANGUAGE_INFO)*cData);
	if (pDataList==NULL) goto allocated_valid;
	pLattice	= (IMLANGUAGE_ELEMENT*)ExternAlloc(sizeof(IMLANGUAGE_ELEMENT)*cElem);
	if (pLattice==NULL) goto allocated_data;

#ifdef DUMP_LM_LATTICE
#ifdef DUMP_LM_LATTICE_APPEND
	f=_wfopen(LM_LATTICE_FILENAME,L"ab");
#else
	f=_wfopen(LM_LATTICE_FILENAME,L"wb");
#endif
    fwprintf(f, L"<S>\r\n\r\n");
#endif

#ifdef HWX_TUNE
    if (g_pTuneFile != NULL) 
    {
        for (int i = 0; i < (int) wcslen(wszCorrectAnswer); i++) 
        {
            if (i > 0) 
            {
                fprintf(g_pTuneFile, " ");
            }
            fprintf(g_pTuneFile, "%04X", wszCorrectAnswer[i]);
        }
        fprintf(g_pTuneFile, "\n");
    }
#endif

	cLattice		= 0;
	cData			= 0;
	if (lat->wszBefore != NULL) 
    {
        int iSrc;
        int iFrame = 1;
        for (iSrc = wcslen(lat->wszBefore) - 1; iSrc >= 0; iSrc--) 
        {
		    // If we have a context character, then create a lattice element for it.
		    pNeutral			= (IMLANGUAGE_INFO_NEUTRAL1*)ExternAlloc(dwNeutralSize);
		    if (pNeutral == NULL) goto allocated_elements;
		    pNeutral->dwUnigram	= 0;
		    pNeutral->fHypothesis = FALSE;
		    pNeutral->wsz[0]	= LocRunDense2Unicode(&g_locRunInfo, lat->wszBefore[iSrc]);
		    pNeutral->wsz[1]	= 0;
		    pNeutral->wsz[2]	= 0;

		    pDataList[cData].guid		= GUID_IMLANGUAGE_INFO_NEUTRAL1;
		    pDataList[cData].dwSize		= dwNeutralSize;
		    pDataList[cData].pbData		= (BYTE*)pNeutral;

		    pLattice[cLattice].dwFrameStart	= iFrame++;
		    pLattice[cLattice].dwFrameLen	= 1;
		    pLattice[cLattice].dwTotalInfo	= 1;
		    pLattice[cLattice].pInfo		= pDataList + cLattice;

#ifdef HWX_TUNE
            if (g_pTuneFile != NULL)
            {
                fprintf(g_pTuneFile, "%04X %d %d %f\n",
                    pNeutral->wsz[0],
                    pLattice[cLattice].dwFrameStart,
                    pLattice[cLattice].dwFrameLen,
                    0.0);
            }
#endif

#ifdef DUMP_LM_LATTICE
		    if (f!=NULL) {
			    char sz[256];
			    ZeroMemory( sz, 256 );
#if defined(LM_LATTICE_CHS)
			    WideCharToMultiByte( 936, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_CHT)
			    WideCharToMultiByte( 950, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_JPN)
			    WideCharToMultiByte( 932, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#endif
#if defined(LM_LATTICE_CHS) || defined(LM_LATTICE_CHT)
			    fwprintf(f, L"%s, %d, %d, %d\r\n",
				    pNeutral->wsz, pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram);
#elif defined(LM_LATTICE_UNICODE)
			    fwprintf(f, L"%3d %2d %10d %s U+%04X\r\n", 
				    pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram, 
				    pNeutral->wsz, pNeutral->wsz[0] );
#endif
		    }
#endif
		    cData++;
		    cLattice++;
        }
	}

	// Now process each position.
	for (iStroke=0; iStroke<lat->nStrokes; iStroke++) {
		// Do we actually want any paths that end at this location?
		if (pValidEnd[iStroke] != LCF_VALID) {
			continue;
		}

//		int max=5;
//		if (iStroke==0) max=2;

		for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++) if (1 /*iAlt<max || lat->pAltList[iStroke].alts[iAlt].fCurrentPath*/) {
			wchar_t		unicode;
            float       flScore;

			// Prune really bad scores.  This MUST match test in path
			// checking code!
			if (ProbIsBad(lat, lat->pAltList[iStroke].alts[iAlt].logProb)) {
				continue;
			}

			// Fill in lattice element
			pNeutral			= (IMLANGUAGE_INFO_NEUTRAL1*)ExternAlloc(dwNeutralSize);
			if (pNeutral==NULL) goto allocated_elements;
            flScore = -lat->pAltList[iStroke].alts[iAlt].logProb;
            if (lat->fUseGuide) 
            {
                flScore *= g_vtuneInfo.pTune->flStringHwxWeight;
            }
            else
            {
                flScore *= g_vtuneInfo.pTune->flFreeHwxWeight * lat->pAltList[iStroke].alts[iAlt].nStrokes;
            }
            if (flScore < 0) flScore = (float)0;
            if (flScore > INT_MAX) flScore = (float)INT_MAX;
			pNeutral->dwUnigram	= (DWORD)(flScore);
			if (lat->pAltList[iStroke].alts[iAlt].wChar==SYM_UNKNOWN)
            {
                unicode=L' ';
            } 
            else 
            {
				unicode	= LocRunDense2Unicode(
					&g_locRunInfo, lat->pAltList[iStroke].alts[iAlt].wChar
				);
			}
			pNeutral->fHypothesis = FALSE;
			pNeutral->wsz[0]	= unicode;
			pNeutral->wsz[1]	= 0;
			pNeutral->wsz[2]	= 0;
			// Check for EUDC codes, which we shouldn't be generating (for debugging)
//			if (pNeutral->wsz[0]>=0xE000 && pNeutral->wsz[0]<0xF900) {
//				fprintf(stderr,"EUDC code in lattice (stroke %d alt %d): U+%04X\n",iStroke,iAlt,pNeutral->wsz[0]);
//			}

			pLattice[cLattice].dwFrameStart = (iStroke - lat->pAltList[iStroke].alts[iAlt].nStrokes) + 2 + cPreContext;
			pLattice[cLattice].dwFrameLen=lat->pAltList[iStroke].alts[iAlt].nStrokes;
			pLattice[cLattice].dwTotalInfo	= 1;
			pLattice[cLattice].pInfo		= pDataList + cData;

			pDataList[cData].guid	= GUID_IMLANGUAGE_INFO_NEUTRAL1;
			pDataList[cData].dwSize	= dwNeutralSize;
			pDataList[cData].pbData	= (BYTE*)pNeutral;
			cData++;

#ifdef HWX_TUNE
            if (g_pTuneFile != NULL)
            {
                fprintf(g_pTuneFile, "%04X %d %d %f\n",
                    pNeutral->wsz[0],
                    pLattice[cLattice].dwFrameStart,
                    pLattice[cLattice].dwFrameLen,
                    lat->pAltList[iStroke].alts[iAlt].logProb);
            }
#endif

#ifdef USE_IFELANG3_BIGRAMS
			lat->pAltList[iStroke].alts[iAlt].indexIFELang3=cLattice;
			if (lat->pAltList[iStroke].alts[iAlt].nBigrams>0) {
				dwBigramSize=sizeof(LATTICE_BIGRAM_INFO_LIST)+
					sizeof(LATTICE_BIGRAM_INFO)*(lat->pAltList[iStroke].alts[iAlt].nBigrams-1);
				pBigramInfo = (LATTICE_BIGRAM_INFO_LIST*)ExternAlloc(dwBigramSize);
				if (pBigramInfo==NULL) goto allocated_elements;

				int iPrevStart=iStroke-lat->pAltList[iStroke].alts[iAlt].nStrokes;
				for (int i=0; i<lat->pAltList[iStroke].alts[iAlt].nBigrams; i++) {
					pBigramInfo->bigrams[i].dwBigram=(DWORD)(lat->pAltList[iStroke].alts[iAlt].bigramLogProbs[i]);
					pBigramInfo->bigrams[i].dwPrevElement=
						lat->pAltList[iPrevStart].alts[lat->pAltList[iStroke].alts[iAlt].bigramAlts[i]].indexIFELang3;
				}

				pDataList[cData].guid	= GUID_LATTICE_BIGRAM_INFO_LIST;
				pDataList[cData].dwSize	= dwBigramSize;
				pDataList[cData].pbData	= (BYTE*)pBigramInfo;
				cData++;
				pLattice[cLattice].dwTotalInfo++;
			}
#endif

#ifdef DUMP_LM_LATTICE
			if (f!=NULL) {
				char sz[256];
				ZeroMemory( sz, 256 );
#if defined(LM_LATTICE_CHS)
			WideCharToMultiByte( 936, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_CHT)
			WideCharToMultiByte( 950, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_JPN)
				WideCharToMultiByte( 932, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#endif
//				fprintf(f,"%3d %2d %10d %s\n",pLattice[cLattice].dwFrameStart,pLattice[cLattice].dwFrameLen,pNeutral->dwUnigram,sz);
//				fprintf(f,"%3d %2d %10d %s U+%04X\n",pLattice[cLattice].dwFrameStart,pLattice[cLattice].dwFrameLen,pNeutral->dwUnigram,sz,pNeutral->wsz[0]);
#if defined(LM_LATTICE_CHS) || defined(LM_LATTICE_CHT)
				fwprintf(f, L"%s, %d, %d, %d\r\n", 
					pNeutral->wsz, pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram);
#elif defined(LM_LATTICE_UNICODE)
				fwprintf(f, L"%3d %2d %10d %s U+%04X\r\n", 
					pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram, 
					pNeutral->wsz, pNeutral->wsz[0] );
#endif
#ifdef USE_IFELANG3_BIGRAMS
				fprintf(f,"%d",lat->pAltList[iStroke].alts[iAlt].nBigrams);
				int iPrevStart=iStroke-lat->pAltList[iStroke].alts[iAlt].nStrokes;
				for (int i=0; i<lat->pAltList[iStroke].alts[iAlt].nBigrams; i++) {
					fprintf(f," %d %d\n",
						lat->pAltList[iPrevStart].alts[lat->pAltList[iStroke].alts[iAlt].bigramAlts[i]].indexIFELang3,
						lat->pAltList[iStroke].alts[iAlt].bigramLogProbs);
				}
				fprintf(f,"\n");
#endif
			}
#endif
			cLattice++;
		}
	}

	if (lat->wszAfter != NULL) 
    {
        int iFrame = pLattice[cLattice].dwFrameStart = (lat->nStrokes - 1) + 2 + cPreContext;
        for (int iSrc = 0; iSrc < (int) wcslen(lat->wszAfter); iSrc++) 
        {
		    // If we have a context character, then create a lattice element for it.
		    pNeutral			= (IMLANGUAGE_INFO_NEUTRAL1*)ExternAlloc(dwNeutralSize);
		    if (pNeutral == NULL) goto allocated_elements;
		    pNeutral->dwUnigram	= 0;
		    pNeutral->fHypothesis = FALSE;
		    pNeutral->wsz[0]	= LocRunDense2Unicode(&g_locRunInfo, lat->wszAfter[iSrc]);
		    pNeutral->wsz[1]	= 0;
		    pNeutral->wsz[2]	= 0;

		    pDataList[cData].guid		= GUID_IMLANGUAGE_INFO_NEUTRAL1;
		    pDataList[cData].dwSize		= dwNeutralSize;
		    pDataList[cData].pbData		= (BYTE*)pNeutral;

		    pLattice[cLattice].dwFrameStart	= iFrame++;
		    pLattice[cLattice].dwFrameLen	= 1;
		    pLattice[cLattice].dwTotalInfo	= 1;
		    pLattice[cLattice].pInfo		= pDataList + cLattice;

#ifdef HWX_TUNE
            if (g_pTuneFile != NULL)
            {
                fprintf(g_pTuneFile, "%04X %d %d %f\n",
                    pNeutral->wsz[0],
                    pLattice[cLattice].dwFrameStart,
                    pLattice[cLattice].dwFrameLen,
                    0.0);
            }
#endif

#ifdef DUMP_LM_LATTICE
		    if (f!=NULL) {
			    char sz[256];
			    ZeroMemory( sz, 256 );
#if defined(LM_LATTICE_CHS)
			    WideCharToMultiByte( 936, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_CHT)
			    WideCharToMultiByte( 950, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#elif defined(LM_LATTICE_JPN)
			    WideCharToMultiByte( 932, 0, pNeutral->wsz, -1, sz, 256, 0, 0 );
#endif
#if defined(LM_LATTICE_CHS) || defined(LM_LATTICE_CHT)
			    fwprintf(f, L"%s, %d, %d, %d\r\n",
				    pNeutral->wsz, pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram);
#elif defined(LM_LATTICE_UNICODE)
			    fwprintf(f, L"%3d %2d %10d %s U+%04X\r\n", 
				    pLattice[cLattice].dwFrameStart, pLattice[cLattice].dwFrameLen, pNeutral->dwUnigram, 
				    pNeutral->wsz, pNeutral->wsz[0] );
#endif
		    }
#endif
		    cData++;
		    cLattice++;
        }
	}

#ifdef DUMP_LM_LATTICE
	if (f!=NULL) {
        fwprintf(f, L"</S>\r\n");
		fclose(f);
	}
#endif

#ifdef HWX_TUNE
    if (g_pTuneFile != NULL)
    {
        fprintf(g_pTuneFile, "\n");
        fflush(g_pTuneFile);
    }
#endif

    // define "batch" for IIMLanguage
	nLMITEM = SetLanguageModelCommands(aLMITEM, &sTuneParam, &sHWTip1Param);

	// Apply IIMLanguage
	rc	= g_pIFELang3->GetLatticeMorphResult(
		nLMITEM, aLMITEM,
		cLattice, pLattice, &cElemOut, &pElemOut
	);

//	TPDBG_DMSG2("%08X: GetLatticeMorphResult -> %08X\n", GetCurrentThreadId(), rc);

	if (SUCCEEDED(rc)) {
		// Let's validate what came back from IFELang3.  The main array of 
		// results must be writable, so we can sort it later.
		if (cElemOut <= 0 || IsBadWritePtr(pElemOut, cElemOut * sizeof(*pElemOut)))
		{
			ASSERT(("IFELang3 pElemOut not readable and writable", FALSE));
			goto free_lattice;
		}
		// Then validate each of the pointers in the above array
		for (ii = 0; ii < cElemOut; ii++) 
		{
			IMLANGUAGE_ELEMENT *pElem = pElemOut + ii;
			// If the element doesn't have any info items in it, then skip it.
			if (pElem->dwTotalInfo <= 0) 
				continue;
			// Otherwise validate the array of info items
			if (IsBadReadPtr(pElem->pInfo, pElem->dwTotalInfo * sizeof(*(pElem->pInfo))))
			{
				ASSERT(("IFELang3 pElemOut->pInfo not readable", FALSE));
				goto free_lattice;
			}
			for (jj = 0; jj < pElem->dwTotalInfo; jj++) 
			{
				// Make sure the info is readable and the size it is supposed to be
				if (IsBadReadPtr(pElem->pInfo[jj].pbData, pElem->pInfo[jj].dwSize))
				{
					ASSERT(("IFELang3 pElemOut->pInfo->pbData not readable", FALSE));
					goto free_lattice;
				}
				// We only care about info of this type
				if (pElem->pInfo[jj].guid == GUID_IMLANGUAGE_INFO_NEUTRAL1) 
				{
					// Get the pointer to the actual info.
					pNeutral = (IMLANGUAGE_INFO_NEUTRAL1 *) pElem->pInfo[jj].pbData;
					// cLattice + 1 is a very loose upper bound on the number of characters 
					// which should be returned; then use the string length to check that
					// the specified size is correct.
					if (IsBadStringPtrW(pNeutral->wsz, cLattice + 1) ||
						sizeof(IMLANGUAGE_INFO_NEUTRAL1) + 
							sizeof(WCHAR) * (wcslen(pNeutral->wsz) + 1) > pElem->pInfo[jj].dwSize)
					{
						ASSERT(("IFELang3 pElemOut->pInfo->pbData->wsz not readable", FALSE));
						goto free_lattice;
					}
				}
			}
		}

		// If the language model worked, 
		// trace the path that came back from the model.
		int cChars = 0;
		wchar_t *wszBestPath = NULL;

		// Sort the output lattice elements into time order
        qsort(pElemOut, cElemOut, sizeof(IMLANGUAGE_ELEMENT), CompareElemTime);
		
		// Count the number of characters in the path
		for (ii=0; ii<cElemOut; ii++) {
			IMLANGUAGE_ELEMENT	*pElem = pElemOut + ii;
			for (jj = 0; jj < pElem->dwTotalInfo; jj++ ) {
				pNeutral = (IMLANGUAGE_INFO_NEUTRAL1 *) pElem->pInfo[jj].pbData;
				if (pElem->pInfo[jj].guid==GUID_IMLANGUAGE_INFO_NEUTRAL1) {
/*					FILE *f=fopen("/log.txt","a+");
					fprintf(f,"element %d has %d chars hypothesis %d\n",cChars,wcslen(pNeutral->wsz),pNeutral->fHypothesis);
					fclose(f); */
					cChars += wcslen(pNeutral->wsz); 
				}
			}
		}

		// Allocate space for the path
		wszBestPath = (wchar_t*)ExternAlloc(sizeof(wchar_t)*(cChars+1));

		// If we failed, then just don't update the path
		if (wszBestPath != NULL) {
			// Copy the path out of the lattice
			wszBestPath[0] = 0;
			for (ii=0; ii<cElemOut; ii++) {
				IMLANGUAGE_ELEMENT	*pElem = pElemOut + ii;
				for (jj = 0; jj < pElem->dwTotalInfo; jj++ ) {
					pNeutral = (IMLANGUAGE_INFO_NEUTRAL1 *) pElem->pInfo[jj].pbData;
					if (pElem->pInfo[jj].guid==GUID_IMLANGUAGE_INFO_NEUTRAL1) 
						wcscat(wszBestPath, pNeutral->wsz);
				}
			}
            // Wipe out the post-context character(s)
            wszBestPath[wcslen(wszBestPath) - cPostContext] = 0;
			// Skip the pre-context character(s)
			wszBestPath += cPreContext;

			// Trace the string through the original lattice, using the
			// same code that is used for the separator.
			int nSubs=SearchForTargetResultInternal(lat, wszBestPath);
//			fprintf(stderr, "Searching for target, nSubs=%d\n", nSubs);
			// Put the context character(s) back
			wszBestPath -= cPreContext;
			if (nSubs!=0) {
//                FILE *f = fopen("c:/log.txt", "a");
//                fprintf(f, "Lost path with %d/%d/%d chars\n",
//                    cPreContext, wcslen(wszBestPath) - cPreContext, cPostContext);
//                fclose(f);
			} else {
//                FILE *f = fopen("c:/log.txt", "a");
//                fprintf(f, "Found path with %d/%d/%d chars\n",
//                    cPreContext, wcslen(wszBestPath) - cPreContext, cPostContext);
//                fclose(f);
			}
			ExternFree(wszBestPath);
		}

free_lattice:
		// And free the memory allocated for us by IIMLanguage.
		if (cElemOut > 0 && !IsBadReadPtr(pElemOut, cElemOut * sizeof(*pElemOut)))
		{
			for (ii=0; ii < cElemOut; ii++) {
				IMLANGUAGE_ELEMENT *pElem = pElemOut + ii;
				if (!IsBadReadPtr(pElem->pInfo, sizeof(*(pElem->pInfo)) * pElem->dwTotalInfo)) 
				{
					// Free each data item in the element.
					for (jj = 0; jj < pElem->dwTotalInfo; jj++) 
					{
						if (!IsBadReadPtr(pElem->pInfo[jj].pbData, pElem->pInfo[jj].dwSize))
						{
							CoTaskMemFree(pElem->pInfo[jj].pbData);
						}
					}
					// Free the element array itself.
					CoTaskMemFree(pElem->pInfo);
				}
			}
			CoTaskMemFree(pElemOut);
		}
	}

	// Free all the memory we allocated.
allocated_elements:
	for (ii = 0; ii < (DWORD)cData; ++ii) {
		if (pDataList[ii].pbData!=NULL) 
			ExternFree(pDataList[ii].pbData);
	}
	ExternFree(pLattice);
allocated_data:
	ExternFree(pDataList);
allocated_valid:
	ExternFree(pValidEnd);
}


#endif
// USE_IFELANG3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\latticefl.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/latticefl.c
//
// Description:
//	    Functions to load various databases for the recognizer from
//      files.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "brknet.h"

BBOX_PROB_TABLE *g_pProbTable;
UNIGRAM_INFO g_unigramInfo;
BIGRAM_INFO g_bigramInfo;
CLASS_BIGRAM_INFO g_classBigramInfo;
TTUNE_INFO g_ttuneInfo;
LOAD_INFO g_bboxProbInfo;
wchar_t g_pLocale[16];
wchar_t g_pLocaleDir[1024];
wchar_t g_pRecogDir[1024];
HINSTANCE g_hDLL;
VOLCANO_PARAMS_INFO g_vtuneInfo;
VOLCANO_CONFIG		g_volcanoConfig;
CENTIPEDE_INFO		g_centipedeInfo;
LOAD_INFO			g_BrkNetInfo;
LOAD_INFO			g_SegmNetInfo;
LOAD_INFO			g_CharDetLoadInfo;

BOOL LoadSegmNetFromFile(wchar_t *pwszRecogDir, LOAD_INFO *pLoadInfo);
BOOL LoadCharDetFromFile(wchar_t *wszPath, LOAD_INFO *pLoadInfo);

// Loads the following databases: unigrams, bigrams, class bigrams, tuning, centipede, free input
BOOL LatticeConfigFile(wchar_t *pRecogDir)
{
    LatticeConfigInit();

    if (!VTuneLoadFile(&g_vtuneInfo, pRecogDir)) 
    {
        ASSERT(("Error in VTuneLoadFile", FALSE));
        return FALSE;
    }

    if (!TTuneLoadFile(&g_ttuneInfo, pRecogDir)) {
        ASSERT(("Error in TTuneLoadFile", FALSE));
        return FALSE;
    }

    if (!UnigramLoadFile(&g_locRunInfo, &g_unigramInfo, pRecogDir)) {
        ASSERT(("Error in UnigramLoadFile", FALSE));
        return FALSE;
    }

#if !defined(WINCE) && !defined(FAKE_WINCE)
    if (!BigramLoadFile(&g_locRunInfo, &g_bigramInfo, pRecogDir)) {
        ASSERT(("Error in BigramLoadFile", FALSE));
			return FALSE;
    }
#endif

    if (!ClassBigramLoadFile(&g_locRunInfo, &g_classBigramInfo, pRecogDir)) {
        ASSERT(("Error in ClassBigramLoadFile", FALSE));
        return FALSE;
    }

    if (!CentipedeLoadFile(&g_centipedeInfo, pRecogDir, &g_locRunInfo)) {
        ASSERT(("Error in CentipedeLoadFile", FALSE));
		return FALSE;
	}

	// Failure here is not an error, it just means we don't support free input
	g_pProbTable = LoadBBoxProbTableFile(pRecogDir, &g_bboxProbInfo);

#ifdef USE_IFELANG3
	LatticeConfigIFELang3();
#endif

	// Don't bother trying to load other databases for free input if the basic
	// one is not present.
	if (g_pProbTable != NULL)
	{
		// load the brk net, this is optional
		if (LoadBrkNetFromFile (pRecogDir, &g_BrkNetInfo))
		{
			// load the segm nets, optional
			if (!LoadSegmNetFromFile (pRecogDir, &g_SegmNetInfo))
			{
	//			ASSERT(("Error in LoadSegmNetFromFile", FALSE));
	//			return FALSE;
			}

			// load the char detector, not optional
			if (!LoadCharDetFromFile(pRecogDir, &g_CharDetLoadInfo))
			{
				ASSERT(("Error in LoadCharDetFromFile", FALSE));
				return FALSE;
			}
		}
	}

	return TRUE;
}

BOOL LatticeUnconfigFile()
{
	BOOL ok = TRUE;
	if (!UnigramUnloadFile(&g_unigramInfo)) ok = FALSE;
#if !defined(WINCE) && !defined(FAKE_WINCE)
	if (!BigramUnloadFile(&g_bigramInfo)) ok = FALSE;
#endif
	if (!ClassBigramUnloadFile(&g_classBigramInfo)) ok = FALSE;
	if (!TTuneUnloadFile(&g_ttuneInfo)) ok = FALSE;
	if (!CentipedeUnloadFile(&g_centipedeInfo)) ok = FALSE;
	if (g_pProbTable != NULL && !UnLoadBBoxProbTableFile(&g_bboxProbInfo)) ok = FALSE;
    if (!VTuneUnloadFile(&g_vtuneInfo)) 
    {
        ok = FALSE;
    }

	BrkNetUnloadfile (&g_BrkNetInfo);

	

	return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\lattice.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/lattice.c
//
// Description:
//	    Functions to implement the lattice search for the best
//      explanation of the input.
//
// Author:
//      hrowley
//
// Modified by:
// ahmadab 11/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <math.h>
#include <stdlib.h>
#include "volcanop.h"
#include "otterp.h"
#include "bboxfeat.h"

// If defined, then centipede is used
#define USE_CENTIPEDE

#ifdef USE_CENTIPEDE
// If defined, all scoring apart from centipede is disabled, to isolate the 
// contribution of centipede relative to the old heuristics.
//#define TEST_CENTIPEDE
#endif

//#define DUMP_BBOXES

// This define controls whether to merge sequential strokes whose end and start points
// are so close together that they were probably caused by a pen skip.  This helps with
// old data from flaky hardware.  Note that this code is size dependent... 
#define MERGE_STROKES
// This defines the maximum distance between the end point of one stroke and the start
// of the next one in order for them to be merged.
#define MERGE_THRESHOLD 10

// This defines the minimum number of characters which must be available to apply
// IFELang3.  For boxed mode, this is just a count of the number of distinct boxes 
// containing ink plus the number of context characters.  For free mode, we use the 
// number of characters on the best path using the internal language model plus the
// context.
#define MIN_CHARS_FOR_IFELANG3 3

// There is a special case for boxed mode when there is only one character of ink,
// in which we require that the pre- and post-context both have at least this many
// characters.
#define MIN_CONTEXT_FOR_IFELANG3 2

// Uncomment to dump out the lattice
//#define DUMP_LATTICE
// Name of lattice file
#define LATTICE_FILENAME "c:/lattice.txt"
// Whether to dump in a format readable by the DOTTY program
#define DUMP_LATTICE_TO_DOTTY

// Uncomment to dump out the DTW lattice used by SearchForTargetResult()
//#define DUMP_DTW

#ifdef HWX_TUNE
#include <stdio.h>
#endif

// These functions were copied and adapted from pathsrch.c in Tsunami

#define TYPE_BASE_MASK		(BYTE)0x0f
#define TYPE_HEIGHT_MASK    (BYTE)0xf0

#define BASE_NORMAL		0x00	// kanji, kana, numbers, etc
#define BASE_QUOTE		0x01	// upper punctuation, etc
#define BASE_DASH       0x02    // middle punctuation, etc
#define BASE_DESCENDER  0x03    // gy, anything that descends.
#define BASE_THIRD      0x04    // something that starts a third way up.

#define XHEIGHT_HALF  0x00    // lower-case, small kana, etc
#define XHEIGHT_FULL  0x10    // upper-case, kana, kanji, numbers, etc
#define XHEIGHT_PUNC  0x20    // comma, quote, etc
#define XHEIGHT_DASH  0x30    // dash, period, etc
#define XHEIGHT_3Q    0x40

#define XHEIGHT_NORMAL	0x00	// lower-case, small kana, etc
#define XHEIGHT_KANJI	0x10	// upper-case, kana, kanji, numbers, etc

// This will go away when we use Greg's scoring code
float FloatClippedLog2(COUNTER num, COUNTER denom)
{
	double ratio, val;
	ASSERT(num>=0);
	ASSERT(denom>=0);
	if (denom==0) return Log2Range;
	if (num==0) return Log2Range;
	ratio=(double)num/(double)denom;
	val=log(ratio)/log(2.0);
	if (val<Log2Range) val=Log2Range;
	if (val>0) val=0;
	return (FLOAT)val;
}

// Given the bounding box of the ink and the dense code of a character,
// guess what the writing area was for the character.  This is the centipede version.
RECT GuessWritingBoxCentipede(RECT bbox, SYM sym)
{
	int stats[INKSTAT_ALL];
	RECT result;

	memset(stats,0,sizeof(int)*INKSTAT_ALL);
	stats[INKSTAT_W] = bbox.right - bbox.left;
	stats[INKSTAT_H] = bbox.bottom - bbox.top;

	// Get the inferred box enclosing the character.
	ShapeUnigramBaseline(&g_centipedeInfo, sym, stats);
	result.left = bbox.left - stats[INKSTAT_X];
	result.top = bbox.top - stats[INKSTAT_Y];
	result.right = result.left + stats[INKSTAT_BOX_W];
	result.bottom = result.top + stats[INKSTAT_BOX_H];

	if (result.right == result.left) result.right++;
	if (result.bottom == result.top) result.bottom++;

	ASSERT(result.bottom > result.top);
	return result;
}

// Given the bounding box of the ink and the dense code of a character,
// guess what the writing area was for the character. 
RECT GuessWritingBox(RECT bbox, SYM sym)
{
	return GuessWritingBoxCentipede(bbox,sym);
}

// Given a guide and a box number, get the drawn box
RECT GetGuideDrawnBox(HWXGUIDE *guide, int iBox)
{
	RECT box;
	box.top = (iBox / guide->cHorzBox) * guide->cyBox + guide->yOrigin + guide->cyOffset;
	box.bottom = box.top + guide->cyWriting;
	box.left = (iBox % guide->cHorzBox) * guide->cxBox + guide->xOrigin + guide->cxOffset;
	box.right = box.left + guide->cxWriting;
	return box;
}

// Get information about a given box in the guide, will go away 
// when the insurance version goes away.
BOXINFO GetBoxinfo(HWXGUIDE *guide, int iBox)
{
	RECT rect = GetGuideDrawnBox(guide,iBox);
	BOXINFO box;
	box.size = rect.bottom - rect.top;
	box.baseline = rect.bottom;
	box.xheight = box.size / 2;
	box.midline = box.baseline - box.xheight;
	return box;
}

// Functions copied from the old lattice search code, used by the insurance version.
FLOAT BaselineTransitionCost(SYM symPrev, RECT rPrev, BOXINFO *biPrev, SYM sym, RECT r, BOXINFO *bi)
{
	BYTE type, typePrev;
	int base;
	FLOAT cost;

	// ASSUMPTION: SYM_UNKNOWN should be the only sym if its present.
	// So there aren't any alternatives that could get a "better" cost
	// so it probably doesn't really matter what cost we return here

	if (sym == SYM_UNKNOWN)
		return (FLOAT) 0.0;

	type = LocRunDense2BLineHgt(&g_locRunInfo, sym);
	type = LOCBH_BASE_MASK & type;

	if (symPrev == SYM_UNKNOWN)
		symPrev = 0;

	if (symPrev)
	{
		typePrev = LocRunDense2BLineHgt(&g_locRunInfo, symPrev);
		typePrev = LOCBH_BASE_MASK & typePrev;
	}

	//
	// If the first and second chars are supposed to have the same baseline then
	// compute a penalty based on the difference in their baseline.
	//

	if (symPrev && type == typePrev)
	{
		cost = (FLOAT) (100L * abs((r.bottom-bi->baseline) - (rPrev.bottom-biPrev->baseline)) / (bi->size * 2));
//		cost = (FLOAT) (100L * abs((r.bottom) - (rPrev.bottom)) / (bi->size * 2));
	}
	else
	{
		switch (type)
		{
			case BASE_NORMAL:
				base = bi->baseline;
				break;

			case BASE_THIRD:
				base = bi->baseline - (bi->xheight / 2);
				break;
	
			case BASE_DASH:
				base = bi->baseline - bi->xheight;
				break;
	
			case BASE_QUOTE:
				base = bi->baseline - (7 * bi->xheight / 4);
				break;
	
			default:
				base = bi->baseline;
				break;
		}

		cost = (FLOAT) (100L * abs(r.bottom - base) / (2 * bi->size));
	}

	cost = (-cost) / (FLOAT) 100.0;
//	ASSERT(cost <= 0.0);
	return(cost);
}

#define HEIGHT_DASH	20

FLOAT HeightTransitionCost(SYM symPrev, RECT rPrev, BOXINFO *biPrev, SYM sym, RECT r, BOXINFO *bi)
{
	BYTE type, typePrev;
	int ht, htPrev;
	FLOAT cost;

	// ASSUMPTION: SYM_UNKNOWN should be the only sym if its present.
	// So there aren't any alternatives that could get a "better" cost
	// so it probably doesn't really matter what cost we return here

	if (sym == SYM_UNKNOWN)
		return (FLOAT) 0.0;

	if (symPrev == SYM_UNKNOWN)
		symPrev = 0;

	cost = (FLOAT) 0.0;

	type = LocRunDense2BLineHgt(&g_locRunInfo, sym);
	type = LOCBH_HEIGHT_MASK & type;
	ht = r.bottom - r.top;

	// we may want to handle XHEIGHT_PUNC in the same manner that
	// we do XHEIGHT_DASH, i.e. no relative sizing

	if (type == XHEIGHT_DASH)
	{
		cost = (FLOAT) (100L * abs(ht - HEIGHT_DASH) / (ht + HEIGHT_DASH));
	}
	else
	{
		if (symPrev)
		{
			typePrev = LocRunDense2BLineHgt(&g_locRunInfo, symPrev);
			typePrev = LOCBH_HEIGHT_MASK & typePrev;
		}

		if (symPrev && typePrev != XHEIGHT_DASH)
		{
			//
			// We scale everything up to be normal (1/2) height.
			//

			htPrev = rPrev.bottom - rPrev.top;

			if (type == XHEIGHT_KANJI)
				ht = ht / 2;
			else if (type == XHEIGHT_PUNC)
				ht = ht * 3;

			if (typePrev == XHEIGHT_KANJI)
				htPrev = htPrev / 2;
			else if (typePrev == XHEIGHT_PUNC)
				htPrev = htPrev * 3;

			if ((ht + htPrev) == 0)
			{
				cost = (FLOAT) 0.0;
			}
			else
			{
				cost = (FLOAT) (100L * abs(ht - htPrev) / (ht + htPrev));
			}
		}
		else
		{
			//
			// We scale everything up to be 1/2 height of box.
			//

			if (type == XHEIGHT_KANJI)
			{
				// 3/4 of the box
				ht = (2 * ht) / 3;
			}
			else if (type == XHEIGHT_NORMAL)
			{
				// 1/3 of the box
				ht = (3 * ht) / 2;
			}
			else if (type == XHEIGHT_PUNC)
			{
				// 1/8 of the box
				ht = 4 * ht;
			}

			//
			// Now we compute a cost based on how far off from what
			// we computed we should be.
			//

			cost = (FLOAT) (100L * abs(ht - bi->xheight) / (2 * bi->xheight));
		}
	}

	cost = (-cost) / (FLOAT) 100.0;
//	ASSERT(cost <= 0.0);

	return(cost);
}

/******************************Public*Routine******************************\
* HeightBoxCost
*
* This function computes the likelihood of a character given the height of
* the character written and the height of the box the person was supposed
* to write in.
*
* History:
*  05-May-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

FLOAT HeightBoxCost(SYM sym, RECT r, BOXINFO *bi)
{
	int heightShouldBe;  // This is the height it should be given the box
						 // they were told to write in.
	int heightIs;        // This is the height the glyph is.

	BYTE type;
	FLOAT cost;

	heightIs = r.bottom - r.top;

	// ASSUMPTION: SYM_UNKNOWN should be the only sym if its present.
	// So there aren't any alternatives that could get a "better" cost
	// so it probably doesn't really matter what cost we return here

	if (sym == SYM_UNKNOWN)
	{
		return (FLOAT) 0.0;
	}

	type = LocRunDense2BLineHgt(&g_locRunInfo, sym);

	// Could not determine the code
	if (type == LOC_RUN_NO_BLINEHGT) {
//		ASSERT(0);
		return (FLOAT) 0.0;
	}

	type = LOCBH_HEIGHT_MASK & type;

	switch (type)
	{
	case XHEIGHT_KANJI:  // full height "ABC" etc.

		heightShouldBe = (bi->size * 3) / 4;

		if (heightIs >= heightShouldBe)
		{
			// No cost, can't be anything bigger.

			cost = (FLOAT) 0.0;
		}
		else
		{
			cost = (FLOAT) ( ((float) (heightShouldBe - heightIs)) / (float) (bi->size));
		}
		break;

	case XHEIGHT_NORMAL: // half height "ace" etc.

		heightShouldBe = (bi->size * 2) / 5;
		cost = (FLOAT) ( ((float) abs(heightIs - heightShouldBe)) / (float) (bi->size));
		break;

	case XHEIGHT_PUNC: // small height "maru ," etc.

		heightShouldBe = bi->size / 6;
		cost = (FLOAT) (((float) abs(heightIs - heightShouldBe)) / (float) (bi->size));
		break;

	case XHEIGHT_DASH:

		heightShouldBe = bi->xheight / 8;

		if (heightIs <= heightShouldBe)
		{
			//
			// It's below the minimum height, way down, so no penalty given.
			//

			cost = (FLOAT) 0.0;
		}
		else
		{
			cost = (FLOAT) (((float) (heightIs - heightShouldBe)) / (float) (bi->size));
		}
		break;

	default:

		ASSERT(0);  // We should not get here but if we do we have some default
					// behaviour that should be OK.

		cost = (FLOAT) 0.0;
	}

	cost = cost * cost * -5.0F;

//	ASSERT(cost <= 0.0);
	return(cost);
}

/******************************Public*Routine******************************\
* BaselineBoxCost
*
* This function computes a penalty given the baseline of the character
* and where we thought the characters baseline should be given the box
* they were told to write in.
*
* History:
*  04-May-1995 -by- Patrick Haluptzok patrickh
* Modify it.
\**************************************************************************/

FLOAT BaselineBoxCost(SYM sym, RECT r, BOXINFO *bi)
{
	BYTE type;
	FLOAT cost;

	int baselineShouldBe;  // This is what the baseline should be for the
						   // char we are proposing.

	int baselineIs;        // This is what the baseline is for the char written.

	// ASSUMPTION: SYM_UNKNOWN should be the only sym if its present.
	// So there aren't any alternatives that could get a "better" cost
	// so it probably doesn't really matter what cost we return here.

	if (sym == SYM_UNKNOWN)
	{
		return (FLOAT) 0.0;
	}

	type = LocRunDense2BLineHgt(&g_locRunInfo, sym);

	// Could not determine the code
	if (type == LOC_RUN_NO_BLINEHGT) {
//		ASSERT(0);
		return (FLOAT) 0.0;
	}

	type = LOCBH_BASE_MASK & type;
	baselineIs = r.bottom;  // This is what the baseline is for the glyph.

	switch (type)
	{
	case BASE_NORMAL:
		baselineShouldBe = bi->baseline - (bi->size / 8);
		cost = (FLOAT) (100L * abs(baselineIs - baselineShouldBe) / (bi->size));
		break;

	case BASE_THIRD:
		baselineShouldBe = bi->baseline - (bi->size / 4);
		cost = (FLOAT) (100L * abs(baselineIs - baselineShouldBe) / (bi->size));
		break;

	case BASE_DASH:
		baselineShouldBe = bi->midline;
		cost = (FLOAT) (100L * abs(baselineIs - baselineShouldBe) / (bi->size));
		break;

	case BASE_QUOTE:
		ASSERT((bi->baseline - bi->midline) > 0);
		baselineShouldBe = ((bi->baseline - bi->size + bi->midline) / 2);

		if (baselineIs <= baselineShouldBe)
		{
			//
			// It's above the quote baseline, way up high, so no penalty
			// for any BASE_QUOTE chars.
			//

			cost = (FLOAT) 0.0;
		}
		else
		{
			cost = (FLOAT) (100L * (baselineIs - baselineShouldBe) / (bi->size));
		}
		break;

	case BASE_DESCENDER:
		baselineShouldBe = bi->baseline;
		if (baselineIs >= baselineShouldBe)
		{
			//
			// It's below the descender baseline, way down, so no penalty
			// for any BASE_DESCENDER chars.
			//

			cost = (FLOAT) 0.0;
		}
		else
		{
			cost = (FLOAT) (100L * (baselineShouldBe - baselineIs) / (bi->size));
		}
		break;

	default:
		ASSERT(0);  // We should not get here but if we do we have some default
					// behaviour that should be OK.

		cost = (FLOAT) 0.0;
		break;
	}

	cost = (-cost) / (FLOAT) 100.0;
//	ASSERT(cost <= 0.0);
	return(cost);
}

// Given a character (dense code), return the probability of that character occuring in natural text.
// If fProbMode is not set, then the value is returned as a score (used by the insurance recognizer).
void LanguageModelUnigram(BOOL fProbMode, wchar_t wChar, int nStrokes,
                          VOLCANO_WEIGHTS *pTuneScores)
{
#ifdef DISABLE_HEURISTICS
	return;
#else

    pTuneScores->afl[VTUNE_UNIGRAM] += (float) (UnigramCost(&g_unigramInfo, wChar) * 100.0 / 10.0);
//        float fl = (float) (UnigramCost(&g_unigramInfo, wChar) * 100.0 / 10.0);
//        fl = log(0.5 * pow(2, fl) + 0.5 / g_locRunInfo.cCodePoints);
//        pTuneScores->aflWeights[VTUNE_UNIGRAM] = fl;
#endif
}

// Given a pair of characters (dense codes), return the probability of that character sequence occurring
// in natural text.
// If fProbMode is not set, then the value is returned as a score (used by the insurance recognizer).
// The fStringMode flag is used to adjust the tuning parameters for the insurance version.
void LanguageModelBigram(BOOL fProbMode, BOOL fStringMode, BOOL fFreeMode, wchar_t wChar, int nStrokes, wchar_t wPrevChar,
						 VOLCANO_WEIGHTS *pTuneScores)
{
#ifdef DISABLE_HEURISTICS
	return;
#else

	if (wPrevChar==SYM_UNKNOWN) 
    {
		LanguageModelUnigram(fProbMode, wChar, nStrokes, pTuneScores);
        return;
	}

    pTuneScores->afl[fFreeMode ? VTUNE_FREE_SMOOTHING_UNIGRAM : VTUNE_STRING_SMOOTHING_UNIGRAM] += 
        (float)(UnigramCost(&g_unigramInfo, wChar) * 100.0 / 10.0);
#if !defined(WINCE) && !defined(FAKE_WINCE)
    pTuneScores->afl[fFreeMode ? VTUNE_FREE_BIGRAM : VTUNE_STRING_BIGRAM] += 
        (float)(BigramTransitionCost(&g_locRunInfo, &g_bigramInfo, wPrevChar, wChar) * 256.0 / 10.0);
#endif
    pTuneScores->afl[fFreeMode ? VTUNE_FREE_CLASS_BIGRAM : VTUNE_STRING_CLASS_BIGRAM] += 
        (float)(ClassBigramTransitionCost(&g_locRunInfo, &g_classBigramInfo, wPrevChar, wChar) * 256.0 / 10.0);
#endif
}

// Allocate memory for a path of nChars characters.  nChars can be zero.
LATTICE_PATH *AllocatePath(int nChars) 
{
	LATTICE_PATH *path=(LATTICE_PATH*)ExternAlloc(sizeof(LATTICE_PATH));
	if (path==NULL) return NULL;
	path->nChars=nChars;
	if (nChars==0) {
		path->pElem=NULL;
	} else {
		path->pElem=(LATTICE_PATH_ELEMENT*)ExternAlloc(sizeof(LATTICE_PATH_ELEMENT)*nChars);
		if (path->pElem==NULL) {
			ExternFree(path);
			path=NULL;
		}
	}
	return path;
}

// Create a stroke structure to store in the lattice.  Makes a copy of the
// array of points that is passed in.
BOOL CreateStroke(STROKE *pStroke, int nInk, POINT *pts, long time)
{
	int iInk;
	ASSERT(nInk>0);
	ASSERT(pts!=NULL);
	pStroke->pts=(POINT*)ExternAlloc(sizeof(POINT)*nInk);
	if (pStroke->pts!=NULL) {
		pStroke->nInk=nInk;
		memcpy(pStroke->pts,pts,sizeof(POINT)*nInk);
	} else {
		return FALSE;
	}
	pStroke->bbox.left=pStroke->bbox.right=pts[0].x;
	pStroke->bbox.top=pStroke->bbox.bottom=pts[0].y;
	for (iInk=1; iInk<nInk; iInk++) {
		pStroke->bbox.left=__min(pStroke->bbox.left,pts[iInk].x);
		pStroke->bbox.right=__max(pStroke->bbox.right,pts[iInk].x);
		pStroke->bbox.top=__min(pStroke->bbox.top,pts[iInk].y);
		pStroke->bbox.bottom=__max(pStroke->bbox.bottom,pts[iInk].y);
	}
	// Make the bottom and right sides exclusive, to match the old glyph code
	pStroke->bbox.right++;
	pStroke->bbox.bottom++;
	pStroke->timeStart=time;
	pStroke->timeEnd=time+10*nInk;
	pStroke->iBox=-1;
	return TRUE;
}

#ifdef MERGE_STROKES
// Given two strokes, add the ink from the second stroke at the end of the first 
// stroke.  The second stroke is freed.  Returns FALSE if for some reason it fails,
// in which case the second stroke is not freed.
BOOL AddStrokeToStroke(STROKE *pStroke, STROKE *pAddStroke)
{
	POINT *pNewPoints=(POINT*)ExternAlloc(sizeof(POINT)*(pStroke->nInk+pAddStroke->nInk));
	if (pNewPoints==NULL) return FALSE;
	memcpy(pNewPoints,pStroke->pts,sizeof(POINT)*pStroke->nInk);
	memcpy(pNewPoints+pStroke->nInk,pAddStroke->pts,sizeof(POINT)*pAddStroke->nInk);
	UnionRect(&pStroke->bbox, &pStroke->bbox, &pAddStroke->bbox);
	pStroke->timeEnd=pAddStroke->timeEnd;
	pStroke->iLast = pAddStroke->iLast;
	pStroke->nInk+=pAddStroke->nInk;
	ExternFree(pStroke->pts);
	pStroke->pts=pNewPoints;
	return TRUE;
}
#endif

// Free the memory for a stroke
void FreeStroke(STROKE *stroke)
{
	ASSERT(stroke!=NULL);
	ASSERT(stroke->pts!=NULL);
	ExternFree(stroke->pts);
}

// Delete the specified alternate from the specified stroke.
void DeleteElement(LATTICE *lat, int iStroke, int iAlt)
{
	// If there are any alternates after the specified one, move them up.
	if (lat->pAltList[iStroke].nUsed-iAlt-1>0) {
		memmove(&lat->pAltList[iStroke].alts[iAlt],
			&lat->pAltList[iStroke].alts[iAlt+1],
			sizeof(LATTICE_ELEMENT)*(lat->pAltList[iStroke].nUsed-iAlt-1));
	}
	// Reduce the number of elements in the column.
	lat->pAltList[iStroke].nUsed--;
}

// Insert a new alternate into the specified lattice column.  If the
// column already contains a "matching" element (having the same character
// label or number of strokes), then that element will get replaced if
// the given one has a higher log prob path score.
void InsertElement(LATTICE *lat, int iStroke, LATTICE_ELEMENT *elem)
{
	int newLength;
	int iAlt;

	// make sure that by default the char detector score is set -1 for any new element
	elem->iCharDetectorScore	=	-1;

	// Log prob is too low (a case we haven't seen in training), so ignore this path
//	if (elem->logProb<=Log2Range) return;

	// Make sure that the element being inserted is connected to a path
	// (unless it is connecting to the start of the lattice).
	ASSERT(iStroke-elem->nStrokes+1==0 || elem->iPrevAlt!=-1);

	// For each alternate already present, check for a match with the given one
	for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++) {
		BOOL fCharMatch=elem->wChar==lat->pAltList[iStroke].alts[iAlt].wChar;
//		BOOL fPrevCharMatch=elem->wPrevChar==lat->pAltList[iStroke].alts[iAlt].wPrevChar;
		BOOL fnStrokesMatch=elem->nStrokes==lat->pAltList[iStroke].alts[iAlt].nStrokes;
//		BOOL fnPrevStrokesMatch=elem->nPrevStrokes==lat->pAltList[iStroke].alts[iAlt].nPrevStrokes;
//		BOOL fMatch=fCharMatch && fPrevCharMatch && fnStrokesMatch && fnPrevStrokesMatch;
		BOOL fMatch=fCharMatch && fnStrokesMatch;
		if (fMatch) {
			// If it matches, check the log probs
			if (elem->logProbPath > lat->pAltList[iStroke].alts[iAlt].logProbPath) {
				// Matched a previous entry, but with a higher log prob, so replace it.
				DeleteElement(lat,iStroke,iAlt);
				// Insert later as normal
				break;
			} else {
				// Matched a previous entry, but with a lower score, so drop the given element.
				return;
			}
		}
	}

	// Compute the new length of the alt list after the insertion.
	newLength=lat->pAltList[iStroke].nUsed;
	if (lat->pAltList[iStroke].nUsed<MaxAltsPerStroke)
		newLength++;

	// Go through all the potential places for the given element.
	for (iAlt=0; iAlt<newLength; iAlt++) 
		// If we are beyond the end of the existing elements in the list, or we beat the current element
		if (iAlt > lat->pAltList[iStroke].nUsed-1 || 
			elem->logProbPath > lat->pAltList[iStroke].alts[iAlt].logProbPath) {
			// Shift all remaining elements (if any) down.  
			if (newLength-iAlt-1>0) {
				memmove(&lat->pAltList[iStroke].alts[iAlt+1],
						&lat->pAltList[iStroke].alts[iAlt],
						sizeof(LATTICE_ELEMENT)*(newLength-iAlt-1));
			}
			// Put in the new element
			lat->pAltList[iStroke].alts[iAlt] = *elem;
			break;
		}

	// Store thew new alt list length
	lat->pAltList[iStroke].nUsed=newLength;
}

// Clear out an alt list
void ClearAltList(LATTICE_ALT_LIST *list)
{
	int i;
	ASSERT(list!=NULL);
	list->nUsed=0;
	for (i=0; i<MaxAltsPerStroke; i++) list->alts[i].fUsed=FALSE;
}

// Create an empty lattice data structure.
LATTICE *AllocateLattice()
{
    LATTICE *lat=(LATTICE*)ExternAlloc(sizeof(LATTICE));
    if (lat!=NULL) {
		lat->nStrokes=0;
		lat->nRealStrokes = 0;
		lat->nStrokesAllocated=0;
		lat->pStroke=NULL;
		lat->pAltList=NULL;
        lat->fUseFactoid = FALSE;
        lat->alcFactoid = 0;
        lat->pbFactoidChars = NULL;
		lat->recogSettings.alcValid=0xFFFFFFFF;
		lat->recogSettings.alcPriority=0;
        lat->recogSettings.pbAllowedChars = NULL;
        lat->recogSettings.pbPriorityChars = NULL;
		lat->recogSettings.partialMode=HWX_PARTIAL_ALL;
		lat->recogSettings.pAbort=(UINT *)0;
        lat->recogSettings.pbAllowedChars = NULL;
		lat->fUseGuide=FALSE;
        lat->wszBefore = NULL;
        lat->wszAfter = NULL;
		lat->nProcessed = 0;
		lat->fEndInput = FALSE;
		lat->fIncremental = FALSE;
		lat->nFixedResult = 0;
        lat->wszAnswer = NULL;
        lat->fWordMode = FALSE;
        lat->fSingleSeg = FALSE;
        lat->fCoerceMode = FALSE;
        lat->fSepMode = 0;
        lat->pvCache = NULL;
        lat->fUseLM = TRUE;
    }
    return lat;
}

// Creates a new lattice structure with the same settings as the old one.
LATTICE *CreateCompatibleLattice(LATTICE *lat)
{
	LATTICE *newlat=AllocateLattice();
	if (newlat==NULL || lat==NULL) return newlat;
	newlat->recogSettings=lat->recogSettings;
    newlat->recogSettings.pbAllowedChars = CopyAllowedChars(&g_locRunInfo, lat->recogSettings.pbAllowedChars);
    newlat->recogSettings.pbPriorityChars = CopyAllowedChars(&g_locRunInfo, lat->recogSettings.pbPriorityChars);
    newlat->pbFactoidChars = CopyAllowedChars(&g_locRunInfo, lat->pbFactoidChars);
    newlat->alcFactoid = lat->alcFactoid;
    newlat->fUseFactoid = lat->fUseFactoid;
    newlat->fWordMode = lat->fWordMode;
    newlat->fSingleSeg = lat->fSingleSeg;
    newlat->fCoerceMode = lat->fCoerceMode;
	newlat->fUseGuide=lat->fUseGuide;
	newlat->guide=lat->guide;
    newlat->fUseLM = lat->fUseLM;
    if (lat->wszBefore != NULL)
    {
        newlat->wszBefore = Externwcsdup(lat->wszBefore);
        if (newlat->wszBefore == NULL) 
        {
            ExternFree(newlat);
            return NULL;
        }
    }
    if (lat->wszAfter != NULL) 
    {
        newlat->wszAfter = Externwcsdup(lat->wszAfter);
        if (newlat->wszAfter == NULL)
        {
            ExternFree(newlat->wszBefore);
            ExternFree(newlat);
            return NULL;
        }
    }
	return newlat;
}

// Sets the guide structure in the lattice
void SetLatticeGuide(LATTICE *lat, HWXGUIDE *pGuide)
{
	ASSERT(lat!=NULL);
	ASSERT(pGuide!=NULL);
	lat->guide=*pGuide;
	lat->fUseGuide=TRUE;
}

// Sets the ALC settings for the lattice (only used in the lower level of the character recognizer,
// if at all)
void SetLatticeALCValid(LATTICE *lat, ALC alcValid)
{
	ASSERT(lat!=NULL);
	lat->recogSettings.alcValid=alcValid;
}

// Sets the ALC settings for the lattice (only used in the lower level of the character recognizer,
// if at all)
void SetLatticeALCPriority(LATTICE *lat, ALC alcPriority)
{
	ASSERT(lat!=NULL);
	lat->recogSettings.alcPriority=alcPriority;
}

// Get one character of the pre-context
wchar_t GetPreContextChar(LATTICE *lat)
{
    if (lat->wszBefore != NULL) 
    {
        return lat->wszBefore[0];
    }
    return SYM_UNKNOWN;
}

// Get one character of the pre-context
wchar_t GetPostContextChar(LATTICE *lat)
{
    if (lat->wszAfter != NULL) 
    {
        return lat->wszAfter[0];
    }
    return SYM_UNKNOWN;
}

// Destroy lattice data structure.
void FreeLattice(LATTICE *lat)
{
    ASSERT(lat!=NULL);
	if (lat->pStroke!=NULL) {
		int i;
		for (i=0; i<lat->nStrokes; i++) {
			FreeStroke(lat->pStroke+i);
		}
		ExternFree(lat->pStroke);
	}
	if (lat->pAltList!=NULL) ExternFree(lat->pAltList);
    ExternFree(lat->wszBefore);
    ExternFree(lat->wszAfter);
    if (lat->wszAnswer != NULL)
    {
        ExternFree(lat->wszAnswer);
    }
    ExternFree(lat->recogSettings.pbAllowedChars);
    ExternFree(lat->recogSettings.pbPriorityChars);
    ExternFree(lat->pbFactoidChars);
    FreeRecognizerCache(lat->pvCache);
    ExternFree(lat);
}

// Add a stroke to the lattice, returns TRUE if it succeeds.
BOOL AddStrokeToLattice(LATTICE *lat, int nInk, POINT *pts, DWORD time)
{
	int iStroke;
	ASSERT(nInk>0);
    ASSERT(lat!=NULL);
	if (lat->nStrokes+1>lat->nStrokesAllocated) {
		STROKE *pNewStroke;
		LATTICE_ALT_LIST *ppNewElem;
		int nNewAlloc=lat->nStrokesAllocated*2;
		if (nNewAlloc==0) nNewAlloc=32;
		pNewStroke=(STROKE*)ExternAlloc(sizeof(STROKE)*nNewAlloc);
		ppNewElem=(LATTICE_ALT_LIST*)ExternAlloc(sizeof(LATTICE_ALT_LIST)*nNewAlloc);
		if (pNewStroke==NULL || ppNewElem==NULL) {
			if (pNewStroke!=NULL) ExternFree(pNewStroke);
			if (ppNewElem!=NULL) ExternFree(ppNewElem);
			return FALSE;
		}
		for (iStroke=0; iStroke<nNewAlloc; iStroke++) ClearAltList(&ppNewElem[iStroke]);
		if (lat->nStrokesAllocated>0) {
			memcpy(pNewStroke,lat->pStroke,sizeof(STROKE)*lat->nStrokesAllocated);
			memcpy(ppNewElem,lat->pAltList,sizeof(LATTICE_ALT_LIST)*lat->nStrokesAllocated);
			ExternFree(lat->pStroke);
			ExternFree(lat->pAltList);
		}
		lat->nStrokesAllocated=nNewAlloc;
		lat->pStroke=pNewStroke;
		lat->pAltList=ppNewElem;
	}
	iStroke=lat->nStrokes;
	ClearAltList(lat->pAltList+iStroke);
	if (CreateStroke(lat->pStroke+iStroke,nInk,pts,time)) {
		lat->pStroke[iStroke].iOrder=lat->nRealStrokes;
		lat->pStroke[iStroke].iLast=lat->nRealStrokes;
		lat->nStrokes++;
		lat->nRealStrokes++;
		return TRUE;
	} else 
		return FALSE;
}

// Pre-segmentation probability for single characters.
BOOL CheapUnaryProb(int nStrokes, RECT bbox, int cSpace, int cArea, VOLCANO_WEIGHTS *pTuneScores)
{
	float logProb;
	int iUnary;
	STROKE_SET_STATS stats;
	stats.rect=bbox;
	stats.space=cSpace;
	stats.area=cArea;
	iUnary=ComputeUnaryFeatures(&stats,nStrokes);
	logProb = (float)g_pProbTable->unarySamples[iUnary];

    pTuneScores->afl[VTUNE_FREE_SEG_UNIGRAM] = logProb;

    return (logProb > Log2Range);
}

// Pre-segmentation probability for character pairs
BOOL CheapBinaryProb(int nStrokes, RECT bbox, int cSpace, int cArea,
					 int nPrevStrokes, RECT prevBbox, int cPrevSpace, int cPrevArea,
                     VOLCANO_WEIGHTS *pTuneScores)
{
	float logProb;
	int iBinary;
	STROKE_SET_STATS stats, prevStats;
	stats.rect=bbox;
	stats.space=cSpace;
	stats.area=cArea;
	prevStats.rect=prevBbox;
	prevStats.space=cPrevSpace;
	prevStats.area=cPrevArea;
	iBinary=ComputeBinaryFeatures(&prevStats,&stats,nPrevStrokes,nStrokes);
	logProb=(float)g_pProbTable->binarySamples[iBinary];

	// Probability of 7/8 of moving to the right, 1/8 for other cases.
	if (prevBbox.right < bbox.right)
		logProb += FloatClippedLog2(7,8); else
			logProb += FloatClippedLog2(1,8);

    pTuneScores->afl[VTUNE_FREE_SEG_BIGRAM] = logProb;

    return (logProb > Log2Range);
}

// Post-segmentation probability for single characters
void RecogUnaryProb(LATTICE *lat, int iStroke, int nStrokes, RECT bbox, wchar_t wChar, 
                    VOLCANO_WEIGHTS *pTuneScores, BOOL fStringMode)
{
#ifdef DISABLE_HEURISTICS
	return;
#else
	float sizePenalty=0;
	wchar_t unicode=LocRunDense2Unicode(&g_locRunInfo,wChar);

	// If there's a guide, compute the probability of this character appearing at
	// a particular location in the box.
	if (lat->fUseGuide) {
		SCORE score;
		int stats[INKSTAT_ALL];
		float logprob;
		RECT guide=GetGuideDrawnBox(&lat->guide,lat->pStroke[iStroke].iBox);
		stats[INKSTAT_X] = bbox.left - guide.left;
		stats[INKSTAT_Y] = bbox.top - guide.top;
		stats[INKSTAT_CX] = (bbox.left + bbox.right + 1) / 2 - (guide.left + guide.right + 1) / 2;
		stats[INKSTAT_CY] = (bbox.top + bbox.bottom + 1) / 2 - (guide.top + guide.bottom + 1) / 2;
		stats[INKSTAT_W] = bbox.right - bbox.left;
		stats[INKSTAT_H] = bbox.bottom - bbox.top;
		stats[INKSTAT_BOX_W] = guide.right - guide.left;
		CentipedeNormalizeUnigram(stats);
		score=ShapeUnigramBoxCost(&g_centipedeInfo,wChar,stats);
		logprob= -(float)score / (float)SCORE_SCALE;
        pTuneScores->afl[fStringMode ? VTUNE_STRING_SHAPE_BOX_UNIGRAM : VTUNE_CHAR_SHAPE_BOX_UNIGRAM] = logprob;
	} else {
		// Otherwise compute the probability of this character having a particular 
		// aspect ratio.
		SCORE score;
		int stats[INKSTAT_ALL];
		float logprob;
		stats[INKSTAT_W] = bbox.right-bbox.left;
		stats[INKSTAT_H] = bbox.bottom-bbox.top;
		score=ShapeUnigramFreeCost(&g_centipedeInfo,wChar,stats);
		logprob= -(float)score / (float)SCORE_SCALE;
		// We'd also like to include a bias so that small ink gives punctuation.
        pTuneScores->afl[VTUNE_FREE_SHAPE_UNIGRAM] = logprob;
	}
#endif
}

// Post-segmentation for character pairs
void RecogBinaryProb(LATTICE *lat,
					 int iStroke, int nStrokes, RECT bbox, wchar_t wChar,
					 int iPrevStroke, int nPrevStrokes, RECT prevBbox, wchar_t wPrevChar,
                     VOLCANO_WEIGHTS *pTuneScores)
{
#ifdef DISABLE_HEURISTICS
	return;
#else

	float sizePenalty=0;
	wchar_t unicode = LocRunDense2Unicode(&g_locRunInfo,wChar);
	wchar_t prevUnicode;
	float logprob=0;

	// If we had to generate a fake alternate because there are no viable alternates, then the 
	// previous character might be one of these fakes.  If we pass this fake through to Centipede,
	// there will be problems.  So let's just use the unary shape scores instead.
	if (wPrevChar == SYM_UNKNOWN) 
    {
		RecogUnaryProb(lat, iStroke, nStrokes, bbox,wChar, pTuneScores, TRUE);
        return;
	}

	prevUnicode = LocRunDense2Unicode(&g_locRunInfo,wPrevChar);

	if (lat->fUseGuide) 
    {	
		SCORE score;
		int prevStats[INKSTAT_ALL], stats[INKSTAT_ALL];
		RECT prevGuide=GetGuideDrawnBox(&lat->guide,lat->pStroke[iStroke-nStrokes].iBox);
		RECT guide=GetGuideDrawnBox(&lat->guide,lat->pStroke[iStroke].iBox);
		memset(prevStats,0,sizeof(int)*INKSTAT_ALL);
		prevStats[INKSTAT_X] = prevBbox.left - prevGuide.left;
		prevStats[INKSTAT_Y] = prevBbox.top - prevGuide.top;
		prevStats[INKSTAT_CX] = (prevBbox.left + prevBbox.right + 1) / 2 - (prevGuide.left + prevGuide.right + 1) / 2;
		prevStats[INKSTAT_CY] = (prevBbox.top + prevBbox.bottom + 1) / 2 - (prevGuide.top + prevGuide.bottom + 1) / 2;
		prevStats[INKSTAT_W] = prevBbox.right - prevBbox.left;
		prevStats[INKSTAT_H] = prevBbox.bottom - prevBbox.top;
		prevStats[INKSTAT_BOX_W] = prevGuide.right - prevGuide.left;
		prevStats[INKSTAT_MARGIN_W] = lat->guide.cxOffset;
		CentipedeNormalizeUnigram(prevStats);

		memset(stats,0,sizeof(int)*INKSTAT_ALL);
		stats[INKSTAT_X] = bbox.left - guide.left;
		stats[INKSTAT_Y] = bbox.top - guide.top;
		stats[INKSTAT_CX] = (bbox.left + bbox.right + 1) / 2 - (guide.left + guide.right + 1) / 2;
		stats[INKSTAT_CY] = (bbox.top + bbox.bottom + 1) / 2 - (guide.top + guide.bottom + 1) / 2;
		stats[INKSTAT_W] = bbox.right - bbox.left;
		stats[INKSTAT_H] = bbox.bottom - bbox.top;
		stats[INKSTAT_BOX_W] = guide.right - guide.left;
		stats[INKSTAT_MARGIN_W] = lat->guide.cxOffset;
		CentipedeNormalizeUnigram(stats);

		score = ShapeBigramBoxCost(&g_centipedeInfo,wPrevChar,wChar,prevStats,stats);
		logprob= -(float)score / (float)SCORE_SCALE;

        pTuneScores->afl[VTUNE_STRING_SHAPE_BOX_BIGRAM] = logprob;
	}
    else 
    {
		int stats[INKBIN_ALL];
		SCORE score;
		stats[INKBIN_W_LEFT] = prevBbox.right - prevBbox.left;
		stats[INKBIN_W_GAP] = bbox.left - prevBbox.right;
		stats[INKBIN_W_RIGHT] = bbox.right - bbox.left;
		stats[INKBIN_H_LEFT] = prevBbox.bottom - prevBbox.top;
		stats[INKBIN_H_GAP] = bbox.top - prevBbox.bottom;
		stats[INKBIN_H_RIGHT] = bbox.bottom - bbox.top;
		CentipedeNormalizeBigram(stats);
		score = ShapeBigramFreeCost(&g_centipedeInfo, wPrevChar, wChar, stats);
		logprob = -(float)score / (float)SCORE_SCALE;

        pTuneScores->afl[VTUNE_FREE_SHAPE_BIGRAM] = logprob;
	}
#endif
}

#ifdef TRAIN_ZILLA_HOUND_COMBINER	// Pass on label when training combiner.
  wchar_t	g_CurCharAnswer;
#endif

// Call the underlying recognizer, and get a list of alternates with 
// associated probability (research version or insurance version in free mode), or
// scores (for the insurance version in boxed mode).
int RecognizerProbs(LATTICE *lat, int iStroke, int nStrokes,
					RECT bbox,
					wchar_t wAlts[MaxAltsPerStroke],
					FLOAT valueAlts[MaxAltsPerStroke],
					FLOAT *pScore, int *pnZillaStrokes,
					VOLCANO_WEIGHTS *pTuneScores,
                    BOOL fStringMode)
{
	int i;
	int space=0;
	RECOG_ALT scoreAlts[MaxAltsPerStroke], probAlts[MaxAltsPerStroke];
	int nScoreAlts=0, nProbAlts=0;
	FLOAT probScore, score=0;
	RECT rGuide;
	SYM context;

	// If we have a guide, convert it into a RECT for the current box
	if (lat->fUseGuide) {
		rGuide = GetGuideDrawnBox(&lat->guide, lat->pStroke[iStroke].iBox);
	} else {
		int size;
		// If we don't have a guide, too bad, because we need one anyway.
		// We'll walk back through the lattice, averaging the box sizes along 
		// the best path from the current node.
		int totalWidth = 0, totalHeight = 0, totalBoxes = 0;
		int currStroke = iStroke - nStrokes, iAlt, bestAlt = 0;
		BOOL fHavePrevBox = FALSE;
		RECT rPrevBox;

		// If there are more characters
		if (currStroke >= 0) {
			// Find the best alternate before the current character
			float bestProb = lat->pAltList[currStroke].alts[0].logProbPath;
			for (iAlt=1; iAlt<lat->pAltList[currStroke].nUsed; iAlt++) {
				if (lat->pAltList[currStroke].alts[iAlt].logProbPath > bestProb) {
					bestAlt = iAlt;
					bestProb = lat->pAltList[currStroke].alts[iAlt].logProbPath;
				}
			}
			// If the previous character is on the same line, then record
			if (bbox.left > lat->pAltList[currStroke].alts[bestAlt].writingBox.left)
			{
				rPrevBox = lat->pAltList[currStroke].alts[bestAlt].writingBox;
				fHavePrevBox = TRUE;
			}
			// Follow the best path back through that alternate to the
			// start of the lattice adding in the box sizes as we go.
			while (currStroke >= 0)
			{
				int newStroke, newAlt;
				RECT box = lat->pAltList[currStroke].alts[bestAlt].writingBox;
				totalWidth += box.right-box.left;
				totalHeight += box.bottom-box.top;
				totalBoxes++;
				newStroke = currStroke - lat->pAltList[currStroke].alts[bestAlt].nStrokes;
				newAlt = lat->pAltList[currStroke].alts[bestAlt].iPrevAlt;

				currStroke=newStroke;
				bestAlt=newAlt;
			}
		}

		// Get the maximum dimension
		if (totalBoxes == 0)
		{
			size = max(bbox.right - bbox.left, bbox.bottom - bbox.top);
		}
		else
		{
			size = __max( totalWidth, totalHeight ) / totalBoxes;
		}
		// Set an arbitrary minimum on the box size to prevent divide by zeros
		size = __max( size, 10 );

		// If there was no previous box on the line
		if (!fHavePrevBox)
		{
			// Then center the square box on top of the ink
			rGuide.top = ( bbox.top + bbox.bottom - size ) / 2;
			rGuide.bottom = ( bbox.top + bbox.bottom + size ) / 2;
			rGuide.left = ( bbox.left + bbox.right - size ) / 2;
			rGuide.right = ( bbox.left + bbox.right + size ) / 2;
		} 
		else
		{
			// If there was a previous character on the same line, then try to
			// keep it lined up.  

			// Center the box vertically with the previous character.
			rGuide.top = (rPrevBox.top + rPrevBox.bottom - size) / 2;
			rGuide.bottom = (rPrevBox.top + rPrevBox.bottom + size) / 2;

			// Center the box horizontally
			rGuide.left = ( bbox.left + bbox.right - size ) / 2;
			rGuide.right = ( bbox.left + bbox.right + size ) / 2;

			// If it overlaps with the previous box, then shift over to the right
			if (rGuide.left - rPrevBox.right < 0)
			{
				rGuide.right += (rPrevBox.right - rGuide.left);
				rGuide.left = rPrevBox.right;
			}

			// Expand to include the ink
			rGuide.top = min(rGuide.top, bbox.top);
			rGuide.bottom = max(rGuide.bottom, bbox.bottom);
			rGuide.left = min(rGuide.left, bbox.left);
			rGuide.right = max(rGuide.right, bbox.right);
		}
	}

	// If this is the first character in the lattice, then pass the context through.
	// Otherwise the context is unknown (at least at the single-character level
	// the recognizer is working at).
	if (iStroke-nStrokes+1==0)
		context = GetPreContextChar(lat); else
			context=SYM_UNKNOWN;

#ifdef USE_OLD_DATABASES
	// Zero out the scores
    for (i = 0; i < MaxAltsPerStroke; i++)
    {
        VTuneZeroWeights(pTuneScores + i);
    }
#ifdef TRAIN_ZILLA_HOUND_COMBINER	// Pass on label when training combiner.
  g_CurCharAnswer	= lat->wszAnswer[0];
#endif
	RecognizeCharInsurance(&lat->recogSettings, nStrokes, lat->nRealStrokes, lat->pStroke + iStroke - nStrokes + 1,
		&score, MaxAltsPerStroke, probAlts, &nProbAlts, scoreAlts, &nScoreAlts, &rGuide, context, &space, pTuneScores,
        fStringMode, lat->fProbMode, lat->pvCache, iStroke);
#else 
	nProbAlts=RecognizeChar(&lat->recogSettings, nStrokes, lat->nRealStrokes, lat->pStroke + iStroke - nStrokes + 1,
		&score,MaxAltsPerStroke,probAlts,&rGuide,&space);
#endif

	if (pScore!=NULL) *pScore=score;
	if (pnZillaStrokes!=NULL) *pnZillaStrokes=space;

	// If we're in probability mode, return the probabilities
	if (lat->fProbMode) {
		if (nProbAlts<=0) return 0;

		// Zero out the scores
        for (i = 0; i < MaxAltsPerStroke; i++)
        {
            VTuneZeroWeights(pTuneScores + i);
        }
			
		// The probability that this is a character given the matcher score.
		// This code is disabled for the old databases, because the otter space 
		// is not returned.  For the new databases, we get space numbers for both
		// otter and zilla, so the match score can be interpreted meaningfully.
#ifdef USE_OLD_DATABASES
		probScore=0;
#else
		probScore=0;
//		probScore=g_pProbTable->scoreSamples[MatchSpaceScoreToFeature(nStrokes,score,space)];
#endif

		for (i=0; i<nProbAlts; i++) {
#ifdef USE_OLD_DATABASES
			double logProbAlt = FloatClippedLog2((int)probAlts[i].prob,65535);
#else
			double logProbAlt = -(double)probAlts[i].prob/(double)SCORE_SCALE;
			ASSERT(SCORE_BASE==2);
#endif
			wAlts[i]=probAlts[i].wch;
			valueAlts[i]=(FLOAT)(probScore+logProbAlt);
			if (!lat->fUseGuide) 
			{
			    pTuneScores[i].afl[VTUNE_FREE_PROB] = valueAlts[i];
			}
			else if (fStringMode)
			{
				pTuneScores[i].afl[VTUNE_STRING_CORE] = valueAlts[i];
			}
			else 
			{
				pTuneScores[i].afl[VTUNE_CHAR_CORE] = valueAlts[i];
			}
		}
		return nProbAlts;

	} else {
		// Otherwise return the matcher scores to emulate the legacy recognizer
#ifndef USE_OLD_DATABASES
		ASSERT(("Trying to use matcher scores with the new recognizer",0));
#endif
		if (nScoreAlts<=0) return 0;
		for (i=0; i<nScoreAlts; i++) {
			wAlts[i]=scoreAlts[i].wch;
			valueAlts[i]=scoreAlts[i].prob;
		}
		return nScoreAlts;
	}
}

#define PENALTY_ALC_PRIORITY 1000

// Sort the alt list so that all characters matching alcPriority are above
// all those that do not.
void ApplyALCPriority(LATTICE *lat, int nAlts, wchar_t *wAlts, VOLCANO_WEIGHTS *pTuneScores)
{
	wchar_t wTmp[MaxAltsPerStroke];
    VOLCANO_WEIGHTS aTuneScoresTmp[MaxAltsPerStroke];
	FLOAT penalty;
	BOOL fPenaltySet = FALSE;
	int iUsed = 0, i;
	BOOL fNonPriorityFound = FALSE, fPriorityBelowNonPriority = FALSE;
    CHARSET charSet;

    charSet.recmask = lat->recogSettings.alcValid;
    charSet.recmaskPriority = lat->recogSettings.alcPriority;
    charSet.pbAllowedChars = lat->recogSettings.pbAllowedChars;
    charSet.pbPriorityChars = lat->recogSettings.pbPriorityChars;

	// If there are no priorities, don't change anything.
	if (charSet.recmaskPriority == 0 && charSet.pbPriorityChars == NULL) return;

    // If there are no alternates, don't do anything.
    if (nAlts == 0) return;

	// Scan through the alt list and copy all the priority characters into the 
	// temporary list.
	for (i = 0; i < nAlts; i ++) {
		if (IsPriorityChar(&g_locRunInfo, &charSet, wAlts[i]))
        {
			wTmp[iUsed] = wAlts[i];
            aTuneScoresTmp[iUsed] = pTuneScores[i];
			iUsed ++;

			if (fNonPriorityFound) {
				fPriorityBelowNonPriority = TRUE;
			}
		} else {
			fNonPriorityFound = TRUE;
		}
	}

	// If there weren't any priority characters, then return
	if (iUsed == 0) return;

	// If there aren't any priority characters listed below non-priority ones
	if (!fPriorityBelowNonPriority) return;

	// Scan through the alt list and copy all the non-priority characters into the 
	// temporary list.
	for (i = 0; i < nAlts; i ++) {
		if (!IsPriorityChar(&g_locRunInfo, &charSet, wAlts[i]))
        {
			// If the penalty has not been set yet.
			if (!fPenaltySet) {
				penalty = (VTuneComputeScore(&g_vtuneInfo.pTune->weights, &(aTuneScoresTmp[iUsed - 1])) - 
                                VTuneComputeScore(&g_vtuneInfo.pTune->weights, &(pTuneScores[i])) - PENALTY_ALC_PRIORITY);
                if (g_vtuneInfo.pTune->weights.afl[VTUNE_UNIGRAM] > 0)
                {
                    penalty /= g_vtuneInfo.pTune->weights.afl[VTUNE_UNIGRAM];
                }
				fPenaltySet = TRUE;
			}
			wTmp[iUsed] = wAlts[i];
            aTuneScoresTmp[iUsed] = pTuneScores[i];
            aTuneScoresTmp[iUsed].afl[VTUNE_UNIGRAM] += penalty;
			iUsed ++;
		}
	}

	ASSERT(iUsed == nAlts);

	// Then copy the temp lists back to the output
	for (i = 0; i < nAlts; i ++) {
		wAlts[i] = wTmp[i];
        pTuneScores[i] = aTuneScoresTmp[i];
	}
}

// See if two rectangles overlap one another
BOOL IsOverlapped(RECT r1, RECT r2)
{
	if (r1.left>r2.right || r1.right<r2.left || r1.top>r2.bottom || r1.bottom<r2.top)
		return FALSE;
	return TRUE;
}

// See if the given bounding box overlaps with any previous character in the
// best path, starting from alternate iPrevAlt at iPrevStroke.
BOOL IsOverlappedPath(LATTICE *lat, int iPrevStroke, int iPrevAlt, RECT bbox)
{
	while (iPrevStroke!=-1) {
		LATTICE_ELEMENT *elem=lat->pAltList[iPrevStroke].alts+iPrevAlt;
		if (IsOverlapped(elem->bbox,bbox)) return TRUE;
		iPrevStroke -= elem->nStrokes;
		iPrevAlt = elem->iPrevAlt;
	}
	return FALSE;
}

// Penalties used in separator mode
#define PENALTY_SKIP_INK 200
#define PENALTY_SKIP_PROMPT 200
#define PENALTY_OVERLAP_CHAR 300
#define PENALTY_OVERLAP 100

// Given the proposed next character to be added to the lattice, and the next available prompt character,
// is the proposed character allowed?  The character is allowed if is either the "SYM_UNKNOWN"
// character or a character which appears later in the string.  If this required skipping prompt
// characters, or the character is SYM_UNKNOWN, then a penalty is also returned.  If fEndInput is set
// then all characters remaining in the prompt are consumed (skipped) with a cost.  If the proposed
// character is not allowed, -1 is returned.  Otherwise, we return the next available prompt character.
int IsAllowedNextChar(LATTICE *lat, wchar_t wchNext, int iAnswerPtr, BOOL fEndInput, float *pflCost)
{
    BOOL fMatched = FALSE;
    *pflCost = 0;

    // If we're not in separator mode, don't do anything.
    if (!lat->fSepMode) 
    {
        return 0;
    }

    // If this character is unknown
    if (wchNext == SYM_UNKNOWN)
    {
        // At end of input, skip all remaining prompt characters
        if (fEndInput)
        {
            while (lat->wszAnswer[iAnswerPtr] != 0)
            {
                *pflCost += -PENALTY_SKIP_PROMPT;
                iAnswerPtr++;
            }
        }

        // Return a pointer to the end of the prompt
        return iAnswerPtr;
    }

    // Convert the dense code to unicode for comparison with the prompt
    wchNext = LocRunDense2Unicode(&g_locRunInfo, wchNext);

    // While we haven't reached the end of the prompt and haven't found a match,
    // skip a prompt character and add a penalty
    while (lat->wszAnswer[iAnswerPtr] != 0 && lat->wszAnswer[iAnswerPtr] != wchNext)
    {
        iAnswerPtr++;
        *pflCost += -PENALTY_SKIP_PROMPT;
    }

    // If we didn't find a match, return failure.
    if (lat->wszAnswer[iAnswerPtr] != wchNext)
    {
        return -1;
    }

    // Found a match
    iAnswerPtr++;
    
    // Now add a penalty for any unmatched characters at the end of the input.
    if (fEndInput)
    {
        while (lat->wszAnswer[iAnswerPtr] != 0)
        {
            *pflCost += -PENALTY_SKIP_PROMPT;
            iAnswerPtr++;
        }
    }

    // Return the prompt pointer.
    return iAnswerPtr;
}

// Sometimes the algorithm will not produce any alternates for a given stroke.  This is bad, because it could
// result in a disconnected lattice.  The solution is to produce an alternate with the lowest possible 
// probability and a character code of SYM_UNKNOWN.  This will never get used if there is another choice, 
// but if there is no other choice, the user might see it.  It will get translated to a SYM_UNKNOWN when returned 
// to the user.
void FakeRecogResult(LATTICE *lat, int iStroke, int nStrokes, float logProb)
{
    int i, width, height;

    // Create the fake alternate, which is always alternate zero.
    LATTICE_ELEMENT elem;
    elem.iPathLength = 1;
    elem.fCurrentPath=FALSE;
    elem.fUsed=TRUE;
    elem.maxDist=0;
    elem.nPrevStrokes=0;
    elem.nStrokes=nStrokes;
    elem.logProb=logProb;
    elem.logProbPath=logProb;
    elem.iPrevAlt=-1;
    elem.score=0;
    elem.wChar=SYM_UNKNOWN;
    elem.wPrevChar=0;
    elem.iPromptPtr = 0;
    
#ifdef HWX_TUNE
    VTuneZeroWeights(&elem.tuneScores);
    elem.tuneScores.afl[VTUNE_FREE_PROB] = logProb;
#endif

    // Build a bounding box for this fake character.
    elem.bbox = lat->pStroke[iStroke].bbox;
    for (i = iStroke-nStrokes+1; i < iStroke; i ++) {
        RECT other = lat->pStroke[i].bbox;
        elem.bbox.left = __min(elem.bbox.left, other.left);
        elem.bbox.right = __max(elem.bbox.right, other.right);
        elem.bbox.top = __min(elem.bbox.top, other.top);
        elem.bbox.bottom = __max(elem.bbox.bottom, other.bottom);
    }
    
    // Copy bounding box to the writing box
    elem.writingBox = elem.bbox;
    
    // If the box is more than 4 times wider than high ...
    width = elem.writingBox.right - elem.writingBox.left;
    height = elem.writingBox.bottom - elem.writingBox.top;
    if (width / 4 > height) {
        // ... increase the height by width / 4
        elem.writingBox.top -= width / 8;
        elem.writingBox.bottom += width / 8;
    }
    
    // If this is not the first character in the lattice, then hook it up to the best previous 
    // alternate.
    if (iStroke-nStrokes>-1) {
        LATTICE_ELEMENT *pPrevElem;
        int iAlt;
        elem.iPrevAlt=0;
        for (iAlt=1; iAlt<lat->pAltList[iStroke-nStrokes].nUsed; iAlt++) {
            if (lat->pAltList[iStroke-nStrokes].alts[elem.iPrevAlt].logProbPath < 
                lat->pAltList[iStroke-nStrokes].alts[iAlt].logProbPath) {
                elem.iPrevAlt=iAlt;
            }
        }
        pPrevElem = &lat->pAltList[iStroke-nStrokes].alts[elem.iPrevAlt];
        elem.iPathLength = pPrevElem->iPathLength + 1;
        elem.wPrevChar = pPrevElem->wChar;
        elem.logProbPath = (pPrevElem->logProbPath * pPrevElem->iPathLength + logProb) / elem.iPathLength;
        elem.iPromptPtr = pPrevElem->iPromptPtr;
#ifdef HWX_TUNE
        {
            int iParam;
            for (iParam = 0; iParam < VTUNE_NUM_WEIGHTS; iParam++)
            {
                elem.tuneScores.afl[iParam] =
                    (elem.tuneScores.afl[iParam] + 
                    pPrevElem->tuneScores.afl[iParam] * pPrevElem->iPathLength) /
                    elem.iPathLength;
            }
        }
#endif
    }

    InsertElement(lat, iStroke, &elem);
}

// Go through the pre-segmentation lattice, and run the recognizer on the top alternates of the
// given column.  The alternates will get replaced with ones containing actual characters.
void BuildRecogAlts(LATTICE *lat, int iStroke, BOOL fStringMode)
{
	VOLCANO_WEIGHTS aTuneScores[MaxAltsPerStroke];
	LATTICE_ALT_LIST bboxAlts;
	int iAlt;
	ASSERT(lat!=NULL);
	ASSERT(iStroke>=0 && iStroke<lat->nStrokes);

	// Make a copy of the current alt-list.
	memcpy(&bboxAlts,&lat->pAltList[iStroke],sizeof(LATTICE_ALT_LIST));

	// Clear out the alt-list in the lattice
	ClearAltList(&lat->pAltList[iStroke]);

	// For each segmentation lattice
	for (iAlt=0; iAlt<bboxAlts.nUsed; iAlt++) {
		
		// We continue only if either there is more space in the alt list, or if it is filled, only
		// if there is a chance that the alternates we are going to insert will have a high enough
		// probability to get on to the list.
		if (1 /*lat->pAltList[iStroke].nUsed<MaxAltsPerStroke ||
			bboxAlts.alts[iAlt].logProbPath>lat->pAltList[iStroke].alts[lat->pAltList[iStroke].nUsed-1].logProbPath*/) {

			int nZillaStrokes;
			wchar_t wAlts[MaxAltsPerStroke];
			FLOAT probAlts[MaxAltsPerStroke];
			FLOAT score;
            float flCost;

			// Run the recognizer, get scores/probabilities back
			int nRecogAlts=RecognizerProbs(lat,iStroke,bboxAlts.alts[iAlt].nStrokes,bboxAlts.alts[iAlt].bbox,
				wAlts,probAlts,&score,&nZillaStrokes, aTuneScores, fStringMode);
			int iRecogAlt;

            // In separator mode, add on an "unknown character" at the end of the alt list
            if (lat->fSepMode) 
            {
                if (nRecogAlts < MaxAltsPerStroke) 
                {
                    wAlts[nRecogAlts] = SYM_UNKNOWN;
                    aTuneScores[nRecogAlts].afl[VTUNE_FREE_PROB] = -PENALTY_SKIP_INK;
                    if (nRecogAlts > 0) 
                    {
                        aTuneScores[nRecogAlts].afl[VTUNE_FREE_PROB] +=
                            aTuneScores[nRecogAlts - 1].afl[VTUNE_FREE_PROB];
                    }
                    nRecogAlts++;
                }
            }

            // Make sure we don't try to apply a priority during tuning.
#ifdef HWX_TUNE
            if (g_pTuneFile == NULL)
#endif
            {
			    ApplyALCPriority(lat, nRecogAlts, wAlts, aTuneScores);
            }

			// For reach alternate from the recognizer
			for (iRecogAlt=0; iRecogAlt<nRecogAlts; iRecogAlt++) 
			{
				LATTICE_ELEMENT elem;

                wchar_t unicode = (wAlts[iRecogAlt] != SYM_UNKNOWN) ? LocRunDense2Unicode(&g_locRunInfo,wAlts[iRecogAlt]) : SYM_UNKNOWN;

				// Set up the alternate
				elem.fUsed=TRUE;
				elem.fCurrentPath=FALSE;
				elem.wChar=wAlts[iRecogAlt];
				elem.wPrevChar=0;
				elem.nStrokes=bboxAlts.alts[iAlt].nStrokes;
				elem.nPrevStrokes=0;
				elem.iPrevAlt=-1;
				elem.space=bboxAlts.alts[iAlt].space;
				elem.area=bboxAlts.alts[iAlt].area;
				elem.bbox=bboxAlts.alts[iAlt].bbox;
				elem.writingBox=GuessWritingBox(elem.bbox,elem.wChar);
				elem.maxDist=bboxAlts.alts[iAlt].maxDist;
				elem.score=score;
#ifdef USE_IFELANG3_BIGRAMS
				elem.nBigrams=0;
#endif

				// If this alternate is the first character in the lattice, then it 
				// gets handled differently.
				if (iStroke-elem.nStrokes+1==0) 
                {
                    int iAnswerPtr = IsAllowedNextChar(lat, elem.wChar, 0, 
                            ((iStroke == lat->nStrokes - 1) && lat->fEndInput), &flCost);
                    if (iAnswerPtr >= 0)
                    {
                        elem.iPromptPtr = iAnswerPtr;
                        aTuneScores[iRecogAlt].afl[VTUNE_FREE_PROB] += flCost;

                        // We can only apply the language model when we are not in 
                        // separator mode, and we know what character this is.
                        if (!lat->fSepMode && elem.wChar != SYM_UNKNOWN)
                        {
                            if (lat->fUseLM) 
                            {
					            // Apply the language model
					            LanguageModelBigram(
                                    lat->fProbMode,
                                    FALSE,
                                    !lat->fUseGuide,
                                    elem.wChar,
                                    elem.nStrokes,
                                    GetPreContextChar(lat),
						            aTuneScores + iRecogAlt);
                                // If we are at the end of the input, use the post-context if it is available
                                if (lat->fEndInput && iStroke == lat->nStrokes - 1 && GetPostContextChar(lat) != SYM_UNKNOWN)
                                {
							        LanguageModelBigram(
                                        lat->fProbMode,
                                        TRUE,
                                        !lat->fUseGuide,
                                        GetPostContextChar(lat),
                                        elem.nStrokes,
                                        elem.wChar,
								        aTuneScores + iRecogAlt); 
                                }
                            }
                            // Centipede only makes sense when the full character is written.
                            // Also we may want to allow this in separator mode once it is
                            // trained on free input data.
                            if (lat->recogSettings.partialMode == HWX_PARTIAL_ALL)
                            {
					            RecogUnaryProb(lat, iStroke, elem.nStrokes, elem.bbox, elem.wChar, aTuneScores + iRecogAlt, fStringMode);
                            }
                        }

					    // If in free mode, also add in the pre-segmentation probabilities.
                        // We don't care about segmentation in word mode.
					    if (!lat->fWordMode && !lat->fUseGuide) 
                        {
						    CheapUnaryProb(elem.nStrokes, elem.bbox, elem.space, elem.area, aTuneScores + iRecogAlt);
					    }
#ifdef HWX_TUNE
                        // Record values for tuning
						elem.tuneScores = aTuneScores[iRecogAlt];
#endif
						
					    // Apply tuning parameters
					    elem.logProb = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, aTuneScores + iRecogAlt);
					    // Combined score includes the language model probability
					    elem.logProbPath = VTuneComputeScore(&g_vtuneInfo.pTune->weights, aTuneScores + iRecogAlt);
                        elem.iPathLength = 1;
					    // Put it in the lattice
					    InsertElement(lat, iStroke, &elem);
                    }
				}
                else 
                {
					BOOL first=TRUE;
					int iPrevAlt;

					// If there are previous characters in the lattice, then we loop over each previous
					// alternate, and use bigram probabilities.  The best alternate is recorded, and 
					// the probability associated with the best alternate is stored with the current
					// alternate.  This essentially does a Viterbi search.  
					for (iPrevAlt=0; iPrevAlt<lat->pAltList[iStroke-elem.nStrokes].nUsed; iPrevAlt++) 
                    {
						LATTICE_ELEMENT *prevElem=&lat->pAltList[iStroke-elem.nStrokes].alts[iPrevAlt];
                        int iAnswerPtr = IsAllowedNextChar(lat, elem.wChar, prevElem->iPromptPtr, 
                                ((iStroke == lat->nStrokes - 1) && lat->fEndInput), &flCost);
                        if (iAnswerPtr >= 0)
                        {
                            float prob, probPath;
                            wchar_t prevUnicode = 
                                (prevElem->wChar == SYM_UNKNOWN) ?
                                    SYM_UNKNOWN : LocRunDense2Unicode(&g_locRunInfo,prevElem->wChar);

                            VOLCANO_WEIGHTS altTuneScores = aTuneScores[iRecogAlt];

						    ASSERT(prevElem->fUsed);


                            // If we're in free mode and this choice of a previous alternate would cause
                            // an overlap, then don't consider it.
                            // Don't use this heuristic in separator mode, because sometimes the characters
                            // really do overlap and we want to be able to learn that in the future.
						    if (!lat->fSepMode && !lat->fUseGuide && 
                                IsOverlappedPath(lat, iStroke - elem.nStrokes, iPrevAlt, elem.bbox))
                            {
							    continue;
                            }

                            // Only use the language model if we are not in separator mode,
                            // and we know what the current character is.
                            if (!lat->fSepMode && elem.wChar != SYM_UNKNOWN) 
                            {
                                if (lat->fUseLM) 
                                {
						            // If we're in boxed mode, and the boxes are consequtive, then 
						            // use bigrams as the language model, otherwise use a unigram
        					        if (!lat->fUseGuide || lat->pStroke[iStroke].iBox-1 == lat->pStroke[iStroke-elem.nStrokes].iBox) 
                                    {
							            LanguageModelBigram(
                                            lat->fProbMode,
                                            TRUE,
                                            !lat->fUseGuide,
                                            elem.wChar,
                                            elem.nStrokes,
                                            prevElem->wChar,
								            &altTuneScores); 
						            }
                                    else 
                                    {
							            LanguageModelBigram(lat->fProbMode,
                                            FALSE,
                                            !lat->fUseGuide,
                                            elem.wChar,
                                            elem.nStrokes,
                                            SYM_UNKNOWN,
								            &altTuneScores);
						            }
                                    // If we are at the end of the input, use the post-context if it is present
                                    if (lat->fEndInput && iStroke == lat->nStrokes - 1 && GetPostContextChar(lat) != SYM_UNKNOWN)
                                    {
							            LanguageModelBigram(
                                            lat->fProbMode,
                                            TRUE,
                                            !lat->fUseGuide,
                                            GetPostContextChar(lat),
                                            elem.nStrokes,
                                            elem.wChar,
								            &altTuneScores); 
                                    }
                                }
                                // Centipede only makes sense when the whole character is written
                                // Also we may want to allow this in separator mode once it is
                                // trained on free input data.
                                if (lat->recogSettings.partialMode == HWX_PARTIAL_ALL)
                                {
						            RecogBinaryProb(lat, iStroke, elem.nStrokes, elem.bbox, elem.wChar,
										            iStroke-elem.nStrokes, prevElem->nStrokes, prevElem->bbox, prevElem->wChar,
                                                    &altTuneScores);
                                }
                            }

							// In free mode, also include the pre-segmentation probabilities
                            // We don't care about segmentation in word mode
                            if (!lat->fWordMode && !lat->fUseGuide) 
                            {
                                BOOL fSegOkay = CheapBinaryProb(elem.nStrokes, elem.bbox, elem.space, elem.area,
											    prevElem->nStrokes, prevElem->bbox, prevElem->space, prevElem->area,
                                                    &altTuneScores);
                                // If we're not in separator mode, then prune based on the 
                                // segmentation score
                                if (!lat->fSepMode && !fSegOkay) 
                                {
                                    continue;
                                }
                                // In separator mode, add a penalty for overlapping characters, rather than
                                // making a hard decision as is done during normal recognition.
						        if (lat->fSepMode && IsOverlappedPath(lat, iStroke - elem.nStrokes, iPrevAlt, elem.bbox))
                                {
                                    altTuneScores.afl[VTUNE_FREE_SEG_BIGRAM] += 
                                        ((elem.wChar == SYM_UNKNOWN) ? -PENALTY_OVERLAP : -PENALTY_OVERLAP_CHAR);
                                }
    						}

                            // Add in the prompt matching cost temporarily
                            altTuneScores.afl[VTUNE_FREE_PROB] += flCost;

					        // Apply tuning parameters
					        prob = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, &altTuneScores);
					        // Combined score includes the language model probability
					        probPath = (VTuneComputeScore(&g_vtuneInfo.pTune->weights, &altTuneScores) + 
                            prevElem->logProbPath * prevElem->iPathLength) / (prevElem->iPathLength + 1);
						    // If we found a better previous alternate, update.
						    if (/*probPath > Log2Range &&*/ (first || probPath > elem.logProbPath))							
                            {
#ifdef HWX_TUNE
                                int iParam;
                                for (iParam = 0; iParam < VTUNE_NUM_WEIGHTS; iParam++)
                                {
                                    elem.tuneScores.afl[iParam] =
                                        (altTuneScores.afl[iParam] + 
                                        prevElem->tuneScores.afl[iParam] * prevElem->iPathLength) /
                                        (prevElem->iPathLength + 1);
                                }
#endif
							    elem.logProb=prob;
							    elem.logProbPath=probPath;
							    elem.iPrevAlt=iPrevAlt;
							    elem.nPrevStrokes=prevElem->nStrokes;
							    elem.wPrevChar=prevElem->wChar;
							    elem.iPathLength = prevElem->iPathLength + 1;
                                elem.iPromptPtr = iAnswerPtr;
    							first=FALSE;
#ifdef USE_IFELANG3_BIGRAMS
							    elem.bigramLogProbs[elem.nBigrams]=prob;
							    elem.bigramAlts[elem.nBigrams]=iPrevAlt;
							    elem.nBigrams++;
#endif
    						}
					    }
					    // put the alternate in the lattice
					    if (!first) InsertElement(lat,iStroke,&elem);
				    }
			    }
		    }
	    }
    }
}

// This function does assignment of strokes to boxes, and tries to keep ink going into
// consequtive sequences of boxes, even if it is not written in quite the right place.  
// This seems to make a difference on the test set. 
void GetBoxIndexSINFO(LATTICE *lat, STROKE *pStroke, int *pixBoxPrev, int *piyBoxPrev)
{
#define CYBASE_FUDGE 4

    XY    xy;
    int   ixBox, iyBox, iyBoxBiased;
    RECT  *rect;

    HWXGUIDE *lpguide = &lat->guide;

	ASSERT(lpguide);
	ASSERT(lpguide->cHorzBox > 0);
	ASSERT(lpguide->cVertBox > 0);

	rect = &pStroke->bbox;

	// Center of the stroke bounding box horizontally
	xy.x = (rect->left + rect->right) / 2;

	// 1/4 down from the top of the stroke's bounding box
	xy.y = (rect->top * (CYBASE_FUDGE - 1) + rect->bottom) / CYBASE_FUDGE;

	// Box number in X is just where xy.x falls in the guide.
	ixBox = (xy.x - lpguide->xOrigin) / (int)lpguide->cxBox;
	if (ixBox < 0)
		ixBox = 0;
	else if (ixBox > (int)lpguide->cHorzBox - 1)
		ixBox = lpguide->cHorzBox - 1;

	// Same for Y
	iyBox = (xy.y - lpguide->yOrigin) / (int)lpguide->cyBox;
	if (iyBox < 0)
		iyBox = 0;
	else if (iyBox > (int)lpguide->cVertBox - 1)
		iyBox = lpguide->cVertBox - 1;

	// If we have a previous stroke's Y box number
	if (*piyBoxPrev >= 0)
	{
		// Help dots, accents, etc land on their respective boxes...

		if (iyBox < *piyBoxPrev)
		{
			// If the stroke seems to be in a higher box,
			// shift the "hot spot" down 1/2 of the remaining distance to the 
			// bottom of the box
			xy.y = (rect->bottom + xy.y) / 2;
	
			// compute the new Y box number
			iyBoxBiased = (xy.y - lpguide->yOrigin) / (int)lpguide->cyBox;
			if (iyBoxBiased > (int)(lpguide->cVertBox - 1))
				iyBoxBiased = lpguide->cVertBox - 1;
			else if (iyBoxBiased < 0)
				iyBoxBiased = 0;

			// if this one matches the previous stroke, then keep it
			if (iyBoxBiased == *piyBoxPrev)
				iyBox = iyBoxBiased;
		}
		else if (iyBox > *piyBoxPrev && ixBox >= *pixBoxPrev)
		{
			// If the stroke seems to be in a lower box,
			// shift the "hot spot" up 1/2 of the remaining distance to the 
			// top of the box
			xy.y = (rect->top + xy.y) / 2;
			
			// compute the new Y box number
			iyBoxBiased = (xy.y - lpguide->yOrigin) / (int)lpguide->cyBox;
			if (iyBoxBiased > (int)(lpguide->cVertBox - 1))
				iyBoxBiased = lpguide->cVertBox - 1;
			else if (iyBoxBiased < 0)
				iyBoxBiased = 0;
  
			// if this one matches the previous stroke, then keep it
			if (iyBoxBiased == *piyBoxPrev)
				iyBox = iyBoxBiased;
		}
	}

	// Return the result
	*pixBoxPrev = ixBox;
	*piyBoxPrev = iyBox;

	pStroke->iBox = ixBox + (iyBox * lpguide->cHorzBox);
}

// This function contained my old algorithm for assigning strokes to boxes, which
// has now been commented out to call the above routine from Tsunami.
void AssignStrokeToBox(LATTICE *lat, STROKE *pStroke, int *pixBoxPrev, int *piyBoxPrev)
{
#if 0
	int iInk;
	int totX=0, totY=0;
	int boxX, boxY;
	ASSERT(lat!=NULL);
	ASSERT(pStroke!=NULL);
	ASSERT(pStroke->nInk>0);
	if (pStroke->iBox != -1) return;
	for (iInk = 0; iInk < pStroke->nInk; iInk++) {
		totX += pStroke->pts[iInk].x;
		totY += pStroke->pts[iInk].y;
	}
	totX /= pStroke->nInk;
	totY /= pStroke->nInk;
	boxX = (totX - lat->guide.xOrigin) / lat->guide.cxBox;
	boxY = (totY - lat->guide.yOrigin) / lat->guide.cyBox;
	if (boxX < 0) boxX=0;
	if (boxX >= (int)lat->guide.cHorzBox) boxX = lat->guide.cHorzBox - 1;
	if (boxY < 0) boxY=0;
	if (boxY >= (int)lat->guide.cVertBox) boxY = lat->guide.cVertBox - 1;
	pStroke->iBox = boxX + boxY * lat->guide.cHorzBox;
#endif
	GetBoxIndexSINFO(lat,pStroke,pixBoxPrev,piyBoxPrev);
}

// Function to compare the ordering of two strokes in qsort.  Used to put
// the strokes back in their original order if re-processing is requested.
int __cdecl CompareStrokes(const void *p1, const void *p2) 
{
	STROKE *pStroke1=(STROKE*)p1;
	STROKE *pStroke2=(STROKE*)p2;
	ASSERT(pStroke1!=NULL);
	ASSERT(pStroke2!=NULL);
	// Boxes are in numerical order
	if (pStroke1->iBox < pStroke2->iBox) return -1;
	if (pStroke1->iBox > pStroke2->iBox) return 1;
	// Within a box, strokes are in time order.
	if (pStroke1->iOrder < pStroke2->iOrder) return -1;
	if (pStroke1->iOrder > pStroke2->iOrder) return 1;
	// Two strokes with the same iOrder values shouldn't occur
	ASSERT(0);
	return 0;
}

#ifdef MERGE_STROKES
// This code merges adjacent strokes with one another, if the end point of
// one is close enough to the starting point of the next.  Note that this 
// code works on the whole list of strokes at once; it is possible to do
// this incrementally also, by keeping track of the last stroke which was
// added.
void MergeStrokes(LATTICE *lat)
{
	int iStroke, iDest;
	// First put the strokes back into time order, and clear the alt lists
/*	for (iStroke=0; iStroke<lat->nStrokes; iStroke++) {
		lat->pStroke[iStroke].iBox=-1;
		ClearAltList(lat->pAltList+iStroke);
	}
	qsort(lat->pStroke,lat->nStrokes,sizeof(STROKE),CompareStrokes); */

	// Make sure we have some more strokes to process
	if (lat->nProcessed == lat->nStrokes)
		return;

	// Then go through and merge strokes, starting at the newly added ones.
	iDest=lat->nProcessed;
	for (iStroke=lat->nProcessed+1; iStroke<lat->nStrokes; iStroke++) {
		BOOL fMerged=FALSE;
		POINT ptFirst=lat->pStroke[iDest].pts[lat->pStroke[iDest].nInk-1];
		POINT ptLast=lat->pStroke[iStroke].pts[0];
		int dx=(ptFirst.x-ptLast.x);
		int dy=(ptFirst.y-ptLast.y);
		int dist=dx*dx+dy*dy;
//		fprintf(stderr,"%d(%d,%d-%d,%d),",dist,ptFirst.x,ptFirst.y,ptLast.x,ptLast.y);
		if (dist<=MERGE_THRESHOLD*MERGE_THRESHOLD) {
			// Merge the strokes, and free up the one that was merged in
			fMerged=AddStrokeToStroke(lat->pStroke+iDest,lat->pStroke+iStroke);
//			fprintf(stderr,"X,");
//			fprintf(stderr,"(%d->%d)",iStroke,iDest);
		}
		if (fMerged) {
			// If we successfully merged, then free the merged stroke.
			FreeStroke(lat->pStroke+iStroke);
		} else {
			// If we didn't merge, just copy the stroke
			iDest++;
			if (iDest<iStroke) 
				lat->pStroke[iDest]=lat->pStroke[iStroke];
		}
	}
//	fprintf(stderr,"\n");
	// Record the new number of strokes
	lat->nStrokes=iDest+1;
}
#endif

// Assign the strokes to boxes, then sort the strokes in order by their box numbers.
// Note that the alternate lists are invalidated by this (since they depend on stroke
// order), so the alt lists are cleared and must be recomputed.
void SortStrokesByGuide(LATTICE *lat)
{
	int iStroke, ixBoxPrev=-1, iyBoxPrev=-1;
	ASSERT(lat!=NULL);
	ASSERT(lat->fUseGuide);
	// If we have any unprocessed strokes left to assign
	if (lat->nStrokes-lat->nProcessed>0) {
		int iEarliestTouched = -1;
		// Assign the strokes to boxes and clear out their alt lists,
		// and record the lowest box number which has been touched.
		for (iStroke=lat->nProcessed; iStroke<lat->nStrokes; iStroke++) 
		{
			AssignStrokeToBox(lat,lat->pStroke+iStroke,&ixBoxPrev,&iyBoxPrev);
			if (iEarliestTouched == -1 || lat->pStroke[iStroke].iBox < iEarliestTouched)
			{
				iEarliestTouched = lat->pStroke[iStroke].iBox;
			}
		}
		// If the writer touched a box which has already been processed, then
		// we will need to do some reprocessing.
		if (lat->nProcessed > 0) 
		{
			if (lat->pStroke[lat->nProcessed - 1].iBox >= iEarliestTouched)
			{
				// Figure out how far back we actually need to process.  This is done
				// by scanning the lattice to find the boundary for the earliest touched box.
				lat->nProcessed = 0;
				for (iStroke = 0; iStroke < lat->nStrokes; iStroke++) 
				{
					if (lat->pStroke[iStroke].iBox >= iEarliestTouched)
					{
						lat->nProcessed = iStroke;
						break;
					}
				}
			}
		}
		// Sort the strokes into box order
		qsort(lat->pStroke + lat->nProcessed,
			lat->nStrokes - lat->nProcessed,
			sizeof(STROKE), CompareStrokes);
	}
}

// Count the number of distinct boxes that are used in the ink
int CountBoxes(LATTICE *lat)
{
	int iStroke;
	int nBoxes=0;
	int prevBox=-1;
	for (iStroke=0; iStroke<lat->nStrokes; iStroke++) {
		if (prevBox!=lat->pStroke[iStroke].iBox) nBoxes++;
		prevBox=lat->pStroke[iStroke].iBox;
	}
	return nBoxes;
}

// Determine if the given stroke number iEnd is the valid end of a character.
BOOL CandidateEnd(LATTICE *lat, int iEnd)
{
	// If we're on the last stroke seen so far, then we don't know for sure that
	// it is the end of a character until we get the end of input signal.
	if (iEnd==lat->nStrokes-1) {
		return TRUE;
/*
		if (lat->fEndInput) 
			return TRUE; else
				return FALSE;
*/
	}
	// If we're not at the last stroke, just check if the box numbers change.
	if (lat->pStroke[iEnd].iBox!=lat->pStroke[iEnd+1].iBox) return TRUE;
	return FALSE;
}

// Mark the "best path so far", ie the path through the lattice which will not change
// if more input is added.  This only works in boxed mode.
void FindIncrementalPath(LATTICE *lat)
{
	int iStroke, iAlt;
	int iStartAlt, iStartStroke = lat->nProcessed - 1;
	if (iStartStroke >= 0) {
		int nPaths = lat->pAltList[iStartStroke].nUsed;

		ASSERT(lat->fUseGuide);

		// First zero out the hit counts in each lattice element which doesn't have
		// its result determined yet.
		for (iStroke = lat->nFixedResult; iStroke < lat->nProcessed; iStroke++) 
			for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++) 
				lat->pAltList[iStroke].alts[iAlt].nHits = 0;
		
		// Then trace back all the paths from the current end of lattice to the 
		// point at which all paths converge, counting the number of times each
		// element occurs on a path.
		for (iStartAlt = 0; iStartAlt < nPaths; iStartAlt++) {
			iStroke = iStartStroke;
			iAlt = iStartAlt;
			while (iStroke >= lat->nFixedResult) {
				LATTICE_ELEMENT *elem = lat->pAltList[iStroke].alts + iAlt;
				elem->nHits++;
				iStroke -= elem->nStrokes;
				iAlt = elem->iPrevAlt;
			}
		}

		// All path elements that were hit by all nPaths paths are part of the
		// current path.  
		for (iStroke = lat->nFixedResult; iStroke < lat->nProcessed; iStroke++) 
			for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++) {
				if (lat->pAltList[iStroke].alts[iAlt].nHits == nPaths) {
					lat->pAltList[iStroke].alts[iAlt].fCurrentPath = TRUE;
					lat->nFixedResult = iStroke + 1;
				} else
					lat->pAltList[iStroke].alts[iAlt].fCurrentPath = FALSE;
			}
	}
}

// Mark the best path through the lattice (assuming we're at the end of the input),
// and return the number of characters along that path.
int FindFullPath(LATTICE *lat)
{
	int nChars=0;
	int iStroke, iAlt;

	// Wipe out the current path
	for (iStroke = 0; iStroke < lat->nStrokes; iStroke++) 
		for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++) 
			lat->pAltList[iStroke].alts[iAlt].fCurrentPath = FALSE;

	// Trace back from the best path
	iStroke = lat->nProcessed - 1;
	iAlt = 0;
	while (iStroke!=-1) {
		int iNextStroke, iNextAlt;
		if (lat->pAltList[iStroke].nUsed==0) {
			ASSERT(lat->pAltList[iStroke].nUsed!=0);
			iStroke--;
			iAlt=0;
			continue;
		}
		lat->pAltList[iStroke].alts[iAlt].fCurrentPath=TRUE;
		nChars++;
		iNextStroke=iStroke-lat->pAltList[iStroke].alts[iAlt].nStrokes;
		iNextAlt=lat->pAltList[iStroke].alts[iAlt].iPrevAlt;
		iStroke=iNextStroke;
		iAlt=iNextAlt;
	}
	return nChars;
}

// This routine is the analogy of ProcessLattice for the boxed mode case.  Since we have
// the boxes, the segmentation problem is "deterministic".  We create the lattice with 
// the minimal set of pre-segmentation lattice elements.
void CreateLatticeForGuide(LATTICE *lat)
{
    int cContextBefore = 0, cContextAfter = 0;
	int iStroke;
	int iPrevEnd;
    BOOL fStringMode;
	ASSERT(lat!=NULL);
#ifdef MERGE_STROKES
	// First run the stroke merging algorithm
	MergeStrokes(lat);
#endif
	// Assign the strokes to boxes, and put them in the appropriate order.  Note that
	// this also clears the alternate lists for the strokes.
	SortStrokesByGuide(lat);
    if (lat->wszBefore != NULL)
        cContextBefore = wcslen(lat->wszBefore);
    if (lat->wszAfter != NULL)
        cContextAfter = wcslen(lat->wszAfter);
    fStringMode = (CountBoxes(lat) + cContextBefore + cContextAfter > 1);
#ifdef USE_IFELANG3
	// Decide whether to use IFELang3.  The criterion is that we can't be doing incremental 
	// processing, we must have IFELang3 available, and we must have at least MIN_CHARS_FOR_IFELANG3 boxes
    // of ink plus context.  There is a special case for one character of ink, in which we require that
    // both the pre- and post-context each have at least MIN_CONTEXT_FOR_IFELANG3 characters.
	if (/* !lat->fIncremental && */ LatticeIFELang3Available())
    {
        int cChars = CountBoxes(lat);
        if ((cChars == 1 && cContextBefore >= MIN_CONTEXT_FOR_IFELANG3 && cContextAfter >= MIN_CONTEXT_FOR_IFELANG3) ||
            (cChars > 1 && cChars + cContextBefore + cContextAfter >= MIN_CHARS_FOR_IFELANG3))
        {
            lat->fUseIFELang3 = TRUE;
        }
        else
        {
    		lat->fUseIFELang3 = FALSE;
        }
	} else {
		lat->fUseIFELang3=FALSE;
	}
//    { FILE *f=fopen("/ife.log","w"); fprintf(f,"%s %d %d %d\n",(lat->fUseIFELang3?"YES":"NO"),cContextBefore,cContextAfter,CountBoxes(lat)); fclose(f); }
#else
	lat->fUseIFELang3=FALSE;
#endif
#ifdef USE_OLD_DATABASES
	if (lat->fUseIFELang3)
		lat->fProbMode=TRUE; else
			lat->fProbMode=FALSE;
//	fprintf(stderr,"prob=%d, ife=%d, guide=%d\n",lat->fProbMode,lat->fUseIFELang3,lat->fUseGuide);
//	lat->fProbMode=FALSE;
//	lat->fUseIFELang3=FALSE;
    lat->fProbMode = FALSE;
#else
	lat->fProbMode=TRUE;
#endif
	iPrevEnd = lat->nProcessed-1;
	// For each stroke
	for (iStroke=lat->nProcessed; iStroke<lat->nStrokes; iStroke++) 
	{
		ClearAltList(lat->pAltList + iStroke);
		// If this stroke is the end of a box, then create an alternate
		if (CandidateEnd(lat,iStroke)) {
			// Create the alternate, filling in all the features
			int i;
			LATTICE_ELEMENT *elem=&(lat->pAltList[iStroke].alts[0]);
			RECT bbox;
//			INTERVALS xIntervals, yIntervals;
			bbox=lat->pStroke[iStroke].bbox;
//			EmptyIntervals(&xIntervals,bbox.left,bbox.right);
//			EmptyIntervals(&yIntervals,bbox.top,bbox.bottom);
			for (i=iPrevEnd+1; i<=iStroke; i++) {
				RECT other=lat->pStroke[i].bbox;
				bbox.left=__min(bbox.left,other.left);
				bbox.right=__max(bbox.right,other.right);
				bbox.top=__min(bbox.top,other.top);
				bbox.bottom=__max(bbox.bottom,other.bottom);
//				ExpandIntervalsRange(&xIntervals,other.left,other.right);
//				ExpandIntervalsRange(&yIntervals,other.top,other.bottom);
//				RemoveInterval(&xIntervals,other.left,other.right);
//				RemoveInterval(&yIntervals,other.top,other.bottom);
			}
			lat->pAltList[iStroke].nUsed=1;
			elem->fCurrentPath=FALSE;
			elem->fUsed=TRUE;
			elem->iPrevAlt=0;
			if (iPrevEnd==-1) elem->iPrevAlt=-1;
			elem->maxDist=0;
			elem->nPrevStrokes=0;
			elem->nStrokes=iStroke-iPrevEnd;
			elem->logProb=0;
			elem->logProbPath=0;
			elem->score=0;
			elem->wChar=0;
			elem->wPrevChar=0;
			elem->area=0; //TotalRange(&xIntervals)+TotalRange(&yIntervals);
			elem->space=0; //TotalPresent(&xIntervals)+TotalPresent(&yIntervals);
			elem->bbox=bbox;
			elem->iPathLength = 1;

			// Convert this alternate to a list of recognition alternates.
            BuildRecogAlts(lat, iStroke, fStringMode);
			if (lat->pAltList[iStroke].nUsed==0) {
				// Well, the recognizer came back and send there were no candidates.  
				// Let's put in a SYM_UNKNOWN so the user will see something, and also so
				// the language model will have a path to work with.
//				fprintf(stderr,"Lost a character in boxed mode (box %d).\n",lat->pStroke[iStroke].iBox);
				FakeRecogResult(lat,iStroke,iStroke-iPrevEnd,0);
			}
//			fprintf(stderr,"Found %d\n",lat->pStroke[iStroke].iBox);
			iPrevEnd=iStroke;

			// Record that we have processed up to this point, so that we don't
			// redo any work.
			lat->nProcessed = iStroke+1;
		}
	}
//	if (!lat->fEndInput) 
//		FindIncrementalPath(lat); else
			FindFullPath(lat);
}

//******************************************************************************
//***** Time Bomb code 
//******************************************************************************

// If there is no setting from the project, then by default turn the time bomb on.
#ifndef TIME_BOMB
#define TIME_BOMB 0
#endif

#if TIME_BOMB

#include <stdio.h>

#define TIME_BOMB_MONTH               4
#define TIME_BOMB_DAY                10
#define TIME_BOMB_YEAR             2000
#define TIME_BOMB_NUM_WARNING_DAYS   14

BOOL TimeBombExpired() 
{
    SYSTEMTIME st;
    FILETIME   ft;
    DWORD      dwCurrent, dwExpired;

    // Get the expired day (relative to January 1, 1601)
    ZeroMemory(&st, sizeof(st));
    st.wMonth = TIME_BOMB_MONTH; 
    st.wDay   = TIME_BOMB_DAY;
    st.wYear  = TIME_BOMB_YEAR;
    SystemTimeToFileTime(&st, &ft);
    dwExpired = (DWORD)(*(DWORDLONG*)&ft / (DWORDLONG)864000000000);

    // Get the current day (relative to January 1, 1601)
    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &ft);
    dwCurrent = (DWORD)(*(DWORDLONG*)&ft / (DWORDLONG)864000000000);

    // Check to see if we have expired.
    if (dwCurrent >= dwExpired) 
    {
        static BOOL fWarned = FALSE;
        if (!fWarned) 
        {
            MessageBox(NULL, L"This beta has expired.  Please install our updated beta.", 
                             L"Expiration", MB_ICONWARNING);
            fWarned = TRUE;
        }
        return TRUE;
    }

    // Check to see if we are in the warning period.
    if ((dwCurrent + TIME_BOMB_NUM_WARNING_DAYS) >= dwExpired) 
    {
        static BOOL fWarned = FALSE;
        if (!fWarned)
        {
            wchar_t wszMsg[256];
            swprintf(wszMsg, L"This beta expires in %d day%s.  Please install our updated beta.",
                             (int)(dwExpired - dwCurrent), (dwExpired - dwCurrent == 1) ? L"" : L"s");
            MessageBox(NULL, wszMsg, L"Expiration", MB_ICONWARNING);
            fWarned = TRUE;
        }
    }

    return FALSE;
}

#endif // TIME_BOMB

// Figure out which strokes are valid end of character in paths that span the
// whole lattice.
static BOOL CheckIfValid(LATTICE *lat, int iStartStroke, int iStroke, BYTE *pValidEnd)
{
	LATTICE_ALT_LIST	*pAlts;
	int					ii;
	BOOL				fValidPath;

	// Have we already checked this position?
	if (pValidEnd[iStroke] == LCF_INVALID) {
		return FALSE;
	} else if (pValidEnd[iStroke] == LCF_VALID) {
		return TRUE;
	}

	// Assume no valid path, until proved otherwise.
	fValidPath	= FALSE;

	// Process each element ending at this position in lattice.
	pAlts	= lat->pAltList + iStroke;
	for (ii = 0; ii < pAlts->nUsed; ++ii) {
		LATTICE_ELEMENT		*pElem;
		int					prevEnd;

		pElem	= pAlts->alts + ii;
		prevEnd	= iStroke - pElem->nStrokes;
		ASSERT(prevEnd >= -1);
        if (prevEnd == iStartStroke - 1) {
			// Reached start.
			fValidPath	= TRUE;
		} else if (CheckIfValid(lat, iStartStroke, prevEnd, pValidEnd)) {
			// Have path to start.
			fValidPath	= TRUE;
		}
	}

	// Did one (or more) paths reach the start?
	if (fValidPath) {
		pValidEnd[iStroke]	= LCF_VALID;
		return TRUE;
	} else {
		pValidEnd[iStroke]	= LCF_INVALID;
		return FALSE;
	}
}

void PruneLattice(LATTICE *lat, int iStartStroke, int iEndStroke)
{
	// Figure out valid character transition points by stroke.  We don't want to include
	// pieces of lattice that don't actually connect up for the full run.  This uses
	// a recursive algorithm to find valid paths.  Since it marks the paths as it
	// finds them, it can quickly test and not redo work.
	int size		= sizeof(BYTE) * (iEndStroke + 1);
    int iStroke;
	BYTE *pValidEnd	= (BYTE *)ExternAlloc(size);
	// If we failed to allocate memory, just return
	if (pValidEnd == NULL) return;

	memset(pValidEnd, LCF_UNKNOWN, size);
	CheckIfValid(lat, iStartStroke, iEndStroke, pValidEnd);

    for (iStroke = iStartStroke; iStroke <= iEndStroke; iStroke++)
    {
        if (pValidEnd[iStroke] != LCF_VALID)
        {
            lat->pAltList[iStroke].nUsed = 0;
        }
    }

    ExternFree(pValidEnd);
}

// Evaluate all the elements on the best path.  If any of them is a member of the big/small kana
// pair, and the other element of that pair is also present, then switch the best path element 
// based on the position criterion.
static void BigSmallKanaHack(LATTICE *lat)
{
	int iStroke, iAlt;
	// List of all the small characters
	static wchar_t *wszSmallKana = L"copsuvwxz\x3041\x3043\x3045\x3047\x3049\x3083\x3085\x3087\x308e\x30a1\x30a3\x30a5\x30a7\x30a9\x30e3\x30e5\x30e7\x30ee\x30f5\x30f6";
	// Corresponding list of all the big characters
	static wchar_t *wszBigKana =   L"COPSUVWXZ\x3042\x3044\x3046\x3048\x304a\x3084\x3086\x3088\x308f\x30a2\x30a4\x30a6\x30a8\x30aa\x30e4\x30e6\x30e8\x30ef\x30ab\x30b1";
	// Threshold on the fraction down from the top of the box below which 
	// we always classify as a large character.
    static float aflBigThreshold[] = {
        (float) 17.910447761194,
        (float) 17.5257731958763,
        (float) 9.33333333333333,
        (float) 12,
        (float) 14.8648648648649,
        (float) 12.1621621621622,
        (float) 13.4328358208955,
        (float) 11,
        (float) 15.2777777777778,
        (float) 16.5532879818594,
        (float) 30.1666666666667,
        (float) 17.5,
        (float) 15.6666666666667,
        (float) 33.5,
        (float) 16,
        (float) 15.4639175257732,
        (float) 15.4639175257732,
        (float) 24.6666666666667,
        (float) 21.5,
        (float) 13.4020618556701,
        (float) 10.3092783505155,
        (float) 25,
        (float) 15.4639175257732,
        (float) 17.5257731958763,
        (float) 27.536231884058,
        (float) 23.3560090702948,
        (float) 27,
        (float) 4.21052631578947,
        (float) 12.3711340206186,
    };
	// Threshold on the fraction down from the top of the box below which 
	// we always classify as a small character.
    static float aflSmallThreshold[] = {
        (float) 58.1081081081081,
        (float) 57.7319587628866,
        (float) 50.5154639175258,
        (float) 51.5463917525773,
        (float) 54.0540540540541,
        (float) 56.7164179104478,
        (float) 54.639175257732,
        (float) 54.0540540540541,
        (float) 64.8148148148148,
        (float) 50.7246376811594,
        (float) 67.0103092783505,
        (float) 50.5154639175258,
        (float) 50.7246376811594,
        (float) 52.6315789473684,
        (float) 54.1666666666667,
        (float) 51.5789473684211,
        (float) 54.639175257732,
        (float) 53.6082474226804,
        (float) 55.6701030927835,
        (float) 52.5773195876289,
        (float) 46.3917525773196,
        (float) 61.9565217391304,
        (float) 49.4845360824742,
        (float) 53.6666666666667,
        (float) 64.9484536082474,
        (float) 57.1666666666667,
        (float) 55.6701030927835,
        (float) 55.6701030927835,
        (float) 50.5154639175258,
    };
	// Sanity checks on the data tables above
	ASSERT(wcslen(wszBigKana) == wcslen(wszSmallKana));
	ASSERT(wcslen(wszBigKana) == sizeof(aflSmallThreshold) / sizeof(float));
	ASSERT(wcslen(wszBigKana) == sizeof(aflBigThreshold) / sizeof(float));
	// For each stroke
	for (iStroke = 0; iStroke < lat->nStrokes; iStroke++)
	{
		RECT rInk, rGuide;
		float flPosition;
		wchar_t *pwchBig, *pwchSmall, wch, wchOther;
		int iBestAlt = -1, iOtherAlt = -1;

		// Scan through the alt list looking for a node on the current path
		for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++)
		{
			if (lat->pAltList[iStroke].alts[iAlt].fCurrentPath) 
			{
				iBestAlt = iAlt;
				break;
			}
		}
		if (iBestAlt == -1)
		{
			continue;
		}

		// If we found one, look to see if it is in a big/small pair
		wch = LocRunDense2Unicode(&g_locRunInfo, lat->pAltList[iStroke].alts[iAlt].wChar);
		pwchBig = wcschr(wszBigKana, wch);
		pwchSmall = wcschr(wszSmallKana, wch);
		if (pwchBig == NULL && pwchSmall == NULL)
		{
			continue;
		}

		// If so, scan the alt list for another character with the same number of 
		// strokes which is the other member of the pair.
		if (pwchBig == NULL) 
		{
			wchOther = wszBigKana[pwchSmall - wszSmallKana];
		}
		else
		{
			wchOther = wszSmallKana[pwchBig - wszBigKana];
		}
		for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++)
		{
			if (lat->pAltList[iStroke].alts[iAlt].nStrokes == lat->pAltList[iStroke].alts[iBestAlt].nStrokes &&
				LocRunDense2Unicode(&g_locRunInfo, lat->pAltList[iStroke].alts[iAlt].wChar) == wchOther)
			{
				iOtherAlt = iAlt;
				break;
			}
		}
		if (iOtherAlt == -1)
		{
			continue;
		}

		// If found, then compute the position of the top of the ink in the writing box.
		rInk = lat->pAltList[iStroke].alts[iAlt].bbox;
		rGuide = GetGuideDrawnBox(&lat->guide, lat->pStroke[iStroke].iBox);
		flPosition = 100 * (float) (rInk.top - rGuide.top) / (float) max(1, rGuide.bottom - rGuide.top);
		
#if 0
		{
			FILE *f = fopen("c:/boxes.log", "a");
			fprintf(f, "top %5d start %5d end %5d bottom %5d fract %f\n", 
				rGuide.top, rInk.top, rInk.bottom, rGuide.bottom, flPosition);
			fclose(f);
		}
#endif

		// Apply the thresholds.
		if ((pwchBig != NULL && flPosition > aflSmallThreshold[pwchBig - wszBigKana]) ||
			(pwchSmall != NULL && flPosition < aflBigThreshold[pwchSmall - wszSmallKana]))
		{
			lat->pAltList[iStroke].alts[iBestAlt].fCurrentPath = FALSE;
			lat->pAltList[iStroke].alts[iOtherAlt].fCurrentPath = TRUE;
		}
	}
}

// Update the probabilities in the lattice, including setting current
// path to the most likely path so far (including language model).
// Can be called repeatedly for incremental processing after each stroke.
BOOL ProcessLattice(LATTICE *lat, BOOL fEndInput)
{
	int iStroke, iAlt, nChars;

//DebugBreak();
	ASSERT(lat!=NULL);

#if TIME_BOMB
    if (TimeBombExpired()) 
    {
        return FALSE;
    }
#endif

	lat->fEndInput = fEndInput;

	if (!fEndInput) 
	{
		lat->fIncremental = TRUE;
	}

	if (lat->nStrokes==0)
    {
        return TRUE;
    }

    if (lat->fUseFactoid) 
    {
        // Figure out which parameters we're updating
        if (lat->fCoerceMode) 
        {
            lat->recogSettings.alcValid = lat->alcFactoid;
            lat->recogSettings.pbAllowedChars = CopyAllowedChars(&g_locRunInfo, lat->pbFactoidChars);
        }
        else
        {
            lat->recogSettings.alcPriority = lat->alcFactoid;
            lat->recogSettings.pbPriorityChars = CopyAllowedChars(&g_locRunInfo, lat->pbFactoidChars);
        }
    }

	if (lat->fUseGuide) 
	{
		CreateLatticeForGuide(lat);
	} 
	else 
	{
        // We're in free mode, so create the cache
        if (lat->pvCache == NULL)
        {
            lat->pvCache = AllocateRecognizerCache();
        }
        
		// Always use probability mode for free input
		lat->fProbMode=TRUE;

        // Word mode processing
        if (lat->fWordMode)
        {
			for (iStroke = 0; iStroke < lat->nStrokes; iStroke++)
			{
				lat->pAltList[iStroke].nUsed = 0;
			}
            // Create a placeholder for the correct segmentation.
            FakeRecogResult(lat, lat->nStrokes - 1, lat->nStrokes, 0);
			BuildRecogAlts(lat, lat->nStrokes - 1, TRUE);

			if (lat->pAltList[lat->nStrokes - 1].nUsed==0) 
			{
				// Well, the recognizer came back and said there were no candidates.  
				// Let's put in a dummy alt so the user will see something, and also so
				// the language model will have a path to work with.
//					fprintf(stderr,"Lost a stroke in free mode.\n");
				FakeRecogResult(lat, lat->nStrokes - 1, lat->nStrokes, -PENALTY_SKIP_INK);
			}
            // Indicate how much processing has been done so far
    	    lat->nProcessed = lat->nStrokes;
        }
        else 
        {
		    // For each stroke in the lattice
		    for (iStroke = lat->nProcessed; iStroke < lat->nStrokes; iStroke++) 
			{
			    int maxDist=0;
			    int nChar1;
			    RECT bbox;
			    INTERVALS xIntervals, yIntervals;

			    // Wipe out the current path
			    ClearAltList(lat->pAltList + iStroke);
			    
			    bbox=lat->pStroke[iStroke].bbox;
			    EmptyIntervals(&xIntervals,bbox.left,bbox.right);
			    EmptyIntervals(&yIntervals,bbox.top,bbox.bottom);
			    // Run through all possible numbers of strokes for this 
			    // character
			    for (nChar1=1;
				     nChar1<=MaxStrokesPerCharacter && iStroke-nChar1+1>=0;
				     nChar1++) {
                    VOLCANO_WEIGHTS tuneScores;
				    // Determine the features for this proposed character
				    LATTICE_ELEMENT elem;
				    if (nChar1>1) {
					    RECT other=lat->pStroke[iStroke-nChar1+1].bbox;

					    int xdist=__max(other.left-bbox.right,bbox.left-other.right);
					    int ydist=__max(other.top-bbox.bottom,bbox.top-other.bottom);
					    int dist=__max(xdist,ydist);

					    bbox.left=__min(bbox.left,other.left);
					    bbox.right=__max(bbox.right,other.right);
					    bbox.top=__min(bbox.top,other.top);
					    bbox.bottom=__max(bbox.bottom,other.bottom);

					    dist=xdist/(bbox.right-bbox.left);
    //						dist=xdist;
					    maxDist=__max(dist,maxDist);
								    
					    ExpandIntervalsRange(&xIntervals,other.left,other.right);
					    ExpandIntervalsRange(&yIntervals,other.top,other.bottom);
					    RemoveInterval(&xIntervals,other.left,other.right);
					    RemoveInterval(&yIntervals,other.top,other.bottom);
				    }
				    elem.fUsed=TRUE;
				    elem.fCurrentPath=FALSE;
				    elem.nStrokes=nChar1;
				    elem.nPrevStrokes=0;
				    elem.wChar=SYM_UNKNOWN;
				    elem.wPrevChar=0;
				    elem.bbox=bbox;
				    ASSERT(bbox.top<=bbox.bottom);
				    ASSERT(bbox.left<=bbox.right);
				    elem.iPrevAlt=-1;
				    elem.area=TotalRange(&xIntervals)+TotalRange(&yIntervals);
				    elem.space=TotalPresent(&xIntervals)+TotalPresent(&yIntervals);
				    elem.maxDist=maxDist;
				    // If this is the first character in the lattice, use single
				    // character statistics
				    if (iStroke-nChar1+1==0) {
                        BOOL fSegOkay = FALSE;
                        VTuneZeroWeights(&tuneScores);
					    fSegOkay = CheapUnaryProb(nChar1,bbox,elem.space,elem.area, &tuneScores);
                        // If we're not in separator mode, then prune based on the 
                        // segmentation score
                        if (!lat->fSepMode && !fSegOkay) 
                        {
                            continue;
                        }
					    // Equalize probs across different numbers of strokes
                        elem.logProb = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, &tuneScores);
					    elem.logProbPath = elem.logProb;
					    elem.iPathLength = 1;
					    InsertElement(lat,iStroke,&elem);
				    } else {
					    // Otherwise go through all the previous characters in the
					    // lattice as alternates.
					    BOOL first=TRUE;
					    for (iAlt=0; iAlt<lat->pAltList[iStroke-nChar1].nUsed; iAlt++) {
						    LATTICE_ELEMENT *prevElem=&lat->pAltList[iStroke-nChar1].alts[iAlt];
						    float prob, probPath;
                            BOOL fSegOkay;
                            // Only disallow overlapping boxes in normal recognition mode
                            if (!lat->fSepMode && IsOverlappedPath(lat,iStroke-nChar1,iAlt,bbox)) {
							    continue;
                            }
                            VTuneZeroWeights(&tuneScores);
						    fSegOkay = CheapBinaryProb(nChar1,bbox,elem.space,elem.area,
											    prevElem->nStrokes,prevElem->bbox,prevElem->space,prevElem->area,
                                                &tuneScores);
                            // If we're not in separator mode, then prune based on the 
                            // segmentation score
                            if (!lat->fSepMode && !fSegOkay) 
                            {
                                continue;
                            }

                            // In separator mode, just add a penalty for overlapping boxes
                            if (lat->fSepMode && IsOverlappedPath(lat,iStroke-nChar1,iAlt,bbox)) 
                            {
                                tuneScores.afl[VTUNE_FREE_SEG_BIGRAM] += -PENALTY_OVERLAP_CHAR;
                            }
                            prob = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, &tuneScores);
						    // Equalize probs across different numbers of strokes
						    probPath = (prob + prevElem->logProbPath * prevElem->iPathLength) / (prevElem->iPathLength + 1);
						    if (first || probPath > elem.logProbPath)
                            {
							    first=FALSE;
							    elem.iPathLength = prevElem->iPathLength + 1;
							    elem.logProb=prob;
							    elem.logProbPath=probPath;
							    elem.nPrevStrokes=prevElem->nStrokes;
							    elem.iPrevAlt=iAlt;
						    }
					    }
                        if (!first)
                        {
                            InsertElement(lat,iStroke,&elem);
                        }
				    }
			    }
			    if (lat->pAltList[iStroke].nUsed==0) 
				{
				    // Well, the pre-segmentation came back and said there were no candidates.  
				    // Let's put in a dummy alt so the pruning will still have a connected lattice
                    // to work with.
//					fprintf(stderr,"Lost a stroke in free mode.\n");
				    FakeRecogResult(lat, iStroke, 1, -PENALTY_SKIP_INK);
			    }
		    }

            PruneLattice(lat, 0, lat->nStrokes - 1);

		    // For each unprocessed stroke in the lattice
		    for (iStroke = 0; iStroke < lat->nStrokes; iStroke++) 
			{
				if (iStroke >= lat->nProcessed)
				{
					BuildRecogAlts(lat, iStroke, TRUE);
				}
			    if (lat->pAltList[iStroke].nUsed==0) 
				{
				    // Well, the recognizer came back and said there were no candidates.  
				    // Let's put in a dummy alt so the user will see something, and also so
				    // the language model will have a path to work with.
//					fprintf(stderr,"Lost a stroke in free mode.\n");
				    FakeRecogResult(lat, iStroke, 1, -PENALTY_SKIP_INK);
			    }
				ASSERT(lat->pAltList[iStroke].nUsed>0);
            }
			// Mark this stroke as processed so we don't redo work.
			lat->nProcessed = lat->nStrokes;
		}

		// Mark the best path so far, and count how many characters it has
		nChars = FindFullPath(lat);

		// If we're at the end of the input
		if (lat->fEndInput) 
		{
            int cContext = 0;
			// If there are enough, use IFELang3
#ifdef USE_IFELANG3
            if (lat->wszBefore != NULL)
                cContext += wcslen(lat->wszBefore);

            if (lat->wszAfter != NULL)
                cContext += wcslen(lat->wszAfter);

			if (nChars + cContext >= MIN_CHARS_FOR_IFELANG3 && LatticeIFELang3Available()) 
			{
				lat->fUseIFELang3=TRUE; 
			}
			else
			{
				lat->fUseIFELang3=FALSE;
			}
#else
			lat->fUseIFELang3 = FALSE;
#endif
            // Until we can get it tuned correctly, force IFELang3 off for free mode.
            lat->fUseIFELang3 = FALSE;
		}
	}

	// Hack for big and small kana characters
	if (lat->fUseGuide)
	{
		BigSmallKanaHack(lat);
	}

    return TRUE;
}

#ifdef DUMP_LATTICE

#include <stdio.h>

#ifdef DUMP_LATTICE_TO_DOTTY

void DumpLatticeElement(FILE *f, LATTICE *lat, int iStroke, int iAlt)
{
	LATTICE_ELEMENT *elem=&(lat->pAltList[iStroke].alts[iAlt]);
	if (elem->fUsed) 
    {
        wchar_t wch = elem->wChar == SYM_UNKNOWN ? SYM_UNKNOWN : LocRunDense2Unicode(&g_locRunInfo, elem->wChar);
        wchar_t wchPrev = elem->wPrevChar == SYM_UNKNOWN ? SYM_UNKNOWN : LocRunDense2Unicode(&g_locRunInfo, elem->wPrevChar);
        int nPrevStrokes = elem->iPrevAlt == -1 ? 0 : lat->pAltList[iStroke - elem->nStrokes].alts[elem->iPrevAlt].nStrokes;

        if (0 && wch == 0) 
        {
            char *color=",color=green,fontcolor=green,weight=2";
		    if (elem->fCurrentPath) 
            {
			    color=",color=red,fontcolor=red,weight=2";
		}
		fprintf(f,
			    "\"%d\" -> \"%d\" [ label = \"DUMMY (prev U+%04X/%d)\\npr=%.2f,pp=%.2f\"%s ];\n",
			iStroke-elem->nStrokes,iStroke,
                wchPrev, nPrevStrokes,
			elem->logProb,
			elem->logProbPath,
			    color);
        }
        else 
        {
            char *color=",color=gray,fontcolor=gray,weight=2";
		    if (elem->fCurrentPath) 
            {
			    color=",color=black,fontcolor=black,weight=2";
		    }
		    fprintf(f,
			        "\"%d\" -> \"%d\" [ label = \"U+%04X (prev U+%04X/%d)\\nfr=%.2f,ch=%.2f\\nsh1=%.2f,sh2=%.2f\\nun1=%.2f,un2=%.2f\\nbi=%.2f,cb=%.2f\\npr=%.2f,pp=%.2f\"%s ];\n",
	    		    iStroke-elem->nStrokes,iStroke,
                    wch, wchPrev, nPrevStrokes,
                    (elem->tuneScores.afl[VTUNE_FREE_SEG_UNIGRAM] + elem->tuneScores.afl[VTUNE_FREE_SEG_BIGRAM]) 
                        * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_PROB] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_SHAPE_UNIGRAM] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_SHAPE_BIGRAM] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_UNIGRAM] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_SMOOTHING_UNIGRAM] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_BIGRAM] * elem->iPathLength,
                    elem->tuneScores.afl[VTUNE_FREE_CLASS_BIGRAM] * elem->iPathLength,
			        elem->logProb,
			        elem->logProbPath * elem->iPathLength,
		        	color);
    	}
    }
}

void DumpLattice(char *filename, LATTICE *lat)
{
    if (lat->fSepMode) 
    {
	    int iStroke, iAlt, i;
	FILE *f;
	ASSERT(filename!=NULL);
	ASSERT(lat!=NULL);
	f=fopen(filename,"w");
	    if (f == NULL) 
        {
		fprintf(stderr,"Couldn't open '%s' to dump the lattice.",filename);
		return;
	}
	    fprintf(f, "digraph lattice {\n");

        // Dump out the answer
        for (i = 0; i < (int)wcslen(lat->wszAnswer); i++) 
        {
            if (i > 0)
            {
                fprintf(f, " -> ");
            }
            fprintf(f, "\"U+%04X\"", lat->wszAnswer[i]);
        }
        fprintf(f, "\n");

        // This produces a timeline
        fprintf(f, "\"Stroke -1\"");
        for (iStroke = 0; iStroke < lat->nStrokes; iStroke++) 
        {
            fprintf(f, " -> \"Stroke %d\"", iStroke);
        }
        fprintf(f, "\n");

        // This forces the nodes to be shown in time order
        for (iStroke = -1; iStroke < lat->nStrokes; iStroke++) 
        {
            fprintf(f, "{rank=same; \"%d\"; \"Stroke %d\";}\n", iStroke, iStroke);
            if (iStroke >= 0) 
            {
                fprintf(f, "\"Stroke %d\" [ label=\"%d-%d\" ];\n",
                    iStroke, lat->pStroke[iStroke].iOrder, lat->pStroke[iStroke].iLast);
            }
        }

        // This produces the actual lattice
        for (iStroke = lat->nStrokes - 1; iStroke >= 0; iStroke--) 
        {
		    for (iAlt = 0; iAlt < lat->pAltList[iStroke].nUsed; iAlt++) 
            {
			DumpLatticeElement(f,lat,iStroke,iAlt);
		}
	}

	fprintf(f,"}\n");

	fclose(f);
}
}

#else

void DumpLatticeElement(FILE *f, LATTICE *lat, int iStroke, int iAlt)
{
	LATTICE_ELEMENT *elem=&(lat->pAltList[iStroke].alts[iAlt]);
	if (elem->fUsed) {
		fprintf(f,"Stroke %d alternate %d",iStroke,iAlt);
		if (elem->fCurrentPath) fprintf(f," on current path\n"); else fprintf(f,"\n");
		fprintf(f,"  nStrokes    =%2d  wChar    =U+%04X  score=%g\n",elem->nStrokes,LocRunDense2Unicode(&g_locRunInfo,elem->wChar),elem->score);
		fprintf(f,"  nPrevStrokes=%2d  wPrevChar=U+%04X\n",elem->nPrevStrokes,LocRunDense2Unicode(&g_locRunInfo,elem->wPrevChar));
		fprintf(f,"  prob=%g   probpath=%g\n",elem->logProb,elem->logProbPath);
		fprintf(f,"  iPrevAlt=%d\n",elem->iPrevAlt);
		fprintf(f,"  bbox xrange=%d-%d, yrange=%d-%d\n",elem->bbox.left,elem->bbox.right,elem->bbox.top,elem->bbox.bottom);
		fprintf(f,"  space=%d  area=%d\n",elem->space,elem->area);
	}
}

void DumpLattice(char *filename, LATTICE *lat)
{
	int iStroke, iAlt;
	FILE *f;
	ASSERT(filename!=NULL);
	ASSERT(lat!=NULL);
	f=fopen(filename,"w");
	if (f==NULL) {
		fprintf(stderr,"Couldn't open '%s' to dump the lattice.",filename);
		return;
	}
	for (iStroke=lat->nStrokes-1; iStroke>=0; iStroke--) {
		for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++) {
			DumpLatticeElement(f,lat,iStroke,iAlt);
			fprintf(f,"\n");
		}
		fprintf(f,"\n");
	}
	fclose(f);
}

#endif

#endif

// Return the current path.
// When called after ProcessLattice, returns the highest probability path.
// The memory for the path should be freed by the caller.
BOOL GetCurrentPath(LATTICE *lat, LATTICE_PATH **pPath)
{
	int				nChars, iStroke, iChar, iAlt, iTestStroke=-1;
	LATTICE_PATH	*path;
	RECT			rectBox, rectPrevBox;
	BOOL			bSpaceEnabled;

	// currently spaces are only enabled in korean free mode
	if (!lat->fUseGuide && !lat->fSepMode && !wcsicmp (g_szRecognizerLanguage, L"KOR"))
	{
		bSpaceEnabled	=	TRUE;
	}
	else
	{
		bSpaceEnabled	=	FALSE;
	}

	ASSERT(lat!=NULL);
#ifdef DUMP_LATTICE
	DumpLattice(LATTICE_FILENAME,lat);
#endif
#ifdef DUMP_BBOXES
	{
		FILE *f = fopen("e:/bbox.txt", "w");
		fprintf(f, "canvas .c -width 1000 -height 1000;\n");
		fprintf(f, "pack .c;\n");
		fclose(f);
	}
#endif

	nChars	=	0;
	for (iStroke=0; iStroke<lat->nStrokes; iStroke++)
	{
		// Wipe out all spaces so far
		lat->pAltList[iStroke].fSpaceAfterStroke = FALSE;

		for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++)
		{
			if (lat->pAltList[iStroke].alts[iAlt].fCurrentPath) 
			{
				nChars++;

				// Make sure this element of the path connects up to the previous one.
				ASSERT(iStroke - lat->pAltList[iStroke].alts[iAlt].nStrokes == iTestStroke);
				iTestStroke = iStroke;
			}
		}
	}

	// we'll allocate memory for 2 * nChars in anticipation of spaces between chars
	path=AllocatePath(2 * nChars);
	if (path==NULL) 
	{
		return FALSE;
	}

	iChar		=	0;

	for (iStroke=0; iStroke<lat->nStrokes; iStroke++)
	{
		for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++)
		{
			if (lat->pAltList[iStroke].alts[iAlt].fCurrentPath) 
			{
				wchar_t		dch;

				// are spaces enabled
				if (bSpaceEnabled)
				{
					// do we have a space before us
					rectBox	=	lat->pAltList[iStroke].alts[iAlt].bbox;

					// we can only have a space before us if we are not the 1st char
					if (iChar > 0)
					{
						int	xDel;
						int	iAvgHgt;

						xDel	=	rectBox.left - rectPrevBox.right;
						iAvgHgt	=	1 + (	(rectBox.right - rectBox.left) + 
											(rectPrevBox.right - rectPrevBox.left)
										) / 2;

						if	(	xDel >= ((int)(iAvgHgt * SPACE_RATIO)) ||
								rectBox.right < rectPrevBox.left
							)
						{
							// create a phantom path element
							path->pElem[iChar].iBoxNum	=	-1;
							path->pElem[iChar].iStroke	=	iStroke - lat->pAltList[iStroke].alts[iAlt].nStrokes;
							path->pElem[iChar].nStrokes	=	0;
							path->pElem[iChar].iAlt		=	SPACE_ALT_ID;
							path->pElem[iChar].wChar	=	SYM_SPACE;

							// mark the location of the space in the lattice
							lat->pAltList[path->pElem[iChar].iStroke].fSpaceAfterStroke = TRUE;

							iChar++;
						}
					}
				    // save the rectangle of the current char
				    rectPrevBox	=	rectBox;
				}
				
				dch	= lat->pAltList[iStroke].alts[iAlt].wChar;

				if (dch==SYM_UNKNOWN) 
				{
                    // In separator mode, we need to return a special symbol for the 
                    // skipped ink cases.
                    path->pElem[iChar].wChar = SYM_UNKNOWN;
				} 
				else 
				{
					ASSERT(LocRunIsDenseCode(&g_locRunInfo, dch));
					path->pElem[iChar].wChar = LocRunDense2Unicode(&g_locRunInfo,dch);
				}

				path->pElem[iChar].nStrokes = lat->pAltList[iStroke].alts[iAlt].nStrokes;
				path->pElem[iChar].iBoxNum = lat->pStroke[iStroke].iBox;
				path->pElem[iChar].iStroke = iStroke;
				path->pElem[iChar].iAlt = iAlt;
//				path->pElem[iChar].scores = lat->pAltList[iStroke].alts[iAlt].score;
//				path->pElem[iChar].bbox=lat->pAltList[iStroke].alts[iAlt].bbox;

#ifdef DUMP_BBOXES
				{
					int i;
					RECT r = lat->pAltList[iStroke].alts[iAlt].writingBox;
					double s = 1.0 / 100.0;
					FILE *f = fopen("e:/bbox.txt","a");
					fprintf(f, ".c create rect %f %f %f %f -outline black -fill {};\n",
						r.left * s, r.top * s, r.right * s, r.bottom * s);
					for (i = iStroke - lat->pAltList[iStroke].alts[iAlt].nStrokes + 1; i <= iStroke; i++)
					{
						int j;
						fprintf(f, ".c create line");
						for (j = 0; j < lat->pStroke[i].nInk; j++) 
						{
							fprintf(f, " %f %f", 
								lat->pStroke[i].pts[j].x * s,
								lat->pStroke[i].pts[j].y * s);
						}
						fprintf(f, " -fill red\n");
					}
					fclose(f);
				}
#endif
				
				iChar++;
			}
		}
	}

	path->nChars	=	iChar;

	*pPath=path;
	return TRUE;
}

// Given a lattice and a path through it, for characters iStartChar (inclusive) through iEndChar
// (exclusive), return the time stamps of the first and last strokes in those characters.
// Returns FALSE if there are no strokes associated with the characters (eg, spaces)
BOOL GetCharacterTimeRange(LATTICE *lat, LATTICE_PATH *path, int iStartChar, int iEndChar,
						   DWORD *piStartTime, DWORD *piEndTime)
{
	int iStartStroke=-1, iEndStroke=-1;
	ASSERT(lat!=NULL);
	ASSERT(path!=NULL);
	ASSERT(iStartChar>=0 && iStartChar<path->nChars);
	ASSERT(iEndChar>iStartChar && iEndChar<=path->nChars);
    while (iStartChar < path->nChars && path->pElem[iStartChar].iAlt == SPACE_ALT_ID) 
    {
        iStartChar++;
    }
    while (iEndChar > 0 && path->pElem[iEndChar - 1].iAlt == SPACE_ALT_ID)
    {
        iEndChar--;
    }
    if (iStartChar >= iEndChar)
    {
        return FALSE;
    }
	iStartStroke=path->pElem[iStartChar].iStroke - path->pElem[iStartChar].nStrokes + 1;
	iEndStroke=path->pElem[iEndChar-1].iStroke;
	ASSERT(iStartStroke>=0);
	ASSERT(iEndStroke>=0);
	ASSERT(iStartStroke<lat->nStrokes);
	ASSERT(iEndStroke<lat->nStrokes);
	*piStartTime=lat->pStroke[iStartStroke].timeStart;
	*piEndTime=lat->pStroke[iEndStroke].timeEnd;
    return TRUE;
}

// Get the number of strokes which have been added to the lattice.
int GetLatticeStrokeCount(LATTICE *lat)
{
	ASSERT(lat!=NULL);
	return lat->nStrokes;
}

// Given a character in the current path, determine a "guide box" around that character.
BOOL GetBoxOfAlternateInCurrentPath(LATTICE *lat, LATTICE_PATH *path, int iChar, RECT *pRect)
{
	int iStroke = path->pElem[iChar].iStroke;
	int iAlt = path->pElem[iChar].iAlt;

	// Get the inferred writing box, using either centipede or the old baseline/height database.
	RECT writingBox = lat->pAltList[iStroke].alts[iAlt].writingBox;

	// Adjust the writing box so the top is the midline:
	writingBox.top = (writingBox.top + writingBox.bottom + 1) / 2;

	// Make sure the box isn't zero or negative sized:
	if (writingBox.bottom <= writingBox.top)
		writingBox.bottom = writingBox.top + 1;
	if (writingBox.right <= writingBox.left)
		writingBox.right = writingBox.left + 1;

	*pRect = writingBox;
	return TRUE;
}

// Look at the lattice column containing the given character, and find alternates with the same number
// of strokes.  The alternates are returned in the given array, and the number of alternates found is
// returned.
int GetAlternatesForCharacterInCurrentPath(LATTICE *lat, LATTICE_PATH *path, int iChar, int nAlts, wchar_t *pwAlts)
{
	int iStroke = path->pElem[iChar].iStroke;
	int nStrokesInChar = path->pElem[iChar].nStrokes;
	int cAlts = 0, iAlt;
	ASSERT(lat!=NULL);
	ASSERT(lat->nStrokes>0);
	ASSERT(path!=NULL);

	// if this is a space char, then we will produce a single entry alt list
	if (path->pElem[iChar].iAlt == SPACE_ALT_ID)
	{
		pwAlts[0]	=	path->pElem[iChar].wChar;
		return 1;
	}

	// Run through the list of alternates, and find those with 
	// the same number of strokes
	for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++) 
	{
		if (lat->pAltList[iStroke].alts[iAlt].nStrokes==nStrokesInChar) 
		{
			int i;
			BOOL found=FALSE;
			for (i=0; i<cAlts; i++) 
			{
				if (pwAlts[i]==lat->pAltList[iStroke].alts[iAlt].wChar)
				{
					found=TRUE;
				}
			}

			if (!found) 
			{
				pwAlts[cAlts++]=lat->pAltList[iStroke].alts[iAlt].wChar;
				if (cAlts==nAlts)
				{
					goto breakLoop;
				}
			}
		}
	} 

breakLoop:

	// Now convert the dense codes to Unicode.
	for (iAlt = 0; iAlt < cAlts; ++iAlt) 
	{
		// We need to return a special symbol
        // for the skipped ink case.
		if (pwAlts[iAlt] != SYM_UNKNOWN) 
		{
			ASSERT(LocRunIsDenseCode(&g_locRunInfo, pwAlts[iAlt]));
			pwAlts[iAlt] = LocRunDense2Unicode(&g_locRunInfo, pwAlts[iAlt]);
		}
	}

	return cAlts;
}

void FreeLatticePath(LATTICE_PATH *path)
{
	ASSERT(path!=NULL);
	if (path->pElem!=NULL) ExternFree(path->pElem);
	ExternFree(path);
}

// Structure used to hold information for the DTW.  
typedef struct tagDTW {
	float logProb;              // Score for this location in the table
	int nSubstitutions;			// How many character substitutions occurred along this path
	int iAlt;                   // Alt list entry in the lattice for this table entry
	int iPrevChar, iPrevStroke; // Prev character and score for trace back
} DTW;

// Given a lattice and a string of unicode characters, find the best path through the lattice 
// which gives that sequence of characters.  Baring that, it will find the most likely path
// through the lattice with the same number of characters and the minimum number of mismatches
// to the prompt.  In case no such path can be found, the current path becomes empty.  
// The function returns the number of substitutions used, or -1 if there is no path with
// the desired number of characters, -2 if a memory allocation error occurs, or -3 if a 
// file write error occurs.
int SearchForTargetResultInternal(LATTICE *lat, wchar_t *wszTarget)
{
	wchar_t *wsz;
	int i, j;
	int iAlt, iStroke, iChar, nSubs = -1;
	DTW *pTable, *dtw;

	ASSERT(lat!=NULL);
	ASSERT(wszTarget!=NULL);
	
	if (wcslen(wszTarget)==0 || lat->nStrokes == 0)
    {
        return -1;
    }

//	fprintf(stderr,"Beginning SearchForTargetResult\n");

	// Allocate the string
	wsz = (wchar_t*)ExternAlloc((wcslen(wszTarget)+1)*sizeof(wchar_t));
	if (wsz==NULL) return -2;
	// Get rid of unwanted characters (spaces)
	j=0;
	for (i = 0; i <= (int)wcslen(wszTarget); i++) 
		if (wszTarget[i]==0 || !iswspace(wszTarget[i]))
			wsz[j++] = wszTarget[i];

    if (wcslen(wsz) == 0) 
    {
        ExternFree(wsz);
        return -1;
    }

	// Allocate the DTW table
	pTable=(DTW*)ExternAlloc(sizeof(DTW)*lat->nStrokes*wcslen(wsz));
	if (pTable==NULL) {
		ExternFree(wsz);
		return -2;
	}

	// For each table entry, find the best path to get there
	for (iStroke=0; iStroke<lat->nStrokes; iStroke++) {
		for (iChar=0; iChar<(int)wcslen(wsz); iChar++) {
			// Convert the character we're looking for to a dense code
			SYM dense=LocRunUnicode2Dense(&g_locRunInfo,wsz[iChar]);

			// To record the best value for this table entry
			BOOL first=TRUE;
			int bestAlt=-1;
			float bestLogProb=0;
			int bestNSubstitutions=0;
			int bestPrevChar=-1, bestPrevStroke=-1;

			// Run through the alternates at this stroke, and see if anything matches
			for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++) {
				float prevLogProb=0;
				int prevNSubstitutions=0;
				// Get the information about the best path leading to this alternate
				int iPrevChar=iChar-1;
				int iPrevStroke=iStroke-lat->pAltList[iStroke].alts[iAlt].nStrokes;
				// Make sure the first character starts at the first stroke.
				if (iPrevChar==-1 && iPrevStroke!=-1) continue;
				if (iPrevStroke==-1 && iPrevChar!=-1) continue;
//				if (iPrevStroke>=0 && iPrevChar==-1) prevLogProb=(float)iPrevStroke+1;
//				if (iPrevStroke==-1 && iPrevChar>=0) prevLogProb=(float)iPrevChar+1;
				// Check the previous best path
				if (iPrevStroke>=0 && iPrevChar>=0) {
					// If there wasn't a path, then skip this alternative
					if (pTable[iPrevChar*lat->nStrokes+iPrevStroke].iAlt==-1) continue;
					prevLogProb=pTable[iPrevChar*lat->nStrokes+iPrevStroke].logProb;
					prevNSubstitutions=pTable[iPrevChar*lat->nStrokes+iPrevStroke].nSubstitutions;
				}
				// If the alternate matches, then record it without increasing the number of substitutions
				if (lat->pAltList[iStroke].alts[iAlt].wChar==dense) {
					float thisLogProb=prevLogProb;
					int thisNSubstitutions=prevNSubstitutions;
					if (first || thisNSubstitutions<bestNSubstitutions || (thisNSubstitutions==bestNSubstitutions && thisLogProb>bestLogProb)) {
						bestAlt=iAlt;
						bestLogProb=thisLogProb;
						bestPrevStroke=iPrevStroke;
						bestPrevChar=iPrevChar;
						bestNSubstitutions=thisNSubstitutions;
						first=FALSE;
					}
				} else {
					// Otherwise it is a substitution, so record as such
					float thisLogProb=/*lat->pAltList[iStroke].alts[iAlt].nStrokes*/prevLogProb;
					int thisNSubstitutions=prevNSubstitutions+1;
					if (first || thisNSubstitutions<bestNSubstitutions || (thisNSubstitutions==bestNSubstitutions && thisLogProb>bestLogProb)) {
						bestAlt=iAlt;
						bestLogProb=thisLogProb;
						bestPrevStroke=iPrevStroke;
						bestPrevChar=iPrevChar;
						bestNSubstitutions=thisNSubstitutions;
						first=FALSE;
					}
				}
				// skip ink
/*				prevLogProb=(float)lat->pAltList[iStroke].alts[iAlt].nStrokes;
				if (iPrevStroke>=0) prevLogProb+=pTable[iChar*lat->nStrokes+iPrevStroke].logProb;
				if (first || prevLogProb<bestLogProb) {
					bestAlt=-1;
					bestLogProb=prevLogProb;
					bestPrevStroke=iPrevStroke;
					bestPrevChar=iChar;
					first=FALSE;
				} */
			}
			// skip char
/*			prevLogProb=1;
			if (iPrevChar>=0) prevLogProb+=pTable[iPrevChar*lat->nStrokes+iStroke].logProb;
			if (first || prevLogProb<bestLogProb) {
				bestAlt=-1;
				bestLogProb=prevLogProb;
				bestPrevStroke=iStroke;
				bestPrevChar=iPrevChar;
				first=FALSE;
			} */

			// Record the best path
			pTable[iChar*lat->nStrokes+iStroke].logProb=bestLogProb;
			pTable[iChar*lat->nStrokes+iStroke].iAlt=bestAlt;
			pTable[iChar*lat->nStrokes+iStroke].iPrevStroke=bestPrevStroke;
			pTable[iChar*lat->nStrokes+iStroke].iPrevChar=bestPrevChar;
			pTable[iChar*lat->nStrokes+iStroke].nSubstitutions=bestNSubstitutions;
		}
	}

	// Dump out some debugging information about which characters were matched.
#ifdef DUMP_DTW
	{
		int iChar, iStroke;
		FILE *f=fopen("/dtw.txt","w");
		iStroke = lat->nStrokes-1;
		iChar = wcslen(wsz)-1;
		// Go back through the DTW lattice to mark the matched path
		while (iStroke!=-1 && iChar!=-1) {
			DTW *dtw=pTable+(iChar*lat->nStrokes+iStroke);
			if (dtw->iAlt!=-1) {
				fprintf(f,"Character %d (U+%04X) found at iStroke=%d iAlt=%d\n",
					iChar,wsz[iChar],iStroke,dtw->iAlt);
			} else {
				fprintf(f,"Character %d (U+%04X) not found (iAlt=%d)\n",
					iChar,wsz[iChar],dtw->iAlt);
			}
			iStroke=dtw->iPrevStroke;
			iChar=dtw->iPrevChar;
		}
		fclose(f);
	}
#endif
	
	// Go back through the DTW lattice to mark the best matched path
	iStroke = lat->nStrokes-1;
	iChar = wcslen(wsz)-1;
	dtw=pTable+(iChar*lat->nStrokes+iStroke);
	if (dtw->iAlt==-1) {
		// If we didn't find any path all the way through, don't return any path.
		nSubs=-1;
	} else {
#ifdef HWX_TUNE
		if (g_pTuneFile == NULL || g_iTuneMode == 3)
#endif
		{
			// Wipe out the old path
			for (iStroke=0; iStroke<lat->nStrokes; iStroke++) 
				for (iAlt=0; iAlt<lat->pAltList[iStroke].nUsed; iAlt++)
					lat->pAltList[iStroke].alts[iAlt].fCurrentPath=FALSE;
		}

		// Get the first step in the path
		iStroke = lat->nStrokes-1;
		iChar = wcslen(wsz)-1;
		dtw=pTable+(iChar*lat->nStrokes+iStroke);
		nSubs=dtw->nSubstitutions;
		while (iStroke!=-1 && iChar!=-1) {
			dtw = pTable + (iChar * lat->nStrokes + iStroke);
			if (dtw->iAlt!=-1) {
#ifdef HWX_TUNE
				if (g_pTuneFile == NULL || g_iTuneMode == 3) 
#endif
				{
					// If there was a path to this point, mark the alternate
					lat->pAltList[iStroke].alts[dtw->iAlt].fCurrentPath=TRUE;
				}
#ifdef HWX_TUNE
				// If there was an correct path up to this point, then dump it out along
				// with the wrong alternates.
				if (g_pTuneFile != NULL && g_iTuneMode != 3) 
                {
					if (lat->fUseGuide || dtw->nSubstitutions == 0) 
                    {
						wchar_t dchCorrect = LocRunUnicode2Dense(&g_locRunInfo, wsz[iChar]);
                        INT idch = dchCorrect;
                        INT iCorrect = -1;
						int iAlt;
						BOOL okay;
						INT nAlts = lat->pAltList[iStroke].nUsed;

						for (iAlt = 0; iAlt < nAlts; iAlt++) 
                        {
							LATTICE_ELEMENT *elem = lat->pAltList[iStroke].alts + iAlt;
							if (elem->wChar == dchCorrect)
                            {
                                iCorrect = iAlt;
                            }
                        }

						// Write out the correct answer
						okay = (fwrite(&idch, sizeof(INT), 1, g_pTuneFile) == 1);

                        // Write out the index of the correct alternate
						okay = okay && (fwrite(&iCorrect, sizeof(INT), 1, g_pTuneFile) == 1);
						
						// Write out the number of alternates
						okay = okay && (fwrite(&nAlts, sizeof(INT), 1, g_pTuneFile) == 1);

						// Write out the alternates
						for (iAlt = 0; iAlt < nAlts; iAlt++) 
                        {
							LATTICE_ELEMENT *elem = lat->pAltList[iStroke].alts + iAlt;
//							int iTem = (iAlt == dtw->iAlt);
//							int iTem = (elem->wChar == dchCorrect);
//							okay = okay && (fwrite(&iTem, sizeof(int), 1, g_pTuneFile) == 1);
//							okay = okay && (fwrite(&elem->logProbPath, sizeof(FLOAT), 1, g_pTuneFile) == 1);
//							okay = okay && (fwrite(&elem->tuneScores, sizeof(VOLCANO_WEIGHTS), 1, g_pTuneFile) == 1);
                            if (g_iTuneMode == 1) 
                            {
                                okay = okay && VTuneCompressTuningRecord(g_pTuneFile, &elem->tuneScores);
                            }
                            if (g_iTuneMode == 2)
                            {
                                okay = okay && (fwrite(&elem->logProb, sizeof(FLOAT), 1, g_pTuneFile) == 1);
                            }
						}

						if (!okay) 
                        {
							ExternFree(wsz);
							ExternFree(pTable);
							return -3;
						}
					}
				}
#endif
			}
			iStroke=dtw->iPrevStroke;
			iChar=dtw->iPrevChar;
		}
	}

	ExternFree(wsz);
	ExternFree(pTable);

	return nSubs;
}

// Configuration info
VOLCANO_CONFIG g_latticeConfigInfo;

// Initialize the lattice configuration to default values.
// These defaults may in the future depend on the language
// that is loaded.
void LatticeConfigInit()
{
	int i;

	// Also go through the stroke counts setting no recognizer.
    for (i = 0; i <= VOLCANO_CONFIG_MAX_STROKE_COUNT; i++) {
        if (i == 0 || i > GLYPH_CFRAMEMAX) {
            g_latticeConfigInfo.iRecognizers[i] = VOLCANO_CONFIG_ZILLA;
        } else {
            g_latticeConfigInfo.iRecognizers[i] = VOLCANO_CONFIG_OTTER;
        }
    }
}

// Update the probabilities in the lattice, including setting current
// path to the most likely path so far (including language model).
BOOL ProcessLatticeRange (LATTICE *lat, int iStrtStroke, int iEndStroke)
{
	int iStroke, iAlt;
	
	ASSERT(lat!=NULL);

	// invalid stroke range
	if (iStrtStroke < 0 || iEndStroke >= lat->nStrokes || iStrtStroke > iEndStroke)
    {
        return FALSE;
    }

	// can only be called in panel free mode
	if (lat->fUseGuide || lat->fWordMode || lat->fSepMode) 
	{
		return FALSE;
	} 

	// Always use probability mode for free input
	lat->fProbMode=TRUE;

	// For each stroke within the range
	for (iStroke = iStrtStroke; iStroke <= iEndStroke; iStroke++) 
	{
		int			maxDist = 0;
		int			nChar1;
		RECT		bbox;
		INTERVALS	xIntervals, yIntervals;

		// Wipe out the current path
		ClearAltList(lat->pAltList + iStroke);
		
		bbox = lat->pStroke[iStroke].bbox;

		EmptyIntervals(&xIntervals,bbox.left,bbox.right);
		EmptyIntervals(&yIntervals,bbox.top,bbox.bottom);

		// Run through all possible numbers of strokes for this 
		// character
		for (nChar1=1; nChar1<=MaxStrokesPerCharacter && iStroke-nChar1+1>=iStrtStroke; nChar1++) 
		{
            VOLCANO_WEIGHTS tuneScores;

			// Determine the features for this proposed character
			LATTICE_ELEMENT elem;

			if (nChar1>1) 
			{
				RECT other=lat->pStroke[iStroke-nChar1+1].bbox;

				int xdist=__max(other.left-bbox.right,bbox.left-other.right);
				int ydist=__max(other.top-bbox.bottom,bbox.top-other.bottom);
				int dist=__max(xdist,ydist);

				bbox.left=__min(bbox.left,other.left);
				bbox.right=__max(bbox.right,other.right);
				bbox.top=__min(bbox.top,other.top);
				bbox.bottom=__max(bbox.bottom,other.bottom);

				dist=xdist/(bbox.right-bbox.left);
				maxDist=__max(dist,maxDist);
							
				ExpandIntervalsRange(&xIntervals,other.left,other.right);
				ExpandIntervalsRange(&yIntervals,other.top,other.bottom);
				RemoveInterval(&xIntervals,other.left,other.right);
				RemoveInterval(&yIntervals,other.top,other.bottom);
			}

			elem.fUsed=TRUE;
			elem.fCurrentPath=FALSE;
			elem.nStrokes=nChar1;
			elem.nPrevStrokes=0;
			elem.wChar=SYM_UNKNOWN;
			elem.wPrevChar=0;
			elem.bbox=bbox;

			ASSERT(bbox.top<=bbox.bottom);
			ASSERT(bbox.left<=bbox.right);

			elem.iPrevAlt=-1;
			elem.area=TotalRange(&xIntervals)+TotalRange(&yIntervals);
			elem.space=TotalPresent(&xIntervals)+TotalPresent(&yIntervals);
			elem.maxDist=maxDist;

			// If this is the first character in the lattice, use single
			// character statistics
			if (iStroke-nChar1+1==0) 
			{
                VTuneZeroWeights(&tuneScores);
				
				CheapUnaryProb(nChar1,bbox,elem.space,elem.area, &tuneScores);
				
				// Equalize probs across different numbers of strokes
                elem.logProb = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, &tuneScores);
				elem.logProbPath = elem.logProb;
				elem.iPathLength = 1;
				InsertElement(lat,iStroke,&elem);
			} 
			else 
			{
                // Otherwise go through all the previous characters in the
				// lattice as alternates.
				BOOL first=TRUE;

				for (iAlt=0; iAlt<lat->pAltList[iStroke-nChar1].nUsed; iAlt++) 
				{
					LATTICE_ELEMENT	*prevElem = &lat->pAltList[iStroke-nChar1].alts[iAlt];
					float			prob, probPath;
					
                    // Only disallow overlapping boxes in normal recognition mode
                    if (IsOverlappedPath(lat, iStroke - nChar1, iAlt, bbox)) 
                    {
					    continue;
                    }

                    VTuneZeroWeights(&tuneScores);
					
					// If we're not in separator mode, then prune based on the 
                    // segmentation score
					CheapBinaryProb(nChar1,bbox,elem.space,elem.area,
										prevElem->nStrokes,prevElem->bbox,prevElem->space,prevElem->area,
                                        &tuneScores);

                    prob = VTuneComputeScoreNoLM(&g_vtuneInfo.pTune->weights, &tuneScores);

					// Equalize probs across different numbers of strokes
					probPath = (prob + prevElem->logProbPath * prevElem->iPathLength) / 
						(prevElem->iPathLength + 1);

					if (first || probPath > elem.logProbPath)
                    {
						first=FALSE;
						elem.iPathLength = prevElem->iPathLength + 1;
						elem.logProb=prob;
						elem.logProbPath=probPath;
						elem.nPrevStrokes=prevElem->nStrokes;
						elem.iPrevAlt=iAlt;
					}
				}

	 			if (!first) 
				{
					InsertElement(lat,iStroke,&elem);
				}
			}
		}
    }

    PruneLattice(lat, iStrtStroke, iEndStroke);

	// For each stroke in the lattice
	for (iStroke = iStrtStroke; iStroke <= iEndStroke; iStroke++) 
	{
		BuildRecogAlts(lat, iStroke, TRUE);
    }

	if (lat->pAltList[iEndStroke].nUsed==0) 
	{
		// Well, the recognizer came back and said there were no candidates.  
		// Let's put in a dummy alt so the user will see something, and also so
		// the language model will have a path to work with.
		FakeRecogResult(lat, iEndStroke, iEndStroke - iStrtStroke + 1, -PENALTY_SKIP_INK);
	}

	return TRUE;
}

void FixupBackPointers (LATTICE *pLat)
{
	int		iStrk,
			iAlt,
			iPrevStrk,
			iPrevAlt,
			cChar;

	iPrevStrk	=	0;
	iPrevAlt	=	-1;
	cChar		=	0;

	// all strokes
	for (iStrk = 0; iStrk < pLat->nStrokes; iStrk++)
	{
		// every alt at this stroke
		for (iAlt = 0; iAlt < pLat->pAltList[iStrk].nUsed; iAlt++)
		{
			// is it part of the best path
			if (pLat->pAltList[iStrk].alts[iAlt].fCurrentPath)
			{
				// the number of strokes should be correct because this is 
				// how we set the fCurrent flags, so assert otherwise
				ASSERT (pLat->pAltList[iStrk].alts[iAlt].nStrokes == (iStrk - iPrevStrk + 1));

				// set the prev alt
				pLat->pAltList[iStrk].alts[iAlt].iPrevAlt		=	iPrevAlt;
				pLat->pAltList[iStrk].alts[iAlt].iPathLength	=	(++cChar);

				// update the prev strk and alt
				iPrevStrk	=	iStrk + 1;
				iPrevAlt	=	iAlt;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\latticers.c ===
#include "volcanop.h"
#include "res.h"
#include "brknet.h"

// Segmentation stuff

BBOX_PROB_TABLE *g_pProbTable;

// Default language model code

UNIGRAM_INFO g_unigramInfo;
BIGRAM_INFO g_bigramInfo;
CLASS_BIGRAM_INFO g_classBigramInfo;
TTUNE_INFO g_ttuneInfo;
wchar_t g_pLocale[16];
wchar_t g_pLocaleDir[1024];
wchar_t g_pRecogDir[1024];

VOLCANO_PARAMS_INFO g_vtuneInfo;
VOLCANO_CONFIG g_volcanoConfig;
CENTIPEDE_INFO g_centipedeInfo;

BOOL LoadSegmNetFromResource (HINSTANCE hInst, int nResID, int nType);
BOOL LoadCharDetFromResource (HINSTANCE hInst, int nResID, int nType);

// Load up everything for the lattice search
// Loads the following databases: unigrams, bigrams, class bigrams, tuning, centipede, free input
BOOL LatticeConfig(HINSTANCE hInstanceDll)
{
	BOOL			fError	= FALSE;

    LatticeConfigInit();

	// Tuning parameters (can probably be removed for the non-insurance version)
	if (!fError && !TTuneLoadRes(
		&g_ttuneInfo, hInstanceDll, RESID_TTUNE, VOLCANO_RES
	)) {
		fError	= TRUE;
		ASSERT(("Error in TTuneLoadRes", FALSE));
	}

	if (!fError && !VTuneLoadRes(&g_vtuneInfo, hInstanceDll, RESID_VTUNE, VOLCANO_RES)) 
	{
		fError = TRUE;
		ASSERT(("Error in VTuneLoadRes", FALSE));
	}

	// Load unigrams
	if (!fError && !UnigramLoadRes(
		&g_locRunInfo, &g_unigramInfo,
		hInstanceDll, RESID_UNIGRAM, VOLCANO_RES
	)) {
		fError	= TRUE;
		ASSERT(("Error in UnigramLoadRes", FALSE));
	}

	// Load bigrams only if we're in WinCE
#	if !defined(WINCE) && !defined(FAKE_WINCE)
		if (!fError && !BigramLoadRes(
			&g_locRunInfo, &g_bigramInfo, hInstanceDll, RESID_BIGRAM,
			VOLCANO_RES
		)) {
			fError	= TRUE;
			ASSERT(("Error in BigramLoadRes", FALSE));
		}
#	endif

	// Load class bigrams
	if (!fError && !ClassBigramLoadRes(
		&g_locRunInfo, &g_classBigramInfo, hInstanceDll, 
		RESID_CLASS_BIGRAM, VOLCANO_RES
	)) {
		fError	= TRUE;
		ASSERT(("Error in ClassBigramLoadRes", FALSE));
	}

	// Load up centipede
	if (!fError) {
		if (!CentipedeLoadRes(&g_centipedeInfo, hInstanceDll, RESID_CENTIPEDE, VOLCANO_RES, &g_locRunInfo)) {
			fError = TRUE;
			ASSERT(("Error in CentipedeLoadRes", FALSE));
		}
	}

	// Load the bbox prob table for pre-segmentation
	if (!fError) {
		g_pProbTable = LoadBBoxProbTableRes(
			hInstanceDll, RESID_BBOX_PROBS, VOLCANO_RES
		);
		// Failure to load here is not an error, we just won't support free input.
	}

	// Try to load up IIMLanguage
#ifdef USE_IFELANG3
//	LatticeConfigIFELang3();
#endif

	// Don't bother trying to load other free input databases if the basic
	// one is not available.
	if (g_pProbTable != NULL)
	{
		// try to load the break net
		if (LoadBrkNetFromResource (hInstanceDll, RESID_BRKNET, VOLCANO_RES))
		{
			// load the segmnet, optional
			if (!LoadSegmNetFromResource (hInstanceDll, RESID_SEGMNET, VOLCANO_RES))
			{
	//			fError	= TRUE;
	//			ASSERT(("Error in LoadSegmNetFromResource", FALSE));
			}

			// load the char detector, not optional
			if (!LoadCharDetFromResource (hInstanceDll, RESID_CHARDET, VOLCANO_RES))
			{
				fError	= TRUE;
				ASSERT(("Error in LoadCharDetFromResource", FALSE));
			}
		}
	}

	// Did everything load correctly?
	if (fError) 
	{
		return FALSE;
	}

	return TRUE;
}

// Unload those things that can be unloaded
BOOL LatticeUnconfig()
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\res.h ===
// res.h: defines for resources

#ifndef __INCLUDE_RES
#define __INCLUDE_RES

#define RESID_ZILLA			5000
#define RESID_COSTCALC		5100
#define RESID_GEOSTAT		5200
#define RESID_OTTER			5300
#define RESID_HAWK			5400
#define RESID_CRANE			5450
#define RESID_LOCRUN		5500
#define RESID_UNIGRAM		5600
#define RESID_TTUNE			5700
#define RESID_CLASS_BIGRAM	5800
#define RESID_BIGRAM		5900
#define RESID_BBOX_PROBS	6000
#define RESID_CENTIPEDE		6100
#define RESID_HWXLANGID		6200
#define RESID_VTUNE			6300
#define	RESID_BRKNET		6400

#define	RESID_SEGMNET		6500
#define	RESID_CHARDET		6600
#define RESID_SOLE          6700
#define RESID_FUGU          6800
#define RESID_JAWS          6900
#define	RESID_HOUND			7000
#define RESID_ZILLA_HOUND	7010

#define RESID_WISP_DATA 	    8000
#define RESID_WISP_FRIENDLYNAME 8001
#define RESID_WISP_VENDORNAME   8002

#define VOLCANO_RES			296

#endif   // _H_RES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\segm.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/segm.c
//
// Description:
//	    Functions to implement the functionality of managing segmentation structures.
//
// Author:
// ahmadab 11/14/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"
#include "brknet.h"
#include "segm.h"
#include "nnet.h"

float FuguSegScore(int cStrokes, STROKE *pStrokes, LOCRUN_INFO *pLocRunInfo);

// enumerate all the segmentations currently present in the lattice
// for the specified ink segment
BOOL EnumerateInkSegmentations (LATTICE	*pLat, INK_SEGMENT *pInkSegment)
{
	int					cAlt, iAlt, iPrevAlt;
	LATTICE_ALT_LIST	*pAlt;

	// find unique segmentations
	pAlt	=	pLat->pAltList + pInkSegment->StrokeRange.iEndStrk;
	cAlt	=	pAlt->nUsed;

	// for each alt find out if there is any prev alt that suggests the same stroke count
	for (iAlt = 0; iAlt < cAlt; iAlt++)
	{
		for (iPrevAlt = 0; iPrevAlt < iAlt; iPrevAlt++)
		{
			// found one, that is enough exit this prev loop
			if (pAlt->alts[iAlt].nStrokes == pAlt->alts[iPrevAlt].nStrokes)
			{
				break;
			}
		}

		// if we found no match, then this is the first existense of this count, we want it
		if (iPrevAlt == iAlt)
		{
			ELEMLIST			*pSegm;
			int					iStrk, iStrkAlt;
			LATTICE_ALT_LIST	*pStrkAlt;

			// now we want to create a new segmentation
			pInkSegment->ppSegm	=	(ELEMLIST **) ExternRealloc (pInkSegment->ppSegm,
				(pInkSegment->cSegm + 1) * sizeof (*pInkSegment->ppSegm));

			if (!pInkSegment->ppSegm)
			{
				return FALSE;
			}
			
			pInkSegment->ppSegm[pInkSegment->cSegm]	=	
				(ELEMLIST *) ExternAlloc (sizeof (*pInkSegment->ppSegm[pInkSegment->cSegm]));

			if (!pInkSegment->ppSegm[pInkSegment->cSegm])
			{
				return FALSE;
			}

			pSegm				=	pInkSegment->ppSegm[pInkSegment->cSegm];
			pInkSegment->cSegm++;

			memset (pSegm, 0, sizeof (*pSegm));

			iStrk		=	pInkSegment->StrokeRange.iEndStrk;
			iStrkAlt	=	iAlt;

			while (iStrk >= pInkSegment->StrokeRange.iStartStrk)
			{
				pStrkAlt	=	pLat->pAltList + iStrk;

				if (!InsertListElement (pSegm, iStrk, iStrkAlt, pStrkAlt->alts + iStrkAlt))
				{
					return FALSE;
				}

				iStrk		-=	pStrkAlt->alts[iStrkAlt].nStrokes;
				iStrkAlt	=	pStrkAlt->alts[iStrkAlt].iPrevAlt;
			}

			ReverseElementList (pSegm);

			// if we had already exceed the maximum number of segmentations, return
			if (pInkSegment->cSegm > MAX_SEGMENTATIONS)
			{
				return TRUE;
			}
		}
	}

	return TRUE;
}

// computes the set of features for a segmentation
int FeaturizeSegmentation (LATTICE *pLat, ELEMLIST *pSeg, int *pFeat)
{
	int						cFeat	=	0;
	LATTICE_ELEMENT			*pElem, *pPrevElem;
	LATTICE_PATH_ELEMENT	*pPathElem;
	int						iChar,
							iBrkNetOut;
                            
    pPrevElem = NULL;
    iBrkNetOut = 0;
                            
	pPathElem	=	pSeg->pElem;

	for (iChar = 0; iChar < MAX_SEG_CHAR; iChar++, pPathElem++)
	{
		// we going beyond the actual number of chars
		if (iChar >= pSeg->cElem)
		{
			// char features

			// FEATURE 0: is this a real char
			pFeat[cFeat++]	=	0;

			// FEATURE 1: # of strokes
			pFeat[cFeat++]	=	0;

			// FEATURE 2: -log prob
			pFeat[cFeat++]	=	65535;

			// FEATURE 3: unigram of code point
			pFeat[cFeat++]	=	65535;

			// FEATURE 3: fake fugu score
			pFeat[cFeat++]	=	0;

			// char pair features
			if (iChar > 0)
			{
				// FEATURE 0: bigram pair
				pFeat[cFeat++]	=	65535;

				// FEATURE 1: normalized delx
				pFeat[cFeat++]	=	0;

				// FEATURE 2: output of brk net
				pFeat[cFeat++]	=	0;
			}

			pPrevElem	=	NULL;
		}
		else
		{
			ASSERT (pPathElem->iStroke < pLat->nStrokes);
			ASSERT (pPathElem->iAlt < pLat->pAltList[pPathElem->iStroke].nUsed);

			pElem	=	pLat->pAltList[pPathElem->iStroke].alts + pPathElem->iAlt;

			// FEATURE 0: is this a real char
			pFeat[cFeat++]	=	65535;

			// FEATURE 1: # of strokes
			pFeat[cFeat++]	=	min (65535, pElem->nStrokes * 1000);

			// FEATURE 2: -log prob
			pFeat[cFeat++]	=	min (65535, (int) (-1000.0 * pElem->logProb));

			// FEATURE 3: unigram of code point
			pFeat[cFeat++]	=	
				min (65535, (int) (-255.0 * UnigramCost (&g_unigramInfo, pElem->wChar)));

			// feature 4: char detector score
			if (pElem->iCharDetectorScore == -1)
			{
				pElem->iCharDetectorScore	=	
					min (65535, (int) (65535.0 * FuguSegScore (pElem->nStrokes, 
					pLat->pStroke + pPathElem->iStroke -  pElem->nStrokes + 1,
					&g_locRunInfo)));
			}

			pFeat[cFeat++]	=	max (min (65535, pElem->iCharDetectorScore), 0);
				

			// char pair features
			if (iChar > 0)
			{
				int	xDist, yHgt;

				ASSERT (pPrevElem != NULL);

				// FEATURE 0: bigram pair
				pFeat[cFeat++]	=	min (65536,
					(int) (-1000.0 * BigramTransitionCost (&g_locRunInfo, &g_bigramInfo, 
					pPrevElem->wChar, pElem->wChar)));

				// FEATURE 1: normalized delx
				xDist	=	pElem->bbox.left - pPrevElem->bbox.right;
				yHgt	=	1 + (	(pElem->bbox.bottom - pElem->bbox.top) +
									(pPrevElem->bbox.bottom - pPrevElem->bbox.top)
								) / 2;

				pFeat[cFeat++]	=	32768 + 
					max (-32767, min (32767, (int)(32768.0 * xDist / (abs(xDist) + yHgt))));

				// FEATURE 2: output of brk net after prev char
				pFeat[cFeat++]	=	iBrkNetOut;
			}

			iBrkNetOut	=	pLat->pAltList[pPathElem->iStroke].iBrkNetScore;
			pPrevElem	=	pElem;
		}
	}
	
	return cFeat;
}


// frees an ink segment
void FreeInkSegment (INK_SEGMENT *pInkSegment)
{
	int	iSeg;

	for (iSeg = 0; iSeg < pInkSegment->cSegm; iSeg++)
	{
		if (pInkSegment->ppSegm[iSeg])
		{
			FreeElemList (pInkSegment->ppSegm[iSeg]);

			ExternFree (pInkSegment->ppSegm[iSeg]);
		}
	}

	if (pInkSegment->ppSegm)
	{
		ExternFree (pInkSegment->ppSegm);
	}
}


// featurize an ink segment
int FeaturizeInkSegment (LATTICE *pLat, INK_SEGMENT *pInkSegment, int *pFeat)
{
	int		iSeg,
			cSegFeat,
			cFeat	=	0;

	for (iSeg = 0; iSeg < pInkSegment->cSegm; iSeg++)
	{
		// featurize this segmentation
		cSegFeat	=	FeaturizeSegmentation (pLat, 
			pInkSegment->ppSegm[iSeg], pFeat + cFeat);

		// did we fail
		if (cSegFeat <= 0)
		{
			return -1;
		}

		// increment the number of features
		cFeat	+=	cSegFeat;
	}

	return cFeat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\segm.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/segm.h
//
// Description:
//	    Functions to implement the functionality of the break Neural net that 
// modifies the lattice structure to correct segmentation errors.
//
// Author:
// ahmadab 11/14/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#ifndef __SEGM_H__

#define	__SEGM_H__

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"

// maximum number of segmentations to consider
#define	MAX_SEGMENTATIONS		5

// maximum number of segmentation features
#define	MAX_SEG_FEAT			20

// maximum number of characters per segmentations consider
#define	MAX_SEG_CHAR			3

// Magic key the identifies the NN bin file
#define	SEGMNET_FILE_TYPE		0xBEEB0FEA

// Version information for file.
#define	SEGMNET_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	SEGMNET_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define SEGMNET_CUR_FILE_VERSION		0		// Current version of code.

// structure describing a range of strokes
typedef struct	tagSTROKE_RANGE
{
	int				iStartStrk;
	int				iEndStrk;
}
STROKE_RANGE;

// structure describing a stroke range and its different possible segmentations
typedef struct tagRange
{
	int				cSegm;
	ELEMLIST		**ppSegm;
	STROKE_RANGE	StrokeRange;
}
INK_SEGMENT;


BOOL	EnumerateInkSegmentations (LATTICE	*pLat, INK_SEGMENT *pInkSegment);
int		FeaturizeSegmentation (LATTICE *pLat, ELEMLIST *pSeg, int *pFeat);
void	FreeInkSegment (INK_SEGMENT *pInkSegment);
int		FeaturizeInkSegment (LATTICE *pLat, INK_SEGMENT *pInkSegment, int *pFeat);
BOOL	UpdateSegmentations	(LATTICE *pLat, int	iStrtStrk, int iEndStrk);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\segmnet.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/segmnet.c
//
// Description:
//	    Functions to implement the functionality of the segmentation Neural net that 
// modifies the lattice structure to correct segmentation errors.
//
// Author:
// ahmadab 11/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "volcanop.h"
#include "lattice.h"
#include "runnet.h"
#include "brknet.h"
#include "segm.h"
#include "nnet.h"

// the size and structure representing the segmentations net used in Free mode
static int			s_aiSegmNetSize[MAX_SEGMENTATIONS + 1]; 
static LOCAL_NET	s_aSegmNet[MAX_SEGMENTATIONS + 1];

// validates the header of the brknet
int CheckSegmNetHeader (void *pData)
{
	NNET_HEADER	*pHeader	=	(NNET_HEADER *)pData;

	// wrong magic number
	ASSERT (pHeader->dwFileType == SEGMNET_FILE_TYPE);

	if (pHeader->dwFileType != SEGMNET_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= SEGMNET_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= SEGMNET_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

    if	(	pHeader->iFileVer >= SEGMNET_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= SEGMNET_CUR_FILE_VERSION && 
			!memcmp (	pHeader->adwSignature, 
						g_locRunInfo.adwSignature, 
						sizeof (pHeader->adwSignature)
					)
		)
    {
        return pHeader->cSpace;
    }
	else
	{
		return 0;
	}
}

// does the necessary preparations for a net to be used later
static BOOL PrepareSegmNet(BYTE *pData)
{
	int					iSpc, cSpc, iSpaceID;
	NNET_SPACE_HEADER	*pSpaceHeader;
	BYTE				*pPtr, *pNetData;

	if (!pData)
	{
		return FALSE;
	}

	// init all nets data 
	memset (s_aiSegmNetSize, 0, sizeof (s_aiSegmNetSize));
	memset (s_aSegmNet, 0, sizeof (s_aSegmNet));

	// check the header info
	cSpc	=	CheckSegmNetHeader (pData);
	if (cSpc <= 0)
	{
		return FALSE;
	}
	
	pPtr	=	pData	+ sizeof (NNET_HEADER);

	for (iSpc = 0; iSpc < cSpc; iSpc++)
	{
		// point to the one and only space that we have
		pSpaceHeader	=	(NNET_SPACE_HEADER *)pPtr;
		pPtr			+=	sizeof (NNET_SPACE_HEADER);

		// point to the actual data
		pNetData	=	pData + pSpaceHeader->iDataOffset;
		iSpaceID	=	pSpaceHeader->iSpace;

		if (iSpaceID < 2 || iSpaceID > MAX_SEGMENTATIONS) 
		{
			ASSERT (iSpaceID >= 2 && iSpaceID <= MAX_SEGMENTATIONS);
			return FALSE;
		}

		// restore the connections
		if (!restoreLocalConnectNet(pNetData, 0, s_aSegmNet + iSpaceID))
		{
			return FALSE;
		}

		// compute the run time memory requirements of the net
		s_aiSegmNetSize[iSpaceID] = getRunTimeNetMemoryRequirements(pNetData);

		if (s_aiSegmNetSize[iSpaceID] <= 0)
		{
			return FALSE;
		}
	}

	return TRUE;
}

// load the brk net from resources
BOOL LoadSegmNetFromFile(wchar_t *pwszRecogDir, LOAD_INFO *pLoadInfo)
{
	BYTE		*pData;
	wchar_t		awszFileName[MAX_PATH];
	
	wsprintf (awszFileName, L"%s\\segmnet.bin", pwszRecogDir);

	// memory map the file
	pData	=	DoOpenFile (pLoadInfo, awszFileName);
	if (!pData)
	{
		return FALSE;
	}

	// prepare Brk net
	if (!PrepareSegmNet(pData))
	{
		return FALSE;
	}

	return TRUE;
}

// load the brk net from resources
BOOL LoadSegmNetFromResource (HINSTANCE hInst, int nResID, int nType)
{
	BYTE		*pData;
	LOAD_INFO	LoadInfo;
	
	// init the size to zero, in case we fail
	pData	=	DoLoadResource (&LoadInfo, hInst, nResID, nType);
	if (!pData)
	{
		return FALSE;
	}

	// prepare Brk net
	if (!PrepareSegmNet(pData))
	{
		return FALSE;
	}

	return TRUE;
}

// update segmentations in the lattice by running a neural
// net that picks a segmentation from a list within an inksegment
BOOL UpdateSegmentations	(LATTICE *pLat, int	iStrtStrk, int iEndStrk)
{
	int			iNet,
				iSeg,
				jSeg,
				cStrk,
				cFeat,
				iWinner,
				cOut,
				iWord,
				iStrk,
				iAlt;

	BOOL		bRet	=	FALSE,
				b;

	RREAL		*pNetBuffer, *pNetOut;

	INK_SEGMENT	InkSegment;

    // Check to see if we loaded the segmentation nets.
    // If not just exit
    if (s_aiSegmNetSize[2] <= 0) 
    {
        return TRUE;
    }

	// create the range
	memset (&InkSegment, 0, sizeof (INK_SEGMENT));
	InkSegment.StrokeRange.iStartStrk	=	iStrtStrk;
	InkSegment.StrokeRange.iEndStrk		=	iEndStrk;

	// alloc memory for the back path
	cStrk				=	iEndStrk - iStrtStrk + 1;
	
	// harvest the segmentations that made it to the final stroke in the ink segment
	b	=	EnumerateInkSegmentations (pLat, &InkSegment);
	if (!b || InkSegment.cSegm < 1)
	{
		goto exit;
	}

	// if the number of segmentations is greater than max_seg, or less than two 
	// then there is nothing for us to do
	if (InkSegment.cSegm < 2 || InkSegment.cSegm > MAX_SEGMENTATIONS)
	{
		iWinner	=	0;
	}
	else
	{
		// sort segmentations by char count	
		for(iSeg = 0; iSeg < (InkSegment.cSegm - 1); iSeg++)
		{
			ELEMLIST	*pSeg;

			for (jSeg = iSeg + 1; jSeg < InkSegment.cSegm; jSeg++)
			{
				if (InkSegment.ppSegm[iSeg]->cElem > InkSegment.ppSegm[jSeg]->cElem)
				{
					pSeg					=	InkSegment.ppSegm[iSeg];
					InkSegment.ppSegm[iSeg]	=	InkSegment.ppSegm[jSeg];
					InkSegment.ppSegm[jSeg]	=	pSeg;
				}
			}
		}

		// run the appropriate segmentation net
		iNet		=	InkSegment.cSegm;

		pNetBuffer	=	(RREAL *) ExternAlloc (s_aiSegmNetSize[iNet] * sizeof (*pNetBuffer));
		if (!pNetBuffer)
		{
			goto exit;
		}

		// featurize this inksegment
		cFeat		=	FeaturizeInkSegment (pLat, &InkSegment, (int *)pNetBuffer);

		// run the net
		pNetOut		=	runLocalConnectNet (&s_aSegmNet[iNet], pNetBuffer, &iWinner, &cOut);
		ASSERT (cOut == InkSegment.cSegm);

		if (!pNetOut)
		{
			goto exit;
		}

		ExternFree (pNetBuffer);
	}
	
	// reset the current path in the specified stroke range
	for (iStrk = iStrtStrk; iStrk <= iEndStrk; iStrk++)
	{
		for (iAlt = 0; iAlt < pLat->pAltList[iStrk].nUsed; iAlt++)
		{
			pLat->pAltList[iStrk].alts[iAlt].fCurrentPath	=	FALSE;
		}
	}

	// now mark the characters proposed by the winning segmentation as part 
	// of the best path
	for (iWord = 0; iWord < InkSegment.ppSegm[iWinner]->cElem; iWord++)
	{
		iStrk	=	InkSegment.ppSegm[iWinner]->pElem[iWord].iStroke;
		iAlt	=	InkSegment.ppSegm[iWinner]->pElem[iWord].iAlt;

		pLat->pAltList[iStrk].alts[iAlt].fCurrentPath	=	TRUE;
	}

	bRet	=	TRUE;

exit:
	FreeInkSegment (&InkSegment);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\sole.c ===
// Code for Sole shape match function

#include <limits.h>
#include <stdio.h>
#include "common.h"
#include "cheby.h"
#include "cowmath.h"
#include "math16.h"
#include "volcanop.h"
#include "runNet.h"
#include "nnet.h"

GLYPH * GlyphFromStrokes(UINT cStrokes, STROKE *pStrokes);
RECT GetGuideDrawnBox(HWXGUIDE *guide, int iBox);

#define ABS(x) (((x) > 0) ? (x) : -(x))
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#define SIGN(x) ((x) > 0 ? 1 : ((x) < 0 ? -1 : 0))
#define PEN_UP_VALUE  LSHFT(-1)
#define PEN_DOWN_VALUE LSHFT(1)

#define XCHB 10
#define YCHB 10
#define ZCHB 10

#define MAXTMP 3

// assumption: GRIDSIZE <= 256 //This is beacuse the pointers to the mapped values are defined as Byte pointers
#define GRIDSIZE 32

typedef struct
{
	int *xy; //Stores the sampled XY points
	int *z;  //Stores the z points--values are either PEN_UP or PEN_DOWN
	int cPoint;//Stores the number of points that are there 
	int cPointMax; //Stores the max number of points that can be allocated
	int iStepSize; //Stores the length of the step size--at present this is taken to be 1.5 % of the guide size
	int iStepSizeSqr; //Stroes the square of the step size
} POINTINFO;
//This macro is used for seeing if two points are neighbours to one another--ie the distance between them <=1
#define Neighbor(a, b) ((a)-(b) < 2 && (b)-(a) < 2)

static int
solve2(int m[][(IMAXCHB+1)/2], int c[], int n)
{
	int i, j, k, t, tmp;

	for (i=0; i<n; ++i)
	{
		t = m[i][i];

		// punt:
		if (t == 0)
		{
			memset(c, 0, n*sizeof(*c));
			return 0;
		}

		for (j=0; j<n; ++j)
			m[i][j] = Div16(m[i][j], t);
		c[i] = Div16(c[i], t);

		for (k=i+1; k<n; ++k)
		{
			t = m[k][i];

			for (j=0; j<n; ++j)
			{
				Mul16(t, m[i][j], tmp)
				m[k][j] -= tmp;
			}
			Mul16(t, c[i], tmp)
			c[k] -= tmp;
		}
	}

	for (i=(n-1); i>=0; --i)
	{
		for (k=i-1; k>=0; --k)
		{
			t = m[k][i];

			for (j=0; j<n; ++j)
			{
				Mul16(t, m[i][j], tmp)
				m[k][j] -= tmp;
			}
			Mul16(t, c[i], tmp)
			c[k] -= tmp;
		}
	}

	return 1;
}

static int
solve(int m[IMAXCHB][IMAXCHB], int *c, int n)
{
	int i, j, i2, j2;
	int mEven[((IMAXCHB+1))/2][((IMAXCHB+1)/2)];
	int mOdd[(IMAXCHB/2)][((IMAXCHB+1)/2)];	// # of cols is bigger than needed so that solve2() works
	int cEven[((IMAXCHB+1)/2)];
	int cOdd[(IMAXCHB/2)];

	for (i = 0, i2 = 0; i2 < n; ++i, i2 += 2)
	{
		for (j = 0, j2 = 0; j2 < n; ++j, j2 += 2)
		{
			mEven[i][j] = m[i2][j2];
		}
		cEven[i] = c[i2];
	}
	for (i = 0, i2 = 1; i2 < n; ++i, i2 += 2)
	{
		for (j = 0, j2 = 1; j2 < n; ++j, j2 += 2)
		{
			mOdd[i][j] = m[i2][j2];
		}
		cOdd[i] = c[i2];
	}
	if (!solve2(mEven, cEven, (n+1)/2)) return 0;
	if (!solve2(mOdd, cOdd, n/2)) return 0;

	for (i = 0, i2 = 0; i2 < n; ++i, i2 += 2)
	{
		c[i2] = cEven[i];
	}
	for (i = 0, i2 = 1; i2 < n; ++i, i2 += 2)
	{
		c[i2] = cOdd[i];
	}

	return 1;
}

// Assumptions:
//    c has size atleast cfeats
//    cfeats is at most IMAXCHB
//    c is uninitialized
int LSCheby(int* y, int n, int *c, int cfeats)
{
	int i, j, t, x, dx, n2, nMin;
	int meanGuess, tmp;
	int T[IMAXCHB], m[IMAXCHB][IMAXCHB];
	
	if (cfeats > IMAXCHB  || cfeats <= 0)
		return 0;
	
	memset(c, 0, cfeats*sizeof(*c));

	n2 = n+n;
	nMin = cfeats + 2;


    if (n < nMin && n > 4)
    {
        cfeats = n - 2;
        nMin = cfeats + 2;
    }

	if (n < nMin)	// approximate the stroke by a straight line
	{
		*c++ = (y[0] + y[n2-2]) >> 1;
		*c   = (y[n2-2] - y[0]) >> 1;
		return 2;
	}

	memset(T, 0, sizeof(T));
	memset(m, 0, sizeof(m));

	meanGuess = y[0];

	x = LSHFT(-1);
	dx = LSHFT(2)/(n-1);

	for (t = 0; t < n2; t += 2)
	{
		T[0] = LSHFT(1);
		T[1] = x;
		for (i = 2; i < cfeats; ++i)
		{
			Mul16(x, T[i-1], tmp)
			T[i] = (tmp<<1) - T[i-2];
		}

		for (i = 0; i < cfeats; ++i)
		{
			for (j = 0; j < cfeats; ++j)
			{
				Mul16(T[i], T[j], tmp)
				m[i][j] += tmp;
			}

			Mul16(T[i], y[t] - meanGuess, tmp)
			c[i] += tmp;
			//c[i] += T[i]*(y[t] - meanGuess);		
		}
		
		x += dx;
	}

	if (!solve(m, c, cfeats)) 
		return 0;

	c[0] += meanGuess;

	return cfeats;
}



int ISqrt(int x)
{
	int n, lastN;

	if (x <= 0)
		return 0;
	if (x==1)
		return 1;

	n = x >> 1;
	do 
	{
		lastN = n;
		n = (n + x/n) >> 1;
	}
	while (n < lastN);

	return n;
}

/******************************Public*Routine******************************\
* YDeviation
*
* Function to compute average deviation of the y values in a sequence of 
* strokes (frames).
* This is not exactly standard deviation.  But it is a lot cheaper and
* close enough.  (See analysis and comments in Numerical Recipes in C).
*
* History:
*  02-Sep-1999 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int YDeviation(GLYPH *pGlyph)
{
	int count, ymin, sum, ymean;
	GLYPH *glyph;
	FRAME *frame;

	if (pGlyph && pGlyph->frame && RgrawxyFRAME(pGlyph->frame))
	{
		ymin = RgrawxyFRAME(pGlyph->frame)->y;
		count = 0;
		sum = 0;
	}
	else
		return 1;

	// find min and mean in one scan
	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		XY *xy;
		int cxy;

		frame = glyph->frame;
		xy = RgrawxyFRAME(frame);
		cxy = CrawxyFRAME(frame);

		for (; cxy; xy++, cxy--)
		{
			int y;

			y = xy->y;
			if (y < ymin)
			{
				sum += count*(ymin - y);
				ymin = y;
			}
			sum += y - ymin;
			count++;
		}
	}


	ASSERT(count > 0);
	ymean = sum/count + ymin;

	// find average deviation
	sum = 0;
	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		XY *xy;
		int cxy;

		frame = glyph->frame;
		xy = RgrawxyFRAME(frame);
		cxy = CrawxyFRAME(frame);

		for (; cxy; xy++, cxy--)
		{
			int diff;

			diff = xy->y - ymean;
			if (diff < 0)
				sum -= diff;
			else
				sum += diff;
		}
	}

	sum = sum/count;
	if (sum < 1)
		sum = 1;
	return sum;
}
/******************************Private*Routine******************************\
* AddPoint
*
* Given a new point and a sequence of points so far, zero or more points
* are added at the end of the sequence.  The points are effectively resampled
* at a pre-computed interval (a distance of pPointinfo->iStepSize between
* successive points).  This function also effectively does a linear interpolation
* of a pen-upstroke between the last point of a pen-down stroke and the first
* point of the next pen-down stroke.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha


  Explanation of parameters
pPointInfo--The pointer to the Point Info structure--The points are added to the xy array of this structure
x--The x coordinate of the point to be added
y--The y coordinate of the point to be added
bFirstPointOfStroke--If true indicates that this is the first point of the stroke
                     Else it it not the first point
* Wrote this comment.Addtional comments added by Mango
\**************************************************************************/
BOOL AddPoint(POINTINFO *pPointinfo, int x, int y, int bFirstPointOfStroke)
{
	int dx, dy, dist2, dist;
	int bChangeLastPoint, x0, y0, zval;
	int *pTemp;

	if (!pPointinfo->cPoint)
	{
		pPointinfo->xy[0] = x;
		pPointinfo->xy[1] = y;
		pPointinfo->z[0] = PEN_DOWN_VALUE;
		pPointinfo->cPoint = 1;
		return TRUE;
	}

	bChangeLastPoint = 0;
	x0 = pPointinfo->xy[2*pPointinfo->cPoint-2];
	y0 = pPointinfo->xy[2*pPointinfo->cPoint-1];
	zval = bFirstPointOfStroke ? PEN_UP_VALUE : PEN_DOWN_VALUE;
	for (;;)
	{
		dx = x - x0;
		dy = y - y0;
		dist2 = dx*dx + dy*dy;
		if (dist2 < pPointinfo->iStepSizeSqr)
			break;

		// add a point at given step size
		dist = ISqrt(dist2);
		x0 += pPointinfo->iStepSize*dx/dist;
		y0 += pPointinfo->iStepSize*dy/dist;
		// a minimum iStepSize of 2 and the fact that ((float)dx/dist)^2 + ((float)dy/dist)^2 = 1 guarantees that
		// the previous two assignments change atleast one of x0 and y0 i.e. its not an infinite loop
		if (pPointinfo->cPoint == pPointinfo->cPointMax)
		{
			// need more space
			// hopefully we don't come here too often
			pPointinfo->cPointMax *= 2;
			pTemp = (int *) ExternRealloc(pPointinfo->xy, 2*pPointinfo->cPointMax*sizeof(int));
			if (!pTemp)
			{
				return FALSE;
			}
			pPointinfo->xy = pTemp;
			pTemp = (int *) ExternRealloc(pPointinfo->z, 2*pPointinfo->cPointMax*sizeof(int));
			if (!pTemp)
			{
				return FALSE;
			}
			pPointinfo->z = pTemp;
		}
		pPointinfo->xy[2*pPointinfo->cPoint] = x0;
		pPointinfo->xy[2*pPointinfo->cPoint+1] = y0;
		pPointinfo->z[2*pPointinfo->cPoint] = zval;
		pPointinfo->cPoint++;
		bChangeLastPoint = bFirstPointOfStroke;
	}

	// if we have interpolated from the last point of a stroke to the first point of another
	if (bChangeLastPoint)
	{
		ASSERT(pPointinfo->z[2*pPointinfo->cPoint - 2] == PEN_UP_VALUE);
		pPointinfo->z[2*pPointinfo->cPoint - 2] = PEN_DOWN_VALUE;
	}
	// this last "if" could be changed to a test on bFirstPointOfStroke and the assert can be removed
	return TRUE;
}

/******************************Private*Routine******************************\
* AddGuideFeatures
*
* Given a piece of ink in a box, compute five features related to the size 
* and position of ink in the box.
* The five features are:-
*	//First feature--Top of the ink relative to the guide box height
*	//Second feature--Width of the ink relative to the guide box width
*	//Third feature--Bottom of the ink relative to the guide box height
*	//Fourth feature--The width of the ink relative to the sum of its width and height
*	//Fifth feature--the iYMean value relative to the guide box height
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
int AddGuideFeatures(RECT *pGuide, RECT *pRect, int iYMean, unsigned short *rgFeat)
{
	// get normalized ink size/position (box is 1000x1000 with top-left at 0,0)
	DRECTS drcs;
	RECT inkRect = *pRect;
	int x;

	//The x coordinate of the top left corner of the current box(note--you are adding the cxBase Value) 
	drcs.x = pGuide->left;

	//The y coordinate of the top left corner of the current box
	drcs.y = pGuide->top;

	//This gives us the width of the current guide box
	drcs.w = pGuide->right - pGuide->left;

	//This gives us the height of the current guide box
	drcs.h = pGuide->bottom - pGuide->top;

	// Translate, convert to delta form
	//Stores the relative position w.rt. the top left of the guide box
	inkRect.left   -= drcs.x;
	inkRect.top    -= drcs.y;
	//Stores the width of the ink
	inkRect.right  -= (drcs.x + inkRect.left);
	//Stores the height of the ink
	inkRect.bottom -= (drcs.y + inkRect.top);
	//Converts the yMean wrt a form relative to the top of the guide box
	iYMean         -= drcs.y;

	// Scale.  We do isotropic scaling and center the shorter dimension.
	//Y Mean as a fraction of the guide box size
	iYMean = ((1000 * iYMean) / drcs.h);
	//Sees where the top of the ink is relative to the guide box height
	drcs.y = ((1000 * inkRect.top) / drcs.h);
	//The width of the ink relative to the guide box width
	drcs.w = ((1000 * inkRect.right) / drcs.h);
	//The height of the ink relative to the guide box height
	drcs.h = ((1000 * inkRect.bottom) / drcs.h);
	
	//Why would any of these conditions happen 
	if (drcs.y < 0) 
		drcs.y = 0;
	else if (drcs.y > 1000) 
		drcs.y = 1000;
	if (drcs.w < 0) 
		drcs.w = 0;
	else if (drcs.w > 1000) 
		drcs.w = 1000;
	if (drcs.h < 0) 
		drcs.h = 0;
	else if (drcs.h > 1000) 
		drcs.h = 1000;

	// 4 guide features

	//First feature--Top of the ink relative to the guide box height
	x = drcs.y;
	x = LSHFT(x)/1000;
	if (x >= 0x10000)
		x = 0xFFFF;
	*rgFeat++ = (unsigned short)x;

	//Second feature--Width of the ink relative to the guide box width
	x = drcs.w;
	x = LSHFT(x)/1000;
	if (x >= 0x10000)
		x = 0xFFFF;
	*rgFeat++ = (unsigned short)x;

	//Third feature--Bottom of the ink relative to the guide box height
	x = drcs.h;
	x = LSHFT(x)/1000;
	if (x >= 0x10000)
		x = 0xFFFF;
	*rgFeat++ = (unsigned short)x;

	//Fourth feature--The width of the ink relative to the sum of its width and height
	if (drcs.w <= 0)
		x = 0;
	else
	{
		x = drcs.w;
		x = LSHFT(x)/(drcs.w+drcs.h);
		if (x >= 0x10000)
			x = 0xFFFF;
	}
	*rgFeat++ = (unsigned short)x;

	//Fifth feature--the iYMean value relative to the guide box height

	// one more guide feature: y-CG
	if (iYMean < 0)
		iYMean = 0;
	else if (iYMean > 1000)
		iYMean = 1000;
	x = iYMean;
	x = LSHFT(x)/1000;
	if (x >= 0x10000)
		x = 0xFFFF;
	*rgFeat = (unsigned short)x;
	
	return 5;
}

/******************************Private*Routine******************************\
* SmoothPoints
*
* Given an array of points and a destination array, this function fills the
* destination array a smoothed version of the raw points.  Smoothing is
* done by local averaging ona window of 5 points with weights 1/8 1/4 1/4 1/4 1/8.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
void SmoothPoints(XY *rgSrc, XY *rgDst, int cXY)
{
   int i,j;

   for (i=0; i<cXY; i++)
   {
      j = cXY - i - 1;
      if (i < j) 
         j = i;

      switch (j) 
      {
      case 0: 
	  case 1: 
         *rgDst = *rgSrc;
         break;
	//+4 is added here so that rounding off takes place rather than truncation
      default:
            rgDst->x = (int)((
							   (rgSrc-2)->x              + 
							  ((rgSrc-1)->x         <<1) + 
							   (rgSrc->x            <<1) + 
							  ((rgSrc+1)->x         <<1) + 
							   (rgSrc+2)->x              +
							  4
                            ) >> 3);
            rgDst->y = (int)((
							   (rgSrc-2)->y              + 
							  ((rgSrc-1)->y         <<1) + 
							   (rgSrc->y            <<1) + 
							  ((rgSrc+1)->y         <<1) + 
							   (rgSrc+2)->y              +
							  4
                            ) >> 3);
         break;
      }
	  rgSrc++;
	  rgDst++;
   }

}

/******************************Private*Routine******************************\
* ComputeCurvedness
*
* Given a stroke, computes three curvature features--namely
*--The sum of the modular change in angle with respect to + and - for the angles
*--The total curviness of the stoke--just directly measure the change in angles.
*--The maximum change in angle that occurs in that stroke in one sampling distance
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
void ComputeCurvedness(XY *rgXY, int cXY, int iStepSizeSqr, int *pSum1, int *pSum2, int *pMaxAngle)
{
	int sum1, sum2;
	int x, y;
	XY *rgxy, *rgxySave;
	int ang, lastAng, diff, dx, dy;

	if (cXY <= 2)
	{
		*pSum1 = *pSum2 = 0;
		return;
	}
	
	// smooth points
	rgxySave = rgxy = (XY *) ExternAlloc(cXY*sizeof(XY));
	if (!rgxy)
	{
		*pSum1 = *pSum2 = 0;
		return;
	}
	SmoothPoints(rgXY, rgxy, cXY);

	sum1 = sum2 = 0;
	x = rgxy->x;
	y = rgxy->y;
	rgxy++;
	cXY--;
	// find first angle
	while (cXY)
	{
		dy = rgxy->y - y;
		dx = rgxy->x - x;
		if (dx*dx+dy*dy >= iStepSizeSqr)
		{ 
			//Function from common/mathx--returns the integer approx in degrees
			lastAng = Arctan2(dy, dx);
			cXY--;
			x = rgxy->x;
			y = rgxy->y;
			rgxy++;
			break;
		}
		cXY--;
		rgxy++;
	}
	// now find difference of every subsequent angle with its previous angle
	while (cXY)
	{
		dy = rgxy->y - y;
		dx = rgxy->x - x;
		if (dx*dx+dy*dy >= iStepSizeSqr)
		{
			ang = Arctan2(dy, dx);
			ANGLEDIFF(lastAng, ang, diff)
			sum1 += diff;
			if (diff < 0)
				diff = -diff;
			sum2 += diff;
			lastAng = ang;
			x = rgxy->x;
			y = rgxy->y;
			if (diff > *pMaxAngle)
				*pMaxAngle = diff;
		}
		cXY--;
		rgxy++;
	}

	// clean up
	ExternFree(rgxySave);
	*pSum1 = sum1;
	*pSum2 = sum2;
}

/******************************Private*Routine******************************\
* AddCurveFeatures
*
* Given an ink (one or more strokes), computes three curvature features.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
int AddCurveFeatures(GLYPH *pGlyph, int iStepSizeSqr, unsigned short *rgFeat)
{
	GLYPH *glyph;
	FRAME *frame;
	int cXY;
	XY *rgXY;
	int sum1=0, sum2=0, ang1, ang2, maxAngle=0;

	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		frame = glyph->frame;
		if (!IsVisibleFRAME(frame))
			continue;
		rgXY = RgrawxyFRAME(frame);
		cXY = CrawxyFRAME(frame);
		ASSERT(cXY > 0);
		//For each frame compute the curvedness
		ComputeCurvedness(rgXY, cXY, iStepSizeSqr, &ang1, &ang2, &maxAngle);
		//sum1 represents the sum of the modular change in angle(with respect to + and - for the angles
		sum1 += ang1;
		//sum2 represent the total curviness of the stoke--just directly measures the change in angles.
		sum2 += ang2;
	}

	// based on emperical obsevations, truncate sum1 between -1000 to 1000
	//    and sum2 between 0 and 1200  
	// (this results in no truncation in more than 99% cases)
	if (sum1 < -1000)
		sum1 = -1000;
	else if (sum1 > 1000)
		sum1 = 1000;
	if (sum2 < 0)
		sum2 = 0;
	else if (sum2 > 1200)
		sum2 = 1200;
	sum1 += 1000;  // now between 0 and 2000
	sum1 = LSHFT(sum1)/2000;
	if (sum1 > 0xFFFF)
		sum1 = 0xFFFF;
	sum2 = LSHFT(sum2)/1200;
	if (sum2 > 0xFFFF)
		sum2 = 0xFFFF;
	// maxAngle should be between 0 and 180
	if (maxAngle < 0)
		maxAngle = 0;
	else if (maxAngle > 180)
		maxAngle = 180;
	maxAngle = LSHFT(maxAngle)/180;
	if (maxAngle > 0xFFFF)
		maxAngle = 0xFFFF;

	*rgFeat++ = (unsigned short) sum1;
	*rgFeat++ = (unsigned short) sum2;
	*rgFeat   = (unsigned short) maxAngle;
	return 3;
}

/******************************Private*Routine******************************\
* AddStrokeCountFeature
*
* Defines a single feature derived from stroke count of a char.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
int AddStrokeCountFeature(int cStroke, unsigned short *rgFeat)
{
	int tmp = LSHFT(cStroke-1)/cStroke;
	*rgFeat++ = (unsigned short)tmp;
	return 1;
}

/******************************Private*Routine******************************\
* DoOneContour
*
* Once a contour has been found (defined by a sequence of values, X-values
* for left- or right-contour, Y-values for top- or bottom-contour), this function
* is called to fit a Chebychev polynomial to the contour generating 9 new
* features.
*
* The arg "contour" is of length GRIDSIZE.  The output features are filled in
* the arg rgFeat and the count of features generated is returned.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int DoOneContour(int *contour, unsigned short *rgFeat)
{
	int rgX[2*GRIDSIZE], *pX;  //The rgX array is of 2*GRIDSIZE because the Chebyshev function takes alternate array values
	int chby[10];
	int norm = 0;
	int dT, i;

	// copy points into required format
	pX = rgX;
	for (i=0; i<GRIDSIZE; i++)
	{
		int x;
		x = 2 * (*contour++);
		//We are now LSHFTing--this is the first place where the 16.16 format surfaces
		//Why do we have to make the value between -1 and +1 ?
		*pX++ = LSHFT(x-GRIDSIZE)/(GRIDSIZE);  // values are in the range -1 to +1
		pX++;
	}
	// fit a chebychev polynomial
	if (!LSCheby(rgX, GRIDSIZE, chby, 10))
	{
		ASSERT(0);
		return 0;
	}

	// find rms of coefficients
	//dT and norm are both in 16.16 notation
	for (i = 0; i < 10; ++i)
	{
		Mul16(chby[i], chby[i], dT)
        norm += dT;
	}
	norm = ISqrt(norm) << 8;
	if (norm < LSHFT(1))
		norm = LSHFT(1);//The normalization value should at least be 1

	// normalize coeffcients
    for (i = 0; i < 10; i++)
    {
		//Why this LSHFT(1) ??
		dT = Div16(chby[i], norm) + LSHFT(1);
		//Why this ??
		dT >>= 1;
		if (dT >= 0x10000)
			dT = 0xFFFF; //Fill it with 1's for the lower 16 bits
		else if (dT < 0)
			dT = 0;
		//Does converting to an unsigned short always take the lowest 16 bits ??
		*rgFeat++ = (unsigned short)dT;
    }
	return 10;
}

/******************************Private*Routine******************************\
* MakeLine
*
* Given a point in the GRIDSIZE x GRIDSIZE grid (bitmap) and given the 
* sequence of points so far, this function adds one or more points in a
* straight line joining the last point and the given point.  
*
* Returns the number of points added.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote it.
*  06-Oct-1997 -by- Angshuman Guha aguha
* Fixed a bug.
\**************************************************************************/
int MakeLine(BYTE x, BYTE y, BYTE *pX, BYTE *pY, int space)
{
	BYTE midx, midy;
	int ts1,ts2;
	int c, c2;

	if (space <= 0)
	{
		return 0;
	}
    ASSERT(x != *pX || y != *pY);
    if (Neighbor(*pX, x) && Neighbor(*pY, y))
    {
			ASSERT(x >= 0);
			ASSERT(x < GRIDSIZE);
	        ASSERT(y >= 0);
			ASSERT(y < GRIDSIZE);
        *++pX = x;
        *++pY = y;
        return 1;
    }
	ts1=(*pX+x)/2;
	ts2=(*pY+y)/2;
	midx = (BYTE) ts1;
	midy = (BYTE) ts2;

    c = MakeLine(midx, midy, pX, pY, space);
	if (!c)
		return 0;
	c2 = MakeLine(x, y, pX+c, pY+c, space-c);
	if (!c2)
		return 0;
    return c + c2;
}

/******************************Private*Routine******************************\
* AddContourFeatures
*
* Given a sequence of already-resampled points (pen-down strokes joined by
* intervening pen-up strokes) and the bounding rect for the ink, this function
* computes some contour features, fills up rgFeat with the features and
* returns the count of features computed.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote it.
*  06-Oct-1997 -by- Angshuman Guha aguha
* Fixed a bug.  Added Realloc for rgMappedX and rgMappedY.

  Comments added by Mango

  The idea of this function is to first map the points that we have to 2 GRIDSIZE*GRIDSIZE bitmap.
  Once the bitmap is made we use the contour features.
Explanation of the arguments to the function
pointinfo--Contains the strructure from which the points will be taken
pRect--pointer to the bounding rectangle of the original ink
rgFeat--This contains the finalk contour features
\**************************************************************************/
int AddContourFeatures(POINTINFO *pointinfo, RECT *pRect, unsigned short *rgFeat)
{
	//BYTE rgGrid[GRIDSIZE][GRIDSIZE];
	int xMin = pRect->left; //Stores the minimum value of x
	int yMin = pRect->top; //Stores the minimum value of y
	int xRange = pRect->right - xMin; //Stores the width of the bounding rectangle
	int yRange = pRect->bottom - yMin; //Stores the height of the bounding rectangle
	int range, xOrigin, yOrigin;//Range stores the greated of the xRange and yRange 
	int iPoint, *xy, *z, i, cMapped, cMappedMax; //cMapped stores the number of points that have been mapped. cMappedMAx--the max number of points that could be mapped
	BYTE *pMappedX, *pMappedY, *rgMappedX, *rgMappedY;//Since we are using BYTE * here,we are assuming that GRIDSIZE <256--a byte size
	int rgMaxX[GRIDSIZE], rgMinY[GRIDSIZE], rgMaxY[GRIDSIZE], lastz; //GRIDSIZE=32
    int lastx, lasty;
	int iRetValue;
	BYTE *pbTmpX = NULL, *pbTmpY = NULL;

	ASSERT(xRange > 0);
	ASSERT(yRange > 0);
//We want to map the points to a GRIDSIZE*GRIDSIZE bitmap--but at the same time we want to preserve the aspect ratio
//It xRange >yRange,then the xValues will span the whole of the bit map 
//The y values will not span the entire bit map--but will simply be centered on the bit map.This helps to preserve the aspect ratio

	if (xRange > yRange)
	{
		range = xRange;
		xOrigin = 0;
		yOrigin = (GRIDSIZE - GRIDSIZE*(yRange-1)/range) / 2;
	}
	else if (yRange > 1)
	{   //In this case the y will span the entire grid map.xOrigin is scaled according to the earlier comment 
		range = yRange;
		xOrigin = (GRIDSIZE - GRIDSIZE*(xRange-1)/range) / 2;
		yOrigin = 0;
	}
	else // xRange == yRange == 1
	{ //In this case the Ink will be centered
		range = 1;
		xOrigin = GRIDSIZE/2;
		yOrigin = GRIDSIZE/2;
	}

	// make list of grid points which will make up the binary pixel map--we will map only the pen down points
	
	//Initialize the pointers to the raw points
	xy = pointinfo->xy;
	z = pointinfo->z;
	

	//In case there is a continuation of a line,then the bit map should not have any vacant spaces in the grid
	//connecting the points of the line.Hence we add extra space by 2*GRIDSIZE in case we need to connect the points
	//cMappedMax represents the maximum number of points that will be mapped
	
	cMappedMax = 2*(pointinfo->cPoint+GRIDSIZE);
	rgMappedX = (BYTE *) ExternAlloc(cMappedMax*sizeof(BYTE));
	rgMappedY = (BYTE *) ExternAlloc(cMappedMax*sizeof(BYTE));
	if (!rgMappedX || !rgMappedY)
	{
		//Allocatation failed.FLEE !!
		ASSERT(0);
		iRetValue = 0;
		goto cleanup;
	}
	cMapped = 0; //This contains the total number of points that have been mapped
	//The pointer to which it has been initialized is one less than the actual start.
	//Hence need to use an increment operator prior to using the first time.
	//After that the pointer always points to the last value that was allocated

	pMappedX = rgMappedX - 1;
	pMappedY = rgMappedY - 1;
	lastz = PEN_UP_VALUE;
	for (iPoint=0; iPoint<pointinfo->cPoint; iPoint++)
	{
		int xRaw, yRaw, x, y, zRaw;
		// get point
		xRaw = *xy++;
		yRaw = *xy++;
		zRaw = *z++;
		z++;
		if (zRaw > 0) // pen-down point
		{
			// map x to grid
			x = xOrigin + GRIDSIZE*(xRaw - xMin)/range;
			ASSERT(x >= 0);
			ASSERT(x < GRIDSIZE);
			// map y to grid
			y = yOrigin + GRIDSIZE*(yRaw - yMin)/range;
			ASSERT(y >= 0);
			ASSERT(y < GRIDSIZE);
			// save this point in the list
			if (lastz < 0)
			{
				if (cMapped==cMappedMax)
				{  //If the max space has already been used up then we ned to realloc.
					cMappedMax *= 2;
					pbTmpX = ExternRealloc(rgMappedX, cMappedMax*sizeof(BYTE));
					if (!pbTmpX)
					{
						ASSERT(0);
						iRetValue = 0;
						goto cleanup;
					}
					rgMappedX = pbTmpX;
					pMappedX = rgMappedX - 1 + cMapped;

					pbTmpY = ExternRealloc(rgMappedY, cMappedMax*sizeof(BYTE));
					if (!pbTmpY)
					{
						ASSERT(0);
						iRetValue = 0;
						goto cleanup;
					}
					rgMappedY = pbTmpY;
					pMappedY = rgMappedY - 1 + cMapped;
				}

				// first point of a stroke
				*++pMappedX = (BYTE)x;
				*++pMappedY = (BYTE)y;
				cMapped++;
			}
			else if (x != *pMappedX || y != *pMappedY)
			{
				// next unique mapped point
				//i contains the count of the number of points that have been added thru MakeLine
				ASSERT(*pMappedX < GRIDSIZE);
				ASSERT(*pMappedY <GRIDSIZE);
				ASSERT(*pMappedX >=0);
				ASSERT(*pMappedY >=0);


				while (!(i = MakeLine((BYTE)x, (BYTE)y, pMappedX, pMappedY, cMappedMax - cMapped)))
				{
					// these reallocs happen on 0.4% of the samples of gtrain02.ste (1860 of 443292 samples)
					cMappedMax *= 2;
					pbTmpX = ExternRealloc(rgMappedX, cMappedMax*sizeof(BYTE));
					if (!pbTmpX)
					{
						ASSERT(0);
						iRetValue = 0;
						goto cleanup;
					}
					rgMappedX = pbTmpX;
					pMappedX = rgMappedX - 1 + cMapped;

					pbTmpY = ExternRealloc(rgMappedY, cMappedMax*sizeof(BYTE));
					if (!pbTmpY)
					{
						ASSERT(0);
						iRetValue = 0;
						goto cleanup;
					}
					rgMappedY = pbTmpY;
					pMappedY = rgMappedY - 1 + cMapped;
				}

				//Increment the count of mapped points by the number of points that have been added.
				cMapped += i;
				ASSERT(cMapped <=cMappedMax);
				//Increment the pointers accordingly
				pMappedX += i;
				pMappedY += i;
			}
		} // if zRaw > 0
		lastz = zRaw;
	} // for iPoint=0

	// now dump the mapped point list into the grid, deleting redundant points along the way
	//memset(rgGrid, 0, sizeof(rgGrid));
	for (i=0; i<GRIDSIZE; i++)
	{
		rgMaxX[i] = -1;
		rgMinY[i] = GRIDSIZE;
		rgMaxY[i] = -1;
	}
	pMappedX = rgMappedX;
	pMappedY = rgMappedY;
	for (iPoint=0; iPoint<cMapped; iPoint++)
	{
		int x, y;
	
		x = *pMappedX++;
		y = *pMappedY++;


	    if (iPoint > 0 && iPoint < cMapped-1)
	    {
			int nextx = *pMappedX;
			int nexty = *pMappedY;
	        if (Neighbor(lastx, nextx) &&
	            Neighbor(lasty, nexty) &&
				lastx != nextx &&
				lasty != nexty)
	            continue;
	    }
	    lastx = x;
	    lasty = y;
	   
		//rgGrid[x][y]=1;
		ASSERT(x >= 0);
		ASSERT(x < GRIDSIZE);
		ASSERT(y >= 0);
		ASSERT(y < GRIDSIZE);
		if (x > rgMaxX[y])
			rgMaxX[y] = x;
		if (y < rgMinY[x])
			rgMinY[x] = y;
		if (y > rgMaxY[x])
			rgMaxY[x] = y;
	}

	// now Chebychev'ize the three contours

	// right contour
	rgFeat += DoOneContour(rgMaxX, rgFeat);
	// top contour
	rgFeat += DoOneContour(rgMinY, rgFeat);
	// bottom contour
	rgFeat += DoOneContour(rgMaxY, rgFeat);

	iRetValue = 30;
cleanup:		// Clean up temp space

	if (rgMappedX)
		ExternFree(rgMappedX);
	if (rgMappedY)
		ExternFree(rgMappedY);

	return iRetValue;
}

/******************************Private*Routine******************************\
* NormalizeCheby
*
* Routine to normalize the three (x, y and z) Chebychev polynomials.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Wrote this comment.
\**************************************************************************/
void NormalizeCheby(int *chbyX, int *chbyY, int *chbyZ, unsigned short *rgFeat)
{
	int norm = 0;
	int dT;
	int cFeat = 0, i;
	//The norm is applied both to x and y prior to dividing,so that the relative sizes of x and y can be kept intact
	// 
	for (i = 1; i < XCHB; ++i)  // 1st X coeff skipped
	{
		Mul16(chbyX[i], chbyX[i], dT)
        norm += dT;
	}
	for (i = 1; i < YCHB; ++i)  // 1st Y coeff skipped
	{
		Mul16(chbyY[i], chbyY[i], dT)
        norm += dT;
	}
	norm = ISqrt(norm) << 8;
	if (norm < LSHFT(1))
		norm = LSHFT(1);

	for (i=1; i<XCHB; i++)
	{
		dT = Div16(chbyX[i], norm) + LSHFT(1);  // now between 0 and 2
		dT >>= 1;  // now between 0 and 1
		if (dT >= 0x10000)
			dT = 0xFFFF;
		else if (dT < 0)
			dT = 0;
		rgFeat[cFeat++] = (unsigned short)dT;
	}

	for (i=1; i<YCHB; i++)
	{
		dT = Div16(chbyY[i], norm) + LSHFT(1);
		dT >>= 1;
		if (dT >= 0x10000)
			dT = 0xFFFF;
		else if (dT < 0)
			dT = 0;
		rgFeat[cFeat++] = (unsigned short)dT;
	}

    // Z
    norm = 0;
	for (i = 0; i < 8; ++i)
	{
		Mul16(chbyZ[i], chbyZ[i], dT)
        norm += dT;
	}
	norm = ISqrt(norm) << 8;
	if (norm < LSHFT(1))
		norm = LSHFT(1);

    for (i = 0; i < 8; i++)
    {
		dT = Div16(chbyZ[i], norm) + LSHFT(1);
		dT >>= 1;
		if (dT >= 0x10000)
			dT = 0xFFFF;
		else if (dT < 0)
			dT = 0;
		rgFeat[cFeat++] = (unsigned short)dT;
    }
	ASSERT(cFeat == 26);
}

/******************************Public*Routine******************************\
* SoleFeaturize
*
* The top-level routine for featurizing ink for a char.
*
* History:
*  26-Sep-1997 -by- Angshuman Guha aguha
* Modified it.
\**************************************************************************/
BOOL SoleFeaturize(GLYPH *pGlyph, RECT *pGuide, unsigned short *rgFeat)
{
	int cStroke, iStroke;
    int iPoint;
    int sumX, sumY, sum;
    double totvar;
    int var;
	int isumX, isumY;//These store the mean values of x and y
    int chbyX[IMAXCHB], chbyY[IMAXCHB], chbyZ[IMAXCHB]; 
	int retVal = 1;
	XY *rgXY, lastXY;
	int cXY, iXY, dx, dy, t;
	GLYPH *glyph;
	FRAME *frame;
	int ydev; //Stores the ydev value used for storing the step size
	POINTINFO pointinfo;
	RECT rect;

	// compute cStroke
	for (cStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		frame = glyph->frame;
		if (!IsVisibleFRAME(frame))
			continue;
		cXY = CrawxyFRAME(frame);
		ASSERT(cXY > 0);
		cStroke++;
	}

	if (cStroke < 1)
		return 0;

	// compute step size--originally this was done using the box height
//	pointinfo.iStepSize = pGuide->cyBox*3/200; // 1.5% of box height
	


	ydev= YDeviation(pGlyph);
	if (ydev < 1)
		ydev = 1;  // a "-" or a "."
	//The step size is computed from the ydev value
	pointinfo.iStepSize =  ydev/5; 

	if (pointinfo.iStepSize < 2)
		pointinfo.iStepSize = 2;
	pointinfo.iStepSizeSqr = pointinfo.iStepSize * pointinfo.iStepSize;

	// estimate total count of points
	pointinfo.cPointMax = 1;  // make sure it does not end up being zero
	for (iStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		frame = glyph->frame;
		if (!IsVisibleFRAME(frame))
			continue;
		rgXY = RgrawxyFRAME(frame);
		cXY = CrawxyFRAME(frame);
		ASSERT(cXY > 0);

		sum = 0;
		for (iXY=1; iXY<cXY; iXY++)
		{
			dx = rgXY[iXY].x - rgXY[iXY-1].x;
			if (dx < 0)
				dx = -dx;
			dy = rgXY[iXY].y - rgXY[iXY-1].y;
			if (dy < 0)
				dy = -dy;
			if (dx > dy)
				sum += dx;
			else
				sum += dy;
		}

		//The sum that we are computing here is an underestimate--we are only taking the max on |x| or |y|.The distance will
		// be more
		pointinfo.cPointMax += sum/pointinfo.iStepSize;

		// if not first stroke simulate pen-up stroke
		if (iStroke)
		{
			dx = lastXY.x - rgXY->x;
			dy = lastXY.y - rgXY->y;
			t = ISqrt(dx*dx + dy*dy)/pointinfo.iStepSize;
			if (t >= 2)
				pointinfo.cPointMax += t-1;
		}
		lastXY = rgXY[cXY-1];
		iStroke++;
	}

	//Since we have computed an underestimate multiply by two
	pointinfo.cPointMax *= 2;

	// allocate space
	pointinfo.xy = (int *) ExternAlloc(2*pointinfo.cPointMax*sizeof(int));
	if (!pointinfo.xy)
		return 0;

	//The array size for z is double of what actually needs to be allocated because-
	//--the chebyshev function expects the array to be spaced in this manner
	//--indexing is easier in the functions--can exactly mirror what you do for the x and y
	pointinfo.z = (int *) ExternAlloc(2*pointinfo.cPointMax*sizeof(int));
	if (!pointinfo.z)
	{
		ExternFree(pointinfo.xy);
		return 0;
	}

    // join all strokes into one stream
    pointinfo.cPoint = 0;
	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		frame = glyph->frame;
		if (!IsVisibleFRAME(frame))
			continue;
		rgXY = RgrawxyFRAME(frame);
		cXY = CrawxyFRAME(frame);
        for (iXY = 0; iXY < cXY; iXY++)
            if (!AddPoint(&pointinfo, rgXY[iXY].x, rgXY[iXY].y, !iXY))
			{
				retVal = 0;
				goto freeReturn;
			}
	}

	// contour features (computed from resampled raw points)
	GetRectGLYPH(pGlyph, &rect);

	//PLEASE NOTE--rgFeat is unsigned short.Its value comes from the lower 16 bits of the 16.16 format that had been defined earlier.
	rgFeat += AddContourFeatures(&pointinfo, &rect, rgFeat);

	//IS there any reason why the mean and the variance has been subtracted only AFTER the contour features ??Maybe because there we are dumping to a bit map ??

    // compute X-mean and Y-mean
    sumX = sumY = 0;
	for (iPoint=0; iPoint<2*pointinfo.cPoint; iPoint+=2)
	{
		sumX += pointinfo.xy[iPoint] - rect.left;
		sumY += pointinfo.xy[iPoint+1] - rect.top;
	}
	//isumX and isumY represent the mean values of the x and y coordinates.
	isumX = (sumX / pointinfo.cPoint) + rect.left;
	isumY = (sumY / pointinfo.cPoint) + rect.top;

    // shift points by means
	for (iPoint=0; iPoint<2*pointinfo.cPoint; iPoint+=2)
	{
		pointinfo.xy[iPoint] -= isumX;
		pointinfo.xy[iPoint+1] -= isumY;
	}

    // compute variance
	totvar = 0;
	for (iPoint=0; iPoint<2*pointinfo.cPoint; iPoint++)
    {
		totvar += (double) pointinfo.xy[iPoint] * (double) pointinfo.xy[iPoint];
    }
	var = (int) sqrt(totvar/pointinfo.cPoint);
	if (var < 1)
		var = 1;

    // scale points by standard deviation


	// From this point on,the pointinfo values are in 16.16
	//IMPORTTANT NOTE---THE pointinfo array is not directly used after this point
	//If it is,you will have to use 16.16 arithmetic

	for (iPoint=0; iPoint<2*pointinfo.cPoint; iPoint++)
	{
		pointinfo.xy[iPoint] = LSHFT(pointinfo.xy[iPoint])/var;
	}
	//Basically,since we effectively have a normal distribution(hopefully)most of the values will be between +-3.
    // chebychev'ize!
	if (!LSCheby(pointinfo.xy, pointinfo.cPoint, chbyX, XCHB))
	{
		retVal = 0;
		goto freeReturn;
	}
	if (!LSCheby(pointinfo.xy+1, pointinfo.cPoint, chbyY, YCHB))
	{
		retVal = 0;
		goto freeReturn;
	}
	if (!LSCheby(pointinfo.z, pointinfo.cPoint, chbyZ, ZCHB))
	{
		retVal = 0;
        goto freeReturn;
	}

	NormalizeCheby(chbyX, chbyY, chbyZ, rgFeat);
	rgFeat += 26;

	// stroke count feature--1 feature is added
	rgFeat += AddStrokeCountFeature(cStroke, rgFeat);

	// guide features
	//The rect had been comptured prior to scaling the points --by mean and standard deviation
	//isumY represents the mean Y value
	//We add 5 guide features
	rgFeat += AddGuideFeatures(pGuide, &rect, isumY, rgFeat);
	
	// curved-ness features
	//Note the original glyph is being passed here
	//Why not simply use the sampled points ??
	rgFeat += AddCurveFeatures(pGlyph, pointinfo.iStepSizeSqr, rgFeat);

freeReturn:
	ExternFree(pointinfo.xy);
    ExternFree(pointinfo.z);
	return retVal;
}

/*
void DumpFeatures (unsigned short *pFeat)
{
	static	int c = 0;
	static FILE *fp = NULL;
	int			i, cMap;

	if (!fp)
	{
		fp	=	fopen ("feat.dmp", "wt");
		if (!fp)
			return;
	}

	cMap	=	sizeof (s_aaMap) / sizeof (s_aaMap[0]);
	for (i = 0; i < cMap; i++)
	{
		if (s_aaMap[i] == s_wch)
			break;
	}

	if (i == cMap)
		return;

	fprintf (fp, "%d\t", i + 1);

	for (i = 0; i < 65; i++)
	{
		fprintf (fp, "%d%c",
			pFeat[i],
			i == 64 ? '\n' : ' ');
	}

	fflush (fp);

	c++;
}
*/

#pragma optimize("",off)

int SoleNN(SOLE_LOAD_INFO *pSole, int cStrk, unsigned short *pFeat, ALT_LIST *pAlt)
{
	RREAL			*pNetMem, *pNetOut;
	int				iWinner, cOut;
	int				i, j, k;
    int             *pIndex;
    wchar_t         *pwchMap;
    
    pAlt->cAlt = -1;

	if (cStrk == 1)
	{
		pNetMem = ExternAlloc(pSole->iNet1Size * sizeof (*pNetMem));
		if (!pNetMem)
			return -1;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = pFeat[i];
		}

		pNetOut = runLocalConnectNet(&pSole->net1, pNetMem, &iWinner, &cOut);
        pwchMap = pSole->pMap1;
	}
	else
	{
		pNetMem = ExternAlloc(pSole->iNet2Size * sizeof (*pNetMem));
		if (!pNetMem)
			return -1;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = pFeat[i];
		}

		pNetOut = runLocalConnectNet(&pSole->net2, pNetMem, &iWinner, &cOut);
        pwchMap = pSole->pMap2;
	}

    pIndex = ExternAlloc(sizeof(int) * cOut);
    if (pIndex == NULL) 
    {
        ExternFree(pNetMem);
        return -1;
    }
    for (i = 0; i < cOut; i++)
    {
        pIndex[i] = i;
    }

	for (i = 0; i < MAX_ALT_LIST; i++)
	{
		for (j = i + 1; j < cOut; j++)
		{
			if (pNetOut[pIndex[i]] < pNetOut[pIndex[j]])
			{
				k		    =	pIndex[i];
				pIndex[i]	=	pIndex[j];
				pIndex[j]	=	k;
			}
		}

        if (pNetOut[pIndex[i]] == 0)
        {
            break;
        }
		pAlt->awchList[i]	= pwchMap[pIndex[i]];
		pAlt->aeScore[i]	= (float) pNetOut[pIndex[i]] / (float) SOFT_MAX_UNITY;
	}

	//DumpFeatures (pFeat);

    // If the following line is compiled with optimization turned on,
    // the VS6 compiler goes into an infinite loop.
	pAlt->cAlt = i;

    ExternFree(pIndex);
    ExternFree(pNetMem);
	return pAlt->cAlt;
}

#pragma optimize("",on)

int SoleMatch(SOLE_LOAD_INFO *pSole,
              ALT_LIST *pAlt, int cAlt, GLYPH *pGlyph, RECT *pGuide, CHARSET *pCS, LOCRUN_INFO * pLocRunInfo)
{
	int				cStrk;
    unsigned short	aiSoleFeat[SOLE_NUM_FEATURES];

	cStrk	=	CframeGLYPH (pGlyph);

	if (SoleFeaturize(pGlyph, pGuide, aiSoleFeat) != 1)
	{
		return -1;
	}

	return SoleNN (pSole, cStrk, aiSoleFeat, pAlt);
}

static void AddChar(wchar_t *pwchTop1, float *pflTop1, ALT_LIST *pAltList, wchar_t dch, float flProb,
                    LOCRUN_INFO *pLocRunInfo, CHARSET *pCS)
{
    int j;
    for (j = 0; j < (int) pAltList->cAlt; j++) 
    {
        if (pAltList->awchList[j] == dch)
        {
            pAltList->aeScore[j] = flProb;
        }
    }
    if (flProb > 0)
    {
		// Check whether the character (or folding set) passes the filter, 
		// if so see if it is the new top 1.
        if (IsAllowedChar(pLocRunInfo, pCS, dch))
        {
            if (*pwchTop1 == 0xFFFE || flProb > *pflTop1) 
            {
                *pflTop1 = flProb;
                *pwchTop1 = dch;
            }
		} 
    }
}

int SoleMatchRescore(SOLE_LOAD_INFO *pSole,
              wchar_t *pwchTop1, float *pflTop1, 
              ALT_LIST *pAltList, int cAlt, GLYPH *pGlyph, RECT *pGuide, 
              CHARSET *pCharSet, LOCRUN_INFO *pLocRunInfo)
{
   	int	i;
	int				cStrk;
	
	RREAL			*pNetMem, *pNetOut;
	int				iWinner, cOut;
	int				j;
    wchar_t         *pwchMap;

    unsigned short	aiSoleFeat[SOLE_NUM_FEATURES];

    // First set all the scores to zero.  This is because some code points Fugu
    // supports may not be supported by Sole.  This implicitly says Sole gives
    // them a score of zero.
    for (j = 0; j < (int) pAltList->cAlt; j++) 
    {
        pAltList->aeScore[j] = 0;
    }

    *pflTop1 = 0;
    *pwchTop1 = 0xFFFE;

	cStrk	=	CframeGLYPH (pGlyph);

	if (SoleFeaturize (pGlyph, pGuide, aiSoleFeat) != 1)
	{
		return pAltList->cAlt;
	}

	if (cStrk == 1)
	{
		pNetMem = ExternAlloc(pSole->iNet1Size * sizeof (*pNetMem));
		if (!pNetMem)
			return -1;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = aiSoleFeat[i];
		}

		pNetOut = runLocalConnectNet(&pSole->net1, pNetMem, &iWinner, &cOut);
        pwchMap = pSole->pMap1;
	}
	else
	{
		pNetMem = ExternAlloc(pSole->iNet2Size * sizeof (*pNetMem));
		if (!pNetMem)
			return -1;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = aiSoleFeat[i];
		}

		pNetOut = runLocalConnectNet(&pSole->net2, pNetMem, &iWinner, &cOut);
        pwchMap = pSole->pMap2;
	}

    // This is the version for Fugu trained on dense codes, which will usually be
	// what we use.  Loops over the outputs
	for (i = 0; i < cOut; i++) 
    {
		wchar_t fdch = pwchMap[i];
        float flProb = (float) pNetOut[i] / (float) SOFT_MAX_UNITY;
#if 1
        AddChar(pwchTop1, pflTop1, pAltList, fdch, flProb, pLocRunInfo, pCharSet);
#else
        if (LocRunIsFoldedCode(pLocRunInfo, fdch))
        {
			// If it is a folded code, look up the folding set
			wchar_t *pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, fdch);

			// Run through the folding set, adding non-NUL items to the output list
			// (until the output list is full)
			for (j = 0; j < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[j] != 0; j++)
            {
                AddChar(pwchTop1, pflTop1, pAltList, pFoldingSet[j], flProb, pLocRunInfo, pCharSet);
			}
        }
        else
        {
            AddChar(pwchTop1, pflTop1, pAltList, fdch, flProb, pLocRunInfo, pCharSet);
        }
#endif
	}

    ExternFree(pNetMem);

	return pAltList->cAlt;
}

BOOL SoleLoadPointer(SOLE_LOAD_INFO *pSole, LOCRUN_INFO *pLocRunInfo)
{
    NNET_HEADER			*pHeader;
	NNET_SPACE_HEADER	*apSpcHeader[2];

    pHeader = (NNET_HEADER *) pSole->info.pbMapping;

	// check version and signature
	ASSERT (pHeader->dwFileType == SOLE_FILE_TYPE);

	ASSERT (pHeader->iFileVer >= SOLE_OLD_FILE_VERSION);
    ASSERT (pHeader->iMinCodeVer <= SOLE_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

    if (pHeader->dwFileType != SOLE_FILE_TYPE || 
        pHeader->adwSignature[0] != pLocRunInfo->adwSignature[0] ||
        pHeader->adwSignature[1] != pLocRunInfo->adwSignature[1] ||
        pHeader->adwSignature[2] != pLocRunInfo->adwSignature[2] ||
        pHeader->iFileVer < SOLE_OLD_FILE_VERSION ||
	    pHeader->iMinCodeVer > SOLE_CUR_FILE_VERSION)
    {
        return FALSE;
    }

	// # of spaces has to be two
	ASSERT (pHeader->cSpace == 2);

	apSpcHeader[0]	=	
		(NNET_SPACE_HEADER *) (pSole->info.pbMapping + sizeof (NNET_HEADER));

	apSpcHeader[1]	=	
		(NNET_SPACE_HEADER *) (	pSole->info.pbMapping + sizeof (NNET_HEADER) + 
								sizeof (NNET_SPACE_HEADER));

    if (restoreLocalConnectNet	(	pSole->info.pbMapping + apSpcHeader[0]->iDataOffset, 
									0, 
									&pSole->net1
								) == NULL
		)
    {
        return FALSE;
    }

	if (restoreLocalConnectNet	(	pSole->info.pbMapping + apSpcHeader[1]->iDataOffset, 
									0, 
									&pSole->net2
								) == NULL
		)
    {
        return FALSE;
    }

    pSole->iNet1Size = 
		getRunTimeNetMemoryRequirements(pSole->info.pbMapping + apSpcHeader[0]->iDataOffset);

    pSole->iNet2Size = 
		getRunTimeNetMemoryRequirements(pSole->info.pbMapping + apSpcHeader[1]->iDataOffset);

    pSole->pMap1 = (wchar_t *) (pSole->info.pbMapping + apSpcHeader[0]->iMapOffset);
    pSole->pMap2 = (wchar_t *) (pSole->info.pbMapping + apSpcHeader[1]->iMapOffset);

    return TRUE;
}

BOOL SoleLoadRes(SOLE_LOAD_INFO *pSole, HINSTANCE hInst, int nResID, int nType, LOCRUN_INFO *pLocRunInfo)
{
    if (DoLoadResource(&pSole->info, hInst, nResID, nType) == NULL)
    {
        return FALSE;
    }
    return SoleLoadPointer(pSole, pLocRunInfo);
}

BOOL SoleLoadFile(SOLE_LOAD_INFO *pSole, wchar_t *wszRecogDir, LOCRUN_INFO *pLocRunInfo)
{
    wchar_t wszName[MAX_PATH];
    FormatPath(wszName, wszRecogDir, NULL, NULL, NULL, L"sole.bin");  
    if (DoOpenFile(&pSole->info, wszName) == NULL)
    {
        return FALSE;
    }
    return SoleLoadPointer(pSole, pLocRunInfo);
}

BOOL SoleUnloadFile(SOLE_LOAD_INFO *pSole)
{
    return DoCloseFile(&pSole->info);
}

#if 0

BOOL SoleReject (int cStrk, wchar_t wchDense)
{
	RREAL			*pNetMem, *pNetOut;
	int				iWinner, cOut;
	int				i;

	if (cStrk == 1)
	{
		pNetMem = _alloca(s_iSoleRejNetSize1 * sizeof (*pNetMem));
		if (!pNetMem)
			return FALSE;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = s_aSoleFeat[i];
		}

		pNetOut = runLocalConnectNet(&s_SoleRejNet1, pNetMem, &iWinner, &cOut);

		ASSERT (cOut == SOLE_OUT_1);

		return s_aaMap[0][iWinner] != LocRunDense2Unicode (&g_locRunInfo, wchDense);
	}
	else
	{
		pNetMem = _alloca(s_iSoleRejNetSize2 * sizeof (*pNetMem));
		if (!pNetMem)
			return FALSE;

		for (i = 0; i < SOLE_NUM_FEATURES; i++)
		{
			pNetMem[i] = s_aSoleFeat[i];
		}

		pNetOut = runLocalConnectNet(&s_SoleRejNet2, pNetMem, &iWinner, &cOut);

		ASSERT (cOut == SOLE_OUT_2);

		return s_aaMap[1][iWinner] != LocRunDense2Unicode (&g_locRunInfo, wchDense);
	}
}

extern wchar_t	s_wch;

void SaveRecoInfo (wchar_t wch)
{
	static FILE *fp	=	NULL;

	if (!fp)
	{
		fp	=	fopen ("recores.txt", "wt");

		if (!fp)
			return;
	}

	fprintf (fp, "%d\n", wch == s_wch);
	fflush (fp);
}

#define JAWS_ALT	10

int	GetCharID (int cStrk, wchar_t wch)
{
	int	i, cClass;

	cClass	=	(cStrk == 1 ? SOLE_OUT_1 : SOLE_OUT_2);

	for (i = 0; i < cClass; i++)
	{
		if (s_aaMap[cStrk - 1][i] == wch)
			return i;
	}

	return -1;
}

void SaveJAWSInfo (LATTICE *pLat)
{
	static FILE			*fpDisagree1	= NULL, *fpDisagree2	= NULL, 
						*fpSole1		= NULL, *fpSole2		= NULL;

	FILE				*fp, *fpSole;
	int					i, iWinningCand, iSoleBest, cAlt, j, cProbAlt, cStrk, cSoleOut, iClass;
	LATTICE_ALT_LIST	*pAlt;
	int					aSoleCost[JAWS_ALT];
	wchar_t				wch;
	RECOG_ALT			aProbAlt[JAWS_ALT];
	BOXINFO				box;
	RECT				bbox;
	RECT				rGuide;
	GLYPH				*pGlyph;
	
	if (!pLat->fUseGuide)
		return;

	if (!fpDisagree1)
	{
		fpDisagree1	=	fopen ("jawsdis1.txt", "wt");

		if (!fpDisagree1)
			return;
	}
	
	if (!fpDisagree2)
	{
		fpDisagree2	=	fopen ("jawsdis2.txt", "wt");

		if (!fpDisagree2)
			return;
	}

	if (!fpSole1)
	{
		fpSole1	=	fopen ("sole1.txt", "wt");

		if (!fpSole1)
			return;
	}

	if (!fpSole2)
	{
		fpSole2	=	fopen ("sole2.txt", "wt");

		if (!fpSole2)
			return;
	}

	// find out if the right answer is in the list
	iWinningCand		=	
	iSoleBest			=	-1;
	pAlt				=	pLat->pAltList + pLat->nStrokes - 1;
	cAlt				=	pAlt->nUsed;

	// This is a temporary call to get probs directly, until we have Hawk.
	cProbAlt	= GetProbsTsunami(pLat->nStrokes, pAlt, JAWS_ALT, aProbAlt);

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.
	pGlyph	= GlyphFromStrokes(pLat->nStrokes, pLat->pStroke);
	if (!pGlyph) 
	{
		return;
	}

	cStrk	=	pLat->nStrokes;

	// Get the bounding box for the character
	GetRectGLYPH(pGlyph, &bbox);

	// Free the glyph structure.
	DestroyFramesGLYPH(pGlyph);
	DestroyGLYPH(pGlyph);

	rGuide = GetGuideDrawnBox(&pLat->guide, pLat->pStroke[pLat->nStrokes - 1].iBox);

	// Build up a BOXINFO structure from the guide, for use in the baseline/height scoring
	box.size		= rGuide.bottom - rGuide.top;
	box.baseline	= rGuide.bottom;
	box.xheight		= box.size / 2;
	box.midline		= box.baseline - box.xheight;
	
	cSoleOut	=	(cStrk == 1 ? SOLE_OUT_1 : SOLE_OUT_2);

	for (i = 0; i < cAlt && i < JAWS_ALT; i++)
	{
		wch	=	LocRunDense2Unicode(&g_locRunInfo, pAlt->alts[i].wChar);

		if (wch == s_wch)
		{
			iWinningCand = i;
		}

		// sole cost
		for (j = 0; j < cSoleOut; j++)
		{
			if (s_aaMap[cStrk -1][j] == wch)
			{
				break;
			}
		}

		if (j == cSoleOut)
		{
			aSoleCost[i]	=	0xFFFF;
		}
		else
		{
			aSoleCost[i]	=	(0xFFFF * s_aSoleOut[j]) / SOFT_MAX_UNITY;
			aSoleCost[i]	=	0xFFFF - aSoleCost[i];
		}
		
		if (iSoleBest == -1 || aSoleCost[iSoleBest] > aSoleCost[i])
		{
			iSoleBest	=	i;
		}
	}

	for (i = cAlt; i < JAWS_ALT; i++)
	{
		aSoleCost[i]	=	0xFFFF;
	}

	if (iWinningCand == -1)
		return;

	if (cStrk == 1)
	{
		fpSole	=	fpSole1;
	}
	else
	{
		fpSole	=	fpSole2;
	}

	// do not run if sole and otter agree
	if (!SoleReject (cStrk, pAlt->alts[0].wChar))
	{
		return;
	}
	else
	{
		if (cStrk == 1)
		{
			fp		=	fpDisagree1;
		}
		else
		{
			fp		=	fpDisagree2;
		}
	}

	fprintf (fp, "{ ");

	// write the alternate features
	for (i = 0; i < cAlt && i < JAWS_ALT; i++)
	{
		int		iOttCost, iUni;
		float	fCost;

		wch	=	LocRunDense2Unicode(&g_locRunInfo, pAlt->alts[i].wChar);

		// otter cost
		iOttCost	=	min (0xFFFF, (int)(-pAlt->alts[i].logProbPath * 1000));
		fprintf (fp, "%d ", iOttCost);

		// sole cost
		fprintf (fp, "%d ", aSoleCost[i]);

		// unigram cost
		iUni	= (int)(-255 * 100 * UnigramCost(&g_unigramInfo, pAlt->alts[i].wChar));
		iUni	= min (0xFFFF, iUni);
		
		fprintf (fp, "%d ", iUni);

		// baseline trans cost
		fCost = BaselineTransitionCost(0, bbox, &box, pAlt->alts[i].wChar, bbox, &box);
		fprintf (fp, "%d ", min (0xFFFF, (int) (-100000.0 * fCost)));

		// base line cost
		fCost = BaselineBoxCost(pAlt->alts[i].wChar, bbox, &box);
		fprintf (fp, "%d ", min (0xFFFF, (int) (-100000.0 * fCost)));

		// height trans cost
		fCost = HeightTransitionCost(0, bbox, &box, pAlt->alts[i].wChar, bbox, &box);
		fprintf (fp, "%d ", min (0xFFFF, (int) (-100000.0 * fCost)));

		// height cost
		fCost = HeightBoxCost(pAlt->alts[i].wChar, bbox, &box);
		fprintf (fp, "%d ", min (0xFFFF, (int) (-100000.0 * fCost)));
				
		// describe the codepoint
		// is it a digit
		if (wch >= L'0' && wch <= '9')
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}

		// is alpha
		if ((wch >= L'a' && wch <= 'z') || (wch >= L'A' && wch <= 'Z'))
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}

		// is punct
		if (iswpunct (wch))
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}

		// is hiragana
		if (wch >= 0x3040 && wch <= 0x309f)
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}

		// is katakana
		if (wch >= 0x30a0 && wch <= 0x30ff)
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}

		// is kanji
		if (wch >= 0x3190 && wch <= 0xabff)
		{
			fprintf (fp, "65535 ");
		}
		else
		{
			fprintf (fp, "0 ");
		}
	}

	// the rest of the candidates
	for (i = cAlt; i < JAWS_ALT; i++)
	{
		// otter cost
		fprintf (fp, "%d ", 0xFFFF);

		// sole cost
		fprintf (fp, "%d ", 0xFFFF);

		// unigram cost
		fprintf (fp, "%d ", 0xFFFF);

		// baseline trans cost
		fprintf (fp, "%d ", 0xFFFF);

		// baseline cost
		fprintf (fp, "%d ", 0xFFFF);

		// height trans cost
		fprintf (fp, "%d ", 0xFFFF);

		// height cost
		fprintf (fp, "%d ", 0xFFFF);

		// describe the codepoint

		// digit
		fprintf (fp, "0 ");

		// is alpha
		fprintf (fp, "0 ");
		
		// is punct
		fprintf (fp, "0 ");
		
		// is hiragana
		fprintf (fp, "0 ");
		
		// is katakana
		fprintf (fp, "0 ");
		
		// is kanji
		fprintf (fp, "0 ");
	}

	// write sole features for fpSole
	if (iWinningCand != 0)
	{
		iClass	=	GetCharID (cStrk, s_wch);

		if (iClass >= 0)
		{
			fprintf (fpSole, "{ ");

			for (i = 0; i < SOLE_NUM_FEATURES; i++)
			{
				fprintf (fpSole, "%d ", s_aSoleFeat[i]);
			}

			fprintf (fpSole, "} { %d }\n", iClass);

			fflush (fpSole);
		}
	}

	fprintf (fp, "} { %d }\n", iWinningCand);
	

	fflush (fp);
	fflush (fpSole);
}

void RunJaws (LATTICE *pLat, HWXRESULTS	*rgRes)
{
	int					i, iSoleBest, cAlt, j, cFeat, k, iWinningCand, iOttBest;
	LATTICE_ALT_LIST	*pAlt;
	int					aSoleCost[JAWS_ALT], aIdx[JAWS_ALT], iWinner, cOut, cStrk, cSoleOut;
	wchar_t				wch, awch[JAWS_ALT];
	RREAL				*pJawsNetMem, *pJawsNetOut;
	float				fCost;
	BOXINFO				box;
	RECT				bbox;
	RECT				rGuide;
	GLYPH				*pGlyph;

	pJawsNetMem = _alloca(s_iJawsNetSize * sizeof (*pJawsNetMem));
	if (!pJawsNetMem)
		return;
	
	// featurize for JAWS
	iOttBest		=	
	iWinningCand	=	
	iSoleBest		=	-1;
	pAlt			=	pLat->pAltList + pLat->nStrokes - 1;
	cAlt			=	pAlt->nUsed;

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.
	pGlyph	= GlyphFromStrokes(pLat->nStrokes, pLat->pStroke);
	if (!pGlyph) 
	{
		return;
	}

	cStrk	=	CframeGLYPH (pGlyph);

	// do not run if sole/reject and otter agree
	if (!SoleReject (cStrk, pAlt->alts[0].wChar))
		return;
	

	// Get the bounding box for the character
	GetRectGLYPH(pGlyph, &bbox);

	// Free the glyph structure.
	DestroyFramesGLYPH(pGlyph);
	DestroyGLYPH(pGlyph);

	rGuide = GetGuideDrawnBox(&pLat->guide, pLat->pStroke[pLat->nStrokes - 1].iBox);

	// Build up a BOXINFO structure from the guide, for use in the baseline/height scoring
	box.size		= rGuide.bottom - rGuide.top;
	box.baseline	= rGuide.bottom;
	box.xheight		= box.size / 2;
	box.midline		= box.baseline - box.xheight;

	cSoleOut	=	(cStrk == 1 ? SOLE_OUT_1 : SOLE_OUT_2);

	for (i = 0; i < cAlt && i < JAWS_ALT; i++)
	{
		wch	=	LocRunDense2Unicode(&g_locRunInfo, pAlt->alts[i].wChar);

		if (wch == s_wch)
		{
			iWinningCand = i;
		}

		// sole cost
		for (j = 0; j < cSoleOut; j++)
		{
			if (s_aaMap[cStrk - 1][j] == wch)
			{
				break;
			}
		}

		if (j == cSoleOut)
		{
			aSoleCost[i]	=	0xFFFF;
		}
		else
		{
			aSoleCost[i]	=	(0xFFFF * s_aSoleOut[j]) / SOFT_MAX_UNITY;
			aSoleCost[i]	=	0xFFFF - aSoleCost[i];
		}
		
		if (iSoleBest == -1 || aSoleCost[iSoleBest] > aSoleCost[i])
		{
			iSoleBest	=	i;
		}

		if (iOttBest == -1 || pAlt->alts[iOttBest].logProbPath < pAlt->alts[i].logProbPath)
		{
			iOttBest	=	i;
		}
	}

	for (i = cAlt; i < JAWS_ALT; i++)
	{
		aSoleCost[i]	=	0xFFFF;
	}
	
	// for all candidates
	cFeat	=	0;
	for (i = 0; i < cAlt && i < JAWS_ALT; i++)
	{
		int	iOttCost, iUni;

		wch	=	LocRunDense2Unicode(&g_locRunInfo, pAlt->alts[i].wChar);

		// otter cost
		iOttCost	=	min (0xFFFF, (int)(-pAlt->alts[i].logProb * 1000));
		pJawsNetMem[cFeat++]	=	iOttCost;
		
		// sole cost
		pJawsNetMem[cFeat++]	=	aSoleCost[i];

		// unigram cost
		iUni	= (int)(-255 * 100 * UnigramCost(&g_unigramInfo, pAlt->alts[i].wChar));
		pJawsNetMem[cFeat++]	=	iUni;

		// baseline trans cost
		fCost = BaselineTransitionCost(0, bbox, &box, pAlt->alts[i].wChar, bbox, &box);
		pJawsNetMem[cFeat++]	=	min (0xFFFF, (int) (-100000.0 * fCost));

		// base line cost
		fCost = BaselineBoxCost(pAlt->alts[i].wChar, bbox, &box);
		pJawsNetMem[cFeat++]	=	min (0xFFFF, (int) (-100000.0 * fCost));

		// height trans cost
		fCost = HeightTransitionCost(0, bbox, &box, pAlt->alts[i].wChar, bbox, &box);
		pJawsNetMem[cFeat++]	=	min (0xFFFF, (int) (-100000.0 * fCost));

		// height cost
		fCost = HeightBoxCost(pAlt->alts[i].wChar, bbox, &box);
		pJawsNetMem[cFeat++]	=	min (0xFFFF, (int) (-100000.0 * fCost));

		// describe the codepoint

		// digit
		if (wch >= L'0' && wch <= '9')
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}

		// is alpha
		if ((wch >= L'a' && wch <= 'z') || (wch >= L'A' && wch <= 'Z'))
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}

		// is punct
		if (iswpunct (wch))
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}

		// is hiragana
		if (wch >= 0x3040 && wch <= 0x309f)
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}

		// is katakana
		if (wch >= 0x30a0 && wch <= 0x30ff)
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}

		// is kanji
		if (wch >= 0x3190 && wch <= 0xabff)
		{
			pJawsNetMem[cFeat++] = 65535;
		}
		else
		{
			pJawsNetMem[cFeat++] = 0;
		}
	}

	// the rest of the candidates
	for (i = cAlt; i < JAWS_ALT; i++)
	{
		// otter cost
		pJawsNetMem[cFeat++] = 65535;

		// sole cost
		pJawsNetMem[cFeat++] = 65535;

		// unigram cost
		pJawsNetMem[cFeat++] = 65535;

		// baseline trans cost
		pJawsNetMem[cFeat++] = 65535;

		// baseline cost
		pJawsNetMem[cFeat++] = 65535;

		// height trans cost
		pJawsNetMem[cFeat++] = 65535;

		// height cost
		pJawsNetMem[cFeat++] = 65535;

		// describe the codepoint

		// digit
		pJawsNetMem[cFeat++] = 0;

		// is alpha
		pJawsNetMem[cFeat++] = 0;
		
		// is punct
		pJawsNetMem[cFeat++] = 0;
		
		// is hiragana
		pJawsNetMem[cFeat++] = 0;
		
		// is katakana
		pJawsNetMem[cFeat++] = 0;
		
		// is kanji
		pJawsNetMem[cFeat++] = 0;
	}

	// call the JAWS net	
	pJawsNetOut = runLocalConnectNet(&s_JawsNet, pJawsNetMem, &iWinner, &cOut);	

	ASSERT (cOut == JAWS_ALT);

	// index the result
	for (i = 0; i < JAWS_ALT; i++)
	{
		aIdx[i]	=	i;
	}

	for (i = 0; i < JAWS_ALT; i++)
	{
		for (j = i + 1; j < JAWS_ALT; j++)
		{
			if (pJawsNetOut[aIdx[i]] < pJawsNetOut[aIdx[j]])
			{
				k		=	aIdx[i];
				aIdx[i]	=	aIdx[j];
				aIdx[j]	=	k;
			}
		}

		awch[i]	=	pAlt->alts[aIdx[i]].wChar;
	}	
	
	for (i = 0; i < cAlt && i < JAWS_ALT; i++)
	{
		rgRes->rgChar[i]	=	LocRunDense2Unicode(&g_locRunInfo, awch[i]);
	}
}

#endif

#if 0
LOCAL_NET *LoadNet(void *pData, int *piNetSize, LOCAL_NET *pNet)
{
	if ( !pData || !(pNet = restoreLocalConnectNet(pData, 0, pNet)) )
	{
		return NULL;
	}

	(*piNetSize) = getRunTimeNetMemoryRequirements(pData);

	if ((*piNetSize) <= 0)
	{
		return NULL;
	}

	return pNet;
}

BOOL LoadSoleFromFile(wchar_t *pwszPath)
{
	BYTE		*pData;
	wchar_t		aPath[128];
	HANDLE		hFile, hMap;
	
	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	wsprintf (aPath, L"%s\\sole1.bin", pwszPath);

	// Try to open the file.
	hFile = CreateMappingCall (aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		return FALSE;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		return FALSE;
	}

	// Map the entire file starting at the first byte
	pData = (void *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pData == NULL) 
	{
		return FALSE;
	}

	// Sole net
	if (!LoadNet(pData, &s_iSoleNetSize1, &s_SoleNet1))
	{
		return FALSE;
	}

	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	wsprintf (aPath, L"%s\\sole2.bin", pwszPath);

	// Try to open the file.
	hFile = CreateMappingCall (aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		return FALSE;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		return FALSE;
	}

	// Map the entire file starting at the first byte
	pData = (void *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pData == NULL) 
	{
		return FALSE;
	}

	// Sole net
	if (!LoadNet(pData, &s_iSoleNetSize2, &s_SoleNet2))
	{
		return FALSE;
	}

	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	wsprintf (aPath, L"%s\\solerej1.bin", pwszPath);

	// Try to open the file.
	hFile = CreateMappingCall (aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		return FALSE;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		return FALSE;
	}

	// Map the entire file starting at the first byte
	pData = (void *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pData == NULL) 
	{
		return FALSE;
	}

	// Sole net
	if (!LoadNet(pData, &s_iSoleRejNetSize1, &s_SoleRejNet1))
	{
		return FALSE;
	}

	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	wsprintf (aPath, L"%s\\solerej2.bin", pwszPath);

	// Try to open the file.
	hFile = CreateMappingCall (aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		return FALSE;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		return FALSE;
	}

	// Map the entire file starting at the first byte
	pData = (void *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pData == NULL) 
	{
		return FALSE;
	}

	// Sole net
	if (!LoadNet(pData, &s_iSoleRejNetSize2, &s_SoleRejNet2))
	{
		return FALSE;
	}

	return TRUE;
}
#endif

#if 0

BOOL LoadJawsFromFile(wchar_t *pwszPath)
{
	BYTE		*pData;
	wchar_t		aPath[128];
	HANDLE		hFile, hMap;
	
	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	wsprintf (aPath, L"%s\\jaws.bin", pwszPath);

	// Try to open the file.
	hFile = CreateMappingCall (aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		return FALSE;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		return FALSE;
	}

	// Map the entire file starting at the first byte
	pData = (void *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pData == NULL) 
	{
		return FALSE;
	}

	// Jaws net
	if (!LoadNet(pData, &s_iJawsNetSize, &s_JawsNet))
	{
		return FALSE;
	}

	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\sources.inc ===
TARGETNAME=volcano
TARGETTYPE=LIBRARY

SYNCHRONIZE_BLOCK=1

USE_MSVCRT=1

C_DEFINES = $(C_DEFINES) -DHWX_PRODUCT -DUSE_OLD_DATABASES -DUSE_RESOURCES -DUSE_IFELANG3
C_DEFINES = $(C_DEFINES) -DUSE_ZILLAHOUND

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\wisp\inc; \
          $(_TPG_ROOT)\hwx\fugu\inc; \
          $(_TPG_ROOT)\hwx\factoid\inc; \
          $(_TPG_ROOT)\hwx\holycow\src; \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\crane\inc; \
          $(_TPG_ROOT)\hwx\otter\inc; \
          $(_TPG_ROOT)\hwx\otter\src; \
          $(_TPG_ROOT)\hwx\hound\inc; \
          $(_TPG_ROOT)\hwx\zilla\inc; \
          $(_TPG_ROOT)\hwx\zilla\src; \
          $(_TPG_ROOT)\hwx\centipede\inc; \
          $(_TPG_ROOT)\hwx\tsunami\inc; \
          $(_TPG_ROOT)\hwx\ifelang3\inc; \
          $(_TPG_ROOT)\hwx\volcano\inc; \
          $(_TPG_ROOT)\hwx\common\src\api; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\BoxApi.c \
         ..\CharRec.c \
         ..\FreeApi.c \
         ..\bboxfeat.c \
         ..\lattice-lm.cpp \
         ..\lattice.c \
         ..\latticers.c \
         ..\vtune.c \
         ..\wispapis.c \
         ..\brknet.c\
         ..\brk.c\
         ..\segm.c \
         ..\segmnet.c \
         ..\sole.c\
         ..\jaws.c\
         ..\eafactoid.c\
         ..\fuguseg.c\
         ..\strkutil.c\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\sole.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/sole.h
//
// Description:
//	    Sole recognizer header file
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "runnet.h"

#pragma once

// Magic key the identifies the NN bin file
#define	SOLE_FILE_TYPE	0x501E501E

// Version information for file.
#define	SOLE_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	SOLE_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define SOLE_CUR_FILE_VERSION		0		// Current version of code.

typedef struct SOLE_LOAD_INFO
{
    LOAD_INFO info;
    LOCAL_NET net1;
    LOCAL_NET net2;
    wchar_t *pMap1;
    wchar_t *pMap2;
    int iNet1Size;
    int iNet2Size;
} SOLE_LOAD_INFO;

#define SOLE_NUM_SPACES 2
#define SOLE_NUM_FEATURES 65

BOOL SoleLoadRes(SOLE_LOAD_INFO *pSole, HINSTANCE hInst, int nResID, int nType, LOCRUN_INFO *pLocRunInfo);
BOOL SoleLoadFile(SOLE_LOAD_INFO *pSole, wchar_t *wszRecogDir, LOCRUN_INFO *pLocRunInfo);
BOOL SoleUnloadFile(SOLE_LOAD_INFO *pSole);

int SoleMatch(SOLE_LOAD_INFO *pSole,
              ALT_LIST *pAlt, int cAlt, GLYPH *pGlyph, RECT *pGuide, CHARSET *pCS, LOCRUN_INFO *pLocRunInfo);
int SoleMatchRescore(SOLE_LOAD_INFO *pSole,
              wchar_t *pwchTop1, float *pflTop1,
              ALT_LIST *pAltList, int cAlt, GLYPH *pGlyph, RECT *pGuide, 
              CHARSET *pCharSet, LOCRUN_INFO *pLocRunInfo);
BOOL SoleFeaturize(GLYPH *pGlyph, RECT *pGuide, unsigned short *rgFeat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\strkutil.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/strkutil.c
//
// Description:
//	    Functions to implement the functionality of managing breakpoint structures.
//
// Author:
// hrowley & ahmadab 12/05/01
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#include "common.h"
#include "volcanop.h"

// Make a copy of the points in a stroke.  Used so that when we free
// the glyph we don't free the passed in points.
POINT *
DupPoints(POINT *pOldPoints, int nPoints)
{
	int		ii;
	POINT	*pPoints;

	// Alloc space.
	pPoints	= (POINT *) ExternAlloc(nPoints * sizeof(POINT));
	if (!pPoints) {
		return (POINT *)0;
	}

	// Copy point data.
	for (ii = 0; ii < nPoints; ++ii) {
		pPoints[ii]	= pOldPoints[ii];
	}

	// Return the new copy.
	return pPoints;
}

// Build glyph structure from stroke array.
GLYPH *
GlyphFromStrokes(UINT cStrokes, STROKE *pStrokes)
{
	int		ii;
	GLYPH	*pGlyph;

	// Convert strokes to GLYPHs and FRAMEs so that we can call the
	// old code.
	pGlyph	= (GLYPH *)0;
	for (ii = cStrokes - 1; ii >= 0; --ii) {
		STROKE	*pStroke;
		GLYPH	*pGlyphCur;

		// Alloc glyph.
		pGlyphCur	= NewGLYPH();
		if (!pGlyphCur) {
			goto error;
		}

		// Add to list, and alloc frame
		pGlyphCur->next		= pGlyph;
		pGlyph				= pGlyphCur;
		pGlyphCur->frame	= NewFRAME();
		if (!pGlyphCur->frame) {
			goto error;
		}

		// Get stroke to process.
		pStroke	= pStrokes + ii;

		// Fill in frame.  We just fill in what we need, and ignore
		// fields not used by Otter and Zilla, or are set by them.
		pGlyphCur->frame->info.cPnt	= pStroke->nInk;
		pGlyphCur->frame->info.wPdk	= PDK_TRANSITION | PDK_DOWN;
		pGlyphCur->frame->rgrawxy	= DupPoints(pStroke->pts, pStroke->nInk);
		pGlyphCur->frame->rect		= pStroke->bbox;
		pGlyphCur->frame->iframe	= ii;

		if (pGlyphCur->frame->rgrawxy == NULL) {
			goto error;
		}
	}

	return pGlyph;

error:
	// Cleanup glyphs on error.
	if (pGlyph) {
		DestroyFramesGLYPH(pGlyph);
		DestroyGLYPH(pGlyph);
	}
	return (GLYPH *)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\vtune.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/vtune.c
//
// Description:
//      Runtime portion of the volcano tuning module
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <stdio.h>
#include <float.h>
#include "common.h"
#include "vtune.h"

///////////////////////////////////////
//
// VTuneZeroWeights
//
//      Zero out an array of weights on scores
//
// Parameters:
//      pWeights: [out] Pointer to a weights array
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneZeroWeights(VOLCANO_WEIGHTS *pWeights)
{
    int i;
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        pWeights->afl[i] = 0;
    }
}

///////////////////////////////////////
//
// VTuneComputeScore
//
//      Compute the weighted sum of the scores and return the result
//
// Parameters:
//      pWeights: [in] Pointer to a weights array
//      pScores:  [in] Pointer to a scores array
//
// Return values:
//      Weighted sum of the scores.
//
//////////////////////////////////////
float VTuneComputeScore(VOLCANO_WEIGHTS *pWeights, VOLCANO_WEIGHTS *pScores)
{
    int i;
    float flTotal = 0.0;
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        flTotal += pWeights->afl[i] * pScores->afl[i];
    }
    return flTotal;
}

///////////////////////////////////////
//
// VTuneComputeScoreNoLM
//
//      Compute the weighted sum of the scores and return the result.
//      Unlike VTuneComputeScore, this version does not add in the 
//      components of the score related to the language model.
//
// Parameters:
//      pWeights: [in] Pointer to a weights array
//      pScores:  [in] Pointer to a scores array
//
// Return values:
//      Weighted sum of the scores.
//
//////////////////////////////////////
float VTuneComputeScoreNoLM(VOLCANO_WEIGHTS *pWeights, VOLCANO_WEIGHTS *pScores)
{
    int i;
    float flTotal = 0.0;
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        // Check th
        switch (i) 
        {
            // Global language model
            case VTUNE_UNIGRAM:
                break;

            // String mode language model
            case VTUNE_STRING_SMOOTHING_UNIGRAM:
            case VTUNE_STRING_BIGRAM:
            case VTUNE_STRING_CLASS_BIGRAM:
                break;

            // Free mode langauge model
            case VTUNE_FREE_SMOOTHING_UNIGRAM:
            case VTUNE_FREE_BIGRAM:
            case VTUNE_FREE_CLASS_BIGRAM:
                break;

            // Otherwise, add in the score
            default:
                flTotal += pWeights->afl[i] * pScores->afl[i];
                break;
        }
    }
    return flTotal;
}

///////////////////////////////////////
//
// VTuneCheckFileVersion
//
//      Check the file header and version information in a tuning database
//
// Parameters:
//      pTune: [in] Tuning database to check
//
// Return values:
//      TRUE if file version is okay, FALSE otherwise
//
//////////////////////////////////////
BOOL VTuneCheckFileVersion(VOLCANO_PARAMS *pTune)
{
    ASSERT(pTune->dwFileType == VTUNE_FILE_TYPE);
    if (pTune->dwFileType != VTUNE_FILE_TYPE)
    {
        return FALSE;
    }
    
    ASSERT(pTune->iFileVer >= VTUNE_OLD_FILE_VERSION);
    ASSERT(pTune->iMinCodeVer <= VTUNE_CUR_FILE_VERSION);
    if (pTune->iFileVer >= VTUNE_OLD_FILE_VERSION &&
        pTune->iMinCodeVer <= VTUNE_CUR_FILE_VERSION)
    {
        return TRUE;
    }
    return FALSE;
}

///////////////////////////////////////
//
// VTuneLoadRes
//
//      Map a resource as the tuning parameter database
//
// Parameters:
//      pInfo:  [out] Pointer to the database structure to fill in
//      hInst:  [in] DLL to locate the resource in
//      nResID: [in] Resource ID
//      nType:  [in] Resource type
//
// Return values:
//      TRUE if the mapping succeeds, FALSE if the mapping fails.
//
//////////////////////////////////////
BOOL VTuneLoadRes(VOLCANO_PARAMS_INFO *pInfo, HINSTANCE hInst, int nResID, int nType)
{
    pInfo->pTune = (VOLCANO_PARAMS *) DoLoadResource(&pInfo->info, hInst, nResID, nType);

    if (pInfo->pTune == NULL)
    {
        ASSERT(("Failed to locate resource for VTune database.\n", FALSE));
        return FALSE;
    }

    // Check the file version
    return VTuneCheckFileVersion(pInfo->pTune);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\wispapis.c ===
// FILE: WispApis.c
//

#include <stdlib.h>

#include "volcanop.h"
#include "RecTypes.h"
#include "RecApis.h"

#include <Limits.h>

#include <strsafe.h>

#include "TpcError.h"
#include "TpgHandle.h"

#include "res.h"

//#define ENABLE_CONFIDENCE_LEVEL

#define LARGE_BREAKS 500

// definitions of possible handle types that WISP used
#define TPG_HRECOCONTEXT		(1)
#define TPG_HRECOGNIZER			(2)
#define TPG_HRECOALT			(3)

//Why cannot we include penwin.h???? I have to redefine everything I need....
#define SYV_UNKNOWN             0x00000001L
BOOL SymbolToCharacterW(SYV *pSyv, int cSyv, WCHAR *wsz, int *pConv);

// If this pointer is non-NULL, then free input is enabled.
extern BBOX_PROB_TABLE *g_pProbTable;

// String identifying which language is loaded
extern wchar_t *g_szRecognizerLanguage;

extern HINSTANCE g_hInstanceDllCode;

#define NUMBER_OF_ALTERNATES 10
#define TAB_STROKE_INC 30

// {7DFE11A7-FB5D-4958-8765-154ADF0D833F}
static const GUID GUID_CONFIDENCELEVEL = 
{ 0x7dfe11a7, 0xfb5d, 0x4958, { 0x87, 0x65, 0x15, 0x4a, 0xdf, 0x0d, 0x83, 0x3f } };

// {8CC24B27-30A9-4b96-9056-2D3A90DA0727}
static const GUID GUID_LINEMETRICS =
{ 0x8cc24b27, 0x30a9, 0x4b96, { 0x90, 0x56, 0x2d, 0x3a, 0x90, 0xda, 0x07, 0x27 } };

// {6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}
static const CLSID JPN_CLSID =
{ 0x6D4087D7, 0x61D2, 0x495f, { 0x92, 0x93, 0x5B, 0x7B, 0x1C, 0x3F, 0xCE, 0xAB } };

static const CLSID KOR_CLSID = 
{ 0x6D5087D7, 0x61D2, 0x495f, { 0x92, 0x93, 0x5B, 0x7B, 0x1C, 0x3F, 0xCE, 0xAB } };

static const CLSID CHS_CLSID = 
{ 0x6D6087D7, 0x61D2, 0x495f, { 0x92, 0x93, 0x5B, 0x7B, 0x1C, 0x3F, 0xCE, 0xAB } };

static const CLSID CHT_CLSID =
{ 0x6D7087D7, 0x61D2, 0x495f, { 0x92, 0x93, 0x5B, 0x7B, 0x1C, 0x3F, 0xCE, 0xAB } };

//
// Definitions of strucure which pointers are used
// to define the WISP handles (HRECOGNIZER, HRECOCONTEXT
// HRECOALTERNATE)
////////////////////////////////////////////////////////


// This is the structure used for the WISP recognizer
// There is no data, because we have nothing to store
struct WispRec
{
    long unused;
};

// This is the structure for WISP alternates
// It contains an array of column used in the 
// lattice and an array of indexes used in 
// those columns.
// We alse cache the reco context for which
// this alternate is valis, the length of the
// string this alternate corresponds to and
// the original RECO_RANGE this alternate was
// produced from (in a call to GetAlternateList
// or other)
struct WispAlternate
{
    HRECOCONTEXT hrc;
    int *pIndexInColumn;
    int *pColumnIndex;
    int iNumberOfColumns;
    int iLength;    
    RECO_RANGE OriginalRecoRange;
};

// This is the WISP structure for the reco context.
// It contains information on the guide used, the
// CAC modem the number of strokes currently
// entered, the context (prefix)
// It also contains the handle to the HWX reco
// context
// We store the lattice so that we not need to
// recreate it every time we are asked for it
struct WispContext
{
    HRC hrc;
    RECO_GUIDE *pGuide;
    ULONG uiGuideIndex;
    BOOL bIsBoxed;
    BOOL bIsCAC;
    BOOL bCACEndInk;
    ULONG iCACMode;
    UINT uAbort;
    ULONG ulCurrentStrokeCount;
    BOOL bHasTextContext;   // Whether any context has been set
    WCHAR *wszBefore;       // Context before ink
    WCHAR *wszAfter;        // Context after ink
    DWORD dwFlags;          // Flags
    WCHAR *wszFactoid;      // Factoid

	// Lattice for the automation code, with associated data structures
    RECO_LATTICE *pLattice;
	RECO_LATTICE_PROPERTY *pLatticeProperties;
	BYTE *pLatticePropertyValues;
	RECO_LATTICE_PROPERTY **ppLatticeProperties;
};

// Structure for the alternate list recursive call
////////////////////////////////////////////////
typedef struct tagAltRank
{
    struct WispAlternate    *wispalt;
    FLOAT                   fScore;
    struct tagAltRank       *next;
    BOOL                    bCurrentPath;
} AltRank;

typedef struct tagAltRankList
{
    AltRank         *pFirst;
    AltRank         *pLast;
    ULONG           ulSize;
} AltRankList;
typedef struct tagDiffBreakElement
{
    int iColumn;
    int iIndex;
    struct tagDiffBreakElement *pNext;
} DiffBreakElement;
typedef struct tagDifBreakList
{
    int iColumnCount;
    DiffBreakElement *pFirst;
    float score;
    BOOL bCurrentPath;
} DifBreakList;

typedef struct tagDifBreakAltStruct
{
    VRC                 *vrc;           // the recognizer data structure
    int                 iFirstStroke;   // the first stroke in the original alternate
    ULONG               ulMax;          // Max alternates that we want to return
    int                 iLastChar;      // This is to put in the original reco range of the alternate
    int                 iFirstChar;     // This is to put in the original reco range of the alternate
    AltRankList         *paltRankList;  // List of Alternates
    int                 iMode;          // Segmentation mode (DIFF_BREAK, ...)
} DifBreakAltStruct;
   
/////////////////////////////////////////////////////
// Declare the GUIDs and consts of the Packet description
/////////////////////////////////////////////////////
const GUID g_guidx ={ 0x598a6a8f, 0x52c0, 0x4ba0, { 0x93, 0xaf, 0xaf, 0x35, 0x74, 0x11, 0xa5, 0x61 } };
const GUID g_guidy = { 0xb53f9f75, 0x04e0, 0x4498, { 0xa7, 0xee, 0xc3, 0x0d, 0xbb, 0x5a, 0x90, 0x11 } };
const PROPERTY_METRICS g_DefaultPropMetrics = { LONG_MIN, LONG_MAX, PROPERTY_UNITS_DEFAULT, 1.0 };

/////////////////////////////////////////////////////
// Helper function to bubble sort an array
/////////////////////////////////////////////////////
// I use a bubble sort because most likely if the
// array is not already sorted, we probably have one or
// two inversion. This is caused by the fact that
// people usually write the letters in a word in
// the correct order
BOOL SlowSort(ULONG *pTab, ULONG ulSize)
{
    ULONG i, j, temp;
    BOOL bPermut;
    // Stupid bubble sort
    for (i = 0; i<ulSize; i++)
    {
        bPermut = FALSE;
        for (j = 0; j < ulSize-1-i; j++)
        {
            if (pTab[j] > pTab[j+1])
            {
                bPermut = TRUE;
                temp = pTab[j];
                pTab[j] = pTab[j+1];
                pTab[j+1] = temp;
            }
        }
        if (!bPermut) return TRUE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////
// Implementation of the Wisp Reco Apis
/////////////////////////////////////////////////////


// CreateRecognizer
//      Returns a recognizer handle to the recognizer 
//      corresponding to the passed CLSID. In the case
//      of this dll, we only support one CLSID so we will
//      not even check for the value of the clsid
//      (even if the clsid is null)
//
// Parameter:
//      pCLSID [in] : The pointer to the CLSID 
//                    that determines what recognizer we want
//      phrec [out] : The address of the returned recognizer
//                    handle.
//////////////////////////////////////////////////////////////////////
HRESULT WINAPI CreateRecognizer(CLSID *pCLSID, HRECOGNIZER *phrec)
{
	struct WispRec		*pRec;

	// We might want to make NULL illegal later.
	if (pCLSID != NULL && IsBadReadPtr(pCLSID, sizeof(CLSID)))
	{
		return E_POINTER;
	}

	// validate the pointer
	if (IsBadWritePtr(phrec, sizeof(HRECOGNIZER))) 
	{
        return E_POINTER;
	}

    // initialize the east asian recognizers
#ifdef USE_RESOURCES
    if (!HwxConfig()) 
	{
		return E_FAIL;
	}
#endif

	// We might want to make NULL illegal later.
	if (pCLSID != NULL)
	{
		if (wcscmp(g_szRecognizerLanguage, L"JPN") == 0 &&
			!IsEqualCLSID(pCLSID, &JPN_CLSID))
		{
			return E_INVALIDARG;
		}

		if (wcscmp(g_szRecognizerLanguage, L"CHS") == 0 &&
			!IsEqualCLSID(pCLSID, &CHS_CLSID))
		{
			return E_INVALIDARG;
		}

		if (wcscmp(g_szRecognizerLanguage, L"CHT") == 0 &&
			!IsEqualCLSID(pCLSID, &CHT_CLSID))
		{
			return E_INVALIDARG;
		}

		if (wcscmp(g_szRecognizerLanguage, L"KOR") == 0 &&
			!IsEqualCLSID(pCLSID, &KOR_CLSID))
		{
			return E_INVALIDARG;
		}
	}

    // We only have one CLSID per recognizer so always return an hrec...
	pRec		= (struct WispRec*)ExternAlloc(sizeof(*pRec));
	if (NULL == pRec)
	{
		return E_OUTOFMEMORY;
	}

	(*phrec)	= (HRECOGNIZER)CreateTpgHandle(TPG_HRECOGNIZER, pRec);	
	if (0 == (*phrec))
	{
		ExternFree(pRec);
        return E_OUTOFMEMORY;
	}

    return S_OK;
}

// DestroyRecognizer
//      Destroys a recognizer handle. Free the associate memory
//
// Parameter:
//      hrec [in] : handle to the recognizer
/////////////////////////////////////////////////////////////
HRESULT WINAPI DestroyRecognizer(HRECOGNIZER hrec)
{
	struct WispRec		*pRec; 

	// destroy the handle and return the corresponding pointer
	pRec = (struct WispRec*)DestroyTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
	if (NULL == pRec)
	{
        return E_INVALIDARG;
	}

#ifdef USE_RESOURCES
	if (!HwxUnconfig(TRUE)) 
	{
		return E_FAIL;
	}
#endif

	ExternFree(pRec);

    return S_OK;
}


// GetRecoAttributes
//      This function returns the reco attributes corresponding 
//      to a given recognizer. Since we only have one recognizer 
//      type we always return the same things.
//
// Parameters:
//      hrc [in] :         The handle to the recognizer we want the
//                         the attributes for.
//      pRecoAttrs [out] : Address of the user allocated buffer
//                         to hold the reco attributes.
///////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetRecoAttributes(HRECOGNIZER hrec, RECO_ATTRS* pRecoAttrs)
{
    HRESULT                 hr = S_OK;
    HRSRC                   hrsrc = NULL;
    HGLOBAL                 hg = NULL;
    LPBYTE                  pv = NULL;
    WORD                    wCurrentCount = 0;
    WORD                    wRecognizerCount = 0;
    DWORD                   dwRecoCapa;
    WORD                    wLanguageCount;
    WORD                    *aLanguages;
    WORD                    iLang;
    struct WispRec          *pRec;	

    if (IsBadWritePtr(pRecoAttrs, sizeof(RECO_ATTRS))) 
        return E_POINTER;

    // Check the recognizer handle
    pRec = (struct WispRec*)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
    if (NULL == pRec)
    {
        return E_INVALIDARG;
    }
    
    ZeroMemory(pRecoAttrs, sizeof(RECO_ATTRS));

    // Update the global structure is necessary
    // Load the resources
    // Load the recognizer friendly name
    if (0 == LoadStringW(g_hInstanceDllCode,                        // handle to resource module
                RESID_WISP_FRIENDLYNAME,                            // resource identifier
                pRecoAttrs->awcFriendlyName,                        // resource buffer
                sizeof(pRecoAttrs->awcFriendlyName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    // Load the recognizer vendor name
    if (0 == LoadStringW(g_hInstanceDllCode,                      // handle to resource module
                RESID_WISP_VENDORNAME,                            // resource identifier
                pRecoAttrs->awcVendorName,                        // resource buffer
                sizeof(pRecoAttrs->awcVendorName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    if (SUCCEEDED(hr))
    {
        hrsrc = FindResource(g_hInstanceDllCode, // module handle
                    (LPCTSTR)RESID_WISP_DATA,  // resource name
                    (LPCTSTR)RT_RCDATA   // resource type
                    );
        if (NULL == hrsrc)
        {
            // The resource is not found!
            ASSERT(NULL != hrsrc);
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        hg = LoadResource(
                g_hInstanceDllCode, // module handle
                hrsrc   // resource handle
                );
        if (NULL == hg)
        {
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        pv = (LPBYTE)LockResource(
            hg   // handle to resource
            );
        if (NULL == pv)
        {
            hr = E_FAIL;
        }
    }
    dwRecoCapa = *((DWORD*)pv);
    pv += sizeof(dwRecoCapa);
    wLanguageCount = *((WORD*)pv);
    pv += sizeof(wLanguageCount);
    aLanguages = (WORD*)pv;
    pv += wLanguageCount * sizeof(WORD);


    // Fill the reco attricute structure for this recognizer
    // Add the languages
    ASSERT(wLanguageCount < 64);
    for (iLang = 0; iLang < wLanguageCount; iLang++)
    {
        pRecoAttrs->awLanguageId[iLang] = aLanguages[iLang];
    }
    // End the list with a NULL
    pRecoAttrs->awLanguageId[wLanguageCount] = 0;
    // Add the recocapability flag
    pRecoAttrs->dwRecoCapabilityFlags = dwRecoCapa;

    return hr;
}

// CreateRecoContext
//      This function creates a reco context for a given recognizer
//      Since we only have one type of recognizers in this dll, 
//      always return the same kind of reco context.
//
// Parameters:
//      hrec [in] :  Handle to the recognizer we want to create a
//                   reco context for.
//      phrc [out] : Pointer to the returned reco context's handle
////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CreateContext(HRECOGNIZER hrec, HRECOCONTEXT *phrc)
{
    struct WispContext *pWispContext = NULL;

	struct WispRec *pRec;	

	// Check the recognizer handle
	pRec = (struct WispRec*)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
	if (NULL == pRec)
	{
        return E_INVALIDARG;
	}

	// validate the pointer
    if (IsBadWritePtr(phrc, sizeof(HRECOCONTEXT))) 
	{
        return E_POINTER;
	}

    pWispContext = (struct WispContext*)ExternAlloc(sizeof(struct WispContext));
    if (!pWispContext) 
        return E_OUTOFMEMORY;

	pWispContext->pGuide = NULL;
    pWispContext->pLattice = NULL;
	pWispContext->pLatticeProperties = NULL;
	pWispContext->pLatticePropertyValues = NULL;
	pWispContext->ppLatticeProperties = NULL;
    pWispContext->bIsBoxed = FALSE;
    pWispContext->bIsCAC = FALSE;
    pWispContext->iCACMode = CAC_FULL;
    pWispContext->bCACEndInk = FALSE;
    pWispContext->uAbort = 0;
    pWispContext->ulCurrentStrokeCount = 0;
    pWispContext->hrc = NULL;
    pWispContext->bHasTextContext = FALSE;
    pWispContext->wszBefore = NULL;
    pWispContext->wszAfter = NULL;
    pWispContext->dwFlags = 0;
    pWispContext->wszFactoid = NULL;

	// create the handle
	*phrc = (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pWispContext);
	if (NULL == (*phrc))
	{
		ExternFree(pWispContext);
		return E_OUTOFMEMORY;
	}
  
    return S_OK;
}

// creates an HRC by calling the appropriate hwx api
HRESULT CreateHRCinContext(struct WispContext *pWispContext)
{
	// are we in boxed mode
    if (pWispContext->bIsBoxed)
    {
        pWispContext->hrc = HwxCreate(NULL);
    }
	// free
    else
    {
        pWispContext->hrc = CreateCompatibleHRC(NULL, NULL);
    }

	// we failed
    if (pWispContext->hrc == NULL)
	{
        return E_FAIL;
	}

	// reco settings
    if (pWispContext->bHasTextContext)
    {
        if (!SetHwxCorrectionContext (pWispContext->hrc, pWispContext->wszBefore, pWispContext->wszAfter))
		{
            return E_FAIL;
		}
    }

    if (!SetHwxFlags(pWispContext->hrc, pWispContext->dwFlags))
	{
        return E_FAIL;
	}

    switch (SetHwxFactoid(pWispContext->hrc, pWispContext->wszFactoid))
    {
		case HRCR_OK:
			break;

		case HRCR_UNSUPPORTED:
			HwxDestroy(pWispContext->hrc);
			return TPC_E_INVALID_PROPERTY;

		case HRCR_CONFLICT:
			HwxDestroy(pWispContext->hrc);
			return TPC_E_OUT_OF_ORDER_CALL;

		case HRCR_ERROR:
		default:
			HwxDestroy(pWispContext->hrc);
			return E_FAIL;
    }

    return S_OK;
}

//
// Frees a reco lattice
//
HRESULT FreeRecoLattice(struct WispContext *wisphrc)
{
    ULONG       i	= 0;
	RECO_LATTICE *pRecoLattice = wisphrc->pLattice;

	if (pRecoLattice == NULL)
	{
		return S_OK;
	}

    // Free the Lattice column information
    if (pRecoLattice->pLatticeColumns)
    {
        // Free the array of strokes
        if (pRecoLattice->pLatticeColumns[0].pStrokes)
		{
            ExternFree(pRecoLattice->pLatticeColumns[0].pStrokes);
		}

        for (i = 0; i < pRecoLattice->ulColumnCount; i++)
        {
            if (pRecoLattice->pLatticeColumns[i].cpProp.apProps)
			{
                ExternFree(pRecoLattice->pLatticeColumns[i].cpProp.apProps);
			}
        }

        // Free the array of lattice elements
        if (pRecoLattice->pLatticeColumns[0].pLatticeElements)
		{
            ExternFree(pRecoLattice->pLatticeColumns[0].pLatticeElements);
		}

        ExternFree(pRecoLattice->pLatticeColumns);
    }

    // Free the the RecoLattice properties
    if (pRecoLattice->pGuidProperties) 
	{
		ExternFree(pRecoLattice->pGuidProperties);
	}

    // Free the best result information
    if (pRecoLattice->pulBestResultColumns) 
	{
		ExternFree(pRecoLattice->pulBestResultColumns);
	}

    if (pRecoLattice->pulBestResultIndexes) 
	{
		ExternFree(pRecoLattice->pulBestResultIndexes);
	}

	if (wisphrc->pLatticeProperties)
	{
		ExternFree(wisphrc->pLatticeProperties);
		wisphrc->pLatticeProperties = NULL;
	}

	if (wisphrc->pLatticePropertyValues)
	{
		ExternFree(wisphrc->pLatticePropertyValues);
		wisphrc->pLatticePropertyValues = NULL;
	}

	if (wisphrc->ppLatticeProperties != NULL)
	{
		ExternFree(wisphrc->ppLatticeProperties);
		wisphrc->ppLatticeProperties = NULL;
	}

    // Free the RECO_LATTICE structure
    ExternFree(wisphrc->pLattice);
	wisphrc->pLattice = NULL;

    return S_OK;
}

// DestroyContextInternal
//      Destroy a reco context and free the associated memory.
//
// Parameters:
//      hrc [in] : pointer to the reco context to destroy
//////////////////////////////////////////////////////////////
HRESULT WINAPI DestroyContextInternal(struct WispContext *wisphrc)
{
	HRESULT					hr;
	
	// validate and destroy the handle & return the pointer
	if (NULL == wisphrc)
    {
		return E_INVALIDARG;
	}

	// free the contents of the context
    if (wisphrc->hrc)
    {
        if (wisphrc->bIsBoxed)
            HwxDestroy(wisphrc->hrc);
        else
            DestroyHRC(wisphrc->hrc);
    }

    if (wisphrc->pGuide) 
	{
		ExternFree(wisphrc->pGuide);
	}

    if (wisphrc->pLattice) 
    {
        hr = FreeRecoLattice(wisphrc);
        ASSERT(SUCCEEDED(hr));
    }

    wisphrc->pLattice = NULL;

    if (wisphrc->bHasTextContext) 
    {
        ExternFree(wisphrc->wszBefore);
        ExternFree(wisphrc->wszAfter);
    }

    ExternFree(wisphrc->wszFactoid);
    ExternFree(wisphrc);
    
	return S_OK;
}

// DestroyContext
//      Destroy a reco context and free the associated memory.
//
// Parameters:
//      hrc [in] : handle to the reco context to destroy
//////////////////////////////////////////////////////////////
HRESULT WINAPI DestroyContext(HRECOCONTEXT hrc)
{
    struct WispContext		*wisphrc;
	
	// validate and destroy the handle & return the pointer
	wisphrc = (struct WispContext*)DestroyTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
    {
		return E_INVALIDARG;
	}

	return DestroyContextInternal(wisphrc);
}

#ifdef ENABLE_CONFIDENCE_LEVEL

const ULONG PROPERTIES_COUNT = 2;

#else

const ULONG PROPERTIES_COUNT = 1;

#endif

// IRecognizer::GetResultPropertyList
HRESULT WINAPI GetResultPropertyList(HRECOGNIZER hrec, ULONG* pPropertyCount, GUID* pPropertyGuid)
{
    HRESULT hr = S_OK;

	struct WispRec *pRec;	

	// Check the recognizer handle
	pRec = (struct WispRec*)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
	if (NULL == pRec)
	{
        return E_INVALIDARG;
	}

    if (IsBadWritePtr(pPropertyCount, sizeof(ULONG)))
    {
        return E_POINTER;
    }

    if (!pPropertyGuid)
    {
        *pPropertyCount = PROPERTIES_COUNT; // For now we support only two GUID properties
    }
    else
    {
        // Check the array
        if (PROPERTIES_COUNT > *pPropertyCount)
        {
            return TPC_E_INSUFFICIENT_BUFFER;
        }

        if (IsBadWritePtr(pPropertyGuid, sizeof(GUID)*(*pPropertyCount)))
        {
            return E_POINTER;
        }

        pPropertyGuid[0] = GUID_LINEMETRICS;
#ifdef ENABLE_CONFIDENCE_LEVEL
        pPropertyGuid[1] = GUID_CONFIDENCELEVEL;
#endif
        *pPropertyCount = PROPERTIES_COUNT;
    }

    return hr;
}

// GetPreferredPacketDescription
//      Returns the preferred packet description for the recognizer
//      This is going to be x, y only for this recognizer
//
// Parameters:
//      hrec [in]                : The recognizer we want the preferred 
//                                 packet description for
//      pPacketDescription [out] : The packet description
/////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetPreferredPacketDescription(HRECOGNIZER hrec , PACKET_DESCRIPTION* pPacketDescription)
{
	struct WispRec *pRec;	

	// Check the recognizer handle
	pRec = (struct WispRec*)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
	if (NULL == pRec)
	{
        return E_INVALIDARG;
	}

	// validate the pointer
	if (IsBadWritePtr(pPacketDescription, sizeof(PACKET_DESCRIPTION)))
	{
		return E_POINTER;
	}

    // We can be called the first time with pPacketProperies
    // equal to NULL, just to get the size of those buffer
    // The second time we get called thoses buffers are allocated, so 
    // we can fill them with the data.
    if (pPacketDescription->pPacketProperties)
    {
        // Make sure that the pPacketProperties is of a valid size
        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2 * sizeof(LONG);
        
        // We are only setting 2 properties (X and Y)
		if (pPacketDescription->cPacketProperties < 2)
			return TPC_E_INSUFFICIENT_BUFFER;
        pPacketDescription->cPacketProperties = 2;
        
        // We are not setting buttons
        pPacketDescription->cButtons = 0;
        
		// Make sure that the pPacketProperties is of a valid size
        if (IsBadWritePtr(pPacketDescription->pPacketProperties, 2 * sizeof(PACKET_PROPERTY)))
		{
            return E_POINTER;
		}
        
        // Fill in pPacketProperies
        // Add the GUID_X
        pPacketDescription->pPacketProperties[0].guid = g_guidx;
        pPacketDescription->pPacketProperties[0].PropertyMetrics = g_DefaultPropMetrics;

        // Add the GUID_Y
        pPacketDescription->pPacketProperties[1].guid = g_guidy;
        pPacketDescription->pPacketProperties[1].PropertyMetrics = g_DefaultPropMetrics;
    }
    else
    {
        // Just fill in the PacketDescription structure leavin NULL
        // pointers for the pguidButtons and pPacketProperies

        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2*sizeof(LONG);

        // We are only setting 2 properties (X and Y)
        pPacketDescription->cPacketProperties = 2;

        // We are not setting buttons
        pPacketDescription->cButtons = 0;

        // There are not guid buttons
        pPacketDescription->pguidButtons = NULL;
    }

    return S_OK;
}

#define FUZZ_GEN	(1e-9)		// general fuzz - nine decimal digits

/**********************************************************************/
// Convert double to int
int RealToInt(double dbl)
{
	// Add in the rounding threshold.  
	// NOTE: The MAXWORD bias used in the floor function
	// below must not be combined with this line. If it
	// is combined the effect of FUZZ_GEN will be lost.
	dbl += 0.5 + FUZZ_GEN;
	
	// Truncate
	// The UINT_MAX bias in the floor function will cause
	// truncation (rounding toward minuse infinity) within
	// the range of a short.
	dbl = floor(dbl + UINT_MAX) - UINT_MAX;
	
	// Clip the result.
	return 	dbl > INT_MAX - 7 ? INT_MAX - 7 :
			dbl < INT_MIN + 7 ? INT_MIN + 7 : (int)dbl;
}

/**********************************************************************/
// Transform POINT array in place
void Transform(const XFORM *pXf, POINT * pPoints, ULONG cPoints)
{
    ULONG iPoint = 0;
    LONG xp = 0;

    if(NULL != pXf)
    {
        for(iPoint = 0; iPoint < cPoints; ++iPoint)
        {
	        xp =  RealToInt(pPoints[iPoint].x * pXf->eM11 + 
				pPoints[iPoint].y * pXf->eM21 + pXf->eDx);

	        pPoints[iPoint].y = RealToInt(pPoints[iPoint].x * pXf->eM12 + 
				pPoints[iPoint].y * pXf->eM22 + pXf->eDy);

	        pPoints[iPoint].x = xp;
        }
    }
}

HRESULT WINAPI AddStroke(HRECOCONTEXT hrc, const PACKET_DESCRIPTION* pPacketDesc, ULONG cbPacket, const BYTE *pPacket, const XFORM *pXForm)
{
    HRESULT                 hr = S_OK;
    ULONG                   ulPointCount = 0;
    STROKEINFO              stInfo;
    POINT                   *ptArray = NULL;
    struct WispContext      *wisphrc;
    ULONG                   ulXIndex = 0, ulYIndex = 0;
    BOOL                    bXFound = FALSE, bYFound = FALSE;
    ULONG                   ulPropIndex = 0;
    ULONG                   index = 0;
    int                     hres = 0;
    VRC                     *vrc = NULL;
    const LONG*             pLongs = (const LONG *)(pPacket);
    int                     temp = 0;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

	if (pPacketDesc != NULL && IsBadReadPtr(pPacketDesc, sizeof(PACKET_DESCRIPTION)))
	{
		return E_POINTER;
	}

	if (pXForm != NULL && IsBadReadPtr(pXForm, sizeof(XFORM)))
	{
		return E_POINTER;
	}

	// validate the data pointer
    if(IsBadReadPtr(pPacket, cbPacket))
	{
        return E_POINTER;
	}

    if (!wisphrc->hrc)
    {
		// If we have a free guide and this is not allowed by 
		// the recognizer, then fail.  Return an out of order
		// error because it probably means they forgot to 
		// set the guide before adding ink.
		if (g_pProbTable == NULL && !wisphrc->bIsBoxed)
		{
			return TPC_E_OUT_OF_ORDER_CALL;
		}
        hr = CreateHRCinContext(wisphrc);
        if (FAILED(hr)) 
		{
            return E_FAIL;
		}
    }

    if (wisphrc->bCACEndInk)
    {
        hr = SetCACMode(hrc, wisphrc->iCACMode);
        if (FAILED(hr)) 
            return E_FAIL;
    }

    vrc = (VRC*)wisphrc->hrc;

    // Get the number of packets
    if (pPacketDesc)
    {
        ASSERT(!(cbPacket%(pPacketDesc->cbPacketSize)));
        ulPointCount = (cbPacket)/(pPacketDesc->cbPacketSize);
    }
    else
    {
        ulPointCount = (cbPacket)/(2*sizeof(LONG));
    }

    // Fill in the stroke info stucture
    // Should check it does not exceed the size of a UINT
    stInfo.cPnt = ulPointCount;
    // PLEASE FIND ANOTHER WAY TO STORE THE STROKE INDEX!!!
    stInfo.dwTick = wisphrc->ulCurrentStrokeCount*60*1000;
    stInfo.wPdk = 0x0001;
    stInfo.cbPnts = ulPointCount*sizeof(POINT);

    wisphrc->ulCurrentStrokeCount++;

    // Find the index of GUID_X and GUID_Y
    if (pPacketDesc)
    {
        for (ulPropIndex = 0; ulPropIndex < pPacketDesc->cPacketProperties; ulPropIndex++)
        {
            if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulPropIndex].guid), &g_guidx))
            {
                bXFound = TRUE;
                ulXIndex = ulPropIndex;
            }
            else
            if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulPropIndex].guid), &g_guidy))
            {
                bYFound = TRUE;
                ulYIndex = ulPropIndex;
            }

            if (bXFound && bYFound) 
			{
				break;
			}
        }

        if (!bXFound || !bYFound)
        {
            // The coordinates are not part of the packet!
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            return TPC_E_INVALID_PACKET_DESCRIPTION;
        }

        // Allocate the memory for the stroke
        // Do it very poorly first (we could reuse the buffer)
        ptArray = (POINT*)ExternAlloc(ulPointCount*sizeof(POINT));
        if (!ptArray)
        {
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            return E_OUTOFMEMORY;
        }

        // Get the points from the packets
        for (index = 0; index < ulPointCount; index++, pLongs += (pPacketDesc->cbPacketSize)/sizeof(long))
        {
            // Feed the ptArray (array of points)
            ptArray[index].x = *(pLongs+ulXIndex);
            ptArray[index].y = *(pLongs+ulYIndex);
        }


        // TO DO, for now I transform the points so they
        // they are in the ink coordinates. It is up to
        // the recognizer team to decide what they should
        // use: raw ink or transformed ink
        Transform(pXForm, ptArray, ulPointCount);

        if (wisphrc->bIsBoxed)
        {
            if (HwxInput(wisphrc->hrc, ptArray, stInfo.cPnt, stInfo.dwTick))
                hres = HRCR_OK;
            else
                hres = HRCR_ERROR;
        }
        else
        {
            hres = AddPenInputHRC(wisphrc->hrc, ptArray, NULL, 0, &stInfo);
        }

        if ( hres != HRCR_OK)
        {
            hr = E_FAIL;
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            ExternFree(ptArray);
            return hr;
        }

        ExternFree(ptArray);
	temp = vrc->pLattice->nRealStrokes;
        InterlockedExchange(&(wisphrc->uAbort), temp);
    }
    else
    {
        if (wisphrc->bIsBoxed)
        {
            if (HwxInput(wisphrc->hrc, (POINT*)pPacket, stInfo.cPnt, stInfo.dwTick))
                hres = HRCR_OK;
            else
                hres = HRCR_ERROR;
        }
        else
        {
            hres = AddPenInputHRC(wisphrc->hrc, (POINT*)pPacket, NULL, 0, &stInfo);
        }
        if (hres != HRCR_OK)
        {
                hr = E_FAIL;
                // Remove the last stroke from the stroke array
                wisphrc->ulCurrentStrokeCount--;
                return hr;
        }

	temp = vrc->pLattice->nRealStrokes;
        InterlockedExchange(&(wisphrc->uAbort), temp);
    }

    ptArray = NULL;

    return hr;
}

HRESULT WINAPI GetBestResultString(HRECOCONTEXT hrc, ULONG *pcwSize, WCHAR* pszBestResult)
{
    struct WispContext      *wisphrc;
    HRESULT                 hr = S_OK;
    VRC                     *vrc = NULL;
    ULONG                   i = 0;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (IsBadWritePtr(pcwSize, sizeof(ULONG))) 
	{
        return E_POINTER;
	}

	// check the string pointer if needed
	if	(	pszBestResult && 
			IsBadWritePtr (pszBestResult, (*pcwSize) * sizeof (*pszBestResult))
		)
	{
		return E_POINTER;
	}

    vrc = (VRC*)wisphrc->hrc;
    if (!vrc)
    {
        *pcwSize = 0;
        return S_OK;
    }

    if (!vrc->pLatticePath) 
    {
        *pcwSize = 0;
        return S_OK;
    }

    if (!pszBestResult)
    {
        *pcwSize = vrc->pLatticePath->nChars;
        return S_OK;
    }

    // Make the length realistic
    if (*pcwSize > (ULONG)vrc->pLatticePath->nChars) 
	{
        *pcwSize = vrc->pLatticePath->nChars;
	}

    // Is the buffer too small?
    if (*pcwSize < (ULONG)vrc->pLatticePath->nChars)
	{
        hr = TPC_S_TRUNCATED;
	}

    for (i = 0; i < *pcwSize; i++)
    {
		pszBestResult[i] = vrc->pLatticePath->pElem[i].wChar;
    }

    return hr;
}

//
// GetBestAlternate
//
// This function create the best alternate from the best segmentation
//
// Parameters:
//      hrc [in] : the reco context
//      pHrcAlt [out] : pointer to the handle of the alternate
/////////////////
HRESULT WINAPI GetBestAlternate(HRECOCONTEXT hrc, HRECOALT* pHrcAlt)
{
	struct WispContext		*wisphrc;
    HRESULT                 hr = S_OK;
    ULONG                   cbSize = 0;
    struct WispAlternate    *pWispAlt = NULL;
    VRC                     *vrc = NULL;
    ULONG                   i = 0;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}
	
    // First get the number of characters in the string
    vrc = (VRC*)wisphrc->hrc;
    if (!vrc)
    {
        return TPC_E_NOT_RELEVANT;
    }

    if (!vrc->pLatticePath)
    {
        // There is no ink
        return TPC_E_NOT_RELEVANT;
    }

    cbSize = vrc->pLatticePath->nChars;

    // Create the alternate
    pWispAlt = (struct WispAlternate*)ExternAlloc(sizeof(struct WispAlternate));
    if (!pWispAlt) 
	{
        return E_OUTOFMEMORY;
	}

    ZeroMemory(pWispAlt, sizeof(struct WispAlternate));
    pWispAlt->iNumberOfColumns = cbSize;
    pWispAlt->iLength = cbSize;
    pWispAlt->OriginalRecoRange.iwcBegin = 0;
    pWispAlt->OriginalRecoRange.cCount = cbSize;
    pWispAlt->hrc = hrc;
    if (cbSize)
    {
        pWispAlt->pColumnIndex = ExternAlloc(sizeof(ULONG)*cbSize);
        if (!pWispAlt->pColumnIndex)
        {
            ExternFree(pWispAlt);
            return E_OUTOFMEMORY;
        }

        // Initialize the column index array
        for (i = 0; i<cbSize; i++)
        {
            pWispAlt->pColumnIndex[i] = vrc->pLatticePath->pElem[i].iStroke;
        }
        pWispAlt->pIndexInColumn = ExternAlloc(sizeof(ULONG)*cbSize);
        if (!pWispAlt->pIndexInColumn)
        {
            ExternFree(pWispAlt->pColumnIndex);
            ExternFree(pWispAlt);
            return E_OUTOFMEMORY;
        }
        // The best alternate doe not always have the index 0 in the alternate column
        // Initialize the index in column array
        for (i = 0; i<cbSize; i++)
        {
            pWispAlt->pIndexInColumn[i] = vrc->pLatticePath->pElem[i].iAlt;
        }
    }

	// create a tpg handle
	*pHrcAlt = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pWispAlt);
	if (0 == *pHrcAlt)
	{
		ExternFree (pWispAlt->pIndexInColumn);
		ExternFree (pWispAlt->pColumnIndex);
		ExternFree (pWispAlt);

		return E_OUTOFMEMORY;
	}

    return S_OK;
}

// internal implementation: destroy the wispalternate structure
HRESULT DestroyAlternateInternal(struct WispAlternate *wisphrcalt)
{
    ExternFree(wisphrcalt->pColumnIndex);
    ExternFree(wisphrcalt->pIndexInColumn);
    ExternFree(wisphrcalt);
    
    return S_OK;
}

//
// DestroyAlternate
//
// This function destroys an alternate, freeing the allocated memory
//
// Parameters:
//		hrcalt [in] : handle of the alternate to be destroyed
/////////////////
HRESULT WINAPI DestroyAlternate(HRECOALT hrcalt)
{
    struct WispAlternate        *wisphrcalt;

	wisphrcalt	=	(struct WispAlternate *) DestroyTpgHandle (hrcalt, TPG_HRECOALT);
	if (NULL == wisphrcalt)
	{
		return E_INVALIDARG;
	}

    return DestroyAlternateInternal (wisphrcalt);
}

HRESULT WINAPI SetGuide(HRECOCONTEXT hrc, const RECO_GUIDE* pGuide, ULONG iIndex)
{
    struct WispContext      *wisphrc;
    HWXGUIDE                hwxGuide;
    HRESULT                 hr = S_OK;
    BOOL                    bGuideAlreadySet = FALSE;
    RECO_GUIDE              rgOldGuide;
    ULONG                   uiOldIndex = 0;
    BOOL                    bIsOldGuideBox = FALSE;
    BOOL                    bIsHRCAlreadyCreated = FALSE;

    // find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}
	
    if (pGuide != NULL && IsBadReadPtr(pGuide, sizeof(RECO_GUIDE))) 
	{
        return E_POINTER;
	}

	if (pGuide != NULL)
	{ 
		if ((pGuide->cHorzBox < 0 || pGuide->cVertBox < 0) ||    // invalid
			(pGuide->cHorzBox == 0 && pGuide->cVertBox > 0) ||   // horizontal lined mode
			(pGuide->cHorzBox > 0 && pGuide->cVertBox == 0) ||   // vertical lined mode
			(g_pProbTable == NULL && pGuide->cHorzBox == 0 && pGuide->cVertBox == 0))    // free mode not allowed sometimes
		{
			return E_INVALIDARG;
		}
	}	

	if (pGuide == NULL && g_pProbTable == NULL)
	{
		// Can't do free mode, but got a NULL guide, so return an error.
		return E_INVALIDARG;
	}

    // Is there already an HRC
    if (wisphrc->hrc)
    {
        bIsHRCAlreadyCreated = TRUE;
    }

    // Save the old values in case the call to the
    // recognizer fails
    if (wisphrc->pGuide)
    {
        bGuideAlreadySet = TRUE;
        rgOldGuide = *(wisphrc->pGuide);
        uiOldIndex = wisphrc->uiGuideIndex;
        bIsOldGuideBox = wisphrc->bIsBoxed;
    }

    // If there was no guide already present, allocate one
    if (!wisphrc->pGuide) 
        wisphrc->pGuide = ExternAlloc(sizeof(RECO_GUIDE));
    if (!wisphrc->pGuide) 
        return E_OUTOFMEMORY;

	// If the guide is NULL, then treat it as all zeros (free mode)
	if (pGuide != NULL) 
	{
	    *(wisphrc->pGuide) = *pGuide;
	} 
	else
	{
		ZeroMemory(wisphrc->pGuide, sizeof(RECO_GUIDE));
	}
    wisphrc->uiGuideIndex = iIndex;

    // Check if we are in box mode or free input mode
    if (wisphrc->pGuide->cHorzBox && wisphrc->pGuide->cVertBox)
    {
        // We are in the box api mode
        // We need to have a proper conversion
        ZeroMemory(&hwxGuide, sizeof(HWXGUIDE));

        hwxGuide.cHorzBox = wisphrc->pGuide->cHorzBox;
        hwxGuide.cVertBox = wisphrc->pGuide->cVertBox;
        hwxGuide.cxBox = wisphrc->pGuide->cxBox;
        hwxGuide.cyBox = wisphrc->pGuide->cyBox;
        hwxGuide.xOrigin = wisphrc->pGuide->xOrigin;
        hwxGuide.yOrigin = wisphrc->pGuide->yOrigin;

        hwxGuide.cxOffset       =   wisphrc->pGuide->cxBase ;
        hwxGuide.cyOffset       =   0;
        hwxGuide.cxWriting      =   wisphrc->pGuide->cxBox - (2 * wisphrc->pGuide->cxBase) ;

        if (wisphrc->pGuide->cyBase > 0) {
            hwxGuide.cyWriting      =   wisphrc->pGuide->cyBase ;
        } else {
            hwxGuide.cyWriting      =   wisphrc->pGuide->cyBox ;
        }

        hwxGuide.cyMid          =   0 ;
        hwxGuide.cyBase         =   0 ; 
        hwxGuide.nDir           =   HWX_HORIZONTAL ;

        // Is the hrc already created
        if (bIsHRCAlreadyCreated)
        {
            // Are we already in box mode?
            if (!wisphrc->bIsBoxed)
            {
                // We need to switch to a box hrc if possible
                if (wisphrc->ulCurrentStrokeCount == 0)
                {
                    // Destroy the previous context
                    DestroyHRC(wisphrc->hrc);
                    wisphrc->hrc = NULL;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        wisphrc->bIsBoxed = TRUE;
        if (SUCCEEDED(hr) && !wisphrc->hrc)
        {
            hr = CreateHRCinContext(wisphrc);
            if (FAILED(hr)) 
                hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            if (HwxSetGuide(wisphrc->hrc, &hwxGuide))
            {
                if (TRUE == HwxSetAbort(wisphrc->hrc, &(wisphrc->uAbort)))
                {
                    return S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else
    {
        wisphrc->bIsBoxed = FALSE;
        if (!wisphrc->hrc)
        {
            // We need to switch to a free hrc if possible
            if (wisphrc->ulCurrentStrokeCount == 0)
            {
                // Destroy the previous context
                HwxDestroy(wisphrc->hrc);
                wisphrc->hrc = NULL;
            }
            else
            {
                hr = E_FAIL;
            }
        }

        hr = CreateHRCinContext(wisphrc);
        if (FAILED(hr)) 
            hr = E_FAIL;

        // we are in the free api mode
        if (SUCCEEDED(hr))
        {
			if (HRCR_OK == SetGuideHRC(wisphrc->hrc, (GUIDE *)wisphrc->pGuide, iIndex))
				return S_OK;
			hr = E_INVALIDARG;
        }
    }

    // The calls did not succeed. 
    // If we allocated an hrc, destroy it
    if (!bIsHRCAlreadyCreated && wisphrc->hrc)
    {
        if (wisphrc->bIsBoxed)
        {
            HwxDestroy(wisphrc->hrc);
        }
        else
        {
            DestroyHRC(wisphrc->hrc);
        }
        wisphrc->hrc = NULL;
    }
    // Set back the old guide 
    if (bGuideAlreadySet)
    {
        *(wisphrc->pGuide) = rgOldGuide;
        wisphrc->bIsBoxed = bIsOldGuideBox;
        wisphrc->uiGuideIndex = uiOldIndex;
    }
    else
    {
        ExternFree(wisphrc->pGuide);
        wisphrc->pGuide = NULL;
        wisphrc->bIsBoxed = FALSE;
    }
    return hr;
}

HRESULT WINAPI GetGuide(HRECOCONTEXT hrc, RECO_GUIDE* pGuide, ULONG *piIndex)
{
    struct WispContext      *wisphrc;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}
	
    if (IsBadWritePtr(pGuide, sizeof(RECO_GUIDE)))
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(piIndex, sizeof(ULONG)))
	{
        return E_POINTER;
	}

    if (!wisphrc->pGuide) 
	{
        return S_FALSE;
	}

    if (wisphrc->pGuide) 
	{
        *pGuide = *(wisphrc->pGuide);
	}

    if (piIndex) 
	{
        *piIndex = wisphrc->uiGuideIndex;
	}

    return S_OK;
}

HRESULT WINAPI AdviseInkChange(HRECOCONTEXT hrc, BOOL bNewStroke)
{
    struct WispContext      *wisphrc;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}
	
    InterlockedIncrement(&(wisphrc->uAbort));
    return S_OK;
}

HRESULT WINAPI SetCACMode(HRECOCONTEXT hrc, int iMode)
{
    HRESULT                 hr = S_OK;
    struct WispContext      *wisphrc;
    VRC                     *vrc;
    HRECOCONTEXT            CloneHrc = NULL;
    HRC                     OldHrc = NULL;
    int                     i = 0, j = 0;
    int                     iCACMode = 0;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (!wisphrc->bIsBoxed) 
	{
        return E_FAIL;
	}

    if (iMode != CAC_FULL && iMode != CAC_PREFIX && iMode != CAC_RANDOM) 
	{
        return E_INVALIDARG;
	}

    vrc = (VRC*)wisphrc->hrc;

    OldHrc = wisphrc->hrc;

    wisphrc->hrc = NULL;

    // Create the new context
    wisphrc->hrc = HwxCreate(OldHrc);

    if (!wisphrc->hrc)
    {
        wisphrc->hrc = OldHrc;
        return E_FAIL;
    }

    if (FALSE == HwxSetAbort(wisphrc->hrc, &(wisphrc->uAbort)))
	{
        ASSERT(0);
	}

    // Set the CAC mode
    if (iMode == CAC_FULL)
	{
        iCACMode = HWX_PARTIAL_ALL;
	}
	else
    if (iMode == CAC_PREFIX)
	{
        iCACMode = HWX_PARTIAL_ORDER;
	}
	else
    if (iMode == CAC_RANDOM)
	{
        iCACMode = HWX_PARTIAL_FREE;
	}

    if (!HwxSetPartial(wisphrc->hrc, iCACMode))
    {
        // Put things back together
        HwxDestroy(wisphrc->hrc);
        wisphrc->hrc = ((struct WispContext*)OldHrc)->hrc;

        return E_FAIL;
    }

    wisphrc->bIsCAC = TRUE;
    wisphrc->iCACMode = iMode;
    wisphrc->bCACEndInk = FALSE;

    // TO DO
    // TO DO
    //
    // We probably need to store the original ink, not use the smoothed and merged ink that
    // is store in the Lattice...

    // We need to get the ink from the old context, if there was an old context
	if (vrc != NULL) 
	{
		for (i = 0; i < vrc->pLattice->nStrokes; i++)
		{
			// We need to reorder the strokes to have them in the same order
			for (j = 0; j < vrc->pLattice->nStrokes; j++)
			{
				if (vrc->pLattice->pStroke[j].iOrder == i)
				{
					// Add the Stroke to the new context
					if (!HwxInput(wisphrc->hrc, vrc->pLattice->pStroke[j].pts, vrc->pLattice->pStroke[j].nInk, vrc->pLattice->pStroke[j].timeStart))
					{
						hr = E_FAIL;
					}
					break;
				}
			}
		}

		wisphrc->uAbort = vrc->pLattice->nStrokes;
		if (vrc->fBoxedInput)
			HwxDestroy(OldHrc);
		else
			DestroyHRC(OldHrc);
	}
	else
	{
	    wisphrc->uAbort = 0;
	}

    return hr;
}

HRESULT WINAPI EndInkInput(HRECOCONTEXT hrc)
{
    struct WispContext      *wisphrc;

    // find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (wisphrc->bIsBoxed)
    {
        if (HwxEndInput(wisphrc->hrc))
            return S_OK;
    }
    else
    {
        if (HRCR_OK == EndPenInputHRC(wisphrc->hrc))
            return S_OK;
    }

    if (!wisphrc->ulCurrentStrokeCount)
	{
        return S_OK; // We do not have ink yet
	}

    return E_FAIL;
}

// Given a recognition context, create a new one which has no ink in it, but
// is otherwise identical.  An error is returned if there are any allocation
// problems (which should be the only types of errors).
HRESULT WINAPI CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc)
{
    struct WispContext      *pWispContext = NULL;
    struct WispContext      *wisphrc;
    HRESULT                 hRes = S_OK, hr = S_OK;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (IsBadWritePtr(pCloneHrc, sizeof(HRECOCONTEXT))) 
	{
        return E_POINTER;
	}

    pWispContext = (struct WispContext*)ExternAlloc(sizeof(struct WispContext));
    if (!pWispContext) 
	{
        return E_OUTOFMEMORY;
	}

    // Did we already create a context???
    if (!wisphrc->hrc)
    {
        // The context was not already created
        memcpy(pWispContext, wisphrc, sizeof(struct WispContext));
		// If a guide was created, then we would have a context
        ASSERT(!wisphrc->pGuide);
		pWispContext->pGuide = NULL;
		// You can't get a lattice until after processing has been done (in a context)
        ASSERT(!wisphrc->pLattice);
		pWispContext->pLattice = NULL;
		pWispContext->pLatticeProperties = NULL;
		pWispContext->pLatticePropertyValues = NULL;
		pWispContext->ppLatticeProperties = NULL;

        // Copy the text context
        if (wisphrc->bHasTextContext)
        {
            pWispContext->bHasTextContext = TRUE;
            pWispContext->wszBefore = Externwcsdup(wisphrc->wszBefore);
            pWispContext->wszAfter = Externwcsdup(wisphrc->wszAfter);
            if (pWispContext->wszBefore == NULL || pWispContext->wszAfter == NULL)
            {
                ExternFree(pWispContext->wszBefore);
                ExternFree(pWispContext->wszAfter);
                ExternFree(pWispContext);
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            pWispContext->bHasTextContext = FALSE;
            pWispContext->wszBefore = NULL;
            pWispContext->wszAfter = NULL;
        }

        // Copy factoid setting
        if (wisphrc->wszFactoid)
        {
            pWispContext->wszFactoid = Externwcsdup(wisphrc->wszFactoid);
            if (pWispContext->wszFactoid == NULL)
            {
                ExternFree(pWispContext->wszAfter);
                ExternFree(pWispContext->wszBefore);
                ExternFree(pWispContext);
                return E_OUTOFMEMORY;
            }
        }
		else
		{
			pWispContext->wszFactoid = NULL;
		}
    }
    else
    {
        // Depending of whether we are in box mode create the hwx hrc
        if (!wisphrc->bIsBoxed)
        {
            pWispContext->bIsBoxed = FALSE;
            pWispContext->hrc = CreateCompatibleHRC(wisphrc->hrc, NULL);
        }
        else
        {
            pWispContext->bIsBoxed = TRUE;
            pWispContext->hrc = HwxCreate(wisphrc->hrc);
        }
        if (!pWispContext->hrc)
        {
			hr = E_OUTOFMEMORY;
        }

        // Set the context variables
		if (SUCCEEDED(hr) && wisphrc->bHasTextContext)
		{
			pWispContext->bHasTextContext = TRUE;
			pWispContext->wszBefore = Externwcsdup(wisphrc->wszBefore);
			pWispContext->wszAfter = Externwcsdup(wisphrc->wszAfter);
			if (pWispContext->wszBefore == NULL || pWispContext->wszAfter == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			pWispContext->bHasTextContext = FALSE;
			pWispContext->wszBefore = NULL;
			pWispContext->wszAfter = NULL;
		}

        // Copy flags
        pWispContext->dwFlags = wisphrc->dwFlags;

        // Copy factoid setting
        if (SUCCEEDED(hr) && wisphrc->wszFactoid)
        {
            pWispContext->wszFactoid = Externwcsdup(wisphrc->wszFactoid);
            if (pWispContext->wszFactoid == NULL)
            {
				hr = E_OUTOFMEMORY;
            }
        }
		else
		{
			pWispContext->wszFactoid = NULL;
		}

        // Set the guide for the Wisp structure
        if (SUCCEEDED(hr) && wisphrc->pGuide)
        {
            pWispContext->pGuide = ExternAlloc(sizeof(RECO_GUIDE));
            if (!pWispContext->pGuide)
            {
				hr = E_OUTOFMEMORY;
            }
			else
			{
				*(pWispContext->pGuide) = *(wisphrc->pGuide);
				pWispContext->uiGuideIndex = wisphrc->uiGuideIndex;
			}
        }
        else
        {
            pWispContext->pGuide = NULL;
        }

        // Set the abort for hwx
        pWispContext->uAbort = 0;
        if (SUCCEEDED(hr) && pWispContext->bIsBoxed)
        {
            if (!HwxSetAbort(pWispContext->hrc, &(pWispContext->uAbort)))
			{
				hr = E_FAIL;
			}
        }
        pWispContext->ulCurrentStrokeCount = 0;
        pWispContext->bCACEndInk = FALSE;
        pWispContext->bIsCAC = FALSE;

        // Set the CAC Mode
        if (SUCCEEDED(hr) && wisphrc->bIsCAC)
        {
            pWispContext->bIsCAC = TRUE;
			pWispContext->iCACMode = wisphrc->iCACMode;
        }
    }

    // Clean the lattice
    pWispContext->pLattice = NULL;
	pWispContext->pLatticeProperties = NULL;
	pWispContext->pLatticePropertyValues = NULL;
	pWispContext->ppLatticeProperties = NULL;

    if (SUCCEEDED(hr))
    {
		// create a tpg handle
		*pCloneHrc	= (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pWispContext);
		if (NULL == (*pCloneHrc))
		{
			hr	=	E_OUTOFMEMORY;
		}
    }

    if (!SUCCEEDED(hr))
    {
        hRes = DestroyContextInternal(pWispContext);
        ASSERT(SUCCEEDED(hRes));
    }

    return hr;
}

// ResetContext
//      This function keeps the settings on the passed reco context
//      but purges it of the ink it contains. If the EndInkInput
//      had been called on the reco context, Reset context will
//      now allow more ink to be entered.
//
// Parameter:
//      hrc [in] : the handle to the reco context
/////////////////////////////////////////////////////////
HRESULT WINAPI ResetContext(HRECOCONTEXT hrc)
{
    struct WispContext      *wisphrc;
    HRESULT                 hr = S_OK;
	HRC						hrcold = NULL;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (!wisphrc->hrc) 
	{
		return S_OK;
	}

	// Save the old HRC (in case of an error), and put in the new one
	hrcold = wisphrc->hrc;

    if (!wisphrc->bIsBoxed)
    {
        wisphrc->hrc = CreateCompatibleHRC(wisphrc->hrc, NULL);
    }
    else
    {
        wisphrc->hrc = HwxCreate(wisphrc->hrc);
    }

    if (!wisphrc->hrc)
    {
		wisphrc->hrc = hrcold;
        return E_FAIL;
    }

    // If there was a guide, put it back
    if (SUCCEEDED(hr) && wisphrc->pGuide)
    {
        hr = SetGuide(hrc, wisphrc->pGuide, wisphrc->uiGuideIndex);
    }
    if (SUCCEEDED(hr) && wisphrc->bIsCAC)
    {
        hr = SetCACMode(hrc, wisphrc->iCACMode);
    }
    if (SUCCEEDED(hr) && wisphrc->bHasTextContext)
    {
        hr = SetTextContext(hrc, 
                    wcslen(wisphrc->wszBefore), wisphrc->wszBefore, 
                    wcslen(wisphrc->wszAfter), wisphrc->wszAfter);
    }

	if (SUCCEEDED(hr)) 
	{
	    hr = SetFlags(hrc, wisphrc->dwFlags);
	}

	if (SUCCEEDED(hr))
	{
		if (wisphrc->wszFactoid) 
			hr = SetFactoid(hrc, wcslen(wisphrc->wszFactoid), wisphrc->wszFactoid);
		else
			hr = SetFactoid(hrc, 0, wisphrc->wszFactoid);
	}

	if (FAILED(hr)) 
	{
		// Something went wrong.  Restore the context to its original state.
		if (!wisphrc->bIsBoxed)
		{
			DestroyHRC(wisphrc->hrc);
		}
		else
		{
			HwxDestroy(wisphrc->hrc);
		}
		wisphrc->hrc = hrcold;
		return hr;
	}

	// These changes are done last, because they can't be undone easily.  
	// All error cases have already been taken care of above.
    wisphrc->ulCurrentStrokeCount = 0;
    wisphrc->uAbort = 0;
    wisphrc->bCACEndInk = FALSE;

    if (wisphrc->pLattice) 
    {
        hr = FreeRecoLattice(wisphrc);
    }
    wisphrc->pLattice = NULL;

    if (!wisphrc->bIsBoxed)
    {
		DestroyHRC(hrcold);
    }
    else
    {
		HwxDestroy(hrcold);
    }

    return hr;
}

// Sets the prefix and suffix context for the recognition context.  Can 
// return errors on memory allocation failure.  Note that this function 
// is called with the strings pointing at the strings already in the HRC,
// so we need to be careful not to free the old strings before copying them.
HRESULT WINAPI SetTextContext(HRECOCONTEXT hrc, ULONG cwcBefore, const WCHAR *pwcBefore, ULONG cwcAfter, const WCHAR *pwcAfter)
{
    HRESULT                 hr			= S_OK;
    struct WispContext      *wisphrc;
	WCHAR					*wszBefore, *wszAfter;

    // find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if	(	IsBadReadPtr(pwcBefore, cwcBefore * sizeof(WCHAR)) || 
			IsBadReadPtr(pwcAfter, cwcAfter * sizeof(WCHAR))
		)
	{
        return E_POINTER;
	}

    wszBefore = ExternAlloc((cwcBefore + 1) * sizeof(WCHAR));
    if (wszBefore == NULL)
	{
        return E_OUTOFMEMORY;
	}

    wszAfter = ExternAlloc((cwcAfter + 1) * sizeof(WCHAR));
    if (wszAfter == NULL) 
    {
        ExternFree(wszBefore);
        return E_OUTOFMEMORY;
    }

    memcpy(wszBefore, pwcBefore, cwcBefore * sizeof(WCHAR));
    wszBefore[cwcBefore] = 0;
    memcpy(wszAfter, pwcAfter, cwcAfter * sizeof(WCHAR));
    wszAfter[cwcAfter] = 0;

	// If we have a context already, then try to set this context.
	// The only errors are memory allocation errors, so we don't need
	// to create a context here to make sure the call will succeed.
    if (wisphrc->hrc)
	{
        if (!SetHwxCorrectionContext(wisphrc->hrc, wszBefore, wszAfter))
		{
            hr = E_FAIL;
		} 
	}

	// If everything went okay, then we can update the context.
	if (SUCCEEDED(hr)) 
	{
	    wisphrc->bHasTextContext = TRUE;
		ExternFree(wisphrc->wszBefore);
		ExternFree(wisphrc->wszAfter);
		wisphrc->wszBefore = wszBefore;
		wisphrc->wszAfter = wszAfter;
	}

    return hr;
}

// Create an alternate (returned by setting the pointer ppAlt).  The contents of
// the alternate are determined by pAltStruct and pdbList.
HRESULT CreateDifBreakAlternate(DifBreakList* pdbList, DifBreakAltStruct *pAltStruct, struct WispAlternate **ppAlt)
{
    int                 i = 0;
    VRC                 *vrc = pAltStruct->vrc;
    DiffBreakElement    *pCur = NULL;

    *ppAlt = (struct WispAlternate*)ExternAlloc(sizeof(struct WispAlternate));
    if (!*ppAlt) 
        return E_OUTOFMEMORY;
    ZeroMemory(*ppAlt, sizeof(struct WispAlternate));
    // Initialize the new alternate structure
    (*ppAlt)->iLength = (*ppAlt)->iNumberOfColumns = pdbList->iColumnCount;
    (*ppAlt)->pColumnIndex = (int*)ExternAlloc(sizeof(int)*(*ppAlt)->iNumberOfColumns);
    if (!(*ppAlt)->pColumnIndex)
    {
        ExternFree(*ppAlt);
        return E_OUTOFMEMORY;
    }
    (*ppAlt)->pIndexInColumn = (int*)ExternAlloc(sizeof(int)*(*ppAlt)->iNumberOfColumns);
    if (!(*ppAlt)->pIndexInColumn)
    {
        ExternFree((*ppAlt)->pColumnIndex);
        ExternFree(*ppAlt);
        return E_OUTOFMEMORY;
    }
    (*ppAlt)->OriginalRecoRange.iwcBegin = pAltStruct->iFirstChar;
    (*ppAlt)->OriginalRecoRange.cCount = pAltStruct->iLastChar - 
        pAltStruct->iFirstChar + 1;
    pCur = pdbList->pFirst;
    for (i = 0; i < pdbList->iColumnCount; i++)
    {
        // Add the ColumnIndex
        (*ppAlt)->pColumnIndex[i] = pCur->iColumn;
        (*ppAlt)->pIndexInColumn[i] = pCur->iIndex;
        pCur = pCur->pNext;
    }
    return S_OK;
}

BOOL AddToDefSegList(DifBreakList* pdbList, DifBreakAltStruct *pAltStruct)
{
    AltRank             *pAltRank = NULL;
    HRESULT             hr = S_OK, hRes = S_OK;
    AltRankList         *pAltRankList = pAltStruct->paltRankList;
    AltRank             *pPrev = NULL, *pCur;
    UINT                i = 0;
    DiffBreakElement    *pCurrent = NULL;
    int                 j = 0;

	// Doesn't make sense to add alternates to a list when no alternates are allowed.
	ASSERT(pAltStruct->ulMax > 0);
	if (pAltStruct->ulMax == 0) 
	{
		return TRUE;
	}

    // Is the score even interesting?
    if (pAltRankList->ulSize == pAltStruct->ulMax && 
		!pdbList->bCurrentPath &&
		pAltRankList->pLast != NULL && 
		pAltRankList->pLast->fScore >= pdbList->score)
        return TRUE;
    // Is the decomposition interesting (depending on the recognition mode)
    // For now yes, everyting is interesting!
    // Create the alternate
    pAltRank = (AltRank*)ExternAlloc(sizeof(AltRank));
    if (!pAltRank) 
        return FALSE;

    pAltRank->fScore = pdbList->score;
    // All paths created here are not on the current path
    pAltRank->bCurrentPath = pdbList->bCurrentPath;
    pAltRank->next = NULL;
    // Add the new alternate at the current location
    hr = CreateDifBreakAlternate(pdbList, pAltStruct, &(pAltRank->wispalt));
    if (FAILED(hr))
    {
        ExternFree(pAltRank);
        return FALSE;
    }
    if (!pAltRankList->pFirst)
    {
        // Add at the start of the location
        pAltRankList->pFirst = pAltRank;
        pAltRankList->pLast = pAltRank;
        pAltRankList->ulSize = 1;
        return TRUE;
    }
    // If the new alternate is the current path, then it goes to the top of the list.
    // If not, and the current top of list is not on the current path, then compare scores.
    if (pdbList->bCurrentPath ||
        (!pAltRankList->pFirst->bCurrentPath && pAltRankList->pFirst->fScore < pdbList->score))
    {
        // Add at the start of the location
        pAltRank->next = pAltRankList->pFirst;
        pAltRankList->pFirst = pAltRank;
        if (pAltRankList->ulSize == pAltStruct->ulMax)
        {
            // Delete the last element
            hRes = DestroyAlternateInternal(pAltRankList->pLast->wispalt);
            ASSERT(SUCCEEDED(hRes));
            ExternFree(pAltRankList->pLast);
            // Get a pointer to the last element
            pCur = pAltRankList->pFirst;
            while(pCur->next != pAltRankList->pLast)
                pCur = pCur->next;
            pAltRankList->pLast = pCur;
            pCur->next = NULL;
        }
        else
		{
            pAltRankList->ulSize++;
		}
        return TRUE;
    }
    pCur = pAltRankList->pFirst;
    // Insert the link at the right location
    for (i = 0; i < pAltRankList->ulSize - 1; i++)
    {
        pPrev = pCur;
        pCur = pCur->next;
        if (pCur->fScore < pdbList->score)
        {
            // insert at the pPrev
            pAltRank->next = pCur;
            pPrev->next = pAltRank;
            if (pAltRankList->ulSize == pAltStruct->ulMax)
            {
                // Delete the last element
                HRESULT hrDA = DestroyAlternateInternal(pAltRankList->pLast->wispalt);
				ASSERT(SUCCEEDED(hrDA));
                ExternFree(pAltRankList->pLast);
                // Get a pointer to the last element
                pCur = pAltRankList->pFirst;
                while(pCur->next != pAltRankList->pLast)
                    pCur = pCur->next;
                pAltRankList->pLast = pCur;
                pCur->next = NULL;
            }
            else
			{
                pAltRankList->ulSize++;
			}
			return TRUE;
        }
    }
    // We are actually adding at the end of the list
    pAltRank->next = NULL;
    pAltRankList->pLast->next = pAltRank;
    pAltRankList->pLast = pAltRank;
    pAltRankList->ulSize++; // obviously we still have room

    return TRUE;
}

/*
static float GetScore(LATTICE *pLattice, int iStroke, int iAlt)
{
	if (pLattice->fUseGuide)
	{
		return pLattice->pAltList[iStroke].alts[iAlt].logProb;
	}
	else
	{
		return pLattice->pAltList[iStroke].alts[iAlt].logProb * pLattice->pAltList[iStroke].alts[iAlt].nStrokes;
	}
}
*/

BOOL GetRecDifSegAltList(int iCurrentStroke, int iCurrentIndex, DifBreakList* pdbList, DifBreakAltStruct *pAltStruct)
{
    int                 iNextStroke = 0;
    int                 i = 0, j = 0, l = 0;
    DiffBreakElement    dbElement;
	DiffBreakElement	dbSpaceElement;
    float               fOriginalScore = pdbList->score;
    BOOL                bOriginalCurrentPath = pdbList->bCurrentPath;
    BOOL                bSomethingAdded = FALSE;
    BOOL                bMainSeg = FALSE;
    int                 iNumberOfStrokes = 0;
    BOOL                bAllBreakSkip = FALSE;

    int iNextNextStroke = 0;
    BOOL bSameBreak = FALSE;
	BOOL				bOkay = TRUE;

    iNextStroke = iCurrentStroke - 
        pAltStruct->vrc->pLattice->pAltList[iCurrentStroke].alts[iCurrentIndex].nStrokes;
    // Check if we are at the end (we include uiFirstIndex)
    if (pAltStruct->iMode == LARGE_BREAKS)
    {
        if (pAltStruct->vrc->pLattice->pAltList[iCurrentStroke].alts[iCurrentIndex].nStrokes 
            > iCurrentStroke-pAltStruct->iFirstStroke)
        {
            // Yes this is a last (or rather "first") stroke
            // But does this stroke correspond to the start of a stroke from the main
            // segmentation?
            bMainSeg = FALSE;
            for (j = pAltStruct->iLastChar; j>=0; j--)
            {
                if (pAltStruct->vrc->pLatticePath->pElem[j].iStroke -
                    pAltStruct->vrc->pLatticePath->pElem[j].nStrokes ==
                    iNextStroke)
                {
                    bMainSeg = TRUE;
                    pAltStruct->iFirstChar = j;
                    break;
                }
            }
            // Add this to the stroke list
            if (bMainSeg)
                return AddToDefSegList(pdbList, pAltStruct);
        }
    }
    else
    {
        if (pAltStruct->vrc->pLattice->pAltList[iCurrentStroke].alts[iCurrentIndex].nStrokes 
            == iCurrentStroke-pAltStruct->iFirstStroke+1)
        {
            // We are at the end
            for (j = pAltStruct->iLastChar; j>=0; j--)
            {
                if (pAltStruct->vrc->pLatticePath->pElem[j].iStroke -
                    pAltStruct->vrc->pLatticePath->pElem[j].nStrokes ==
                    iNextStroke)
                {
                    pAltStruct->iFirstChar = j;
					return AddToDefSegList(pdbList, pAltStruct);
                }
            }
			// This is an error case
            return FALSE;
        }
        if (pAltStruct->vrc->pLattice->pAltList[iCurrentStroke].alts[iCurrentIndex].nStrokes 
            > iCurrentStroke-pAltStruct->iFirstStroke+1)
        {
			// Not an error, we just stepped back too far in the lattice.
            return TRUE;
        }
    }

    // We are not at the end (or start) of the alternate, dig deeper

	// First, see if we need a space
	if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].fSpaceAfterStroke)
	{
		dbSpaceElement.iColumn = iNextStroke;
		dbSpaceElement.iIndex = SPACE_ALT_ID;
		dbSpaceElement.pNext = pdbList->pFirst;
		pdbList->iColumnCount++;
		pdbList->pFirst = &dbSpaceElement;
	}

	// Then add on the placeholder for the current character
    dbElement.iColumn = iNextStroke;
    dbElement.pNext = pdbList->pFirst;
    pdbList->iColumnCount++;
    pdbList->pFirst = &dbElement;

    // In the case of ALT_BREAKS_SAME, get the number of strokes of the best result's column
    if (pAltStruct->iMode == ALT_BREAKS_SAME)
    {
        iNumberOfStrokes = -1;
        for (i = 0; i < pAltStruct->vrc->pLattice->pAltList[iNextStroke].nUsed; i++)
        {
            if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].fCurrentPath)
            {
                iNumberOfStrokes = pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].nStrokes;
                break;
            }
        }
        ASSERT(iNumberOfStrokes>0);
		// If we don't find the current path, something has gone wrong.  The 
		// rest of the code will behave sensibly, though, so continue.
    }

    for (i = 0; i < pAltStruct->vrc->pLattice->pAltList[iNextStroke].nUsed; i++)
    {
        // TBD:
        // Here we should have an optimization to know if
        // we should continue processing the alternates with the
        // same decomposition
        if (pAltStruct->iMode == ALT_BREAKS_SAME)
            if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].nStrokes != iNumberOfStrokes)
                continue;

        // If we have been on the current path so far and are still on it with this
        // node, then we are staying on the current path
        pdbList->bCurrentPath = bOriginalCurrentPath && 
            pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].fCurrentPath;
		
		// Only need to skip alternates if we are trying to get one of each 
		// segmentation.  And we never need to skip the current path, since we
		// always want to return that segmentation.
		if (pAltStruct->iMode == ALT_BREAKS_UNIQUE && !pdbList->bCurrentPath)
        {
            bAllBreakSkip = FALSE;
            // Did we already go over an alternate with the same number of strokes?
            for (l = 0; l<i; l++)
            {
                if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].nStrokes ==
                    pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[l].nStrokes)
                {
                    bAllBreakSkip = TRUE;
                    break;
                }
            }
            if (bAllBreakSkip) 
                continue;
            // If we have been on the current path so far, but are now considering a 
            // character off the current path, 
            // then skip it if there is a currrent path character later in the alt
            // list with the same number of strokes.
            if (!pdbList->bCurrentPath && bOriginalCurrentPath) 
            {
                for (l = i + 1; l < pAltStruct->vrc->pLattice->pAltList[iNextStroke].nUsed; l++)
                {
                    if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[l].fCurrentPath &&
                        pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].nStrokes ==
                        pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[l].nStrokes)
                    {
                        bAllBreakSkip = TRUE;
                        break;
                    }
                }
            }
            if (bAllBreakSkip) continue;
        }
        dbElement.iIndex = i;
        pdbList->score = fOriginalScore + 
            pAltStruct->vrc->pLattice->pAltList[iNextStroke].alts[i].logProb;
//			GetScore(pAltStruct->vrc->pLattice, iNextStroke, i);
        if (!GetRecDifSegAltList(iNextStroke, i, pdbList, pAltStruct))
			bOkay = FALSE;
    }
    pdbList->iColumnCount--;
    pdbList->pFirst = dbElement.pNext;
	// Unwind the space if necessary
	if (pAltStruct->vrc->pLattice->pAltList[iNextStroke].fSpaceAfterStroke)
	{
		pdbList->iColumnCount--;
		pdbList->pFirst = dbSpaceElement.pNext;
	}
    pdbList->score = fOriginalScore;
    pdbList->bCurrentPath = bOriginalCurrentPath;
    return bOkay;
}

HRESULT GetDifSegAltList(VRC *vrc, int iLastStroke, int iFirstStroke, ULONG ulMax, AltRankList *pAltRankList, int iMode, int iFirstChar, int iLastChar)
{
    HRESULT             hr = S_OK;
    int                 iStroke = 0;
    int                 i = 0, j = 0, l = 0;
    DifBreakList        dbList;
    DiffBreakElement    dbElement;
    BOOL                bGoodStart = FALSE;
    BOOL                bAllBreakSkip = FALSE;
    DifBreakAltStruct   altStruct;
    int                 iNumberOfStrokes = 0;

    // Get the last Column alternates, they should contain uiLastStroke
    // For each of these alternate, get the complete alternate list, stopping
    // at uiFirstStroke.
    // Initialize the data
    altStruct.iFirstStroke = iFirstStroke;
    altStruct.iFirstChar = iFirstChar;
    altStruct.iLastChar = iLastChar;
    altStruct.iMode = iMode;
    altStruct.ulMax = ulMax;
    altStruct.vrc = vrc;
    altStruct.paltRankList = pAltRankList;
    altStruct.paltRankList->pFirst = altStruct.paltRankList->pLast = NULL; 
    altStruct.paltRankList->ulSize = 0;
    dbList.iColumnCount = 1;
    dbList.pFirst = &dbElement;
    dbList.score = 0.0;
    // The starting last stroke should no be further away than 35 strokes from
    // the uiLastStroke
    if (iMode == LARGE_BREAKS)
        iStroke = (vrc->pLattice->nStrokes > iLastStroke + 35 ? iLastStroke + 35 : vrc->pLattice->nStrokes - 1);
    else
        iStroke = iLastStroke;
    while (iStroke >= iLastStroke)
    {
        // The stroke has to be one of the main decomposition
        if (iMode == LARGE_BREAKS)
        {
            bGoodStart = FALSE;
            for (i = 0; i < vrc->pLattice->pAltList[iStroke].nUsed; i++)
            {
                if (vrc->pLattice->pAltList[iStroke].alts[i].fCurrentPath)
                {
                    bGoodStart = TRUE;
                    // Get the character number in the best alternate string
                    for (j = 0; j < vrc->pLatticePath->nChars; j++)
                    {
                        if (vrc->pLatticePath->pElem[j].iStroke == iStroke)
                        {
                            altStruct.iLastChar = j;
                            break;
                        }
                    }
                    break;
                }
            }
        }
        else
        {
            altStruct.iLastChar = iLastChar;
            bGoodStart = TRUE;
        }
        if (bGoodStart)
        {
            // In the case of ALT_BREAKS_SAME, get the number of strokes of the best result's column
            if (iMode == ALT_BREAKS_SAME)
            {
                iNumberOfStrokes = -1;
                for (i = 0; i < vrc->pLattice->pAltList[iStroke].nUsed; i++)
                {
                    if (vrc->pLattice->pAltList[iStroke].alts[i].fCurrentPath)
                    {
                        iNumberOfStrokes = vrc->pLattice->pAltList[iStroke].alts[i].nStrokes;
                        break;
                    }
                }
                ASSERT(iNumberOfStrokes>0);
				if (iNumberOfStrokes <= 0)
					hr = E_UNEXPECTED;
            }

            // Search if there is an alternate that contains uiLastStroke
            for (i = 0; i < vrc->pLattice->pAltList[iStroke].nUsed; i++)
            {
                if (iMode == ALT_BREAKS_SAME)
                    if (vrc->pLattice->pAltList[iStroke].alts[i].nStrokes != iNumberOfStrokes)
                        continue;

                if (iMode == ALT_BREAKS_UNIQUE && !vrc->pLattice->pAltList[iStroke].alts[i].fCurrentPath)
                {
                    // Did we already go over an alternate with the same number of strokes?
                    bAllBreakSkip = FALSE;
                    for (l = 0; l<i; l++)
                    {
                        if (vrc->pLattice->pAltList[iStroke].alts[i].nStrokes ==
                            vrc->pLattice->pAltList[iStroke].alts[l].nStrokes)
                        {
                            bAllBreakSkip = TRUE;
                            break;
                        }
                    }
                    if (bAllBreakSkip) continue;

                    // If we are considering a character which is not on the current path,
                    // then skip it if there is a current path character later in the alt
                    // list with the same number of strokes.
                    if (!vrc->pLattice->pAltList[iStroke].alts[i].fCurrentPath) 
                    {
                        for (l = i + 1; l < vrc->pLattice->pAltList[iStroke].nUsed; l++)
                        {
                            if (vrc->pLattice->pAltList[iStroke].alts[l].fCurrentPath &&
                                vrc->pLattice->pAltList[iStroke].alts[i].nStrokes ==
                                vrc->pLattice->pAltList[iStroke].alts[l].nStrokes)
                            {
                                bAllBreakSkip = TRUE;
                                break;
                            }
                        }
                    }
                    if (bAllBreakSkip) continue;
                }
                if (vrc->pLattice->pAltList[iStroke].alts[i].nStrokes > iStroke-iLastStroke)
                {
                    dbElement.iColumn = iStroke;
                    dbElement.iIndex = i;
                    dbElement.pNext = NULL;
                    dbList.bCurrentPath = vrc->pLattice->pAltList[iStroke].alts[i].fCurrentPath;

                    // We found one that contains uiLastStroke
                    if (!GetRecDifSegAltList(iStroke, i, &dbList, &altStruct))
					{
						hr = E_OUTOFMEMORY;
					}
                }
            }
        }
        iStroke--;
    }

	// If something went wrong, then clean up before returning
	if (!SUCCEEDED(hr)) 
	{
		AltRank *pCur = pAltRankList->pFirst;
		while (pCur != NULL)
		{
			AltRank *pNext = pCur->next;
			DestroyAlternateInternal(pCur->wispalt);
			ExternFree(pCur);
			pCur = pNext;
		}
		pAltRankList->pFirst = pAltRankList->pLast = NULL;
		pAltRankList->ulSize = 0;
	}
    return hr;
}

HRESULT FitAlternateToRecoRange(VRC *vrc, struct WispAlternate *wispalt, RECO_RANGE recoRange)
{
    HRESULT         hr = S_OK;
    int             *newColumns = NULL;
    int             *newIndexes = NULL;
    int             iCurrent = 0, j = 0;
    UINT            i = 0;
    int             iNumberOfColumns = 0;

    // Return straight away if the reco range is already good
    if (recoRange.iwcBegin == wispalt->OriginalRecoRange.iwcBegin &&
        recoRange.cCount == wispalt->OriginalRecoRange.cCount)
        return S_OK;
    // Allocate the new arrays
    iNumberOfColumns = wispalt->iNumberOfColumns + recoRange.cCount - wispalt->OriginalRecoRange.cCount;
    newColumns = (int*)ExternAlloc(sizeof(int)*iNumberOfColumns);
    if (!newColumns) 
        return E_OUTOFMEMORY;
    newIndexes = (int*)ExternAlloc(sizeof(int)*iNumberOfColumns);
    if (!newIndexes) 
    {
        ExternFree(newColumns);
        return E_OUTOFMEMORY;
    }
    iCurrent = 0;
    // Copy the first elements of the array
    for (i = recoRange.iwcBegin; i < wispalt->OriginalRecoRange.iwcBegin; i++)
    {
        // Fill with the information from the best result
        newColumns[iCurrent] = vrc->pLatticePath->pElem[i].iStroke;
        newIndexes[iCurrent] = vrc->pLatticePath->pElem[i].iAlt;
        iCurrent++;
    }
    // Copy the existing alternate information
    for (j = 0; j < wispalt->iNumberOfColumns; j++)
    {
        newColumns[iCurrent] = wispalt->pColumnIndex[j];
        newIndexes[iCurrent] = wispalt->pIndexInColumn[j];
        iCurrent++;
    }
    // Copy what follows with the information from the best result
    for (i = wispalt->OriginalRecoRange.iwcBegin + wispalt->OriginalRecoRange.cCount;
         i < recoRange.iwcBegin + recoRange.cCount; i++)
    {
        newColumns[iCurrent] = vrc->pLatticePath->pElem[i].iStroke;
        newIndexes[iCurrent] = vrc->pLatticePath->pElem[i].iAlt;
        iCurrent++;
    }
    ASSERT (iCurrent == iNumberOfColumns);

    // Swap the arrays
    ExternFree(wispalt->pColumnIndex);
    ExternFree(wispalt->pIndexInColumn);
    wispalt->pColumnIndex = newColumns;
    wispalt->pIndexInColumn = newIndexes;
    wispalt->iLength = iCurrent;
    wispalt->iNumberOfColumns = iCurrent;
    return hr;
}

// GetAlternateList
//
// This function returns alternates of the best result
//
// Parameters:
//		hrc [in] :				The handle to the reco context
//		pRecoRange [in, out] :	Pointer to a RECO_RANGE that contains the range we want to get
//								the alternates for. This range comes bck modified to
//								reflect the range we actually used.
//		pSize [in, out] :		The number of alternates. If phrcalt is NULL then this function returns
//								the number of alternates it can return - Note we may return an arbitrary
//								number with an HRESULT S_FALSE if we think that the number of alternate
//								is too long to compute.
//		phrcalt [out] :			Array of alternates used to return the alternate list
//		iBreak [in] :			Mode for querying alternates: ALT_BREAKS_SAME, ALT_BREAKS_FULL or ALT_BREAKS_UNIQUE
/////////////////
HRESULT WINAPI GetAlternateList(HRECOCONTEXT hrc, RECO_RANGE* pRecoRange, ULONG*pSize, HRECOALT *phrcalt, ALT_BREAKS iBreak)
{
    HRESULT                 hr			= S_OK;
    struct WispContext      *wisphrc;
    VRC                     *vrc		= NULL;
    RECO_RANGE              recoRange, widestRecoRange;
    ULONG                   i = 0;
	ULONG					iAlt;
    int                     j = 0;	
    int                     iColumnIndex = 0;
    FLOAT                   fCurrentScore = 0.0;
    BOOL                    bSomethingAdded = FALSE;
    AltRank                 *pCur = NULL, *pTemp1 = NULL, *pTemp2 = NULL;
    ULONG                   ulAltCountSameStrokeCount = 0;
    AltRankList             altRankList;
    int                     iFirstStroke = 0;
    int                     iLastStroke = 0;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

	if (pRecoRange != NULL && IsBadReadPtr(pRecoRange, sizeof(RECO_RANGE)))
	{
		return E_POINTER;
	}

	if (IsBadWritePtr(pSize, sizeof(ULONG)))
	{
        return E_POINTER;
	}

	if (phrcalt && IsBadWritePtr(phrcalt, (*pSize) * sizeof(*phrcalt))) 
	{
		return E_POINTER;
	}

    if (iBreak != ALT_BREAKS_FULL && 
//        iBreak != LARGE_BREAKS &&
        iBreak != ALT_BREAKS_UNIQUE && 
        iBreak != ALT_BREAKS_SAME)
	{
        return E_INVALIDARG;
	}

    vrc = (VRC*)wisphrc->hrc;
    if (!vrc || !vrc->pLatticePath) 
    {
        // There is no ink
        *pSize = 0;
        return TPC_E_NOT_RELEVANT;
    }

    // Check the reco range to see if it is valid
    if (pRecoRange)
    {
        recoRange = *pRecoRange;
        if (!recoRange.cCount) return E_INVALIDARG;
        if (recoRange.iwcBegin + recoRange.cCount > (ULONG)vrc->pLatticePath->nChars) 
            return E_INVALIDARG;
    }
    else
    {
        recoRange.iwcBegin = 0;
        recoRange.cCount = vrc->pLatticePath->nChars;
    }

	// First trim spaces (if any) from the beginning and end of the reco range
	while (recoRange.cCount > 0 && vrc->pLatticePath->pElem[recoRange.iwcBegin].iAlt == SPACE_ALT_ID)
	{
		recoRange.iwcBegin++;
		recoRange.cCount--;
	}

	while (recoRange.cCount > 0 && vrc->pLatticePath->pElem[recoRange.iwcBegin + recoRange.cCount - 1].iAlt == SPACE_ALT_ID)
	{
		recoRange.cCount--;
	}

	// If the range only contained spaces, then return an error
	if (recoRange.cCount == 0)
	{
		return TPC_E_NOT_RELEVANT;
	}

	// If there aren't any results, error
    if (!vrc->pLatticePath->nChars)
    {
        *pSize = 0;
        return TPC_E_NOT_RELEVANT;
    }

	// If we are passed a buffer for alternates but it has size zero, just 
	// return immediately.  (Some of the code for handling alternates doesn't
	// work with a buffer size of zero.)
	if (phrcalt != NULL && *pSize == 0)
	{
		return S_OK;
	}

	// If we're in single segmentation mode and have asked for full breaks, then
	// switch to same breaks.
	if ((wisphrc->dwFlags & RECOFLAG_SINGLESEG) != 0 && iBreak == ALT_BREAKS_FULL)
	{
		iBreak = ALT_BREAKS_SAME;
	}

	widestRecoRange = recoRange;
    if (iBreak == ALT_BREAKS_FULL || iBreak == LARGE_BREAKS) 
    {
        // Get the number of alternates
        if (!phrcalt)
        {
            *pSize = 50; //We need to find a way how to calculate the real count easily...
            return S_FALSE;
        }
        iLastStroke = vrc->pLatticePath->pElem[recoRange.iwcBegin+recoRange.cCount-1].iStroke;
        iFirstStroke = vrc->pLatticePath->pElem[recoRange.iwcBegin].iStroke -
                vrc->pLatticePath->pElem[recoRange.iwcBegin].nStrokes + 1;

        hr = GetDifSegAltList(vrc, iLastStroke, iFirstStroke, *pSize, &altRankList, iBreak, recoRange.iwcBegin, recoRange.iwcBegin+recoRange.cCount-1);
        if (FAILED(hr)) 
        {
            return hr;
        }
        // Copy the info from the list to the array
        *pSize = altRankList.ulSize;

        if (altRankList.ulSize == 0) return S_OK;

        // TBD: Adjust the alternates to fit the "widest" returned
        // alternate
        // First find the widest alternate (widestRecoRange)
        if (iBreak == LARGE_BREAKS)
        {
	        pCur = altRankList.pFirst;
            widestRecoRange = pCur->wispalt->OriginalRecoRange;
            for (i = 0; i < *pSize; i++)
            {
                // Check the start point
                if (widestRecoRange.iwcBegin > pCur->wispalt->OriginalRecoRange.iwcBegin)
                {
                    widestRecoRange.cCount += widestRecoRange.iwcBegin - 
                        pCur->wispalt->OriginalRecoRange.iwcBegin;
                    widestRecoRange.iwcBegin = pCur->wispalt->OriginalRecoRange.iwcBegin;
                }
                // Check the end point
                if (widestRecoRange.iwcBegin + widestRecoRange.cCount < 
                    pCur->wispalt->OriginalRecoRange.iwcBegin + 
                    pCur->wispalt->OriginalRecoRange.cCount)
                {
                    widestRecoRange.cCount = pCur->wispalt->OriginalRecoRange.iwcBegin 
                        + pCur->wispalt->OriginalRecoRange.cCount
                        - widestRecoRange.iwcBegin;
                }
                // Go to the next
                pCur = pCur->next;
            }
            pCur = altRankList.pFirst;
            // Then call on each alternate the "fit" function
            for (i = 0; i < *pSize; i++)
            {
                hr = FitAlternateToRecoRange(vrc, pCur->wispalt, widestRecoRange);
                // Go to the next
                pCur = pCur->next;
            }
        }
        pCur = altRankList.pFirst;
        pTemp1 = altRankList.pFirst;
    }
    if (iBreak == ALT_BREAKS_UNIQUE || iBreak == ALT_BREAKS_SAME)
    {
        if (iBreak == ALT_BREAKS_UNIQUE && !phrcalt)
        {
            // Get the number of alternates
            *pSize = 50; //We need to find a way how to calculate the real count easily... Impossible?

			// If we're pretending there is only one segmentation...
			if (wisphrc->dwFlags & RECOFLAG_SINGLESEG)
			{
				*pSize = 1;
			}
            return S_FALSE;
        }
        if (!vrc->pLatticePath)
        {
            *pSize = 0;
            return hr;
        }

        // Get the number of alternates
        if (!phrcalt)
        {
            *pSize = 1;
            for (i = recoRange.iwcBegin; i < recoRange.iwcBegin + recoRange.cCount; i++)
            {
                iColumnIndex = vrc->pLatticePath->pElem[i].iStroke;
                // We need to get the number of alternates with the same number of strokes!!!
                ulAltCountSameStrokeCount = 0;
                for (j = 0; j < vrc->pLattice->pAltList[iColumnIndex].nUsed; j++)
                {
                    if (vrc->pLattice->pAltList[iColumnIndex].alts[j].nStrokes == 
                        vrc->pLatticePath->pElem[i].nStrokes)
                        ulAltCountSameStrokeCount++;
                }
                *pSize *= ulAltCountSameStrokeCount;
            }
            return S_OK;
        }

		// If we're in single segmentation mode and have asked for unique breaks, then 
		// we just want to return the best path.  Easiest way to do this is to 
		// ask for same breaks with one alternate.
		if ((wisphrc->dwFlags & RECOFLAG_SINGLESEG) != 0 && iBreak == ALT_BREAKS_UNIQUE)
		{
			if (*pSize > 1) 
			{
				*pSize = 1;
			}
			iBreak = ALT_BREAKS_SAME;
		}

        // Get the alternates
        // Create a list of alternates
        iLastStroke = vrc->pLatticePath->pElem[recoRange.iwcBegin+recoRange.cCount-1].iStroke;
        iFirstStroke = vrc->pLatticePath->pElem[recoRange.iwcBegin].iStroke -
                vrc->pLatticePath->pElem[recoRange.iwcBegin].nStrokes + 1;

        hr = GetDifSegAltList(vrc, iLastStroke, iFirstStroke, *pSize, &altRankList, iBreak, recoRange.iwcBegin, recoRange.iwcBegin+recoRange.cCount-1);
        if (FAILED(hr)) 
        {
            return hr;
        }
        // Copy the info from the list to the array
        *pSize = altRankList.ulSize;
        pCur = altRankList.pFirst;
        pTemp1 = altRankList.pFirst;

        if (altRankList.ulSize == 0) return S_OK;
    }
    for (i = 0; i < *pSize; i++)
    {
        // Allocate the memory for the pRecoRange array
        pCur->wispalt->OriginalRecoRange	= recoRange;
        pCur->wispalt->hrc					= hrc;

		// create a tpg handle
        phrcalt[i] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pCur->wispalt);

		// if we fail we'll have to destroy all the other handles
		if (phrcalt[i] == NULL)
		{			
			for (iAlt = 0; iAlt < i; iAlt++)
			{
				DestroyTpgHandle(phrcalt[iAlt], TPG_HRECOALT);
			}
			// And also destroy the alternate list
			while (pTemp1)
			{
				pTemp2 = pTemp1->next;
				DestroyAlternateInternal(pTemp1->wispalt);
				ExternFree(pTemp1);
				pTemp1 = pTemp2;
			}
			return E_OUTOFMEMORY;
		}

        // Go to the next
        pCur = pCur->next;
    }

	// Get rid of the linked list which previous held all the alternates
    while (pTemp1)
    {
        pTemp2 = pTemp1->next;
        ExternFree(pTemp1);
        pTemp1 = pTemp2;
    }

    if (pRecoRange)
        *pRecoRange = widestRecoRange;

    return hr;
}

HRESULT WINAPI Process(HRECOCONTEXT hrc, BOOL *pbPartialProcessing)
{
    struct WispContext      *wisphrc;
    HRESULT                 hr = S_OK;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    if (IsBadWritePtr(pbPartialProcessing, sizeof(BOOL)))
        return E_POINTER;

    *pbPartialProcessing = FALSE;

    if (!wisphrc->hrc) 
	{
        return S_OK; // There is no ink
	}

    // We should call the HwxProcess if there is a Guide
    if (wisphrc->bIsBoxed)
    {
        if (wisphrc->bIsCAC)
        {
            hr = EndInkInput(hrc);
            if (FAILED(hr)) return hr;
            wisphrc->bCACEndInk = TRUE;
        }
        if (HwxProcess(wisphrc->hrc))
        {
            // Test wether the result is valid or invalid
            // the result can be invalid if the call to Process was
            // interrupted by a call to AdviseInkChanged
            if (wisphrc->uAbort != (ULONG)((VRC*)wisphrc->hrc)->pLattice->nRealStrokes)
                return TPC_S_INTERRUPTED;
            return hr;
        }
    }
    else
    {
        if (HRCR_OK == ProcessHRC(wisphrc->hrc, 0))
            return S_OK;
    }
    return E_FAIL;
}

HRESULT WINAPI SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR* pwcFactoid)
{
    struct WispContext		*wisphrc;
    HRESULT					hr				= S_OK;
    WCHAR					*wszOldFactoid;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

	// Save the old factoid so it can be restored if there is an error
    wszOldFactoid = wisphrc->wszFactoid;

    if (pwcFactoid)
    {
		// validate pointer if not null
		if (IsBadReadPtr (pwcFactoid, cwcFactoid * sizeof (*pwcFactoid)))
		{
			return E_POINTER;
		}

        wisphrc->wszFactoid = (WCHAR*)ExternAlloc(sizeof(WCHAR)*(cwcFactoid+1));
        if (!wisphrc->wszFactoid)
        {
            wisphrc->wszFactoid = wszOldFactoid;
            return E_OUTOFMEMORY;
        }
        memcpy(wisphrc->wszFactoid, pwcFactoid, cwcFactoid * sizeof(WCHAR));
        wisphrc->wszFactoid[cwcFactoid] = 0;
    }
    else
    {
        wisphrc->wszFactoid = NULL;
    }

    // If we have an HRC already, set the factoid in it.
    if (wisphrc->hrc != NULL) 
    {
        switch (SetHwxFactoid(wisphrc->hrc, wisphrc->wszFactoid))
        {
           case HRCR_OK:
                hr = S_OK;
                break;
           case HRCR_UNSUPPORTED:
                hr = TPC_E_INVALID_PROPERTY;
    		    break;
           case HRCR_CONFLICT:
                hr = TPC_E_OUT_OF_ORDER_CALL;
		        break;
           case HRCR_ERROR:
           default:
                hr = E_FAIL;
		        break;
        }
    }
    else
    {
        // Try to create an HRC to test out the factoid setting, 
        // then destroy it immediately.
        hr = CreateHRCinContext(wisphrc);
        // Destroy the HRC if we succeeded in creating one.
        if (wisphrc->hrc != NULL)
        {
            if (wisphrc->bIsBoxed)
                HwxDestroy(wisphrc->hrc);
            else
                DestroyHRC(wisphrc->hrc);
            wisphrc->hrc = NULL;
        }
    }

    if (SUCCEEDED(hr)) 
    {
        ExternFree(wszOldFactoid);
    }
    else
    {
        ExternFree(wisphrc->wszFactoid);
        wisphrc->wszFactoid = wszOldFactoid;
    }
    return hr;
}

HRESULT WINAPI SetFlags(HRECOCONTEXT hrc, DWORD dwFlags)
{
    struct WispContext	*wisphrc;
    DWORD				dwOldFlags;
    HRESULT				hr;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

    dwOldFlags = wisphrc->dwFlags;
    wisphrc->dwFlags = dwFlags;

    if (wisphrc->hrc)
    {
        if (SetHwxFlags(wisphrc->hrc, dwFlags))
            hr = S_OK;
        else
            hr = E_INVALIDARG;
    }
    else
    {
        // Try to create an HRC to set out the flag setting, 
        // then destroy it immediately.
        hr = CreateHRCinContext(wisphrc);
        // Destroy the HRC if we succeeded in creating one.
        if (wisphrc->hrc != NULL)
        {
            if (wisphrc->bIsBoxed)
                HwxDestroy(wisphrc->hrc);
            else
                DestroyHRC(wisphrc->hrc);
            wisphrc->hrc = NULL;
        }
    }
    if (FAILED(hr))
    {
        wisphrc->dwFlags = dwOldFlags;
    }

    return hr;
}

HRESULT WINAPI IsStringSupported(HRECOCONTEXT hrc, ULONG cwcString, const WCHAR *pwcString)
{
    struct WispContext		*wisphrc;
    WCHAR                   *tempBuffer;
    ULONG                   ulSize = 0;
    HRESULT                 hr = S_OK;
    BOOL                    fCreatedHRC = FALSE;
    
	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
	{
        return E_INVALIDARG;
	}

	if (IsBadReadPtr(pwcString, cwcString * sizeof(*pwcString)))
	{
        return E_POINTER;
	}

    // We need to have a valid HRC to check the factoid
    if (!wisphrc->hrc)
    {
        hr = CreateHRCinContext(wisphrc);
        if (FAILED(hr)) 
        {
            // Failure might mean we actually made the 
            // HRC, but a flag setting or factoid setting failed.
            // So destroy the HRC if it was created.
            if (wisphrc->hrc != NULL)
            {
                if (wisphrc->bIsBoxed)
                    HwxDestroy(wisphrc->hrc);
                else
                    DestroyHRC(wisphrc->hrc);
                wisphrc->hrc = NULL;
            }
            return E_FAIL;
        }

        fCreatedHRC = TRUE;
    }

    tempBuffer = (WCHAR *) ExternAlloc((cwcString + 1) * sizeof(*tempBuffer));
    if (!tempBuffer)
        return E_OUTOFMEMORY;

    memcpy(tempBuffer, pwcString, cwcString * sizeof(WCHAR));
    tempBuffer[cwcString] = 0;

    if (IsWStringSupportedHRC(wisphrc->hrc, tempBuffer))
        hr = S_OK;
    else
        hr = S_FALSE;
    ExternFree(tempBuffer);

    if (fCreatedHRC)
    {
        if (wisphrc->bIsBoxed)
            HwxDestroy(wisphrc->hrc);
        else
            DestroyHRC(wisphrc->hrc);
        wisphrc->hrc = NULL;
    }

    return hr;
}

int _cdecl CompareWCHAR(const void *arg1, const void *arg2)
{
	int wch1 = *((WCHAR *) arg1);
	int wch2 = *((WCHAR *) arg2);
    return (wch1 - wch2);
}

// GetUnicodeRanges
//
// Parameters:
//		hrec [in]			:	Handle to the recognizer
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetUnicodeRanges(HRECOGNIZER		hrec,
								ULONG			*pcRanges,
								CHARACTER_RANGE *pcr)
{
	struct WispRec *pRec;
	WCHAR *aw;
	int cChar, i;
	ULONG cRange, iRange = 0;
	HRESULT hr = S_OK;

	// Check the recognizer handle
	pRec = (struct WispRec*)FindTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER);
	if (NULL == pRec)
	{
        return E_INVALIDARG;
	}

	if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
	{
        return E_POINTER;
	}

	if (pcr != NULL && IsBadWritePtr(pcr, sizeof(CHARACTER_RANGE) * (*pcRanges)))
	{
		return E_POINTER;
	}

	cChar = g_locRunInfo.cCodePoints - 1;
	aw = (WCHAR *) ExternAlloc(cChar * sizeof(WCHAR));
	if (!aw)
	{
		return E_OUTOFMEMORY;
	}
	for (i = 1; i < g_locRunInfo.cCodePoints; i++) 
	{
		aw[i - 1] = LocRunDense2Unicode(&g_locRunInfo, (WCHAR) i);
	}

	if (cChar == 0)
	{
		cRange = 0;
	}
	else 
	{
		qsort((void*)aw, (size_t)cChar, sizeof(WCHAR), CompareWCHAR);

		// count the ranges
		cRange = 1;
		for (i = 1; i < cChar; i++)
		{
			if (aw[i] > aw[i - 1] + 1)
				cRange++;
		}
	}


	if (!pcr)	// Need only a count of ranges
	{
		*pcRanges = cRange;
		goto cleanup;
	}
	
	if (*pcRanges < cRange)
	{
		hr = TPC_E_INSUFFICIENT_BUFFER;
		goto cleanup;
	}

	if (*pcRanges > cRange)
	{
		*pcRanges = cRange;
	}

	if (*pcRanges > 0) 
	{
		// convert the array of Unicode values to an array of CHARACTER_RANGEs
		pcr[iRange].wcLow = aw[0];
		pcr[iRange].cChars = 1;
		for (i = 1; i < cChar; i++)
		{
			if (aw[i] == aw[i - 1] + 1)
				pcr[iRange].cChars++;
			else
			{
				if (iRange >= (*pcRanges) - 1)
				{
					break;
				}
				iRange++;
				pcr[iRange].wcLow = aw[i];
				pcr[iRange].cChars = 1;
			}
		}
		ASSERT(iRange == (*pcRanges) - 1);
	}

cleanup:
	ExternFree(aw);
	return hr;
}

// GetEnabledUnicodeRanges
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetEnabledUnicodeRanges(HRECOCONTEXT		hrc,
									   ULONG			*pcRanges,
									   CHARACTER_RANGE	*pcr)
{
	VRC		*pVRC;
    CHARSET charset;
	WCHAR *aw;
	int cChar, i;
	ULONG cRange, iRange = 0;
	HRESULT hr = S_OK;
	BOOL	fCreatedHRC = FALSE;

	struct WispContext *wisphrc;

	// validate the correpsonding hrc pointer
	wisphrc = (struct WispContext *) FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
	{
        return E_POINTER;
	}

	if (pcr != NULL && IsBadWritePtr(pcr, sizeof(CHARACTER_RANGE) * *(pcRanges)))
	{
		return E_POINTER;
	}

	cChar = 0;
	aw = (WCHAR *) ExternAlloc((g_locRunInfo.cCodePoints - 1) * sizeof(WCHAR));
	if (!aw)
		return E_OUTOFMEMORY;

    // If we have an HRC, the factoid should be set already.  If not, we'll have
	// to make one.
    if (wisphrc->hrc == NULL) 
    {
		fCreatedHRC = TRUE;
        hr = CreateHRCinContext(wisphrc);
	}

	pVRC = (VRC *) wisphrc->hrc;
	
	if (SUCCEEDED(hr) && pVRC != NULL) 
	{
		charset.recmask = pVRC->pLattice->alcFactoid;
		charset.pbAllowedChars = pVRC->pLattice->pbFactoidChars;
		for (i = 1; i < g_locRunInfo.cCodePoints; i++) 
		{
			if (IsAllowedChar(&g_locRunInfo, &charset, (WCHAR) i)) 
			{
				aw[cChar++] = LocRunDense2Unicode(&g_locRunInfo, (WCHAR) i);
			}
		}
    }

	if (fCreatedHRC) 
	{
        // Destroy the HRC if we created one.
        if (wisphrc->hrc != NULL)
        {
            if (wisphrc->bIsBoxed)
                HwxDestroy(wisphrc->hrc);
            else
                DestroyHRC(wisphrc->hrc);
            wisphrc->hrc = NULL;
        }
    }

	if (cChar == 0)
	{
		cRange = 0;
	}
	else 
	{
		qsort((void*)aw, (size_t)cChar, sizeof(WCHAR), CompareWCHAR);

		// count the ranges
		cRange = 1;
		for (i = 1; i < cChar; i++)
		{
			if (aw[i] > aw[i - 1] + 1)
				cRange++;
		}
	}

	if (!pcr)	// Need only a count of ranges
	{
		*pcRanges = cRange;
		goto cleanup;
	}
	
	if (*pcRanges < cRange)
	{
		hr = TPC_E_INSUFFICIENT_BUFFER;
        goto cleanup;
	}

	if (*pcRanges > cRange)
	{
		*pcRanges = cRange;
	}

	if (*pcRanges > 0) 
	{
		// convert the array of Unicode values to an array of CHARACTER_RANGEs
		pcr[iRange].wcLow = aw[0];
		pcr[iRange].cChars = 1;
		for (i = 1; i < cChar; i++)
		{
			if (aw[i] == aw[i - 1] + 1)
				pcr[iRange].cChars++;
			else
			{
				if (iRange >= (*pcRanges) - 1)
				{
					break;
				}
				iRange++;
				pcr[iRange].wcLow = aw[i];
				pcr[iRange].cChars = 1;
			}
		}
		ASSERT(iRange == (*pcRanges) - 1);
	}

cleanup:
	ExternFree(aw);
	return hr;
}

// SetEnabledUnicodeRanges
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI SetEnabledUnicodeRanges(HRECOCONTEXT		hrc,
									   ULONG			cRanges,
									   CHARACTER_RANGE  *pcr)
{
	struct WispContext *wisphrc;

	// validate the correpsonding hrc pointer
	wisphrc = (struct WispContext *) FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	if (IsBadReadPtr(pcr, sizeof(CHARACTER_RANGE) * cRanges))
	{
		return E_POINTER;
	}

	return E_NOTIMPL;
}

////////////////////////
// IAlternate
////////////////////////
HRESULT WINAPI GetString(HRECOALT hrcalt, RECO_RANGE *pRecoRange, ULONG* pcSize, WCHAR* szString)
{
	struct WispContext		*wisphrc;
    struct WispAlternate    *wispalt;
    VRC                     *vrc = NULL;
    HRESULT                 hr = S_OK;
    ULONG                   i = 0, ulSize = 0;

	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the correpsonding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	if (pRecoRange && IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
	{
		return E_POINTER;
	}

    if (IsBadWritePtr(pcSize, sizeof(ULONG))) 
	{
        return E_POINTER;
	}

	// if the string pointer is not null, validate it
	if (szString && IsBadWritePtr(szString, (*pcSize) * sizeof (*szString)))
	{
		return E_POINTER;
	}

    vrc = (VRC*)wisphrc->hrc;
    if (!vrc) 
	{
		return E_POINTER;
	}

    if (pRecoRange)
    {
        pRecoRange->iwcBegin = wispalt->OriginalRecoRange.iwcBegin;
        pRecoRange->cCount = wispalt->OriginalRecoRange.cCount;
    }

    ulSize = (ULONG)wispalt->iLength;

    if (!szString)
    {
        *pcSize = ulSize;
        return S_OK;
    }

    if (*pcSize > ulSize) 
	{
        *pcSize = ulSize;
	}

    if (*pcSize < ulSize) 
	{
        hr = TPC_S_TRUNCATED;
	}

    // Fill the string
    for (i = 0; i<*pcSize; i++)
    {
        // Fill the characters in the string
		if (wispalt->pIndexInColumn[i] == SPACE_ALT_ID)
		{
			szString[i] = SYM_SPACE;
		}
		else
        if (vrc->pLattice->pAltList[wispalt->pColumnIndex[i]].alts[wispalt->pIndexInColumn[i]].wChar != SYM_UNKNOWN)
        {
            szString[i] = LocRunDense2Unicode(&g_locRunInfo,
                vrc->pLattice->pAltList[wispalt->pColumnIndex[i]].alts[wispalt->pIndexInColumn[i]].wChar);
        }
        else
        {
            szString[i] = SYM_UNKNOWN;
        }
    }

    return hr;
}


HRESULT WINAPI GetStrokeRanges(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG* pcRanges, STROKE_RANGE* pStrokeRange)
{
    HRESULT                 hr = S_OK;
    RECO_RANGE              recoRange;
	struct WispContext		*wisphrc;
    struct WispAlternate    *wispalt;
    VRC                     *vrc; 
    ULONG                   ulStrokeCount = 0, ulCurrentIndex = 0;
    ULONG                   i = 0;
    int                     j = 0;
    int                     k = 0;
    ULONG                   *StrokeArray = NULL;
    ULONG                   ulStrokeRangesCount = 0;
    ULONG                   iCurrentStrokeRange = 0;

	// find the handle and validate the corresponding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	vrc = (VRC *) wisphrc->hrc;
	if (vrc == NULL)
	{
		return E_INVALIDARG;
	}

    if (IsBadReadPtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
    {
        return E_POINTER;
    }

	// validate pointer if not null
	if (pStrokeRange && IsBadWritePtr(pStrokeRange, (*pcRanges) * sizeof (*pStrokeRange)))
	{
		return E_POINTER;
	}

    recoRange = *pRecoRange;
    if (!recoRange.cCount) 
    {
        *pcRanges = 0;
        return S_OK;
    }
    if (recoRange.iwcBegin + recoRange.cCount > (ULONG)wispalt->iLength)
        return E_INVALIDARG;

    // Get the number of strokes
    for (i = recoRange.iwcBegin; i < recoRange.iwcBegin + recoRange.cCount; i++)
    {
		// Make sure we're not looking at a space
		if (wispalt->pIndexInColumn[i] != SPACE_ALT_ID)
		{
			// There might be some stroke that have been merged!
			// We need to examine every single column to know if strokes have been merged
			// (and also how many times)
			for (j = 0; j < vrc->pLattice->pAltList[wispalt->pColumnIndex[i]].alts[wispalt->pIndexInColumn[i]].nStrokes; j++)
			{
				ulStrokeCount += vrc->pLattice->pStroke[wispalt->pColumnIndex[i]-j].iLast -
					vrc->pLattice->pStroke[wispalt->pColumnIndex[i]-j].iOrder + 1;
			}
		}
    }

	// If there aren't any strokes, then exit early.
	// (The rest of this function behaves badly if there are no strokes or no ranges.)
	if (ulStrokeCount == 0)
	{
		*pcRanges = 0;
		return S_OK;
	}

    // Allocate the array of strokes
    StrokeArray = (ULONG*)ExternAlloc(sizeof(ULONG)*ulStrokeCount);
    if (!StrokeArray) 
    {
        ASSERT(StrokeArray);
        return E_OUTOFMEMORY;
    }
    // Get the array of strokes
    ulCurrentIndex = 0;
    for (i = recoRange.iwcBegin; i < recoRange.iwcBegin + recoRange.cCount; i++)
    {
		// Make sure we're not looking at a space
		if (wispalt->pIndexInColumn[i] != SPACE_ALT_ID)
		{
			// This loop goes backwards so we get the strokes in order
			for (j = vrc->pLattice->pAltList[wispalt->pColumnIndex[i]].alts[wispalt->pIndexInColumn[i]].nStrokes - 1; j >= 0; j--)
			{
				// There might more than one stroke here
				// because of the possibility of a stroke merge!!!
				for (k = vrc->pLattice->pStroke[wispalt->pColumnIndex[i]-j].iOrder; 
					k <= vrc->pLattice->pStroke[wispalt->pColumnIndex[i]-j].iLast;
					k++)
				{
					StrokeArray[ulCurrentIndex] = k;
					ulCurrentIndex++;
				}
			}
		}
    }
    // Sort the array
    SlowSort(StrokeArray, ulStrokeCount);
    // Get the number of STROKE_RANGES needed
    ulStrokeRangesCount = 1;
    for (i = 1; i<ulStrokeCount; i++)
    {
        if (StrokeArray[i-1]+1!=StrokeArray[i]) ulStrokeRangesCount++;
    }
    // Return the count is this is all that is asked
    if (!pStrokeRange)
    {
        *pcRanges = ulStrokeRangesCount;
        ExternFree(StrokeArray);
        return S_OK;
    }
    if (*pcRanges < ulStrokeRangesCount) 
    {
        ExternFree(StrokeArray);
        return TPC_E_INSUFFICIENT_BUFFER;
    }

    // Fill in the Strokes
    iCurrentStrokeRange = 0;
    pStrokeRange[iCurrentStrokeRange].iStrokeBegin = StrokeArray[0];
    pStrokeRange[ulStrokeRangesCount-1].iStrokeEnd = StrokeArray[ulStrokeCount-1];
    for(i = 1; i < ulStrokeCount; i++)
    {
        if (StrokeArray[i-1]+1!=StrokeArray[i]) 
        {
            pStrokeRange[iCurrentStrokeRange].iStrokeEnd = StrokeArray[i-1];
            iCurrentStrokeRange++;
            if (iCurrentStrokeRange == ulStrokeRangesCount) break;
            pStrokeRange[iCurrentStrokeRange].iStrokeBegin = StrokeArray[i];
        }
    }
    *pcRanges = ulStrokeRangesCount;
    ExternFree(StrokeArray);
    return hr;
}

typedef struct AltScore
{
	float flScore;
	int iAlt;
	BOOL fCurrentPath;
} AltScore;

int __cdecl CompareAltScore(const void *p1, const void *p2)
{
	const AltScore *pAlt1 = (const AltScore *) p1;
	const AltScore *pAlt2 = (const AltScore *) p2;
	if (pAlt1->fCurrentPath) return -1;
	if (pAlt2->fCurrentPath) return 1;
	if (pAlt1->flScore > pAlt2->flScore) return -1;
	if (pAlt1->flScore < pAlt2->flScore) return 1;
	return 0;
}

HRESULT WINAPI GetSegmentAlternateList(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *pcAlts, HRECOALT* pAlts)
{
    HRESULT                     hr = S_OK;
    struct WispAlternate        *wispalt;
	struct WispContext			*wisphrc;
    VRC                         *vrc;
    ULONG                       ulMaxAlt = 0;
    struct WispAlternate        *pWispAlt = NULL;
    int                         i = 0;
    int                         j = 0;
    ULONG                       ulCurrentIndex = 0;

	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	vrc = (VRC *) wisphrc->hrc;
	if (vrc == NULL)
	{
		return E_INVALIDARG;
	}

    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pcAlts, sizeof(ULONG))) 
	{
        return E_POINTER;
	}

	if (pAlts && IsBadWritePtr(pAlts, (*pcAlts) * sizeof (*pAlts)))
	{
		return E_POINTER;
	}

    // Check that the pRecoRange is valid:
    if (pRecoRange->cCount == 0 || 
		pRecoRange->iwcBegin + pRecoRange->cCount > (ULONG)wispalt->iLength) 
	{
        return E_INVALIDARG;
	}

    // Get the number of alternates for this character (with the same number of strokes!!!)
    ulMaxAlt = 0;

	// if this char is a space
	if (wispalt->pIndexInColumn[pRecoRange->iwcBegin] == SPACE_ALT_ID)
	{
		if (!pAlts) 
		{
			*pcAlts = 1;
		}
		if (pAlts && *pcAlts > 0)
		{
			pWispAlt = (struct WispAlternate *)ExternAlloc(sizeof(struct WispAlternate));
			if (!pWispAlt)
			{
				return E_OUTOFMEMORY;
			}

			pWispAlt->hrc = wispalt->hrc;
			pWispAlt->iLength = 1;
			pWispAlt->iNumberOfColumns = 1;
			pWispAlt->OriginalRecoRange = *pRecoRange;
			pWispAlt->pColumnIndex = NULL;
			pWispAlt->pIndexInColumn = NULL;
			pWispAlt->pColumnIndex = ExternAlloc(sizeof(int));
			pWispAlt->pIndexInColumn = ExternAlloc(sizeof(int));
			if (!pWispAlt->pColumnIndex || !pWispAlt->pIndexInColumn)
			{
				// Problem allocating memory, unallocate the array
				HRESULT hrDA = DestroyAlternateInternal(pWispAlt);
				ASSERT(SUCCEEDED(hrDA));
				return E_OUTOFMEMORY;
			}

			pWispAlt->pColumnIndex[0] = wispalt->pColumnIndex[pRecoRange->iwcBegin];
			pWispAlt->pIndexInColumn[0] = SPACE_ALT_ID;

			pAlts[0] = (HRECOALT) CreateTpgHandle(TPG_HRECOALT, pWispAlt);
			if (pAlts[0] == NULL)
			{
				// Problem allocating memory, unallocate the array
				HRESULT hrDA = DestroyAlternateInternal(pWispAlt);
				ASSERT(SUCCEEDED(hrDA));
				return E_OUTOFMEMORY;
			}
			*pcAlts = 1;
		}
	}
	else
	{
		AltScore *pAltScores;
        int iCurrentPath = -1;
		for (i = 0; i < vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].nUsed; i++)
		{
			if (vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].alts[i].nStrokes ==
				vrc->pLatticePath->pElem[pRecoRange->iwcBegin].nStrokes)
				ulMaxAlt++;
		}

		if (!pAlts)
		{
			*pcAlts = ulMaxAlt;
			return S_OK;
		}

		pAltScores = (AltScore *) ExternAlloc(sizeof(AltScore) * ulMaxAlt);
		if (pAltScores == NULL)
		{
			return E_OUTOFMEMORY;
		}

		ulCurrentIndex = 0;
		for (i = 0; i < vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].nUsed; i++)
		{
			// Do the stuff only when we have the same number of strokes
			if (vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].alts[i].nStrokes ==
				vrc->pLatticePath->pElem[pRecoRange->iwcBegin].nStrokes)
			{
				pAltScores[ulCurrentIndex].fCurrentPath = vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].alts[i].fCurrentPath;
				pAltScores[ulCurrentIndex].iAlt = i;
				pAltScores[ulCurrentIndex].flScore = 
					vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].alts[i].logProbPath;
//					GetScore(vrc->pLattice, wispalt->pColumnIndex[pRecoRange->iwcBegin], i);
				ulCurrentIndex++;
			}
		}

		qsort(pAltScores, ulMaxAlt, sizeof(AltScore), CompareAltScore);

		if (*pcAlts>ulMaxAlt) *pcAlts = ulMaxAlt;

		// Fill in the array of alternates
		for (i = 0; i < (int)(*pcAlts); i++)
		{
			// Create an alternate
			pWispAlt = (struct WispAlternate *)ExternAlloc(sizeof(struct WispAlternate));
			if (!pWispAlt)
			{
				// Problem allocating memory, unallocate the array
				ExternFree(pAltScores);
				for (j = 0; j < i; j++)
				{
					HRESULT hrDA = DestroyAlternate(pAlts[j]);
					ASSERT(SUCCEEDED(hrDA));
				}
				return E_OUTOFMEMORY;
			}

			pWispAlt->hrc = wispalt->hrc;
			pWispAlt->iLength = 1;
			pWispAlt->iNumberOfColumns = 1;
			pWispAlt->OriginalRecoRange = *pRecoRange;
			pWispAlt->pColumnIndex = NULL;
			pWispAlt->pIndexInColumn = NULL;
			pWispAlt->pColumnIndex = ExternAlloc(sizeof(int));
			pWispAlt->pIndexInColumn = ExternAlloc(sizeof(int));
			if (!pWispAlt->pColumnIndex || !pWispAlt->pIndexInColumn)
			{
				// Problem allocating memory, unallocate the array
				ExternFree(pAltScores);
				for (j = 0; j < i; j++)
				{
					HRESULT hrDA = DestroyAlternate(pAlts[j]);
					ASSERT(SUCCEEDED(hrDA));
				}
				return E_OUTOFMEMORY;
			}
			pWispAlt->pColumnIndex[0] = wispalt->pColumnIndex[pRecoRange->iwcBegin];
			pWispAlt->pIndexInColumn[0] = pAltScores[i].iAlt;
			pAlts[i] = CreateTpgHandle(TPG_HRECOALT, pWispAlt);
			if (pAlts[i] == NULL)
			{
				// Problem allocating memory, unallocate the array
				ExternFree(pAltScores);
				for (j = 0; j < i; j++)
				{
					HRESULT hrDA = DestroyAlternate(pAlts[j]);
					ASSERT(SUCCEEDED(hrDA));
				}
				return E_OUTOFMEMORY;
			}
		}
		ExternFree(pAltScores);
	}
	pRecoRange->cCount = 1;
    return hr;
}

HRESULT WINAPI GetMetrics(HRECOALT hrcalt, RECO_RANGE* pRecoRange, LINE_METRICS lm, LINE_SEGMENT* pls)
{
    struct WispAlternate        *wispalt;
	struct WispContext			*wisphrc;
    VRC                         *vrc;
    HRESULT                     hr = S_OK;
    ULONG                       index = 0;
    LONG                        lPrevChar = 0;
	float						flTotalY = 0;
	int							cCharacters = 0;

	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	vrc = (VRC *) wisphrc->hrc;
	if (vrc == NULL)
	{
		return E_INVALIDARG;
	}
    
    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE))) 
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pls, sizeof(LINE_SEGMENT))) 
	{
        return E_POINTER;
	}

    if (pRecoRange->cCount == 0 || 
		pRecoRange->iwcBegin+pRecoRange->cCount > (ULONG)wispalt->iLength) 
	{
        return E_INVALIDARG;
	}

	// First trim spaces (if any) from the beginning and end of the reco range
	while (pRecoRange->cCount > 0 && wispalt->pIndexInColumn[pRecoRange->iwcBegin] == SPACE_ALT_ID)
	{
		pRecoRange->iwcBegin++;
		pRecoRange->cCount--;
	}

	while (pRecoRange->cCount > 0 && wispalt->pIndexInColumn[pRecoRange->iwcBegin + pRecoRange->cCount - 1] == SPACE_ALT_ID)
	{
		pRecoRange->cCount--;
	}

	// If the range only contained spaces, then return an error
	if (pRecoRange->cCount == 0)
	{
		return TPC_E_NOT_RELEVANT;
	}

    index = 0;
    lPrevChar = 0;

	// Right now we only work from left to right, top to bottom so we will compare the x coordinates
    // of two consecutive writing boxes to know if we have a new line
    while (index < pRecoRange->cCount)
    {
		int iColumn = wispalt->pColumnIndex[pRecoRange->iwcBegin+index];
		int iIndexInColumn = wispalt->pIndexInColumn[pRecoRange->iwcBegin+index];

		// Skip over spaces in the range
		if (iIndexInColumn == SPACE_ALT_ID)
		{
	        index++;
			continue;
		}

        // Check if we switched to a new line
	    if (index > 0 && 
			lPrevChar > vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.left)
		{
			// Looks like we moved to a new line, modify the reco range to end here and exit the loop.
			pRecoRange->cCount = index;
			// Back up over spaces until we reach the actual end of the previous line
			while (pRecoRange->cCount > 0 && wispalt->pIndexInColumn[pRecoRange->iwcBegin + pRecoRange->cCount - 1] == SPACE_ALT_ID)
			{
				pRecoRange->cCount--;
			}
            break;
		}
        lPrevChar = vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.left;

		switch(lm)
        {
            case LM_BASELINE:
            case LM_DESCENDER:
                flTotalY += vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.bottom;
                break;
            case LM_MIDLINE:
                flTotalY += (vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.bottom + 
                    vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.top) / 2;
                break;
            case LM_ASCENDER:
                flTotalY += vrc->pLattice->pAltList[iColumn].alts[iIndexInColumn].writingBox.top;
                break;
            default:
                ASSERT(!lm);
                return E_INVALIDARG;
        }
        index++;
		cCharacters++;
    }

	// Average the y positions
    pls->PtA.y = (LONG) (flTotalY / cCharacters);
    pls->PtB.y = pls->PtA.y;

	// Set the x range based on the updated reco range
    pls->PtA.x = vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin]].alts[wispalt->pIndexInColumn[pRecoRange->iwcBegin]].writingBox.left;
    pls->PtB.x = vrc->pLattice->pAltList[wispalt->pColumnIndex[pRecoRange->iwcBegin+pRecoRange->cCount-1]].alts[wispalt->pIndexInColumn[pRecoRange->iwcBegin+pRecoRange->cCount-1]].writingBox.right;
    return hr;
}

HRESULT WINAPI GetGuideIndex(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *piIndex)
{
    struct WispAlternate        *wispalt;
    struct WispContext          *wisphrc;
    VRC                         *vrc;

	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}

	vrc = (VRC *) wisphrc->hrc;
	if (vrc == NULL)
	{
		return E_INVALIDARG;
	}
    
    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE))) 
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(piIndex, sizeof(ULONG))) 
	{
        return E_POINTER;
	}

    if (!pRecoRange->cCount) 
	{
        return E_INVALIDARG;
	}

    if (pRecoRange->iwcBegin + pRecoRange->cCount > (ULONG)wispalt->iLength) 
	{
        return E_INVALIDARG;
	}

    if (!wisphrc->bIsBoxed) 
	{
        return TPC_E_NOT_RELEVANT;
	}

    // Ok we are clean
    pRecoRange->cCount = 1;

    // Find the Guide index for this character
    *piIndex = wisphrc->uiGuideIndex;
	*piIndex += vrc->pLattice->pStroke[wispalt->pColumnIndex[pRecoRange->iwcBegin]].iBox;

	// We should not have any spaces in boxed mode.  But just in case, let's try to deal with 
	// them in a reasonable way, by assuming the space comes in the box immediately after
	// the box containing the stroke.
	if (wispalt->pIndexInColumn[pRecoRange->iwcBegin] == SPACE_ALT_ID)
	{
		(*piIndex)++;
	}
    return S_OK;
}

// If the specified character is a space or on the current path, return medium
// confidence.  Otherwise return poor.
CONFIDENCE_LEVEL GetConfidenceLevelInternal(VRC *vrc, int iColumn, int iAlt)
{
	if (iAlt == SPACE_ALT_ID ||	vrc->pLattice->pAltList[iColumn].alts[iAlt].fCurrentPath)
	{
		return CFL_INTERMEDIATE;
	}
	else
	{
		return CFL_POOR;
	}
}

HRESULT WINAPI GetConfidenceLevel(HRECOALT hrcalt, RECO_RANGE* pRecoRange, CONFIDENCE_LEVEL* pcl)
{
    struct WispAlternate        *wispalt;
    struct WispContext          *wisphrc;
	VRC							*vrc;

	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}
	vrc = (VRC *) wisphrc->hrc;

	// Check the parameters
    if (pRecoRange != NULL)
	{
		if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE))) 
		{
			return E_POINTER;
		}

		if (!pRecoRange->cCount) 
		{
			return E_INVALIDARG;
		}

		if (pRecoRange->iwcBegin + pRecoRange->cCount > (ULONG)wispalt->iLength) 
		{
			return E_INVALIDARG;
		}
	}

    if (IsBadWritePtr(pcl, sizeof(CONFIDENCE_LEVEL))) 
	{
        return E_POINTER;
	}

#ifndef ENABLE_CONFIDENCE_LEVEL

	// Ok we are clean
	return E_NOTIMPL;

#else

	if (pRecoRange != NULL) 
	{
		// We only return confidence for single characters
		pRecoRange->cCount = 1;

		// If the specified character is a space or on the current path, return medium
		// confidence.  Otherwise return poor.
		*pcl = GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[pRecoRange->iwcBegin], wispalt->pIndexInColumn[pRecoRange->iwcBegin]);
	}
	else
	{
		// If the first character is a space or on the current path, return medium
		// confidence.  Otherwise return poor.
		*pcl = GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[0], wispalt->pIndexInColumn[0]);
	}

    return S_OK;

#endif
}

HRESULT WINAPI GetPropertyRanges(HRECOALT hrcalt, const GUID *pPropertyGuid, ULONG* pcRanges, RECO_RANGE* pRecoRange)
{
    struct WispAlternate    *wispalt;
    struct WispContext      *wisphrc;
	VRC						*vrc;
    
	// find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}
	vrc = (VRC *) wisphrc->hrc;

    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
    {
        return E_POINTER;
    }

	if (pRecoRange != NULL && IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE) * (*pcRanges)))
	{
		return E_POINTER;
	}

    if (IsEqualGUID(pPropertyGuid, &GUID_LINEMETRICS))
	{
		return TPC_E_NOT_RELEVANT;
	}

#ifdef ENABLE_CONFIDENCE_LEVEL
	if (IsEqualGUID(pPropertyGuid, &GUID_CONFIDENCELEVEL))
	{
		CONFIDENCE_LEVEL clPrev, clThis;
		int iRange = 0;
		int i;
		for (i = 0; i < wispalt->iLength; i++)
		{
			clThis = GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[i], wispalt->pIndexInColumn[i]);
			if (i == 0 || (clPrev != clThis))
			{
				iRange++;
			} 
			clPrev = clThis;
		}
		if (pRecoRange != NULL && *pcRanges < (ULONG) iRange) 
		{
			return TPC_E_INSUFFICIENT_BUFFER;
		}
		*pcRanges = iRange;
		if (pRecoRange != NULL)
		{
			iRange = 0;
			for (i = 0; i < wispalt->iLength; i++)
			{
				clThis = GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[i], wispalt->pIndexInColumn[i]);
				if (i == 0 || (clPrev != clThis))
				{
					pRecoRange[iRange].iwcBegin = i;
					pRecoRange[iRange].cCount = 1;
					iRange++;
				}
				else
				{
					pRecoRange[iRange - 1].cCount++;
				}
				clPrev = clThis;
			}
		}
		return S_OK;
	}
#endif

    return TPC_E_INVALID_PROPERTY;
}

HRESULT WINAPI GetRangePropertyValue(HRECOALT hrcalt, const GUID *pPropertyGuid, RECO_RANGE* pRecoRange, ULONG*pcbSize, BYTE* pProperty)
{
    struct WispAlternate    *wispalt;
    struct WispContext      *wisphrc;
	VRC						*vrc;
    
    // find the handle and validate the correpsonding pointer
	wispalt = (struct WispAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT);
	if (NULL == wispalt)
	{
        return E_INVALIDARG;
	}

	// validate the corresponding hrc pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)wispalt->hrc, TPG_HRECOCONTEXT);
    if (wisphrc == NULL) 
	{
        return E_INVALIDARG;
	}
	vrc = (VRC *) wisphrc->hrc;

    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pcbSize, sizeof(ULONG)))
    {
        return E_POINTER;
    }

	if (pProperty != NULL && IsBadWritePtr(pProperty, *pcbSize)) 
	{
		return E_POINTER;
	}

    if (IsEqualGUID(pPropertyGuid, &GUID_LINEMETRICS))
	{
		HRESULT hr = S_OK;
		LINE_SEGMENT baseline, midline;
		if (pProperty == NULL)
		{
			*pcbSize = sizeof(LATTICE_METRICS);
		}
		else if (*pcbSize < sizeof(LATTICE_METRICS)) 
		{
			return TPC_E_INSUFFICIENT_BUFFER;
		}
		*pcbSize = sizeof(LATTICE_METRICS);
		hr = GetMetrics(hrcalt, pRecoRange, LM_BASELINE, &baseline);
		if (SUCCEEDED(hr))
		{
			hr = GetMetrics(hrcalt, pRecoRange, LM_MIDLINE, &midline);
		}
		if (SUCCEEDED(hr) && pProperty != NULL)
		{
			LATTICE_METRICS *plm = (LATTICE_METRICS *) pProperty;
			plm->lsBaseline = baseline;
			plm->iMidlineOffset = (short)(midline.PtA.y - baseline.PtA.y);
		}
		return hr;
	}

#ifdef ENABLE_CONFIDENCE_LEVEL
	if (IsEqualGUID(pPropertyGuid, &GUID_CONFIDENCELEVEL))
	{
		CONFIDENCE_LEVEL cl;
		int iStart = pRecoRange->iwcBegin;
		int iLimit = pRecoRange->iwcBegin + pRecoRange->cCount;
		int i;
		if (pProperty == NULL) 
		{
			*pcbSize = sizeof(CONFIDENCE_LEVEL);
		} 
		else if (*pcbSize < sizeof(CONFIDENCE_LEVEL))
		{
			return TPC_E_INSUFFICIENT_BUFFER;
		}
		*pcbSize = sizeof(CONFIDENCE_LEVEL);
		cl = GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[iStart],
										wispalt->pIndexInColumn[iStart]);
		for (i = iStart + 1; i < iLimit; i++) 
		{
			if (GetConfidenceLevelInternal(vrc, wispalt->pColumnIndex[i], wispalt->pIndexInColumn[i]) != cl)
			{
				pRecoRange->cCount = i - iStart;
				break;
			}
		}
		if (pProperty != NULL)
		{
			*((CONFIDENCE_LEVEL *) pProperty) = cl;
		}
		return S_OK;
	}
#endif

    return TPC_E_INVALID_PROPERTY;
}

void SortLatticeElements(RECO_LATTICE_ELEMENT *pStartElement, RECO_LATTICE_ELEMENT *pCurrent)
{
    RECO_LATTICE_ELEMENT    rleTemp;
    BOOL                    bSwap = TRUE;
    int                     iElementCount = pCurrent - pStartElement;
    int                     i = 0, count = 0;

    // For now just a quick bubble sort
    count = 1;
    while (bSwap)
    {
        bSwap = FALSE;
        for (i = 0; i < iElementCount-count; i++)
        {
            if (pStartElement[i].score > pStartElement[i+1].score)
            {
                // swap
                rleTemp = pStartElement[i];
                pStartElement[i] = pStartElement[i+1];
                pStartElement[i+1] = rleTemp;
                bSwap = TRUE;
            }
        }
        count++;
    }
}

// GetLatticePtr
//
// Description: This method creates a Lattice structure for 
// the recognition context and returns a pointer to it. The
// structure is going to be freed when the recognition
// context is destoyed or when a new call to GetLatticePtr
// is issued.
HRESULT WINAPI GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice)
{
	BOOL					fNextColumnSpace = FALSE;
    HRESULT                 hr = S_OK;
    struct WispContext      *wisphrc;
    RECO_LATTICE_ELEMENT    *pCurrent = NULL, *pStartElement = NULL, rleInPath;
	int						*pMapToLatticeColumn = NULL;
    VRC                     *vrc = NULL;
    int                     i = 0, j = 0, k = 0;
    ULONG                   ulElementCount = 0, ulRealElementCount = 0;
    ULONG                   ulMaxStroke = 0;
    ULONG                   *pCurrentStroke = NULL;
    ULONG                   ulBestResultIndex = 0;
    RECO_LATTICE_ELEMENT    *pCur = NULL;
	int						iStroke;
	int						iExternalColumn;
	BYTE					*pCurrentPropertyValue = NULL;
	RECO_LATTICE_PROPERTY	*pCurrentProperty = NULL;
	RECO_LATTICE_PROPERTY	*pConfidencePropStart = NULL;
	RECO_LATTICE_PROPERTY	**ppCurrentProperty = NULL;
	LATTICE_METRICS			*pLatticeMetrics;
	FLOAT					flScore;
    
    // validate and destroy the handle & return the pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (NULL == wisphrc)
    {
		return E_INVALIDARG;
	}

	// Check the parameters 
    if (IsBadWritePtr(ppLattice, sizeof(RECO_LATTICE*))) 
	{
        return E_POINTER;
	}

    *ppLattice = NULL;

    // We should only do this if the lattice is dirty!
    if (wisphrc->pLattice)
    {
        hr = FreeRecoLattice(wisphrc);
        ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }

    // Do we have results?
    if (!wisphrc->hrc) 
	{
        return TPC_E_NOT_RELEVANT;
	}

    vrc = (VRC*) wisphrc->hrc;
    if (!vrc->pLatticePath) 
	{
        return TPC_E_NOT_RELEVANT;
	}

    // Allocate the lattice
    wisphrc->pLattice = (RECO_LATTICE*)ExternAlloc(sizeof(RECO_LATTICE));
    if (!wisphrc->pLattice)
	{
        return E_OUTOFMEMORY;
	}

    // Initialize the RECO_LATTICE structure
    ZeroMemory(wisphrc->pLattice, sizeof(RECO_LATTICE));

    wisphrc->pLattice->pGuidProperties = NULL;
    wisphrc->pLattice->ulPropertyCount = 0;
    wisphrc->pLattice->ulColumnCount = vrc->pLattice->nStrokes;
    wisphrc->pLattice->ulBestResultColumnCount = vrc->pLatticePath->nChars;

	// Add columns to the lattice for each space
	for (i = 0; i < vrc->pLattice->nStrokes; i++)
	{
		if (vrc->pLattice->pAltList[i].fSpaceAfterStroke)
		{
			wisphrc->pLattice->ulColumnCount++;
		}
	}

    // For now we have only two properties: the GUID_CONFIDENCELEVEL and GUID_LINEMETRICS
    wisphrc->pLattice->ulPropertyCount = 1;
#ifdef ENABLE_CONFIDENCE_LEVEL
    wisphrc->pLattice->ulPropertyCount++;
#endif
    wisphrc->pLattice->pGuidProperties = (GUID *) ExternAlloc(wisphrc->pLattice->ulPropertyCount * sizeof(GUID));
	if (wisphrc->pLattice->pGuidProperties == NULL)
    {
        HRESULT hrFRL = FreeRecoLattice(wisphrc);
		ASSERT(SUCCEEDED(hrFRL));
        return E_OUTOFMEMORY;
    }
	wisphrc->pLattice->pGuidProperties[0] = GUID_LINEMETRICS;
#ifdef ENABLE_CONFIDENCE_LEVEL
	wisphrc->pLattice->pGuidProperties[1] = GUID_CONFIDENCELEVEL;
#endif

	if (wisphrc->pLattice->ulColumnCount)
    {
        // Allocating the array of LatticeColumns
        wisphrc->pLattice->pLatticeColumns = 
            ExternAlloc(wisphrc->pLattice->ulColumnCount * sizeof(RECO_LATTICE_COLUMN));
		if (wisphrc->pLattice->pLatticeColumns)
		{
			ZeroMemory(wisphrc->pLattice->pLatticeColumns, 
				wisphrc->pLattice->ulColumnCount * sizeof(RECO_LATTICE_COLUMN));
		}
        // Allocate the arrays for the best result
        wisphrc->pLattice->pulBestResultColumns = (ULONG*)
            ExternAlloc(vrc->pLatticePath->nChars * sizeof(ULONG));
        wisphrc->pLattice->pulBestResultIndexes = (ULONG*)
            ExternAlloc(vrc->pLatticePath->nChars * sizeof(ULONG));
        if (!wisphrc->pLattice->pLatticeColumns ||
			!wisphrc->pLattice->pulBestResultColumns ||
            !wisphrc->pLattice->pulBestResultIndexes)
        {
            HRESULT hrFRL = FreeRecoLattice(wisphrc);
			ASSERT(SUCCEEDED(hrFRL));
            return E_OUTOFMEMORY;
        }

        // Allocating the array of Strokes
        wisphrc->pLattice->pLatticeColumns[0].pStrokes = 
            ExternAlloc(vrc->pLattice->nRealStrokes * sizeof(ULONG));
        if (!wisphrc->pLattice->pLatticeColumns[0].pStrokes)
        {
            HRESULT hrFRL = FreeRecoLattice(wisphrc);
			ASSERT(SUCCEEDED(hrFRL));
            return E_OUTOFMEMORY;
        }

        // Do corrections for the merged strokes - Annoying detail!
        j = 0;
        for (i = 0; i < vrc->pLattice->nStrokes; i++)
        {
            if (vrc->pLattice->pStroke[i].iLast != vrc->pLattice->pStroke[i].iOrder)
            {
                //There has been Stroke merging
                // Add the Stroke list for this merge stroke
                for (k = vrc->pLattice->pStroke[i].iOrder; k <= vrc->pLattice->pStroke[i].iLast; k++)
                {
                    wisphrc->pLattice->pLatticeColumns[0].pStrokes[j] = k;
                    j++;
                }
            }
            else
            {
                // No stroke merging for this stroke
                wisphrc->pLattice->pLatticeColumns[0].pStrokes[j] = 
                    vrc->pLattice->pStroke[i].iOrder;
                j++;
            }
        }

        // Count the number of Lattice elements
        for (i = 0; i < vrc->pLattice->nStrokes; i++)
        {
			unsigned int ulElements = vrc->pLattice->pAltList[i].nUsed;
            // For each column count the elements
			if ((wisphrc->dwFlags & RECOFLAG_SINGLESEG) != 0)
			{
				int nStrokes = -1;
				ulElements = 0;
				for (j = 0; j < vrc->pLattice->pAltList[i].nUsed; j++)
				{
					if (vrc->pLattice->pAltList[i].alts[j].fCurrentPath)
					{
						nStrokes = vrc->pLattice->pAltList[i].alts[j].nStrokes;
						break;
					}
				}
				for (j = 0; j < vrc->pLattice->pAltList[i].nUsed; j++)
				{
					if (nStrokes == vrc->pLattice->pAltList[i].alts[j].nStrokes)
					{
						ulElements++;
					}
				}
			}
            ulElementCount += ulElements;
	        ulRealElementCount += ulElements;
			// Add an element for each space
			if (vrc->pLattice->pAltList[i].fSpaceAfterStroke)
			{
				ulElementCount++;
			}
        }

        // Create the elements if needed
        if (ulElementCount)
        {
            wisphrc->pLattice->pLatticeColumns[0].pLatticeElements 
                = ExternAlloc(ulElementCount*sizeof(RECO_LATTICE_ELEMENT));
            if (!wisphrc->pLattice->pLatticeColumns[0].pLatticeElements)
            {
                HRESULT hrFRL = FreeRecoLattice(wisphrc);
				ASSERT(SUCCEEDED(hrFRL));
                return E_OUTOFMEMORY;
            }
            ZeroMemory(wisphrc->pLattice->pLatticeColumns[0].pLatticeElements,
                ulElementCount*sizeof(RECO_LATTICE_ELEMENT));
            pCurrent = wisphrc->pLattice->pLatticeColumns[0].pLatticeElements;

			// Let's do the line metrics and the confidence levels
			pCurrentProperty =
				(RECO_LATTICE_PROPERTY *) ExternAlloc((3 + ulRealElementCount) * sizeof(RECO_LATTICE_PROPERTY));
			wisphrc->pLatticeProperties = pCurrentProperty;
			pCurrentPropertyValue = 
				(BYTE *) ExternAlloc(3 * sizeof(CONFIDENCE_LEVEL) + ulRealElementCount * sizeof(LATTICE_METRICS));
			wisphrc->pLatticePropertyValues = pCurrentPropertyValue;

			// Allocate property lists for each element.  The non-spaces (real elements) each have two
			// properties, and the spaces have one property.
#ifdef ENABLE_CONFIDENCE_LEVEL
			ppCurrentProperty = 
				(RECO_LATTICE_PROPERTY **) ExternAlloc((ulElementCount + ulRealElementCount) * sizeof(RECO_LATTICE_PROPERTY *));
#else
			ppCurrentProperty = 
				(RECO_LATTICE_PROPERTY **) ExternAlloc(ulRealElementCount * sizeof(RECO_LATTICE_PROPERTY *));
#endif
			wisphrc->ppLatticeProperties = ppCurrentProperty;
			
			if (!pCurrentProperty || !pCurrentPropertyValue || !ppCurrentProperty)
			{
				HRESULT hrFRL = FreeRecoLattice(wisphrc);
				ASSERT(SUCCEEDED(hrFRL));
				return E_OUTOFMEMORY;
			}

			// Fill the RECO_LATTICE_PROPERTY array to contain the confidence level
			pConfidencePropStart = pCurrentProperty;

			pCurrentProperty->guidProperty = GUID_CONFIDENCELEVEL;
			pCurrentProperty->cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty->pPropertyValue = pCurrentPropertyValue;
			*( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_STRONG;
			pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty++;

			// next value
			pCurrentProperty->guidProperty = GUID_CONFIDENCELEVEL;
			pCurrentProperty->cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty->pPropertyValue = pCurrentPropertyValue;
			*( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_INTERMEDIATE;
			pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty++;

			// next value
			pCurrentProperty->guidProperty = GUID_CONFIDENCELEVEL;
			pCurrentProperty->cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty->pPropertyValue = pCurrentPropertyValue;
			*( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_POOR;
			pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
			pCurrentProperty++;
		}

		// Allocate space for the mapping
		pMapToLatticeColumn = (int *) ExternAlloc(sizeof(int) * vrc->pLattice->nStrokes);
		if (pMapToLatticeColumn == NULL)
		{
			HRESULT hrFRL = FreeRecoLattice(wisphrc);
			ASSERT(SUCCEEDED(hrFRL));
			return E_OUTOFMEMORY;
		}

        // Fill in mapping from internal lattice columns to the newly created lattice columns.
		// Note that this mapping always points to columns related to strokes, not to spaces.
		j = 0;
        for (i = 0; i < vrc->pLattice->nStrokes; i++)
        {
			pMapToLatticeColumn[i] = j;
			j++;
			// Add a column for each space
			if (vrc->pLattice->pAltList[i].fSpaceAfterStroke)
			{
				j++;
			}
        }
		ASSERT( wisphrc->pLattice->ulColumnCount == j );
	
		// Initialize the lattice columns
        pCurrentStroke = wisphrc->pLattice->pLatticeColumns[0].pStrokes;
		iExternalColumn = 0;
        for (i = 0; i < vrc->pLattice->nStrokes; i++)
        {
			int iStartStroke = i, iEndStroke = vrc->pLattice->nStrokes;
			ASSERT(pMapToLatticeColumn[i] == iExternalColumn);

			rleInPath.type = RECO_TYPE_WSTRING;
			ulMaxStroke = 0;
			pStartElement = pCurrent;

			// If we're pretending to have a single segmentation, then find the next
			// element on the best path, and restrict the search for elements starting
			// here to that column.
			if ((wisphrc->dwFlags & RECOFLAG_SINGLESEG) != 0) 
			{
				BOOL fFound = FALSE;
				for (j = i; j < vrc->pLattice->nStrokes && !fFound; j++) 
				{
					for (k = 0; k < vrc->pLattice->pAltList[j].nUsed && !fFound; k++)
					{
						if (vrc->pLattice->pAltList[j].alts[k].fCurrentPath) 
						{
							// Make sure this element links up to the starting column we 
							// are at now.  If it doesn't, then the current stroke is in 
							// the middle of a best path element, so this column will 
							// be empty.
							if (j + 1 - vrc->pLattice->pAltList[j].alts[k].nStrokes != i)
							{
								goto NoElementsInColumn;
							}
							iStartStroke = j;
							iEndStroke = j + 1;
							fFound = TRUE;
						}
					}
				}
				if (!fFound) 
				{
					goto NoElementsInColumn;
				}
			}

			// Find all elements that start at this columns #
			// This could probably be optimized
			for (j = iStartStroke; j < iEndStroke; j++)
			{
				// Go through each alt
				for (k = 0; k < vrc->pLattice->pAltList[j].nUsed; k++)
				{
					if (j + 1 - vrc->pLattice->pAltList[j].alts[k].nStrokes == i)
					{
						// This one starts at the right location

						// Set up the properties.  There are two properties for each
						// character, the line metrics and the confidence level.
						pCurrent->epProp.cProperties = 1;
						ASSERT(pCurrent->epProp.apProps == NULL);
						pCurrent->epProp.apProps = ppCurrentProperty;

						*ppCurrentProperty = pCurrentProperty;
						ppCurrentProperty++;

						pCurrentProperty->guidProperty = GUID_LINEMETRICS;
						pCurrentProperty->cbPropertyValue = sizeof(LATTICE_METRICS);
						pCurrentProperty->pPropertyValue = pCurrentPropertyValue;
						pCurrentProperty++;

						pLatticeMetrics = (LATTICE_METRICS *) pCurrentPropertyValue;
						pCurrentPropertyValue += sizeof(LATTICE_METRICS);

						pLatticeMetrics->lsBaseline.PtA.x = vrc->pLattice->pAltList[j].alts[k].writingBox.left;
						pLatticeMetrics->lsBaseline.PtA.y = vrc->pLattice->pAltList[j].alts[k].writingBox.bottom;
						pLatticeMetrics->lsBaseline.PtB.x = vrc->pLattice->pAltList[j].alts[k].writingBox.right;
						pLatticeMetrics->lsBaseline.PtB.y = vrc->pLattice->pAltList[j].alts[k].writingBox.bottom;
						pLatticeMetrics->iMidlineOffset = 
							(SHORT) ((vrc->pLattice->pAltList[j].alts[k].writingBox.top -
										vrc->pLattice->pAltList[j].alts[k].writingBox.bottom) / 2);

#ifdef ENABLE_CONFIDENCE_LEVEL
						switch (GetConfidenceLevelInternal(vrc, i, k))
						{
						case CFL_STRONG:
							pCurrent->epProp.cProperties++;
							*ppCurrentProperty = pConfidencePropStart;
							ppCurrentProperty++;
							break;
						case CFL_INTERMEDIATE:
							pCurrent->epProp.cProperties++;
							*ppCurrentProperty = pConfidencePropStart + 1;
							ppCurrentProperty++;
							break;
						case CFL_POOR:
							pCurrent->epProp.cProperties++;
							*ppCurrentProperty = pConfidencePropStart + 2;
							ppCurrentProperty++;
							break;
						}
#endif
						// Get the character
						if (vrc->pLattice->pAltList[j].alts[k].wChar == SYM_UNKNOWN)
						{
							pCurrent->pData = (void*) SYM_UNKNOWN;
						}
						else
						{
							pCurrent->pData = (void*)(LocRunDense2Unicode(&g_locRunInfo,
								vrc->pLattice->pAltList[j].alts[k].wChar));
						}
						pCurrent->ulNextColumn = pMapToLatticeColumn[j] + 1;

						// Count up the number of real strokes used by this alternate
						pCurrent->ulStrokeNumber = 0;
						// For each merged stroke in this alternate
						for (iStroke = j; iStroke > j - vrc->pLattice->pAltList[j].alts[k].nStrokes; iStroke--)
						{
							// Add the number of real strokes contained in this merged stroke
							pCurrent->ulStrokeNumber += 
								vrc->pLattice->pStroke[iStroke].iLast -
								vrc->pLattice->pStroke[iStroke].iOrder + 1;
						}
						if (ulMaxStroke < pCurrent->ulStrokeNumber)
							ulMaxStroke = pCurrent->ulStrokeNumber;

						pCurrent->type = RECO_TYPE_WCHAR;
						flScore = -1024 * 
							vrc->pLattice->pAltList[j].alts[k].logProb;
//							GetScore(vrc->pLattice, j, k);
						if (flScore > INT_MAX)
						{
							flScore = (FLOAT) INT_MAX;
						}
						pCurrent->score = (int) flScore;
						// Is it part of the best result?
						if (vrc->pLattice->pAltList[j].alts[k].fCurrentPath)
						{
							// Yes, strore the column
							wisphrc->pLattice->pulBestResultColumns[ulBestResultIndex] = iExternalColumn;
							ASSERT(rleInPath.type == RECO_TYPE_WSTRING);
							rleInPath = *pCurrent;
						}
						pCurrent++;
					}
				}
			}
			// We need to sort that list!
			SortLatticeElements(pStartElement, pCurrent);
			// Is there an element from the best result in this column?
			if (rleInPath.type != RECO_TYPE_WSTRING)
			{
				// find its index in the column
				for (pCur = pStartElement; pCur < pCurrent; pCur++)
				{
					if (!memcmp(pCur, &rleInPath, sizeof(RECO_LATTICE_ELEMENT))) 
						break;
				}
				ASSERT(pCur != pCurrent);
				if (pCur != pCurrent)
				{
					wisphrc->pLattice->pulBestResultIndexes[ulBestResultIndex] = pCur - pStartElement;
					ulBestResultIndex++;
				}
			}
		
NoElementsInColumn:
			// Fill in the Reco Column information
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].key = iExternalColumn;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].cpProp.cProperties = 0;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].cpProp.apProps = NULL;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].cStrokes = ulMaxStroke;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].pStrokes = pCurrentStroke;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].cLatticeElements = pCurrent-pStartElement;
			wisphrc->pLattice->pLatticeColumns[iExternalColumn].pLatticeElements = pStartElement;

			// Jump to the next "current" stroke : Always the annoying detail!
			pCurrentStroke += vrc->pLattice->pStroke[i].iLast -
				vrc->pLattice->pStroke[i].iOrder + 1;

			// The new Start is:
			pStartElement = pCurrent;
			iExternalColumn++;

			if (vrc->pLattice->pAltList[i].fSpaceAfterStroke) 
			{
				// If there is a space, then it must be on the current path (because spaces are only 
				// created on the current path).  This simplifies the code a lot.
				pStartElement = pCurrent;

				// Set up the properties.  For spaces, the only property that applies is the 
				// confidence level.
				pCurrent->epProp.cProperties = 0;
				ASSERT(pCurrent->epProp.apProps == NULL);
				pCurrent->epProp.apProps = ppCurrentProperty;
#ifdef ENABLE_CONFIDENCE_LEVEL
				switch (GetConfidenceLevelInternal(vrc, i, SPACE_ALT_ID))
				{
				case CFL_STRONG:
					pCurrent->epProp.cProperties++;
					*ppCurrentProperty = pConfidencePropStart;
					ppCurrentProperty++;
					break;
				case CFL_INTERMEDIATE:
					pCurrent->epProp.cProperties++;
					*ppCurrentProperty = pConfidencePropStart + 1;
					ppCurrentProperty++;
					break;
				case CFL_POOR:
					pCurrent->epProp.cProperties++;
					*ppCurrentProperty = pConfidencePropStart + 2;
					ppCurrentProperty++;
					break;
				}
#endif
				pCurrent->pData = (void*) SYM_SPACE;
				pCurrent->ulNextColumn = iExternalColumn + 1;
				pCurrent->ulStrokeNumber = 0;
				pCurrent->type = RECO_TYPE_WCHAR;
				pCurrent->score = 0;
				wisphrc->pLattice->pulBestResultColumns[ulBestResultIndex] = iExternalColumn;
				wisphrc->pLattice->pulBestResultIndexes[ulBestResultIndex] = 0;
				ulBestResultIndex++;

				pCurrent++;

				// Fill in the Reco Column information
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].key = iExternalColumn;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].cpProp.cProperties = 0;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].cpProp.apProps = NULL;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].cStrokes = 0;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].pStrokes = pCurrentStroke;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].cLatticeElements = 1;
				wisphrc->pLattice->pLatticeColumns[iExternalColumn].pLatticeElements = pStartElement;

				// The new Start is:
				pStartElement = pCurrent;
				iExternalColumn++;
			}
		}
        // Check the number of elements in the best path
        ASSERT(ulBestResultIndex == (ULONG)vrc->pLatticePath->nChars);
		ASSERT(iExternalColumn == wisphrc->pLattice->ulColumnCount);
		ASSERT(pCurrentStroke - wisphrc->pLattice->pLatticeColumns[0].pStrokes == vrc->pLattice->nRealStrokes);
    }

    if (SUCCEEDED(hr))
        *ppLattice = wisphrc->pLattice;

	ExternFree(pMapToLatticeColumn);

    return hr;
}

// Lists of properties
static const ULONG CONTEXT_PROPERTIES_COUNT = 1;

// {1ABC3828-BDF1-4ef3-8F2C-0751EC0DE742}
static const GUID GUID_ENABLE_IFELANG3 = { 0x1abc3828, 0xbdf1, 0x4ef3, { 0x8f, 0x2c, 0x7, 0x51, 0xec, 0xd, 0xe7, 0x42 } };

//	GetContextPropertyList
//		Return a list of properties supported on the context
//
//	Parameters:
//		hrc [in]	:				Handle to the recognition context
//		pcProperties [in/out]	:	Number of properties supported
//		pPropertyGUIDS [out]	:	List of properties supported
HRESULT WINAPI GetContextPropertyList(HRECOCONTEXT hrc,
									  ULONG* pcProperties,
									  GUID* pPropertyGUIDS)
{
	if (NULL == (HRC *)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT) )
	{
        return E_POINTER;
	}
	if ( IsBadWritePtr(pcProperties, sizeof(ULONG)) )
		return E_POINTER;
	if (pPropertyGUIDS == NULL)		// Need only the count
	{
		*pcProperties = CONTEXT_PROPERTIES_COUNT;
		return S_OK;
	}

	if (*pcProperties < CONTEXT_PROPERTIES_COUNT)
		return TPC_E_INSUFFICIENT_BUFFER;

	*pcProperties = CONTEXT_PROPERTIES_COUNT;
	if ( IsBadWritePtr(pPropertyGUIDS, CONTEXT_PROPERTIES_COUNT * sizeof(GUID)) )
		return E_POINTER;

	pPropertyGUIDS[0] = GUID_ENABLE_IFELANG3;
	return S_OK;
}

//	GetContextPropertyValue
//		Return a property of the context, currently no properties are supported
//
//	Parameters:
//		hrc [in] :			Handle to the recognition context
//		pGuid [in]	:		Property GUID
//		pcbSize [in/out] :	Size of the property buffer (in BYTEs)
//		pProperty [out]  :	Value of the desired property
HRESULT WINAPI GetContextPropertyValue(HRECOCONTEXT hrc,
						GUID *pGuid,
						ULONG *pcbSize,
						BYTE *pProperty)
{
    struct WispContext		*wisphrc;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (wisphrc == NULL)
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pGuid, sizeof(GUID)) )
		return E_POINTER;
	if ( IsBadWritePtr(pcbSize, sizeof(ULONG)) )
		return E_POINTER;

	if ( IsEqualGUID(pGuid, &GUID_ENABLE_IFELANG3) )
	{
		BOOL *pb = (BOOL *) pProperty;
		if (pProperty == NULL) 
		{
			*pcbSize = sizeof(BOOL);
			return S_OK;
		}
		if (*pcbSize < sizeof(BOOL))
		{
			return TPC_E_INSUFFICIENT_BUFFER;
		}
		*pcbSize = sizeof(BOOL);
#ifdef USE_IFELANG3
		*pb = LatticeIFELang3Available();
#else
		*pb = FALSE;
#endif
		return S_OK;
	}

	return TPC_E_INVALID_PROPERTY;
}

//	SetContextPropertyValue
//		Set a property of the context  (currently only GUID_ENABLE_IFELANG3)
//
//	Parameters:
//		hrc [in] :			Handle to the recognition context
//		pGuid [in]	:		Property GUID
//		pcbSize [in] :		Size of the property buffer (in BYTEs)
//		pProperty [in]  :	Value of the desired property
HRESULT WINAPI SetContextPropertyValue(HRECOCONTEXT hrc,
						GUID *pGuid,
						ULONG cbSize,
						BYTE *pProperty)
{
    struct WispContext		*wisphrc;

	// find the handle and validate the correpsonding pointer
	wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT);
	if (wisphrc == NULL)
	{
        return E_POINTER;
	}
	if ( IsBadReadPtr(pGuid, sizeof(GUID)) )
		return E_POINTER;
	if ( IsBadReadPtr(pProperty, cbSize) )
		return E_POINTER;

	if ( IsEqualGUID(pGuid, &GUID_ENABLE_IFELANG3) )
	{
		BOOL *pb = (BOOL *) pProperty;
		if (cbSize != sizeof(BOOL)) 
		{
			return E_INVALIDARG;
		}
		if (*pb) 
		{
#ifdef USE_IFELANG3
			// If already enabled, return S_FALSE
			if (LatticeIFELang3Available()) 
			{
				return S_FALSE;
			}
			return LatticeConfigIFELang3() ? S_OK : E_FAIL;
#else
			return E_FAIL;
#endif
		}
		else
		{
#ifdef USE_IFELANG3
			// If already disabled, return S_FALSE
			if (!LatticeIFELang3Available())
			{
				return S_FALSE;
			}
			return LatticeUnconfigIFELang3() ? S_OK : E_FAIL;
#else
			return S_FALSE;
#endif
		}
	}
	return TPC_E_INVALID_PROPERTY;
}

/////////////////////////////////////////////////////////////////
// Registration information
//
//

#define FULL_PATH_VALUE     L"Recognizer dll"
#define RECO_LANGUAGES      L"Recognized Languages"
#define RECO_CAPABILITIES   L"Recognizer Capability Flags"
#define RECO_MANAGER_KEY    L"CLSID\\{DE815B00-9460-4F6E-9471-892ED2275EA5}\\InprocServer32"
#define CLSID_KEY           L"CLSID"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

// This recognizer GUID is going to be
// {6D0087D7-61D2-495f-9293-5B7B1C3FCEAB}
// Each recognizer HAS to have a different GUID

STDAPI DllRegisterServer(void)
{
    HKEY        hKeyReco = NULL;
    HKEY        hKeyRecoManager = NULL;
    LONG        lRes = 0;   
    HKEY        hkeyMyReco = NULL;
    DWORD       dwLength = 0, dwType = 0, dwSize = 0;
    DWORD       dwDisposition;
    WCHAR       szRecognizerPath[MAX_PATH];
    WCHAR       *RECO_SUBKEY = NULL, *RECOGNIZER_SUBKEY = NULL;
    WCHAR       *RECOPROC_SUBKEY = NULL, *RECOCLSID_SUBKEY = NULL;
    RECO_ATTRS  recoAttr;
    HRESULT     hr = S_OK;
	HRECOGNIZER hrec;

	if (FAILED(CreateRecognizer(NULL, &hrec))) 
	{
		return E_FAIL;
	}
    hr = GetRecoAttributes(hrec, &recoAttr);
    if (FAILED(hr))
    {
        return E_FAIL;
    }
	if (FAILED(DestroyRecognizer(hrec)))
	{
		return E_FAIL;
	}
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    // Write the path to this dll in the registry under
    // the recognizer subkey

    // Wipe out the previous values
    lRes = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);
    // Create the new key
    lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE, RECO_SUBKEY, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyMyReco, &dwDisposition);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
    {
        if (hkeyMyReco)
			RegCloseKey(hkeyMyReco);
        return E_FAIL;
    }
    // Get the current path
    // Try to get the path of the RecoObj.dll
    // It should be the same as the one for the RecoCom.dll
    dwLength = GetModuleFileNameW((HMODULE)g_hInstanceDllCode, szRecognizerPath, MAX_PATH);
	if (dwLength == 0 || (dwLength == MAX_PATH && szRecognizerPath[MAX_PATH - 1] != 0)) 
	{
        RegCloseKey(hkeyMyReco);
        return E_FAIL;
	}

    // Write the path to the dll as a value
    lRes = RegSetValueExW(hkeyMyReco, FULL_PATH_VALUE, 0, REG_SZ, 
        (BYTE*)szRecognizerPath, sizeof(WCHAR)*(wcslen(szRecognizerPath)+1));
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyMyReco);
        return E_FAIL;
    }
    // Add the reco attribute information
    lRes = RegSetValueExW(hkeyMyReco, RECO_LANGUAGES, 0, REG_BINARY, 
        (BYTE*)recoAttr.awLanguageId, 64 * sizeof(WORD));
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyMyReco);
        return E_FAIL;
    }
    lRes = RegSetValueExW(hkeyMyReco, RECO_CAPABILITIES, 0, REG_DWORD, 
        (BYTE*)&(recoAttr.dwRecoCapabilityFlags), sizeof(DWORD));
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyMyReco);
        return E_FAIL;
    }
    
    RegCloseKey(hkeyMyReco);
                   
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    LONG        lRes1 = 0;

    // get language id
    WCHAR       *RECO_SUBKEY = NULL, *RECOGNIZER_SUBKEY = NULL;
    WCHAR       *RECOPROC_SUBKEY = NULL, *RECOCLSID_SUBKEY = NULL;
    RECO_ATTRS  recoAttr;
    HRESULT     hr = S_OK;
    HRECOGNIZER hrec;
    
	if (FAILED(CreateRecognizer(NULL, &hrec))) 
	{
		return E_FAIL;
	}
    hr = GetRecoAttributes(hrec, &recoAttr);
    if (FAILED(hr))
    {
        return E_FAIL;
    }
	if (FAILED(DestroyRecognizer(hrec)))
	{
		return E_FAIL;
	}
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D4087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D5087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D6087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (recoAttr.awLanguageId[0] == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D7087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    
    // Wipe out the registry information
    lRes1 = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);

    // Try to erase the local machine\software\microsoft\tpg\recognizer
    // if necessary (don't care if it fails)
	RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\TPG\\System Recognizers");
    RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\TPG");
    
    if (lRes1 != ERROR_SUCCESS && lRes1 != ERROR_FILE_NOT_FOUND)
    {
        return E_FAIL;
    }
    return S_OK ;
}

/*************************************************
 * NAME: validateTpgHandle
 *
 * Generic function to validate a pointer obtained from a WISP
 * style handle. For now function checks the memory
 * is writable
 *
 * RETURNS
 *   TRUE if the pointer passes a minimal validation
 *
 *************************************************/
BOOL validateTpgHandle(void *pPtr, int type)
{
	BOOL	bRet = FALSE;


	switch (type)
	{
		case TPG_HRECOCONTEXT:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(struct WispContext)))
			{
				bRet = TRUE;
			}
			break;
		}

		case TPG_HRECOGNIZER:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(struct WispRec)))
			{
				bRet = TRUE;
			}
		
			break;
		}

		case TPG_HRECOALT:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(struct WispAlternate)))
			{
				bRet = TRUE;
			}
		
			break;
		}

		default:
			break;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\volcanop.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/volcanop.h
//
// Description:
//	    Private header for volcano project.
//	    This should include all the internal data types
//	    as well as including all recognizers used by TSUNAMI class products
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#pragma once

// Sort out which 2 stroke recognizer we're using.
#if !defined(USE_FUGU) && !defined(USE_OTTER) && !defined(USE_OTTERFUGU)
#	define USE_OTTER
#endif

// Sort out which 3 and up stroke recognizer we're using.
#if !defined(USE_HOUND) && !defined(USE_ZILLA) && !defined(USE_ZILLAHOUND)
#	define USE_ZILLA
#endif

// When training Hound-Zilla combiner, set this.
//#define TRAIN_ZILLA_HOUND_COMBINER	1

#include "common.h"
#include "zilla.h"
#include "otter.h"
#include "jaws.h"
#include "sole.h"
#include "fugu.h"
#ifdef USE_OLD_DATABASES
#	include "crane.h"
#else
#	include	"hawk.h"
#endif
#include "bboxfeat.h"
#include "ttune.h"
#include "centipede.h"
#include "inkbox.h"
#include "score.h"
#include "vtune.h"
#include "lattice.h"

// Max alternates we can return for one character.
#define		MAX_ALTERNATES	20

// Flag to mark VRCRESULT as the full top one string.
#define		ALL_TOP_ONE		0xFFFF

// Structure to hold free input results.  Predeclare the VRC pointer
// since it froms a loop, we have to break it.
typedef struct tagVRC	*PVRC;
typedef struct tagVRCRESULT {
	PVRC		pVRC;			// We need the XRC object to get all top1.
	wchar_t		wch;			// Results charater, FFFF -> return all top1.
	short		iChar;			// The position of this alternate in the current path
} VRCRESULT;

// Struct to hold InkSet information.
typedef struct tagVINKSET {
	PVRC		pVRC;	// We need the XRC object to get all top1.
	UINT		iChar;	// Index of first char.
	UINT		cChar;	// Count of chars.
    UINT        cIntervals; // How many intervals in inkset
} VINKSET;

// Internal structure matching up to the HRC passed to most interface
// calls.  To avoid accidental confusion and problems with the 
// Tsunami name of XRC, it will be called VRC (for Volcano RC).
typedef struct tagVRC {
	// Status flags.
	BOOL			fBoxedInput;// Being called by boxed API.
	BOOL			fHaveInput;	// Have recieved at least one stroke.
	BOOL			fEndInput;	// End input has been called.
	BOOL			fBeginProcess; // If a process input call has been made (to disallow further config calls)

	// The lattice used to build up and process the ink.
	LATTICE			*pLattice;

	// The final results.
	LATTICE_PATH	*pLatticePath;
} VRC;

// Global data loaded by LoadCharRec.
extern LOCRUN_INFO		g_locRunInfo;

#ifdef __cplusplus
extern "C" {
#endif

// The language ("JPN", "KOR", "CHS", or "CHT") we are recognizing
extern wchar_t *g_szRecognizerLanguage;

// Other APIs and calls used by wispapis.c
BOOL SetHwxCorrectionContext(HRC hrc, wchar_t *wszBefore, wchar_t *wszAfter);
BOOL HwxUnconfig(BOOL bCanUnloadIFELang3);
BOOL SetHwxFlags(HRC hrc, DWORD dwFlags);
BOOL SetHwxFactoid(HRC hrc, wchar_t *wszFactoid);
BOOL IsWStringSupportedHRC(HRC hrc, wchar_t *pwcString);

// Factoid related functions private to the recognizer
BOOL FactoidTableConfig(LOCRUN_INFO *pLocRunInfo, wchar_t *wszRecognizerLanguage);
BOOL FactoidTableUnconfig();
BOOL SetFactoidDefaultInternal(LATTICE *pLattice);
BOOL SetFactoidInternal(LOCRUN_INFO *pLocRunInfo, LATTICE *pLattice, DWORD dwFactoid);
BOOL IsSupportedFactoid(DWORD dwFactoid);


// Stroke utils functions
POINT *DupPoints(POINT *pOldPoints, int nPoints);
GLYPH *GlyphFromStrokes(UINT cStrokes, STROKE *pStrokes);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\vtunefl.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/vtunefl.c
//
// Description:
//      Volcano tuning parameters, training and runtime code
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <stdio.h>
#include <float.h>
#include <stdlib.h>
#include "common.h"
#include "vtune.h"

// An array of names of the weights, for the tuning program
wchar_t *g_wszVTuneWeightNames[VTUNE_NUM_WEIGHTS] = 
{
    L"Circle",
    L"IJ",
    L"Unigram",
    L"CharShapeBoxUni",
    L"CharCrane",
    L"CharOtter",
    L"CharZilla",
    L"CharHound",
    L"StrShapeBoxUni",
    L"StrCrane",
    L"StrOtter",
    L"StrZilla",
    L"StrHound",
    L"StrShapeBoxBi",
    L"StrSUnigram",
    L"StrBigram",
    L"StrCBigram",
    L"FreeProb",
    L"FreeSUnigram",
    L"FreeBigram",
    L"FreeCBigram",
    L"FreeShapeUni",
    L"FreeShapeBi",
    L"FreeSegUni",
    L"FreeSegBi"
};

///////////////////////////////////////
//
// VTuneInit
//
//      Initialize the parameter database to a reasonable set of defaults
//      based on the previous volcano parameters.
//
// Parameters:
//      pTune: [out] Pointer to a parameter database to be initialized
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneInit(VOLCANO_PARAMS *pTune)
{
    int i;

    // Initialize the header
    pTune->dwFileType = VTUNE_FILE_TYPE;
    pTune->iFileVer = VTUNE_CUR_FILE_VERSION;
    pTune->iMinCodeVer = VTUNE_MIN_FILE_VERSION;

	// Untunable parameters, not enough data
	pTune->weights.afl[VTUNE_ADHOC_CIRCLE] = (float) 18;
	pTune->weights.afl[VTUNE_ADHOC_IJ] = (float) 5;

    // One fixed weight to get everything to scale well
	pTune->weights.afl[VTUNE_UNIGRAM] = (float) 1;

    // Initialize the weights for all the core recognizers.
    for (i = 0; i < VOLCANO_CONFIG_NUM_CORE_RECOGNIZERS; i++) 
    {
        pTune->weights.afl[VTUNE_CHAR_CORE + i] = (float) 1;
        pTune->weights.afl[VTUNE_STRING_CORE + i] = (float) 1;
    }

    // Character mode parameters
	pTune->weights.afl[VTUNE_CHAR_CRANE] = (float) 1;
	pTune->weights.afl[VTUNE_CHAR_CORE + VOLCANO_CONFIG_ZILLA] = (float) 9.469135;
	pTune->weights.afl[VTUNE_CHAR_SHAPE_BOX_UNIGRAM] = (float) 0.4;

	// String mode parameters
	pTune->weights.afl[VTUNE_STRING_CRANE] = (float) 1;
	pTune->weights.afl[VTUNE_STRING_CORE + VOLCANO_CONFIG_ZILLA] = (float) 9.469135;
	pTune->weights.afl[VTUNE_STRING_SHAPE_BOX_UNIGRAM] = (float) 0.4;
	pTune->weights.afl[VTUNE_STRING_SHAPE_BOX_BIGRAM] = (float) 0.0747;
	pTune->weights.afl[VTUNE_STRING_SMOOTHING_UNIGRAM] = (float) 0.455;
	pTune->weights.afl[VTUNE_STRING_BIGRAM] = (float) 0.0576;
	pTune->weights.afl[VTUNE_STRING_CLASS_BIGRAM] = (float) 0.0;

	// Free mode parameters
	pTune->weights.afl[VTUNE_FREE_SMOOTHING_UNIGRAM] = (float) 0.455;
	pTune->weights.afl[VTUNE_FREE_BIGRAM] = (float) 0.0576;
	pTune->weights.afl[VTUNE_FREE_CLASS_BIGRAM] = (float) 0.0;
	pTune->weights.afl[VTUNE_FREE_SEG_UNIGRAM] = (float) 0.227;
	pTune->weights.afl[VTUNE_FREE_SEG_BIGRAM] = (float) 0.227;
	pTune->weights.afl[VTUNE_FREE_SHAPE_UNIGRAM] = (float) 0.4;
	pTune->weights.afl[VTUNE_FREE_SHAPE_BIGRAM] = (float) 0.0747;
    pTune->weights.afl[VTUNE_FREE_PROB] = (float) 1.0;

    // The following five parameters are not tuned using the 
    // linear tuning algorithm so they are not placed in the array 
    // of weights.

    // Zilla geometric weighting
	pTune->flZillaGeo = (float) 1.333333;

    // IFELang3 weightings
    pTune->flStringHwxWeight = (float) (7000.0);
    pTune->flStringHwxThreshold = -FLT_MAX;
    pTune->flFreeHwxWeight = (float) (1250.0);
    pTune->flFreeHwxThreshold = -FLT_MAX;
}

///////////////////////////////////////
//
// VTuneWriteFile
//
//      Given a set of parameters and a file name, write out the database.
//
// Parameters:
//      pTune:       [in] The parameters to write out
//      wszFileName: [in] The file name to write to
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneWriteFile(VOLCANO_PARAMS *pTune, wchar_t *wszFileName)
{
	FILE *f = _wfopen(wszFileName, L"wb");

	if (f == NULL) 
    {
        return FALSE;
    }

	if (fwrite(pTune, sizeof(VOLCANO_PARAMS), 1, f) < 1) 
    {
		fclose(f);
		return FALSE;
	}

	if (fclose(f) < 0) 
    {
        return FALSE;
    }

	return TRUE;
}

///////////////////////////////////////
//
// VTuneLoadFileFromName
//
//      Given a pointer to a parameter structure and a file name, read
//      the parameter database in.
//
// Parameters:
//      pTune:       [out] Pointer to parameter structure to fill in
//      wszFileName: [in] File to read from
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneLoadFileFromName(VOLCANO_PARAMS *pTune, wchar_t *wszFileName)
{
	FILE *f = _wfopen(wszFileName, L"rb");

	if (f == NULL) return FALSE;

	if (fread(pTune, sizeof(VOLCANO_PARAMS), 1, f) < 1) 
    {
		fclose(f);
		return FALSE;
	}

	fclose(f);

    // Check the file version
    if (!VTuneCheckFileVersion(pTune))
    {
        return FALSE;
    }

	return TRUE;
}

///////////////////////////////////////
//
// VTuneLoadFile
//
//      Given a parameter information structure and a path,
//      map the database from a file called vtune.bin in that
//      directory and fill in the info structure.
//
// Parameters:
//      pInfo:   [out] Pointer to the parameter information structure to fill in.
//      wszPath: [in] Name of directory to map vtune.bin from
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneLoadFile(VOLCANO_PARAMS_INFO *pInfo, wchar_t *wszPath)
{
	wchar_t wszFile[_MAX_PATH];

	// Generate path to file.
	FormatPath(wszFile, wszPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"vtune.bin");

    pInfo->pTune = (VOLCANO_PARAMS *) DoOpenFile(&pInfo->info, wszFile);

    if (pInfo->pTune == NULL)
    {
        ASSERT(("Failed to map file for VTune database.\n", FALSE));
        return FALSE;
    }

    // Check the file version
    return VTuneCheckFileVersion(pInfo->pTune);
}

///////////////////////////////////////
//
// VTuneUnloadFile
//
//      Given a parameter information structure, close the mapping
//      from the file that holds the parameters.
//
// Parameters:
//      pInfo:   [in] Pointer to the parameter information structure to fill in.
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneUnloadFile(VOLCANO_PARAMS_INFO *pInfo)
{
    return DoCloseFile(&pInfo->info);
}

///////////////////////////////////////
//
// VTuneCompressTuningRecord
//
//      Given an array of scores from the various recognizer components,
//      write it out to a file in a compact form.  The compaction process
//      makes two assumptions, first that there are less than 32 components,
//      and second that many of the component scores will be zero.  The compact
//      form consists of a DWORD which is a bitmask of which components
//      have non-zero stores, followed by FLOATs giving those scores.
//
// Parameters:
//      f:     [in] File to write tuning information to
//      pTune: [in] Array of component scores to write out
//
// Return values:
//      TRUE on success, FALSE on write failure.
//
//////////////////////////////////////
BOOL VTuneCompressTuningRecord(FILE *f, VOLCANO_WEIGHTS *pTune)
{

#if VTUNE_NUM_WEIGHTS > 32
#error VTUNE_NUM_WEIGHTS must be not be more than 32
#endif

    int i;

    // Build the bitmask of non-zero scores
    DWORD fFlags = 0;
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        if (pTune->afl[i] != 0) 
        {
            fFlags |= (1 << i);
        }
    }

    // Write out the bitmask
    if (fwrite(&fFlags, sizeof(DWORD), 1, f) < 1)
    {
        return FALSE;
    }

    // Then write out the non-zero scores
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        if (pTune->afl[i] != 0) 
        {
            if (fwrite(pTune->afl + i, sizeof(FLOAT), 1, f) < 1)
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

///////////////////////////////////////
//
// VTuneDecompressTuningRecord
//
//      Given a compacted array of scores as produced by the VTuneCompressTuningRecord,
//      unpack it into a flat array for use by the tuning programs.
//
// Parameters:
//      pTune:   [out] Pointer to score array to fill in
//      pBuffer: [in] Pointer to the compacted record
//
// Return values:
//      Pointer to the next tuning record.
//
//////////////////////////////////////
DWORD *VTuneDecompressTuningRecord(VOLCANO_WEIGHTS *pTune, DWORD *pBuffer)
{
    int i;
    // Get the bitmask of non-zero scores
    DWORD fFlags = *(pBuffer++);

    // Initialize all the scores to zero
    VTuneZeroWeights(pTune);

    // Then run through all the non-zero scores and fill them in
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        if (fFlags & (1 << i)) 
        {
            pTune->afl[i] = *((FLOAT *)pBuffer);
            pBuffer++;
        }
    }
    return pBuffer;
}

///////////////////////////////////////
//
// VTuneAddScores
//
//      Add an array of scores to another array of scores
//
// Parameters:
//      pDest: [in/out] Array of scores where the result is stored.
//      pSrc:  [in] Array of scores to add to pDest.
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneAddScores(VOLCANO_WEIGHTS *pDest, VOLCANO_WEIGHTS *pSrc)
{
    int i;
    for (i = 0; i < VTUNE_NUM_WEIGHTS; i++)
    {
        pDest->afl[i] += pSrc->afl[i];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\chs\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\chs\sources.inc ===
TARGETNAME=mshwchs
TARGETTYPE=DYNLINK
TARGETEXT=dll

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\hwxchsi.def

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DCONFIG_SHIP_DESKTOP_I -DUSE_RESOURCES -DHWX_PRODUCT -DUSE_OLD_DATABASES -DUSE_IFELANG3

NTTARGETFILES=$(TARGETNAME).cpy

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\Wisp\public\sdk\inc; \

LINKLIBS= $(LINKLIBS) \
            $(_TPG_ROOT)\hwx\commonu\src\Win2KUnicode\$(O)\commonu.lib \
            $(_TPG_ROOT)\hwx\crane\src\Win2KUnicode\$(O)\crane.lib \
            $(_TPG_ROOT)\hwx\otter\src\Win2KUnicode\$(O)\otter.lib \
            $(_TPG_ROOT)\hwx\fugu\src\Win2KUnicode\$(O)\fugu.lib \
            $(_TPG_ROOT)\hwx\hound\src\Win2KUnicode\$(O)\hound.lib \
            $(_TPG_ROOT)\hwx\zilla\src\Win2KUnicode\$(O)\zilla.lib \
            $(_TPG_ROOT)\hwx\centipede\src\Win2KUnicode\$(O)\centipede.lib \
            $(_TPG_ROOT)\hwx\factoid\src\$(O)\factoid.lib \
            $(_TPG_ROOT)\hwx\tsunami\src\Win2KUnicode\$(O)\tsunami.lib \
            $(_TPG_ROOT)\hwx\volcano\dll\Win2KUnicode\$(O)\volcano.lib \
            $(_TPG_ROOT)\hwx\common\src\api\Win2KUnicode\$(O)\commonapi.lib
	    
TARGETLIBS=$(TARGETLIBS)\
            $(SDK_LIB_PATH)\oldnames.lib \
            $(SDK_LIB_PATH)\version.lib \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\gdi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\ole32.lib \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\uuid.lib \

SOURCES= \
         ..\mshwchs.rc \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\cht\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\jpn\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\cht\sources.inc ===
TARGETNAME=mshwcht
TARGETTYPE=DYNLINK
TARGETEXT=dll

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\hwxchti.def

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DCONFIG_SHIP_DESKTOP_I -DUSE_RESOURCES -DHWX_PRODUCT -DUSE_OLD_DATABASES -DUSE_IFELANG3

NTTARGETFILES=$(TARGETNAME).cpy

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\Wisp\public\sdk\inc; \

LINKLIBS= $(LINKLIBS) \
            $(_TPG_ROOT)\hwx\commonu\src\Win2KUnicode\$(O)\commonu.lib \
            $(_TPG_ROOT)\hwx\crane\src\Win2KUnicode\$(O)\crane.lib \
            $(_TPG_ROOT)\hwx\otter\src\Win2KUnicode\$(O)\otter.lib \
            $(_TPG_ROOT)\hwx\fugu\src\Win2KUnicode\$(O)\fugu.lib \
            $(_TPG_ROOT)\hwx\hound\src\Win2KUnicode\$(O)\hound.lib \
            $(_TPG_ROOT)\hwx\zilla\src\Win2KUnicode\$(O)\zilla.lib \
            $(_TPG_ROOT)\hwx\centipede\src\Win2KUnicode\$(O)\centipede.lib \
            $(_TPG_ROOT)\hwx\factoid\src\$(O)\factoid.lib \
            $(_TPG_ROOT)\hwx\tsunami\src\Win2KUnicode\$(O)\tsunami.lib \
            $(_TPG_ROOT)\hwx\volcano\dll\Win2KUnicode\$(O)\volcano.lib \
            $(_TPG_ROOT)\hwx\common\src\api\Win2KUnicode\$(O)\commonapi.lib
	    
TARGETLIBS=$(TARGETLIBS)\
            $(SDK_LIB_PATH)\oldnames.lib \
            $(SDK_LIB_PATH)\version.lib \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\gdi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\ole32.lib \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\uuid.lib \

SOURCES= \
         ..\mshwcht.rc \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\kor\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\jpn\sources.inc ===
TARGETNAME=mshwjpn
TARGETTYPE=DYNLINK
TARGETEXT=dll

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\hwxjpni.def

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DCONFIG_SHIP_DESKTOP_I -DUSE_RESOURCES -DHWX_PRODUCT -DUSE_OLD_DATABASES -DUSE_IFELANG3

NTTARGETFILES=$(TARGETNAME).cpy

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\Wisp\public\sdk\inc; \

LINKLIBS= $(LINKLIBS) \
            $(_TPG_ROOT)\hwx\commonu\src\Win2KUnicode\$(O)\commonu.lib \
            $(_TPG_ROOT)\hwx\crane\src\Win2KUnicode\$(O)\crane.lib \
            $(_TPG_ROOT)\hwx\otter\src\Win2KUnicode\$(O)\otter.lib \
            $(_TPG_ROOT)\hwx\fugu\src\Win2KUnicode\$(O)\fugu.lib \
            $(_TPG_ROOT)\hwx\hound\src\Win2KUnicode\$(O)\hound.lib \
            $(_TPG_ROOT)\hwx\zilla\src\Win2KUnicode\$(O)\zilla.lib \
            $(_TPG_ROOT)\hwx\centipede\src\Win2KUnicode\$(O)\centipede.lib \
            $(_TPG_ROOT)\hwx\factoid\src\$(O)\factoid.lib \
            $(_TPG_ROOT)\hwx\tsunami\src\Win2KUnicode\$(O)\tsunami.lib \
            $(_TPG_ROOT)\hwx\volcano\dll\Win2KUnicode\$(O)\volcano.lib \
            $(_TPG_ROOT)\hwx\common\src\api\Win2KUnicode\$(O)\commonapi.lib
	    
TARGETLIBS=$(TARGETLIBS)\
            $(SDK_LIB_PATH)\oldnames.lib \
            $(SDK_LIB_PATH)\version.lib \
            $(SDK_LIB_PATH)\gdi32.lib \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\ole32.lib \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\uuid.lib \

SOURCES= \
         ..\mshwjpn.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\dll\kor\sources.inc ===
TARGETNAME=mshwkor
TARGETTYPE=DYNLINK
TARGETEXT=dll

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\hwxkori.def

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DCONFIG_SHIP_DESKTOP_I -DUSE_RESOURCES -DHWX_PRODUCT -DUSE_OLD_DATABASES -DUSE_IFELANG3

NTTARGETFILES=$(TARGETNAME).cpy

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\wisp\public\sdk\inc; \
          $(_TPG_ROOT)\hwx\wisp\inc; \

LINKLIBS= $(LINKLIBS) \
            $(_TPG_ROOT)\hwx\commonu\src\Win2KUnicode\$(O)\commonu.lib \
            $(_TPG_ROOT)\hwx\crane\src\Win2KUnicode\$(O)\crane.lib \
            $(_TPG_ROOT)\hwx\otter\src\Win2KUnicode\$(O)\otter.lib \
            $(_TPG_ROOT)\hwx\fugu\src\Win2KUnicode\$(O)\fugu.lib \
            $(_TPG_ROOT)\hwx\hound\src\Win2KUnicode\$(O)\hound.lib \
            $(_TPG_ROOT)\hwx\zilla\src\Win2KUnicode\$(O)\zilla.lib \
            $(_TPG_ROOT)\hwx\centipede\src\Win2KUnicode\$(O)\centipede.lib \
            $(_TPG_ROOT)\hwx\factoid\src\$(O)\factoid.lib \
            $(_TPG_ROOT)\hwx\tsunami\src\Win2KUnicode\$(O)\tsunami.lib \
            $(_TPG_ROOT)\hwx\volcano\dll\Win2KUnicode\$(O)\volcano.lib \
            $(_TPG_ROOT)\hwx\common\src\api\Win2KUnicode\$(O)\commonapi.lib
	    
TARGETLIBS=$(TARGETLIBS) \
            $(SDK_LIB_PATH)\oldnames.lib \
            $(SDK_LIB_PATH)\version.lib \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\gdi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\ole32.lib \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\uuid.lib \

SOURCES= \
         ..\mshwkor.rc \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\lattice-bigram.h ===
#ifndef _LATTICE_BIGRAM_INCLUDED
#define _LATTICE_BIGRAM_INCLUDED

#include "imlang.h"

typedef struct	tag_LATTICE_BIGRAM_INFO
{
	DWORD dwBigram;
	DWORD dwPrevElement;
}	LATTICE_BIGRAM_INFO;

// {11858E48-DE9B-4fe8-BCC8-B35CC1B1E2F0}
DEFINE_GUID( GUID_LATTICE_BIGRAM_INFO_LIST, 0x11858e48, 0xde9b, 0x4fe8, 0xbc, 0xc8, 0xb3, 0x5c, 0xc1, 0xb1, 0xe2, 0xf0 );

typedef struct  tag_LATTICE_BIGRAM_INFO_LIST
{
	DWORD dwTotalBigrams;
	LATTICE_BIGRAM_INFO bigrams[1];
}	LATTICE_BIGRAM_INFO_LIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\probhack.h ===
// FILE: probhack.h

#define	MAX_PROB	((WORD)0xFFFF)
#define	ZERO_PROB	((WORD)0x0000)

#define		MAX_PROB_ENTRY	(128 * 1024)
#define		MAX_PROB_ALT	(1024 * 1024)

typedef struct tagPROB_ALT {
	wchar_t		wchAlt;
	WORD		prob;
} PROB_ALT;

typedef struct tagPROB_ENTRY {
	wchar_t		wch;
	WORD		cAlts;
} PROB_ENTRY;

typedef struct tagPROB_HEADER {
	DWORD	aEntryOffset[30];
	DWORD	aAltOffset[30];
} PROB_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\bboxfeat.h ===
#ifndef _BBOX_FEAT_INCLUDED
#define _BBOX_FEAT_INCLUDED

#include <windows.h>
#include "common.h"

// Bins for the various features
#define OverlapBins 1
//#define OverlapBins 2
#define RatioBins 11
#define StrokeBins 8
#define SpaceBins 1
//#define SpaceBins 5
#define ScoreBins 20
#define CodeRange 65536
#define MatchSpaceRange 64

// All unary feature bins should fall in the range 0<=bin<UnaryFeatureRange
#define UnaryFeatureRange (RatioBins*StrokeBins*SpaceBins)

// All binary feature bins should fall in the range 0<=bin<BinaryFeatureRange
#define BinaryFeatureRange (OverlapBins*RatioBins*StrokeBins*StrokeBins*RatioBins*SpaceBins)

// Maximum number of strokes per character
#define MaxStrokesPerCharacter 32

// Maximum number of strokes per character used by zilla
#define MaxZillaStrokesPerCharacter 29

// Log2 values for probabilities are clipped to the range Log2Range<=val<=0
#define Log2Range -32767

typedef struct tagSTROKE_SET_STATS {
	RECT rect;
	int space, area;
	int iBestPath;
	int iBestPathScore;
	int recogPenalty;
	FLOAT recogScore;
	wchar_t recogResult;
} STROKE_SET_STATS;

// Type to hold a log probability (which shouldn't get too big).  This should
// be a platform independent type, but I don't know what to use...
typedef int PROB;

typedef __int64 COUNTER;

typedef struct tagINTERVALS {
	int numIntervals;
	int minRange, maxRange;
	int min[MaxStrokesPerCharacter+1];
	int max[MaxStrokesPerCharacter+1];
} INTERVALS;

typedef struct tagBBOX_PROB_TABLE {
//	__int32 nOtterPrototypes;
//	__int32 nZillaPrototypes;
	__int16 unarySamples[UnaryFeatureRange];
	__int16 binarySamples[BinaryFeatureRange];
//	__int8 scorePrototype[1];
//	__int16 scoreSamples[MatchSpaceRange*ScoreBins];
//	__int16 aspectSamples[CodeRange*RatioBins];
} BBOX_PROB_TABLE;

#ifdef __cplusplus
extern "C" {
#endif

int AspectRatioToFeature(RECT r);
int ScoreToFeature(FLOAT score);
int MatchSpaceScoreToFeature(int nStrokes, FLOAT score, int matchSpace);

void EmptyIntervals(INTERVALS *intervals, int min, int max);
void ExpandIntervalsRange(INTERVALS *intervals, int min, int max);
void RemoveInterval(INTERVALS *intervals, int min, int max);
int TotalRange(INTERVALS *intervals);
int TotalPresent(INTERVALS *intervals);

PROB ClippedLog2(COUNTER num, COUNTER denom);

// Returns the unary feature bin of one range of the ink, from index iStart<=index<iEnd
// The returned bin should be in the range 0<=bin<UnaryFeatureRange
int ComputeUnaryFeatures(STROKE_SET_STATS *stats, int nStrokes);

// Returns the unary feature bin of one range of the ink, from index iStart1<=index<iStart2
// and iStart2<=index<iEnd
// The returned bin should be in the range 0<=bin<BinaryFeatureRange
int ComputeBinaryFeatures(STROKE_SET_STATS *stats1, STROKE_SET_STATS *stats2, int nStrokes1, int nStrokes2);

BBOX_PROB_TABLE *LoadBBoxProbTableFile(wchar_t *pRecogDir, LOAD_INFO *pInfo);
BOOL UnLoadBBoxProbTableFile(LOAD_INFO *pInfo);
BBOX_PROB_TABLE *LoadBBoxProbTableRes(HINSTANCE hInst, int nResID, int nType);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\charrec.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/dll/CharRec.h
//
// Description:
//	    Header for main sequencing of character shape recognizer.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#pragma once

// const defintions
#define	SYM_UNKNOWN				((SYM)0xFFFF)

// unicode value for space
#define	SYM_SPACE				0x0020

// stroke ID corresponding to a space character
#define	SPACE_ALT_ID			-2

// ratio of avg char hgt above which a gap is considered a space
#define SPACE_RATIO				0.75


////
//// Data structures
////

// Settings used to configure recognizer as it is being run.
typedef struct tagRECOG_SETTINGS {
	ALC		alcValid;		// Characters to recognize.
	ALC		alcPriority;	// Characters to prioritize.
	UINT	partialMode;	// Which partial mode are we in.
	UINT	*pAbort;        // Abort address used by partial processing modes.
    BYTE    *pbAllowedChars; // Bitmask representing which (folded) dense codes are allowed.
    BYTE    *pbPriorityChars;// Bitmask representing which (folded) dense codes are preferred.
} RECOG_SETTINGS;

// A single stroke of ink.
typedef struct tagSTROKE {
	int		nInk;		// How many points in this stroke
	int		iBox;		// The box containing this stroke
	int		iOrder;		// The index of the first real stroke in this (merged) stroke
	int		iLast;		// The index of the last real stroke in this (merged) stroke
	DWORD	timeStart, timeEnd;		// Range of time indices in this stroke
	RECT	bbox;		// Bounding box of stroke
	POINT	*pts;		// Array of points in the stroke
} STROKE;

// An alternate returned from the shape recognizer.
typedef struct tagRECOG_ALT {
	wchar_t		wch;
	float		prob;
} RECOG_ALT;

// Build a copy of the glyph structure.
GLYPH *CopyGlyph(GLYPH *pOldGlyph);

////
//// Functions
////

//  Load and initialize the databases used.
#ifdef USE_RESOURCES
	extern BOOL		LoadCharRec(HINSTANCE hInstanceDll);
#else
	extern BOOL		LoadCharRec(wchar_t	*pPath);
#endif

// Unload the databases used.
extern BOOL		UnloadCharRec();

// Do shape matching.
extern INT		RecognizeChar(
	RECOG_SETTINGS	*pRecogSettings,// Setting for recognizers.
	UINT			cStrokes,		// Number of strokes to process.
	UINT			cRealStrokes,	// Number of strokes before merging
	STROKE			*pStrokes,		// Array of strokes to process.
	FLOAT			*pProbIsChar,	// Out: probability of being valid char.
	UINT			maxAlts,		// Size of alts array supplied.
	RECOG_ALT		*pAlts,			// Out: alternate list matched.
	RECT			*pGuideBox,		// Guide box for this ink.
	int				*pCount			// Matching space for otter or zilla
);

// Do shape matching.
INT RecognizeCharInsurance(
	RECOG_SETTINGS	*pRecogSettings,// Setting for recognizers.
	UINT			cStrokes,		// Number of strokes to process.
	UINT			cRealStrokes,	// Number of strokes before merging
	STROKE			*pStrokes,		// Array of strokes to process.
	FLOAT			*pProbIsChar,	// Out: probability of being valid char.
	UINT			maxAlts,		// Size of alts array supplied.
	RECOG_ALT		*pProbAlts,		// Out: alternate list by probs.
	int				*pnProbAlts,
	RECOG_ALT		*pScoreAlts,	// Out: alternate list by scores
	int				*pnScoreAlts,
	RECT			*pGuideBox,		// Guide box for this ink.
	wchar_t			dchContext,		// Context (dense code, SYM_UNKNOWN=none)
	int				*pCount,		// Matching space for otter or zilla
	VOLCANO_WEIGHTS	*pTuneScore,	// Component scores for score alternates
    BOOL            fStringMode,    // Whether to use string mode weightings
    BOOL            fProbMode,      // Whether we are in prob mode
    void            *pvCache,       // Recognizer cache, or NULL for unused
    int             iStroke         // Index of last stroke of character
);

// Call the core recognizer for the given character.  Returned the 
// number of alternates produced, or -1 if an error occurs.
int CoreRecognizeChar(
    ALT_LIST *pAltList,		        // Alt list to be returned
	int cAlt,						// Max number of alternates
	GLYPH **ppGlyph,				// Character to recognize (which may be modified)
	int nRealStrokes,				// Real stroke count for abort processing
	RECT *pGuideBox,				// Guide box (for partial mode)
	RECOG_SETTINGS *pRecogSettings,	// partial mode, other settings
    CHARSET *pCharSet,              // ALCs
	int *piRecognizer,				// Returns the VOLCANO_CONFIG_* constant for the recognizer used
	int *piSpace);					// The space number in that recognizer

// Initialize the recognizer partially.
// When iLevel is set to 0, only the locale database, tuning database, 
// otter and zilla (and other core recognizers) are loaded. 
// When iLevel is set to 1, all the above databases are loaded, as well as 
// unigrams and crane/hawk.
BOOL HwxConfigExPartial(wchar_t *pLocale, wchar_t *pRecogDir, int iLevel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\vtune.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/inc/vtune.h
//
// Description:
//      Volcano tuning parameters
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#pragma once

#include <wtypes.h>
#include "common.h"

// These constants are used to configure which recognizer is used at
// which stroke counts.  They are also used as indices into a lookup
// table for the weight to give to the score from each recognizer.
// Configuration for the recognizer
#define VOLCANO_CONFIG_NONE -1
#define VOLCANO_CONFIG_OTTER 0
#define VOLCANO_CONFIG_ZILLA 1
#define VOLCANO_CONFIG_HOUND 2

// How many recognizers are defined above.
#define VOLCANO_CONFIG_NUM_CORE_RECOGNIZERS 3

// The maximum stroke count which needs to be configured
#define VOLCANO_CONFIG_MAX_STROKE_COUNT 29

// Recognizer configuration
typedef struct tagVOLCANO_CONFIG 
{
    // Which recognizer to use fo reach number of strokes
    int iRecognizers[VOLCANO_CONFIG_MAX_STROKE_COUNT + 1];
} VOLCANO_CONFIG;

// These values are used as indices into the array of 
// weights for scores from different recognizer components.

// The first three are global weights for all recognizer modes
// The following two don't actually get tuned because there isn't enough data.
#define VTUNE_ADHOC_CIRCLE              (0)
#define VTUNE_ADHOC_IJ                  (VTUNE_ADHOC_CIRCLE + 1)
#define VTUNE_UNIGRAM                   (VTUNE_ADHOC_IJ + 1)

// These parameters are used only in character mode
#define VTUNE_CHAR_SHAPE_BOX_UNIGRAM    (VTUNE_UNIGRAM + 1)
#define VTUNE_CHAR_CRANE                (VTUNE_CHAR_SHAPE_BOX_UNIGRAM + 1)
#define VTUNE_CHAR_CORE                 (VTUNE_CHAR_CRANE + 1)

// These are used in string mode
#define VTUNE_STRING_SHAPE_BOX_UNIGRAM  (VTUNE_CHAR_CORE + VOLCANO_CONFIG_NUM_CORE_RECOGNIZERS)
#define VTUNE_STRING_CRANE              (VTUNE_STRING_SHAPE_BOX_UNIGRAM + 1)
#define VTUNE_STRING_CORE               (VTUNE_STRING_CRANE + 1)
#define VTUNE_STRING_SHAPE_BOX_BIGRAM   (VTUNE_STRING_CORE + VOLCANO_CONFIG_NUM_CORE_RECOGNIZERS)
#define VTUNE_STRING_SMOOTHING_UNIGRAM  (VTUNE_STRING_SHAPE_BOX_BIGRAM + 1)
#define VTUNE_STRING_BIGRAM             (VTUNE_STRING_SMOOTHING_UNIGRAM + 1)
#define VTUNE_STRING_CLASS_BIGRAM       (VTUNE_STRING_BIGRAM + 1)

// These are used in free input mode
#define VTUNE_FREE_PROB                 (VTUNE_STRING_CLASS_BIGRAM + 1)
#define VTUNE_FREE_SMOOTHING_UNIGRAM    (VTUNE_FREE_PROB + 1)
#define VTUNE_FREE_BIGRAM               (VTUNE_FREE_SMOOTHING_UNIGRAM + 1)
#define VTUNE_FREE_CLASS_BIGRAM         (VTUNE_FREE_BIGRAM + 1)
#define VTUNE_FREE_SHAPE_UNIGRAM        (VTUNE_FREE_CLASS_BIGRAM + 1)
#define VTUNE_FREE_SHAPE_BIGRAM         (VTUNE_FREE_SHAPE_UNIGRAM + 1)
#define VTUNE_FREE_SEG_UNIGRAM          (VTUNE_FREE_SHAPE_BIGRAM + 1)
#define VTUNE_FREE_SEG_BIGRAM           (VTUNE_FREE_SEG_UNIGRAM + 1)

// Total number of weights
#define VTUNE_NUM_WEIGHTS (VTUNE_FREE_SEG_BIGRAM + 1)

// Hold the weights for various recognizer components.
// It is also used to hold the individual scores from each component when doing
// the tuning, so as to keep the weights and scores in one-to-one correpsondence.
typedef struct VOLCANO_WEIGHTS
{
    FLOAT afl[VTUNE_NUM_WEIGHTS];
} VOLCANO_WEIGHTS;

// An array of names of the weights, for the tuning program
extern wchar_t *g_wszVTuneWeightNames[VTUNE_NUM_WEIGHTS];

// Magic key the identifies the tuning database files
#define	VTUNE_FILE_TYPE 0x19980808

// Version information for file.
#define	VTUNE_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	VTUNE_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define VTUNE_CUR_FILE_VERSION		0		// Current version of code.

// In addition to holding the weights, this holds other parameters which are 
// not tuned by the normal linear tuning algorithm, because they have a
// non-linear relationship with the scores.
typedef struct VOLCANO_PARAMS
{
	DWORD		dwFileType;			        // This should always be set to VTUNE_FILE_TYPE.
	INT 		iFileVer;			        // Version of code that wrote the file.
	INT 		iMinCodeVer;			    // Earliest version of code that can read this file

    VOLCANO_WEIGHTS weights;                // Weights for components
    FLOAT flZillaGeo;                       // Zilla geometrics weight (untuned for now)
    FLOAT flStringHwxWeight;                // Weight of hwx scores for IFELang3 in string mode
    FLOAT flStringHwxThreshold;             // Threshold for hwx scores for IFELang3 in string mode
    FLOAT flFreeHwxWeight;                  // Weight of hwx scores for IFELang3 in free mode
    FLOAT flFreeHwxThreshold;               // Threshold for hwx scores for IFELang3 in free mode
} VOLCANO_PARAMS;

// This structure holds the pointer to the loaded tuning database
// as well as information for unloading the database later.
typedef struct VOLCANO_PARAMS_INFO 
{
    VOLCANO_PARAMS *pTune;
    LOAD_INFO info;
} VOLCANO_PARAMS_INFO;

// Functions for loading and unloading the database

///////////////////////////////////////
//
// VTuneLoadFile
//
//      Given a parameter information structure and a path,
//      map the database from a file called vtune.bin in that
//      directory and fill in the info structure.
//
// Parameters:
//      pInfo:   [out] Pointer to the parameter information structure to fill in.
//      wszPath: [in] Name of directory to map vtune.bin from
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneLoadFile(VOLCANO_PARAMS_INFO *pInfo, wchar_t *wszPath);

///////////////////////////////////////
//
// VTuneUnloadFile
//
//      Given a parameter information structure, close the mapping
//      from the file that holds the parameters.
//
// Parameters:
//      pInfo:   [in] Pointer to the parameter information structure to fill in.
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneUnloadFile(VOLCANO_PARAMS_INFO *pInfo);

///////////////////////////////////////
//
// VTuneLoadRes
//
//      Map a resource as the tuning parameter database
//
// Parameters:
//      pInfo:  [out] Pointer to the database structure to fill in
//      hInst:  [in] DLL to locate the resource in
//      nResID: [in] Resource ID
//      nType:  [in] Resource type
//
// Return values:
//      TRUE if the mapping succeeds, FALSE if the mapping fails.
//
//////////////////////////////////////
BOOL VTuneLoadRes(VOLCANO_PARAMS_INFO *pInfo, HINSTANCE hInst, int nResID, int nType);

// Functions used at runtime 

///////////////////////////////////////
//
// VTuneInit
//
//      Initialize the parameter database to a reasonable set of defaults
//      based on the previous volcano parameters.
//
// Parameters:
//      pTune: [out] Pointer to a parameter database to be initialized
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneInit(VOLCANO_PARAMS *pTune);

///////////////////////////////////////
//
// VTuneWriteFile
//
//      Given a set of parameters and a file name, write out the database.
//
// Parameters:
//      pTune:       [in] The parameters to write out
//      wszFileName: [in] The file name to write to
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneWriteFile(VOLCANO_PARAMS *pTune, wchar_t *wszFileName);

///////////////////////////////////////
//
// VTuneZeroWeights
//
//      Zero out an array of weights on scores
//
// Parameters:
//      pWeights: [out] Pointer to a weights array
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneZeroWeights(VOLCANO_WEIGHTS *pWeights);

///////////////////////////////////////
//
// VTuneComputeScore
//
//      Compute the weighted sum of the scores and return the result
//
// Parameters:
//      pWeights: [in] Pointer to a weights array
//      pScores:  [in] Pointer to a scores array
//
// Return values:
//      Weighted sum of the scores.
//
//////////////////////////////////////
float VTuneComputeScore(VOLCANO_WEIGHTS *pWeights, VOLCANO_WEIGHTS *pScores);

///////////////////////////////////////
//
// VTuneComputeScoreNoLM
//
//      Compute the weighted sum of the scores and return the result.
//      Unlike VTuneComputeScore, this version does not add in the 
//      components of the score related to the language model.
//
// Parameters:
//      pWeights: [in] Pointer to a weights array
//      pScores:  [in] Pointer to a scores array
//
// Return values:
//      Weighted sum of the scores.
//
//////////////////////////////////////
float VTuneComputeScoreNoLM(VOLCANO_WEIGHTS *pWeights, VOLCANO_WEIGHTS *pScores);

///////////////////////////////////////
//
// VTuneAddScores
//
//      Add an array of scores to another array of scores
//
// Parameters:
//      pDest: [in/out] Array of scores where the result is stored.
//      pSrc:  [in] Array of scores to add to pDest.
//
// Return values:
//      None.
//
//////////////////////////////////////
void VTuneAddScores(VOLCANO_WEIGHTS *pDest, VOLCANO_WEIGHTS *pSrc);

// Functions used at train time

///////////////////////////////////////
//
// VTuneLoadFileFromName
//
//      Given a pointer to a parameter structure and a file name, read
//      the parameter database in.
//
// Parameters:
//      pTune:       [out] Pointer to parameter structure to fill in
//      wszFileName: [in] File to read from
//
// Return values:
//      TRUE on success, FALSE on failure.
//
//////////////////////////////////////
BOOL VTuneLoadFileFromName(VOLCANO_PARAMS *pTune, wchar_t *wszFileName);

///////////////////////////////////////
//
// VTuneCheckFileVersion
//
//      Check the file header and version information in a tuning database
//
// Parameters:
//      pTune: [in] Tuning database to check
//
// Return values:
//      TRUE if file version is okay, FALSE otherwise
//
//////////////////////////////////////
BOOL VTuneCheckFileVersion(VOLCANO_PARAMS *pTune);

///////////////////////////////////////
//
// VTuneCompressTuningRecord
//
//      Given an array of scores from the various recognizer components,
//      write it out to a file in a compact form.  The compaction process
//      makes two assumptions, first that there are less than 32 components,
//      and second that many of the component scores will be zero.  The compact
//      form consists of a DWORD which is a bitmask of which components
//      have non-zero stores, followed by FLOATs giving those scores.
//
// Parameters:
//      f:     [in] File to write tuning information to
//      pTune: [in] Array of component scores to write out
//
// Return values:
//      TRUE on success, FALSE on write failure.
//
//////////////////////////////////////
BOOL VTuneCompressTuningRecord(FILE *f, VOLCANO_WEIGHTS *pTune);

///////////////////////////////////////
//
// VTuneDecompressTuningRecord
//
//      Given a compacted array of scores as produced by the VTuneCompressTuningRecord,
//      unpack it into a flat array for use by the tuning programs.
//
// Parameters:
//      pTune:   [out] Pointer to score array to fill in
//      pBuffer: [in] Pointer to the compacted record
//
// Return values:
//      Pointer to the next tuning record.
//
//////////////////////////////////////
DWORD *VTuneDecompressTuningRecord(VOLCANO_WEIGHTS *pTune, DWORD *pBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\volcano\inc\lattice.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      volcano/inc/lattice.h
//
// Description:
//	    Holds the internal structures related to the lattice for Volcano,
//      as well as the functions used to manipulate the lattice.
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#pragma once

// Uncomment this (or put it in the project settings) to enable tuning code.
// The tuning code writes out data to the file c:\tune.log when the SearchForTargetResult()
// API function is called, saving the components of the score for the best path and all
// alternate paths through the lattice.  This allows a simple program to adjust the linear
// weightings of these components to maximize the number of times the correct path is chosen.
//#define HWX_TUNE

//#define USE_IFELANG3_BIGRAMS

#include <windows.h>

#include "vtune.h"
#include "charrec.h"

#ifdef __cplusplus
extern "C" {
#endif

// References to the various databases that get loaded
// Eventually this stuff, along with a few other globals, should 
// be placed in a structure so we can have multiple languages 
// active at once.
extern BBOX_PROB_TABLE *g_pProbTable;
extern UNIGRAM_INFO g_unigramInfo;
extern BIGRAM_INFO g_bigramInfo;
extern CLASS_BIGRAM_INFO g_classBigramInfo;
extern TTUNE_INFO g_ttuneInfo;
extern wchar_t g_pLocale[16];
extern wchar_t g_pLocaleDir[1024];
extern wchar_t g_pRecogDir[1024];
extern HINSTANCE g_hDLL;
extern CENTIPEDE_INFO g_centipedeInfo;
extern VOLCANO_PARAMS_INFO g_vtuneInfo;         // Tuning parameters
extern VOLCANO_CONFIG g_latticeConfigInfo;      // Configuration data
extern JAWS_LOAD_INFO g_JawsLoadInfo;
extern FUGU_LOAD_INFO g_FuguLoadInfo;
extern SOLE_LOAD_INFO g_SoleLoadInfo;
extern BOOL g_fUseJaws;
extern BOOL g_fUseZillaHound;

// Initialize the configuration info
void LatticeConfigInit();

/////////////////////////////////////////////////////////////////////////////////////
// References to legacy baseline/height and language model, currently in lattice.c //
/////////////////////////////////////////////////////////////////////////////////////
typedef struct tagBOXINFO
{
    int   size;     // Absolute size.
    int   xheight;  // Absolute height to midline.
    int   baseline; // Baseline in tablet coordinates.
    int   midline;  // Midline in tablet coordinates.
} BOXINFO;

FLOAT BaselineTransitionCost(SYM symPrev, RECT rPrev, BOXINFO *biPrev, SYM sym, RECT r, BOXINFO *bi);
FLOAT HeightTransitionCost(SYM symPrev, RECT rPrev, BOXINFO *biPrev, SYM sym, RECT r, BOXINFO *bi);
FLOAT HeightBoxCost(SYM sym, RECT r, BOXINFO *bi);
FLOAT BaselineBoxCost(SYM sym, RECT r, BOXINFO *bi);

////////////////////////////
// Public data structures //
////////////////////////////

typedef struct tagLATTICE_PATH_ELEMENT {
	wchar_t wChar;                // Unicode character
	int		iStroke, iAlt;        // Information to look up the character in the lattice
	int		nStrokes, iBoxNum;    // Box number
	// FLOAT score;				  // Raw zilla/otter score
	// RECT bbox;                 // Bounding box of the character
} LATTICE_PATH_ELEMENT;

// This structure is returned by GetCurrentPath.
typedef struct tagLATTICE_PATH {
	int						nChars;			          // Number of character in current path
	LATTICE_PATH_ELEMENT	*pElem;  // The characters themselves
} LATTICE_PATH;

//////////////////////////////////////////////////////////////////////////
// Data structures, which are for the most part internal to the module. //
//////////////////////////////////////////////////////////////////////////

typedef struct tagLATTICE LATTICE;

#define MinLogProb Log2Range
#define MaxStrokesPerCharacter 32
#define MaxAltsPerStroke 20

//#define	SCALE_FOR_IFELANG3	-1024
//#define SCALE_FOR_IFELANG3 -10000
#define SCALE_FOR_IFELANG3 (-1024.0*log(2.0))

// Cache entry for recognition results
typedef struct CACHE_ENTRY 
{
    int nStrokes;           // Number of strokes for this character
    int iRecognizer;        // Which recognizer gave an answer
    ALT_LIST alts;          // The results
    struct CACHE_ENTRY *pNext;     // Pointer to the next cache entry
} CACHE_ENTRY;

// Cache for recognition results
typedef struct CACHE 
{
    int nStrokes;           // How many strokes we have allocated space for
    CACHE_ENTRY **pStrokes; // Pointers to the cache entries for each stroke
} CACHE;

void *AllocateRecognizerCache();
void FreeRecognizerCache(void *pvCache);
ALT_LIST *LookupRecognizerCache(void *pvCache, int iStroke, int nStrokes, int *piRecognizer);
void AddRecognizerCache(void *pvCache, int iStroke, int nStrokes, int iRecognizer, ALT_LIST *pAlts);

typedef struct tagLATTICE_ELEMENT {
	BOOL fUsed;                             // Whether this alternate is in use
	float logProb;                          // Score for just this alternate, without language model
	float logProbPath;                      // Score for path to this point, including language model
	int	iCharDetectorScore;					// score coming from char detector
	int iPathLength;	                    // How many characters are on the best path to this element
	int nStrokes;                           // Number of strokes in this character
	int iPrevAlt;                           // Index of previous character in the appropriate column
    int nPrevStrokes;                       // Number of strokes in the previous character
	wchar_t wChar;                          // Dense code of this character
    wchar_t wPrevChar;                      // Dense code of previous character
	RECT bbox;                              // Bounds of the ink
    RECT writingBox;                        // Estimated writing box
	int space;  
    int area;                               
	BOOL fCurrentPath;                      // Whether this alternate is on the best path
	FLOAT score;                            
	int maxDist;                            
	int nHits;			                    // How many times this element has occurred on paths
    int iPromptPtr;                         // How far along we are in the prompt string.
                                            // Eventually this field could represent the current state
                                            // of the DFA implementing a factoid.
#ifdef USE_IFELANG3_BIGRAMS
	int indexIFELang3;
	int nBigrams;
	float bigramLogProbs[MaxAltsPerStroke]; 
	int bigramAlts[MaxAltsPerStroke];
#endif
#ifdef HWX_TUNE
	VOLCANO_WEIGHTS tuneScores;             // Store the components of the score for this alternate
#endif
} LATTICE_ELEMENT;

typedef struct tagLATTICE_ALT_LIST {
	int				iBrkNetScore;			// is this a hard break point
	BOOL			fSpaceAfterStroke;		// is there a hard space after this stroke
	int				nUsed;                  // Number of alternates used in this column
	LATTICE_ELEMENT alts[MaxAltsPerStroke]; // Column of alternates
} LATTICE_ALT_LIST;

typedef struct tagSCORES_ALT_LIST {
	VOLCANO_WEIGHTS alts[MaxAltsPerStroke];
} SCORES_ALT_LIST;

typedef struct tagLATTICE {
	RECOG_SETTINGS recogSettings;	// Other settings (ALCs, abort flag)
    BOOL fWordMode;         // "Word" mode, in which free mode treats all the ink as one char
    BOOL fCoerceMode;       // ALCPriority -> ALCValid
    BOOL fSingleSeg;        // Return only a single segmentation
    BOOL fUseFactoid;       // Whether to use factoid settings or not
    ALC alcFactoid;         // ALC from factoid settings
    BYTE *pbFactoidChars;   // Bitmask of chars from factoid
    BOOL fSepMode;          // "Separate" mode, disables language model
    wchar_t *wszAnswer;     // Used during tuning and training, to tell the recognizer in advance 
                            // what the correct answer is.  Also used by separator
	BOOL fUseGuide;			// Whether or not to use the guide
	HWXGUIDE guide;			// The guide
    int nStrokes;			// How many strokes (after merging) are in the pStroke array
	int nStrokesAllocated;	// How much space is allocated in the pStroke array
	int nRealStrokes;		// How many strokes have been added to the lattice (before merging)
    STROKE *pStroke;		// The array of strokes
	LATTICE_ALT_LIST *pAltList;		// Array of lattice columns
    wchar_t *wszBefore;     // Pre-context (in reverse order, the first character is the one just before the ink)
    wchar_t *wszAfter;      // Post-context (in normal order, the first character is the one just after the ink)
	BOOL fProbMode;			// Whether the score associated with alt is a log prob or a score
	BOOL fUseIFELang3;		// Whether to use IFELang3 (available, and enough characters to be useful)
	int nProcessed;			// How many strokes have been processed so far
	BOOL fEndInput;			// Whether we have reached the end of the input
	BOOL fIncremental;		// Whether we're doing processing incrementally
	int nFixedResult;		// The number of strokes for which results have already been returned, and
							// whose interpretation cannot change.
    void *pvCache;          // Cache for recognition results, or NULL if unused
    BOOL fUseLM;            // Whether to use the language model
} LATTICE;

#ifdef HWX_TUNE
extern FILE *g_pTuneFile;
extern int g_iTuneMode;
#endif

///////////////////
// API Functions //
///////////////////

// Get the number of strokes which have been added to the lattice
int GetLatticeStrokeCount(LATTICE *lat);

// Create an empty lattice data structure.  Returns NULL if it fails to allocate memory.
LATTICE *AllocateLattice();

// Create a new lattice with the same settings as the given lattice.
LATTICE *CreateCompatibleLattice(LATTICE *lat);

// Set the ALC values for the underlying boxed recognizer
void SetLatticeALCValid(LATTICE *lat, ALC alcValid);
void SetLatticeALCPriority(LATTICE *lat, ALC alcPriority);

// Set the guide for the lattice (which will switch things to boxed mode)
void SetLatticeGuide(LATTICE *lat, HWXGUIDE *pGuide);

// Destroy lattice data structure.
void FreeLattice(LATTICE *lat);

// Add a stroke to the lattice, returns TRUE if it succeeds.
BOOL AddStrokeToLattice(LATTICE *lat, int nInk, POINT *pts, DWORD time);

// Update the probabilities in the lattice, including setting current
// path to the most likely path so far (not including language model).
// Can be called repeatedly for incremental processing after each stroke.
BOOL ProcessLattice(LATTICE *lat, BOOL fEndInput);

BOOL ProcessLatticeRange(LATTICE *lat, int iStrtStroke, int iEndStroke);

// Return the current path in a LATTICE_PATH structure, which contains
// arrays of the bounding boxes for each character, the stroke counts,
// and the characters themselves.
// When called after ProcessLattice, returns the highest probability path.
// The memory for the path should be freed by the caller.
BOOL GetCurrentPath(LATTICE *lat, LATTICE_PATH **pPath);

// Free a LATTICE_PATH structure returned by GetCurrentPath()
void FreeLatticePath(LATTICE_PATH *path);

// Given a lattice and a path through it, for characters iStartChar through iEndChar
// inclusive, return the time stamps of the first and last strokes in those characters.
// Returns FALSE if there are no strokes associated with the characters (eg, spaces)
BOOL GetCharacterTimeRange(LATTICE *lat, LATTICE_PATH *path, int iStartChar, int iEndChar,
						   DWORD *piStartTime, DWORD *piEndTime);

// Given a character number in the current path (counting from zero), 
// and the number of alternates to return, it returns alternates for
// the character which contain the same number of strokes.  This means
// alternate segmentations cannot be returned.  The number of alternates
// actually stored in the array are returned.
int GetAlternatesForCharacterInCurrentPath(LATTICE *lat, LATTICE_PATH *path, int iChar, int nAlts, wchar_t *pwAlts);

// Apply language model to produce a better current path.  Currently only
// runs IFELang3 if available, and asserts otherwise.  This will be changed
// to use the existing unigram/bigram stuff later.
void ApplyLanguageModel(LATTICE *lat, wchar_t *wszCorrectAnswer);

// Load some global tables (the locale table, unigrams, bigrams, and class bigrams)
// The tables needed by the segmenter are not loaded until needed, this will 
// probably change later.  The path is the same format as taken by the file loading 
// functions.  This interface will probably change when I read the code in hwx.c
// to see how it should be done. :)
BOOL LatticeConfigFile(wchar_t *pRecogDir);

// Unload any global tables loaded earlier by LatticeConfig
BOOL LatticeUnconfigFile();

// Load some global tables (the locale table, unigrams, bigrams, and class bigrams)
// The tables needed by the segmenter are not loaded until needed, this will 
// probably change later.  The path is the same format as taken by the file loading 
// functions.  This interface will probably change when I read the code in hwx.c
// to see how it should be done. :)
BOOL LatticeConfig(HINSTANCE hInst);

// Unload any global tables loaded earlier by LatticeConfig
BOOL LatticeUnconfig();

BOOL GetBoxOfAlternateInCurrentPath(LATTICE *pLattice, LATTICE_PATH *path, int iChar, RECT *pRect);

///////////////
// Call flow //
///////////////

// 0. LatticeConfig
// 1. AllocateLattice
// 2. For each stroke
//    a. AddStrokeToLattice
//    b. ProcessLattice (this is optional, for incremental processing)
//    c. GetCurrentPath (this is optional, for incremental results)
// 3. ProcessLattice
// 4. ApplyLanguageModel (optional, probably not useful at the moment)
// 5. GetCurrentPath
// 6. GetAlternatesForCharacterInCurrentPath
// 7. FreeLatticePath
// 8. FreeLattice
// 9. LatticeUnconfig

int SearchForTargetResultInternal(LATTICE *lat, wchar_t *wsz);

RECT GetAlternateBbox(LATTICE *lat, int iStroke, int iAlt);
FLOAT GetAlternateRecogScore(LATTICE *lat, int iStroke, int iAlt);
FLOAT GetAlternateScore(LATTICE *lat, int iStroke, int iAlt);
FLOAT GetAlternatePathScore(LATTICE *lat, int iStroke, int iAlt);
int GetAlternateStrokes(LATTICE *lat, int iStroke, int iAlt);
wchar_t GetAlternateChar(LATTICE *lat, int iStroke, int iAlt);

/////////////////////
// Internal stuff. //
/////////////////////

void BuildStrokeCountRecogAlts(LATTICE *lat, int iStroke, int cStrk);
int FindFullPath(LATTICE *lat);
void ClearAltList(LATTICE_ALT_LIST *list);
void FixupBackPointers (LATTICE *pLat);

BOOL LatticeConfigIFELang3();
BOOL LatticeIFELang3Available();
BOOL LatticeUnconfigIFELang3();

// Flags used to check for valid paths in lattice.
#define	LCF_UNKNOWN		0
#define	LCF_INVALID		1
#define	LCF_VALID		2

// Figure out which strokes are valid end of character in paths that span the
// whole lattice.
BOOL CheckIfValid(LATTICE *lat, int iStartStroke, int iStroke, BYTE *pValidEnd);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\wisp\inc\rectypes.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rectypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rectypes_h__
#define __rectypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rectypes_0000 */
/* [local] */ 

//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      rectypes.h
//
//--------------------------------------------------------------------------
#include "RecDefs.h"
#define SAFE_PARTIAL 1
#define BEST_COMPLETE 2
#define MAX_VENDORNAME 32
#define MAX_FRIENDLYNAME 64
#define MAX_LANGUAGES 64
#define CAC_FULL 0
#define CAC_PREFIX 1
#define CAC_RANDOM 2
#define ASYNC_RECO_INTERRUPTED 0x1  //when the process is interrupted
#define ASYNC_RECO_PROCESS_FAILED 0x2
#define ASYNC_RECO_ADDSTROKE_FAILED 0x4
#define ASYNC_RECO_SETCACMODE_FAILED 0x8
#define ASYNC_RECO_RESETCONTEXT_FAILED 0x10
#define ASYNC_RECO_SETGUIDE_FAILED 0x20
#define ASYNC_RECO_SETFLAGS_FAILED 0x40
#define ASYNC_RECO_SETFACTOID_FAILED 0x80
#define ASYNC_RECO_SETTEXTCONTEXT_FAILED 0x100
#define ASYNC_RECO_SETWORDLIST_FAILED 0x200
#define RF_DONTCARE		1// overrides all other ones if set
#define RF_OBJECT		2	// if not set, this is a text recognizer
#define RF_FREE_INPUT	4	// supports free input
#define RF_LINED_INPUT	8	// supports simple guide structure with lines only
#define RF_BOXED_INPUT	16	// supports boxed (guided) input
#define RF_CAC_INPUT	32	// supports boxed Character Auto Completion 	
#define RF_RIGHT_AND_DOWN	64// used in western and FE languages
#define RF_LEFT_AND_DOWN	128// used in Hebrew and Arabic
#define RF_DOWN_AND_LEFT	256// used in most FE languages
#define RF_DOWN_AND_RIGHT	512// used in Chinese only
#define RF_ARBITRARY_ANGLE	1024// can read text written at arbitrary angles (mimio)
#define RF_LATTICE		2048// can return lattice in results
#define RF_ADVISEINKCHANGE		4096// advise ink change can interrupt process
#ifndef __RECOTYPES__
#define __RECOTYPES__
typedef struct tagRECO_GUIDE
    {
    int xOrigin;
    int yOrigin;
    int cxBox;
    int cyBox;
    int cxBase;
    int cyBase;
    int cHorzBox;
    int cVertBox;
    int cyMid;
    } 	RECO_GUIDE;

typedef struct tagRECO_ATTRS
    {
    DWORD dwRecoCapabilityFlags;
    WCHAR awcVendorName[ 32 ];
    WCHAR awcFriendlyName[ 64 ];
    WORD awLanguageId[ 64 ];
    } 	RECO_ATTRS;

typedef struct tagRECO_RANGE
    {
    ULONG iwcBegin;
    ULONG cCount;
    } 	RECO_RANGE;

typedef struct tagLINE_SEGMENT
    {
    POINT PtA;
    POINT PtB;
    } 	LINE_SEGMENT;

typedef struct tagLATTICE_METRICS
    {
    LINE_SEGMENT lsBaseline;
    short iMidlineOffset;
    } 	LATTICE_METRICS;

typedef 
enum enumLINE_METRICS
    {	LM_BASELINE	= 0,
	LM_MIDLINE	= 1,
	LM_ASCENDER	= 2,
	LM_DESCENDER	= 3
    } 	LINE_METRICS;

typedef 
enum enumCONFIDENCE_LEVEL
    {	CFL_STRONG	= 0,
	CFL_INTERMEDIATE	= 1,
	CFL_POOR	= 2
    } 	CONFIDENCE_LEVEL;

typedef 
enum enumALT_BREAKS
    {	ALT_BREAKS_SAME	= 0,
	ALT_BREAKS_UNIQUE	= 1,
	ALT_BREAKS_FULL	= 2
    } 	ALT_BREAKS;

typedef 
enum enumRECO_TYPE
    {	RECO_TYPE_WSTRING	= 0,
	RECO_TYPE_WCHAR	= 1
    } 	RECO_TYPE;

typedef struct tagRECO_LATTICE_PROPERTY
    {
    GUID guidProperty;
    USHORT cbPropertyValue;
    /* [size_is][unique] */ BYTE *pPropertyValue;
    } 	RECO_LATTICE_PROPERTY;

typedef struct tagRECO_LATTICE_PROPERTIES
    {
    ULONG cProperties;
    /* [size_is][unique] */ RECO_LATTICE_PROPERTY **apProps;
    } 	RECO_LATTICE_PROPERTIES;

typedef int RECO_SCORE;

typedef struct tagRECO_LATTICE_ELEMENT
    {
    RECO_SCORE score;
    WORD type;
    BYTE *pData;
    ULONG ulNextColumn;
    ULONG ulStrokeNumber;
    RECO_LATTICE_PROPERTIES epProp;
    } 	RECO_LATTICE_ELEMENT;

typedef struct tagRECO_LATTICE_COLUMN
    {
    ULONG key;
    RECO_LATTICE_PROPERTIES cpProp;
    ULONG cStrokes;
    ULONG *pStrokes;
    ULONG cLatticeElements;
    RECO_LATTICE_ELEMENT *pLatticeElements;
    } 	RECO_LATTICE_COLUMN;

typedef struct tagRECO_LATTICE
    {
    ULONG ulColumnCount;
    RECO_LATTICE_COLUMN *pLatticeColumns;
    ULONG ulPropertyCount;
    GUID *pGuidProperties;
    ULONG ulBestResultColumnCount;
    ULONG *pulBestResultColumns;
    ULONG *pulBestResultIndexes;
    } 	RECO_LATTICE;

typedef struct tagCHARACTER_RANGE
    {
    WCHAR wcLow;
    USHORT cChars;
    } 	CHARACTER_RANGE;

typedef struct tagCHARACTER_RANGE *PCHARACTER_RANGE;

#endif


extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\inc\jumbotool.h ===
/**************************************************************************\
 * FILE: jumbotool.h
 *
 * Lists functions Zilla exports to its tools that are related to jumbo but nothing else.
\**************************************************************************/

#ifndef JUMBOTOOL_H
#define JUMBOTOOL_H

#ifdef __cplusplus
extern "C" {
#endif

	// Featurize ink
int JumboFeaturize(GLYPH **glyph, BIGPRIM *rgprim);

#ifdef __cplusplus
};
#endif

#endif	// JUMBOTOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\wisp\inc\recdefs.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecDefs.h
//
//--------------------------------------------------------------------------


#ifndef __INC_RECDEFS_H
#define __INC_RECDEFS_H

// RECO FLAGS
#define RECOFLAG_WORDMODE	0x00000001
#define RECOFLAG_COERCE		0x00000002
#define RECOFLAG_SINGLESEG	0x00000004

// Confidence constants
#define RECOCONF_LOWCONFIDENCE -1
#define RECOCONF_MEDIUMCONFIDENCE 0
#define RECOCONF_HIGHCONFIDENCE 1
#define RECOCONF_NOTSET    128

// Gesture ids
#define GESTURE_NULL                        0xf000
#define GESTURE_SCRATCHOUT                  0xf001
#define GESTURE_TRIANGLE                    0xf002
#define GESTURE_SQUARE                      0xf003
#define GESTURE_STAR                        0xf004
#define GESTURE_CHECK                       0xf005
#define GESTURE_INFINITY                    0xf006
#define GESTURE_CROSS                       0xf007
#define GESTURE_PARAGRAPH                   0xf008
#define GESTURE_SECTION                     0xf009
#define GESTURE_BULLET                      0xf00a
#define GESTURE_BULLET_CROSS                0xf00b
#define GESTURE_SQUIGGLE                    0xf00c
#define GESTURE_SWAP                        0xf00d
#define GESTURE_OPENUP                      0xf00e
#define GESTURE_CLOSEUP                     0xf00f
#define GESTURE_CURLICUE                    0xf010
#define GESTURE_DOUBLE_CURLICUE             0xf011
#define GESTURE_RECTANGLE                   0xf012
#define GESTURE_CIRCLE                      0xf020
#define GESTURE_DOUBLE_CIRCLE               0xf021
#define GESTURE_CIRCLE_TAP                  0xf022
#define GESTURE_CIRCLE_CIRCLE               0xf023
#define GESTURE_CIRCLE_CROSS                0xf025
#define GESTURE_CIRCLE_LINE_VERT            0xf026
#define GESTURE_CIRCLE_LINE_HORZ            0xf027
#define GESTURE_SEMICIRCLE_LEFT             0xf028
#define GESTURE_SEMICIRCLE_RIGHT            0xf029
#define GESTURE_CHEVRON_UP                  0xf030
#define GESTURE_CHEVRON_DOWN                0xf031
#define GESTURE_CHEVRON_LEFT                0xf032
#define GESTURE_CHEVRON_RIGHT               0xf033
#define GESTURE_ARROW_UP                    0xf038
#define GESTURE_ARROW_DOWN                  0xf039
#define GESTURE_ARROW_LEFT                  0xf03a
#define GESTURE_ARROW_RIGHT                 0xf03b
#define GESTURE_DOUBLE_ARROW_UP             0xf03c
#define GESTURE_DOUBLE_ARROW_DOWN           0xf03d
#define GESTURE_DOUBLE_ARROW_LEFT           0xf03e
#define GESTURE_DOUBLE_ARROW_RIGHT          0xf03f
#define GESTURE_UP_ARROW_LEFT               0xf040
#define GESTURE_UP_ARROW_RIGHT              0xf041
#define GESTURE_DOWN_ARROW_LEFT             0xf042
#define GESTURE_DOWN_ARROW_RIGHT            0xf043
#define GESTURE_LEFT_ARROW_UP               0xf044
#define GESTURE_LEFT_ARROW_DOWN             0xf045
#define GESTURE_RIGHT_ARROW_UP              0xf046
#define GESTURE_RIGHT_ARROW_DOWN            0xf047
#define GESTURE_UP                          0xf058
#define GESTURE_DOWN                        0xf059
#define GESTURE_LEFT                        0xf05a
#define GESTURE_RIGHT                       0xf05b
#define GESTURE_DIAGONAL_LEFTUP             0xf05c
#define GESTURE_DIAGONAL_RIGHTUP            0xf05d
#define GESTURE_DIAGONAL_LEFTDOWN           0xf05e
#define GESTURE_DIAGONAL_RIGHTDOWN          0xf05f
#define GESTURE_UP_DOWN                     0xf060
#define GESTURE_DOWN_UP                     0xf061
#define GESTURE_LEFT_RIGHT                  0xf062
#define GESTURE_RIGHT_LEFT                  0xf063
#define GESTURE_UP_LEFT_LONG                0xf064
#define GESTURE_UP_RIGHT_LONG               0xf065
#define GESTURE_DOWN_LEFT_LONG              0xf066
#define GESTURE_DOWN_RIGHT_LONG             0xf067
#define GESTURE_UP_LEFT                     0xf068
#define GESTURE_UP_RIGHT                    0xf069
#define GESTURE_DOWN_LEFT                   0xf06a
#define GESTURE_DOWN_RIGHT                  0xf06b
#define GESTURE_LEFT_UP                     0xf06c
#define GESTURE_LEFT_DOWN                   0xf06d
#define GESTURE_RIGHT_UP                    0xf06e
#define GESTURE_RIGHT_DOWN                  0xf06f
#define GESTURE_LETTER_A                    0xf080
#define GESTURE_LETTER_B                    0xf081
#define GESTURE_LETTER_C                    0xf082
#define GESTURE_LETTER_D                    0xf083
#define GESTURE_LETTER_E                    0xf084
#define GESTURE_LETTER_F                    0xf085
#define GESTURE_LETTER_G                    0xf086
#define GESTURE_LETTER_H                    0xf087
#define GESTURE_LETTER_I                    0xf088
#define GESTURE_LETTER_J                    0xf089
#define GESTURE_LETTER_K                    0xf08a
#define GESTURE_LETTER_L                    0xf08b
#define GESTURE_LETTER_M                    0xf08c
#define GESTURE_LETTER_N                    0xf08d
#define GESTURE_LETTER_O                    0xf08e
#define GESTURE_LETTER_P                    0xf08f
#define GESTURE_LETTER_Q                    0xf090
#define GESTURE_LETTER_R                    0xf091
#define GESTURE_LETTER_S                    0xf092
#define GESTURE_LETTER_T                    0xf093
#define GESTURE_LETTER_U                    0xf094
#define GESTURE_LETTER_V                    0xf095
#define GESTURE_LETTER_W                    0xf096
#define GESTURE_LETTER_X                    0xf097
#define GESTURE_LETTER_Y                    0xf098
#define GESTURE_LETTER_Z                    0xf099
#define GESTURE_DIGIT_0                     0xf09a
#define GESTURE_DIGIT_1                     0xf09b
#define GESTURE_DIGIT_2                     0xf09c
#define GESTURE_DIGIT_3                     0xf09d
#define GESTURE_DIGIT_4                     0xf09e
#define GESTURE_DIGIT_5                     0xf09f
#define GESTURE_DIGIT_6                     0xf0a0
#define GESTURE_DIGIT_7                     0xf0a1
#define GESTURE_DIGIT_8                     0xf0a2
#define GESTURE_DIGIT_9                     0xf0a3
#define GESTURE_EXCLAMATION                 0xf0a4
#define GESTURE_QUESTION                    0xf0a5
#define GESTURE_SHARP                       0xf0a6
#define GESTURE_DOLLAR                      0xf0a7
#define GESTURE_ASTERISK                    0xf0a8
#define GESTURE_PLUS                        0xf0a9
#define GESTURE_DOUBLE_UP                   0xf0b8
#define GESTURE_DOUBLE_DOWN                 0xf0b9
#define GESTURE_DOUBLE_LEFT                 0xf0ba
#define GESTURE_DOUBLE_RIGHT                0xf0bb
#define GESTURE_TRIPLE_UP                   0xf0bc
#define GESTURE_TRIPLE_DOWN                 0xf0bd
#define GESTURE_TRIPLE_LEFT                 0xf0be
#define GESTURE_TRIPLE_RIGHT                0xf0bf
#define GESTURE_BRACKET_OVER                0xf0e4
#define GESTURE_BRACKET_UNDER               0xf0e5
#define GESTURE_BRACKET_LEFT                0xf0e6
#define GESTURE_BRACKET_RIGHT               0xf0e7
#define GESTURE_BRACE_OVER                  0xf0e8
#define GESTURE_BRACE_UNDER                 0xf0e9
#define GESTURE_BRACE_LEFT                  0xf0ea
#define GESTURE_BRACE_RIGHT                 0xf0eb
#define GESTURE_TAP                         0xf0f0
#define GESTURE_DOUBLE_TAP                  0xf0f1
#define GESTURE_TRIPLE_TAP                  0xf0f2
#define GESTURE_QUAD_TAP                    0xf0f3
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\wisp\inc\tpcerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File: TPCError.h
//      Microsoft TabletPC API Error Code definitions
//
//--------------------------------------------------------------------------

#ifndef _WINERROR_
#include <winerror.h>
#endif

/*** TPC_E_INVALID_PROPERTY                   0x80040241    -2147220927
*   The property was not found, or supported by the recognizer.
*/
#define TPC_E_INVALID_PROPERTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x241)

/*** TPC_E_NO_DEFAULT_TABLET                  0x80040212    -2147220974
*   No default tablet.
*/
#define TPC_E_NO_DEFAULT_TABLET               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x212)

/*** TPC_E_UNKNOWN_PROPERTY                   0x8004021b    -2147220965
*   Unknown property specified.
*/
#define TPC_E_UNKNOWN_PROPERTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x21b)

/*** TPC_E_INVALID_INPUT_RECT                 0x80040219    -2147220967
*   An invalid input rectangle was specified.
*/
#define TPC_E_INVALID_INPUT_RECT              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x219)

/*** TPC_E_INVALID_STROKE                     0x80040222    -2147220958
*   The stroke object was deleted.
*/
#define TPC_E_INVALID_STROKE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x222)

/*** TPC_E_INITIALIZE_FAIL                    0x80040223    -2147220957
*   Initialize failure.
*/
#define TPC_E_INITIALIZE_FAIL                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x223)

/*** TPC_E_NOT_RELEVANT                       0x80040232    -2147220942
*   The data required for the operation was not supplied.
*/
#define TPC_E_NOT_RELEVANT                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x232)

/*** TPC_E_RECOGNIZER_NOT_REGISTERED          0x80040235    -2147220939
*   There are no Recognizers registered.
*/
#define TPC_E_RECOGNIZER_NOT_REGISTERED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x235)

/*** TPC_E_INVALID_RIGHTS                     0x80040236    -2147220938
*   User does not have the necessary rights to read recognizer information.
*/
#define TPC_E_INVALID_RIGHTS                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x236)

/*** TPC_E_OUT_OF_ORDER_CALL                  0x80040237    -2147220937
*   API calls were made in an incorrect order.
*/
#define TPC_E_OUT_OF_ORDER_CALL               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x237)

#define FACILITY_INK      40
#define INK_ERROR_BASE    0x0000

#define MAKE_INK_HRESULT(sev, err) MAKE_HRESULT(sev,FACILITY_INK,err)
#define MAKE_INK_ERROR(err)        MAKE_INK_HRESULT(SEVERITY_ERROR,err+INK_ERROR_BASE)
#define MAKE_INK_SCODE(scode)      MAKE_INK_HRESULT(SEVERITY_SUCCESS,scode+INK_ERROR_BASE)

// IErrorInfo helper for objects that support error info (CLSID_IFoo && IID_IFoo)
#define MAKE_OBJ_ERROR_INFO( ID, hr, helpid, helpfile )     \
            AtlReportError( CLSID_##ID , IDS_##hr,          \
                            helpid, helpfile,               \
                            IID_I##ID, hr,                  \
                            _Module.GetModuleInstance())

// IErrorInfo helper for interfaces that support error info, but are not cocreatable
//      (e.g. IID_IFoo, but NOT CLSID_IFoo)
#define MAKE_INT_ERROR_INFO( ID, hr, helpid, helpfile )     \
            AtlReportError( GUID_NULL , IDS_##hr,           \
                            helpid, helpfile,               \
                            IID_I##ID, hr,                  \
                            _Module.GetModuleInstance())

/*** E_INK_EXCEPTION                                   0x80280001    -2144862207
*   An internal exception occurred while executing the method or property.
*/
#define E_INK_EXCEPTION                                MAKE_INK_ERROR(0x001)

/*** E_INK_MISMATCHED_INK_OBJECT                       0x80280002    -2144862206
*   The object is already associated with an ink object and cannot be reassociated.
*/
#define E_INK_MISMATCHED_INK_OBJECT                    MAKE_INK_ERROR(0x002)

/*** E_INK_COLLECTOR_BUSY                              0x80280003    -2144862205
*   The operation cannot be performed while the user is actively inking.
*/
#define E_INK_COLLECTOR_BUSY                           MAKE_INK_ERROR(0x003)

/*** E_INK_INCOMPATIBLE_OBJECT                          0x80280004    -2144862204
*   The interface pointer points to an object that is incompatible with the Ink API
*/
#define E_INK_INCOMPATIBLE_OBJECT                      MAKE_INK_ERROR(0x004)

/*** E_INK_WINDOW_NOT_SET                              0x80280005    -2144862203
*   The window handle must be set before ink collection can occur.
*/
#define E_INK_WINDOW_NOT_SET                           MAKE_INK_ERROR(0x005)

/*** E_INK_INVALID_MODE                                0x80280006    -2144862202
*   The InkCollector must be gesture mode for gesture features,
            and single tablet mode for single tablet features.
*/
#define E_INK_INVALID_MODE                             MAKE_INK_ERROR(0x006)

/*** E_INK_COLLECTOR_ENABLED                           0x80280007    -2144862201
*   The operation cannot be performed while the InkCollector is enabled.
*/
#define E_INK_COLLECTOR_ENABLED                        MAKE_INK_ERROR(0x007)

/*** E_INK_NO_STROKES_TO_RECOGNIZE                     0x80280008    -2144862200
*   There are no strokes for the recognizer to process.
*/
#define E_INK_NO_STROKES_TO_RECOGNIZE                  MAKE_INK_ERROR(0x008)

/*** E_INK_EMPTY_RECOGNITION_RESULT                    0x80280009    -2144862199
*   There are no strokes for the recognizer to process.
*/
#define E_INK_EMPTY_RECOGNITION_RESULT                 MAKE_INK_ERROR(0x009)


// Recognizer Engine Driver Error Codes

/*** TPC_E_INVALID_PACKET_DESCRIPTION         0x80040233    -2147220941
*   Invalid packet description.
*/
#define TPC_E_INVALID_PACKET_DESCRIPTION      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x233)

#define TPC_E_INSUFFICIENT_BUFFER             HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

//
// Definition of Success codes
// 
#define TPC_S_TRUNCATED                       MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x252)
#define TPC_S_INTERRUPTED                     MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x253)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\wisp\inc\recapis.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecApis.h
//
//--------------------------------------------------------------------------

#ifndef __HRECOALT__
#define __HRECOALT__
DECLARE_HANDLE(HRECOALT); // definition of a handle for the alternate
#endif

#ifndef __HRECOCONTEXT__
#define __HRECOCONTEXT__
DECLARE_HANDLE(HRECOCONTEXT); // definition of a handle for the reco context
#endif

#ifndef __HRECOGNIZER__
#define __HRECOGNIZER__
DECLARE_HANDLE(HRECOGNIZER); // definition of a handle for the recognizer
#endif

#ifndef __HRECOLATTICE__
#define __HRECOLATTICE__
DECLARE_HANDLE(HRECOLATTICE); // definition of a handle for the lattice
#endif

#ifndef __HRECOWORDLIST__
#define __HRECOWORDLIST__
DECLARE_HANDLE(HRECOWORDLIST); // definition of a handle for the lattice
#endif

typedef HRESULT (*PfnRecoCallback)(DWORD, LPBYTE, HRECOCONTEXT);


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED
#include "tpcshrd.h"
#include "RecTypes.h"

////////////////////////
// IRecognizer
////////////////////////
HRESULT WINAPI CreateRecognizer(CLSID *pCLSID, HRECOGNIZER *phrec);
HRESULT WINAPI DestroyRecognizer(HRECOGNIZER hrec);
HRESULT WINAPI GetRecoAttributes(HRECOGNIZER hrec, RECO_ATTRS* pRecoAttrs);
HRESULT WINAPI CreateContext(HRECOGNIZER hrec, HRECOCONTEXT *phrc);
HRESULT WINAPI DestroyContext(HRECOCONTEXT hrc);
HRESULT WINAPI GetResultPropertyList(HRECOGNIZER hrec, ULONG* pPropertyCount, GUID*pPropertyGuid);
HRESULT WINAPI GetPreferredPacketDescription(HRECOGNIZER hrec, PACKET_DESCRIPTION* pPacketDescription);
HRESULT WINAPI GetUnicodeRanges(HRECOGNIZER hrec, ULONG *pcRanges, CHARACTER_RANGE *pcr);

////////////////////////
// IRecoContext
////////////////////////
HRESULT WINAPI AddStroke(HRECOCONTEXT hrc, const PACKET_DESCRIPTION* pPacketDesc, ULONG cbPacket, const BYTE *pPacket, const XFORM *pXForm);
HRESULT WINAPI GetBestResultString(HRECOCONTEXT hrc, ULONG *pcSize, WCHAR* pwcBestResult);
HRESULT WINAPI GetBestAlternate(HRECOCONTEXT hrc, HRECOALT* pHrcAlt);
HRESULT WINAPI DestroyAlternate(HRECOALT hrcalt);
HRESULT WINAPI SetGuide(HRECOCONTEXT hrc, const RECO_GUIDE* pGuide, ULONG iIndex);
HRESULT WINAPI GetGuide(HRECOCONTEXT hrc, RECO_GUIDE* pGuide, ULONG *piIndex);
HRESULT WINAPI AdviseInkChange(HRECOCONTEXT hrc, BOOL bNewStroke);
HRESULT WINAPI SetCACMode(HRECOCONTEXT hrc, int iMode);
HRESULT WINAPI EndInkInput(HRECOCONTEXT hrc);
HRESULT WINAPI CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc);
HRESULT WINAPI ResetContext(HRECOCONTEXT hrc);
HRESULT WINAPI GetAlternateList(HRECOCONTEXT hrc, RECO_RANGE* pRecoRange, ULONG*pcAlt, HRECOALT*phrcalt, ALT_BREAKS iBreak);
HRESULT WINAPI Process(HRECOCONTEXT hrc, BOOL *pbPartialProcessing);
HRESULT WINAPI SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR *pwcFactoid);
HRESULT WINAPI SetFlags(HRECOCONTEXT hrc, DWORD dwFlags);
HRESULT WINAPI GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice);
HRESULT WINAPI SetTextContext(HRECOCONTEXT hrc, ULONG cwcBefore, const WCHAR *pwcBefore, ULONG cwcAfter, const WCHAR *pwcAfter);
HRESULT WINAPI GetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG *pcRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI SetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG cRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI GetContextPropertyList(HRECOCONTEXT hrc, ULONG *pcProperties, GUID *pPropertyGUIDS);
HRESULT WINAPI GetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG *pcbSize, BYTE *pProperty);
HRESULT WINAPI SetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG cbSize, BYTE *pProperty);
HRESULT WINAPI IsStringSupported(HRECOCONTEXT hrc, ULONG wcString, const WCHAR *pwcString);
HRESULT WINAPI SetWordList(HRECOCONTEXT hrc, HRECOWORDLIST hwl);


////////////////////////
// IAlternate
////////////////////////
HRESULT WINAPI GetString(HRECOALT hrcalt, RECO_RANGE *pRecoRange, ULONG* pcSize, WCHAR* pwcString);
HRESULT WINAPI GetStrokeRanges(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG* pcRanges, STROKE_RANGE* pStrokeRange);
HRESULT WINAPI GetSegmentAlternateList(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *pcAlts, HRECOALT* pAlts);
HRESULT WINAPI GetMetrics(HRECOALT hrcalt, RECO_RANGE* pRecoRange, LINE_METRICS lm, LINE_SEGMENT* pls);
HRESULT WINAPI GetGuideIndex(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *piIndex);
HRESULT WINAPI GetConfidenceLevel(HRECOALT hrcalt, RECO_RANGE* pRecoRange, CONFIDENCE_LEVEL* pcl);
HRESULT WINAPI GetPropertyRanges(HRECOALT hrcalt, const GUID *pPropertyGuid, ULONG* pcRanges, RECO_RANGE* pRecoRange);
HRESULT WINAPI GetRangePropertyValue(HRECOALT hrcalt, const GUID *pPropertyGuid, RECO_RANGE* pRecoRange, ULONG*cbSize, BYTE* pProperty);

////////////////////////
// IRecoWordList
////////////////////////
HRESULT WINAPI DestroyWordList(HRECOWORDLIST hwl);
HRESULT WINAPI AddWordsToWordList(HRECOWORDLIST hwl, WCHAR *pwcWords);
HRESULT WINAPI MakeWordList(HRECOGNIZER hrec, WCHAR *pBuffer, HRECOWORDLIST *phwl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\wisp\inc\tpcshrd.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for tpcshrd.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __tpcshrd_h__
#define __tpcshrd_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_tpcshrd_0000 */
/* [local] */ 

//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      TpcShrd.h
//
//--------------------------------------------------------------------------
#ifndef __WISPSHRD_H
#define __WISPSHRD_H
#define IP_CURSOR_DOWN           0x00000001
#define IP_INVERTED              0x00000002
#define IP_MARGIN                0x00000004
typedef DWORD CURSOR_ID;

typedef USHORT SYSTEM_EVENT;

typedef DWORD TABLET_CONTEXT_ID;

typedef 
enum _PROPERTY_UNITS
    {	PROPERTY_UNITS_DEFAULT	= 0,
	PROPERTY_UNITS_INCHES	= 1,
	PROPERTY_UNITS_CENTIMETERS	= 2,
	PROPERTY_UNITS_DEGREES	= 3,
	PROPERTY_UNITS_RADIANS	= 4,
	PROPERTY_UNITS_SECONDS	= 5,
	PROPERTY_UNITS_POUNDS	= 6,
	PROPERTY_UNITS_GRAMS	= 7,
	PROPERTY_UNITS_SILINEAR	= 8,
	PROPERTY_UNITS_SIROTATION	= 9,
	PROPERTY_UNITS_ENGLINEAR	= 10,
	PROPERTY_UNITS_ENGROTATION	= 11,
	PROPERTY_UNITS_SLUGS	= 12,
	PROPERTY_UNITS_KELVIN	= 13,
	PROPERTY_UNITS_FAHRENHEIT	= 14,
	PROPERTY_UNITS_AMPERE	= 15,
	PROPERTY_UNITS_CANDELA	= 16
    } 	PROPERTY_UNITS;

typedef enum _PROPERTY_UNITS *PPROPERTY_UNITS;

#ifndef _XFORM_
#define _XFORM_
typedef /* [hidden] */ struct tagXFORM
    {
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
    } 	XFORM;

#endif
typedef struct tagSYSTEM_EVENT_DATA
    {
    BYTE bModifier;
    WCHAR wKey;
    LONG xPos;
    LONG yPos;
    BYTE bCursorMode;
    DWORD dwButtonState;
    } 	SYSTEM_EVENT_DATA;

typedef struct tagSTROKE_RANGE
    {
    ULONG iStrokeBegin;
    ULONG iStrokeEnd;
    } 	STROKE_RANGE;

typedef struct _PROPERTY_METRICS
    {
    LONG nLogicalMin;
    LONG nLogicalMax;
    PROPERTY_UNITS Units;
    FLOAT fResolution;
    } 	PROPERTY_METRICS;

typedef struct _PROPERTY_METRICS *PPROPERTY_METRICS;

typedef struct _PACKET_PROPERTY
    {
    GUID guid;
    PROPERTY_METRICS PropertyMetrics;
    } 	PACKET_PROPERTY;

typedef struct _PACKET_PROPERTY *PPACKET_PROPERTY;

typedef struct _PACKET_DESCRIPTION
    {
    ULONG cbPacketSize;
    ULONG cPacketProperties;
    /* [size_is][unique] */ PACKET_PROPERTY *pPacketProperties;
    ULONG cButtons;
    /* [size_is][unique] */ GUID *pguidButtons;
    } 	PACKET_DESCRIPTION;

typedef struct _PACKET_DESCRIPTION *PPACKET_DESCRIPTION;

#endif // __WISPSHRD_H


extern RPC_IF_HANDLE __MIDL_itf_tpcshrd_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tpcshrd_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\inc\zilla.h ===
/**************************************************************************\
 * FILE: zilla.h
 *
 * Lists functions Zilla exports to the outside world
\**************************************************************************/

#ifndef ZILLA_H
#define ZILLA_H 1

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif

#define	Cost(x)			((FLOAT)x)
#define	NegCOST(a)		(-(a))
#define	DivCOST(a,b)	(a / b)

/***************** Public Prototypes **********************/

// Do zilla match on a glyph.
int   ZillaMatch(ALT_LIST *, int, GLYPH **, CHARSET *, FLOAT, DWORD *, DWORD, int, RECT *);

// Do zilla match on a glyph, returns proto ID numbers, not dense codes!
int   ZillaMatch2(ALT_LIST *, int, GLYPH **, CHARSET *, FLOAT, DWORD *, DWORD, int, RECT *);

// Do zilla match on a glyph with the jumbo features
int   JumboMatch(ALT_LIST *, int, GLYPH **, CHARSET *, FLOAT, DWORD *, DWORD, int, RECT *);

// Load and unload Zilla database and tables from resources
BOOL ZillaLoadResource(
	HINSTANCE	hInst,
	int			nResIDDB,		// ID for main Database
	int			nTypeDB,		// Type for main Database
	int			nResIDCost,		// ID for costcalc table
	int			nTypeCost,		// Type for costcalc table
	int			nResIDGeo,		// ID for geostats table
	int			nTypeGeo,		// Type for geostats table
	LOCRUN_INFO *pLocRunInfo
);
BOOL ZillaUnloadResource();

// Load and unload Zilla database and tables from files.
BOOL ZillaLoadFile(LOCRUN_INFO *pLocRunInfo, wchar_t * pPath, BOOL fOpenTrainTxt);
BOOL ZillaUnLoadFile();

// Access to locale information.
// WARNING: must be declared and loaded by code that calls Zilla.
// This is a hack, clean it up!
extern LOCRUN_INFO	g_locRunInfo;

// Train time only stuff
#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\jfeature.c ===
/**************************************************************************\
* FILE: feature.c
*
* Jumbo featurizer routines
*
* History:
*  12-May-1998 -by- Ahmad abdulKader	AhmadAB
\**************************************************************************/

#include "common.h"
#include "ASSERT.h"
#include "zillatool.h"
#include "hmmrecog.h"

/******************************Public*Routine******************************\
* FeaturizeGLYPH
*
* Converts the ink in the GLYPH to a feature array.
* 
* using the jumbo(HMM) stroke recognizer as a feature, plus the usual
* Zilla geometrics
*
* History:
*  12-May-1998 -by- Ahmad abdulKader	AhmadAB
\**************************************************************************/

int JumboFeaturize(GLYPH **ppGlyph, BIGPRIM *pRGPrim)
{
    int		iFrame, cFrame, cStrokes;
    FRAME	*pFrame;
	int		*pStrokes;
	int		x, y, dx, dy, cPts;
	RECT	r;
	XY		*pPts;

    ASSERT(*ppGlyph);

	   // get the bounding rectangle of the glyph
	GetRectGLYPH(*ppGlyph, &r);
	dx = r.right - r.left + 1;
    dy = r.bottom - r.top + 1;

	// go thru all frames
	cFrame		= min (CframeGLYPH(*ppGlyph), CPRIMMAX - 1);

    for (iFrame = 0; iFrame < cFrame; iFrame++)
    {
        pFrame = FrameAtGLYPH(*ppGlyph, iFrame);

		// call the StrokeRecognizer 
		if (!HRrun(pFrame))
			return 0;

		// get the results
		pStrokes = HRgetLabelOrder(&cStrokes);

		if (!pStrokes || cStrokes < 1)
			return 0;

		// we only care (for now) about the top1
		pRGPrim[iFrame].code = pStrokes[0];

		// Geometrics, extract from smoothed XY
		pPts		=	pFrame->rgsmoothxy;
		cPts		=	pFrame->csmoothxy;
		//pPts		=	pFrame->rgrawxy;
		//cPts		=	pFrame->info.cPnt;
		
		// make sure that frame was smoothed
		if (!pPts)
			return 0;

        // fit into a 16 X 16 square and use co-ordinates of end points
		// as features
		x = ((pPts[0].x - r.left) * 16) / dx;
        ASSERT(x >= 0 && x <= 15);

        y = ((pPts[0].y - r.top) * 16) / dy;
        ASSERT(y >= 0 && y <= 15);

        pRGPrim[iFrame].x1= (unsigned)x;
        pRGPrim[iFrame].y1= (unsigned)y;

		x = ((pPts[cPts - 1].x - r.left) * 16) / dx;
        ASSERT(x >= 0 && x <= 15);

        y = ((pPts[cPts - 1].y - r.top) * 16) / dy;
        ASSERT(y >= 0 && y <= 15);

        pRGPrim[iFrame].x2= (unsigned)x;
        pRGPrim[iFrame].y2= (unsigned)y;
    }

    return(cFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\sources.inc ===
TARGETNAME=zilla
TARGETTYPE=LIBRARY

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DUSE_ZILLAHOUND

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\hound\inc; \
          $(_TPG_ROOT)\hwx\zilla\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\zfeature.c \
         ..\zilla.c \
         ..\zillars.c \
         ..\zmatch.c \
         ..\ZillaHound.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\inc\zillatool.h ===
/**************************************************************************\
 * FILE: zillatool.h
 *
 * Lists functions Zilla exports to its tools but nothing else.
\**************************************************************************/

#ifndef ZILLATOOL_H
#define ZILLATOOL_H
#include "runnet.h"

#ifdef __cplusplus
extern "C" {
#endif

// Version of primitive with x and y values stored in bytes, not nibbles.
#pragma pack(1)
typedef struct tagBIGPRIM
{
    BYTE code;              /* 0-15 stroke fpendown, 4 unused bits. */
    BYTE x1;
    BYTE x2;
    BYTE y1;
    BYTE y2;
} BIGPRIM, *PBIGPRIM;
#pragma pack()

#ifdef ZTRAIN
typedef struct tagTRAININFO
{
	WORD		wclass;
    BYTE        rgfInfo;
    BYTE        cstrokes;
    int         chits;          // How many times this guy appeared in the top10 correctly
    int         cmishits;       // How many times this guy appeared incorrectly top1
    int         cattempts;      // How many times this guy appeared in the top10 list
    float       eHits;          // How many times this guy appeared in the top10 correctly
    float       eMishits;       // How many times this guy appeared incorrectly top1
    float       eAttempts;      // How many times this guy appeared in the top10 list before the correct answer
} TRAININFO;
#endif

typedef struct tagGEOMETRIC
{
	BYTE	x1:4; 		   /* start x-coord */
	BYTE	x2:4; 		   /* end x */
	BYTE	y1:4; 		   /* start y-coord */
	BYTE	y2:4; 		   /* end y */
} GEOMETRIC;

#pragma pack(1)
typedef struct tagPRIMITIVE
{
	BYTE	code;

	union
	{
		struct
		{
			BYTE	x1:4; 		   /* start x-coord */
			BYTE	x2:4; 		   /* end x */
			BYTE	y1:4; 		   /* start y-coord */
			BYTE	y2:4; 		   /* end y */
		};

		char	rgch[2];
	};
} PRIMITIVE, *PPRIMITIVE;
#pragma pack()

typedef struct tagPROTOHEADER
{
    DWORD		cprotoRom;
	WORD	   *rgdbcRom;
	BYTE	   *rgfeatRom;
    GEOMETRIC  *rggeomRom;
#ifdef ZTRAIN
    DWORD		cprotoDynamic;
    WORD       *rgdbcDynamic;
    PRIMITIVE  *rgprimDynamic;

	TRAININFO **rgptraininfo;
#endif // ZTRAIN
} PROTOHEADER;

typedef struct tagMATCH
{
    SYM         sym;
	WORD 		dist;
#ifdef ZTRAIN
	TRAININFO	*ptraininfo;
#endif // ZTRAIN
} MATCH;

typedef struct tagPROTOTYPE
{
    WORD        dbc;
	GEOMETRIC	*rggeom;
	BYTE		*rgfeat;
	BOOL		nybble;
    RECMASK		recmask;

#ifdef ZTRAIN
    PRIMITIVE	*rgprim;
	TRAININFO	*ptraininfo;
#endif // ZTRAIN
} PROTOTYPE;

typedef struct tagBIGPROTOTYPE
{
	WORD		dbc;
    PBIGPRIM	rgprim;
    ALC			recmask;

#ifdef ZTRAIN
	TRAININFO	*ptraininfo;
#endif // ZTRAIN
} BIGPROTOTYPE;

// Internal constants needed by the tools.
#define CMATCHMAX               20
#define CPRIM_DIFF              18	// number of different primitives
#define CPRIMMAX                30	// max primitives per character.
#define GEOM_DIST_MAX           900  // maximum geometric distance for 1 prim

// Internal declerations needed by tools.
typedef BYTE		**COST_TABLE;

// Featurize ink
int ZillaFeaturize(GLYPH **glyph, BIGPRIM *rgprim, BYTE *pHoundFeat);

// Globals to hold pointers to loaded data.
extern PROTOHEADER	mpcfeatproto[CPRIMMAX];

extern int			g_iCostTableSize;	
extern COST_TABLE	g_ppCostTable;
extern BYTE			*pGeomCost;

// Magic key the identifies the NN bin file
#define	ZILLA_HOUND_FILE_TYPE	0x31142253

// Version information for file.
#define	ZILLA_HOUND_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	ZILLA_HOUND_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define ZILLA_HOUND_CUR_FILE_VERSION		0		// Current version of code.

// Load info for Zilla-Hound
typedef struct tagZILLA_HOUND_LOAD_INFO
{
    LOAD_INFO	info;
    LOCAL_NET	net;
    int			iNetSize;
} ZILLA_HOUND_LOAD_INFO;

// Feature count information for Zilla/Hound combiner net
#define NUM_ZILLA_HOUND_ALTERNATES	4
#define NUM_ZILLA_HOUND_FEATURES	9

// Load the Zilla-Hound combining net.
BOOL ZillaHoundLoadFile(wchar_t *wszPath);

// Unload the Zilla-Hound combining net.
BOOL ZillaHoundUnloadFile();

// Load from a resource.
BOOL ZillaHoundLoadRes(HINSTANCE hInst, int nResID, int nType);

// Given Zilla results run Hound and combine the results.
void	ZillaHoundMatch(MATCH *pMatch, int cPrim, BYTE *pSampleVector, LOCRUN_INFO *pLocRunInfo);

// Generate features used by Zilla/Hound combiner net.
RREAL	*ZillaHoundFeat(
	MATCH *pMatch, int cPrim, BYTE *pSampleVector, RREAL *pZillaHoundNetMemory, LOCRUN_INFO *pLocRunInfo
);

// Train time only stuff
#ifdef ZTRAIN

// Flags set per prototype during training.

#define MASK_INFO_IN            0x01      // Prototype has been added to database
#define MASK_INFO_NOISY         0x04      // Don't match against this prototype

#define IsInsertedLPTRAININFO(lptraininfoIn)    (lptraininfoIn->rgfInfo & MASK_INFO_IN)
#define MarkInsertedLPTRAININFO(lptraininfoIn)  (lptraininfoIn->rgfInfo |= MASK_INFO_IN)
#define MarkNoisyLPTRAININFO(lptraininfoIn)     (lptraininfoIn->rgfInfo |= MASK_INFO_NOISY)
#define MarkNotNoisyLPTRAININFO(lptraininfoIn)  (lptraininfoIn->rgfInfo &= ~MASK_INFO_NOISY)
#define IsNoisyLPTRAININFO(lptraininfoIn)       (lptraininfoIn->rgfInfo & MASK_INFO_NOISY)

#define ProtoheaderFromMpcfeatproto(cprim)  &(mpcfeatproto[cprim])

#define GetCprotoDynamicPROTOHEADER(pprotohdr)				\
			((pprotohdr)->cprotoDynamic)
#define SetCprotoDynamicPROTOHEADER(pprotohdr, cproto)		\
			((pprotohdr)->cprotoDynamic = (cproto))

#define PrototypeFromPROTOHEADER(pprotohdr, cprim, iproto, proto) {			\
	if ((iproto) < (pprotohdr)->cprotoRom) {								\
		ASSERT(0);															\
	} else {																\
		UINT iprotoD = (iproto) - (pprotohdr)->cprotoRom;					\
		ASSERT(iprotoD < (pprotohdr)->cprotoDynamic);						\
		(proto).dbc = (pprotohdr)->rgdbcDynamic[iprotoD];					\
		(proto).rgprim = &((pprotohdr)->rgprimDynamic[(cprim) * (iprotoD)]);\
	}																		\
	(proto).recmask = LocRun2ALC(&g_locRunInfo, (proto).dbc);				\
	SetTraininfoPROTO(proto, (pprotohdr), iproto);							\
}

#define SetTraininfoPROTO(proto, pphdr, iproto) \
    (proto).ptraininfo = (pphdr)->rgptraininfo[iproto]

// Write out the cost calc table.
BOOL	CostCalcWriteFile(COST_TABLE ppCostTable, int iCostTableSize, FILE *pFile, wchar_t *pLocale);

// Write out the geostats table.
BOOL	GeoStatWriteFile(BYTE *pGeomCost, FILE *pFile, wchar_t *pLocale);

// Match primitives with extra stuff for training.
extern VOID MatchPrimitivesTrain(
    const BIGPRIM * const pprim,	// Featurized Query
    const UINT		cprim,			// Number of features in query (aka feature space)
    MATCH * const	rgmatch,		// Output: ranked list of characters and distances
    const UINT		cmatchmax,		// size of rgmatch array
    const CHARSET * const cs,		// Allowed character set
    const FLOAT		zillaGeo		// How important geometrics are vs. features.
);

BOOL AddPrototypeToDatabase(BIGPRIM *pprim, int cprim, WORD wTrain, VOID *pti);
BOOL TrimDatabase(VOID);
BOOL WriteTextDatabase(FILE *fpText, FILE *fpLog);
BOOL WriteZillaDat(LOCRUN_INFO *pLocRunInfo, FILE *cp, wchar_t *pLocale, BOOL bNibbleFeat);
VOID FreeDynamicMpcfeatproto(VOID);
int	ComputeZillaSize(void);
void GetDynamicProto(PROTOHEADER *pphdr, UINT cprim, UINT iproto, BIGPROTOTYPE *proto);
int CountPrototypes(void);

#endif

#ifdef __cplusplus
};
#endif

#endif	// ZILLATOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zfeature.c ===
/**************************************************************************\
* FILE: feature.c
*
* Zilla featurizer routines
*
* History:
*  12-Dec-1996 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
* (mostly from algo.c)
\**************************************************************************/

#include <math.h>
#include "hound.h"
#include "zillap.h"

/******************************* Constants *******************************/

#define MIN_STEPSIZE			5
#define MIN_STEPSMOOTH			3
#define FEATURE_NULL			20
#define FEAT_UP_RIGHT_CORNER    7
#define FEAT_DOWN_LEFT_CORNER   8
#define MAXINT					0x7fffffff
#define COORD_MAX               0x7fff
#define FRAME_MAXSTEPS			128

/********************** Types ***************************/

typedef struct tagSTEP
{
	int	x;
	int	y;
	short	slope;
    BYTE    dir;
} STEP;

typedef struct tagFEAT
{
	RECT	rect;
	POINT	ptBegin;
	POINT	ptEnd;
	BYTE	feature;
	WORD	iframe;
} FEAT;

typedef struct tagKPROTO
{
	RECT	rect;
    FEAT    rgfeat[CFEATMAX];
    WORD    cfeat;
} KPROTO;

/********************** Macros ***************************/

#define SetStepXRGSTEP(rg, i, bx)	((rg)[i].x = (bx))
#define SetStepYRGSTEP(rg, i, by)	((rg)[i].y = (by))
#define GetStepXRGSTEP(rg, i)			((rg)[i].x)
#define GetStepYRGSTEP(rg, i)			((rg)[i].y)

#define SetXmaxFEAT(f, mx)		((f)->rect.right = (mx))
#define SetYmaxFEAT(f, my)		((f)->rect.bottom = (my))
#define SetXminFEAT(f, mx)		((f)->rect.left = (mx))
#define SetYminFEAT(f, my)		((f)->rect.top = (my))
#define GetXmaxFEAT(f)			((f)->rect.right)
#define GetYmaxFEAT(f)			((f)->rect.bottom)
#define GetXminFEAT(f)			((f)->rect.left)
#define GetYminFEAT(f)			((f)->rect.top)

#define SetXbeginFEAT(f, bx)	((f)->ptBegin.x = (bx))
#define SetYbeginFEAT(f, by)	((f)->ptBegin.y = (by))
#define SetXendFEAT(f, ex)		((f)->ptEnd.x = (ex))
#define SetYendFEAT(f, ey)		((f)->ptEnd.y = (ey))
#define GetXbeginFEAT(f)		((f)->ptBegin.x)
#define GetYbeginFEAT(f)		((f)->ptBegin.y)
#define GetXendFEAT(f)			((f)->ptEnd.x)
#define GetYendFEAT(f)			((f)->ptEnd.y)

/******************************* Procedures ******************************/

void ZillaInitializeKPROTO(KPROTO *kproto)
{
    // assumes that kproto is zero init'ed

    kproto->rect.left = MAXINT;
    kproto->rect.top = MAXINT;
}

int ZillaGetStepsizeGLYPH(GLYPH *glyph)
{
    RECT rect;
    int dmax, stepsize;

    GetRectGLYPH(glyph, &rect);

    dmax = max(rect.right - rect.left, rect.bottom - rect.top);

    stepsize = (dmax + 1) / 16;

    if (stepsize < MIN_STEPSIZE)
        stepsize = MIN_STEPSIZE;

    return(stepsize);
}

/******************************Public*Routine******************************\
* FindHookJoint
*
* Finds possible spurrious hooks in the stroke due to pen down/ pen up noise.
* I take the largest hook possible that is less than 1/10th of an inch in
* size.  A hook is guessed to exist if the angle change is greater than
* KANJI_HOOK_FIND.
*
* History:
*  10-May-1996 -by- Patrick Haluptzok patrickh
* Modified it, restrict dehooking to less than 100/1000th of an inch.
\**************************************************************************/

#define KANJI_HOOK_FIND     85
#define MAX_HOOK_LENGTH     66

#define REAL_LEN(a,b) ((int)sqrt(((long)(a) * (long)(a)) + ((long)(b) * (long)(b))))

UINT PRIVATE FindHookJoint(XY *rgxy, UINT cxy, BOOL fBegin, int *angle)
{
	UINT ixy, ixyEdgeLeft, ixyEdgeRight, indxJoint, ixyStop;
    int alpha, angleTurn;
	int iLength;

	angleTurn = 0;

	if (fBegin)
    {
        //
        // Find how far into the stroke we can look for a hook.
        //

        for (iLength = 0, ixyStop = 0;
             (iLength < MAX_HOOK_LENGTH) && (ixyStop < (cxy / 3));
             ixyStop++)
        {
            iLength += REAL_LEN(rgxy[ixyStop + 1].x - rgxy[ixyStop].x,
                                rgxy[ixyStop + 1].y - rgxy[ixyStop].y);
        }

		indxJoint = 0;
		
        // Select the tightest angle that exceeds the threshold as far in as possible.

		for (ixy = 1; ixy < ixyStop; ixy++)
        {
			ixyEdgeLeft = (ixy == 1) ? 0 : ixy - 2;
			CALCANGLEPT(rgxy[ixyEdgeLeft], rgxy[ixy], rgxy[ixy + 2], alpha);
			alpha = abs(alpha);
			
			if ((180 - alpha) < KANJI_HOOK_FIND)
            {
                angleTurn = alpha;
                indxJoint = ixy;
            }
        }
    }
	else
    {
        for (iLength = 0, ixyStop = cxy - 1;
             (iLength < MAX_HOOK_LENGTH) && (ixyStop > ((2 * cxy) / 3));
             ixyStop--)
        {
            iLength += REAL_LEN(rgxy[ixyStop - 1].x - rgxy[ixyStop].x,
                                rgxy[ixyStop - 1].y - rgxy[ixyStop].y);
        }

		indxJoint = cxy - 1;
		
        for (ixy = cxy - 2; ixy > ixyStop; ixy--)
        {
            ixyEdgeRight = (ixy == (cxy - 2)) ? (cxy - 1) : ixy + 2;
			CALCANGLEPT(rgxy[ixy - 2], rgxy[ixy], rgxy[ixyEdgeRight], alpha);
			alpha = abs(alpha);
			
			if ((180 - alpha) < KANJI_HOOK_FIND)
            {
                angleTurn = alpha;
                indxJoint = ixy;
            }
        }
    }

	*angle = angleTurn;

	return(indxJoint);
}

UINT DehookStrokePoints(XY *rgxy, UINT cxy)
{
	int angle;
	UINT iHookBegin, iHookEnd;

	iHookBegin = FindHookJoint(rgxy, cxy, TRUE, &angle);
	iHookEnd = FindHookJoint(rgxy, cxy, FALSE, &angle);

	if (iHookBegin > 0 || iHookEnd < cxy - 1)
    {
		ASSERT(iHookBegin < iHookEnd);
		ASSERT(iHookEnd < cxy);

		cxy = iHookEnd - iHookBegin + 1;
		memmove((VOID *)rgxy, (VOID *)(&rgxy[iHookBegin]), sizeof(XY) * cxy);
    }

	return(cxy);
}

/******************************Public*Routine******************************\
* SmoothPointsFRAME
*
* Smooth the points from the jitter of the input device.
*
* History:
*  24-May-1996 -by- Patrick Haluptzok patrickh
* Smooth and dehook the less than 5 point strokes.
\**************************************************************************/

void SmoothPointsFRAME(FRAME *frame)
{
	XY	   *rgrawxy;           // array: Raw (x,y) data
	XY	   *rgxy;              // array: Smoothed Data
    UINT    crawxy, i, maxxy;
	LONG 	x, y;

	ASSERT(frame->rgsmoothxy == NULL);
	rgrawxy = frame->rgrawxy;
	crawxy  = frame->info.cPnt;

	rgxy = (XY *) ExternAlloc(crawxy * sizeof(XY));
	if (rgxy == (XY *) NULL)
		return;

	frame->csmoothxy = crawxy;
    rgxy[0].x = rgrawxy[0].x;
    rgxy[0].y = rgrawxy[0].y;

    maxxy = crawxy - 1;
   
    rgxy[maxxy].x = rgrawxy[maxxy].x;
    rgxy[maxxy].y = rgrawxy[maxxy].y;

    if (crawxy < 5)
    {
        for (i = 1; i < maxxy; ++i)
        {
            x = (1 + (LONG)(rgrawxy[i - 1].x) + (LONG)(rgrawxy[i].x) + (LONG)(rgrawxy[i + 1].x))/3;
            y = (1 + (LONG)(rgrawxy[i - 1].y) + (LONG)(rgrawxy[i].y) + (LONG)(rgrawxy[i + 1].y))/3;

            rgxy[i].x = (int)x;
            rgxy[i].y = (int)y;
        }

        for (i = 1; i < maxxy; ++i)
        {
            x = (1 + (LONG)(rgrawxy[i - 1].x) + (LONG)(rgrawxy[i].x) + (LONG)(rgrawxy[i + 1].x))/3;
            y = (1 + (LONG)(rgrawxy[i - 1].y) + (LONG)(rgrawxy[i].y) + (LONG)(rgrawxy[i + 1].y))/3;

            rgxy[i].x = (int)x;
            rgxy[i].y = (int)y;
        }
    }
	else // smooth by trapazoidal 5-point running average
    {
		x = (1 + (LONG)(rgrawxy[0].x) + (LONG)(rgrawxy[1].x) + (LONG)(rgrawxy[2].x))/3;
		y = (1 + (LONG)(rgrawxy[0].y) + (LONG)(rgrawxy[1].y) + (LONG)(rgrawxy[2].y))/3;
		rgxy[1].x = (int)x;
		rgxy[1].y = (int)y;
	
		for (i = 2; i < (crawxy - 2); ++i)
        {
			x = (rgrawxy[i-2].x)>>1;
			x += rgrawxy[i-1].x;
			x += rgrawxy[i].x;
			x += rgrawxy[i+1].x;
			x += ((rgrawxy[i+2].x)>>1);
			rgxy[i].x = (int)(x>>2);
			
			y = (rgrawxy[i-2].y)>>1;
			y += rgrawxy[i-1].y;
			y += rgrawxy[i].y;
			y += rgrawxy[i+1].y;
			y += ((rgrawxy[i+2].y)>>1);
			rgxy[i].y = (int)(y>>2);
        }
	
		x = (1 +(LONG)(rgrawxy[maxxy].x) + (LONG)(rgrawxy[maxxy-1].x) + (LONG)(rgrawxy[maxxy-2].x))/3;
		y = (1 + (LONG)(rgrawxy[maxxy].y) + (LONG)(rgrawxy[maxxy-1].y) + (LONG)(rgrawxy[maxxy-2].y))/3;
		rgxy[maxxy-1].x = (int)x;
        rgxy[maxxy-1].y = (int)y;
        frame->csmoothxy = DehookStrokePoints(rgxy, crawxy);
    }

    frame->rgsmoothxy = rgxy;
}

XY *PUBLIC ZillaPointSmoothFRAME(FRAME *frame)
{
	if (frame->rgsmoothxy == NULL)
		SmoothPointsFRAME(frame);

	return frame->rgsmoothxy;					// If SmoothPointsFRAME failed, this is NULL
}

int ZillaStepsFromFRAME(FRAME *frame, int stepsize, STEP *rgstep, int cstepmax)
{
    int cstep, slope, cxy, ixy;
    LONG dx, dy;
    BYTE dir;
    XY *pxy;

    ASSERT(stepsize > 0);
    cstep = 0;

    pxy = ZillaPointSmoothFRAME(frame);			// Until we call the smoother
    cxy = CpointSmoothFRAME(frame);				// This value is meaningless 

	if (pxy == (XY *) NULL)
		return 0;

    // set first step to first point

    SetStepXRGSTEP(rgstep, cstep, pxy->x);  // rgstep[cstep] = pxy->x;
    SetStepYRGSTEP(rgstep, cstep, pxy->y);	// rgstep[cstep] = pxy->y;

    for (ixy = 0; ixy < cxy; ixy++)
    {
        dx = (LONG)pxy[ixy].x - GetStepXRGSTEP(rgstep, cstep);
        dy = (LONG)pxy[ixy].y - GetStepYRGSTEP(rgstep, cstep);

        if (abs((int)dx) > stepsize ||
            abs((int)dy) > stepsize ||
            (ixy == cxy - 1 && ((dx || dy) || cstep == 0)))
        {
            if (dx != 0)
                slope = (int)(dy * 10 / dx);
            else
                slope = COORD_MAX;

            if (slope > 35 || slope < -35)
            {
                if (dy > 0)
                    dir = 6;
                else
                    dir = 2;
            }
            else if (slope <= 3 && slope >= -3)
            {
                if (dx > 0)
                    dir = 0;
                else
                    dir = 4;
            }
            else
            {
                if (dx > 0)
                {
                    if (dy > 0)
                        dir = 7;
                    else
                        dir = 1;
                }
                else
                {
                    if (dy > 0)
                        dir = 5;
                    else
                        dir = 3;
                }
            }

            ASSERT(dir >= 0 && dir <= 7);

            rgstep[cstep].dir = dir;
            rgstep[cstep].slope = (short)slope;
            cstep++;

            SetStepXRGSTEP(rgstep, cstep, pxy[ixy].x);
            SetStepYRGSTEP(rgstep, cstep, pxy[ixy].y);

            if (cstep + 1 >= cstepmax)
                break;
        }
    }

    ASSERT(cstep > 0);
    return(cstep);
}

int ZillaSmoothSteps(STEP *rgstep, int cstep, int cframe)
{
    int istep;

    if (cstep < MIN_STEPSMOOTH)
	{
        return(cstep);
	}

    // filtering

    for (istep = 1; istep < cstep - 1; istep++)
    {
        ASSERT(rgstep[istep].dir >= 0 && rgstep[istep].dir <= 7);

        if (rgstep[istep - 1].dir == rgstep[istep + 1].dir)
        {
            rgstep[istep].dir = rgstep[istep - 1].dir;
            istep++;
        }
    }

    rgstep[0].dir = rgstep[1].dir;
    rgstep[cstep - 1].dir = rgstep[cstep - 2].dir;

    return(cstep);
}

int ZillaCurvatureFromSteps(STEP *step0, STEP *step1)
{
	static const char	rgrgCurve[8][8] = {
		{ 0,-1,-2,-3, 4, 3, 2, 1},
		{ 1, 0,-1,-2,-3, 4, 3, 2},
		{ 2, 1, 0,-1,-2,-3, 4, 3},
		{ 3, 2, 1, 0,-1,-2,-3, 4},
		{ 4, 3, 2, 1, 0,-1,-2,-3},
		{-3, 4, 3, 2, 1, 0,-1,-2},
		{-2,-3, 4, 3, 2, 1, 0,-1},
		{-1,-2,-3, 4, 3, 2, 1, 0}
	};

	short slope0, slope1;
    int curve;

    ASSERT(step0->dir >= 0 && step0->dir <= 7);
    ASSERT(step1->dir >= 0 && step1->dir <= 7);

	curve = (short)rgrgCurve[step0->dir][step1->dir];

    if (curve == 4)
        {
        slope0 = step0->slope;
        slope1 = step1->slope;

        if ((slope0 <= 0 && slope1 <= 0) ||
            (slope0 > 0 && slope1 > 0) ||
            step0->dir == 0 ||
            step0->dir == 4)
            {
            if (slope0 > slope1)
                curve = -4;
            }
        else
            // (dir == 2 || dir == 6) && slopes with different signs
            {
            if (slope0 <= slope1)
                curve = -4;
            }
        }

    return(curve);
}

BYTE ZillaCode(LONG x1, LONG y1, LONG x2, LONG y2)
{
    LONG dx, dy, m;

    dx = (LONG)(x2 - x1);
    dy = (LONG)(y2 - y1);

    if (dx == 0)
    {
        if (dy >= 0)
            return(1);  // Vertical line.
        else
            return(6);
    }

    dy *= 1000;
    m = dy / dx;

    if (dx > 0)
    {
        if (m < -1000)     // 45 degrees
            return(6);
        else if (m < 400)
            return(0);
        else if (m < 2000)
            return(3);
        else
            return(1);
    }
    else
    {
        if (m > 333)
            return(3);
        else if (m > -333)
            return(0);
        else if (m > -3000)
            return(2);
        else
            return(1);
    }
}

void ZillaAddStepsKPROTO(KPROTO *kproto, STEP *rgstep, int cstep, int nframe)
{
    int istep;
    int cwise;   // How much clockwise it's turned in octants
	int ccwise;  // How much counter-clockwise it's turned in octants 
	int curve;   // Delta octants for this step
	int cfeat, x, y, state, dir;
    BOOL fOneMoreFeature;   // Need ???
    BOOL fNextPrim;			// We are ready to start the next feature (at start, or inflection, heavy cusp).
    LPRECT lprect;		// Pointer to glyph bounding box.
    FEAT *feat = NULL;  // Pointer to the current feature.

    ASSERT(cstep > 0);

    cfeat	= kproto->cfeat;
    lprect	= &(kproto->rect);

    fOneMoreFeature	= TRUE;
    fNextPrim		= TRUE;  // beginning primitive of stroke

    for (istep = 0; ; istep++)
    {
        if (fNextPrim)
        {
            state = -1;

            // generate a new primitive

            fNextPrim	= FALSE;
            cwise		= 0;
            ccwise		= 0;

            feat		= &(kproto->rgfeat[cfeat]);
			feat->iframe = (WORD)nframe;

            //
            // The array of primitives is CPRIMMAX in size so
            // the largest index it can handle is (CPRIMMAX-1),
            // otherwise we fault.
            //

            if (cfeat < (CPRIMMAX - 1))
            {
                cfeat++;
            }

            x = GetStepXRGSTEP(rgstep, istep);
            y = GetStepYRGSTEP(rgstep, istep);

            SetXbeginFEAT(feat, x);
            SetYbeginFEAT(feat, y);

            SetXminFEAT(feat, x);
            SetXmaxFEAT(feat, x);
            SetYminFEAT(feat, y);
            SetYmaxFEAT(feat, y);

            feat->feature = FEATURE_NULL;
        }

        x = GetStepXRGSTEP(rgstep, istep + 1);
        y = GetStepYRGSTEP(rgstep, istep + 1);

		// Record end of feature so far.

		SetXendFEAT(feat, x);
		SetYendFEAT(feat, y);

		// Expand the bounding rectangles for the feature and the glyph.			

        if (x > GetXmaxFEAT(feat))
            SetXmaxFEAT(feat, x);
        else if (x < GetXminFEAT(feat))
            SetXminFEAT(feat, x);

        if (y > GetYmaxFEAT(feat))
            SetYmaxFEAT(feat, y);
        else if (y < GetYminFEAT(feat))
            SetYminFEAT(feat, y);

        if (GetXminFEAT(feat) < lprect->left)
            lprect->left = GetXminFEAT(feat);
        if (GetXmaxFEAT(feat) > lprect->right)
            lprect->right = GetXmaxFEAT(feat);
        if (GetYminFEAT(feat) < lprect->top)
            lprect->top = GetYminFEAT(feat);
        if (GetYmaxFEAT(feat) > lprect->bottom)
            lprect->bottom = GetYmaxFEAT(feat);

		// Check if we are done.			
        
        if (istep == cstep - 1)
            break;

        if (state >= -1)
        {
            dir = (int)rgstep[istep].dir;
            ASSERT(dir >= 0 && dir <= 7);

            if ((state == -1 || state >= 6) && dir >= 6)
                state = dir;
            else if (state <= 1 && dir <= 1)
                state = dir;
            else if (state >= 6 && dir == 0)
                state = 4;
            else if (state == 0 && dir >= 6)
                state = 5;
            else if (state == 4 && dir <= 2)
                ;
            else if (state == 5 && dir >= 5)
                ;
            else
                state = -2;
        }

        fOneMoreFeature = TRUE;

        curve = ZillaCurvatureFromSteps(&(rgstep[istep]), &(rgstep[istep + 1]));

        if (curve == 0)
            continue;

        if (curve > 0)
            cwise += curve;
        else
            ccwise -= curve;

        if (cwise > 1 || ccwise > 1)
        {
            fNextPrim = TRUE;   // Time to start new feature.

            if (cwise > 1 && ccwise > 1 && feat->feature != FEATURE_NULL)
            {
                // inflection point
            }
            else if (cwise >= 8 || ccwise >= 8)
            {
                // more than 360 degrees
            }
            else if (cwise > 1)
            {
                if (feat->feature != 4)
                    ccwise = 0;

                feat->feature = 4;
                fOneMoreFeature = FALSE;
                fNextPrim = FALSE;
            }
            else if (ccwise > 1)
            {
                if (feat->feature != 5)
                    cwise = 0;

                feat->feature = 5;
                fOneMoreFeature = FALSE;
                fNextPrim = FALSE;
            }
        }
    }

    ASSERT(feat);

    // Is there a missing feature we need to add?

    if (fOneMoreFeature && feat->feature == FEATURE_NULL)
    {
        feat->feature = ZillaCode(GetXbeginFEAT(feat), GetYbeginFEAT(feat),
                             GetXendFEAT(feat), GetYendFEAT(feat));
    }

    if (state == 5 &&
        feat->feature == 4 && 
        (cfeat - kproto->cfeat == 1))
    {
        feat->feature = FEAT_UP_RIGHT_CORNER;
    }
    else if (state == 4 &&
             feat->feature == 5 && 
             (cfeat - kproto->cfeat == 1))
    {
        feat->feature = FEAT_DOWN_LEFT_CORNER;
    }

    kproto->cfeat = (WORD)cfeat;
}

/******************************Public*Routine******************************\
* PrimitivesFromKPROTO
*
* Converts steps into primitives.
*
* History:
*  15-Aug-1996 -by- Patrick Haluptzok patrickh
* Use BIGPRIM structure.
\**************************************************************************/

int ZillaPrimitivesFromKPROTO(KPROTO *kproto, BIGPRIM *rgprim, RECT *lprect)
{
    unsigned ifeat;
    int dx, dy;
    LONG xlast, ylast, x, y;
    FEAT *feat;
    BIGPRIM *prim;

    ASSERT(kproto->cfeat > 0);

    dx = lprect->right - lprect->left + 1;
    dy = lprect->bottom - lprect->top + 1;

    for (ifeat = 0; ifeat < kproto->cfeat; ifeat++)
    {
        feat = &(kproto->rgfeat[ifeat]);
        prim = &(rgprim[ifeat]);

        ASSERT(feat->feature >= 0 && feat->feature <= 15);
		feat->feature = min(feat->feature,15);
		feat->feature = max(feat->feature,0);

        xlast = GetXendFEAT(feat);
        ylast = GetYendFEAT(feat);

        x = ((xlast - (LONG)(lprect->left)) * 16) / (LONG)dx;
        ASSERT(x >= 0 && x <= 15);
		x = min(x, 15);
		x = max(x, 0);

        y = ((ylast - (LONG)(lprect->top)) * 16) / (LONG)dy;
        ASSERT(y >= 0 && y <= 15);
		y = min(y,15);
		y = max(y,0);

        prim->x2 = (unsigned)x;
        prim->y2 = (unsigned)y;

        x = ((GetXbeginFEAT(feat) - (LONG)(lprect->left)) * 16) / (LONG)dx;
        ASSERT(x >= 0 && x <= 15);
		x = min(x,15);
		x = max(x, 0);

        y = ((GetYbeginFEAT(feat) - (LONG)(lprect->top)) * 16) / (LONG)dy;
        ASSERT(y >= 0 && y <= 15);
		y = min(y, 15);
		y = max(y, 0);

        prim->x1 = (unsigned)x;
        prim->y1 = (unsigned)y;

        prim->code = feat->feature;

        // is it a small feature?
        x = GetXmaxFEAT(feat) - GetXminFEAT(feat);
        y = GetYmaxFEAT(feat) - GetYminFEAT(feat);

        if (x * 6 <= dx && y * 6 <= dy)
        {
            prim->code += 9;
        }
    }

    return((int)kproto->cfeat);
}

// Rebuild the glyph so that the strokes match up to the features.  E.g. any time a stroke has
// more than one feature, split it up into multiple strokes.
BOOL RebuildGlyphFromKproto(GLYPH **ppglOld, KPROTO *pkp)
{
	GLYPH  *pglOld = *ppglOld;
	GLYPH  *pglNew = (GLYPH *) NULL;
	GLYPH  *prev;
	GLYPH  *curr = (GLYPH *) NULL;
	FRAME  *frame;
	FRAME  *build = (FRAME *) NULL;
	int		ifeat;
	int		iframe;
	int		nframe;
	UINT	start;
	UINT	final;
	UINT	count;

	frame  = pglOld->frame;
	prev   = (GLYPH *) NULL;
	start  = 0;
	iframe = 0;
	nframe = 0;

	for (ifeat = 0; ifeat < pkp->cfeat; ifeat++)
	{
	// Did this feature move to the next frame?

		if (pkp->rgfeat[ifeat].iframe != iframe)
		{
			pglOld = pglOld->next;
			frame  = pglOld->frame;
			start  = 0;
			iframe++;
		}

	// Create a new glyph and frame 

		if ((build = NewFRAME()) == (FRAME *) NULL)
			goto cleanup;

		if ((curr = NewGLYPH()) == (GLYPH *) NULL)
			goto cleanup;

		curr->next  = (GLYPH *) NULL;
		curr->frame = build;

	// Count the number of points in the feature

		final = start + 1;

		while ((final < frame->csmoothxy) && ((frame->rgsmoothxy[final].x != pkp->rgfeat[ifeat].ptEnd.x) || (frame->rgsmoothxy[final].y != pkp->rgfeat[ifeat].ptEnd.y)))
			final++;

		if (final >= frame->csmoothxy)
			final = frame->csmoothxy - 1;

//		if (final == start)
//			continue;

		count = final - start + 1;

		if ((build->rgrawxy = (XY *) ExternAlloc(count * sizeof(XY))) == (XY *) NULL)
			goto cleanup;

	// Copy the relevant information to the newly build frame

		build->info = frame->info;
		build->info.cPnt = count;
		memcpy(build->rgrawxy, &frame->rgsmoothxy[start], count * sizeof(XY));
		RectFRAME(build);
		build->iframe = nframe++;

	// Move the start index to the end of what we just copied

		start = final;

	// Link this into the list of glyphs

		if (prev == (GLYPH *) NULL)
			pglNew = curr;
		else
			prev->next = curr;

		prev = curr;
		curr = (GLYPH *) NULL;
	}

// If we made it this far we've built a new GLYPH.  Destroy the old one and update the address

	pglOld = *ppglOld;
	DestroyFramesGLYPH(pglOld);
    DestroyGLYPH(pglOld);
   *ppglOld = pglNew;

	return TRUE;

// If we made it here we ran out of memory.  Blow the new glyph and return the old one.

cleanup:

	DestroyFramesGLYPH(pglNew);
	DestroyGLYPH(pglNew);

	if (curr)
	{
		DestroyFramesGLYPH(curr);
		DestroyGLYPH(curr);
	}
	else if (build)
		DestroyFRAME(build);

	return FALSE;
}

void Ink2HoundFeatures(RECT *pRect, GLYPH *pGlyph, BYTE *pHoundFeat)
{
	int			xShift, yShift, xScaleBy, yScaleBy;
	int			iStroke, cStroke;

	// The shift
	xShift	= - pRect->left;
	yShift	= - pRect->top;

	// The scaling
	xScaleBy	= pRect->right - pRect->left + 1;
	yScaleBy	= pRect->bottom - pRect->top + 1;

	// Strokes
	cStroke		= CframeGLYPH(pGlyph);
	for (iStroke = 0; iStroke < cStroke; iStroke++)
	{
		int		cPntsInk;
		POINT	*pPntsInk;
		int		xBegin, xMid, xEnd;
		int		yBegin, yMid, yEnd;

		cPntsInk	= pGlyph->frame->info.cPnt;
		pPntsInk	= pGlyph->frame->rgrawxy;

		ASSERT(cPntsInk > 0);

		// Get begin point
		xBegin	= pPntsInk[0].x;
		yBegin	= pPntsInk[0].y;

		// Get end point
		xEnd	= pPntsInk[cPntsInk - 1].x;
		yEnd	= pPntsInk[cPntsInk - 1].y;

		// Get mid point for smaller number of strokes..
		if (cStroke > MAX_HOUND_STROKES_USE_MIDPOINT)
		{
			// Don't want mid points.
		}
		else if (cPntsInk == 1)
		{
			// Deal with degnereate line.
			xMid = pPntsInk[0].x;
			yMid = pPntsInk[0].y;
		}
		else
		{
			double	dblXdiff, dblYdiff, dblMidLength, dblLength;
			double	dblLengthBefore,dblLegRatio;
			int		jj;

			// Make prefast happy.
			dblLengthBefore	= 0.0;

			// The length of stroke
			dblLength = 0.0;
			for (jj = 1; jj < cPntsInk; jj++) 
			{
				dblXdiff = pPntsInk[jj].x - pPntsInk[jj-1].x;
				dblYdiff = pPntsInk[jj].y - pPntsInk[jj-1].y;

				dblLength += sqrt(dblXdiff * dblXdiff + dblYdiff * dblYdiff);			
			}

			// The mid-point
			dblMidLength = dblLength / 2.0;

			dblLength = 0.0;
			for (jj = 1; jj < cPntsInk; jj++) 
			{
				dblLengthBefore = dblLength;

				dblXdiff = pPntsInk[jj].x - pPntsInk[jj-1].x;
				dblYdiff = pPntsInk[jj].y - pPntsInk[jj-1].y;

				dblLength += sqrt(dblXdiff * dblXdiff + dblYdiff * dblYdiff);	
				
				if (dblLength >= dblMidLength)
				{
					break;
				}
			}

			dblLegRatio = (dblMidLength - dblLengthBefore) / (dblLength - dblLengthBefore);

			xMid = (int)(pPntsInk[jj-1].x + dblLegRatio * (pPntsInk[jj].x - pPntsInk[jj-1].x));
			yMid = (int)(pPntsInk[jj-1].y + dblLegRatio * (pPntsInk[jj].y - pPntsInk[jj-1].y));

			// Go to next stroke.
			pGlyph	= pGlyph->next;
		}

		// Scale results and save in feature array.
		*pHoundFeat++	= ((xBegin + xShift) * 16) / xScaleBy;
		*pHoundFeat++	= ((yBegin + yShift) * 16) / yScaleBy;
		if (cStroke <= MAX_HOUND_STROKES_USE_MIDPOINT)
		{
			*pHoundFeat++	= ((xMid + xShift) * 16) / xScaleBy;
			*pHoundFeat++	= ((yMid + yShift) * 16) / yScaleBy;
		}
		*pHoundFeat++	= ((xEnd + xShift) * 16) / xScaleBy;
		*pHoundFeat++	= ((yEnd + yShift) * 16) / yScaleBy;
	}
}

/******************************Public*Routine******************************\
* FeaturizeGLYPH
*
* Converts the ink in the GLYPH to a feature array.
*
* History:
*  15-May-1996 -by- Patrick Haluptzok patrickh
* Perf changes, don't hit the heap.
\**************************************************************************/

int ZillaFeaturize(GLYPH **glyph, BIGPRIM *rgprim, BYTE *pHoundFeat)
{
    KPROTO kproto;
    int stepsize, iframe, cframe, cstep, cprim;
    STEP rgstep[FRAME_MAXSTEPS];
    FRAME *frame;

    ASSERT(*glyph);

    memset(&kproto, 0, sizeof(KPROTO)); // 0 init structure
    ZillaInitializeKPROTO(&kproto);          // Set rectangle invalid in struct

	//
	// The step size is the minimum of the minimum extent of the character
	// divided by 16 or 5.
	//

    stepsize	= ZillaGetStepsizeGLYPH(*glyph);
    cframe		= CframeGLYPH(*glyph);

    for (iframe = 0; iframe < cframe; iframe++)
    {
        frame = FrameAtGLYPH(*glyph, iframe);
        cstep = ZillaStepsFromFRAME(frame, stepsize, rgstep, FRAME_MAXSTEPS);

		if (!cstep)
			return 0;

        cstep = ZillaSmoothSteps(rgstep, cstep, cframe);

        ZillaAddStepsKPROTO(&kproto, rgstep, cstep, iframe);
    }

	if (!RebuildGlyphFromKproto(glyph, &kproto))
		return 0;

#	if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
		// Build up hound features.
		Ink2HoundFeatures(&kproto.rect, *glyph, pHoundFeat);
#	endif
    
	cprim = ZillaPrimitivesFromKPROTO(&kproto, rgprim, &kproto.rect);

    return(cprim);
}

/******************************Public*Routine******************************\
* FeaturizeGLYPH
*
* Converts the ink in the GLYPH to a feature array.
*
* History:
*  15-May-1996 -by- Patrick Haluptzok patrickh
* Perf changes, don't hit the heap.
\**************************************************************************/

int ZillaFeaturize2(GLYPH **glyph, BIGPRIM *rgprim, RECT *prc)
{
    KPROTO	kproto;
    int		stepsize, iframe, cframe, cstep, cprim;
    STEP	rgstep[FRAME_MAXSTEPS];
    FRAME  *frame;
	RECT	rc;
	int		dist, mind;
#if 0
	int		mindX, mindY;
	int		ink, box;
#endif

    ASSERT(*glyph);

    memset(&kproto, 0, sizeof(KPROTO)); // 0 init structure
    ZillaInitializeKPROTO(&kproto);          // Set rectangle invalid in struct

	//
	// The step size is the minimum of the minimum extent of the character
	// divided by 16 or 5.
	//

    stepsize	= ZillaGetStepsizeGLYPH(*glyph);
    cframe		= CframeGLYPH(*glyph);

    for (iframe = 0; iframe < cframe; iframe++)
    {
        frame = FrameAtGLYPH(*glyph, iframe);
        cstep = ZillaStepsFromFRAME(frame, stepsize, rgstep, FRAME_MAXSTEPS);

		if (!cstep)
			return 0;

        cstep = ZillaSmoothSteps(rgstep, cstep, cframe);

        ZillaAddStepsKPROTO(&kproto, rgstep, cstep, iframe);
    }

	if (!RebuildGlyphFromKproto(glyph, &kproto))
		return 0;

// Compute the min distance of ink from edge of bounding rect

#if 0
	mindX = kproto.rect.left - prc->left;
	dist = prc->right - kproto.rect.right;
	if (dist < mindX)
		mindX = dist;

	mindY = kproto.rect.top - prc->top;
	dist = prc->bottom - kproto.rect.bottom;
	if (dist < mindY)
		mindY = dist;
#else
	mind = kproto.rect.left - prc->left;
	dist = prc->right - kproto.rect.right;
	if (dist < mind)
		mind = dist;

	dist = kproto.rect.top - prc->top;
	if (dist < mind)
		mind = dist;

	dist = prc->bottom - kproto.rect.bottom;
	if (dist < mind)
		mind = dist;
#endif

// OK, we now have the minimum distance to an edge. scale this by the ratio of the ink box to the bounding box

#if 0
	ink = kproto.rect.right - kproto.rect.left;
	if (ink < kproto.rect.bottom - kproto.rect.top)
		ink = kproto.rect.bottom - kproto.rect.top;

	box = prc->right - prc->left;
	if (box < prc->bottom - prc->top)
		box = prc->bottom - prc->top;

	mind = (mind * ink) / box;
#endif

// Now, build a new adjusted guide box.
#if 0
	rc.left   = prc->left   + mindX;
	rc.right  = prc->right  - mindX;
	rc.top    = prc->top    + mindY;
	rc.bottom = prc->bottom - mindY;
#elif 1
	rc.left   = prc->left   + mind;
	rc.right  = prc->right  - mind;
	rc.top    = prc->top    + mind;
	rc.bottom = prc->bottom - mind;
#else
	rc.left   = prc->left;
	rc.right  = prc->right;
	rc.top    = prc->top ;
	rc.bottom = prc->bottom ;
#endif

    cprim = ZillaPrimitivesFromKPROTO(&kproto, rgprim, &rc);

    return(cprim);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\jumbo.c ===
/**************************************************************************\
* FILE: zilla.c
*
* Zilla shape classifier entry and support routines
*
* History:
*  12-Dec-1996 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
* (mostly from algo.c)
\**************************************************************************/

#include "zillap.h"
#include "jumbotool.h"

/******************************* Variables *******************************/

extern PROTOHEADER		mpcfeatproto[CPRIMMAX];

extern int				g_iCostTableSize;
extern COST_TABLE		g_ppCostTable;
extern BYTE			*pGeomCost;

extern BOOL			g_bNibbleFeat;			// are primitives stored as nibbles (TRUE) or Bytes (FALSE)

int JumboMatch(
	ALT_LIST	*pAlt, 
	int			cAlt, 
	GLYPH		**ppGlyph, 
	CHARSET		*pCS, 
	FLOAT		zillaGeo, 
	DWORD		*pdwAbort, 
	DWORD		cstrk, 
	int			nPartial, 
	RECT		*prc
) {
	int		cprim;
	int		index, jndex;
	BIGPRIM	rgprim[CPRIMMAX];
	MATCH	rgMatch[MAX_ZILLA_NODE];
	FLOAT	score;

	// We will not accept a partial mode for now
	if (nPartial != 0)
	{
		cprim = 0;
		return FALSE;
	}

	cprim = JumboFeaturize(ppGlyph, rgprim);

	if (!cprim)
		return FALSE;

    memset(rgMatch, 0, sizeof(MATCH) * MAX_ZILLA_NODE);

// Call the apropriate shape matching algorithm

	MatchPrimitivesMatch(rgprim, cprim, rgMatch, MAX_ZILLA_NODE, pCS, zillaGeo, pdwAbort, cstrk);
	
// Now, copy the results to the passed in alt-list

	jndex = 0;

	for (index = 0; (rgMatch[index].sym && (index < MAX_ZILLA_NODE) && (jndex < cAlt)); index++)
	{
		// this is a hack to convert the zilla shape recognition dist
		// to as close to the mars shape cost range as possible...

		score  = (FLOAT) rgMatch[index].dist / (FLOAT) cprim;
		score /= (FLOAT) -15.0;

		pAlt->aeScore[jndex]	= score;
		pAlt->awchList[jndex]	= rgMatch[index].sym;
		jndex++;
	}

	pAlt->cAlt = jndex;
	return jndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zillafl.c ===
/***********************************************************************************************\
 * FILE: ZillaFl.c
 *
 *	Code to load and unload Zilla tables from files.
\***********************************************************************************************/
#include <stdio.h>
#include "common.h"
#include "zilla.h"
#include "zillap.h"

static LOAD_INFO g_ZillaDB;
static LOAD_INFO g_CostCalcDB;
static LOAD_INFO g_GeoStatsDB;

// Load runtime localization information from a file.
BOOL
ZillaLoadFile(LOCRUN_INFO * pLocRunInfo, wchar_t * pPath, BOOL fOpenTrainTxt)
{
	BYTE			*pByte;
	wchar_t			aFile[128];

	InitLoadInfo(&g_ZillaDB);
	InitLoadInfo(&g_CostCalcDB);
	InitLoadInfo(&g_GeoStatsDB);

	// Load the main zilla database.  Optional for tools that need  costcalc and
	// geostat information while building main train database.
	if (fOpenTrainTxt) {
		// Generate path to file.
		FormatPath(aFile, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"zilla.dat");

		pByte	= DoOpenFile(&g_ZillaDB, aFile);
		if (!pByte || !ZillaLoadFromPointer(pLocRunInfo, pByte)) {
			return FALSE;
		}
	}

	// Generate path to file.
	FormatPath(aFile, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"costcalc.bin");

	// Load the costcalc table.
	pByte	= DoOpenFile(&g_CostCalcDB, aFile);
	if (!pByte || !CostCalcLoadFromPointer(pByte)) {
		return FALSE;
	}

	// Generate path to file.
	FormatPath(aFile, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"geostats.bin");

	// Load the geostat table.
	pByte	= DoOpenFile(&g_GeoStatsDB, aFile);
	if (!pByte || !GeoStatLoadFromPointer(pByte)) {
		return FALSE;
	}

	return TRUE;
}

BOOL
ZillaUnLoadFile() 
{
	BOOL ok = TRUE;
	if (!CostCalcUnloadFromPointer()) {
		ok = FALSE;
	}
	if (!DoCloseFile(&g_ZillaDB)) {
		ok = FALSE;
	}
	if (!DoCloseFile(&g_CostCalcDB)) {
		ok = FALSE;
	}
	if (!DoCloseFile(&g_GeoStatsDB)) {
		ok = FALSE;
	}
	return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\matchtrn.c ===
/**************************************************************************\
* FILE: matchtrn.c
*
* Zilla shape matcher routines for training
*
* WARNING: This is almost identical to match.c, so fixes need to be
* propagated to both.
*
* History:
*  12-Dec-1996 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
* (mostly from algo.c)
*   1-Jan-1997 -by- John Bennett jbeen
* Split training version from match only version. Note that there is no
* Pegasus version of the training code.
\**************************************************************************/

#include "zillap.h"

/********************** Constants ***************************/

#define DIST_MAX                9999

/******************************** Macros ********************************/

#define SMALLSQUARE(x) (rgbDeltaSq[(x) + 15])

static const int	rgbDeltaSq[] = {
	225,196,169,144,121,100,81,64,49,36,25,16,9,4,1,
	0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225
};

#define SetTraininfoMATCH(pmatchIn, pproto) ((pmatchIn)->ptraininfo = (pproto)->ptraininfo)
#define IsNoisyPROTOTYPE(protoIn) (IsNoisyLPTRAININFO(protoIn.ptraininfo))

/******************************* Procedures ******************************/

/******************************Public*Routine******************************\
* GetDynamicProto
*
* Prototypes in the dynamic database are stored in a slightly compressed
* format.  We need to convert them to the big format for MatchPrimitives.
*
* History:
*  14-Aug-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BIGPRIM aGlobalDynamic[CPRIMMAX];

void GetDynamicProto(
	PROTOHEADER   *pphdr,
	UINT          cprim,
	UINT          iproto,
	BIGPROTOTYPE  *proto)
{
    PBIGPRIM pprimDst;
    PBIGPRIM pprimStop;
    PPRIMITIVE pprimSrc;
    UINT imatch;
    
    imatch = iproto - pphdr->cprotoRom;	
    ASSERT(imatch < pphdr->cprotoDynamic);

    proto->dbc = pphdr->rgdbcDynamic[imatch];
    proto->recmask = LocRunDense2ALC(&g_locRunInfo, proto->dbc);

    SetTraininfoPROTO((*proto), (pphdr), iproto);

    pprimDst = proto->rgprim = aGlobalDynamic;
    pprimStop = pprimDst + cprim;
    pprimSrc = &(pphdr->rgprimDynamic[cprim * imatch]);

    while (pprimDst < pprimStop)
    {
        pprimDst->code = pprimSrc->code;
        pprimDst->x1   = (BYTE) pprimSrc->x1;
        pprimDst->x2   = (BYTE) pprimSrc->x2;
        pprimDst->y1   = (BYTE) pprimSrc->y1;
        pprimDst->y2   = (BYTE) pprimSrc->y2;

        pprimSrc++;
        pprimDst++;
    }
}

/******************************Public*Routine******************************\
* MatchPrimitivesTrn
*
* Finds the closest matching primitives in the database.
*
* History:
*  16-Apr-1995 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

VOID MatchPrimitivesTrain(
	const BIGPRIM	* const pprim,     // Featurized Query
	const UINT	cprim,		// Number of features in query (aka feature space)
	MATCH	* const rgmatch,	// Output: ranked list of characters and distances
	const UINT	cmatchmax,	// size of rgmatch array
	const CHARSET * const cs,		// Allowed character set
	const FLOAT	zillaGeo	// How important geometrics are vs. features.
)
{
    MATCH *pmatch;
    UINT dist, distTotal, distGeo, imatch, cproto, iproto;
    PROTOHEADER *pphdr;
    BIGPROTOTYPE proto;
    const BIGPRIM *p2;
    const BIGPRIM *p1;
    const BIGPRIM *p1End;
    UINT threshold;
    int distmin = cprim * 800;

    pphdr = ProtoheaderFromMpcfeatproto(cprim);
    cproto = (UINT)GetCprotoDynamicPROTOHEADER(pphdr);
    threshold = (UINT)0x00ffffff;

    //
    // Loop through all the prototypes in the space, looking for the best matches.  For
    // each unique character (codepoint) we only keep the best match.  (That is, any character
    // only appears once in the list)
    //

    for (iproto = 0; iproto < cproto; iproto++)
    {
		GetDynamicProto(pphdr, cprim, iproto, &proto);

        #ifdef ZTRAIN

        if (IsNoisyPROTOTYPE(proto))
        {
            continue;
        }

        #endif

        distTotal = 0;

        //
        // Loop through all the features in the character, computing the "directional
        // cost" alone.  We'll use this to decide whether to abort the rest of the computation
        //

        p1 = proto.rgprim;
        p1End = p1 + cprim;
        p2 = pprim;

        do
        {
            distTotal += (int)g_ppCostTable[p1->code][p2->code];

            p1++;
            p2++;

        } while (p1 < p1End);

        if (distTotal >= ((UINT) distmin))     // What happens if we change this the threshold ?
            continue;

        /* Scale the directional cost */

        distTotal = (UINT) (distTotal * (2.0F - zillaGeo));

        p1 = proto.rgprim;
        p2 = pprim;
        distGeo = 0;

        do
        {
            //
            // Now compute and accumulate the geometric difference cost.
            //

            dist = SMALLSQUARE(p1->x1 - p2->x1);
            dist += SMALLSQUARE(p1->x2 - p2->x2);
            dist += SMALLSQUARE(p1->y1 - p2->y1);
            dist += SMALLSQUARE(p1->y2 - p2->y2);

            ASSERT(dist >= 0 && dist <= GEOM_DIST_MAX);

            distGeo += pGeomCost[dist];

            p1++;
            p2++;

        } while (p1 < p1End);

        /* Scale the Geometric costs */

        distGeo = (UINT) (distGeo * zillaGeo);

        distTotal += distGeo;

		/* If this isn't as good as the last thing in the ranked list don't bother
        trying to add it */

        if (distTotal >= threshold)
            continue;

        // find shape to replace (previous occurence of this shape
        // or the last (worst) shape in the array)

        for (imatch = 0; imatch < cmatchmax - 1; imatch++)
        {
            if ((rgmatch[imatch].sym == 0) ||
                (proto.dbc == rgmatch[imatch].sym))
            {
                break;
            }
        }

        // if cloud is better than equivalent (or worst) shape

        if ((rgmatch[imatch].sym == 0) ||
            (distTotal < rgmatch[imatch].dist))
        {
            // then shift down until encountering a better one

            while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
            {
                rgmatch[imatch] = rgmatch[imatch - 1];
                imatch--;
            }

            pmatch = &(rgmatch[imatch]);
            pmatch->sym = proto.dbc;
            pmatch->dist  = distTotal;

            SetTraininfoMATCH(pmatch, &proto);	// ZTRAIN Only

			/* Update the threshold, if we changed the bottom entry */

            if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist < threshold)
                threshold = rgmatch[cmatchmax - 1].dist;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zilla.c ===
/**************************************************************************\
* FILE: zilla.c
*
* Zilla shape classifier entry and support routines
*
* History:
*  12-Dec-1996 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
* (mostly from algo.c)
\**************************************************************************/

#include "zillap.h"
#if defined(USE_HOUND) || defined(USE_ZILLAHOUND)
	#include "math16.h"
	#include "hound.h"
#endif

//#	define	TRAIN_ZILLA_HOUND_COMBINER	1
#ifdef	TRAIN_ZILLA_HOUND_COMBINER
#	include <stdio.h>
#	include <float.h>
	FILE			*g_pDebugFile = 0;
#endif

/******************************* Variables *******************************/

PROTOHEADER		mpcfeatproto[CPRIMMAX];

int				g_iCostTableSize;
COST_TABLE		g_ppCostTable;
BYTE			*pGeomCost = NULL;

BOOL			g_bNibbleFeat;			// are primitives stored as nibbles (TRUE) or Bytes (FALSE)

/******************************Public*Routine******************************\
* GetMatchProbGLYPHSYM
*
* Zilla shape classifier entry point.
*
* History:
*  24-Jan-1995 -by- Patrick Haluptzok patrickh
* Comment it.
*  12-Dec-1996 -by- John Bennett jbenn
* Move over into new Zilla library. Remove glyphsym expansion code.
\**************************************************************************/
int ZillaMatch(
	ALT_LIST	*pAlt, 
	int			cAlt, 
	GLYPH		**ppGlyph, 
	CHARSET		*pCS, 
	FLOAT		zillaGeo, 
	DWORD		*pdwAbort, 
	DWORD		cstrk, 
	int			nPartial, 
	RECT		*prc
) {
	int		cprim;
	int		index, jndex;
	BIGPRIM	rgprim[CPRIMMAX];
	MATCH	rgMatch[MAX_ZILLA_NODE];
	FLOAT	score;
	BYTE	aSampleVector[29 * 4];

#	ifdef TRAIN_ZILLA_HOUND_COMBINER	// Hack code to open file to write Zilla/Hound combiner features to.
		if (!g_pDebugFile)
		{
			g_pDebugFile	= fopen("ZillaHound.txt", "w");
			ASSERT(g_pDebugFile);
		}
#	endif

	if (nPartial)
		cprim = ZillaFeaturize2(ppGlyph, rgprim, prc);
	else
	{
		cprim = ZillaFeaturize(ppGlyph, rgprim, aSampleVector);
	}

	if (!cprim)
		return 0;

    memset(rgMatch, 0, sizeof(MATCH) * MAX_ZILLA_NODE);

// Call the apropriate shape matching algorithm

	switch (nPartial)
	{
	case 0:
		// This is a mess of #if's so that we can include either zilla or hound, or both.
#		if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
			{
				extern BOOL g_fUseZillaHound;

				// For Zilla only or Zilla-Hound we run zilla.
				MatchPrimitivesMatch(rgprim, cprim, rgMatch, MAX_ZILLA_NODE, pCS, zillaGeo, pdwAbort, cstrk);

#				if defined(USE_ZILLAHOUND)
					// We currently do the Hound part of Zilla-Hound for only 3 space.
#					ifndef TRAIN_ZILLA_HOUND_COMBINER	// Code to run combiner
						if (cprim == 3 && g_fUseZillaHound)
						{
							// This updates the zilla results.
							ZillaHoundMatch(rgMatch, cprim, aSampleVector, &g_locRunInfo);
#					else	// Code to generate combiner file.
						if (cprim == 3)
						{
							RREAL	*pZillaHoundNetMemory;
							RREAL	*pCombineFeat;

							pZillaHoundNetMemory = (RREAL *)ExternAlloc(sizeof(RREAL) * 120);
							if (pZillaHoundNetMemory == NULL)
							{
								return 0;
							}

							pCombineFeat	= ZillaHoundFeat(rgMatch, cprim, aSampleVector, pZillaHoundNetMemory, &g_locRunInfo);
							if (pCombineFeat)
							{
								// Print out training records for merging net.
								extern wchar_t		g_CurCharAnswer;

								wchar_t			dchCurChar, dchZilla, dchTemp;
								int				iCorrect, iZilla;

								dchCurChar	= LocRunUnicode2Dense(&g_locRunInfo, g_CurCharAnswer);
								dchTemp		= LocRunDense2Folded(&g_locRunInfo, dchCurChar);
								if (dchTemp > 0)
								{
									dchCurChar	= dchTemp;
								}

								fprintf(g_pDebugFile, "{");
								iCorrect	= 5;
								for (iZilla = 0; iZilla < NUM_ZILLA_HOUND_ALTERNATES; ++iZilla)
								{
									int			iFeat;

									dchZilla	= rgMatch[iZilla].sym;
									if (dchZilla == dchCurChar)
									{
										iCorrect	= iZilla;
									}

									for (iFeat = 0; iFeat < NUM_ZILLA_HOUND_FEATURES; ++iFeat)
									{
										fprintf(g_pDebugFile, " %d", *pCombineFeat++);
									}
								}
								fprintf(g_pDebugFile, " } {%d}\n", iCorrect);
							}
							ExternFree(pZillaHoundNetMemory);
#						endif
					}
#				endif
			}
#		endif
#		if defined(USE_HOUND)
			// Hound only logic.
			{
				HoundMatch(cprim, aSampleVector, pAlt);
				if ((int)pAlt->cAlt > cAlt)
				{
					pAlt->cAlt	= cAlt;
				}
				return pAlt->cAlt;
			}
#		endif
		break;

	case 1:
		// Currently we use zilla unless we are hound only.
#		if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
			{
				MatchStartMatch(rgprim, cprim, rgMatch, MAX_ZILLA_NODE, pCS, pdwAbort, cstrk);
			}
#		endif
#		if defined(USE_HOUND)
			{
				HoundStartMatch(aSampleVector, (BYTE)(cprim * 4), pAlt, pdwAbort, cstrk);
				if ((int)pAlt->cAlt > cAlt)
				{
					pAlt->cAlt	= cAlt;
				}
				return pAlt->cAlt;
			}
#		endif
		break;

	case 2:
		// Currently we use zilla unless we are hound only.
#		if defined(USE_ZILLA) || defined(USE_ZILLAHOUND)
		MatchFreeMatch(rgprim, cprim, rgMatch, MAX_ZILLA_NODE, pCS, pdwAbort, cstrk);
#		endif
#		if defined(USE_HOUND)
			// Don't have code for Hound order free yet!
			return 0;
#		endif
		break;
	}

	// Now, copy the results to the passed in alt-list, unfold tokens as we go.
	jndex = 0;

	for (index = 0; (rgMatch[index].sym && (index < MAX_ZILLA_NODE) && (jndex < cAlt)); index++)
	{
		// this is a hack to convert the zilla shape recognition dist
		// to as close to the mars shape cost range as possible...

		score  = (FLOAT) rgMatch[index].dist / (FLOAT) cprim;
		score /= (FLOAT) -15.0;

		pAlt->aeScore[jndex]	= score;
		pAlt->awchList[jndex]	= rgMatch[index].sym;
		jndex++;

	}

	pAlt->cAlt = jndex;
	return jndex;
}


/******************************Public*Routine******************************\
* ZillaLoadFromPointer
*
* Sets up the Zilla database from a pointer to the .dats.  The .dats may
* be from a locked resource or from a mapped file.
*
* History:
*  20-Mar-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL ZillaLoadFromPointer(LOCRUN_INFO *pLocRunInfo,BYTE *pbRes)
{
	const ZILLADB_HEADER	*pHeader	= (ZILLADB_HEADER *)pbRes;
	PROTOHEADER				*pprotohdr;
	int						ifeat;
	WORD					*rgwCproto;
    int						iOffset = CFEATMAX;	// Offset in WORDS to the beginning of the file.
    int						iIndex, iProto, cProto;
	BYTE					*pbBase;

	if (
		(pHeader->fileType != ZILLADB_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > ZILLADB_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < ZILLADB_OLD_FILE_VERSION)
		|| memcmp (pLocRunInfo->adwSignature, pHeader->adwSignature, sizeof(pLocRunInfo->adwSignature))
	) {
		return FALSE;
	}

	// Clear memory to hold results.
	memset(mpcfeatproto, 0, sizeof(mpcfeatproto));

	// Get pointer to data after the header.
	pbBase		= pbRes + pHeader->headerSize;

	// older version only contain nibble size features
	if (pHeader->curFileVer == ZILLADB_OLD_FILE_VERSION) {
		g_bNibbleFeat	=	TRUE;
	}
	// new version has a field that determines this
	else {
		g_bNibbleFeat	=	(BOOL) *((BOOL *)pbBase);
		pbBase			+=	sizeof (BOOL);
	}

    rgwCproto	= (WORD *)pbBase;

    //
    // First set up the counts and the pointers to the dbcs.
    //

	for (ifeat = 0; ifeat < CFEATMAX; ifeat++)
    {
		if (!rgwCproto[ifeat])
			continue;

        pprotohdr = ProtoheaderFromMpcfeatproto(ifeat);

        pprotohdr->cprotoRom = rgwCproto[ifeat];

        //
        // We need to calculate how much space this takes.
        //

        cProto = (int) ((unsigned int) pprotohdr->cprotoRom);

        pprotohdr->rgdbcRom = rgwCproto + iOffset;

        for (iIndex = 0, iProto = 0; iProto < cProto;)
        {
            if (pprotohdr->rgdbcRom[iIndex] > (g_locRunInfo.cCodePoints + g_locRunInfo.cFoldingSets))
            {
                iProto += (pprotohdr->rgdbcRom[iIndex] - (g_locRunInfo.cCodePoints + g_locRunInfo.cFoldingSets));
                iIndex += 2;
            }
            else
            {
                iProto += 1;
                iIndex += 1;
            }
        }

        iOffset += iIndex;        
    }

    //
    // Now set up the pointers to the geo.
    //

	for (ifeat = 0; ifeat < CFEATMAX; ifeat++)
    {
		if (!rgwCproto[ifeat])
			continue;

        pprotohdr = ProtoheaderFromMpcfeatproto(ifeat);

        pprotohdr->rggeomRom = (GEOMETRIC *) (rgwCproto + iOffset);

        iOffset += (ifeat * pprotohdr->cprotoRom);
    }

    //
    // Now set up the pointers to the features.
    //

    iOffset = iOffset << 1;

	for (ifeat = 0; ifeat < CFEATMAX; ifeat++)
    {
		if (!rgwCproto[ifeat])
			continue;

 		pprotohdr = ProtoheaderFromMpcfeatproto(ifeat);

        pprotohdr->rgfeatRom = (BYTE *) (pbBase + iOffset);

        if (g_bNibbleFeat)
			iOffset += ((ifeat * pprotohdr->cprotoRom + 1) >> 1);
		else
			iOffset += (ifeat * pprotohdr->cprotoRom);
    }

    return TRUE;
}

// Load cost calc information from an image already loaded into memory.
BOOL
CostCalcLoadFromPointer(void *pData)
{
	const COSTCALC_HEADER	*pHeader	= (COSTCALC_HEADER *)pData;
	BYTE					*pScan;
	int						i;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != COSTCALC_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > COSTCALC_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < COSTCALC_OLD_FILE_VERSION)
	) {
		goto error;
	}

	// Fill in pointer to the data in the file
	pScan				=	(BYTE *)pData + pHeader->headerSize;


	// the old format did not have the size written it always assumes it is CPRIM_DIFF
	if (pHeader->curFileVer == COSTCALC_OLD_FILE_VERSION) {
		g_iCostTableSize	=	CPRIM_DIFF;
	}
	else {
		// read the size
		g_iCostTableSize	=	*((int *)pScan);
		pScan				+=	sizeof (g_iCostTableSize);
	}
	
	// allocate necessary memory 
	g_ppCostTable			=	(COST_TABLE) ExternAlloc (g_iCostTableSize * sizeof (BYTE *));
	if (!g_ppCostTable)
		return FALSE;

	// assign pointer values
	for (i = 0; i < g_iCostTableSize; i++) {
		g_ppCostTable[i] 		=	(BYTE *)pScan;
		pScan				+=	(g_iCostTableSize * sizeof (BYTE));
	}
	
	return TRUE;

error:
	return FALSE;
}

BOOL
CostCalcUnloadFromPointer()
{
	if (g_ppCostTable == NULL) {
		return FALSE;
	}
	ExternFree(g_ppCostTable);
	g_ppCostTable = NULL;
	return TRUE;
}

// Load geostat information from an image already loaded into memory.
BOOL
GeoStatLoadFromPointer(void *pData)
{
	const GEOSTAT_HEADER	*pHeader	= (GEOSTAT_HEADER *)pData;
	BYTE					*pScan;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != GEOSTAT_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > GEOSTAT_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < GEOSTAT_OLD_FILE_VERSION)
	) {
		goto error;
	}

	// Fill in pointer to the data in the file
	pScan				= (BYTE *)pData + pHeader->headerSize;
	pGeomCost			= (BYTE *)pScan;

	return TRUE;

error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zillagn.c ===
/************************************************************************************************
 * FILE: LocRunGn.c
 *
 *	Code to generate runtime localization tables in a binary file.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "zilla.h"
#include "zillap.h"
#include "time.h"

// Write a properly formated binary file containing the costcalc information.
BOOL
CostCalcWriteFile(COST_TABLE ppCostTable, int iCostTableSize, FILE *pFile, wchar_t *pLocale)
{
	COSTCALC_HEADER		header;
	DWORD				count;
	int					i;

	// Setup the header
	memset(&header, 0, sizeof(header));
	header.fileType			= COSTCALC_FILE_TYPE;
	header.headerSize		= sizeof(header);
	header.minFileVer		= COSTCALC_MIN_FILE_VERSION;
	header.curFileVer		= COSTCALC_CUR_FILE_VERSION;
	header.locale[0]		= pLocale[0];
	header.locale[1]		= pLocale[1];
	header.locale[2]		= pLocale[2];
	header.locale[3]		= L'\0';

	// Time Stamp
	header.dwTimeStamp		= (DWORD) time (NULL);

	// Write it out.
	if (fwrite(&header, sizeof(header), 1, pFile) != 1) {
		return FALSE;
	}

	// Write out the cost table size
	count	= 1;
	if (fwrite(&iCostTableSize, sizeof(iCostTableSize), count, pFile) != count) {
		return FALSE;
	}

	// Write out the cost table.
	for (i = 0; i < iCostTableSize; i++) {

		count	= iCostTableSize;
		if (fwrite(ppCostTable[i], sizeof(ppCostTable[0][0]), count, pFile) != count) {
			return FALSE;
		}
	}
	
	return TRUE;
}

// Write a properly formated binary file containing the geostat information.
BOOL
GeoStatWriteFile(BYTE *pGeomCost, FILE *pFile, wchar_t *pLocale)
{
	GEOSTAT_HEADER		header;
	DWORD				count;

	// Setup the header
	memset(&header, 0, sizeof(header));
	header.fileType			= GEOSTAT_FILE_TYPE;
	header.headerSize		= sizeof(header);
	header.minFileVer		= GEOSTAT_MIN_FILE_VERSION;
	header.curFileVer		= GEOSTAT_CUR_FILE_VERSION;
	header.locale[0]		= pLocale[0];
	header.locale[1]		= pLocale[1];
	header.locale[2]		= pLocale[2];
	header.locale[3]		= L'\0';

	// Time Stamp
	header.dwTimeStamp		= (DWORD) time (NULL);

	// Write it out.
	if (fwrite(&header, sizeof(header), 1, pFile) != 1) {
		return FALSE;
	}

	// Write out the geostat table.
	count	= GEOM_DIST_MAX + 1;
	if (fwrite(pGeomCost, sizeof(BYTE), count, pFile) != count) {
		return FALSE;
	}
	
	return TRUE;
}

/******************************Public*Routine******************************\
* WriteZillaDat
*
* The compressed dats are written out from the dynamic database.
*
* History:
*  17-Mar-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL WriteZillaDat(LOCRUN_INFO *pLocRunInfo, FILE *pFile, wchar_t *pLocale, BOOL bNibbleFeat)
{
	int				icode;
	BYTE			ilead;
	int				istrk;
	int				iprim;
	int				cproto;
	int				iproto;
    PRIMITIVE		*pprim;
    int				cCountLabel;
    WORD			wLabelLast;
	int				cWritten;
	ZILLADB_HEADER	header;

	// Setup the header
	memset(&header, 0, sizeof(header));
	header.fileType			= ZILLADB_FILE_TYPE;
	header.headerSize		= sizeof(header);
	header.minFileVer		= ZILLADB_MIN_FILE_VERSION;
	header.curFileVer		= ZILLADB_CUR_FILE_VERSION;
	header.locale[0]		= pLocale[0];
	header.locale[1]		= pLocale[1];
	header.locale[2]		= pLocale[2];
	header.locale[3]		= L'\0';

	// copy the LOC Signature
	memcpy (header.adwSignature, pLocRunInfo->adwSignature, sizeof (pLocRunInfo->adwSignature) );

	// Write it out.
	if (fwrite(&header, sizeof(header), 1, pFile) != 1) {
		return FALSE;
	}

	// Write NibbleFeat
	if (fwrite(&bNibbleFeat, sizeof(bNibbleFeat), 1, pFile) != 1) {
		return FALSE;
	}

	// Now actually write out the zilla DB
    for (istrk = 0; istrk < CFEATMAX; istrk++) {
		if (mpcfeatproto[istrk].cprotoDynamic > 0xFFFF) {
			// Number of prototypes won't fit in a WORD!
			return FALSE;
		}
        cproto = mpcfeatproto[istrk].cprotoDynamic;
		if (fwrite(&cproto, sizeof(WORD), 1, pFile) != 1) {
			return FALSE;
		}
    }

    for (istrk = 0; istrk < CFEATMAX; istrk++) {
        cproto = mpcfeatproto[istrk].cprotoDynamic;

        if (cproto == 0) {
            continue;
        }

        cCountLabel = 0;
        wLabelLast = mpcfeatproto[istrk].rgdbcDynamic[0];

        for (iproto = 0; iproto <= cproto; iproto++) {
            if ((iproto == cproto) ||
                (wLabelLast != mpcfeatproto[istrk].rgdbcDynamic[iproto])
			) {
                // Write out the previous label.
                if (cCountLabel != 1) {
					int	cWriteCountLabel;

                    // Write out the count, then the label.
					cWriteCountLabel	
						= cCountLabel + g_locRunInfo.cCodePoints + g_locRunInfo.cFoldingSets;
                    cWritten	= fwrite(&cWriteCountLabel, sizeof(WORD), 1, pFile);
					if (cWritten != 1) {
						return FALSE;
					}
                }

                // Now write out the label.
                cWritten	= fwrite(&wLabelLast, sizeof(WORD), 1, pFile);
				if (cWritten != 1) {
					return FALSE;
				}

                cCountLabel = 0;
                wLabelLast = mpcfeatproto[istrk].rgdbcDynamic[iproto];
            }

            cCountLabel += 1;
        }
    }

    for (istrk = 0; istrk < CFEATMAX; istrk++) {
        cproto = mpcfeatproto[istrk].cprotoDynamic;

        if (cproto) {
            for (iproto = 0; iproto < cproto; iproto++) {
                pprim = (PRIMITIVE *) &mpcfeatproto[istrk].rgprimDynamic[iproto * istrk];

                for (iprim = 0; iprim < istrk; iprim++) {
                    // Always write the geometrics
                    cWritten	= fwrite(&((BYTE *) pprim)[1], 2, 1, pFile);
					if (cWritten != 1) {
						return FALSE;
					}
                    pprim++;
                }
            }
        }
    }

    for (istrk = 0; istrk < CFEATMAX; istrk++) {
        cproto = mpcfeatproto[istrk].cprotoDynamic;

        if (cproto) {
            ilead = 0xff;

            for (iproto = 0; iproto < cproto; iproto++) {
                pprim = (PRIMITIVE *) &mpcfeatproto[istrk].rgprimDynamic[iproto * istrk];

                for (iprim = 0; iprim < istrk; iprim++) {
                    
					// features (prims) are stored in nibbles
					if (bNibbleFeat) {

						// Adjust the code to 0-15 range
						icode = pprim->code;
						if (icode > 15)
							icode -= 9;

						// If this is the first nybble, shift it into place

						if (ilead == 0xff) {
							ilead = icode << 4;
						} else {
							ilead |= icode;

							cWritten	= fwrite(&ilead, 1, 1, pFile);
							if (cWritten != 1) {
								return FALSE;
							}
							ilead = 0xff;
						}
					}
					// features (prims) are stored in bytes
					else  {
						
						ilead = pprim->code;

						cWritten	= fwrite(&ilead, 1, 1, pFile);
						if (cWritten != 1) {
							return FALSE;
						}
					}

                    pprim++;
                }
            }

            if (bNibbleFeat && ilead != 0xff) {
                cWritten	= fwrite(&ilead, 1, 1, pFile);
				if (cWritten != 1) {
					return FALSE;
				}
			}
        }
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zillars.c ===
/************************************************************************************************
 * FILE: ZillaRs.c
 *
 *	Code to load and unload Zilla tables from resources.
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "zilla.h"
#include "zillap.h"

// Load zilla information from a resource.
BOOL
ZillaLoadResource(
	HINSTANCE	hInst,
	int			nResIDDB,		// ID for main Database
	int			nTypeDB,		// Type for main Database
	int			nResIDCost,		// ID for costcalc table
	int			nTypeCost,		// Type for costcalc table
	int			nResIDGeo,		// ID for geostats table
	int			nTypeGeo,		// Type for geostats table
	LOCRUN_INFO *pLocRunInfo
) {
	BYTE		*pByte;

	// Load the main zilla database
	pByte	= DoLoadResource(NULL, hInst, nResIDDB, nTypeDB);
	if (!pByte || !ZillaLoadFromPointer(pLocRunInfo, pByte)) {
		return FALSE;
	}

	// Load the costcalc table.
	pByte	= DoLoadResource(NULL, hInst, nResIDCost, nTypeCost);
	if (!pByte || !CostCalcLoadFromPointer(pByte)) {
		return FALSE;
	}

	// Load the geostat table.
	pByte	= DoLoadResource(NULL, hInst, nResIDGeo, nTypeGeo);
	if (!pByte || !GeoStatLoadFromPointer(pByte)) {
		return FALSE;
	}

	return TRUE;
}

BOOL 
ZillaUnloadResource()
{
	return CostCalcUnloadFromPointer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zillahound.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      zilla/src/ZillaHound.c
//
// Description:
//	    Funcitions to handle combining Zilla and Hound results.
//
// Author:
//      jbenn
//
// Modified by:
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "common.h"
#include "score.h"
#include "hound.h"
#include "zillap.h"
#include "zillatool.h"
#include "runnet.h"
#include "nnet.h"

LOCAL_NET				g_ZillaHoundNet;
ZILLA_HOUND_LOAD_INFO	g_ZillaHoundLoadInfo;

// validates the header of the fugu net
BOOL CheckZillaHoundNetHeader (void *pData)
{
	NNET_HEADER		*pHeader	=	(NNET_HEADER *)pData;

	// wrong magic number
	ASSERT (pHeader->dwFileType == ZILLA_HOUND_FILE_TYPE);

	if (pHeader->dwFileType != ZILLA_HOUND_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= ZILLA_HOUND_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= ZILLA_HOUND_CUR_FILE_VERSION);

	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							g_locRunInfo.adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

	ASSERT (pHeader->cSpace == 1);

    if	(	pHeader->iFileVer >= ZILLA_HOUND_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= ZILLA_HOUND_CUR_FILE_VERSION &&
			!memcmp (	pHeader->adwSignature, 
						g_locRunInfo.adwSignature, 
						sizeof (pHeader->adwSignature)
					) &&
			pHeader->cSpace == 1
		)
    {
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

BOOL ZillaHoundLoadPointer(ZILLA_HOUND_LOAD_INFO *pInfo)
{
	BYTE				*pb = pInfo->info.pbMapping;
	NNET_SPACE_HEADER	*pSpaceHeader;

	// check the header
	if (!CheckZillaHoundNetHeader (pb))
		return FALSE;

	// point to the one and only space that we have
	pSpaceHeader	=	(NNET_SPACE_HEADER *)(pb + sizeof (NNET_HEADER));
	pb				+=	pSpaceHeader->iDataOffset;
    
    if (!restoreLocalConnectNet(pb, 0, &g_ZillaHoundNet))
    {
        return FALSE;
    }

    pInfo->iNetSize = getRunTimeNetMemoryRequirements(pb);
    if (pInfo->iNetSize <= 0)
    {
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////
//
// ZillaHoundLoadFile
//
// Load Zilla/Hound combiner from file
//
// Parameters:
//      wszPath: [in] Path to load from
//
// Return values:
//      TRUE on successful, FALSE otherwise.
//
//////////////////////////////////////
BOOL ZillaHoundLoadFile(wchar_t *wszPath)
{
	wchar_t	wszFile[MAX_PATH];

	// Generate path to file.
	FormatPath(wszFile, wszPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"ZillaHound.bin");

    if (!DoOpenFile(&g_ZillaHoundLoadInfo.info, wszFile)) 
    {
        return FALSE;
    }

    return ZillaHoundLoadPointer(&g_ZillaHoundLoadInfo);
}

///////////////////////////////////////
//
// ZillaHoundUnloadFile
//
// Load otter/fugu/sole combiner from file
//
// Parameters:
//      pInfo: [out] File to unmap
//
// Return values:
//      TRUE on successful, FALSE otherwise.
//
//////////////////////////////////////
BOOL ZillaHoundUnloadFile()
{
    return DoCloseFile(&g_ZillaHoundLoadInfo.info);
}

// Load from a resource.
BOOL ZillaHoundLoadRes(HINSTANCE hInst, int nResID, int nType)
{
    if (DoLoadResource(&g_ZillaHoundLoadInfo.info, hInst, nResID, nType) == NULL)
    {
        return FALSE;
    }

    return ZillaHoundLoadPointer(&g_ZillaHoundLoadInfo);
}

// describe the codepoint
RREAL *CodePointFlagsZH(ALC alc, RREAL *pFeat)
{
    *(pFeat++) = ((alc & ALC_NUMERIC) ? 65535 : 0);
    *(pFeat++) = ((alc & ALC_ALPHA) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_PUNC | ALC_NUMERIC_PUNC | ALC_OTHER)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_HIRAGANA | ALC_JAMO | ALC_BOPOMOFO)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_KATAKANA | ALC_HANGUL_ALL)) ? 65535 : 0);
    *(pFeat++) = ((alc & (ALC_KANJI_ALL)) ? 65535 : 0);

    return pFeat;
}

///////////////////////////////////////
//
// ZillaHoundFeat
//
// Generate feature vector for ZillaHound combiner.  
//
// Parameters:
//		pMatch			[in]  Zilla alt list to modify
//		cPrim:			[in]  The number of zilla primitives being matched.
//      pSampleVector:  [in]  The hound feature vectore.
//      pLocRunInfo:    [in]  Pointer to the locale database
//
// Return value:
//		pointer to feature vector.  Zero means don't run combiner (e.g. both matcher agree).
//
//////////////////////////////////////
RREAL	*
ZillaHoundFeat(
	MATCH		*pMatch,
	int			cPrim,
	BYTE		*pSampleVector,
    RREAL		*pZillaHoundNetMemory,
	LOCRUN_INFO	*pLocRunInfo
)
{
    RREAL		*pFeat;
	ALT_LIST	altHound;
	int			ii;

    pFeat = pZillaHoundNetMemory;
	// Rescore zilla alt list.
	for (ii = 0; pMatch[ii].sym && ii < MAX_ZILLA_NODE; ++ii)
	{
		double	eAltScore;
		if (!HoundMatchSingle(cPrim, pMatch[ii].sym, pSampleVector, &eAltScore))
		{
			return (RREAL *)0;	// Error.
		}
		altHound.aeScore[ii]	= (float)eAltScore;
		altHound.awchList[ii]	= pMatch[ii].sym;
	}
	altHound.cAlt	= ii;
	SortAltList(&altHound);

	// Do we have too few alternates to do this with?  Or do recognizers agree?
	if (altHound.cAlt < NUM_ZILLA_HOUND_ALTERNATES || pMatch[0].sym == altHound.awchList[0])
	{
		// Yes, so just return null to indicate not combiner needed.
		return (RREAL *)0;
	}

	// Build up feature vector.
    for (ii = 0; ii < NUM_ZILLA_HOUND_ALTERNATES; ii++) 
    {
		wchar_t	wchZilla;
		int		iHound;

		wchZilla	= pMatch[ii].sym;
		for (iHound = 0; iHound < (int)altHound.cAlt; ++iHound)
		{
			if (altHound.awchList[iHound] == wchZilla)
			{
				break;
			}
		}
		*(pFeat++) = pMatch[ii].dist * 100 / cPrim;
		*(pFeat++) = (int)(-altHound.aeScore[iHound] * 1000.0);
		*(pFeat++) = (int) (iHound * 5000);
		pFeat = CodePointFlagsZH(LocRun2ALC(pLocRunInfo, wchZilla), pFeat);
	}

	return pZillaHoundNetMemory;
}

///////////////////////////////////////
//
// ZillaHoundMatch
//
// Invoke Zilla/Hound combiner on a character.  
//
// Parameters:
//		pMatch			[in/out]  Zilla alt list to modify
//		cPrim:			[in]  The number of zilla primitives being matched.
//      pSampleVector:  [in]  The hound feature vectore.
//      pLocRunInfo:    [in]  Pointer to the locale database
//
//////////////////////////////////////
void
ZillaHoundMatch(
	MATCH		*pMatch,
	int			cPrim,
	BYTE		*pSampleVector,
	LOCRUN_INFO	*pLocRunInfo
)
{
    RREAL		*pNetOut;
    RREAL		*pFeat;
	ALT_LIST	altCombined;
	int			ii;
    int			iWinner, cOut;
	RREAL		*pZillaHoundNetMemory;

	// Allow featureization when no net has been loaded (needed for training currently).
	if (g_ZillaHoundLoadInfo.iNetSize == 0)
	{
		g_ZillaHoundLoadInfo.iNetSize	= 60;
	}

    pZillaHoundNetMemory = (RREAL *) ExternAlloc(sizeof(RREAL) * g_ZillaHoundLoadInfo.iNetSize);
    if (pZillaHoundNetMemory == NULL)
    {
        return;
    }

	// Generate feature vector for combiner.
	if (!(pFeat = ZillaHoundFeat(pMatch, cPrim, pSampleVector, pZillaHoundNetMemory, pLocRunInfo)))
	{
		// No need to run combiner.
		ExternFree(pZillaHoundNetMemory);
		return;
	}

	// Run the net.
    pNetOut = runLocalConnectNet(&g_ZillaHoundNet, pZillaHoundNetMemory, &iWinner, &cOut);

	// Figure out order returned by the net.
    for (ii = 0; ii < cOut; ii++) 
    {
		altCombined.awchList[ii]	= pMatch[ii].sym;
        altCombined.aeScore[ii]		= (float)(-ProbToScore(*(pNetOut++) / (float) SOFT_MAX_UNITY));
    }
	altCombined.cAlt	= cOut;
	SortAltList(&altCombined);

	// Now overwrite zillas order.
	for (ii = 0; ii < cOut; ++ii)
	{
		pMatch[ii].sym	= altCombined.awchList[ii];
	}

	// Clean up allocated memory.
	ExternFree(pZillaHoundNetMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zillap.h ===
/**************************************************************************\
 * FILE: zillap.h
 *
 * Main include file for stuff private to zilla.lib
\**************************************************************************/

#ifndef ZILLAP_H
#define ZILLAP_H 1

#include "zilla.h"
#include "zillatool.h"

// Sort out which 3 and up stroke recognizer we're using.
#if !defined(USE_HOUND) && !defined(USE_ZILLA) && !defined(USE_ZILLAHOUND)
#	define USE_ZILLA
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define CFEATMAX                CPRIMMAX
#define MAX_ZILLA_NODE          MAX_ALT_LIST   // Max Alt List Size.

/********************** Externs ***************************/

#define GetRgprimDynamicPROTOHEADER(pprotohdr)				\
			((pprotohdr)->rgprimDynamic)
#define SetRgprimDynamicPROTOHEADER(pprotohdr, rgprim)		\
			((pprotohdr)->rgprimDynamic = (rgprim))

#define GetRgdbcDynamicPROTOHEADER(pprotohdr)				\
			((pprotohdr)->rgdbcDynamic)
#define SetRgdbcDynamicPROTOHEADER(pprotohdr, rgdbc)		\
			((pprotohdr)->rgdbcDynamic = (rgdbc))

#define SetDbcDynamicPROTOHEADER(pprotohdr, iproto, wDbc)	\
			((pprotohdr)->rgdbcDynamic[iproto] = (wDbc))

#define GetPprimDynamicPROTOHEADER(pprotohdr, cprim, iproto)	\
			(&((pprotohdr)->rgprimDynamic[(iproto) * (cprim)]))

#define AllocRgptraininfoPPROTOHDR(pprotohdrIn, cprotoIn)       \
	pprotohdrIn->rgptraininfo = (TRAININFO **)ExternAlloc(sizeof(TRAININFO *) * (DWORD)cprotoIn)

#define DestroyRgptraininfoPPROTOHDR(pprotohdrIn)       \
	if (pprotohdrIn->rgptraininfo) ExternFree(pprotohdrIn->rgptraininfo)

#define ReallocRgptraininfoPPROTOHDR(pprotohdrIn, cprotoIn)     \
	pprotohdrIn->rgptraininfo = (TRAININFO **)ExternRealloc((TRAININFO **)pprotohdrIn->rgptraininfo, sizeof(TRAININFO *) * (DWORD)cprotoIn)

#define SetPtraininfoPPROTOHDR(pprotohdrIn, cprotoIn, ptraininfo)       \
	(pprotohdrIn)->rgptraininfo[cprotoIn] = (TRAININFO *)(ptraininfo)

#define ProtoheaderFromMpcfeatproto(cprim)  &(mpcfeatproto[cprim])

extern VOID MatchPrimitivesMatch(
	const BIGPRIM * const pprim,	// Featurized Query
    const UINT		cprim,			// Number of features in query (aka feature space)
    MATCH * const	rgmatch,		// Output: ranked list of characters and distances
    const UINT		cmatchmax,		// size of rgmatch array
    const CHARSET * const cs,		// Allowed character set
    const FLOAT		zillaGeo,		// How important geometrics are vs. features.
	const DWORD   * pdwAbort,		// Address of abort parameter
	const DWORD		cstrk			// Number of strokes in character
);

extern VOID MatchStartMatch(
	const BIGPRIM * const pprim,	// Featurized Query
    const UINT		cprim,			// Number of features in query (aka feature space)
    MATCH * const	rgmatch,		// Output: ranked list of characters and distances
    const UINT		cmatchmax,		// size of rgmatch array
    const CHARSET * const cs,		// Allowed character set
	const DWORD   * pdwAbort,		// Address of abort parameter
	const DWORD		cstrk			// Number of strokes in character
);

extern VOID MatchFreeMatch(
	const BIGPRIM * const pprim,	// Featurized Query
    const UINT		cprim,			// Number of features in query (aka feature space)
    MATCH * const	rgmatch,		// Output: ranked list of characters and distances
    const UINT		cmatchmax,		// size of rgmatch array
    const CHARSET * const cs,		// Allowed character set
	const DWORD   * pdwAbort,		// Address of abort parameter
	const DWORD		cstrk			// Number of strokes in character
);

int ZillaFeaturize2(GLYPH **glyph, BIGPRIM *rgprim, RECT *prc);

//
// Code and data to load generated data
//

// Magic keys the identifies the costcalc and geostat files
#define	ZILLADB_FILE_TYPE	0xAB435902
#define	COSTCALC_FILE_TYPE	0x9A0E35B3
#define	GEOSTAT_FILE_TYPE	0x3E67CD69

// Version information for each file type.
#define	ZILLADB_MIN_FILE_VERSION		1		// First version of code that can read this file
#define ZILLADB_CUR_FILE_VERSION		1		// Current version of code.
#define	ZILLADB_OLD_FILE_VERSION		0		// Oldest file version this code can read.

#define	COSTCALC_MIN_FILE_VERSION		1		// First version of code that can read this file
#define COSTCALC_CUR_FILE_VERSION		1		// Current version of code.
#define	COSTCALC_OLD_FILE_VERSION		0		// Oldest file version this code can read.

#define	GEOSTAT_MIN_FILE_VERSION		0		// First version of code that can read this file
#define GEOSTAT_CUR_FILE_VERSION		0		// Current version of code.
#define	GEOSTAT_OLD_FILE_VERSION		0		// Oldest file version this code can read.

// The header of the costcalc.bin file
typedef struct tagZILLADB_HEADER {
	DWORD		fileType;		// This should always be set to LOCRUN_FILE_TYPE.
	DWORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	wchar_t		locale[4];		// Locale ID string.
	DWORD		adwSignature[3];	// Locale signature
	WORD		reserved1;
	DWORD		reserved2[3];
} ZILLADB_HEADER;

typedef struct tagCOSTCALC_HEADER {
	DWORD		fileType;		// This should always be set to LOCRUN_FILE_TYPE.
	DWORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	wchar_t		locale[4];		// Locale ID string.
	DWORD		dwTimeStamp;	// A creation time stamp
	WORD		reserved1;
	DWORD		reserved2[3];
} COSTCALC_HEADER;

// The header of the geostat.bin file
typedef struct tagGEOSTAT_HEADER {
	DWORD		fileType;		// This should always be set to LOCRUN_FILE_TYPE.
	DWORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	wchar_t		locale[4];		// Locale ID string.
	DWORD		dwTimeStamp;	// A creation time stamp
	WORD		reserved1;
	DWORD		reserved2[3];
} GEOSTAT_HEADER;

// Load and unload fundtions.
BOOL ZillaLoadFromPointer(LOCRUN_INFO *pLocRunInfo, void *pbRes);
BOOL CostCalcLoadFromPointer(void *pByte);
BOOL CostCalcUnloadFromPointer();
BOOL GeoStatLoadFromPointer(void *pByte);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zmatch2.c ===
/**************************************************************************\
* FILE: zmatch2.c
*
* Zilla shape matcher routine to return proto ID instead of code point
* 
* WARNING: This is almost identical to parts of zmatch.c and zilla.c, so
* fixes need to be propigated to both.
*
* History:
*  24-Jan-2000 -by- John Bennett jbenn
* Created file from pieces of zmatch.c
\**************************************************************************/

#include "zillap.h"

/******************************** Macros ********************************/

#define SMALLSQUARE(x) (rgbDeltaSq[(x) + 15])

static const int	rgbDeltaSq[] = {
	225,196,169,144,121,100,81,64,49,36,25,16,9,4,1,
	0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225
};

#define GetCprotoPROTOHEADER(pprotohdr)	((pprotohdr)->cprotoRom)

extern BOOL	g_bNibbleFeat;	// are primitives stored as nibbles (TRUE) or Bytes (FALSE)

/******************************* Procedures ******************************/

/******************************Public*Routine******************************\
* MatchPrimitivesMatch
*
* Finds the closest matching primitives in the database.
*
* History:
*  16-Apr-1995 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

VOID MatchPrimitivesMatch2(
	const BIGPRIM	* const pprim,		// Featurized Query
	const UINT		cprim,				// Number of features in query (aka feature space)
	MATCH			* const rgmatch,	// Output: ranked list of characters and distances
	const UINT		cmatchmax,			// size of rgmatch array
	const CHARSET	* const cs,			// Allowed character set
	const FLOAT		zillaGeo,			// How important geometrics are vs. features.
	const DWORD		* pdwAbort,
	const DWORD		cstrk
)
{
    MATCH		   *pmatch;
    UINT			dist, distTotal, distGeo, imatch, cproto, iproto, iIndex, cLabel;
    PROTOHEADER	   *pphdr;
	PROTOTYPE		proto;
    UINT			threshold;
    int				distmin = cprim * 800;
	BYTE			code;
	BIGPRIM		   *ptemp;
	BIGPRIM		   *pdone;

    //
    // Get a pointer to the list of prototypes in same feature space as query, get a count
    // of the number of prototypes in this space, and initialize the ranked list threshold
    // to guarantee that the first entries go into the list no matter how bad they are.
    //

    pphdr     = ProtoheaderFromMpcfeatproto(cprim);
    cproto    = (UINT) GetCprotoPROTOHEADER(pphdr);
    threshold = (UINT) 0x00ffffff;

    //
    // Loop through all the prototypes in the space, looking for the best matches. For each
    // unique character (codepoint) we only keep the best match.  (That is, any character
    // only appears once in the list)
    //

    for (iproto = 0, iIndex = 0; iproto < cproto;)
    {
		int		minCount;

		// Test the abort address

		if (pdwAbort && (*pdwAbort != cstrk))
			return;

        //
        // Get the label and how many times in a row it occurs decoded.
        //

		minCount	= g_locRunInfo.cCodePoints + + g_locRunInfo.cFoldingSets;
		if (pphdr->rgdbcRom[iIndex] > minCount) {
            cLabel		= pphdr->rgdbcRom[iIndex] - minCount;
            proto.dbc	= pphdr->rgdbcRom[iIndex + 1];
            iIndex		+= 2;
        } else {
            cLabel		= 1;
            proto.dbc	= pphdr->rgdbcRom[iIndex];
            iIndex		+= 1;
        }

        //
        // Test whether this prototype is allowed, based on the character set.
        // This is both a global setting and (optionally) a per-box setting. */
        //

        if (!IsAllowedChar(&g_locRunInfo, cs, proto.dbc))
        {
            iproto += cLabel;
            continue;
        }

        for (; cLabel > 0; iproto++, cLabel--)
        {
			distTotal = 0;

			ptemp = (BIGPRIM *) pprim;
            pdone = ptemp + cprim;

            proto.rggeom  = &pphdr->rggeomRom[iproto * cprim];

			// We might be duplicating some code here, but we thought that's better
			// than putting the 'if (g_bNibbleFeat)' inside the do loop

			// if features are stored as nibbles
			if (g_bNibbleFeat)
			{
	            proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim / 2];
		        proto.nybble  =  (iproto * cprim) & 1;

				// Compare the features in the prototype database to the passed in features
				do
				{
					code = (proto.nybble ? *proto.rgfeat : *proto.rgfeat >> 4) & 0x0f;
					distTotal += (int)g_ppCostTable[ptemp->code][code];

					ptemp++;
					proto.rgfeat += proto.nybble;
					proto.nybble ^= 1;
				} while (ptemp < pdone);
			}
			// features are stored as bytes
			else
			{
				proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim];

				// Compare the features in the prototype database to the passed in features
				do
				{
					distTotal += (int)g_ppCostTable[ptemp->code][*proto.rgfeat];
					ptemp++;
					proto.rgfeat++;
				} while (ptemp < pdone);
			}

            if (distTotal >= ((UINT) distmin))     // What happens if we change this the threshold ?
                continue;

            /* Scale the directional cost */

#			if !defined(WINCE) && !defined(FAKE_WINCE)
				distTotal = (UINT) (distTotal * (2.0F - zillaGeo));
#			else
				distTotal = (distTotal << 1);
				distTotal /=3;
#			endif

            // Now compute and accumulate the geometric difference cost.

            ptemp = (BIGPRIM *) pprim;
            distGeo = 0;

            do
            {
                dist  = SMALLSQUARE(ptemp->x1 - proto.rggeom->x1);
                dist += SMALLSQUARE(ptemp->x2 - proto.rggeom->x2);
                dist += SMALLSQUARE(ptemp->y1 - proto.rggeom->y1);
                dist += SMALLSQUARE(ptemp->y2 - proto.rggeom->y2);

                ASSERT(dist <= GEOM_DIST_MAX);

                distGeo += pGeomCost[dist];

                ptemp++;
                proto.rggeom++;
            } while (ptemp < pdone);

            /* Scale the Geometric costs */

#			if !defined(WINCE) && !defined(FAKE_WINCE)
            distGeo = (UINT) (distGeo * zillaGeo);
			distTotal += distGeo;
#			else
			distGeo	  = (distGeo << 2);
			distGeo   /= 3;
			distTotal += distGeo;
#			endif

            /* If this isn't as good as the last thing in the ranked list don't bother
            trying to add it */

            if (distTotal >= threshold)
                continue;

            // find an empty slot or the last (worst) shape in the array

            for (imatch = 0; imatch < cmatchmax - 1; imatch++)
            {
                if (rgmatch[imatch].sym == 0)
                {
                    break;
                }
            }

            // if cloud is better than equivalent (or worst) shape

            if ((rgmatch[imatch].sym == 0) ||
                (distTotal < rgmatch[imatch].dist))
            {
                // then shift down until encountering a better one

                while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
                {
                    rgmatch[imatch] = rgmatch[imatch - 1];
                    imatch--;
                }

                pmatch = &(rgmatch[imatch]);
                pmatch->sym = iproto + 1;	// Use array index (+1) as ID
                pmatch->dist  = (WORD)distTotal;

                /* Update the threshold, if we changed the bottom entry */

                if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist < threshold)
                    threshold = rgmatch[cmatchmax - 1].dist;
            }
        }
    }
}

/******************************* Variables *******************************/
extern COST_TABLE		g_ppCostTable; // JRB: Why is is this global????
extern BYTE				*pGeomCost;

/******************************Public*Routine******************************\
* GetMatchProbGLYPHSYM
*
* Zilla shape classifier entry point.
*
* History:
*  24-Jan-1995 -by- Patrick Haluptzok patrickh
* Comment it.
*  12-Dec-1996 -by- John Bennett jbenn
* Move over into new Zilla library. Remove glyphsym expansion code.
\**************************************************************************/
int ZillaMatch2(
	ALT_LIST	*pAlt, 
	int			cAlt, 
	GLYPH		**ppGlyph, 
	CHARSET		*pCS, 
	FLOAT		zillaGeo, 
	DWORD		*pdwAbort, 
	DWORD		cstrk, 
	int			nPartial, 
	RECT		*prc
) {
	int		cprim;
	int		index, jndex;
	BIGPRIM	rgprim[CPRIMMAX];
	MATCH	rgMatch[MAX_ZILLA_NODE];
	FLOAT	score;
	BYTE	aSampleVector[29 * 4];

	// Partial modes not currently supported.
	if (nPartial)
		return FALSE;

	cprim = ZillaFeaturize(ppGlyph, rgprim, aSampleVector);

	if (!cprim)
		return FALSE;

    memset(rgMatch, 0, sizeof(MATCH) * MAX_ZILLA_NODE);

	// Call the shape matching algorithm
	MatchPrimitivesMatch2(rgprim, cprim, rgMatch, MAX_ZILLA_NODE, pCS, zillaGeo, pdwAbort, cstrk);

	// Now, copy the results to the passed in alt-list.
	jndex = 0;
	for (index = 0; (rgMatch[index].sym && (index < MAX_ZILLA_NODE) && (jndex < cAlt)); index++)
	{
		// this is a hack to convert the zilla shape recognition dist
		// to as close to the mars shape cost range as possible...
		score  = (FLOAT) rgMatch[index].dist / (FLOAT) cprim;
		score /= (FLOAT) -15.0;

		pAlt->aeScore[jndex]	= score;
		pAlt->awchList[jndex]	= rgMatch[index].sym;
		jndex++;
	}

	pAlt->cAlt = jndex;
	return jndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\zmatch.c ===
/**************************************************************************\
* FILE: zmatch.c
*
* Zilla shape matcher routines (non-train version)
* 
* WARNING: This is almost identical to matchtrn.c, so fixes need to be
*	propigated to both.
*
* History:
*  12-Dec-1996 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
* (mostly from algo.c)
*   1-Jan-1997 -by- John Bennett jbeen
* Split training version from match only version
\**************************************************************************/

#include "zillap.h"

/********************** Constants ***************************/

#define DIST_MAX                9999

/******************************** Macros ********************************/

#define SMALLSQUARE(x) (rgbDeltaSq[(x) + 15])

static const int	rgbDeltaSq[] = {
	225,196,169,144,121,100,81,64,49,36,25,16,9,4,1,
	0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225
};

#define GetCprotoPROTOHEADER(pprotohdr)	((pprotohdr)->cprotoRom)

extern BOOL			g_bNibbleFeat;			// are primitives stored as nibbles (TRUE) or Bytes (FALSE)

/******************************* Procedures ******************************/

/******************************Public*Routine******************************\
* MatchPrimitivesMatch
*
* Finds the closest matching primitives in the database.
*
* History:
*  16-Apr-1995 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

VOID MatchPrimitivesMatch(
	const BIGPRIM	* const pprim,		// Featurized Query
	const UINT		cprim,				// Number of features in query (aka feature space)
	MATCH			* const rgmatch,	// Output: ranked list of characters and distances
	const UINT		cmatchmax,			// size of rgmatch array
	const CHARSET	* const cs,			// Allowed character set
	const FLOAT		zillaGeo,			// How important geometrics are vs. features.
	const DWORD		* pdwAbort,
	const DWORD		cstrk
)
{
    MATCH		   *pmatch;
    UINT			dist, distTotal, distGeo, imatch, cproto, iproto, iIndex, cLabel;
    PROTOHEADER	   *pphdr;
	PROTOTYPE		proto;
    UINT			threshold;
    int				distmin = cprim * 800;
	BYTE			code;
	BIGPRIM		   *ptemp;
	BIGPRIM		   *pdone;

    //
    // Get a pointer to the list of prototypes in same feature space as query, get a count
    // of the number of prototypes in this space, and initialize the ranked list threshold
    // to guarantee that the first entries go into the list no matter how bad they are.
    //

    pphdr     = ProtoheaderFromMpcfeatproto(cprim);
    cproto    = (UINT) GetCprotoPROTOHEADER(pphdr);
    threshold = (UINT) 0x00ffffff;

    //
    // Loop through all the prototypes in the space, looking for the best matches. For each
    // unique character (codepoint) we only keep the best match.  (That is, any character
    // only appears once in the list)
    //

    for (iproto = 0, iIndex = 0; iproto < cproto;)
    {
		int		minCount;

		// Test the abort address

		if (pdwAbort && (*pdwAbort != cstrk))
			return;

        //
        // Get the label and how many times in a row it occurs decoded.
        //

		minCount	= g_locRunInfo.cCodePoints + + g_locRunInfo.cFoldingSets;
		if (pphdr->rgdbcRom[iIndex] > minCount) {
            cLabel		= pphdr->rgdbcRom[iIndex] - minCount;
            proto.dbc	= pphdr->rgdbcRom[iIndex + 1];
            iIndex		+= 2;
        } else {
            cLabel		= 1;
            proto.dbc	= pphdr->rgdbcRom[iIndex];
            iIndex		+= 1;
        }

        //
        // Test whether this prototype is allowed, based on the character set.
        // This is both a global setting and (optionally) a per-box setting. */
        //

        if (!IsAllowedChar(&g_locRunInfo, cs, proto.dbc))
        {
            iproto += cLabel;
            continue;
        }

        for (; cLabel > 0; iproto++, cLabel--)
        {
			distTotal = 0;

			ptemp = (BIGPRIM *) pprim;
            pdone = ptemp + cprim;

            proto.rggeom  = &pphdr->rggeomRom[iproto * cprim];

			// We might be duplicating some code here, but we thought that's better
			// than putting the 'if (g_bNibbleFeat)' inside the do loop

			// if features are stored as nibbles
			if (g_bNibbleFeat)
			{
	            proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim / 2];
		        proto.nybble  =  (iproto * cprim) & 1;

				// Compare the features in the prototype database to the passed in features
				do
				{
					code = (proto.nybble ? *proto.rgfeat : *proto.rgfeat >> 4) & 0x0f;
					distTotal += (int)g_ppCostTable[ptemp->code][code];

					ptemp++;
					proto.rgfeat += proto.nybble;
					proto.nybble ^= 1;
				} while (ptemp < pdone);
			}
			// features are stored as bytes
			else
			{
				proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim];

				// Compare the features in the prototype database to the passed in features
				do
				{
					distTotal += (int)g_ppCostTable[ptemp->code][*proto.rgfeat];
					ptemp++;
					proto.rgfeat++;
				} while (ptemp < pdone);
			}

            if (distTotal >= ((UINT) distmin))     // What happens if we change this the threshold ?
                continue;

            /* Scale the directional cost */

#			if !defined(WINCE) && !defined(FAKE_WINCE)
				distTotal = (UINT) (distTotal * (2.0F - zillaGeo));
#			else
				distTotal = (distTotal << 1);
				distTotal /=3;
#			endif

            // Now compute and accumulate the geometric difference cost.

            ptemp = (BIGPRIM *) pprim;
            distGeo = 0;

            do
            {
                dist  = SMALLSQUARE(ptemp->x1 - proto.rggeom->x1);
                dist += SMALLSQUARE(ptemp->x2 - proto.rggeom->x2);
                dist += SMALLSQUARE(ptemp->y1 - proto.rggeom->y1);
                dist += SMALLSQUARE(ptemp->y2 - proto.rggeom->y2);

                ASSERT(dist <= GEOM_DIST_MAX);

                distGeo += pGeomCost[dist];

                ptemp++;
                proto.rggeom++;
            } while (ptemp < pdone);

            /* Scale the Geometric costs */

#			if !defined(WINCE) && !defined(FAKE_WINCE)
            distGeo = (UINT) (distGeo * zillaGeo);
			distTotal += distGeo;
#			else
			distGeo	  = (distGeo << 2);
			distGeo   /= 3;
			distTotal += distGeo;
#			endif

            /* If this isn't as good as the last thing in the ranked list don't bother
            trying to add it */

            if (distTotal >= threshold)
                continue;

            // find shape to replace (previous occurence of this shape
            // or the last (worst) shape in the array)

            for (imatch = 0; imatch < cmatchmax - 1; imatch++)
            {
                if ((rgmatch[imatch].sym == 0) ||
                    (proto.dbc == rgmatch[imatch].sym))
                {
                    break;
                }
            }

            // if cloud is better than equivalent (or worst) shape

            if ((rgmatch[imatch].sym == 0) ||
                (distTotal < rgmatch[imatch].dist))
            {
                // then shift down until encountering a better one

                while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
                {
                    rgmatch[imatch] = rgmatch[imatch - 1];
                    imatch--;
                }

                pmatch = &(rgmatch[imatch]);
                pmatch->sym = proto.dbc;
                pmatch->dist  = (WORD)distTotal;

                /* Update the threshold, if we changed the bottom entry */

                if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist < threshold)
                    threshold = rgmatch[cmatchmax - 1].dist;
            }
        }
    }

    //
    // If the match wasn't very good we jump into the order free code.  This tries
    // to match features that are most similair together so out of order strokes
    // don't hurt us.
    //
/*
// This stroke independent matching was removed because it hardly made any improvements
// and caused speed degradation
#ifndef WINCE
    if (rgmatch[0].dist > 109 * cprim)
    {
        UINT	iprimk, iprim;
        int		distpartmin,iprimmin;
        int		distpart;
        char	mpifeatmark[CPRIMMAX];

        pphdr = ProtoheaderFromMpcfeatproto(cprim);
        cproto = (UINT)GetCprotoPROTOHEADER(pphdr);

        distmin = 109 * cprim;

        for (iproto = 0, iIndex = 0; iproto < cproto;)
        {
			int		minCount;

			if (pdwAbort && (*pdwAbort != cstrk))
				return;

            //
            // Get the label and how many times in a row it occurs decoded.
            //

			minCount	= g_locRunInfo.cCodePoints + + g_locRunInfo.cFoldingSets;
			if (pphdr->rgdbcRom[iIndex] > minCount) {
				cLabel		= pphdr->rgdbcRom[iIndex] - minCount;
				proto.dbc	= pphdr->rgdbcRom[iIndex + 1];
				iIndex		+= 2;
			} else {
				cLabel		= 1;
				proto.dbc	= pphdr->rgdbcRom[iIndex];
				iIndex		+= 1;
			}

            //
            // Test whether this prototype is allowed, based on the character set.
            // This is both a global setting and (optionally) a per-box setting. 
            //

            if (!IsAllowedChar(&g_locRunInfo, cs, proto.dbc))
            {
                iproto += cLabel;
                continue;
            }

            for (; cLabel > 0; iproto++, cLabel--)
            {
				proto.rggeom  = &pphdr->rggeomRom[iproto * cprim];

				// Here we've put the if statements inside teh loops and 
				// we did not bother to repeat the code because this
				// whole code fragment should be rarely executed when the score
				// is really low
				if (g_bNibbleFeat)
				{
	                proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim / 2];
		            proto.nybble  =  (iproto * cprim) & 1;
				}
				else
				{
					proto.rgfeat  = &pphdr->rgfeatRom[iproto * cprim];
				}

                distTotal = 0;

                memset(mpifeatmark, 0, sizeof(mpifeatmark));

                // Basically we start with the features of the prototype in the
                // dictionary and try and find the closest matching feature in
                // the prototype we are classifying.  This doesn't guarantee the
                // optimal match, but's it way better than nothing.

                for (iprim = 0; iprim < cprim; iprim++)
                {
                    distpartmin = DIST_MAX;
                    iprimmin    = CPRIMMAX + 1;

					if (g_bNibbleFeat)
					{
						code = (proto.nybble ? *proto.rgfeat : *proto.rgfeat >> 4) & 0x0f;
						proto.rgfeat += proto.nybble;
						proto.nybble ^= 1;
					}
					else
					{
						code = *proto.rgfeat;
					}

                    for (iprimk = 0; iprimk < cprim; iprimk++)
                    {
                        int costC;

                        ptemp = (BIGPRIM *) &pprim[iprimk];
                        costC = (int)g_ppCostTable[ptemp->code][code];

                        if ((mpifeatmark[iprimk] > 0) || (costC >= 100))
                            continue;

                        distpart  = SMALLSQUARE(ptemp->x1 - proto.rggeom[iprim].x1);
                        distpart += SMALLSQUARE(ptemp->x2 - proto.rggeom[iprim].x2);
                        distpart += SMALLSQUARE(ptemp->y1 - proto.rggeom[iprim].y1);
                        distpart += SMALLSQUARE(ptemp->y2 - proto.rggeom[iprim].y2);

                        distpart = pGeomCost[distpart];
                        distpart += costC;

                        if (distpart < distpartmin)
                        {
                            distpartmin = distpart;
                            iprimmin = iprimk;
                        }
                    }

                    // not a good match

                    if (iprimmin == CPRIMMAX + 1)
                    {
                        // can we skip this feature?

                        distTotal = DIST_MAX;
                        break;
                    }

                    mpifeatmark[iprimmin] = 1;
                    distTotal += distpartmin;

                    if ((int)distTotal > distmin)
                        break;
                }

                if ((int)distTotal <= distmin)
                {
                    // find shape to replace (previous occurence of this shape
                    // or the last (worst) shape in the array)

                    for (imatch = 0; imatch < cmatchmax - 1; imatch++)
                    {
                        if ((rgmatch[imatch].sym == 0)  || (proto.dbc == rgmatch[imatch].sym))
                            break;
                    }

                    // if cloud is better than equivalent (or worst) shape

                    if ((rgmatch[imatch].sym == 0) ||
                        (distTotal < rgmatch[imatch].dist))
                    {
                        // then shift down until encountering a better one

                        while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
                        {
                            rgmatch[imatch] = rgmatch[imatch - 1];
                            imatch--;
                        }

                        pmatch = &(rgmatch[imatch]);
                        pmatch->sym = proto.dbc;
                        pmatch->dist  = distTotal;

                        if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist <(UINT)distmin)
                            distmin = rgmatch[cmatchmax - 1].dist;
                    }
                }
            }
        }
    }
#endif
*/
}

/******************************Public*Routine******************************\
* MatchStartMatch
*
* Search the database for the characters best represented by the primitives
* being the starting features in a character.
*
* History:
*  29-Apr-1997 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID MatchStartMatch(
const BIGPRIM * const	pprim,		// Featurized Query
const UINT				cprim,		// Number of features in query (aka feature space)
	  MATCH   * const	rgmatch,	// Output: ranked list of characters and distances
const UINT				cmatchmax,	// size of rgmatch array
const CHARSET * const	cs,			// Allowed character set
const DWORD   *			pdwAbort,
const DWORD				cstrk
)
{
    MATCH		   *pmatch;
    UINT			dist, distTotal, distGeo, imatch, cproto, iproto, iIndex, cLabel;
    PROTOHEADER	   *pphdr;
	PROTOTYPE		proto;
    UINT			threshold;
    int				distmin;
	BYTE			code;
	int				iprim;
	BIGPRIM		   *ptemp;
	BIGPRIM		   *pdone;

	threshold = (UINT) 0x00ffffff;
	iprim = max(3, cprim);

	while (iprim < 30)
	{
		pphdr     = ProtoheaderFromMpcfeatproto(iprim);
		cproto    = (UINT) GetCprotoPROTOHEADER(pphdr);
		distmin   = cprim * 800;

	// Loop through all the prototypes in the space, looking for the best matches. For each
	// unique character (codepoint) we only keep the best match.  (That is, any character
	// only appears once in the list)

		for (iproto = 0, iIndex = 0; iproto < cproto;)
		{
			int		minCount;

			// Test the abort address

			if (pdwAbort && (*pdwAbort != cstrk))
				return;

			// Get the label and how many times in a row it occurs decoded.

			minCount	= g_locRunInfo.cCodePoints + + g_locRunInfo.cFoldingSets;
			if (pphdr->rgdbcRom[iIndex] > minCount) {
				cLabel		= pphdr->rgdbcRom[iIndex] - minCount;
				proto.dbc	= pphdr->rgdbcRom[iIndex + 1];
				iIndex		+= 2;
			} else {
				cLabel		= 1;
				proto.dbc	= pphdr->rgdbcRom[iIndex];
				iIndex		+= 1;
			}

			// Test whether this prototype is allowed, based on the character set.
			// This is both a global setting and (optionally) a per-box setting. */

            if (!IsAllowedChar(&g_locRunInfo, cs, proto.dbc))
			{
				iproto += cLabel;
				continue;
			}

			for (; cLabel > 0; iproto++, cLabel--)
			{
				distTotal = 0;

				ptemp = (BIGPRIM *) pprim;
				pdone = ptemp + cprim;

				proto.rggeom  = &pphdr->rggeomRom[iproto * iprim];
				
				// We might be duplicating some code here, but we thought that's better
				// than putting the 'if (g_bNibbleFeat)' inside the do loop

				// if features are stored as nibbles
				if (g_bNibbleFeat)
				{
					proto.rgfeat  = &pphdr->rgfeatRom[iproto * iprim / 2];
					proto.nybble  =  (iproto * iprim) & 1;

					// Compare the features in the prototype database to the passed in features
					do
					{
						code = (proto.nybble ? *proto.rgfeat : *proto.rgfeat >> 4) & 0x0f;
						distTotal += (int)g_ppCostTable[ptemp->code][code];

						ptemp++;
						proto.rgfeat += proto.nybble;
						proto.nybble ^= 1;
					} while (ptemp < pdone);
				}
				// features are stored as bytes
				else
				{
					proto.rgfeat  = &pphdr->rgfeatRom[iproto * iprim];

					// Compare the features in the prototype database to the passed in features
					do
					{
						distTotal += (int)g_ppCostTable[ptemp->code][*proto.rgfeat];
						ptemp++;
						proto.rgfeat++;
					} while (ptemp < pdone);
				}


				if (distTotal >= ((UINT) distmin))     // What happens if we change this the threshold ?
					continue;

				//distTotal = (int) (distTotal * (2.0- 1.33333));
				// Now compute and accumulate the geometric difference cost.

				ptemp = (BIGPRIM *) pprim;
				distGeo = 0;

				do
				{
					dist  = SMALLSQUARE(ptemp->x1 - proto.rggeom->x1);
					dist += SMALLSQUARE(ptemp->x2 - proto.rggeom->x2);
					dist += SMALLSQUARE(ptemp->y1 - proto.rggeom->y1);
					dist += SMALLSQUARE(ptemp->y2 - proto.rggeom->y2);

					ASSERT(dist <= GEOM_DIST_MAX);

					distGeo += pGeomCost[dist];

					ptemp++;
					proto.rggeom++;
				} while (ptemp < pdone);

				//distTotal += (int) (distGeo * 1.3333333);

				distTotal += distGeo;

				/* If this isn't as good as the last thing in the ranked list don't bother
				trying to add it */

				if (distTotal >= threshold)
					continue;

				// find shape to replace (previous occurence of this shape
				// or the last (worst) shape in the array)

				for (imatch = 0; imatch < cmatchmax - 1; imatch++)
				{
					if ((rgmatch[imatch].sym == 0) ||
						(proto.dbc == rgmatch[imatch].sym))
					{
						break;
					}
				}

				// if cloud is better than equivalent (or worst) shape

				if ((rgmatch[imatch].sym == 0) ||
					(distTotal < rgmatch[imatch].dist))
				{
					// then shift down until encountering a better one

					while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
					{
						rgmatch[imatch] = rgmatch[imatch - 1];
						imatch--;
					}

					pmatch = &(rgmatch[imatch]);
					pmatch->sym = proto.dbc;
					pmatch->dist  = (WORD)distTotal;

					/* Update the threshold, if we changed the bottom entry */

					if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist < threshold)
						threshold = rgmatch[cmatchmax - 1].dist;
				}
			}
		}

		iprim++;
	}
}

/******************************Public*Routine******************************\
* MatchFreeMatch
*
* Search the database for the characters best represented by the primitives
* being any features in a character.  No order is assumed.
*
* History:
*  29-Apr-1997 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID MatchFreeMatch(
const BIGPRIM * const	pprim,		// Featurized Query
const UINT				cprim,		// Number of features in query (aka feature space)
	  MATCH   * const	rgmatch,	// Output: ranked list of characters and distances
const UINT				cmatchmax,	// size of rgmatch array
const CHARSET * const	cs,			// Allowed character set
const DWORD   *			pdwAbort,
const DWORD				cstrk
)
{
    MATCH		   *pmatch;
    UINT			dist, distTotal, imatch, cproto, iproto, iIndex, cLabel;
    PROTOHEADER	   *pphdr;
	PROTOTYPE		proto;
    UINT			threshold;
    int				distmin;
	BYTE			code;
	BIGPRIM		   *ptemp;
	BIGPRIM		   *pdone;
	BYTE			maskprim[30];
	BYTE			order[30];
	int				primBest;
	int				distBest;
	int				distTry;
	int				penalty;
	UINT			iprim;
	UINT			jprim;
	UINT			kprim;

	threshold = (UINT) 0x00ffffff;
	iprim = max(3, cprim);	

	while (iprim < 30)
	{
		pphdr     = ProtoheaderFromMpcfeatproto(iprim);
		cproto    = (UINT) GetCprotoPROTOHEADER(pphdr);
		distmin   = cprim * 800;

		// Loop through all the prototypes in the space, looking for the best matches. For each
		// unique character (codepoint) we only keep the best match.  (That is, any character
		// only appears once in the list)


		for (iproto = 0, iIndex = 0; iproto < cproto;)
		{
			int		minCount;

			// Test the abort address

			if (pdwAbort && (*pdwAbort != cstrk))
				return;

			//
			// Get the label and how many times in a row it occurs decoded.
			//

			minCount	= g_locRunInfo.cCodePoints + + g_locRunInfo.cFoldingSets;
			if (pphdr->rgdbcRom[iIndex] > minCount) {
				cLabel		= pphdr->rgdbcRom[iIndex] - minCount;
				proto.dbc	= pphdr->rgdbcRom[iIndex + 1];
				iIndex		+= 2;
			} else {
				cLabel		= 1;
				proto.dbc	= pphdr->rgdbcRom[iIndex];
				iIndex		+= 1;
			}

			//
			// Test whether this prototype is allowed, based on the character set.
			// This is both a global setting and (optionally) a per-box setting. */
			//

            if (!IsAllowedChar(&g_locRunInfo, cs, proto.dbc))
			{
				iproto += cLabel;
				continue;
			}

			for (; cLabel > 0; iproto++, cLabel--)
			{
				distTotal = 0;

			// Compare each feature to all the remaining features in the prototype from the database.
			// Pick the best one and add its distance to the score

				memset(maskprim, '\0', sizeof(maskprim));

				ptemp = (BIGPRIM *) pprim;
				pdone = ptemp + cprim;
				jprim = 0;

				do
				{
					proto.rggeom  = &pphdr->rggeomRom[iproto * iprim];

					// nibble features
					if (g_bNibbleFeat)
					{
						proto.rgfeat  = &pphdr->rgfeatRom[iproto * iprim / 2];
						proto.nybble  =  (iproto * iprim) & 1;
					}
					else
						proto.rgfeat  = &pphdr->rgfeatRom[iproto * iprim];

					distBest = 0x0fffffff;

					for (kprim = 0; kprim < iprim; kprim++)
					{
						if (!maskprim[kprim])
						{
							if (g_bNibbleFeat)
								code = (proto.nybble ? *proto.rgfeat : *proto.rgfeat >> 4) & 0x0f;
							else
								code = *proto.rgfeat;

							distTry = (int) g_ppCostTable[ptemp->code][code];

							dist  = SMALLSQUARE(ptemp->x1 - proto.rggeom->x1);
							dist += SMALLSQUARE(ptemp->x2 - proto.rggeom->x2);
							dist += SMALLSQUARE(ptemp->y1 - proto.rggeom->y1);
							dist += SMALLSQUARE(ptemp->y2 - proto.rggeom->y2);

							distTry += pGeomCost[dist];

							if (distTry < distBest)
							{
								distBest = distTry;
								primBest = kprim;
							}
						}

						proto.rggeom++;

						if (g_bNibbleFeat)
						{
							proto.rgfeat += proto.nybble;
							proto.nybble ^= 1;
						}
						else
							proto.rgfeat++;
					}

					distTotal += distBest;
					maskprim[primBest] = TRUE;
					order[jprim++] = (BYTE)primBest;

					ptemp++;
				} while (ptemp < pdone);

				// OK, now run down the list order.  Strokes in an unexpected order gain a penalty

				kprim   = 0;		// Expected stroke
				penalty = 0;		// Total unexpected events

				for (jprim = 0; jprim < cprim; jprim++)
				{
					if (kprim != order[jprim])
						penalty++;

					kprim = order[jprim] + 1;	// We expect the next stroke to follow this one
				}

				// Adjust the score by the penalty

				penalty   *= 16;
				distTotal += penalty;

				/* If this isn't as good as the last thing in the ranked list don't bother
				trying to add it */

				if (distTotal >= threshold)
					continue;

				// find shape to replace (previous occurence of this shape
				// or the last (worst) shape in the array)

				for (imatch = 0; imatch < cmatchmax - 1; imatch++)
				{
					if ((rgmatch[imatch].sym == 0) ||
						(proto.dbc == rgmatch[imatch].sym))
					{
						break;
					}
				}

				// if cloud is better than equivalent (or worst) shape

				if ((rgmatch[imatch].sym == 0) ||
					(distTotal < rgmatch[imatch].dist))
				{
					// then shift down until encountering a better one

					while (imatch > 0 && distTotal < rgmatch[imatch - 1].dist)
					{
						rgmatch[imatch] = rgmatch[imatch - 1];
						imatch--;
					}

					pmatch = &(rgmatch[imatch]);
					pmatch->sym = proto.dbc;
					pmatch->dist  = (WORD)distTotal;

					/* Update the threshold, if we changed the bottom entry */

					if (rgmatch[cmatchmax - 1].sym && rgmatch[cmatchmax - 1].dist < threshold)
						threshold = rgmatch[cmatchmax - 1].dist;
				}
			}
	    }

		iprim++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\wisp\public\sdk\inc\tpcver.h ===
#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif
#define VER_PRODUCTBUILD 2201
#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif
#define VER_PRODUCTBUILD_QFE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\zilla\src\ztrain.c ===
/**************************************************************************\
* FILE: ztrain.c
*
* Training routines routines
*
* History:
*   8-Jan-1997 -by- John Bennett jbenn
* Created file from pieces in the old integrated tsunami recognizer
\**************************************************************************/

#include "common.h"
#include "zillap.h"

/******************************Public*Routine******************************\
* ComputeZillaSize
*
* Returns the size of the Zilla database.
*
* History:
*  04-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int ComputeZillaSize(void)
{
    PROTOHEADER *pprotohdr;
    int iprim, iproto, cproto;    
    WORD wLabelLast;

    int iSize = 60; // 30 * 2 for count of prototypes.

    for (iprim = 0; iprim < CPRIMMAX; iprim++)
    {
        pprotohdr = ProtoheaderFromMpcfeatproto(iprim);
        cproto = GetCprotoDynamicPROTOHEADER(pprotohdr);

        iSize += (cproto * 2 * iprim);  // For the geos.
        iSize += (((cproto * iprim) + 1) >> 1);  // For the features.

        //
        // A bit trickier to compute the size of the stored labels.
        //

        wLabelLast = 0;

        for (iproto = 0; iproto < cproto; iproto++)
        {
            if (wLabelLast != pprotohdr->rgdbcDynamic[iproto])
            {
                iSize += 2;  // Need space for the label.

                wLabelLast = pprotohdr->rgdbcDynamic[iproto];

                //
                // Check if there more than 1, if there is we need
                // a count to (first goes the count !).
                //

                if (iproto < cproto - 1)
                {
                    if (wLabelLast == pprotohdr->rgdbcDynamic[iproto + 1])
                    {
                        iSize += 2;
                    }
                }
            }
        }
    }

    return(iSize);
}

/******************************Public*Routine******************************\
* CountPrototypes
*
* Counts how many prototypes there are.
*
* History:
*  05-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int CountPrototypes(void)
{
	DWORD cproto;
	PROTOHEADER *pprotohdr;
    LONG iprim;
    int cTotal;

    cTotal = 0;

    for (iprim = 0; iprim < CPRIMMAX; iprim++)
    {
        pprotohdr = ProtoheaderFromMpcfeatproto(iprim);

        cproto = GetCprotoDynamicPROTOHEADER(pprotohdr);

        cTotal += cproto;
    }

    return(cTotal);
}

BOOL PUBLIC AddPrototypeToDatabase(BIGPRIM *pprim, int cprim, WORD wDbcs, VOID *pti)
{
	WORD wToken;
    int cproto, iprim, cprotoAlloc;
    WORD *pnewdbc;
    PPRIMITIVE pnewprim;
    PROTOHEADER *pprotohdr;
    BOOL fAlloc = FALSE;
    TRAININFO FAR *ptraininfo;

    if (wToken = LocRunDense2Folded(&g_locRunInfo, wDbcs))
    {
        wDbcs = wToken;
    }

    //
    // We grow this guy by 4096 at a time, not too tricky but make sure
    // you understand how this works before modifying the code.
    //

	pprotohdr = ProtoheaderFromMpcfeatproto(cprim);
    cproto = GetCprotoDynamicPROTOHEADER(pprotohdr);

	if (cproto > 0) {
        if ((cproto >> 12) != ((cproto + 1) >> 12)) {
            cprotoAlloc = cproto + 1 + 4096;

            pnewprim = (PPRIMITIVE)ExternRealloc(GetRgprimDynamicPROTOHEADER(pprotohdr),
                                (DWORD)cprotoAlloc * (DWORD)cprim * sizeof(PRIMITIVE));
            if (pnewprim) {
                pnewdbc = (PWORD)ExternRealloc(GetRgdbcDynamicPROTOHEADER(pprotohdr),
                                                            sizeof(WORD) * (DWORD)cprotoAlloc);
                if (pnewdbc) {
                    ReallocRgptraininfoPPROTOHDR(pprotohdr, cprotoAlloc);
					if (pprotohdr->rgptraininfo) {
						fAlloc = TRUE;
					}
                }
            }
        } else {
            pnewprim = GetRgprimDynamicPROTOHEADER(pprotohdr);
            pnewdbc = GetRgdbcDynamicPROTOHEADER(pprotohdr);
            fAlloc = TRUE;
        }
    } else {
        cprotoAlloc = 4096;

        pnewprim = (PPRIMITIVE)ExternAlloc(cprotoAlloc * (DWORD)cprim * sizeof(PRIMITIVE));

		if (pnewprim) {
            pnewdbc = (PWORD)ExternAlloc(cprotoAlloc * (DWORD)sizeof(WORD));

			if (pnewdbc) {
                AllocRgptraininfoPPROTOHDR(pprotohdr, cprotoAlloc);
				if (pprotohdr->rgptraininfo) {
					fAlloc = TRUE;
				} else {
					ExternFree(pnewdbc);
					ExternFree(pnewprim);
				}
            } else {
				ExternFree(pnewprim);
			}
        }
    }

    cprotoAlloc = cproto + 1;
	
	if (fAlloc)
    {
		SetRgprimDynamicPROTOHEADER(pprotohdr, pnewprim);
		SetRgdbcDynamicPROTOHEADER(pprotohdr, pnewdbc);
		
		SetDbcDynamicPROTOHEADER(pprotohdr, cproto, wDbcs);
		pnewprim = GetPprimDynamicPROTOHEADER(pprotohdr, cprim, cproto);
		for (iprim = 0; iprim < cprim; iprim++) {
			pnewprim[iprim].code = pprim[iprim].code;
			pnewprim[iprim].x1 = pprim[iprim].x1;
			pnewprim[iprim].x2 = pprim[iprim].x2;
			pnewprim[iprim].y1 = pprim[iprim].y1;
			pnewprim[iprim].y2 = pprim[iprim].y2;
        }
		
		ptraininfo = (TRAININFO FAR *)pti;
		
		SetPtraininfoPPROTOHDR(pprotohdr, cproto, ptraininfo);

		if (pti) {
			if (LocRunIsFoldedCode(&g_locRunInfo, wDbcs)) {
				ASSERT(wDbcs == LocRunDense2Folded(&g_locRunInfo, ptraininfo->wclass));
			} else {
				ASSERT(wDbcs == ptraininfo->wclass);
			}
        }
		
		SetCprotoDynamicPROTOHEADER(pprotohdr, cprotoAlloc);
    }

	return(fAlloc);
}

/******************************Public*Routine******************************\
* EliminateBadTrainAcc
*
* Removes any prototypes that give the database on the train set a worse
* score.
*
* History:
*  05-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void EliminateBadTrainAcc(void)
{
	DWORD iproto, iprotoNew, cproto;
	PROTOTYPE proto;
	PROTOHEADER *pprotohdr;
	LONG iprim, iprimNew;
	PPRIMITIVE pprimitive;

 	for (iprim = 1; iprim < CPRIMMAX; iprim++)
    {
 		pprotohdr = ProtoheaderFromMpcfeatproto(iprim);
		cproto = GetCprotoDynamicPROTOHEADER(pprotohdr);

        iprotoNew = 0;

 		for (iproto = 0; iproto < cproto; ++iproto)
        {
 			PrototypeFromPROTOHEADER(pprotohdr, iprim, iproto, proto);

			ASSERT(proto.ptraininfo);

			if (proto.ptraininfo == 0)
                continue;

			if (iprim <= 4)
            {
                if (proto.ptraininfo->chits <= proto.ptraininfo->cmishits)
					continue;
            }
            else if (proto.ptraininfo->chits < proto.ptraininfo->cmishits)
            {
                continue;
            }

 			if (!IsNoisyLPTRAININFO(proto.ptraininfo))
            {
                //
                // It's not noisy so move it up to next position.
                //

 				if (iproto != iprotoNew)
                {
 					pprotohdr->rgdbcDynamic[iprotoNew] = proto.dbc;
 					pprimitive = &(pprotohdr->rgprimDynamic[iprotoNew * iprim]);
 					for (iprimNew = 0; iprimNew < iprim; iprimNew++)
 						pprimitive[iprimNew] = proto.rgprim[iprimNew];
 					pprotohdr->rgptraininfo[iprotoNew] = proto.ptraininfo;
                }

 				iprotoNew++;
            }
        }

        SetCprotoDynamicPROTOHEADER(pprotohdr, iprotoNew);
    }
}

/******************************Public*Routine******************************\
* SortDatabaseByLabel
*
* This thing looks like a real hack to sort the database, but it works.
*
* History:
*  05-Nov-1996 -by- Patrick Haluptzok patrickh
* Comment block it.
\**************************************************************************/

// Hack access to logfile since we can't pass it in.
static FILE *g_fpLog;

static int __cdecl SortbyLabel(const void *arg1, const void *arg2)
{
    int iret;
	TRAININFO *lpti1, *lpti2;

	lpti1 = *(TRAININFO **)arg1;
	lpti2 = *(TRAININFO **)arg2;

    if (lpti1->wclass > lpti2->wclass)
    {
        iret = 1;
    }
    else if (lpti1->wclass < lpti2->wclass)
    {
        iret = -1;
    }
    else
    {
        PPRIMITIVE pprim1, pprim2;
        int iprim;

        pprim1 = (PPRIMITIVE) lpti1->cmishits;
        pprim2 = (PPRIMITIVE) lpti2->cmishits;
        iret = 0;

        for (iprim = 0; iprim < lpti1->cattempts; iprim++)
        {
            if (pprim1[iprim].code > pprim2[iprim].code)
            {
                iret = 1;
                break;
            }

            if (pprim1[iprim].code < pprim2[iprim].code)
            {
                iret = -1;
                break;
            }

            if (pprim1[iprim].rgch[0] > pprim2[iprim].rgch[0])
            {
                iret = 1;
                break;
            }

            if (pprim1[iprim].rgch[0] < pprim2[iprim].rgch[0])
            {
                iret = -1;
                break;
            }

            if (pprim1[iprim].rgch[1] > pprim2[iprim].rgch[1])
            {
                iret = 1;
                break;
            }

            if (pprim1[iprim].rgch[1] < pprim2[iprim].rgch[1])
            {
                iret = -1;
                break;
            }
        }
    }

#if 0	// jbenn: Hack so that we can run.  Should actually get the file
		// pointer defined before this code executes.
    if (iret == 0) {
        fwprintf(g_fpLog, L"1Dup class %x cprim %d index %d\n",
			lpti1->wclass, lpti1->cattempts, lpti1->chits
		);
        fwprintf(g_fpLog, L"2Dup class %x cprim %d index %d\n",
			lpti2->wclass, lpti2->cattempts, lpti2->chits
		);
    }
#endif

	return(iret);
}

static BOOL SortDatabaseByLabel(VOID)
{
    int iprim, iproto;
    int cproto;
	PROTOHEADER *pprotohdr;
    TRAININFO **rgpti, **ptrainNew;
    TRAININFO *rgti;
    PWORD pwordNew, pwordOld;
    PPRIMITIVE pprimNew, pprimOld;

  	for (iprim = 1; iprim < CPRIMMAX; iprim++)
    {
  		pprotohdr = ProtoheaderFromMpcfeatproto(iprim);

        cproto = (int)GetCprotoDynamicPROTOHEADER(pprotohdr);

        if (cproto == 0)
        {
            continue;
        }
        ASSERT(pprotohdr->rgptraininfo);

        rgti = (TRAININFO *)ExternAlloc(cproto * sizeof(TRAININFO));
        rgpti = (TRAININFO **)ExternAlloc(cproto * sizeof(TRAININFO *));

		if (!rgpti || !rgpti) {
			return FALSE;
		}

        //
        // Mark each traininfo with it's current order.
        //

        pprimOld = pprotohdr->rgprimDynamic;
        pwordOld = pprotohdr->rgdbcDynamic;

        for (iproto = 0; iproto < cproto; iproto++)
        {
            rgpti[iproto] = &rgti[iproto];
            rgpti[iproto]->wclass = pprotohdr->rgptraininfo[iproto]->wclass;
            rgpti[iproto]->chits = iproto;
            rgpti[iproto]->cmishits = (int) (pprimOld + (iprim * iproto));
            rgpti[iproto]->cattempts = iprim;
        }

        qsort(rgpti, (size_t)cproto, (size_t)sizeof(TRAININFO *), SortbyLabel);

        //
        // Now copy them into the sorted order.
        //

        pprimNew = ExternAlloc(cproto * iprim * sizeof(PRIMITIVE));
        pwordNew = ExternAlloc(cproto * sizeof(WORD));
        ptrainNew = (TRAININFO **)ExternAlloc(cproto * sizeof(TRAININFO *));
		if (!pprimNew || !pwordNew || !ptrainNew) {
			return FALSE;
		}
        pprimOld = pprotohdr->rgprimDynamic;
        pwordOld = pprotohdr->rgdbcDynamic;

        for (iproto = 0; iproto < cproto; iproto++)
        {
            ptrainNew[iproto] = pprotohdr->rgptraininfo[rgpti[iproto]->chits];
            pwordNew[iproto] = pwordOld[rgpti[iproto]->chits];
            memcpy(pprimNew + (iprim * iproto),
                   pprimOld + (iprim * rgpti[iproto]->chits),
                   iprim * sizeof(PRIMITIVE));
        }
		
		ExternFree(pprimOld);
		ExternFree(pwordOld);
        ExternFree(pprotohdr->rgptraininfo);
        ExternFree(rgti);
        ExternFree(rgpti);

        pprotohdr->rgptraininfo = ptrainNew;
		pprotohdr->rgprimDynamic = pprimNew;
		pprotohdr->rgdbcDynamic = pwordNew;
    }

	return TRUE;
}

/******************************Public*Routine******************************\
* TrimDatabase
*
* We delete from the database any prototype that has
*
* History:
*  23-Mar-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL TrimDatabase(VOID)
{
    EliminateBadTrainAcc();
    return SortDatabaseByLabel();
}

VOID FreeDynamicMpcfeatproto(VOID)
{
	register int iprim;
	PROTOHEADER *pprotohdr;

	for (iprim = 1; iprim < CPRIMMAX; iprim++)
    {
		pprotohdr = &mpcfeatproto[iprim];

		if (pprotohdr->cprotoDynamic)
        {
            if ((PWORD)pprotohdr->rgdbcDynamic)
            {
                ExternFree((PWORD)pprotohdr->rgdbcDynamic);
				pprotohdr->rgdbcDynamic = NULL;
            }
			if ((PPRIMITIVE)pprotohdr->rgprimDynamic)
            {
				ExternFree((PPRIMITIVE)pprotohdr->rgprimDynamic);
				pprotohdr->rgprimDynamic = NULL;
            }
			pprotohdr->cprotoDynamic = 0;

			DestroyRgptraininfoPPROTOHDR(pprotohdr);
        }
    }
}

/******************************Public*Routine******************************\
* WriteTextDatabase()
*
* Writes the database out as a text file.
*
* History:
*  30-Oct-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
*  12-Dec-1997 -by- John Bennett jbenn
* Added error checking to write calls.
\**************************************************************************/

BOOL WriteTextDatabase(FILE *fpText, FILE *fpLog)
{
	PROTOHEADER	*pprotohdr;
    int			cPrim, iPrim, cSamp, iSamp;
	int			writeStatus;
    TRAININFO	*pti;
	PRIMITIVE	*rgprim;

	// Make log file available to sort code.
	g_fpLog	= fpLog;

    for (cPrim = 1; cPrim < CFEATMAX; cPrim++)
    {
        pprotohdr = &mpcfeatproto[cPrim];

        cSamp = pprotohdr->cprotoDynamic;

        for (iSamp = 0; iSamp < cSamp; iSamp++)
        {
            pti = pprotohdr->rgptraininfo[iSamp];

            rgprim = pprotohdr->rgprimDynamic + (iSamp * cPrim);

            writeStatus	= fwprintf(fpText, L"%4.4x %2.2d %2.2d %5.5d %d %d %e %e %e ",
				(int) pti->wclass,
				cPrim,
				(int) pti->cstrokes,
				pti->chits,
				pti->cmishits,
				pti->cattempts,
				pti->eHits,
				pti->eMishits,
				pti->eAttempts
			);
			if (writeStatus < 0) {
				return FALSE;
			}

            for (iPrim = 0; iPrim < cPrim; iPrim++)
            {
                writeStatus	= fwprintf(fpText, L"%.2x", rgprim[iPrim].code);
 				if (writeStatus < 0) {
					return FALSE;
				}
           }

            writeStatus	= fwprintf(fpText, L" ");
			if (writeStatus < 0) {
				return FALSE;
			}

            for (iPrim = 0; iPrim < cPrim; iPrim++)
            {
                writeStatus	= fwprintf(fpText, L"%x%x%x%x", rgprim[iPrim].x1, rgprim[iPrim].y1,
					rgprim[iPrim].x2, rgprim[iPrim].y2
				);
 				if (writeStatus < 0) {
					return FALSE;
				}
           }

            writeStatus	= fwprintf(fpText, L"\n");
			if (writeStatus < 0) {
				return FALSE;
			}
        }
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\wisp\public\sdk\inc\tpcver.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyVersion("1.0.2201.0")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\blt.c ===
/******************************Module*Header*******************************\
* Module Name: blt.c
*
* Contains the low-level blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vFillPat1bpp
*
\**************************************************************************/

VOID vFillPat1bpp(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjBase;
    RBRUSH* prb;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulDwg;
    ULONG   ulHwMix;

    ASSERTDD(rbc.prb->fl & RBRUSH_2COLOR, "Must be 2 colour pattern here");

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if ((rop4 & 0xff) == 0xf0)
    {
        ulDwg = opcode_TRAP + blockm_OFF + atype_RPL + bop_SRCCOPY;
    }
    else
    {
        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        ulDwg = opcode_TRAP + blockm_OFF + atype_RSTR + (ulHwMix << 16);
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Normal opaque mode:

        ulDwg |= transc_BG_OPAQUE;
    }
    else
    {
        // GDI guarantees us that if the foreground and background
        // ROPs are different, the background rop is LEAVEALONE:

        ulDwg |= transc_BG_TRANSP;
    }

    if ((GET_CACHE_FLAGS(ppdev, (SIGN_CACHE | ARX_CACHE))) == (SIGN_CACHE | ARX_CACHE))
    {
        CHECK_FIFO_SPACE(pjBase, 12);
    }
    else
    {
        CHECK_FIFO_SPACE(pjBase, 17);

        CP_WRITE(pjBase, DWG_SGN, 0);
        CP_WRITE(pjBase, DWG_AR1, 0);
        CP_WRITE(pjBase, DWG_AR2, 0);
        CP_WRITE(pjBase, DWG_AR4, 0);
        CP_WRITE(pjBase, DWG_AR5, 0);
    }

    ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE);

    CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);
    CP_WRITE(pjBase, DWG_SHIFT, ((-(pptlBrush->y + yOffset) & 7) << 4) |
                                 (-(pptlBrush->x + xOffset) & 7));

    prb = rbc.prb;
    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, prb->ulColor[1]));
    CP_WRITE(pjBase, DWG_BCOL, COLOR_REPLICATE(ppdev, prb->ulColor[0]));
    CP_WRITE(pjBase, DWG_SRC0, prb->aulPattern[0]);
    CP_WRITE(pjBase, DWG_SRC1, prb->aulPattern[1]);
    CP_WRITE(pjBase, DWG_SRC2, prb->aulPattern[2]);
    CP_WRITE(pjBase, DWG_SRC3, prb->aulPattern[3]);

    while(TRUE)
    {
        CP_WRITE(pjBase, DWG_FXLEFT,  prcl->left   + xOffset);
        CP_WRITE(pjBase, DWG_FXRIGHT, prcl->right  + xOffset);
        CP_WRITE(pjBase, DWG_LEN,     prcl->bottom - prcl->top);
        CP_START(pjBase, DWG_YDST,    prcl->top    + yOffset);

        if (--c == 0)
            return;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vXfer4bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xSrc;
    LONG    iLoop;
    BYTE    jSrc;
    ULONG*  pulXlate;
    ULONG   ulHwMix;
    ULONG   ulCtl;
    LONG    i;
    ULONG   ul;
    LONG    xBug;
    LONG    xAbsLeft;
    BOOL    bHwBug;
    LONG    cjSrc;
    LONG    cwSrc;
    LONG    lSrcSkip;
    LONG    cxRem;
    ULONG   ul0;
    ULONG   ul1;
    ULONG   ulBoardId;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjBase    = ppdev->pjBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulBoardId = ppdev->ulBoardId;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    if (rop4 == 0xcccc)         // SRCCOPY
    {
        ulCtl = (opcode_ILOAD + atype_RPL + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + bop_SRCCOPY);
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulCtl = (opcode_ILOAD + atype_RSTR + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + (ulHwMix << 16));
    }

    if (ulBoardId != MGA_STORM)
    {
        if (cjPelSize >= 3)
        {
            ulCtl |= (hcprs_SRC_24_BPP | bltmod_BUCOL);
            xBug = 0;
        }
        else
        {
            ulCtl |= (bltmod_BFCOL);
            xBug = (8 >> cjPelSize);    // 8bpp and 16bpp have h/w alignment bugs
        }
    }
    else
    {
        ulCtl |= (bltmod_BFCOL);
        xBug = 0;
    }

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, ulCtl);
    CP_WRITE(pjBase, DWG_SHIFT, 0);

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }
    if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
    {
        CP_WRITE(pjBase, DWG_AR5, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt.  AR0 will
    // be modified shortly:

    ppdev->HopeFlags = SIGN_CACHE;

    while(TRUE)
    {
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + prcl->right - 1);
        CP_WRITE(pjBase, DWG_YDST,    yOffset + prcl->top);
        CP_WRITE(pjBase, DWG_LEN,     cy);
        CP_WRITE(pjBase, DWG_AR3,     0);

        xSrc     =  prcl->left + dx;
        pjSrc    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        xAbsLeft = (xOffset + prcl->left);
        CP_WRITE(pjBase, DWG_CXLEFT, xAbsLeft);

        xAbsLeft -= (xSrc & 1);         // Align to start of first source byte
        cx       += (xSrc & 1);

        bHwBug = (ulBoardId != MGA_STORM) && (xAbsLeft & xBug);
        if (!bHwBug)
        {
            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft);
            CP_START(pjBase, DWG_AR0,    cx - 1);
        }
        else
        {
            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft - xBug);
            CP_START(pjBase, DWG_AR0,    cx + xBug - 1);
        }

        cjSrc    = (cx + 1) >> 1;   // Number of source bytes touched
        lSrcSkip = lSrcDelta - cjSrc;

        // Make sure the MGA is ready to take the data:

        CHECK_FIFO_SPACE(pjBase, 32);

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cwSrc = (cjSrc >> 1);    // Number of whole source words

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                for (i = cwSrc; i != 0; i--)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    jSrc = *pjSrc++;
                    ul  |= (pulXlate[jSrc >> 4] << 16);
                    ul  |= (pulXlate[jSrc & 0xf] << 24);
                    CP_WRITE_SRC(pjBase, ul);
                }

                // Handle an odd end byte, if there is one:

                if (cjSrc & 1)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 16);
                    CP_WRITE_SRC(pjBase, ul);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 4)
        {
            cjSrc    = cx >> 1;   // Number of whole source bytes touched
            cxRem    = cx & 1;

            // This part handles 32bpp output:

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                i = cjSrc;
                while (i--)     // may be 0
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    CP_WRITE_SRC(pjBase, ul);
                    ul   = (pulXlate[jSrc & 0xf]);
                    CP_WRITE_SRC(pjBase, ul);
                }
                if (cxRem)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles packed 24bpp output:

            ASSERTDD(!bHwBug, "There is no hardware bug when higher than 16bpp");

            cwSrc = (cx >> 2);      // Number of whole source words
            cxRem = (cx & 3);
            if (cxRem == 3)
            {
                // Merge this case into the whole word case:

                cwSrc++;
                cxRem = 0;
            }

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    jSrc = *pjSrc++;
                    ul0  = (pulXlate[jSrc >> 4]);
                    ul1  = (pulXlate[jSrc & 0xf]);
                    ul   = ul0 | (ul1 << 24);
                    CP_WRITE_SRC(pjBase, ul);

                    jSrc = *pjSrc++;
                    ul0  = (pulXlate[jSrc >> 4]);
                    ul   = (ul1 >> 8) | (ul0 << 16);
                    CP_WRITE_SRC(pjBase, ul);

                    ul1  = (pulXlate[jSrc & 0xf]);
                    ul   = (ul1 << 8) | (ul0 >> 16);
                    CP_WRITE_SRC(pjBase, ul);
                }

                if (cxRem > 0)
                {
                    jSrc = *pjSrc++;
                    ul0  = (pulXlate[jSrc >> 4]);
                    ul1  = (pulXlate[jSrc & 0xf]);
                    ul   = ul0 | (ul1 << 24);
                    CP_WRITE_SRC(pjBase, ul);

                    if (cxRem > 1)
                    {
                        ul = (ul1 >> 8);
                        CP_WRITE_SRC(pjBase, ul);
                    }
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
        {
            // Restore the clipping:

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_CXLEFT, 0);
            return;
        }

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 7);
    }
}

/******************************Public*Routine******************************\
* VOID vXfer8bpp
*
* Does a 8bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 8bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vXfer8bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xSrc;
    LONG    iLoop;
    ULONG*  pulXlate;
    ULONG   ulHwMix;
    ULONG   ulCtl;
    LONG    i;
    ULONG   ul;
    LONG    xBug;
    LONG    xAbsLeft;
    BOOL    bHwBug;
    LONG    cwSrc;
    LONG    cdSrc;
    LONG    lSrcSkip;
    LONG    cxRem;
    ULONG   ul0;
    ULONG   ul1;
    ULONG   ulBoardId;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_8BPP, "Source must be 8bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pxlo->pulXlate != NULL, "Must be a translate");

    pjBase    = ppdev->pjBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulBoardId = ppdev->ulBoardId;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    if (rop4 == 0xcccc)         // SRCCOPY
    {
        ulCtl = (opcode_ILOAD + atype_RPL + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + bop_SRCCOPY);
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulCtl = (opcode_ILOAD + atype_RSTR + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + (ulHwMix << 16));
    }

    if (ulBoardId != MGA_STORM)
    {
        if (cjPelSize >= 3)
        {
            ulCtl |= (hcprs_SRC_24_BPP | bltmod_BUCOL);
            xBug = 0;
        }
        else
        {
            ulCtl |= (bltmod_BFCOL);
            xBug = (8 >> cjPelSize);    // 8bpp and 16bpp have h/w alignment bugs
        }
    }
    else
    {
        ulCtl |= (bltmod_BFCOL);
        xBug = 0;
    }

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, ulCtl);
    CP_WRITE(pjBase, DWG_SHIFT, 0);

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }
    if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
    {
        CP_WRITE(pjBase, DWG_AR5, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt.  AR0 will
    // be modified shortly:

    ppdev->HopeFlags = SIGN_CACHE;

    while(TRUE)
    {
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + prcl->right - 1);
        CP_WRITE(pjBase, DWG_YDST,    yOffset + prcl->top);
        CP_WRITE(pjBase, DWG_LEN,     cy);
        CP_WRITE(pjBase, DWG_AR3,     0);

        xSrc     =  prcl->left + dx;
        pjSrc    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + xSrc;
        xAbsLeft = (xOffset + prcl->left);

        bHwBug = (ulBoardId != MGA_STORM) && (xAbsLeft & xBug);
        if (!bHwBug)
        {
            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft);
            CP_START(pjBase, DWG_AR0,    cx - 1);
        }
        else
        {
            CP_WRITE(pjBase, DWG_CXLEFT, xAbsLeft);
            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft - xBug);
            CP_START(pjBase, DWG_AR0,    cx + xBug - 1);
        }

        lSrcSkip = lSrcDelta - cx;

        // Make sure the MGA is ready to take the data:

        CHECK_FIFO_SPACE(pjBase, 32);

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cdSrc = (cx >> 2);
            cxRem = (cx & 3);

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                for (i = cdSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 8);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    ul |= (pulXlate[*pjSrc++] << 24);
                    CP_WRITE_SRC(pjBase, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    if (cxRem > 1)
                    {
                        ul |= (pulXlate[*pjSrc++] << 8);
                        if (cxRem > 2)
                        {
                            ul |= (pulXlate[*pjSrc++] << 16);
                        }
                    }
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            cwSrc = (cx >> 1);
            cxRem = (cx & 1);

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                for (i = cwSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    CP_WRITE_SRC(pjBase, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 4)
        {
            // This part handles 32bpp output:

            cdSrc = cx;

            do {
                if (bHwBug)
                    CP_WRITE_SRC(pjBase, 0);

                for (i = cdSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles packed 24bpp output:

            ASSERTDD(!bHwBug, "There is no hardware bug when higher than 16bpp");

            cdSrc = (cx >> 2);
            cxRem = (cx & 3);

            do {
                for (i = cdSrc; i != 0; i--)
                {
                    ul0  = (pulXlate[*pjSrc++]);
                    ul1  = (pulXlate[*pjSrc++]);
                    ul   = ul0 | (ul1 << 24);
                    CP_WRITE_SRC(pjBase, ul);

                    ul0  = (pulXlate[*pjSrc++]);
                    ul   = (ul1 >> 8) | (ul0 << 16);
                    CP_WRITE_SRC(pjBase, ul);

                    ul1  = (pulXlate[*pjSrc++]);
                    ul   = (ul1 << 8) | (ul0 >> 16);
                    CP_WRITE_SRC(pjBase, ul);
                }

                if (cxRem > 0)
                {
                    ul0 = (pulXlate[*pjSrc++]);
                    ul  = ul0;
                    if (cxRem > 1)
                    {
                        ul1 = (pulXlate[*pjSrc++]);
                        ul |= (ul1 << 24);
                        CP_WRITE_SRC(pjBase, ul);

                        ul = (ul1 >> 8);
                        if (cxRem > 2)
                        {
                            ul0 = (pulXlate[*pjSrc++]);
                            ul |= (ul0 << 16);
                            CP_WRITE_SRC(pjBase, ul);
                            ul = (ul0 >> 16);
                        }
                    }
                    CP_WRITE_SRC(pjBase, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (bHwBug)
        {
            // Restore the clipping:

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_CXLEFT, 0);
        }

        if (--c == 0)
            return;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 7);
    }
}

/******************************Public*Routine******************************\
* VOID vXferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vXferNative(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPel;
    LONG    dx;
    LONG    dy;
    BYTE*   pjSrcScan0;
    LONG    lSrcDelta;
    ULONG   ulCtl;
    ULONG   ulHwMix;
    LONG    yTop;
    LONG    xLeft;
    LONG    xAbsLeft;
    LONG    xBug;
    BOOL    bHwBug;
    LONG    xRight;
    LONG    cy;
    LONG    xOriginalLeft;
    BYTE*   pjSrc;
    LONG    cdSrc;
    ULONG   ulBoardId;

    pjBase      = ppdev->pjBase;
    xOffset     = ppdev->xOffset;
    yOffset     = ppdev->yOffset;
    cjPel       = ppdev->cjPelSize;
    ulBoardId   = ppdev->ulBoardId;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    pjSrcScan0 = psoSrc->pvScan0;
    lSrcDelta  = psoSrc->lDelta;

    if (rop4 == 0xcccc)         // SRCCOPY
    {
        ulCtl = (opcode_ILOAD + atype_RPL + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + bop_SRCCOPY);
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulCtl = (opcode_ILOAD + atype_RSTR + blockm_OFF + pattern_OFF +
                 transc_BG_OPAQUE + (ulHwMix << 16));
    }

    if ((ulBoardId != MGA_STORM) && (ppdev->iBitmapFormat == BMF_24BPP))
    {
        ulCtl |= (hcprs_SRC_24_BPP | bltmod_BUCOL);
    }
    else
    {
        ulCtl |= (bltmod_BFCOL);
    }

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, ulCtl);
    CP_WRITE(pjBase, DWG_SHIFT, 0);

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }
    if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
    {
        CP_WRITE(pjBase, DWG_AR5, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt.  AR0 will
    // be modified shortly:

    ppdev->HopeFlags = SIGN_CACHE;

    while (TRUE)
    {
        yTop          = prcl->top;
        cy            = prcl->bottom - yTop;
        xRight        = prcl->right;
        xLeft         = prcl->left;
        xOriginalLeft = xLeft;

        // Adjust the destination so that the source is dword aligned.
        // Note that this works at 24bpp (but is less restrictive than
        // it could be at 16bpp):

        xLeft -= (xLeft + dx) & 3;

        // Since we're using hardware clipping, the start is always
        // dword aligned:

        pjSrc = pjSrcScan0 + (yTop + dy) * lSrcDelta + ((xLeft + dx) * cjPel);
        cdSrc = ((xRight - xLeft) * cjPel + 3) >> 2;

        CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + xRight - 1);
        CP_WRITE(pjBase, DWG_YDST,    yOffset + yTop);
        CP_WRITE(pjBase, DWG_LEN,     cy);
        CP_WRITE(pjBase, DWG_AR3,     0);

        xAbsLeft = (xOffset + xLeft);
        xBug     = (8 >> cjPel);                // 4 for 8bpp, 2 for 16bpp

        bHwBug = (ulBoardId != MGA_STORM) && (xAbsLeft & xBug) && (cjPel < 3);

        if (!bHwBug)  // 24bpp doesn't have h/w bug
        {
            // Don't have to work-around the hardware bug:

            if (xLeft != xOriginalLeft)
            {
                // Since we always dword align the source by adjusting
                // the destination rectangle, we may have to set the clip
                // register to compensate:

                CP_WRITE(pjBase, DWG_CXLEFT, xOffset + xOriginalLeft);
            }

            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft);
            CP_START(pjBase, DWG_AR0,    xRight - xLeft - 1);

            // Make sure the MGA is ready to take the data:

            CHECK_FIFO_SPACE(pjBase, 32);

            do {
                DATA_TRANSFER(pjBase, pjSrc, cdSrc);
                pjSrc += lSrcDelta;
            } while (--cy != 0);

            if (xLeft != xOriginalLeft)
            {
                CHECK_FIFO_SPACE(pjBase, 1);
                CP_WRITE(pjBase, DWG_CXLEFT, 0);
            }
        }
        else
        {
            // Work-around the hardware bug:

            CP_WRITE(pjBase, DWG_CXLEFT, xOffset + xOriginalLeft);
            CP_WRITE(pjBase, DWG_FXLEFT, xAbsLeft - xBug);
            CP_START(pjBase, DWG_AR0,    xRight - xLeft + xBug - 1);

            // Make sure the MGA is ready to take the data:

            CHECK_FIFO_SPACE(pjBase, 32);

            do {
                DATA_TRANSFER(pjBase, pjSrc, 1);    // Account for h/w bug
                DATA_TRANSFER(pjBase, pjSrc, cdSrc);
                pjSrc += lSrcDelta;
            } while (--cy != 0);

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_CXLEFT, 0);
        }

        if (--c == 0)
            break;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 7);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).
*
*       Unfortunately, if we've created our primary surface as a device-
*       managed surface, it has an 'iType' of STYPE_BITMAP and not
*       STYPE_DEVICE.  So throughout this code, we will determine if a
*       surface is one of ours by checking 'dhsurf' -- a NULL value means
*       that it's a GDI-created DIB, otherwise it's one of our surfaces and
*       'dhsurf' points to our DSURF structure.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#if 0

    BOOL gbPuntBitBlt       = FALSE;
    BOOL gbPuntCopyBits     = FALSE;

#else

    #define gbPuntBitBlt    FALSE
    #define gbPuntCopyBits  FALSE

#endif


/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(i386)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cjPelSize;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // vGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cjPelSize = ppdev->cjPelSize;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPelSize;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            vGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cjPelSize
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bMilPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bMilPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;
    BOOL    b = FALSE;

    if (psoDst->dhpdev != NULL)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;

        if (psoDst->dhpdev != NULL)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((2, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((2, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((2, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((2, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((2, "        << With brush -- Not created"));
            else
                DISPDBG((2, "        << With brush -- Created Ok"));
        }
    }
    #endif

    {
        //////////////////////////////////////////////////////////////////////
        // Linear Framebuffer punt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer.

        POINTL  ptlSrc;
        DSURF*  pdsurfDst;
        DSURF*  pdsurfSrc;
        OH*     pohSrc;
        OH*     pohDst;

        if (psoDst->dhsurf != NULL)
        {
            pdsurfDst       = (DSURF*) psoDst->dhsurf;
            psoDst          = ppdev->psoPunt;
            psoDst->pvScan0 = pdsurfDst->poh->pvScan0;
            psoDst->lDelta  = ppdev->lDelta;

            if (psoSrc != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;
                if ((pdsurfSrc != NULL) &&
                    (pdsurfSrc != pdsurfDst))
                {
                    // If we're doing a BitBlt between different off-screen
                    // surfaces, we have to be sure to give GDI different
                    // surfaces, otherwise it may get confused when it has
                    // to do screen-to-screen blts with a translate...

                    pohSrc = pdsurfSrc->poh;
                    pohDst = pdsurfDst->poh;

                    psoSrc          = ppdev->psoPunt2;
                    psoSrc->pvScan0 = pohSrc->pvScan0;
                    psoSrc->lDelta  = ppdev->lDelta;

                    // Undo the source pointer adjustment we did earlier:

                    ptlSrc.x = pptlSrc->x + (pohDst->x - pohSrc->x);
                    ptlSrc.y = pptlSrc->y + (pohDst->y - pohSrc->y);
                    pptlSrc  = &ptlSrc;
                }
            }
        }
        else
        {
            ppdev           = (PDEV*)  psoSrc->dhpdev;
            pdsurfSrc       = (DSURF*) psoSrc->dhsurf;
            psoSrc          = ppdev->psoPunt;
            psoSrc->pvScan0 = pdsurfSrc->poh->pvScan0;
            psoSrc->lDelta  = ppdev->lDelta;
        }

        START_DIRECT_ACCESS_STORM_FOR_READ(ppdev, ppdev->pjBase);

        b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                         pptlMsk, pbo, pptlBrush, rop4);

        END_DIRECT_ACCESS_STORM(ppdev, ppdev->pjBase);
        return b;
    }
}

/******************************Public*Routine******************************\
* BOOL bMgaPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bMgaPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;
    BOOL    b = FALSE;

    if (psoDst->dhpdev != NULL)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;

        if (psoDst->dhpdev != NULL)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((2, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((2, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((2, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((2, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((2, "        << With brush -- Not created"));
            else
                DISPDBG((2, "        << With brush -- Created Ok"));
        }
    }
    #endif

    {
        //////////////////////////////////////////////////////////////////////
        // Really slow punt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            if ((rclDst.left >= rclDst.right) ||
                (rclDst.top  >= rclDst.bottom))
            {
                // The entire draw operation was trivially rejected:

                return(TRUE);
            }

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // vGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            vGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                   * ppdev->cjPelSize;

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - ((rclDst.left & ~3L) * ppdev->cjPelSize);

            ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.
            //
            // So SRCCOPY is one of the few things we don't read the screen
            // for, and even then only if there's not complex clipping
            // (because complex clipping would leave some parts of the
            // temporary bitmap as uninitialized pixels, which we would copy
            // back to the screen):

            if ((rop4 != 0xcccc) ||
                (psoSrc->iBitmapFormat > BMF_32BPP) ||
                ((pco != NULL) && (pco->iDComplexity == DC_COMPLEX)))
            {
                vGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);
            }

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            vPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }
}

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because on the Millennium it's faster than using the data transfer
* register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'vPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        vPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    XLATEOBJ        xloTmp;
    ULONG           aulTmp[2];

    bRet = TRUE;                // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (gbPuntBitBlt)
    {
        goto Setup_Surfaces;
    }

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset = poh->x;
            ppdev->yOffset = poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = rbc.prb->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

Setup_Surfaces:

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset = pdsurfSrc->poh->x;
        ppdev->yOffset = pdsurfSrc->poh->y;
    }

    if (gbPuntBitBlt)
    {
        goto Punt_It;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        pfnXfer = (rop4 == 0xcccc) ? vXferNativeSrccopy : vXferNative;
                        goto Xfer_It;
                    }

                    // It's faster to use the frame buffer than the transfer
                    // register when the ROP is SRCCOPY, particularly with
                    // USWC enabled.  So it's faster to call 'bPuntBlt' and
                    // have GDI do the drawing directly to the frame buffer
                    // for those cases:

                    else if ((ppdev->ulBoardId != MGA_STORM) ||
                             (rop3 != 0xCC))
                    {
                        if (iSrcBitmapFormat == BMF_4BPP)
                        {
                            pfnXfer = vXfer4bpp;
                            goto Xfer_It;
                        }
                        else if (iSrcBitmapFormat == BMF_8BPP)
                        {
                            pfnXfer = vXfer8bpp;
                            goto Xfer_It;
                        }
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            ppdev->pfnCopyBlt(ppdev, 1, prclDst, rop4, pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                ppdev->pfnCopyBlt(ppdev, 1, &rcl, rop4, pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    ppdev->pfnCopyBlt(ppdev, c, ce.arcl, rop4, pptlSrc,
                                             prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (((rop3 == 0xb8) || (rop3 == 0xe2)) &&
                     (pbo->iSolidColor != (ULONG) -1) &&
                     (psoSrc->iBitmapFormat == BMF_1BPP) &&
                     (pxlo->pulXlate[0] == 0) &&
                     ((pxlo->pulXlate[1] & ppdev->ulWhite) == ppdev->ulWhite))
            {
                // When the background and foreground colors are black and
                // white, respectively, and the ROP is 0xb8 or 0xe2, and
                // the source bitmap is monochrome, the blt is simply a
                // color expanding monochrome blt.

                pfnXfer = ppdev->pfnXfer1bpp;

                // Rather than add another parameter to 'pfnXfer', we simply
                // overload the 'pxlo' pointer.  Note that we still have to
                // special-case 0xb8 and 0xe2 in our 'pfnXfer1bpp' routine
                // to handle this convention:

                pxlo = &xloTmp;
                xloTmp.pulXlate = aulTmp;
                aulTmp[0] = pbo->iSolidColor;
                aulTmp[1] = pbo->iSolidColor;

                goto Xfer_It;
            }
        }
        else
        {
            #if defined(i386)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

    else if ((psoMsk == NULL) && (rop4 == 0xaacc))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        rop3 = (BYTE) rop4;

        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:

    bRet = ppdev->pfnPuntBlt(psoDst,
                             psoSrc,
                             psoMsk,
                             pco,
                             pxlo,
                             prclDst,
                             pptlSrc,
                             pptlMsk,
                             pbo,
                             pptlBrush,
                             rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    if (gbPuntCopyBits)
    {
        return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                         NULL, NULL, 0xcccc));
    }

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL)        &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL)        &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // vCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset = pohDst->x;
                        ppdev->yOffset = pohDst->y;

                        ppdev->pfnCopyBlt(ppdev, 1, prclDst, 0xCCCC, &ptl, prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL)        &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL)        &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    pohDst = pdsurfDst->poh;

                    // vPutBits takes absolute screen coordinates, so we have
                    // to muck with the destination rectangle:

                    rcl.left    = prclDst->left + pohDst->x;
                    rcl.top     = prclDst->top + pohDst->y;
                    rcl.right   = prclDst->right + pohDst->x;
                    rcl.bottom  = prclDst->bottom + pohDst->y;

                    vPutBits(ppdev, psoSrc, &rcl, pptlSrc);

                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL)        &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL)        &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // vGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    vGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\blt16.c ===
/******************************Module*Header*******************************\
* Module Name: blt16.c
*
* This module contains the low-level blt functions that are specific to
* 16bpp.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMgaPatRealize16bpp
*
\**************************************************************************/

VOID vMgaPatRealize16bpp(
PDEV*   ppdev,
RBRUSH* prb)
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        i;
    ULONG*      pulSrc;

    pjBase = ppdev->pjBase;

    // We have to allocate a new off-screen cache brush entry for
    // the brush:

    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->pbe[iBrushCache];

    iBrushCache++;
    if (iBrushCache >= ppdev->cBrushCache)
        iBrushCache = 0;

    ppdev->iBrushCache = iBrushCache;

    // Update our links:

    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL + blockm_OFF +
                                  bop_SRCCOPY + bltmod_BFCOL + pattern_OFF +
                                  transc_BG_OPAQUE));

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt:

    ppdev->HopeFlags = SIGN_CACHE;

    // Since our brushes are always interleaved, we want to send down
    // 2 pels, skip 2 pels, send down 2 pels, etc.  So we contrive to
    // adjust the blt width and pitch to do that automatically for us:

    CP_WRITE(pjBase, DWG_AR3,     0);       // Source start address, not
                                            //   included in ARX_CACHE
    CP_WRITE(pjBase, DWG_SHIFT,   0);
    CP_WRITE(pjBase, DWG_LEN,     8);       // Transfering 8 scans
    CP_WRITE(pjBase, DWG_AR0,     15);      // Source width is 16
    CP_WRITE(pjBase, DWG_AR5,     32);      // Source pitch is 32
    CP_WRITE(pjBase, DWG_FXLEFT,  pbe->ulLeft);
    CP_WRITE(pjBase, DWG_FXRIGHT, pbe->ulLeft + 15);
    CP_WRITE(pjBase, DWG_YDST,    pbe->ulYDst);
    CP_START(pjBase, DWG_PITCH,   32 + ylin_LINEARIZE_NOT);

    CHECK_FIFO_SPACE(pjBase, 32);           // Make sure MGA is ready

    for (pulSrc = prb->aulPattern, i = 8; i != 0; i--, pulSrc += 4)
    {
        CP_WRITE_SRC(pjBase, *(pulSrc));
        CP_WRITE_SRC(pjBase, *(pulSrc + 1));
        CP_WRITE_SRC(pjBase, *(pulSrc + 2));
        CP_WRITE_SRC(pjBase, *(pulSrc + 3));

        // Repeat the brush's scan, because the off-screen pattern has to
        // be 16 x 8:

        CP_WRITE_SRC(pjBase, *(pulSrc));
        CP_WRITE_SRC(pjBase, *(pulSrc + 1));
        CP_WRITE_SRC(pjBase, *(pulSrc + 2));
        CP_WRITE_SRC(pjBase, *(pulSrc + 3));
    }

    // Don't forget to restore the pitch:

    CHECK_FIFO_SPACE(pjBase, 1);
    CP_WRITE(pjBase, DWG_PITCH, ppdev->cxMemory);
}

/******************************Public*Routine******************************\
* VOID vMgaFillPat16bpp
*
\**************************************************************************/

VOID vMgaFillPat16bpp(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    ULONG       ulHwMix;
    LONG        yTop;
    LONG        xLeft;
    LONG        xBrush;
    LONG        yBrush;
    LONG        cx;
    LONG        cy;
    ULONG       ulAr3;
    ULONG       ulAr0;
    CHAR        cFifo;
    LONG        xAlign;
    LONG        cxThis;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");

    ASSERTDD((rbc.prb != NULL) && (rbc.prb->apbe[IBOARD(ppdev)] != NULL),
             "apbe[iBoard] should be initialized to &beUnrealizedBrush");

    // We have to ensure that no other brush took our spot in off-screen
    // memory, or we might have to realize the brush for the first time:

    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if (pbe->prbVerify != rbc.prb)
    {
        vMgaPatRealize16bpp(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    do {
        cFifo = GET_FIFO_SPACE(pjBase) - 4;
    } while (cFifo < 0);

    if (rop4 == 0xf0f0)         // PATCOPY
    {
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + blockm_OFF +
                                      trans_0 + bltmod_BFCOL + pattern_ON +
                                      transc_BG_OPAQUE + bop_SRCCOPY));
    }
    else
    {
        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + blockm_OFF +
                                      trans_0 + bltmod_BFCOL + pattern_ON +
                                      transc_BG_OPAQUE + (ulHwMix << 16)));
    }

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_AR5,   32);

    while (TRUE)
    {
        // We must be careful here, there are some hardware limitations.  We
        // must check the width and the alignment of the blt to decide how to
        // slice the operation along X.  Here are the limitations:
        //
        //  - if the destination is aligned on a 16-pel address, then we are
        //    limited to 16-pel wide slices;
        //  - if the destination is not aligned on a 16-pel address, then we
        //    are limited to 8-pel wide slices.
        //
        // This means that if the width is 8 or less, we can do it right away;
        // if not, then we must first do one or two slices limited to 8 pels,
        // then a bunch of 16-pel slices, and maybe a last slice to complete
        // the blt.

        yTop     = prcl->top;
        xLeft    = prcl->left;
        cy       = prcl->bottom - yTop;
        cx       = prcl->right - xLeft;
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulAr3    = pbe->ulLinear + (yBrush << 5) + xBrush;
        ulAr0    = pbe->ulLinear + (yBrush << 5) + 15;

        xLeft += xOffset;       // Convert to absolute coordinates
        yTop  += yOffset;

        if (cx > 8)
        {
            xAlign = (xLeft & 7);
            if (xAlign != 0)
            {
                cFifo -= 6;
                while (cFifo < 0)
                {
                    cFifo = GET_FIFO_SPACE(pjBase) - 6;
                }

                cxThis = 8 - xAlign;
                CP_WRITE(pjBase, DWG_AR3,     ulAr3);
                CP_WRITE(pjBase, DWG_AR0,     ulAr0);
                CP_WRITE(pjBase, DWG_LEN,     cy);
                CP_WRITE(pjBase, DWG_YDST,    yTop);
                CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                CP_START(pjBase, DWG_FXRIGHT, xLeft + cxThis - 1);
                xLeft += cxThis;
                cx    -= cxThis;
                ulAr3 = ulAr0 - 15 + ((ulAr3 + cxThis) & 7);
            }
            if (cx > 8)
            {
                if (xLeft & 15)
                {
                    cFifo -= 6;
                    while (cFifo < 0)
                    {
                        cFifo = GET_FIFO_SPACE(pjBase) - 6;
                    }

                    CP_WRITE(pjBase, DWG_AR3,     ulAr3);
                    CP_WRITE(pjBase, DWG_AR0,     ulAr0);
                    CP_WRITE(pjBase, DWG_LEN,     cy);
                    CP_WRITE(pjBase, DWG_YDST,    yTop);
                    CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                    CP_START(pjBase, DWG_FXRIGHT, xLeft + 7);
                    xLeft += 8;
                    cx    -= 8;
                }
                while (cx > 16)
                {
                    cFifo -= 6;
                    while (cFifo < 0)
                    {
                        cFifo = GET_FIFO_SPACE(pjBase) - 6;
                    }

                    CP_WRITE(pjBase, DWG_AR3,     ulAr3);
                    CP_WRITE(pjBase, DWG_AR0,     ulAr0);
                    CP_WRITE(pjBase, DWG_LEN,     cy);
                    CP_WRITE(pjBase, DWG_YDST,    yTop);
                    CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                    CP_START(pjBase, DWG_FXRIGHT, xLeft + 15);
                    xLeft += 16;
                    cx    -= 16;
                }
            }
        }

        // Do the final strip:

        cFifo -= 6;
        while (cFifo < 0)
        {
            cFifo = GET_FIFO_SPACE(pjBase) - 6;
        }

        CP_WRITE(pjBase, DWG_AR3,     ulAr3);
        CP_WRITE(pjBase, DWG_AR0,     ulAr0);
        CP_WRITE(pjBase, DWG_LEN,     cy);
        CP_WRITE(pjBase, DWG_YDST,    yTop);
        CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
        CP_START(pjBase, DWG_FXRIGHT, xLeft + cx - 1);

        if (--c == 0)
            break;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vMgaGet16bppSliceFromScreen
*
* Get a limited number of pels from the screen and make sure that the
* transfer went OK.  This assumes that the IDUMP is almost fully set up,
* and that a number of dwords must be jumped over at the end of each
* destination scanline.
*
\**************************************************************************/

VOID vMgaGet16bppSliceFromScreen(
PDEV*   ppdev,          // pdev
ULONG   ulSSA,          // Source start address for current slice
ULONG   ulSEA,          // Source end address for current slice
ULONG   ulLen,          // Nb of scanlines in current slice
LONG    NbDWordsPerScan,// Nb of dwords to be read in each scanline
LONG    lPreDWordBytes, // Nb bytes before any dword on a scan
LONG    lDWords,        // Nb dwords to be moved on a scan
LONG    lPostDWordBytes,// Nb bytes after all dwords on a scan
LONG    lDestDelta,     // Increment to get from one dest scan to the next
BYTE    bPreShift,      // Shift to align first byte to be stored
ULONG** ppulDest)       // Ptr to where to store the first dword we read
{
    BYTE*   pjBase;
    ULONG   temp, HstStatus, AbortCnt;
    ULONG*  pulDest;
    ULONG*  locpulDest;
    ULONG*  pDMAWindow;
    LONG    i, TotalDWords, locTotalDWords;
    BYTE*   pbDest;

    pjBase = ppdev->pjBase;

    AbortCnt = 1000;

    pDMAWindow = (ULONG*) (ppdev->pjBase + DMAWND);

    // We want to stop reading just before the last dword is read.

    TotalDWords = (NbDWordsPerScan * ulLen) - 1;

    do {
        CHECK_FIFO_SPACE(pjBase, 3);

        // This is where we'll start storing data.

        pulDest = *ppulDest;

        // Complete the IDUMP setup.

        CP_WRITE(pjBase, DWG_AR3, ulSSA);
        CP_WRITE(pjBase, DWG_AR0, ulSEA);

        // Turn the pseudoDMA on.

        BLT_READ_ON(ppdev, pjBase);

        CP_START(pjBase, DWG_LEN, ulLen);

        // Make sure the setup is complete.

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

        if (TotalDWords)
        {
            // There is at least one dword left to be read.
            // Make a copy so that we can play with it.

            locTotalDWords = TotalDWords;
            do {
                // Make a copy for updating to the next scan.

                locpulDest = pulDest;

                if (lPreDWordBytes)
                {
                    // There are pixels to be stored as bytes.
                    // Read 2 pixels and shift them into place.

                    locTotalDWords--;
                    temp = CP_READ_DMA(ppdev, pDMAWindow);
                    temp &= ppdev->ulPlnWt;
                    temp >>= bPreShift;

                    pbDest = (BYTE*)pulDest;
                    for (i = 0; i < lPreDWordBytes; i++)
                    {
                        *pbDest = (BYTE) temp;
                        temp >>= 8;
                        pbDest++;
                    }
                    pulDest = (ULONG*)pbDest;

                    if (locTotalDWords == 0)
                    {
                        // This was the end of the current slice.
                        // Exit the do-while loop.

                        if ((NbDWordsPerScan == 1) && (lPreDWordBytes != 0))
                        {
                            // Since it was a narrow slice, the next read
                            // goes on the next scan, so add in the delta:

                            (UCHAR*) pulDest = (UCHAR*) locpulDest + lDestDelta;
                            pbDest = (UCHAR*) pulDest;
                        }
                        break;
                    }
                }

                // We should be dword-aligned in the destination now.
                // Copy a number of full dwords from the current scanline.

                for (i = 0; i < lDWords; i++)
                {
                    temp = CP_READ_DMA(ppdev, pDMAWindow);
                    *pulDest++ = temp & ppdev->ulPlnWt;
                }

                // We're left with this many dwords to be read.

                locTotalDWords -= lDWords;

                if (locTotalDWords != 0)
                {
                    // This was not the last scanline, so we must read a
                    // possibly partial dword to end this scan.

                    if (lPostDWordBytes)
                    {
                        // There are pixels to be stored as bytes.

                        locTotalDWords--;
                        temp = CP_READ_DMA(ppdev, pDMAWindow);
                        temp &= ppdev->ulPlnWt;

                        if (lPostDWordBytes == 4)
                        {
                            *pulDest = temp;
                        }
                        else
                        {
                            pbDest = (BYTE*)pulDest;
                            *pbDest = (BYTE)temp;
                            pbDest++;
                            temp >>= 8;
                            *pbDest = (BYTE)temp;
                        }
                    }

                    // We should be done with this scan.
                    // We're done with the current scan, go to the next one.

                    (UCHAR*) pulDest = (UCHAR*) locpulDest + lDestDelta;
                }
            } while (locTotalDWords > 0);
        }

        // Check for the EngineBusy flag.

        for (i = 0; i < 7; i++)
        {
            HstStatus = CP_READ_STATUS(pjBase);
        }

        if (HstStatus &= (dwgengsts_MASK >> 16))
        {
            // The drawing engine is still busy, while it should not be:
            // there was a problem with this slice.
            // Empty the DMA window.

            do {
                CP_READ_DMA(ppdev, pDMAWindow);

                // Check for the EngineBusy flag.  If the engine is still
                // busy, then we'll have to read another dword.

                for (i = 0; i < 7; i++)
                {
                    temp = CP_READ_STATUS(pjBase);
                }
            } while (temp & (dwgengsts_MASK >> 16));

            // The DMA window should now be empty.

            // We cannot check the HST_STATUS two lower bytes anymore,
            // so this is new.

            if (--AbortCnt > 0)
            {
                // Signal we'll have to do this again.
                HstStatus = 1;
            }
            else
            {
                // We tried hard enough, desist.
                HstStatus = 0;
            }
        }

        // The last dword to be read should be available now.

        temp = CP_READ_DMA(ppdev, pDMAWindow);
        temp &= ppdev->ulPlnWt;

        // We must take some care so as not to write after the end of the
        // destination bitmap.

        pbDest = (BYTE*)pulDest;

        if ((NbDWordsPerScan == 1) && (lPreDWordBytes != 0))
        {
            // The X extent was smaller than 2.

            for (i = 0; i < lPreDWordBytes; i++)
            {
                *pbDest = (BYTE)temp;
                pbDest++;
                temp >>= 8;
            }
        }
        else if (lPostDWordBytes > 0)
        {
            // There are pixels to be stored as bytes.

            if (lPostDWordBytes == 4)
            {
                // We can store a dword.
                *pulDest = temp;
            }
            else
            {
                *pbDest = (BYTE)temp;
                pbDest++;
                temp >>= 8;
                *pbDest = (BYTE)temp;
            }
        }
        else
        {
            // Store the last dword.
            *pulDest = temp;
        }

        // Turn the pseudoDMA off.

        BLT_READ_OFF(ppdev, pjBase);

        // Redo the whole thing if there was a problem with this slice.

    } while (HstStatus);

    // Update the destination pointer for the calling routine.

    *ppulDest += ((ulLen * lDestDelta) / sizeof(ULONG));
}

/******************************Public*Routine******************************\
* VOID vMgaGetBits16bpp
*
* Reads the bits from the screen at 16bpp.
*
\**************************************************************************/

VOID vMgaGetBits16bpp(
PDEV*     ppdev,        // Current src pdev
SURFOBJ*  psoDst,       // Destination surface for the color bits
RECTL*    prclDst,      // Area to be modified within the dest surface,
                        //   in absolute coordinates
POINTL*   pptlSrc)      // Upper left corner of source rectangle,
                        //   in absolute coordinates
{
    BYTE*   pjBase;
    BYTE*   pbScan0;
    BYTE*   pbDestRect;
    LONG    xSrc, ySrc, xTrg, yTrg, cxTrg, cyTrg, lDestDelta, cySlice,
            xTrgAl, cxTrgAl, lPreDWordBytes, lDWords,
            lPostDWordBytes, NbDWordsPerScan, TotalDWords, i;
    ULONG   ulSSA, ulSEA, ulSSAIncrement, temp,
            NbDWords, NbBytesPerScan;
    ULONG*  pDW;
    ULONG*  locpDW;
    BYTE    bPreShift;

    DWORD   dwi, dwo;
    BYTE*   pbDest;

    pjBase = ppdev->pjBase;

    // Calculate the size of the target rectangle, and pick up
    // some convenient locals.

    // Starting (x,y) and extents within the destination bitmap.
    // If an extent is 0 or negative, we don't have anything to do.

    cxTrg = prclDst->right - prclDst->left;
    cyTrg = prclDst->bottom - prclDst->top;
    xTrg  = prclDst->left;
    yTrg  = prclDst->top;

    ASSERTDD(cxTrg > 0 && cyTrg > 0, "Shouldn't get empty extents");

    // First scanline of the destination bitmap.

    pbScan0 = (BYTE*) psoDst->pvScan0;

    // Starting (x,y) on the screen.

    xSrc = pptlSrc->x;
    ySrc = pptlSrc->y;

    // Scan increment within the destination bitmap.

    lDestDelta = psoDst->lDelta;

    // Calculate the location of the destination rectangle.

    pbDestRect = pbScan0 + (yTrg * lDestDelta) + (2 * xTrg);

    // Set the registers that can be set now for the operation.
    // SIGN_CACHE=1 and cuts 1 register from the setup.

    CHECK_FIFO_SPACE(pjBase, 6);

    // DWGCTL   IDUMP+RPL+SRCCOPY+blockm_OFF+bltmod_BFCOL+patt_OFF+BG_OPAQUE
    // SGN      0
    // SHIFT    0
    // AR0      sea: ySrc*pitch + xSrc + cxTrg - 1
    // AR3      ssa: ySrc*pitch + xSrc
    // AR5      Screen pitch
    // FXLEFT   0
    // FXRIGHT  cxTrg - 1
    // LEN      cyTrg
    // MCTLWTST special value required by IDUMP bug fix

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    // The SRC0-3 registers are trashed by the blt.

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_FXLEFT, 0);
    CP_WRITE(pjBase, DWG_AR5, ppdev->cxMemory);
    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_IDUMP+atype_RPL+blockm_OFF+
                                  bop_SRCCOPY+bltmod_BFCOL+pattern_OFF+
                                  transc_BG_OPAQUE));

    // Recipe for IDUMP fix.  We must break the IDUMP into a number of
    // smaller IDUMPS, according to the following formula:
    //
    //    0 < cx <  256 ==> cYSlice = int(1024/(cx << 2)) << 2 = int( 256/cx)<<2
    //  256 < cx < 1024 ==> cYSlice = int(4096/(cx << 2)) << 2 = int(1024/cx)<<2
    // 1024 < cx < 1600 ==> cYSlice = int(1600/(cx << 2)) << 2 = int(1600/cx)<<2
    //
    // We will modify it this way:
    //
    //    0 < cx <= 256 ==> cYSlice = int(1024/(cx << 2)) << 2 = int( 256/cx)<<2
    //  256 < cx <= 512 ==> cYSlice = int(4096/(cx << 2)) << 2 = int(1024/cx)<<2
    //  512 < cx        ==> cYSlice = 4

    if (cxTrg > 512)
    {
        cySlice = 4;
    }
    else if (cxTrg > 256)
    {
        cySlice = (1024 / cxTrg) << 2;
    }
    else
    {
        cySlice = (256 / cxTrg) << 2;
    }

    // Number of bytes, padded to the next dword, to be moved per scanline.

    NbBytesPerScan = (2*cxTrg + 3) & -4;
    NbDWords = NbBytesPerScan >> 2;

    pDW = (ULONG*) pbDestRect;

    // There will probably be a number of full slices (of height cySlice).

    // Source Start Address of the first slice.

    ulSSA = ySrc * ppdev->cxMemory + xSrc + ppdev->ulYDstOrg;
    ulSEA = ulSSA + cxTrg - 1;

    // Increment to get to the SSA of the next full slice.

    ulSSAIncrement = cySlice * ppdev->cxMemory;

    // We can't go full speed.

    // Compute alignment parameters for the blt.  We want to read the
    // minimum number of dwords from the screen, and we want to align
    // the write into memory on dword boundaries.  We want to do it
    // this way:
    //
    // width -> 1     2          3               4               5
    //       ----  ----  ---------  --------------  --------------
    // xTrg&1
    //   0   --10  DWxx  DWxx --10  DWxx DWxx       DWxx DWxx --10
    //   1   --10  3210  32-- DWxx  32-- DWxx --10  32-- DWxx DWxx
    //
    // where 0, 1, 2, or 3 means that the corresponding byte of the dword
    // that was read in is stored as a byte, and DWxx means that the dword
    // that was read in is stored as a dword.

    // Compute some useful values.

    xTrgAl = xTrg & 0x01;                 // 0, 1
    cxTrgAl = cxTrg - xTrgAl;

    if (cxTrgAl < 2)
    {
        // The width is really small.
                                    // On each scanline:
        lPreDWordBytes = 2*cxTrg;   // Nb of bytes before the first dword
        lDWords = 0;                // Nb of dwords to be stored
        lPostDWordBytes = 0;        // Nb of bytes after the last dword.
        NbDWordsPerScan = 1;        // Nb of dwords to be read in.
        bPreShift = 0;              // How to shift the first dword.
    }
    else
    {
        // Pixels will be stored as bytes and dwords.

        lPreDWordBytes = 2*xTrgAl;  // Nb of bytes before the first dword
        lDWords = cxTrgAl / 2;
        if((lPostDWordBytes = 2 * (cxTrgAl & 1)) == 0)
        {
            lPostDWordBytes = 4;
            lDWords--;
        }
        NbDWordsPerScan = (xTrgAl + cxTrg + 1)/2;
        bPreShift = (BYTE)(16 * xTrgAl);
        ulSSA -= xTrgAl;
    }

    CP_WRITE(pjBase, DWG_FXRIGHT, (bPreShift/16) + cxTrg - 1);

    while ((cyTrg -= cySlice) >= 0)
    {
        // There is another full height slice to be read.

        vMgaGet16bppSliceFromScreen(ppdev, ulSSA, ulSEA,
                                     (ULONG) cySlice, NbDWordsPerScan,
                                     lPreDWordBytes, lDWords,
                                     lPostDWordBytes, lDestDelta,
                                     bPreShift, &pDW);

        // Bump Source Start Address to the start of the next slice.

        ulSSA += ulSSAIncrement;
        ulSEA += ulSSAIncrement;
    }

    // Make cyTrg positive again, and read the last slice, if any.

    if ((cyTrg += cySlice) != 0)
    {
        // There is a last, partial slice to be read.

        vMgaGet16bppSliceFromScreen(ppdev, ulSSA, ulSEA,
                                     (ULONG) cyTrg, NbDWordsPerScan,
                                     lPreDWordBytes, lDWords,
                                     lPostDWordBytes, lDestDelta,
                                     bPreShift, &pDW);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\blt8.c ===
/******************************Module*Header*******************************\
* Module Name: blt8.c
*
* This module contains the low-level blt functions that are specific to
* 8bpp.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMgaPatRealize8bpp
*
\**************************************************************************/

VOID vMgaPatRealize8bpp(
PDEV*   ppdev,
RBRUSH* prb)
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        i;
    ULONG*      pulSrc;

    pjBase = ppdev->pjBase;

    // We have to allocate a new off-screen cache brush entry for
    // the brush:

    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->pbe[iBrushCache];

    iBrushCache++;
    if (iBrushCache >= ppdev->cBrushCache)
        iBrushCache = 0;

    ppdev->iBrushCache = iBrushCache;

    // Update our links:

    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL + blockm_OFF +
                                  bop_SRCCOPY + bltmod_BFCOL + pattern_OFF +
                                  transc_BG_OPAQUE));

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt:

    ppdev->HopeFlags = SIGN_CACHE;

    // Since our brushes are always interleaved, we want to send down
    // 2 pels, skip 2 pels, send down 2 pels, etc.  So we contrive to
    // adjust the blt width and pitch to do that automatically for us:

    CP_WRITE(pjBase, DWG_AR3,     0);       // Source start address, not
                                            //   included in ARX_CACHE
    CP_WRITE(pjBase, DWG_SHIFT,   0);
    CP_WRITE(pjBase, DWG_LEN,     8);       // Transfering 8 scans
    CP_WRITE(pjBase, DWG_AR0,     15);      // Source width is 16
    CP_WRITE(pjBase, DWG_AR5,     32);      // Source pitch is 32
    CP_WRITE(pjBase, DWG_FXLEFT,  pbe->ulLeft);
    CP_WRITE(pjBase, DWG_FXRIGHT, pbe->ulLeft + 15);
    CP_WRITE(pjBase, DWG_YDST,    pbe->ulYDst);
    CP_START(pjBase, DWG_PITCH,   32);

    CHECK_FIFO_SPACE(pjBase, 32);

    for (pulSrc = prb->aulPattern, i = 8; i != 0; i--, pulSrc += 2)
    {
        CP_WRITE_SRC(pjBase, *(pulSrc));
        CP_WRITE_SRC(pjBase, *(pulSrc + 1));

        // Repeat the brush's scan, because the off-screen pattern has to
        // be 16 x 8:

        CP_WRITE_SRC(pjBase, *(pulSrc));
        CP_WRITE_SRC(pjBase, *(pulSrc + 1));
    }

    // Don't forget to restore the pitch:

    CHECK_FIFO_SPACE(pjBase, 1);
    CP_WRITE(pjBase, DWG_PITCH, ppdev->cxMemory);
}

/******************************Public*Routine******************************\
* VOID vMgaFillPat8bppWorkAround
*
* Works around an MGA hardware bug with colour patterns and hardware ROPs.
*
\**************************************************************************/

VOID vMgaFillPat8bppWorkAround( // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    ULONG       ulHwMix;
    LONG        yTop;
    LONG        xLeft;
    LONG        xBrush;
    LONG        yBrush;
    ULONG       ulLinear;
    ULONG       ulLinear0;
    ULONG       ulLinear3;
    LONG        cx;
    LONG        cy;
    LONG        cxSlice;
    LONG        cLoops;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");
    ASSERTDD(rop4 != 0xf0f0, "PATCOPY should already have been handled");
    ASSERTDD(rbc.prb->apbe[IBOARD(ppdev)]->prbVerify == rbc.prb,
            "Brush realization should have been handled by vFillPat8bpp");

    pbe     = rbc.prb->apbe[IBOARD(ppdev)];
    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    CHECK_FIFO_SPACE(pjBase, 10);

    ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + blockm_OFF +
                                  trans_0 + bltmod_BFCOL + pattern_ON +
                                  transc_BG_OPAQUE + (ulHwMix << 16)));

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_AR5, 32);

    while (TRUE)
    {
        yTop     = prcl->top;
        xLeft    = prcl->left;
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulLinear = pbe->ulLinear + (yBrush << 5);

        CP_WRITE(pjBase, DWG_AR3,    ulLinear + xBrush);
        CP_WRITE(pjBase, DWG_AR0,    ulLinear + 15);
        CP_WRITE(pjBase, DWG_LEN,    prcl->bottom - yTop);
        CP_WRITE(pjBase, DWG_YDST,   yOffset + yTop);
        CP_WRITE(pjBase, DWG_FXLEFT, xOffset + xLeft);

        // We do the fix by setting FXRIGHT to mark the end of our first
        // slice, start the engine, then draw full-width (32 pel wide)
        // slices, if any, and then the last (partial) slice, if required:

        cx      = prcl->right - xLeft;
        cxSlice = 32 - ((xLeft + xOffset) & 0xf);
        if (cx <= cxSlice)
        {
            // We can still use the fast way:

            CP_START(pjBase, DWG_FXRIGHT, xOffset + prcl->right - 1);
        }
        else
        {
            // Do the first slice:

            xLeft += cxSlice;
            cx    -= cxSlice;
            CP_START(pjBase, DWG_FXRIGHT, xOffset + xLeft - 1);

            // Recompute the new brush alignment:

            xBrush    = (xLeft - pptlBrush->x) & 7;
            ulLinear3 = ulLinear + xBrush;
            ulLinear0 = ulLinear + 15;

            // Convert to absolute coordinates from here on:

            cy     = prcl->bottom - yTop;
            xLeft += xOffset;
            yTop  += yOffset;

            // Do any full-width slices:

            for (cLoops = (cx >> 5); cLoops != 0; cLoops--)
            {
                CHECK_FIFO_SPACE(pjBase, 6);

                CP_WRITE(pjBase, DWG_AR3,     ulLinear3);
                CP_WRITE(pjBase, DWG_AR0,     ulLinear0);
                CP_WRITE(pjBase, DWG_LEN,     cy);
                CP_WRITE(pjBase, DWG_YDST,    yTop);
                CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                xLeft += 32;
                CP_START(pjBase, DWG_FXRIGHT, xLeft - 1);
            }

            // Do any partial last slice:

            cx &= 31;
            if (cx > 0)
            {
                CHECK_FIFO_SPACE(pjBase, 6);

                // We've got to reload these registers each time:

                CP_WRITE(pjBase, DWG_AR3,     ulLinear3);
                CP_WRITE(pjBase, DWG_AR0,     ulLinear0);
                CP_WRITE(pjBase, DWG_LEN,     cy);
                CP_WRITE(pjBase, DWG_YDST,    yTop);
                CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                CP_START(pjBase, DWG_FXRIGHT, xLeft + cx - 1);
            }
        }

        if (--c == 0)
            break;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 6);
    }
}

/******************************Public*Routine******************************\
* VOID vFillPat8bpp
*
\**************************************************************************/

VOID vMgaFillPat8bpp(           // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    ULONG       ulHwMix;
    LONG        yTop;
    LONG        xLeft;
    LONG        xBrush;
    LONG        yBrush;
    ULONG       ulLinear;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");

    ASSERTDD((rbc.prb != NULL) && (rbc.prb->apbe[IBOARD(ppdev)] != NULL),
             "apbe[iBoard] should be initialized to &beUnrealizedBrush");

    // We have to ensure that no other brush took our spot in off-screen
    // memory, or we might have to realize the brush for the first time:

    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if (pbe->prbVerify != rbc.prb)
    {
        vMgaPatRealize8bpp(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    CHECK_FIFO_SPACE(pjBase, 10);

    if (rop4 == 0xf0f0)         // PATCOPY
    {
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + blockm_OFF +
                                      trans_0 + bltmod_BFCOL + pattern_ON +
                                      transc_BG_OPAQUE + bop_SRCCOPY));
    }
    else
    {
        {
            // On some MGA chips, we have to work around a hardware bug
            // with arbitrary ROPs:

            vMgaFillPat8bppWorkAround(ppdev, c, prcl, rop4, rbc, pptlBrush);
            return;
        }

        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + blockm_OFF +
                                      trans_0 + bltmod_BFCOL + pattern_ON +
                                      transc_BG_OPAQUE + (ulHwMix << 16)));
    }

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_AR5,   32);

    while (TRUE)
    {
        yTop     = prcl->top;
        xLeft    = prcl->left;
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulLinear = pbe->ulLinear + (yBrush << 5);

        CP_WRITE(pjBase, DWG_AR3,     ulLinear + xBrush);
        CP_WRITE(pjBase, DWG_AR0,     ulLinear + 15);
        CP_WRITE(pjBase, DWG_LEN,     prcl->bottom - yTop);
        CP_WRITE(pjBase, DWG_YDST,    yOffset + yTop);
        CP_WRITE(pjBase, DWG_FXLEFT,  xOffset + xLeft);
        CP_START(pjBase, DWG_FXRIGHT, xOffset + prcl->right - 1);

        if (--c == 0)
            break;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 6);
    }
}

/******************************Public*Routine******************************\
* VOID vMgaGet8bppSliceFromScreen
*
* Get a limited number of pels from the screen and make sure that the
* transfer went OK.  This assumes that the IDUMP is almost fully set up,
* and that a number of dwords must be jumped over at the end of each
* destination scanline.
*
\**************************************************************************/

VOID vMgaGet8bppSliceFromScreen(
PDEV*   ppdev,          // pdev
ULONG   ulSSA,          // Source start address for current slice
ULONG   ulSEA,          // Source end address for current slice
ULONG   ulLen,          // Nb of scanlines in current slice
LONG    NbDWordsPerScan,// Nb of dwords to be read in each scanline
LONG    NbFirstBytes,   // Nb bytes to be used from 1st dword
LONG    NbLastBytes,    // Nb bytes to be used from 2nd (last) dword
LONG    lPreDWordBytes, // Nb bytes before any dword on a scan
LONG    lDWords,        // Nb dwords to be moved on a scan
LONG    lPostDWordBytes,// Nb bytes after all dwords on a scan
LONG    lDestDelta,     // Increment to get from one dest scan to the next
BYTE    bPreShift,      // Shift to align first byte to be stored
ULONG** ppulDest)       // Ptr to where to store the first dword we read
{
    BYTE*   pjBase;
    ULONG   temp, HstStatus, AbortCnt;
    ULONG*  pulDest;
    ULONG*  locpulDest;
    ULONG*  pDMAWindow;
    LONG    i, TotalDWords, locTotalDWords;
    BYTE*   pbDest;

    AbortCnt = 1000;

    pjBase     = ppdev->pjBase;
    pDMAWindow = (ULONG*) (pjBase+ DMAWND);

    // We want to stop reading just before the last dword is read.

    TotalDWords = (NbDWordsPerScan * ulLen) - 1;

    do
    {
        CHECK_FIFO_SPACE(pjBase, 3);

        // This is where we'll start storing data.

        pulDest = *ppulDest;

        // Complete the IDUMP setup.

        CP_WRITE(pjBase, DWG_AR3, ulSSA);
        CP_WRITE(pjBase, DWG_AR0, ulSEA);

        // Turn the pseudoDMA on.

        BLT_READ_ON(ppdev, pjBase);

        CP_START(pjBase, DWG_LEN, ulLen);

        // Make sure the setup is complete.

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

        if (TotalDWords)
        {
            // There is at least one dword left to be read.
            // Make a copy so that we can play with it.

            locTotalDWords = TotalDWords;
            do
            {
                // Make a copy for updating to the next scan.

                locpulDest = pulDest;

                if (lPreDWordBytes)
                {
                    // There are pixels to be stored as bytes.
                    // Read 4 pixels and shift them into place.

                    locTotalDWords--;
                    temp = CP_READ_DMA(ppdev, pDMAWindow);
                    temp >>= bPreShift;
                    pbDest = (BYTE*)pulDest;
                    for (i = 0; i < NbFirstBytes; i++)
                    {
                        *pbDest = (BYTE)temp;
                        temp >>= 8;
                        pbDest++;
                    }
                    pulDest = (ULONG*)pbDest;

                    if (locTotalDWords == 0)
                    {
                        // This was the end of the current slice.
                        // Exit the do-while loop.

                        if (NbDWordsPerScan == 1)
                        {
                            // Since it was a narrow slice, the next read
                            // goes on the next scan, so add in the delta:

                            (UCHAR*) pulDest = (UCHAR*) locpulDest + lDestDelta;
                            pbDest = (UCHAR*) pulDest;
                        }
                        break;
                    }

                    if (NbLastBytes > 0)
                    {
                        // We need more pixels.

                        locTotalDWords--;
                        temp = CP_READ_DMA(ppdev, pDMAWindow);
                        for (i = 0; i < NbLastBytes; i++)
                        {
                            *pbDest = (BYTE)temp;
                            temp >>= 8;
                            pbDest++;
                        }

                        // We should be done with this scan.
                    }
                }

                // We should be dword-aligned in the destination now.
                // Copy a number of full dwords from the current scanline.

                for (i = 0; i < lDWords; i++)
                {
                    *pulDest++ = CP_READ_DMA(ppdev, pDMAWindow);
                }

                // We're left with this many dwords to be read.

                locTotalDWords -= lDWords;

                if (locTotalDWords != 0)
                {
                    // This was not the last scanline, so we must read a
                    // possibly partial dword to end this scan.

                    if (lPostDWordBytes)
                    {
                        // There are pixels to be stored as bytes.

                        locTotalDWords--;
                        temp = CP_READ_DMA(ppdev, pDMAWindow);
                        pbDest = (BYTE*)pulDest;
                        for (i = 0; i < lPostDWordBytes; i++)
                        {
                            *pbDest = (BYTE)temp;
                            temp >>= 8;
                            pbDest++;
                        }
                    }
                    // We should be done with this scan.
                    // We're done with the current scan, go to the next one.

                    (UCHAR*) pulDest = (UCHAR*) locpulDest + lDestDelta;
                }
            } while (locTotalDWords > 0);
        }

        // Check for the EngineBusy flag.
        for (i = 0; i < 7; i++)
        {
            HstStatus = CP_READ_STATUS(pjBase);
        }

        if (HstStatus &= (dwgengsts_MASK >> 16))
        {
            // The drawing engine is still busy, while it should not be:
            // there was a problem with this slice.
            // Empty the DMA window.

            do
            {
                CP_READ_DMA(ppdev, pDMAWindow);

                // Check for the EngineBusy flag.  If the engine is still
                // busy, then we'll have to read another dword.

                for (i = 0; i < 7; i++)
                {
                    temp = CP_READ_STATUS(pjBase);
                }
            } while (temp & (dwgengsts_MASK >> 16));

            // The DMA window should now be empty.

            // We cannot check the HST_STATUS two lower bytes anymore,
            // so this is new.

            if (--AbortCnt > 0)
            {
                // Signal we'll have to do this again.
                HstStatus = 1;
            }
            else
            {
                // We tried hard enough, desist.
                HstStatus = 0;
            }
        }

        // The last dword to be read should be available now.

        temp = CP_READ_DMA(ppdev, pDMAWindow);

        // We must take some care so as not to write after the end of the
        // destination bitmap.

        pbDest = (BYTE*)pulDest;
        if (NbDWordsPerScan == 1)
        {
            // The X extent was smaller than 4.

            for (i = 0; i < NbFirstBytes; i++)
            {
                *pbDest = (BYTE)temp;
                temp >>= 8;
                pbDest++;
            }
        }
        else if (NbLastBytes > 0)
        {
            // The X extent was 5 or 6:  we wrote only bytes into the dest.

            for (i = 0; i < NbLastBytes; i++)
            {
                *pbDest = (BYTE)temp;
                temp >>= 8;
                pbDest++;
            }
        }
        else if (lPostDWordBytes > 0)
        {
            // There are pixels to be stored as bytes.

            if (lPostDWordBytes == 4)
            {
                // We can store a dword.
                *pulDest = temp;
            }
            else
            {
                for (i = 0; i < lPostDWordBytes; i++)
                {
                    *pbDest = (BYTE)temp;
                    temp >>= 8;
                    pbDest++;
                }
            }
        }
        else
        {
            // Store the last dword.
            *pulDest = temp;
        }

        // Turn the pseudoDMA off.

        BLT_READ_OFF(ppdev, pjBase);

        // Redo the whole thing if there was a problem with this slice.
    } while (HstStatus);

    // Update the destination pointer for the calling routine.

    *ppulDest += ((ulLen * lDestDelta) / sizeof(ULONG));
}

/******************************Public*Routine******************************\
* VOID vMgaGetBits8bpp
*
* Reads the bits from the screen at 8bpp.
*
\**************************************************************************/

VOID vMgaGetBits8bpp(
PDEV*     ppdev,        // Current src pdev
SURFOBJ*  psoDst,       // Destination surface for the color bits
RECTL*    prclDst,      // Area to be modified within the dest surface,
                        //   in absolute coordinates
POINTL*   pptlSrc)      // Upper left corner of source rectangle,
                        //   in absolute coordinates
{
    BYTE*   pjBase;
    INT     i, j;
    BYTE*   pbScan0;
    BYTE*   pbDestRect;
    BYTE*   pByte;
    BYTE*   LocalpByte;
    LONG    xSrc, ySrc, xTrg, yTrg, cxTrg, cyTrg, lDestDelta, cySlice,
            xTrgAl, xTrgInvAl, cxTrgAl, lPreDWordBytes, lDWords,
            lPostDWordBytes, NbFirstBytes, NbLastBytes, NbDWordsPerScan;
    ULONG   temp, ulSSA, ulSEA, ulSSAIncrement,
            NbDWords, NbBytesPerScan;
    ULONG*  pDW;
    ULONG*  pulXlate;
    ULONG*  pDMAWindow;
    BYTE    bPreShift;

    pjBase = ppdev->pjBase;

    // Calculate the size of the target rectangle, and pick up
    // some convenient locals.

    // Starting (x,y) and extents within the destination bitmap.

    cxTrg = prclDst->right - prclDst->left;
    cyTrg = prclDst->bottom - prclDst->top;
    xTrg  = prclDst->left;
    yTrg  = prclDst->top;

    ASSERTDD(cxTrg > 0 && cyTrg > 0, "Shouldn't get empty extents");

    // First scanline of the destination bitmap.

    pbScan0 = (BYTE*) psoDst->pvScan0;

    // Starting (x,y) on the screen.

    xSrc  = pptlSrc->x;
    ySrc  = pptlSrc->y;

    // Scan increment within the destination bitmap.

    lDestDelta = psoDst->lDelta;

    // Calculate the location of the destination rectangle.

    pbDestRect = pbScan0 + (yTrg * lDestDelta) + xTrg;

    // Set the registers that can be set now for the operation.
    // SIGN_CACHE=1 and cuts 1 register from the setup.

    CHECK_FIFO_SPACE(pjBase, 7);

    // DWGCTL   IDUMP+RPL+SRCCOPY+blockm_OFF+bltmod_BFCOL+patt_OFF+BG_OPAQUE
    // SGN      0
    // SHIFT    0
    // AR0      sea: ySrc*pitch + xSrc + cxTrg - 1
    // AR3      ssa: ySrc*pitch + xSrc
    // AR5      Screen pitch
    // FXLEFT   0
    // FXRIGHT  cxTrg - 1
    // LEN      cyTrg
    // xxMCTLWTST special value required by IDUMP bug fix

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    // The SRC0-3 registers are trashed by the blt.

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);

    CP_WRITE(pjBase, DWG_FXLEFT, 0);

    CP_WRITE(pjBase, DWG_AR5, ppdev->cxMemory);

    CP_WRITE(pjBase, DWG_LEN, cyTrg);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_IDUMP+atype_RPL+blockm_OFF+
                bop_SRCCOPY+bltmod_BFCOL+pattern_OFF+transc_BG_OPAQUE));

    // Recipe for IDUMP fix.  We must break the IDUMP into a number of
    // smaller IDUMPS, according to the following formula:
    //
    //    0 < cx <  256 ==> cYSlice = int(1024/(cx << 2)) << 2 = int( 256/cx)<<2
    //  256 < cx < 1024 ==> cYSlice = int(4096/(cx << 2)) << 2 = int(1024/cx)<<2
    // 1024 < cx < 1600 ==> cYSlice = int(1600/(cx << 2)) << 2 = int(1600/cx)<<2
    //
    // We will modify it this way:
    //
    //    0 < cx <= 256 ==> cYSlice = int(1024/(cx << 2)) << 2 = int( 256/cx)<<2
    //  256 < cx <= 512 ==> cYSlice = int(4096/(cx << 2)) << 2 = int(1024/cx)<<2
    //  512 < cx        ==> cYSlice = 4

    if (cxTrg > 512)
    {
        cySlice = 4;
    }
    else if (cxTrg > 256)
    {
        cySlice = (1024 / cxTrg) << 2;
    }
    else
    {
        cySlice = (256 / cxTrg) << 2;
    }

    // Number of bytes, padded to the next dword, to be moved per scanline.

    NbBytesPerScan = (cxTrg+3) & -4;
    NbDWords = NbBytesPerScan >> 2;

    pDW = (ULONG*) pbDestRect;

    // There will probably be a number of full slices (of height cySlice).

    // Source Start Address of the first slice.

    ulSSA = ySrc * ppdev->cxMemory + xSrc;
    ulSEA = ulSSA + cxTrg - 1;

    // Increment to get to the SSA of the next full slice.

    ulSSAIncrement = cySlice * ppdev->cxMemory;

    // Compute alignment parameters for the blt.  We want to read the
    // minimum number of dwords from the screen, and we want to align
    // the write into memory on dword boundaries.  We want to do it
    // this way:
    //
    // width -> 1    2    3    4          5               6               7
    //       ---- ---- ---- ----  ---------  --------------  --------------
    // xTrg&3
    //   1   ---0 --10 -210 3210  321- --10  321- -210       321- DWxx
    //   2   ---0 --10 -210 3210  32-- -210  32-- DWxx       32-- DWxx ---0
    //   3   ---0 --10 -210 3210  3--- DWxx  3--- DWxx ---0  3--- DWxx --10
    //   0   ---0 --10 -210 DWxx  DWxx ---0  DWxx --10       DWxx -210
    //
    // where 0, 1, 2, or 3 means that the corresponding byte of the dword
    // that was read in is stored as a byte, and DWxx means that the dword
    // that was read in is stored as a dword.

    // Compute some useful values.

    xTrgAl = xTrg & 0x03;                 // 0, 1, 2, 3
    xTrgInvAl = (0x04 - xTrgAl) & 0x03;   // 0, 3, 2, 1
    cxTrgAl = cxTrg - xTrgInvAl;

    if (cxTrgAl < 4)
    {
        // The width is really small, we will need at most 2 dwords per scan.
        // All the pixels will be stored as bytes.
                                // On each scanline:
        lPreDWordBytes = cxTrg; // Nb of bytes defore the first dword
        lDWords = 0;            // Nb of dwords to be stored
        lPostDWordBytes = 0;    // Nb of bytes after the last dword.
    }
    else
    {
        // Pixels will be stored as bytes and dwords.

        lPreDWordBytes = xTrgInvAl;
        lDWords = cxTrgAl / 4;
        if((lPostDWordBytes = cxTrgAl & 3) == 0)
        {
            lPostDWordBytes = 4;
            lDWords--;
        }
    }

    if (cxTrg <= 4)
    {
        NbFirstBytes = cxTrg;
        bPreShift = 0;
        NbLastBytes = 0;
        NbDWordsPerScan = 1;
    }
    else
    {
        ulSSA -= xTrgAl;
        bPreShift = (BYTE)xTrgAl * 8;
        NbFirstBytes = 4 - xTrgAl;
        NbLastBytes = lPreDWordBytes - NbFirstBytes;
        NbDWordsPerScan = ((lPreDWordBytes + 3) / 4) + lDWords +
                          ((lPostDWordBytes + 3) / 4);
    }

    CP_WRITE(pjBase, DWG_FXRIGHT, (bPreShift/8) + cxTrg - 1);

    // No index translation while copying.

    while ((cyTrg -= cySlice) >= 0)
    {
        // There is another full height slice to be read.

        vMgaGet8bppSliceFromScreen(ppdev, ulSSA, ulSEA,
                                    (ULONG) cySlice, NbDWordsPerScan,
                                    NbFirstBytes, NbLastBytes,
                                    lPreDWordBytes, lDWords,
                                    lPostDWordBytes, lDestDelta,
                                    bPreShift, &pDW);

        // Bump Source Start Address to the start of the next slice.

        ulSSA += ulSSAIncrement;
        ulSEA += ulSSAIncrement;
    }

    // Make cyTrg positive again, and read the last slice, if any.

    if ((cyTrg += cySlice) != 0)
    {
        // There is a last, partial slice to be read.

        vMgaGet8bppSliceFromScreen(ppdev, ulSSA, ulSEA,
                                    (ULONG) cyTrg, NbDWordsPerScan,
                                    NbFirstBytes, NbLastBytes,
                                    lPreDWordBytes, lDWords,
                                    lPostDWordBytes, lDestDelta,
                                    bPreShift, &pDW);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\bltmga.c ===
/******************************Module*Header*******************************\
* Module Name: bltmga.c
*
* Contains the low-level blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMgaFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMgaFillSolid(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulDwg;
    ULONG   ulHwMix;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if (rop4 == 0xf0f0)         // PATCOPY
    {
        ulDwg = opcode_TRAP + atype_RPL + blockm_ON +
                pattern_OFF + transc_BG_OPAQUE +
                bop_SRCCOPY;
    }
    else
    {
        // The ROP3 is a combination of P and D only:
        //
        //      ROP3  Mga   ROP3  Mga   ROP3  Mga   ROP3  Mga
        //
        //      0x00  0     0x50  4     0xa0  8     0xf0  c
        //      0x05  1     0x55  5     0xa5  9     0xf5  d
        //      0x0a  2     0x5a  6     0xaa  a     0xfa  e
        //      0x0f  3     0x5f  7     0xaf  b     0xff  f

        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        if (ulHwMix == MGA_WHITENESS)
        {
            rbc.iSolidColor = 0xffffffff;
            ulDwg = opcode_TRAP + atype_RPL + blockm_ON +
                    pattern_OFF + transc_BG_OPAQUE +
                    bop_SRCCOPY;
        }
        else if (ulHwMix == MGA_BLACKNESS)
        {
            rbc.iSolidColor = 0;
            ulDwg = opcode_TRAP + atype_RPL + blockm_ON +
                    pattern_OFF + transc_BG_OPAQUE +
                    bop_SRCCOPY;
        }
        else
        {
            ulDwg = opcode_TRAP + atype_RSTR + blockm_OFF +
                    pattern_OFF + transc_BG_OPAQUE +
                    (ulHwMix << 16);
        }
    }

    if ((GET_CACHE_FLAGS(ppdev, (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE))) ==
                                (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE))
    {
        CHECK_FIFO_SPACE(pjBase, 6);
    }
    else
    {
        CHECK_FIFO_SPACE(pjBase, 15);

        if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
        {
            CP_WRITE(pjBase, DWG_SGN, 0);
        }
        if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
        {
            CP_WRITE(pjBase, DWG_AR1, 0);
            CP_WRITE(pjBase, DWG_AR2, 0);
            CP_WRITE(pjBase, DWG_AR4, 0);
            CP_WRITE(pjBase, DWG_AR5, 0);
        }
        if (!(GET_CACHE_FLAGS(ppdev, PATTERN_CACHE)))
        {
            CP_WRITE(pjBase, DWG_SRC0, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC1, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC2, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC3, 0xFFFFFFFF);
        }

        ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE);
    }

    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, rbc.iSolidColor));
    CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);

    while(TRUE)
    {
        CP_WRITE(pjBase, DWG_FXLEFT,  prcl->left   + xOffset);
        CP_WRITE(pjBase, DWG_FXRIGHT, prcl->right  + xOffset);
        CP_WRITE(pjBase, DWG_LEN,     prcl->bottom - prcl->top);
        CP_START(pjBase, DWG_YDST,    prcl->top    + yOffset);

        if (--c == 0)
            return;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vMgaXfer1bpp
*
* This routine colour expands a monochrome bitmap.
*
\**************************************************************************/

VOID vMgaXfer1bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Foreground and background hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulBitFlip;
    LONG    dx;
    LONG    dy;
    BYTE*   pjSrcScan0;
    LONG    lSrcDelta;
    ULONG   ulDwg;
    ULONG   ulHwMix;
    ULONG*  pulXlate;
    LONG    cxDst;
    LONG    cyDst;
    LONG    xAlign;
    ULONG   cFullLoops;
    ULONG   cRemLoops;
    BYTE*   pjDma;
    ULONG*  pulSrc;
    ULONG   cdSrc;
    LONG    lSrcSkip;
    ULONG*  pulDst;
    LONG    i;
    BOOL    bHwBug;
    LONG    cFifo;

    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only an opaquing rop");

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    ulBitFlip = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    pjSrcScan0 = psoSrc->pvScan0;
    lSrcDelta  = psoSrc->lDelta;

    if (rop4 == 0xcccc)                 // SRCCOPY
    {
        ulDwg = opcode_ILOAD+atype_RPL+blockm_OFF+bltmod_BMONO+
                hbgr_SRC_WINDOWS+pattern_OFF+transc_BG_OPAQUE+bop_SRCCOPY;
    }
    else if ((rop4 == 0xb8b8) || (rop4 == 0xe2e2))
    {
        ulDwg = opcode_ILOAD+atype_RPL+blockm_OFF+bop_SRCCOPY+trans_0+
                bltmod_BMONO+pattern_OFF+hbgr_SRC_WINDOWS+transc_BG_TRANSP;

        // We special-cased 0xb8b8 and 0xe2e2 in bitblt.c:

        if (rop4 == 0xb8b8)
        {
            // 0xb8 is weird because it says that the '1' bit is leave-alone,
            // but the '0' bit is the destination color.  The Millennium can
            // only handle transparent blts when the '0' bit is leave-alone,
            // so we flip the source bits before we give it to the Millennium.
            //
            // Since we're limited by the speed of the bus, this additional
            // overhead of an extra XOR on every write won't be measurable.

            ulBitFlip = (ULONG) -1;
        }
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulDwg = opcode_ILOAD+atype_RSTR+blockm_OFF+bltmod_BMONO+
                hbgr_SRC_WINDOWS+pattern_OFF+transc_BG_OPAQUE+ (ulHwMix << 16);
    }

    pjDma = ppdev->pjBase + DMAWND;
    pulXlate = pxlo->pulXlate;

    CHECK_FIFO_SPACE(pjBase, 15);

    CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
    {
        CP_WRITE(pjBase, DWG_AR5, 0);
    }

    // The SRC0 through SRC3 registers are trashed by the blt, and
    // other ARx registers will be modified shortly, so signal it:

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, pulXlate[1]));
    CP_WRITE(pjBase, DWG_BCOL, COLOR_REPLICATE(ppdev, pulXlate[0]));

    while (TRUE)
    {
        cxDst = (prcl->right - prcl->left);
        cyDst = (prcl->bottom - prcl->top);

        CP_WRITE(pjBase, DWG_LEN,     cyDst);
        CP_WRITE(pjBase, DWG_YDST,    prcl->top + yOffset);
        CP_WRITE(pjBase, DWG_FXLEFT,  prcl->left + xOffset);
        CP_WRITE(pjBase, DWG_FXRIGHT, prcl->right + xOffset - 1);

        xAlign = (prcl->left + dx) & 31;

        bHwBug = ((cxDst >= 128) && (xAlign <= 15));

        if (!bHwBug)
        {
            CP_WRITE(pjBase, DWG_SHIFT, 0);
            CP_WRITE(pjBase, DWG_AR3,   xAlign);
            CP_START(pjBase, DWG_AR0,   xAlign + cxDst - 1);
        }
        else
        {
            // We have to work around a hardware bug.  Start 8 pels to
            // the left of the original start.

            CP_WRITE(pjBase, DWG_AR3,   xAlign + 8);
            CP_WRITE(pjBase, DWG_AR0,   xAlign + cxDst + 31);
            CP_START(pjBase, DWG_SHIFT, (24 << 16));
        }

        // We have to ensure that the command has been started before doing
        // the BLT_WRITE_ON:

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
        BLT_WRITE_ON(ppdev, pjBase);

        // Point to the first dword of the source bitmap that is to be
        // downloaded:

        pulSrc = (ULONG*) (pjSrcScan0 + (((prcl->top + dy) * lSrcDelta
                                      + ((prcl->left + dx) >> 3)) & ~3L));

        // Calculate the number of dwords to be moved per scanline.  Since
        // we align the starting dword on a dword boundary, we know that
        // we cannot overflow the end of the bitmap:

        cdSrc = (xAlign + cxDst + 31) >> 5;

        lSrcSkip = lSrcDelta - (cdSrc << 2);

        if (!(bHwBug) && (lSrcSkip == 0))
        {
            // It's rather frequent that there will be no scan-to-scan
            // delta, and no hardware bug, so we can go full speed:

            cdSrc *= cyDst;

            cFullLoops = ((cdSrc - 1) / FIFOSIZE);
            cRemLoops = ((cdSrc - 1) % FIFOSIZE) + 1;

            pulDst = (ULONG*) pjDma;

            if (cFullLoops > 0)
            {
                do {
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

                    for (i = FIFOSIZE; i != 0; i--)
                    {
                        CP_WRITE_DMA(ppdev, pulDst, *pulSrc ^ ulBitFlip);
                        pulSrc++;
                    }
                } while (--cFullLoops != 0);
            }

            CHECK_FIFO_SPACE(pjBase, (LONG) cRemLoops);

            do {
                CP_WRITE_DMA(ppdev, pulDst, *pulSrc ^ ulBitFlip);
                pulSrc++;
            } while (--cRemLoops != 0);
        }
        else
        {
            // Okay, blt it the slow way:

            cFifo = 0;

            do {
                pulDst = (ULONG*) pjDma;

                if (bHwBug)
                {
                    if (--cFifo < 0)
                    {
                        cFifo = FIFOSIZE - 1;
                        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                    }
                    CP_WRITE_DMA(ppdev, pulDst, 0);  // Account for hardware bug
                }

                for (i = cdSrc; i != 0; i--)
                {
                    if (--cFifo < 0)
                    {
                        cFifo = FIFOSIZE - 1;
                        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                    }
                    CP_WRITE_DMA(ppdev, pulDst, *pulSrc++ ^ ulBitFlip);
                }

                pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

            } while (--cyDst != 0);
        }

        BLT_WRITE_OFF(ppdev, pjBase);

        if (--c == 0)
            break;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 7);
    }
}

/******************************Public*Routine******************************\
* VOID vMgaCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vMgaCopyBlt(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // Rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    FLONG   flDirCode;
    LONG    lSignedPitch;
    ULONG   ulHwMix;
    ULONG   ulDwg;
    LONG    yDst;
    LONG    ySrc;
    LONG    cy;
    LONG    xSrc;
    LONG    lSignedWidth;
    LONG    lSrcStart;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;         // Add to destination to get source

    flDirCode    = DRAWING_DIR_TBLR;
    lSignedPitch = ppdev->cxMemory;

    // If the destination and source rectangles overlap, we will have to
    // tell the accelerator in which direction the copy should be done:

    if (OVERLAP(prclDst, pptlSrc))
    {
        if (prclDst->left > pptlSrc->x)
        {
            flDirCode |= scanleft_RIGHT_TO_LEFT;
        }
        if (prclDst->top > pptlSrc->y)
        {
            flDirCode |= sdy_BOTTOM_TO_TOP;
            lSignedPitch = -lSignedPitch;
        }
    }

    if (rop4 == 0xcccc)
    {
        ulDwg = opcode_BITBLT + atype_RPL + blockm_OFF + bltmod_BFCOL +
                pattern_OFF + transc_BG_OPAQUE + bop_SRCCOPY;
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulDwg = opcode_BITBLT + atype_RSTR + blockm_OFF + bltmod_BFCOL +
                pattern_OFF + transc_BG_OPAQUE + (ulHwMix << 16);
    }

    // The SRC0 to SRC3 registers are probably trashed by the blt, and we
    // may be using a different SGN:

    ppdev->HopeFlags = 0;

    CHECK_FIFO_SPACE(pjBase, 10);

    CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);
    CP_WRITE(pjBase, DWG_SHIFT,  0);
    CP_WRITE(pjBase, DWG_SGN,    flDirCode);
    CP_WRITE(pjBase, DWG_AR5,    lSignedPitch);

    while (TRUE)
    {
        CP_WRITE(pjBase, DWG_LEN,     prcl->bottom - prcl->top);
        CP_WRITE(pjBase, DWG_FXLEFT,  prcl->left  + xOffset);
        CP_WRITE(pjBase, DWG_FXRIGHT, prcl->right + xOffset - 1);

        yDst = yOffset + prcl->top;
        ySrc = yOffset + prcl->top + dy;

        if (flDirCode & sdy_BOTTOM_TO_TOP)
        {
            cy = prcl->bottom - prcl->top - 1;
            yDst += cy;
            ySrc += cy;
        }

        CP_WRITE(pjBase, DWG_YDST, yDst);

        xSrc         = xOffset + prcl->left + dx;
        lSignedWidth = prcl->right - prcl->left - 1;
        if (flDirCode & scanleft_RIGHT_TO_LEFT)
        {
            xSrc += lSignedWidth;
            lSignedWidth = -lSignedWidth;
        }

        lSrcStart = ppdev->ulYDstOrg + (ySrc * ppdev->cxMemory) + xSrc;
        CP_WRITE(pjBase, DWG_AR3, lSrcStart);
        CP_START(pjBase, DWG_AR0, lSrcStart + lSignedWidth);

        if (--c == 0)
            break;

        CHECK_FIFO_SPACE(pjBase, 6);
        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\blt24.c ===
/******************************Module*Header*******************************\
* Module Name: blt32.c
*
* This module contains the low-level blt functions that are specific to
* 32bpp.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMgaPatRealize24bpp
*
\**************************************************************************/

VOID vMgaPatRealize24bpp(
PDEV*   ppdev,
RBRUSH* prb)
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        i;
    ULONG*      pulSrc;

    pjBase = ppdev->pjBase;

    // We have to allocate a new off-screen cache brush entry for
    // the brush:

    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->pbe[iBrushCache];

    iBrushCache++;
    if (iBrushCache >= ppdev->cBrushCache)
        iBrushCache = 0;

    ppdev->iBrushCache = iBrushCache;

    // Update our links:

    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    CHECK_FIFO_SPACE(pjBase, 11);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL + blockm_OFF +
                                  bop_SRCCOPY + bltmod_BUCOL + pattern_OFF +
                                  transc_BG_OPAQUE + hcprs_SRC_24_BPP));

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    // The SRC0 - SRC3 registers will be trashed by the blt:

    ppdev->HopeFlags = SIGN_CACHE;

    // Since our brushes are always interleaved, we want to send down
    // 2 pels, skip 2 pels, send down 2 pels, etc.  So we contrive to
    // adjust the blt width and pitch to do that automatically for us:

    CP_WRITE(pjBase, DWG_AR3,     0);       // Source start address, not
                                            //   included in ARX_CACHE
    CP_WRITE(pjBase, DWG_SHIFT,   0);
    CP_WRITE(pjBase, DWG_LEN,     8);       // Transfering 8 scans
    CP_WRITE(pjBase, DWG_AR0,     8);       // Source width is 9
    CP_WRITE(pjBase, DWG_AR5,     32);      // Source pitch is 32

    // I'm guessing that there was a hardware bug found with FXLEFT
    // or FXRIGHT being 32 or greater, because the old code does a
    // modulo 32 on 'x' for a reason:

    CP_WRITE(pjBase, DWG_FXLEFT,  pbe->ulLeft);
    CP_WRITE(pjBase, DWG_FXRIGHT, pbe->ulLeft + 15);
    CP_WRITE(pjBase, DWG_YDST,    pbe->ulYDst);
    CP_START(pjBase, DWG_PITCH,   32 + ylin_LINEARIZE_NOT);

    CHECK_FIFO_SPACE(pjBase, 32);

    ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP,
             "Expect 24bpp packed pattern.  You may have to change RealizeBrush");

    for (pulSrc = prb->aulPattern, i = 8; i != 0; i--, pulSrc += 6)
    {
        CP_WRITE_SRC(pjBase, *(pulSrc));
        CP_WRITE_SRC(pjBase, *(pulSrc + 1));
        CP_WRITE_SRC(pjBase, *(pulSrc + 2));
        CP_WRITE_SRC(pjBase, *(pulSrc + 3));
        CP_WRITE_SRC(pjBase, *(pulSrc + 4));
        CP_WRITE_SRC(pjBase, *(pulSrc + 5));

        // The pattern has to be 9 pixels wide, with an extra copy of
        // the first pixel:

        CP_WRITE_SRC(pjBase, *(pulSrc ));
    }

    // Don't forget to restore the pitch:

    CHECK_FIFO_SPACE(pjBase, 1);
    CP_WRITE(pjBase, DWG_PITCH, ppdev->cxMemory);
}

/******************************Public*Routine******************************\
* VOID vMgaFillPat24bpp
*
\**************************************************************************/

VOID vMgaFillPat24bpp(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    CHAR        cFifo;
    ULONG       ulHwMix;
    LONG        xLeft;
    LONG        xRight;
    LONG        yTop;
    LONG        cx;
    LONG        cy;
    LONG        xBrush;
    LONG        yBrush;
    ULONG       ulLinear;
    LONG        i;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");

    ASSERTDD((rbc.prb != NULL) && (rbc.prb->apbe[IBOARD(ppdev)] != NULL),
             "apbe[iBoard] should be initialized to &beUnrealizedBrush");

    // We have to ensure that no other brush took our spot in off-screen
    // memory, or we might have to realize the brush for the first time:

    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if (pbe->prbVerify != rbc.prb)
    {
        vMgaPatRealize24bpp(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    do {
        cFifo = GET_FIFO_SPACE(pjBase) - 4;
    } while (cFifo < 0);

    if (rop4 == 0xf0f0)         // PATCOPY
    {
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + blockm_OFF +
                                      trans_0 + bltmod_BUCOL + pattern_ON +
                                      transc_BG_OPAQUE + bop_SRCCOPY));
    }
    else
    {
        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + blockm_OFF +
                                      trans_0 + bltmod_BUCOL + pattern_ON +
                                      transc_BG_OPAQUE + (ulHwMix << 16)));
    }

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
    }

    ppdev->HopeFlags = SIGN_CACHE;

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_AR5,   32);

    do {
        yTop     = prcl->top;
        cy       = prcl->bottom - yTop;
        xLeft    = prcl->left;
        cx       = prcl->right - xLeft - 1;         // Note inclusiveness
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulLinear = pbe->ulLinear + (yBrush << 5);

        // Convert to absolute coordinates:

        xLeft += xOffset;
        yTop  += yOffset;

        // Due to hardware limitations, we have to draw the rectangle
        // in four or five passes.  On each pass, a maximum of two columns
        // of the brush can be drawn.

        if (xLeft & 1)
        {
            // It seems to be a hardware limitation that our passes always
            // to start on an even pixel when the width is more than one.
            // As such, do an initial strip of width one to align to an even
            // pixel:

            cFifo -= 6;
            while (cFifo < 0)
            {
                cFifo = GET_FIFO_SPACE(pjBase) - 6;
            }

            CP_WRITE(pjBase, DWG_LEN,     cy);
            CP_WRITE(pjBase, DWG_YDST,    yTop);
            CP_WRITE(pjBase, DWG_AR3,     ulLinear + xBrush);
            CP_WRITE(pjBase, DWG_AR0,     ulLinear + xBrush + 3);
            CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
            CP_START(pjBase, DWG_FXRIGHT, xLeft);

            xBrush = (xBrush + 1) & 7;
            xLeft++;
            cx--;
            if (cx < 0)                             // Recall inclusiveness
                continue;
        }

        i = 4;
        do {
            cFifo -= 6;
            while (cFifo < 0)
            {
                cFifo = GET_FIFO_SPACE(pjBase) - 6;
            }

            CP_WRITE(pjBase, DWG_LEN,     cy);
            CP_WRITE(pjBase, DWG_YDST,    yTop);
            CP_WRITE(pjBase, DWG_AR3,     ulLinear + xBrush);
            CP_WRITE(pjBase, DWG_AR0,     ulLinear + xBrush + 3);
            CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);

            xRight = xLeft + (cx & ~7);
            if (cx & 7)
                xRight++;

            CP_START(pjBase, DWG_FXRIGHT, xRight);

            if (--i == 0)
                break;

            xBrush = (xBrush + 2) & 7;
            xLeft += 2;
            cx    -= 2;

        } while (cx >= 0);

    } while (prcl++, --c != 0);
}

/******************************Public*Routine******************************\
* VOID vMgaGetBits24bpp
*
* Reads the bits from the screen at 24bpp
\**************************************************************************/

VOID vMgaGetBits24bpp(
PDEV*     ppdev,        // Current src pdev
SURFOBJ*  psoDst,       // Destination surface for the color bits
RECTL*    prclDst,      // Area to be modified within the dest surface,
                        //   in absolute coordinates
POINTL*   pptlSrc)      // Upper left corner of source rectangle,
                        //   in absolute coordinates
{
    BYTE*   pjBase;
    BYTE*   pbScan0;
    BYTE*   pbDestRect;
    LONG    xSrc, ySrc, xTrg, yTrg, cxTrg, cyTrg, lDestDelta;
    ULONG   temp, ulSSA, ulSSAIncrement, HstStatus, AbortCnt;
    LONG    i, NbDWords;
    ULONG*  pulDest;
    ULONG*  locpulDest;
    ULONG*  pDMAWindow;

    pjBase = ppdev->pjBase;

    AbortCnt = 1000;

    // Calculate the size of the target rectangle, and pick up
    // some convenient locals.

    // Starting (x,y) and extents within the destination bitmap.
    // If an extent is 0 or negative, we don't have anything to do.

    cxTrg = prclDst->right - prclDst->left;
    cyTrg = prclDst->bottom - prclDst->top;
    xTrg  = prclDst->left;
    yTrg  = prclDst->top;

    ASSERTDD(cxTrg > 0 && cyTrg > 0, "Shouldn't get empty extents");

    // First scanline of the destination bitmap.

    pbScan0 = (BYTE*) psoDst->pvScan0;

    // Starting (x,y) on the screen.

    xSrc = pptlSrc->x;
    ySrc = pptlSrc->y;

    // Scan increment within the destination bitmap.

    lDestDelta = psoDst->lDelta;

    // Calculate the location of the destination rectangle.

    pbDestRect = pbScan0 + (yTrg * lDestDelta);
    pbDestRect += 3*xTrg;

    // Set the registers that can be set now for the operation.
    // SIGN_CACHE=1 and cuts 1 register from the setup.

    CHECK_FIFO_SPACE(pjBase, 7);

    // DWGCTL   IDUMP+RPL+SRCCOPY+blockm_OFF+bltmod_BUCOL+patt_OFF+BG_OPAQUE
    // SGN      0
    // SHIFT    0
    // AR0      sea: ySrc*pitch + xSrc + cxTrg - 1
    // AR3      ssa: ySrc*pitch + xSrc
    // AR5      Screen pitch
    // FXLEFT   0
    // FXRIGHT  cxTrg - 1
    // LEN      cyTrg

    if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SGN, 0);
        ppdev->HopeFlags |= SIGN_CACHE;
    }

    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_YDST, 0);

    CP_WRITE(pjBase, DWG_FXLEFT, 0);
    CP_WRITE(pjBase, DWG_FXRIGHT, (cxTrg - 1));

    CP_WRITE(pjBase, DWG_AR5, ppdev->cxMemory);

    // The SRC0-3 registers are trashed by the blt.

    ppdev->HopeFlags &= ~(ARX_CACHE | PATTERN_CACHE);

    CP_WRITE(pjBase, DWG_DWGCTL, (opcode_IDUMP+atype_RPL+blockm_OFF+
                                  bop_SRCCOPY+bltmod_BUCOL+pattern_OFF+
                                  transc_BG_OPAQUE));

    // We won't have a full-speed routine, because we must read 32 bits per
    // pixel and either store only 24 bits (if the destination bitmap is
    // 24bpp), or mask out the eight msb's and then store 32 bits (if the
    // destination bitmap is 32bpp).

    // Source Start Address of the first slice.

    ulSSA = ySrc * ppdev->cxMemory + xSrc + ppdev->ulYDstOrg;

    // Increment to get to the SSA of the next scanline.

    ulSSAIncrement = ppdev->cxMemory;

    // Number of full dwords to be read within the loop on each scan.

    NbDWords = cxTrg - 1;

    pDMAWindow = (ULONG*) (ppdev->pjBase + DMAWND);

    locpulDest = (ULONG*) pbDestRect;

    // No color translation while copying.
    while (cyTrg-- > 0)
    {
        do {
            CHECK_FIFO_SPACE(pjBase, 3);

            // This is where we'll start storing data.

            pulDest = locpulDest;

            // Complete the IDUMP setup.

            CP_WRITE(pjBase, DWG_AR3, ulSSA);
            CP_WRITE(pjBase, DWG_AR0, ulSSA + cxTrg - 1);

            // Turn the pseudoDMA on.

            BLT_READ_ON(ppdev, pjBase);

            CP_START(pjBase, DWG_LEN, 1);

            // Make sure the setup is complete.

            CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

            if (NbDWords)
            {
                // There is at least one dword left to be read.

                // Copy a number of full dwords from the current scanline.

                for (i = 0; i < NbDWords; i++)
                {
                    temp = CP_READ_DMA(ppdev, pDMAWindow);

                    * ((UCHAR*)pulDest + 0) = (UCHAR) (temp);
                    * ((UCHAR*)pulDest + 1) = (UCHAR) (temp >> 8);
                    * ((UCHAR*)pulDest + 2) = (UCHAR) (temp >> 16);
                    (UCHAR*)pulDest += 3;
                }
            }

            // Check for the EngineBusy flag.

            for (i = 0; i < 7; i++)
            {
                HstStatus = CP_READ_STATUS(pjBase);
            }
            if (HstStatus &= (dwgengsts_MASK >> 16))
            {
                // The drawing engine is still busy, while it should not be:
                // there was a problem with this slice.

                // Empty the DMA window.

                do {
                    CP_READ_DMA(ppdev, pDMAWindow);

                    // Check for the EngineBusy flag.  If the engine is still
                    // busy, then we'll have to read another dword.

                    for (i = 0; i < 7; i++)
                    {
                        temp = CP_READ_STATUS(pjBase);
                    }
                } while (temp & (dwgengsts_MASK >> 16));

                // The DMA window should now be empty.

                // We cannot check the HST_STATUS two lower bytes anymore,
                // so this is new.

                if (--AbortCnt > 0)
                {
                    // Signal we'll have to do this again.
                    HstStatus = 1;
                }
                else
                {
                    // We tried hard enough, desist.
                    HstStatus = 0;
                }
            }
            // The last dword to be read should be available now.

            temp = CP_READ_DMA(ppdev, pDMAWindow);
            * ((UCHAR*)pulDest + 0) = (UCHAR) (temp);
            * ((UCHAR*)pulDest + 1) = (UCHAR) (temp >> 8);
            * ((UCHAR*)pulDest + 2) = (UCHAR) (temp >> 16);

            // Turn the pseudoDMA off.

            BLT_READ_OFF(ppdev, pjBase);

            // Redo the whole thing if there was a problem with this slice.

        } while (HstStatus);

        // We're done with the current scanline, deal with the next one.

        (UCHAR*) locpulDest += lDestDelta;
        ulSSA += ulSSAIncrement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
PDEV*   ppdev,
RBRUSH* prb,
ULONG   ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->fl         = 0;
    prb->pfnFillPat = ppdev->pfnFillPatNative;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = &ppdev->beUnrealizedBrush;
    }
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*       ppdev;
    ULONG       iPatternFormat;
    BYTE        jSrc;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        lSrcDelta;
    LONG        cj;
    LONG        i;
    LONG        j;
    RBRUSH*     prb;
    ULONG*      pulXlate;
    SURFOBJ*    psoPunt;
    RECTL       rclDst;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
            goto ReturnFalse;

        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + ppdev->ulBrushSize);
        if (prb == NULL)
            goto ReturnFalse;

        DISPDBG((5, "Realizing dithered brush"));

        vRealizeDitherPattern(ppdev, prb, iHatch);
        goto DoneWith8x8;
    }

    // We only handle colour brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it).
    //
    // We also only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8) ||
        ((psoPattern->iBitmapFormat != BMF_1BPP) &&
         !(ppdev->flStatus & STAT_BRUSH_CACHE)))
    {
        goto ReturnFalse;
    }

    prb = BRUSHOBJ_pvAllocRbrush(pbo,
          sizeof(RBRUSH) + ppdev->ulBrushSize);
    if (prb == NULL)
    {
        goto ReturnFalse;
    }

    // Initialize the fields we need:

    prb->fl         = 0;
    prb->pfnFillPat = ppdev->pfnFillPatNative;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = &ppdev->beUnrealizedBrush;
    }

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    iPatternFormat = psoPattern->iBitmapFormat;
    if ((ppdev->iBitmapFormat == iPatternFormat) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        DISPDBG((5, "Realizing un-translated brush"));

        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done:

        cj = (8 * ppdev->cjPelSize);    // Every pattern is 8 pels wide

        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
        }
    }
    else if (iPatternFormat == BMF_1BPP)
    {
        if (ppdev->cjHwPel == 3)
        {
            // [!!!] - add true 24 bpp support
            goto ReturnFalse;
        }

        DISPDBG((5, "Realizing 1bpp brush"));

        // Since we allocated at least 64 bytes when we did our
        // BRUSHOBJ_pvAllocBrush call, we've got plenty of space
        // to store our monochrome brush.
        //
        // Since the Windows convention for monochrome bitmaps is that
        // the MSB of a given byte represents the leftmost pixel, which
        // is opposite that of the MGA, we must reverse the order of
        // each byte before using it in SRC0 through SRC3.  Moreover,
        // each byte must be replicated so as to yield a 16x8 pattern.

        for (i = 8; i != 0; i--)
        {
            jSrc         = gajFlip[*pjSrc];
            *(pjDst)     = jSrc;
            *(pjDst + 1) = jSrc;
            pjDst       += 2;
            pjSrc       += lSrcDelta;
        }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulColor[1]  = pulXlate[1];
        prb->ulColor[0]  = pulXlate[0];
        prb->pfnFillPat  = vFillPat1bpp;
    }
    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        DISPDBG((5, "Realizing 4bpp brush"));

        // The screen is 8bpp and the pattern is 4bpp:

        ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                 (iPatternFormat == BMF_4BPP),
                 "Messed up brush logic");

        pulXlate = pxlo->pulXlate;

        for (i = 8; i != 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop
            // handles 2 pixels:

            for (j = 4; j != 0; j--)
            {
                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                pjSrc++;
            }

            pjSrc += lSrcDelta - 4;
        }
    }
    else
    {
        // We've got a brush whose format we haven't special cased.  No
        // problem, we can have GDI convert it to our device's format.
        // We simply use a temporary surface object that was created with
        // the same format as the display, and point it to our brush
        // realization:

        DISPDBG((5, "Realizing funky brush"));

        psoPunt          = ppdev->psoPunt;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = 8 * ppdev->cjPelSize;

        rclDst.left      = 0;
        rclDst.top       = 0;
        rclDst.right     = 8;
        rclDst.bottom    = 8;

        if (!EngCopyBits(psoPunt, psoPattern, NULL, pxlo,
                         &rclDst, (POINTL*) &rclDst))
        {
            goto ReturnFalse;
        }
    }

DoneWith8x8:

    if ((ppdev->ulBoardId == MGA_STORM) &&
        (ppdev->cjHwPel == 3) &&
        (iPatternFormat != BMF_1BPP))
    {
        // The display is at 24bpp, we need to build a special 16x8 brush.
        // We already have an 8x8 pattern.
        cj    = 8 * 3;
        pjSrc = (BYTE*) &prb->aulPattern + (7 * cj);
        pjDst = (BYTE*) &prb->aulPattern + (7 * 2 * cj);

        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);
            pjDst += cj;
            RtlCopyMemory(pjDst, pjSrc, cj);
            pjSrc -= cj;
            pjDst -= (3 * cj);
        }
    }

    return(TRUE);

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((5, "Failed realization -- Type: %li Format: %li cx: %li cy: %li flags: %x",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy, ppdev->flStatus));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bMilEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
* Millenium (storm) specific.
\**************************************************************************/

BOOL bMilEnableBrushCache(
    PDEV*   ppdev)
{
    OH*             poh;            // Points to off-screen chunk of memory
    BRUSHENTRY*     pbe;            // Pointer to the brush-cache entry
    ULONG           ulLinearStart;
    ULONG           ulLinearEnd;
    LONG            cBrushCache;
    ULONG           ulTmp;
    LONG            x;
    LONG            y;
    LONG            i;

    pbe = ppdev->pbe;       // Points to where we'll put the first brush
                            //   cache entry

    poh = pohAllocate(ppdev,
                      NULL,
                      ppdev->cxMemory,
                      BRUSH_CACHE_HEIGHT,
                      FLOH_MAKE_PERMANENT);
    if (poh == NULL)
    {
        DISPDBG((2, "Brush cache NOT enabled"));
        goto ReturnTrue;    // See note about why we can return TRUE...
    }

    ulLinearStart = (poh->y  * ppdev->cxMemory) + ppdev->ulYDstOrg;
    ulLinearEnd   = (poh->cy * ppdev->cxMemory) + ulLinearStart;

    // The brushes must be stored with a 256-pel alignment.

    ulLinearStart = (ulLinearStart + 0xff) & ~0xff;

    // In general, we'll be caching 8x8 brushes, so the number of cached
    // brushes can be four times the number of 256-pel slices that can be
    // stored from ulLinearStart to ulLinearEnd.  In 24bpp, however, we'll
    // be caching 16x8 brushes, so we can cache only half this number.

    // Moreover, there are wrapping problems when a brush is stored in
    // the last slot of a 256-pel slice, so it's best not to use it.

    cBrushCache = (ulLinearEnd - ulLinearStart) >> 8;

    if (ppdev->cjPelSize == 3)
    {
        cBrushCache *= 2;       // 24bpp, Don't forget they come in pairs...
    }
    else
    {
        cBrushCache *= 3;       // ... or more, but beware of some slots!
    }

    pbe = EngAllocMem(FL_ZERO_MEMORY, cBrushCache * sizeof(BRUSHENTRY), ALLOC_TAG);

    if (pbe == NULL)
        goto ReturnTrue;    // See note about why we can return TRUE...

    ppdev->cBrushCache = cBrushCache;
    ppdev->pbe         = pbe;

    for (i = 0; i < cBrushCache; i++)
    {
        // If we hadn't allocated 'pbe' with FL_ZERO_MEMORY, we would have
        // to initialize pbe->prbVerify, too...

        // Set up linear coordinate for reading the pattern from offscreen
        // memory.

        pbe->ulLinear = ulLinearStart;

        // Set up coordinates for writing the pattern into offscreen
        // memory, assuming a HW_PATTERN_PITCH stride.

        ulTmp       = ulLinearStart - ppdev->ulYDstOrg;
        x           = ulTmp % ppdev->cxMemory;
        y           = ulTmp / ppdev->cxMemory;
        pbe->ulLeft = x & 31;
        pbe->ulYDst = (y * ppdev->cxMemory + x) >> 5;

        pbe->pvScan0 = ppdev->pjScreen +
                       ((ulTmp + ppdev->ulYDstOrg) * ppdev->cjPelSize);

        // Prepare for the next brush, accounting for the interleave.

        if (ppdev->cjHwPel == 3)
        {
            // At 24bpp, every second cached brush starts on a 256+16
            // boundary.

            if ((i & 1) == 0)
            {
                ulLinearStart += 16;
            }
            else
            {
                ulLinearStart += (256 - 16);
            }
        }
        else
        {
            // In general, we have three brushes in every 256-pel slice.

            if ((i % 3) == 2)
            {
                ulLinearStart += (256 - 16);
            }
            else
            {
                ulLinearStart += 8;
            }
        }

        pbe++;
    }

    // When we create a new brush, we always point it to our
    // 'beUnrealizedBrush' entry, which will always have 'prbVerify'
    // set to NULL.  In this way, we can remove an 'if' from our
    // check to see if we have to realize the brush in 'vFillPat' --
    // we only have to compare to 'prbVerify'.

    ppdev->beUnrealizedBrush.prbVerify = NULL;

    // Note that we don't have to remember 'poh' for when we have
    // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it.

    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:


    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bMilEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*             poh;            // Points to off-screen chunk of memory
    BRUSHENTRY*     pbe;            // Pointer to the brush-cache entry
    ULONG           ulLinearStart;
    ULONG           ulLinearEnd;
    LONG            cBrushCache;
    ULONG           ulTmp;
    LONG            x;
    LONG            y;
    LONG            i;

    if (ppdev->ulBoardId == MGA_STORM)
    {
        return(bMilEnableBrushCache(ppdev));
    }

    pbe = ppdev->pbe;       // Points to where we'll put the first brush
                            //   cache entry

    poh = pohAllocate(ppdev,
                      NULL,
                      ppdev->cxMemory,
                      BRUSH_CACHE_HEIGHT,
                      FLOH_MAKE_PERMANENT);
    if (poh == NULL)
        goto ReturnTrue;    // See note about why we can return TRUE...

    ulLinearStart = (poh->y             * ppdev->cxMemory) + ppdev->ulYDstOrg;
    ulLinearEnd   = (BRUSH_CACHE_HEIGHT * ppdev->cxMemory) + ulLinearStart;

    // An MGA brush is always cached with a 256-pel alignment.  The brush
    // can be 16x16, or two interleaved 16x8 brushes.  We use the second
    // option, so that every second brush starts on a 256+16 alignment.
    //
    // So the brushes are stored in pairs, with a 256-pel alignment:

    ulLinearStart = (ulLinearStart + 0xff) & ~0xff;

    cBrushCache = (ulLinearEnd - ulLinearStart) >> 8;
    cBrushCache *= 2;       // Don't forget they're pairs

    pbe = EngAllocMem(FL_ZERO_MEMORY,
                     cBrushCache * sizeof(BRUSHENTRY), ALLOC_TAG);
    if (pbe == NULL)
        goto ReturnTrue;    // See note about why we can return TRUE...

    ppdev->cBrushCache = cBrushCache;
    ppdev->pbe         = pbe;

    do {
        // If we hadn't allocated 'pbe' with FL_ZERO_MEMORY, we would have
        // to initialize pbe->prbVerify, too...

        // Set up linear coordinate for reading the pattern from offscreen
        // memory:

        pbe->ulLinear = ulLinearStart;

        // Set up coordinates for writing the pattern into offscreen
        // memory, assuming a '32' stride:

        ulTmp         = ulLinearStart - ppdev->ulYDstOrg;
        x             = ulTmp % ppdev->cxMemory;
        y             = ulTmp / ppdev->cxMemory;
        pbe->ulLeft   = x & 31;
        pbe->ulYDst   = (y * ppdev->cxMemory + x) >> 5;

        // Account for the interleave, where every second cached brush
        // starts on a 256+16 boundary:

        if ((cBrushCache & 1) == 0)
        {
            ulLinearStart += 16;
        }
        else
        {
            ulLinearStart += (256 - 16);
        }

    } while (pbe++, --cBrushCache != 0);

    // When we create a new brush, we always point it to our
    // 'beUnrealizedBrush' entry, which will always have 'prbVerify'
    // set to NULL.  In this way, we can remove an 'if' from our
    // check to see if we have to realize the brush in 'vFillPat' --
    // we only have to compare to 'prbVerify':

    ppdev->beUnrealizedBrush.prbVerify = NULL;

    // Note that we don't have to remember 'poh' for when we have
    // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:

    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    EngFreeMem(ppdev->pbe);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY*     pbe;
    LONG            i;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = ppdev->pbe;

        for (i = ppdev->cBrushCache; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\bltmil.c ===
/******************************Module*Header*******************************\
* Module Name: bltmil.c
*
* Contains the low-level blt functions for the Millenium.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMilFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMilFillSolid(
    PDEV*           ppdev,      // pdev
    LONG            c,          // Number of rectangles to be filled,
                                // can't be zero
    RECTL*          prcl,       // List of rectangles to be filled
    ULONG           rop4,       // Rop4
    RBRUSH_COLOR    rbc,        // rbc.prb points to brush realization structure
    POINTL*         pptlBrush)  // Pattern alignment
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulDwg;
    ULONG   ulHwMix;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    CHECK_FIFO_SPACE(pjBase, 4);

    ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE);

    if (rop4 == 0xf0f0)         // PATCOPY
    {
        if (ppdev->iBitmapFormat == BMF_24BPP)
        {
            if (((rbc.iSolidColor & 0x000000ff) !=
                 ((rbc.iSolidColor >> 8) & 0x000000ff)) ||
                ((rbc.iSolidColor & 0x000000ff) !=
                 ((rbc.iSolidColor >> 16) & 0x000000ff)))
            {
                // We're in 24bpp, and the color is not a gray level, so we
                // can't use block mode.
                ulDwg = (opcode_TRAP + blockm_OFF + atype_RPL + solid_SOLID +
                         arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                         bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
            }
            else
            {
                // We're in 24bpp, and the color is a gray level, so we
                // can use block mode if we prepare our color.
                rbc.iSolidColor = (rbc.iSolidColor << 8) |
                                  (rbc.iSolidColor & 0x000000ff);
                ulDwg   = (opcode_TRAP + blockm_ON + solid_SOLID +
                           arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                           bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
            }
        }
        else
        {
            // This is not 24bpp.
            ulDwg = (opcode_TRAP + blockm_ON + solid_SOLID +
                     arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                     bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
        }
    }
    else
    {
        // The ROP3 is a combination of P and D only:
        //
        //      ROP3  Mga   ROP3  Mga   ROP3  Mga   ROP3  Mga
        //
        //      0x00  0     0x50  4     0xa0  8     0xf0  c
        //      0x05  1     0x55  5     0xa5  9     0xf5  d
        //      0x0a  2     0x5a  6     0xaa  a     0xfa  e
        //      0x0f  3     0x5f  7     0xaf  b     0xff  f

        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        if (ulHwMix == MGA_WHITENESS)
        {
            rbc.iSolidColor = 0xffffffff;
            ulDwg = (opcode_TRAP + blockm_ON + solid_SOLID +
                     arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                     bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
        }
        else if (ulHwMix == MGA_BLACKNESS)
        {
            rbc.iSolidColor = 0x00000000;
            ulDwg = (opcode_TRAP + blockm_ON + solid_SOLID +
                     arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                     bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
        }
        else
        {
            ulDwg = (opcode_TRAP + blockm_OFF + atype_RSTR + solid_SOLID +
                     arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                     pattern_OFF + transc_BG_OPAQUE +
                     (ulHwMix << 16));
        }
    }

    CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);
    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, rbc.iSolidColor));

    while(TRUE)
    {
        CP_WRITE(pjBase, DWG_FXBNDRY,
                        (((prcl->right + xOffset) << bfxright_SHIFT) |
                         ((prcl->left  + xOffset) & bfxleft_MASK)));

        // ylength_MASK not is needed since coordinates are within range

        CP_START(pjBase, DWG_YDSTLEN,
                        (((prcl->top    + yOffset  ) << yval_SHIFT) |
                         ((prcl->bottom - prcl->top))));

        if (--c == 0)
            return;

        CHECK_FIFO_SPACE(pjBase, 2);
        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vMilPatRealize
*
* Download the Color Brush to the Color brush cache in the Storm offscreen
* memory.  For 8, 16, and 32 bpp, we download an 8x8 brush;  a special
* routine, vPatRealize24bpp, is used for 24bpp brushes.  We'll use direct
* frame buffer access whenever possible.
*
* There are some hardware restrictions concerning the way that a pattern
* must be stored in memory:
* - the first pixel of the pattern must be stored so that the first pixel
*   address mod 256 is 0, 8, 16, or 24;
* - each line of 8 pixels is stored continuously, but there must be a
*   difference of 32 in the pixel addresses of successive pattern lines.
* This means that we will store patterns in the following way:
*
* +----+---------------+---------------+---------------+---------------+
* |    |   Pattern 0   |   Pattern 1   |   Pattern 2   |   Pattern 3   |
* |Line|               |               |1 1 1 1 1 1 1 1|1 1 1 1 1 1 1 1|
* |    |0 1 2 3 4 5 6 7|8 9 a b c d e f|0 1 2 3 4 5 6 7|8 9 a b c d e f|
* +----+---------------+---------------+---------------+---------------+
* |  0 |*   *   *   *  |        X      |      o       o|x       x      |
* |  1 |  *   *   *   *|        X      |    o       o  |  x       x    |
* |  2 |*   *   *   *  |        X      |  o       o    |    x       x  |
* |  3 |  *   *   *   *|        X      |o       o      |      x       x|
* |  4 |*   *   *   *  |X X X X X X X X|      o       o|x       x      |
* |  5 |  *   *   *   *|        X      |    o       o  |  x       x    |
* |  6 |*   *   *   *  |        X      |  o       o    |    x       x  |
* |  7 |  *   *   *   *|        X      |o       o      |      x       x|
* +----+---------------+---------------+---------------+---------------+
*
* where a given pixel address is
*  FirstPixelAddress + Line*0x20 + Pattern*0x08 + xPat.
*
\**************************************************************************/

VOID vMilPatRealize(
    PDEV*   ppdev,
    RBRUSH* prb)
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    ULONG       culScan;
    ULONG       i;
    ULONG       j;
    ULONG*      pulBrush;
    ULONG*      pulDst;
    ULONG       lDeltaPat;

    pjBase = ppdev->pjBase;

    // Allocate a new off-screen cache brush entry for the brush.
    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->pbe[iBrushCache];

    iBrushCache++;
    if (iBrushCache >= ppdev->cBrushCache)
        iBrushCache = 0;

    ppdev->iBrushCache = iBrushCache;

    // Update our links.
    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    // Point to the pattern bits.
    pulBrush = prb->aulPattern;

    // Calculate delta from end of pattern scan 1 to start of pattern scan2.
    lDeltaPat = 8 * ppdev->cjHwPel;     // 8 -> 32?

    // Convert it to a byte address.
    culScan = 2 * ppdev->cjHwPel;

    pulDst = (ULONG*) (pbe->pvScan0);

    START_DIRECT_ACCESS_STORM(ppdev, pjBase);

    for (i = 8; i != 0 ; i--)
    {
        for (j = 0; j < culScan; j++)
        {
            pulDst[j] = *pulBrush++;
        }
        pulDst += lDeltaPat;
    }

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);
}

/*****************************************************************************
 * VOID vMilFillPat
 *
 * 8, 16, and 32bpp patterned color fills for Storm.
 ****************************************************************************/

VOID vMilFillPat(
    PDEV*           ppdev,
    LONG            c,          // Can't be zero
    RECTL*          prcl,       // List of rectangles to be filled, in relative
                                //   coordinates
    ULONG           rop4,       // Rop4
    RBRUSH_COLOR    rbc,        // rbc.prb points to brush realization structure
    POINTL*         pptlBrush)  // Pattern alignment
{
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    LONG        xBrush;
    LONG        yBrush;
    LONG        lSrcAdd;
    ULONG       ulLinear;
    BYTE*       pjBase;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");

    // We have to ensure that no other brush took our spot in off-screen
    // memory, or we might have to realize the brush for the first time.
    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if (pbe->prbVerify != rbc.prb)
    {
        vMilPatRealize(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjBase = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    lSrcAdd = ppdev->lPatSrcAdd;

    CHECK_FIFO_SPACE(pjBase, 6);

    CP_WRITE(pjBase, DWG_AR5, 32);   // Source (pattern) pitch.

    ppdev->HopeFlags = SIGN_CACHE;

    if ((rop4 & 0x000000FF) == 0x000000F0)
    {
        // The rop is PATCOPY.
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + sgnzero_ZERO +
                                   shftzero_ZERO + bop_SRCCOPY +
                                   bltmod_BFCOL + pattern_ON +
                                   transc_BG_OPAQUE));
    }
    else
    {
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + sgnzero_ZERO +
                                   shftzero_ZERO + bltmod_BFCOL + pattern_ON +
                                   transc_BG_OPAQUE +
                                   (((rop4 & 0x03) + ((rop4 & 0x30) >> 2))
                                                            << 16)));
    }

    // The pattern setup is complete.
    while(TRUE)
    {
        // There is a problem with Storm.  We have to program:
        //  AR3: ssa
        //  AR0: sea, where sea<18:3> = ssa<18:3> and
        //                  sea< 2:0> = ssa< 2:0> + 2 for 8bpp;
        //                  sea< 2:0> = ssa< 2:0> + 4 for 16bpp;
        //                  sea< 2:0> = ssa< 2:0> + 6 for 32bpp.

        // Take into account the brush origin.  The upper left pel of the
        // brush should be aligned here in the destination surface.
        yTop     = prcl->top;
        xLeft    = prcl->left;
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulLinear = pbe->ulLinear + (yBrush << 5) + xBrush;

        CP_WRITE(pjBase, DWG_AR3, ulLinear);
        CP_WRITE(pjBase, DWG_AR0, ((ulLinear & 0xfffffff8) |
                                   ((ulLinear+lSrcAdd) & 7)));

        CP_WRITE(pjBase, DWG_FXBNDRY,
                    (((prcl->right + xOffset - 1) << bfxright_SHIFT) |
                     ((xLeft       + xOffset) & bfxleft_MASK)));

        // ylength_MASK not is needed since coordinates are within range

        CP_START(pjBase, DWG_YDSTLEN,
                    (((yTop + yOffset     ) << yval_SHIFT) |
                     ((prcl->bottom - yTop))));

        if (--c == 0)
            return;

        CHECK_FIFO_SPACE(pjBase, 4);
        prcl++;
    }
}

/******************************Public*Routine******************************\
* vMilXfer1bpp
*
* This routine colour expands a monochrome bitmap.
*
\**************************************************************************/

VOID vMilXfer1bpp(          // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // List of destination rectangles, in relative
                            //   coordinates
    ULONG       rop4,       // Foreground and background hardware mix
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulBitFlip;
    LONG    dx;
    LONG    dy;
    LONG    xSrc;
    LONG    ySrc;
    LONG    xDst;
    LONG    yDst;
    LONG    cxDst;
    LONG    cyDst;
    LONG    xSrcAlign;
    LONG    lSrcDelta;
    LONG    lSrcSkip;
    LONG    i;
    LONG    k;
    LONG    cdSrc;
    LONG    cdSrcPerScan;
    ULONG   FCol;
    ULONG   BCol;
    ULONG   ul;
    BYTE*   pjDma;
    ULONG*  pulXlate;
    ULONG*  pulSrc;
    ULONG*  pulDst;
    BYTE*   pjSrcScan0;
    BYTE*   pjBase;
    LONG    cFifo;
    LONG    xAlign;
    ULONG   cFullLoops;
    ULONG   cRemLoops;

    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only an opaquing rop");

    pjBase = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    ulBitFlip = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    pjSrcScan0 = psoSrc->pvScan0;
    lSrcDelta  = psoSrc->lDelta;

    pjDma = pjBase + DMAWND;

    ppdev->HopeFlags = SIGN_CACHE;

    // Get the foreground and background colors.
    pulXlate = pxlo->pulXlate;
    FCol = COLOR_REPLICATE(ppdev, pulXlate[1]);
    BCol = COLOR_REPLICATE(ppdev, pulXlate[0]);

    CHECK_FIFO_SPACE(pjBase, 10);

    if (rop4 == 0x0000CCCC)     // SRCCOPY
    {
        if (ppdev->iBitmapFormat == BMF_24BPP)
        {
            CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL +
                                       sgnzero_ZERO + shftzero_ZERO +
                                       bop_SRCCOPY + bltmod_BMONOWF));
        }
        else
        {
            CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + blockm_ON +
                                       sgnzero_ZERO + shftzero_ZERO +
                                       bop_SRCCOPY + bltmod_BMONOWF));
        }
    }
    else if ((rop4 == 0xb8b8) || (rop4 == 0xe2e2))
    {
        // We special-cased 0xb8b8 and 0xe2e2 in bitblt.c:

        if (rop4 == 0xb8b8)
        {
            // 0xb8 is weird because it says that the '1' bit is leave-alone,
            // but the '0' bit is the destination color.  The Millennium can
            // only handle transparent blts when the '0' bit is leave-alone,
            // so we flip the source bits before we give it to the Millennium.
            //
            // Since we're limited by the speed of the bus, this additional
            // overhead of an extra XOR on every write won't be measurable.

            ulBitFlip = (ULONG) -1;
        }

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL + blockm_OFF +
                                         bop_SRCCOPY + trans_0 + bltmod_BMONO +
                                         pattern_OFF + hbgr_SRC_WINDOWS +
                                         transc_BG_TRANSP));
    }
    else
    {
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RSTR +
                                   sgnzero_ZERO + shftzero_ZERO +
                                   ((rop4 & 0xf) << 16) +
                                   bltmod_BMONOWF));
    }

    CP_WRITE(pjBase, DWG_BCOL, BCol);
    CP_WRITE(pjBase, DWG_FCOL, FCol);

    CP_WRITE(pjBase, DWG_AR5, 0);
    CP_WRITE(pjBase, DWG_SGN, 0);

    while (TRUE)
    {
        cxDst = prcl->right - prcl->left;
        cyDst = prcl->bottom - prcl->top;

        xDst  = prcl->left + xOffset;
        yDst  = prcl->top  + yOffset;

        ySrc  = prcl->top + dy;
        xSrc  = prcl->left + dx;

        // Since SSA (AR3) is always zero, we may have to clip the expanded
        // ILOAD using CXLEFT, and we'll have to modify FXLEFT accordingly.

        xSrcAlign = xSrc & 0x1F;
        if (xSrcAlign)
        {
            // We'll have to use clipping.

            CP_WRITE(pjBase, DWG_CXLEFT, xDst);
        }

        // Number of pixels per line.

        CP_WRITE(pjBase, DWG_AR0, (cxDst - 1 + xSrcAlign));
        CP_WRITE(pjBase, DWG_AR3, 0);
        CP_WRITE(pjBase, DWG_FXBNDRY, (((xDst + cxDst - 1) << bfxright_SHIFT) |
                                    ((xDst - xSrcAlign) & bfxleft_MASK)));

        // ylength_MASK not needed since coordinates are within range

        CP_START(pjBase, DWG_YDSTLEN, ((yDst << yval_SHIFT) | cyDst));

        // Calculate the location of the source rectangle.  This points to the
        // first dword to be downloaded.  It is aligned on a dword boundary.
        // The first bit of interest in the first dword is at (xSrc & 0x1f).

        pulSrc = (ULONG*)(pjSrcScan0 + (ySrc * lSrcDelta)
                                     + ((xSrc & 0xFFFFFFE0) >> 3));

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
        BLT_WRITE_ON(ppdev, pjBase);

        // Number of bytes, padded to the next dword, to be moved per
        // scanline.  Since we align the starting dword on a dword boundary,
        // we know that we cannot overflow the end of the bitmap.

        cdSrc = ((xSrcAlign + cxDst + 0x1F) & 0xFFFFFFE0) >> 3;

        lSrcSkip = lSrcDelta - cdSrc;

        if (lSrcSkip == 0)
        {
            // There is no line-to-line increment, we can go full speed.

            // Total number of dwords to be sent.

            cdSrc = cyDst * (cdSrc >> 2);
            while ((cdSrc -= FIFOSIZE) > 0)
            {
                pulDst = (ULONG*)pjDma;

                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

                for (i = FIFOSIZE; i != 0; i--)
                {
                    CP_WRITE_DMA(ppdev, pulDst++, *pulSrc++ ^ ulBitFlip);
                }
            }

            pulDst = (ULONG*)pjDma;
            cdSrc += FIFOSIZE;

            CHECK_FIFO_SPACE(pjBase, cdSrc);

            for (i = cdSrc; i != 0; i--)
            {
                CP_WRITE_DMA(ppdev, pulDst++, *pulSrc++ ^ ulBitFlip);
            }
        }
        else
        {
            // We can't go full speed.
            // Number of full dwords to be moved on each scan.  We know that
            // we won't overflow the end of the bitmap with this.

            cdSrc >>= 2;
            cdSrcPerScan = cdSrc;

            for (k = cyDst; k != 0; k--)
            {
                pulDst = (ULONG*)pjDma;
                cdSrc = cdSrcPerScan;

                while ((cdSrc -= FIFOSIZE) > 0)
                {
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

                    for (i = FIFOSIZE; i != 0; i--)
                    {
                        CP_WRITE_DMA(ppdev, pulDst++, *pulSrc++ ^ ulBitFlip);
                    }
                }

                cdSrc += FIFOSIZE;

                CHECK_FIFO_SPACE(pjBase, cdSrc);

                for (i = cdSrc; i != 0; i--)
                {
                    CP_WRITE_DMA(ppdev, pulDst++, *pulSrc++ ^ ulBitFlip);
                }

                // We're done with the current scan, go to the next one.

                pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
            }
        }

        BLT_WRITE_OFF(ppdev, pjBase);

        if (xSrcAlign)
        {
            // Restore the clipping:

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_CXLEFT, 0);
        }
        if (--c == 0)
            break;

        prcl++;
        CHECK_FIFO_SPACE(pjBase, 5);
    }
}

/******************************Public*Routine******************************\
* LONG lSplitRcl
*
* WRAM-WRAM blts can't span banks, and this routine does the tough work
* of figuring out how much of the blt can be done via WRAM-WRAM in one bank,
* then a regular blt over the bank boundary, and again WRAM-WRAM in the
* next bank.
*
\**************************************************************************/

LONG lSplitRcl(
RECTL   *arclDst,
LONG    *ayBreak,
LONG    cyBreak,
LONG    dy,
ULONG   flDirCode,
LONG    *aiCmd)
{
    LONG    iBreak = 0;
    LONG    iSrc = 0;
    LONG    iDst = 0;
    RECTL   rcl;
    LONG    lBoundsTop;
    LONG    lBoundsBottom;
    LONG    iCmdLast = 0;

    ///////////////////////////////////////////////////////////////////////////////
    // See [WRN] comment below before changing this macro.  This macro is
    // particular to this function.

    #define NON_EMPTY_RECT(rcl) ((rcl.right > rcl.left) && (rcl.bottom > rcl.top))

    aiCmd[0] = 0;

    if (cyBreak == 0)
    {
        return 1;
    }

    while (TRUE)
    {
        rcl = arclDst[iSrc];

        // Find the bounding scans of the union of the source and destination.

        lBoundsTop = min(rcl.top, rcl.top + dy);
        lBoundsBottom = max(rcl.bottom, rcl.bottom + dy);

        if ((ayBreak[iBreak] < lBoundsTop) ||
            (ayBreak[iBreak] >= lBoundsBottom))
        {
            // Do nothing
            iDst++;
            goto next_break;
        }

        // [WRN]  For the following, bottom could be less than top and
        //        right could be less than left.  These should be considered
        //        empty rectangles, and the macro above reflects this.

        arclDst[iDst].left     = rcl.left;
        arclDst[iDst].right    = rcl.right;
        arclDst[iDst].top      = rcl.top;
        arclDst[iDst].bottom   = min(rcl.bottom, (ayBreak[iBreak] - dy));
        if (NON_EMPTY_RECT(arclDst[iDst]))
        {
            aiCmd[iDst++] = 0;
            iCmdLast = 0;
        }

        arclDst[iDst].left     = rcl.left;
        arclDst[iDst].right    = rcl.right;
        arclDst[iDst].top      = max(rcl.top, (ayBreak[iBreak] - dy));
        arclDst[iDst].bottom   = min(rcl.bottom, (ayBreak[iBreak] + 1));
        if (NON_EMPTY_RECT(arclDst[iDst]))
        {
            aiCmd[iDst++] = 1;
            iCmdLast = 1;
        }

        arclDst[iDst].left     = rcl.left;
        arclDst[iDst].right    = rcl.right;
        arclDst[iDst].top      = max(rcl.top, (ayBreak[iBreak] + 1));
        arclDst[iDst].bottom   = rcl.bottom;
        if (NON_EMPTY_RECT(arclDst[iDst]))
        {
            aiCmd[iDst++] = 0;
            iCmdLast = 0;
        }

next_break:

        if ((--cyBreak == 0) ||
            (iCmdLast == 1))
        {
            // If we have run out of breaks, we're done.
            // Once the last rectangle is marked slow, it stays slow.

            break;
        }

        iSrc = --iDst;
        iBreak++;
    };

    return iDst;
}

/******************************Public*Routine******************************\
* VOID vMilCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vMilCopyBlt(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // Rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    FLONG   flDirCode;
    LONG    lSignedPitch;
    ULONG   ulHwMix;
    ULONG   ulDwg;
    LONG    yDst;
    LONG    ySrc;
    LONG    cy;
    LONG    xSrc;
    LONG    lSignedWidth;
    LONG    lSrcStart;
    ULONG   ulDwgFast = 0;
    LONG    cjPelSize;

    pjBase      = ppdev->pjBase;
    xOffset     = ppdev->xOffset;
    yOffset     = ppdev->yOffset;
    cjPelSize   = ppdev->cjPelSize;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;         // Add to destination to get source

    flDirCode    = DRAWING_DIR_TBLR;
    lSignedPitch = ppdev->cxMemory;

    // If the destination and source rectangles overlap, we will have to
    // tell the accelerator in which direction the copy should be done:

    if (OVERLAP(prclDst, pptlSrc))
    {
        if (prclDst->left > pptlSrc->x)
        {
            flDirCode |= scanleft_RIGHT_TO_LEFT;
        }
        if (prclDst->top > pptlSrc->y)
        {
            flDirCode |= sdy_BOTTOM_TO_TOP;
            lSignedPitch = -lSignedPitch;
        }
    }

    if (rop4 == 0xcccc)
    {
        ulDwg = opcode_BITBLT   | atype_RPL     | blockm_OFF        |
                bltmod_BFCOL    | pattern_OFF   | transc_BG_OPAQUE  |
                bop_SRCCOPY     | shftzero_ZERO | sgnzero_NO_ZERO;

        if ((dy > 0) && (dx == 0))
        {
            // We enable fast WRAM to WRAM blts only for upward scrolls.
            // We could enable it for more blts, but it has stringent
            // alignment requirements which aren't likely to be met unless
            // it's a vertical scroll.

            ulDwgFast = opcode_FBITBLT  | atype_RPL     | blockm_OFF        |
                        bltmod_BFCOL    | pattern_OFF   | transc_BG_OPAQUE  |
                        bop_NOP         | shftzero_ZERO | sgnzero_NO_ZERO;
        }
    }
    else
    {
        ulHwMix = rop4 & 0xf;

        ulDwg = opcode_BITBLT + atype_RSTR + blockm_OFF + bltmod_BFCOL +
                pattern_OFF + transc_BG_OPAQUE + (ulHwMix << 16);
    }

    // The SRC0 to SRC3 registers are probably trashed by the blt, and we
    // may be using a different SGN:

    ppdev->HopeFlags = 0;

    CHECK_FIFO_SPACE(pjBase, 8);

    CP_WRITE(pjBase, DWG_SGN, flDirCode);
    CP_WRITE(pjBase, DWG_AR5, lSignedPitch);

    // If the overhead for setting up the fast blt is too high, then we should
    // have a minimum size for prclDst.

    if (ulDwgFast)
    {
        RECTL   arclDst[1+(MAX_WRAM_BARRIERS*2)];
        LONG    aiCmd[1+(MAX_WRAM_BARRIERS*2)];
        LONG    ayBreak[MAX_WRAM_BARRIERS];
        LONG    cyBreak;
        RECTL   *prclDst;
        LONG    crclDst;
        ULONG   aulCmd[2] = {ulDwgFast, ulDwg};
        LONG    i;

        cyBreak = ppdev->cyBreak;
        for (i = 0; i < cyBreak; i++)
        {
            // lSplitRcl deals in relative coordinates for the destination and
            // source rectangles, so convert the break locations to relative
            // coordinates, too:

            ayBreak[i] = ppdev->ayBreak[i] - yOffset;
        }

        while (TRUE)
        {
            arclDst[0] = *prcl;
            prclDst = arclDst;

            // split the rectangle at each ayBreak[i]
            // If the first scan was on a split, start with the slow blt,
            //   otherwise, start with the fast blt and alternate.

            crclDst = lSplitRcl(arclDst, ayBreak, cyBreak, dy, flDirCode, aiCmd);
            i = 0;

            while (TRUE)
            {
                LONG xRight;

                ASSERTDD((aiCmd[i] & ~1) == 0, "Only bit 0 of aiCmd[i] should be set.");
                CP_WRITE(pjBase, DWG_DWGCTL, aulCmd[aiCmd[i]]);

                xRight = prclDst->right + xOffset - 1;

                ////////////////////////////////////////////////////////////////
                // The following code is a bugfix for the fast WRAM copies
                // Extend the right edge to a specific value and then
                // clip to the actual desired edge.

                CP_WRITE(pjBase, DWG_CXRIGHT, xRight);

                switch(cjPelSize)
                {
                    case 1: xRight |= 0x40;
                            break;
                    case 2: xRight |= 0x20;
                            break;
                    case 4: xRight |= 0x10;
                            break;
                    case 3: xRight = (((xRight * 3) + 2) | 0x40) / 3;
                            break;
                }
                ////////////////////////////////////////////////////////////////

                CP_WRITE(pjBase, DWG_FXBNDRY,
                                (((xRight) << bfxright_SHIFT) |
                                 ((prclDst->left  + xOffset) & bfxleft_MASK)));

                yDst = yOffset + prclDst->top;
                ySrc = yOffset + prclDst->top + dy;

                // ylength_MASK not is needed since coordinates are within range

                CP_WRITE(pjBase, DWG_YDSTLEN,
                                (((yDst) << yval_SHIFT) |
                                 ((prclDst->bottom - prclDst->top))));

                xSrc         = xOffset + prclDst->left + dx;
                lSignedWidth = prclDst->right - prclDst->left - 1;

                lSrcStart = ppdev->ulYDstOrg + (ySrc * ppdev->cxMemory) + xSrc;
                CP_WRITE(pjBase, DWG_AR3, lSrcStart);
                CP_START(pjBase, DWG_AR0, lSrcStart + lSignedWidth);

                if (--crclDst == 0)
                    break;

                prclDst++;
                i++;

                CHECK_FIFO_SPACE(pjBase, 6);
            }

            if (--c == 0)
                break;

            prcl++;
            CHECK_FIFO_SPACE(pjBase, 6);
        }

        // Restore the clipping:

        CHECK_FIFO_SPACE(pjBase, 1);
        CP_WRITE(pjBase, DWG_CXRIGHT, (ppdev->cxMemory - 1));
    }
    else
    {
        CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);

        while (TRUE)
        {
            CP_WRITE(pjBase, DWG_FXBNDRY,
                            (((prcl->right + xOffset - 1) << bfxright_SHIFT) |
                             ((prcl->left  + xOffset) & bfxleft_MASK)));

            yDst = yOffset + prcl->top;
            ySrc = yOffset + prcl->top + dy;

            if (flDirCode & sdy_BOTTOM_TO_TOP)
            {
                cy = prcl->bottom - prcl->top - 1;
                yDst += cy;
                ySrc += cy;
            }

            // ylength_MASK not is needed since coordinates are within range

            CP_WRITE(pjBase, DWG_YDSTLEN,
                            (((yDst) << yval_SHIFT) |
                             ((prcl->bottom - prcl->top))));

            xSrc         = xOffset + prcl->left + dx;
            lSignedWidth = prcl->right - prcl->left - 1;

            if (flDirCode & scanleft_RIGHT_TO_LEFT)
            {
                xSrc += lSignedWidth;
                lSignedWidth = -lSignedWidth;
            }

            lSrcStart = ppdev->ulYDstOrg + (ySrc * ppdev->cxMemory) + xSrc;
            CP_WRITE(pjBase, DWG_AR3, lSrcStart);
            CP_START(pjBase, DWG_AR0, lSrcStart + lSignedWidth);

            if (--c == 0)
                break;

            prcl++;
            CHECK_FIFO_SPACE(pjBase, 4);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Implements all the DirectDraw components for the driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// FourCC formats are encoded in reverse because we're little endian:

#define FOURCC_YUY2         '2YUY'

// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    7

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}

/******************************Public*Routine******************************\
* VOID vYuvStretch
*
* Does an expanding stretch blt from a 16-bit YUV surface to video memory.
*
\**************************************************************************/

VOID vYuvStretch(
PDEV*   ppdev,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc)
{
    BYTE*   pjBase;
    BYTE*   pjDma;
    LONG    cxMemory;
    LONG    cxDst;
    LONG    cxSrc;
    LONG    cyDst;
    LONG    cySrc;
    LONG    cyWholeDuplicate;
    LONG    lPartialDuplicate;
    LONG    lError;
    LONG    lErrorLimit;
    LONG    xDstLeft;
    LONG    xDstRight;
    LONG    xDstRightFast;
    LONG    yDstTop;
    LONG    xSrcAlign;
    ULONG   cd;
    BYTE*   pjSrc;
    ULONG   ulCmd;
    LONG    lDstAddress;
    ULONG*  pulSrc;
    ULONG*  pulDma;
    ULONG   i;
    LONG    cyDuplicate;
    LONG    cyBreak;
    LONG    iBreak;

    pjBase           = ppdev->pjBase;
    cxMemory         = ppdev->cxMemory;
    pjDma            = pjBase + DMAWND;
    ppdev->HopeFlags = SIGN_CACHE;      // Only register that's zero when done

    cxDst = prclDst->right - prclDst->left;
    cxSrc = prclSrc->right - prclSrc->left;

    cyDst = prclDst->bottom - prclDst->top;
    cySrc = prclSrc->bottom - prclSrc->top;

    ASSERTDD((cySrc <= cyDst) && (cxSrc <= cxDst),
        "Expanding stretches only may be allowed here");

    // We'll be doing the vertical stretching in software, so calculate the
    // DDA terms here.  We have the luxury of not worrying about overflow
    // because DirectDraw limits our coordinate space to 15 bits:

    cyWholeDuplicate  = (cyDst / cySrc) - 1;
    lPartialDuplicate = (cyDst % cySrc);
    lErrorLimit       = cySrc;
    lError            = cySrc >> 1;

    xDstLeft  = prclDst->left;
    xDstRight = prclDst->right - 1;         // Note this is inclusive
    yDstTop   = prclDst->top;
    cyDst     = prclDst->bottom - prclDst->top;

    // Fast WRAM-WRAM blts have a funky requirement for 'FXRIGHT':

    switch (ppdev->cjPelSize)
    {
    case 1: xDstRightFast = xDstRight | 0x40; break;
    case 2: xDstRightFast = xDstRight | 0x20; break;
    case 4: xDstRightFast = xDstRight | 0x10; break;
    case 3: xDstRightFast = (((xDstRight * 3) + 2) | 0x40) / 3;
            break;
    }

    // Figure out how many scans we can duplicate before we hit the first
    // WRAM boundary:

    cyBreak = 0xffff;
    for (iBreak = 0; iBreak < ppdev->cyBreak; iBreak++)
    {
        if (ppdev->ayBreak[iBreak] >= yDstTop)
        {
            cyBreak = ppdev->ayBreak[iBreak] - yDstTop;
            break;
        }
    }

    CHECK_FIFO_SPACE(pjBase, 8);

    CP_WRITE(pjBase, DWG_YDST,    yDstTop);
    CP_WRITE(pjBase, DWG_CXBNDRY, (xDstRight << bfxright_SHIFT)
                                | (xDstLeft));

    // Make sure we always read dword-aligned from the source:

    xSrcAlign = prclSrc->left & 1;
    if (xSrcAlign)
    {
        xDstLeft -= cxDst / cxSrc;  // We guess that Millennium takes ceiling
    }

    CP_WRITE(pjBase, DWG_FXBNDRY, (xDstRight << bfxright_SHIFT)
                                | (xDstLeft & bfxleft_MASK));

    lDstAddress = (yDstTop - 1) * cxMemory + xDstLeft + ppdev->ulYDstOrg;

    CP_WRITE(pjBase, DWG_AR5, cxMemory);
    CP_WRITE(pjBase, DWG_AR3, lDstAddress);
    CP_WRITE(pjBase, DWG_AR0, lDstAddress + cxDst - 1);

    cd    = (cxSrc + xSrcAlign + 1) >> 1;
    pjSrc = (BYTE*) pvSrc + (prclSrc->top * lDeltaSrc)
                          + ((prclSrc->left - xSrcAlign) * 2);

    ASSERTDD(((ULONG_PTR) pjSrc & 3) == 0, "Must dword align source");

    if (cxDst >= 2 * cxSrc)
    {
        ulCmd = opcode_ILOAD_FILTER |
                atype_RPL           |
                blockm_OFF          |
                bltmod_BUYUV        |
                pattern_OFF         |
                transc_BG_OPAQUE    |
                bop_SRCCOPY         |
                shftzero_ZERO       |
                sgnzero_ZERO;

        CP_WRITE(pjBase, DWG_AR2, 2 * cxSrc - 1);
        CP_WRITE(pjBase, DWG_AR6, 2 * cxSrc - cxDst - 1);
    }
    else
    {
        ulCmd = opcode_ILOAD_SCALE  |
                atype_RPL           |
                blockm_OFF          |
                bltmod_BUYUV        |
                pattern_OFF         |
                transc_BG_OPAQUE    |
                bop_SRCCOPY         |
                shftzero_ZERO       |
                sgnzero_ZERO;

        CP_WRITE(pjBase, DWG_AR2, cxSrc);
        CP_WRITE(pjBase, DWG_AR6, cxSrc - cxDst);
    }


    do {
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_DWGCTL, ulCmd);
        CP_START(pjBase, DWG_LEN, 1);

        // Turn on pseudo-DMA so that we can use PCI burst mode:

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
        BLT_WRITE_ON(ppdev, pjBase);

        pulSrc = (ULONG*) pjSrc;
        pulDma = (ULONG*) pjDma;
        pjSrc += lDeltaSrc;

        #if defined(_X86_)

            __asm   mov esi, pulSrc
            __asm   mov edi, pulDma
            __asm   mov ecx, cd
            __asm   rep movsd

        #else

            for (i = cd; i != 0; i--)
            {
                WRITE_REGISTER_ULONG(pulDma, *pulSrc);
                pulSrc++;
                pulDma++;
            }

        #endif

        BLT_WRITE_OFF(ppdev, pjBase);

        // Do an iteration of the DDA to determine how many lines we'll
        // be duplicating.  This biases

        cyDuplicate = cyWholeDuplicate;
        lError += lPartialDuplicate;
        if (lError >= lErrorLimit)
        {
            cyDuplicate++;
            lError -= lErrorLimit;
        }

        // Account for the line we just stretched:

        cyDst--;
        cyBreak--;

        // Remember not to duplicate past where we're supposed to end:

        if (cyDuplicate > cyDst)
            cyDuplicate = cyDst;

        if (cyDuplicate != 0)
        {
            cyDst   -= cyDuplicate;
            cyBreak -= cyDuplicate;

            if (cyBreak >= 0)
            {
                // We haven't crossed a WRAM boundary, so we can use a
                // WRAM-WRAM blt to duplicate the scan:

                CHECK_FIFO_SPACE(pjBase, 4);
                CP_WRITE(pjBase, DWG_DWGCTL,  opcode_FBITBLT     |
                                              atype_RPL          |
                                              blockm_OFF         |
                                              bltmod_BFCOL       |
                                              pattern_OFF        |
                                              transc_BG_OPAQUE   |
                                              bop_NOP            |
                                              shftzero_ZERO      |
                                              sgnzero_ZERO);
                CP_WRITE(pjBase, DWG_FXRIGHT, xDstRightFast);
                CP_START(pjBase, DWG_LEN,     cyDuplicate);
                CP_WRITE(pjBase, DWG_FXRIGHT, xDstRight);
            }
            else
            {
                // We just crossed a WRAM boundary, so we have to use a
                // regular blt to duplicate the scan:

                CHECK_FIFO_SPACE(pjBase, 2);
                CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT      |
                                             atype_RPL          |
                                             blockm_OFF         |
                                             bltmod_BFCOL       |
                                             pattern_OFF        |
                                             transc_BG_OPAQUE   |
                                             bop_SRCCOPY        |
                                             shftzero_ZERO      |
                                             sgnzero_ZERO);
                CP_START(pjBase, DWG_LEN,    cyDuplicate);

                iBreak++;
                if (iBreak >= ppdev->cyBreak)
                {
                    // That was the last break we have to worry about:

                    cyBreak = 0xffff;
                }
                else
                {
                    cyBreak += ppdev->ayBreak[iBreak]
                             - ppdev->ayBreak[iBreak - 1];
                }
            }
        }
    } while (cyDst != 0);

    // Reset the clipping, and we're done!

    CHECK_FIFO_SPACE(pjBase, 1);
    CP_WRITE(pjBase, DWG_CXBNDRY, (cxMemory - 1) << bcxright_SHIFT);
}

/******************************Public*Routine******************************\
* VOID vYuvBlt
*
* Does a non-stretching blt from a 16-bit YUV surface to video memory.
*
\**************************************************************************/

VOID vYuvBlt(
PDEV*   ppdev,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
POINTL* pptlSrc)
{
    BYTE*   pjBase;
    BYTE*   pjDma;
    LONG    cy;
    LONG    xLeft;
    LONG    xRight;
    LONG    xAlign;
    ULONG   cd;
    BYTE*   pjSrc;
    ULONG*  pulSrc;
    ULONG*  pulDma;
    ULONG   i;

    pjBase           = ppdev->pjBase;
    pjDma            = pjBase + DMAWND;
    ppdev->HopeFlags = SIGN_CACHE;      // Only register that's zero when done

    CHECK_FIFO_SPACE(pjBase, 6);

    CP_WRITE(pjBase, DWG_DWGCTL, opcode_ILOAD
                               | atype_RPL
                               | blockm_OFF
                               | pattern_OFF
                               | transc_BG_OPAQUE
                               | bop_SRCCOPY
                               | shftzero_ZERO
                               | sgnzero_ZERO
                               | bltmod_BUYUV);

    xLeft  = prclDst->left;
    xRight = prclDst->right;
    cy     = prclDst->bottom - prclDst->top;

    CP_WRITE(pjBase, DWG_AR3,     0);
    CP_WRITE(pjBase, DWG_YDSTLEN, (prclDst->top << yval_SHIFT) | cy);

    // Make sure we always read dword-aligned from the source:

    xAlign = pptlSrc->x & 1;
    if (xAlign)
    {
        CP_WRITE(pjBase, DWG_CXLEFT, xLeft);
        xLeft--;
    }

    CP_WRITE(pjBase, DWG_FXBNDRY, ((xRight - 1) << bfxright_SHIFT) |
                                  (xLeft & bfxleft_MASK));
    CP_START(pjBase, DWG_AR0,     xRight - xLeft - 1);

    cd    = (xRight - xLeft + 1) >> 1;
    pjSrc = (BYTE*) pvSrc + (pptlSrc->y * lDeltaSrc)
                          + ((pptlSrc->x - xAlign) * 2);

    ASSERTDD(((ULONG_PTR) pjSrc & 3) == 0, "Must dword align source");

    // Turn on pseudo-DMA so that we can use PCI burst mode:

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    BLT_WRITE_ON(ppdev, pjBase);

    do {
        pulSrc = (ULONG*) pjSrc;
        pulDma = (ULONG*) pjDma;
        pjSrc += lDeltaSrc;

        #if defined(_X86_)

            __asm   mov esi, pulSrc
            __asm   mov edi, pulDma
            __asm   mov ecx, cd
            __asm   rep movsd

        #else

            for (i = cd; i != 0; i--)
            {
                WRITE_REGISTER_ULONG(pulDma, *pulSrc);
                pulSrc++;
                pulDma++;
            }

        #endif
    } while (--cy != 0);

    // Reset the registers and leave:

    BLT_WRITE_OFF(ppdev, pjBase);
    if (xAlign)
    {
        CHECK_FIFO_SPACE(pjBase, 1);
        CP_WRITE(pjBase, DWG_CXLEFT, 0);
    }
}

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(PDEV* ppdev)
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.

    while (VBLANK_IS_ACTIVE(pjBase))
        ;
    while (!(VBLANK_IS_ACTIVE(pjBase)))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(VBLANK_IS_ACTIVE(pjBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (VBLANK_IS_ACTIVE(pjBase))
                ;
            while (!(VBLANK_IS_ACTIVE(pjBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((1, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((1, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((1, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
            li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
            ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;
}

/******************************Public*Routine******************************\
* HRESULT ddrvalUpdateFlipStatus
*
* Checks to if the most recent flip has occurred.
*
* Takes advantage of the hardware's ability to get the current scan line
* to determine if a vertical retrace has occured since the flip command
* was given.
*
\**************************************************************************/

HRESULT ddrvalUpdateFlipStatus(
PDEV*   ppdev,
FLATPTR fpVidMem)   // Surface for which we're requesting flip status;
                    //   -1 indicates status of last flip, regardless of what
                    //   surface it was.
{
    BYTE*       pjBase;
    DWORD       dwScanLine;
    LONGLONG    liTime;

    pjBase = ppdev->pjBase;

    if (ppdev->flipRecord.bFlipFlag)
    {
        dwScanLine = GET_SCANLINE(pjBase);
        if (dwScanLine < ppdev->flipRecord.dwScanLine)
        {
            ppdev->flipRecord.bFlipFlag = FALSE;
        }
        else
        {
            ppdev->flipRecord.dwScanLine = dwScanLine;
            if ((fpVidMem == (FLATPTR) -1) ||
                (fpVidMem == ppdev->flipRecord.fpFlipFrom))
            {
                // Sampling the current scan line at random times is not a
                // fool-proof indicator that the flip has occured.  As a
                // backup, if the time elapsed since the flip command was
                // given is more than the duration of one entire refresh of
                // the display, then we know for sure it has happened:

                EngQueryPerformanceCounter(&liTime);

                if (liTime - ppdev->flipRecord.liFlipTime
                                        <= ppdev->flipRecord.liFlipDuration)
                {
                    return(DDERR_WASSTILLDRAWING);
                }

                ppdev->flipRecord.bFlipFlag = FALSE;
            }
        }
    }

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt
*
\**************************************************************************/

DWORD DdBlt(
PDD_BLTDATA lpBlt)
{
    PDD_SURFACE_GLOBAL      srcSurf;
    PDD_SURFACE_LOCAL       dstSurfx;
    PDD_SURFACE_GLOBAL      dstSurf;
    PDEV*                   ppdev;
    HRESULT                 ddRVal;
    DWORD                   dstX;
    DWORD                   dstY;
    DWORD                   dwFlags;
    DWORD                   srcX;
    DWORD                   srcY;
    LONG                    dstWidth;
    LONG                    dstHeight;
    LONG                    srcWidth;
    LONG                    srcHeight;
    ULONG                   ulBltCmd;
    LONG                    lSrcStart;
    LONG                    lSignedPitch;
    RECTL                   rclSrc;
    RECTL                   rclDest;
    BYTE*                   pjBase;

    ppdev    = (PDEV*) lpBlt->lpDD->dhpdev;
    pjBase   = ppdev->pjBase;

    dstSurfx = lpBlt->lpDDDestSurface;
    dstSurf  = dstSurfx->lpGbl;

    ASSERTDD(dstSurf->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // We don't have to do any drawing to YUV surfaces.  Note that unlike
    // Windows 95, Windows NT always guarantees that there will be a valid
    // 'ddpfSurface' structure, so we don't have to first check if
    // 'dwSize == sizeof(DDPIXELFORMAT)':

    if (dstSurf->ddpfSurface.dwFlags & DDPF_FOURCC)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    // Is a flip in progress?

    ddRVal = ddrvalUpdateFlipStatus(ppdev, dstSurf->fpVidMem);
    if (ddRVal != DD_OK)
    {
        lpBlt->ddRVal = ddRVal;
        return(DDHAL_DRIVER_HANDLED);
    }

    dwFlags = lpBlt->dwFlags;
    if (dwFlags & DDBLT_ASYNC)
    {
        // If async, then only work if we won't have to wait on the
        // accelerator to start the command.
        //
        // The FIFO wait should account for the worst-case possible
        // blt that we would do:
        //
        // We should check for enough entries that we're guaranteed
        // to not have to wait later in this routine.

        if (GET_FIFO_SPACE(pjBase) < DDBLT_FIFO_COUNT)
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    // Copy destination rectangle:

    dstX      = lpBlt->rDest.left;
    dstY      = lpBlt->rDest.top;
    dstWidth  = lpBlt->rDest.right - lpBlt->rDest.left;
    dstHeight = lpBlt->rDest.bottom - lpBlt->rDest.top;

    convertToGlobalCord(dstX, dstY, dstSurf);

    if (dwFlags & DDBLT_COLORFILL)
    {
        ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE);

        if (ppdev->iBitmapFormat == BMF_24BPP)
        {
            // We can't use block mode.

            ulBltCmd = (opcode_TRAP + blockm_OFF + atype_RPL + solid_SOLID +
                        arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                        bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
        }
        else
        {
            ulBltCmd = (opcode_TRAP + blockm_ON + solid_SOLID +
                        arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                        bop_SRCCOPY + pattern_OFF + transc_BG_OPAQUE);
        }

        CHECK_FIFO_SPACE(pjBase, 4);
        CP_WRITE(pjBase, DWG_DWGCTL, ulBltCmd);
        CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, lpBlt->bltFX.dwFillColor));
        CP_WRITE(pjBase, DWG_FXBNDRY, (((dstX + dstWidth) << bfxright_SHIFT) | dstX));
        CP_START(pjBase, DWG_YDSTLEN, (((dstY) << yval_SHIFT) | dstHeight));

        lpBlt->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    // We specified with Our ddCaps.dwCaps that we handle a limited number
    // of commands, and by this point in our routine we've handled everything
    // except DDBLT_ROP.  DirectDraw and GDI shouldn't pass us anything
    // else; we'll assert on debug builds to prove this:

    ASSERTDD((dwFlags & DDBLT_ROP) && (lpBlt->lpDDSrcSurface),
        "Expected dwFlags commands of only DDBLT_ASYNC and DDBLT_COLORFILL");

    // Get source rectangle dimensions:

    srcSurf   = lpBlt->lpDDSrcSurface->lpGbl;
    srcX      = lpBlt->rSrc.left;
    srcY      = lpBlt->rSrc.top;
    srcWidth  = lpBlt->rSrc.right - lpBlt->rSrc.left;
    srcHeight = lpBlt->rSrc.bottom - lpBlt->rSrc.top;


    rclDest.left   = dstX;
    rclDest.right  = dstX + dstWidth;
    rclDest.top    = dstY;
    rclDest.bottom = dstY + dstHeight;

    if (srcSurf->ddpfSurface.dwFlags & DDPF_FOURCC)
    {
        rclSrc.left   = srcX;
        rclSrc.top    = srcY;
        rclSrc.right  = srcX + srcWidth;
        rclSrc.bottom = srcY + srcHeight;

        if ((dstWidth == srcWidth) && (dstHeight == srcHeight))
        {
            vYuvBlt(ppdev,
                    &rclDest,
                    (VOID*) srcSurf->fpVidMem,
                    srcSurf->lPitch,
                    (POINTL*) &rclSrc);
        }

        // Note that we would fall over if we actually got a shrink here,
        // even though we've set our caps to indicate we can only do
        // expands.  We're paranoid and don't want to ever fall over:

        else if ((dstWidth >= srcWidth) && (dstHeight >= srcHeight))
        {
            vYuvStretch(ppdev,
                        &rclDest,
                        (VOID*) srcSurf->fpVidMem,
                        srcSurf->lPitch,
                        &rclSrc);
        }

        lpBlt->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    // NT only ever gives us SRCCOPY rops, so don't even bother checking
    // for anything else.

    convertToGlobalCord(srcX, srcY, srcSurf);

    rclSrc.left   = srcX;
    rclSrc.top    = srcY;
    rclSrc.right  = srcX + srcWidth;
    rclSrc.bottom = srcY + srcHeight;

    // Must be set for our copy routines to operate properly:

    ppdev->xOffset = 0;
    ppdev->yOffset = 0;

    if ((srcWidth == dstWidth) && (srcHeight == dstHeight))
    {
        // There's no stretching involved, so do a straight screen-to-
        // screen copy.  'vMilCopyBlt' takes care of the overlapping
        // cases, and

        vMilCopyBlt(ppdev, 1, &rclDest, 0xcccc, (POINTL*) &rclSrc, &rclDest);
    }
    else
    {
        // Ugh, we've been asked to stretch an off-screen surface.  We'll
        // just pass it to our hardware-assisted StretchBlt routine.
        //
        // Unfortunately, the source is in off-screen memory and so the
        // performance will be terrible -- slower than if the surface had
        // been created in system memory.  We have to support stretched RGB
        // surfaces in the first place because we set DDCAPS_BLTSTRETCH so
        // that we could use the Millennium's YUV stretch capabilities --
        // and DirectDraw has no concept of being able to say "we support
        // hardware stretches with these types of off-screen surfaces, but
        // not those with those other types of off-screen surfaces."  Oh
        // well.  I expect that if applications will be doing stretches,
        // they'll be doing it mostly from YUV surfaces (as will be the
        // case with ActiveMovie), so this should be a win overall.
        //
        // Note: If you are modeling your driver on this code and don't have
        //       any hardware stretch capabilities, then simply don't set
        //       DDCAPS_BLTSTRETCH, and you'll never have to worry about
        //       this!  We only do this weirdness here because the
        //       Millennium can hardware stretch YUV surfaces but not RGB
        //       surfaces.  (Sort of.)

        vStretchDIB(ppdev,
                    &rclDest,
                    ppdev->pjScreen + (ppdev->ulYDstOrg * ppdev->cjPelSize),
                    ppdev->lDelta,
                    &rclSrc,
                    &rclDest);
    }

    lpBlt->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjBase;
    HRESULT     ddRVal;
    ULONG       ulMemoryOffset;
    ULONG       ulLowOffset;
    ULONG       ulMiddleOffset;
    ULONG       ulHighOffset;
    BYTE        jReg;

    ppdev   = (PDEV*) lpFlip->lpDD->dhpdev;
    pjBase  = ppdev->pjBase;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddRVal = ddrvalUpdateFlipStatus(ppdev, (FLATPTR) -1);
    if ((ddRVal != DD_OK) || (IS_BUSY(pjBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Do the flip:

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2);

    ulMemoryOffset >>= ((ppdev->flFeatures & INTERLEAVE_MODE) ? 1 : 0);

    ulLowOffset    = 0x0d | ((ulMemoryOffset & 0x0000ff) << 8);
    ulMiddleOffset = 0x0c | ((ulMemoryOffset & 0x00ff00));
    ulHighOffset   = 0x00 | ((ulMemoryOffset & 0x0f0000) >> 8);

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:

    while (!(DISPLAY_IS_ACTIVE(pjBase)))
        ;

    CP_WRITE_REGISTER_BYTE(pjBase + VGA_CRTCEXT_INDEX, 0x00);
    jReg = CP_READ_REGISTER_BYTE(pjBase + VGA_CRTCEXT_DATA);
    jReg &= ~0x0f;
    CP_WRITE_REGISTER_WORD(pjBase + VGA_CRTC_INDEX,     ulLowOffset);
    CP_WRITE_REGISTER_WORD(pjBase + VGA_CRTC_INDEX,     ulMiddleOffset);
    CP_WRITE_REGISTER_WORD(pjBase + VGA_CRTCEXT_INDEX,  ((ulHighOffset) |
                                                         (jReg << 8)));

    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.dwScanLine = GET_SCANLINE(pjBase);
    ppdev->flipRecord.bFlipFlag  = TRUE;
    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    lpFlip->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(
PDD_LOCKDATA lpLock)
{
    PDEV*               ppdev;
    BYTE*               pjBase;
    DD_SURFACE_GLOBAL*  lpSurface;
    HRESULT             ddRVal;

    ppdev  = (PDEV*) lpLock->lpDD->dhpdev;
    pjBase = ppdev->pjBase;
    lpSurface = lpLock->lpDDSurface->lpGbl;

    if (lpSurface->ddpfSurface.dwFlags & DDPF_FOURCC)
    {
        // We create all FourCC surfaces in system memory, so just return
        // the user-mode address:

        lpLock->lpSurfData = (VOID*) lpSurface->fpVidMem;
        lpLock->ddRVal = DD_OK;

        // When a driver returns DD_OK and DDHAL_DRIVER_HANDLED from DdLock,
        // DirectDraw expects it to have adjusted the resulting pointer
        // to point to the upper left corner of the specified rectangle, if
        // any:

        if (lpLock->bHasRect)
        {
            lpLock->lpSurfData = (VOID*) ((BYTE*) lpLock->lpSurfData
                + lpLock->rArea.top * lpSurface->lPitch
                + lpLock->rArea.left
                    * (lpSurface->ddpfSurface.dwYUVBitCount >> 3));
        }

        return(DDHAL_DRIVER_HANDLED);
    }

    // Check to see if any pending physical flip has occurred.
    // Don't allow a lock if a blt is in progress:

    ddRVal = ddrvalUpdateFlipStatus(ppdev, lpSurface->fpVidMem);
    if (ddRVal != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Here's one of the places where the Windows 95 and Windows NT DirectDraw
    // implementations differ: on Windows NT, you should watch for
    // DDLOCK_WAIT and loop in the driver while the accelerator is busy.
    // On Windows 95, it doesn't really matter.
    //
    // (The reason is that Windows NT allows applications to draw directly
    // to the frame buffer even while the accelerator is running, and does
    // not synchronize everything on the Win16Lock.  Note that on Windows NT,
    // it is even possible for multiple threads to be holding different
    // DirectDraw surface locks at the same time.)

    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        WAIT_NOT_BUSY(pjBase)
    }
    else if (IS_BUSY(pjBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Because we correctly set 'fpVidMem' to be the offset into our frame
    // buffer when we created the surface, DirectDraw will automatically take
    // care of adding in the user-mode frame buffer address if we return
    // DDHAL_DRIVER_NOTHANDLED:

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus(
PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;
    BYTE*   pjBase;

    ppdev   = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
    pjBase  = ppdev->pjBase;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = ddrvalUpdateFlipStatus(ppdev,
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            if (GET_FIFO_SPACE(pjBase) < DDBLT_FIFO_COUNT)
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (IS_BUSY(pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess = (FLATPTR)ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;
    BYTE*   pjBase;

    ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = ddrvalUpdateFlipStatus(ppdev, (FLATPTR) -1);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (IS_BUSY(pjBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjBase;

    ppdev  = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (VBLANK_IS_ACTIVE(pjBase))
        {
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        }
        else
        {
            lpWaitForVerticalBlank->bIsInVB = FALSE;
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (VBLANK_IS_ACTIVE(pjBase))
            ;
        while (!(VBLANK_IS_ACTIVE(pjBase)))
            ;

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(VBLANK_IS_ACTIVE(pjBase)))
            ;
        while (VBLANK_IS_ACTIVE(pjBase))
            ;

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine
*
* Reads the scan line currently being scanned by the CRT.
*
\**************************************************************************/

DWORD DdGetScanLine(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjBase;

    ppdev  = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    lpGetScanLine->dwScanLine = GET_SCANLINE(pjBase);

    lpGetScanLine->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdCanCreateSurface
*
* Called by DirectDraw to determine if the driver can create a particular
* off-screen surface type.
*
\**************************************************************************/

DWORD DdCanCreateSurface(
PDD_CANCREATESURFACEDATA lpCanCreateSurface)
{
    PDEV*           ppdev;
    LPDDSURFACEDESC lpSurfaceDesc;

    ppdev = (PDEV*) lpCanCreateSurface->lpDD->dhpdev;
    lpSurfaceDesc = lpCanCreateSurface->lpDDSurfaceDesc;

    // It's trivially easy to create surfaces that are the same type as
    // the primary surface:

    if (!lpCanCreateSurface->bIsDifferentPixelFormat)
    {
        lpCanCreateSurface->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    // The only type of YUV mode that the Millennium supports is
    // "YUY2".  The Millennium also supports 24bpp and 32bpp surfaces,
    // but we won't support them because they're not used very much
    // and there isn't any good testing coverage for it.
    //
    // In addition, the Millennium supports YUV only when in RGB modes,
    // and at 8bpp we're always running palettized.

    if ((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC) &&
        (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUY2) &&
        ((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP)))
    {
        // We have to fill-in the bit count:

        lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;

        lpCanCreateSurface->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
    {
        DISPDBG((0, "Failed creation of %libpp RGB surface %lx %lx %lx",
            lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount,
            lpSurfaceDesc->ddpfPixelFormat.dwRBitMask,
            lpSurfaceDesc->ddpfPixelFormat.dwGBitMask,
            lpSurfaceDesc->ddpfPixelFormat.dwBBitMask));
    }
    else
    {
        DISPDBG((0, "Failed creation of type 0x%lx YUV 0x%lx surface",
            lpSurfaceDesc->ddpfPixelFormat.dwFlags,
            lpSurfaceDesc->ddpfPixelFormat.dwFourCC));
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdCreateSurface
*
* Creates an off-screen surface.
*
* We use the Millennium's own off-screen heap manager instead of DirectDraw's
* so that the MCD and DirectDraw parts can coexist -- at the time of this
* writing NT has no support for call-backs from the driver to allocate memory,
* which we need to do to allocate the MCD's back buffer and Z-buffer.  So
* we simply manage all of off-screen memory ourselves.
*
* In addition, on the Millennium, YUV surfaces must live in CPU memory.
*
\**************************************************************************/

DWORD DdCreateSurface(
PDD_CREATESURFACEDATA lpCreateSurface)
{
    PDEV*               ppdev;
    DD_SURFACE_GLOBAL*  lpSurface;
    LPDDSURFACEDESC     lpSurfaceDesc;
    LONG                wWidth;
    LONG                wHeight;
    LONG                lPitch;
    OH*                 poh;
    FLATPTR             fpVidMem;

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:

    lpSurface = lpCreateSurface->lplpSList[0]->lpGbl;
    lpSurfaceDesc = lpCreateSurface->lpDDSurfaceDesc;

    wWidth  = lpSurface->wWidth;
    wHeight = lpSurface->wHeight;

    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.

    ASSERTDD(lpSurface->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // Note that the Millennium cannot do YUV surfaces at 24bpp or at
    // palettized 8bpp:

    if ((lpSurface->ddpfSurface.dwFlags & DDPF_FOURCC) &&
        (lpSurface->ddpfSurface.dwFourCC == FOURCC_YUY2) &&
        ((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP)))
    {
        // Compute the stride of the surface, keeping in mind that it has
        // to be dword aligned.  Since the Millennium supports only 16bpp
        // YUV surfaces, this is easy to do:

        lPitch = (2 * wWidth + 3) & ~3;

        // By setting 'fpVidMem' to 'DDHAL_PLEASEALLOC_USERMEM', we can have
        // DirectDraw allocate a piece of user-mode memory of our requested
        // size.
        //
        // Note that we could not simply call EngAllocMem, because that gives
        // us a chunk of kernel-mode memory that is not visible from user-mode.
        // We also cannot call EngAllocUserMem for obscure reasons dealing with
        // the fact EngFreeUserMem must be called from the same process context
        // in which the memory was allocated, and DirectDraw sometimes needs
        // to call DestroySurface from the context of a different process.

        lpSurface->fpVidMem      = DDHAL_PLEASEALLOC_USERMEM;
        lpSurface->dwUserMemSize = lPitch * wHeight;
        lpSurface->lPitch        = lPitch;

        // DirectDraw expects us to fill in the following fields, too:

        lpSurface->ddpfSurface.dwYUVBitCount = 16;
        lpSurfaceDesc->lPitch    = lPitch;
        lpSurfaceDesc->dwFlags  |= DDSD_PITCH;

        DISPDBG((0, "Created YUV: %li x %li", wWidth, wHeight));

        return(DDHAL_DRIVER_NOTHANDLED);
    }
    else
    {
        // Due to weirdness of the Matrox, we create non-flippable off-screen
        // surfaces only if running at 8bpp.  (The reason is that at 16bpp and
        // 32bpp, we report DDCAPS_BLTSTRETCH so that applications can stretch
        // YUV surfaces via the hardware -- but the hardware is increidbly
        // slow at stretching off-screen RGB surfaces, we don't want off-screen
        // RGB surfaces that are likely to be stretched.)

        if ((ppdev->iBitmapFormat == BMF_8BPP) ||
            ((wWidth == ppdev->cxScreen) && (wHeight == ppdev->cyScreen)))
        {
            // Allocate a space in off-screen memory, using our own heap
            // manager:

            poh = pohAllocate(ppdev, NULL, wWidth, wHeight, FLOH_MAKE_PERMANENT);
            if (poh != NULL)
            {
                fpVidMem = (poh->y * ppdev->lDelta)
                         + (poh->x + ppdev->ulYDstOrg) * ppdev->cjPelSize;

                // Flip surfaces, detected by surface requests that are
                // the same size as the current display, have special
                // considerations on the Millennium: they must live entirely
                // in the first two megabytes of video memory:

                if ((wWidth  != ppdev->cxScreen) ||
                    (wHeight != ppdev->cyScreen) ||
                    ((fpVidMem + (wHeight * ppdev->lDelta)) <= 0x200000))
                {
                    lpSurface->dwReserved1  = (ULONG_PTR)poh;
                    lpSurface->xHint        = poh->x;
                    lpSurface->yHint        = poh->y;
                    lpSurface->fpVidMem     = fpVidMem;
                    lpSurface->lPitch       = ppdev->lDelta;

                    lpSurfaceDesc->lPitch   = ppdev->lDelta;
                    lpSurfaceDesc->dwFlags |= DDSD_PITCH;

                    // We handled the creation entirely ourselves, so we have to
                    // set the return code and return DDHAL_DRIVER_HANDLED:

                    lpCreateSurface->ddRVal = DD_OK;
                    return(DDHAL_DRIVER_HANDLED);
                }

                // Argh, it's a possible flip surface that we can't use:

                pohFree(ppdev, poh);
            }
        }
    }

    // Fail the call by not setting lpSurface->fpVidMem and returning
    // DDHAL_DRIVER_NOTHANDLED:

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdDestroySurface
*
* Note that if DirectDraw did the allocation, DDHAL_DRIVER_NOTHANDLED
* should be returned.
*
\**************************************************************************/

DWORD DdDestroySurface(
PDD_DESTROYSURFACEDATA lpDestroySurface)
{
    PDEV*               ppdev;
    DD_SURFACE_GLOBAL*  lpSurface;
    LONG                lPitch;

    ppdev = (PDEV*) lpDestroySurface->lpDD->dhpdev;
    lpSurface = lpDestroySurface->lpDDSurface->lpGbl;

    if (!(lpSurface->ddpfSurface.dwFlags & DDPF_FOURCC))
    {
        pohFree(ppdev, (OH*) lpSurface->dwReserved1);

        // Since we did the original allocation ourselves, we have to
        // return DDHAL_DRIVER_HANDLED here:

        lpDestroySurface->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/**************************************************************************************
 *  GetAvailDriverMemory
 *
 *  DDraw 'miscellaneous' callback returning the amount of free memory in driver's
 *  'private' heap
 ***************************************************************************************/

DWORD __stdcall GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd)
{
    OH      *poh;
    OH      *pohSentinel;
    LONG     lArea;
    PDEV    *ppdev;
    ppdev = (PDEV*)(pDmd->lpDD->dhpdev);
    ASSERTDD(ppdev != NULL,"Bad ppdev in GetAvailDriverMemory");
    pohSentinel = &ppdev->heap.ohFree;
    lArea       = 0;
    for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState != OH_PERMANENT,
                    "Permanent node in free or discardable list");
        lArea += poh->cx * poh->cy;
    }
    pDmd->dwTotal = ppdev->ulTotalAvailVideoMemory;
    pDmd->dwFree  = lArea * ppdev->cjPelSize;
    pDmd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/******************************Public*Routine******************************\
* DWORD __stdcall DdGetDriverInfo
*
*  DESCRIPTION: DirectDraw has had many compatability problems
*               in the past, particularly from adding or modifying
*               members of public structures.  GetDriverInfo is an extension
*               architecture that intends to allow DirectDraw to
*               continue evolving, while maintaining backward compatability.
*               This function is passed a GUID which represents some DirectDraw
*               extension.  If the driver recognises and supports this extension,
*               it fills out the required data and returns.
*
* Callback that registers additional DDraw callbacks
* in this case used to register GetAvailDriverMemory callback
*
\**************************************************************************/

DWORD __stdcall DdGetDriverInfo(DD_GETDRIVERINFODATA *lpInput)
{
    DWORD dwSize = 0;
    lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
    if ( IsEqualIID(&lpInput->guidInfo, &GUID_MiscellaneousCallbacks) )
    {
        DD_MISCELLANEOUSCALLBACKS MiscellaneousCallbacks;
        memset(&MiscellaneousCallbacks, 0, sizeof(MiscellaneousCallbacks));
        DISPDBG((0,"Get Miscelaneous Callbacks"));
        dwSize = min(lpInput->dwExpectedSize, sizeof(DD_MISCELLANEOUSCALLBACKS));
        MiscellaneousCallbacks.dwSize  = dwSize;
        MiscellaneousCallbacks.dwFlags = DDHAL_MISCCB32_GETAVAILDRIVERMEMORY | 0;
        MiscellaneousCallbacks.GetAvailDriverMemory = GetAvailDriverMemory;
        memcpy(lpInput->lpvData, &MiscellaneousCallbacks, dwSize);
        lpInput->ddRVal = DD_OK;
    }
    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo
*
* Will be called twice before DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;

    ppdev = (PDEV*) dhpdev;

    *pdwNumFourCC = 0;
    *pdwNumHeaps = 0;

    // We may not support DirectDraw on this card:

    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
        return(FALSE);

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = ppdev->ulYDstOrg * ppdev->cjPelSize;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize        = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags       = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cjHwPel * 8;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    // Free up as much off-screen memory as possible:

    bMoveAllDfbsFromOffscreenToDibs(ppdev);

    // Capabilities supported:

    pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                            | DDCAPS_BLTCOLORFILL
                            | DDCAPS_READSCANLINE;

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE
                                    | DDSCAPS_FLIP;

    // We have to tell DirectDraw our preferred off-screen alignment, even
    // if we're doing our own off-screen memory management:

    pHalInfo->vmiData.dwOffscreenAlign = 4;

    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:

    pHalInfo->ddCaps.dwVidMemTotal
        = ppdev->heap.cxMax * ppdev->heap.cyMax * ppdev->cjPelSize;

    // We can do YUV conversions and hardware accelerated stretches at
    // all RGB modes except 24bpp.

    if ((ppdev->iBitmapFormat != BMF_24BPP) &&
        (ppdev->iBitmapFormat != BMF_8BPP))
    {
        pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH
                                 | DDCAPS_BLTFOURCC;

        pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTSTRETCHX
                                   | DDFXCAPS_BLTSTRETCHY;

        // The Millennium supports only one type of YUV format:

        *pdwNumFourCC = 1;
        if (pdwFourCC)
        {
            *pdwFourCC = FOURCC_YUY2;
        }
    }

    // Tell DDraw that we support additional callbacks through DdGetDriverInfo
    pHalInfo->GetDriverInfo = DdGetDriverInfo;
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

    return(TRUE);
}

/**************************************************************************\
* ULONG TotalAvailVideoMemory
*
*    Added for GetAvailVideoMemoty calback
*    Calculate total amount of offscreen video memory without permanent
*    driver allocations. We need to do it here since we won't be able
*    to distinguish between driver's permanent allocation and ddraw's
*    permanent allocation later.
*
\**************************************************************************/

ULONG TotalAvailVideoMemory(PDEV *ppdev)
{
    OH      *poh;
    OH      *pohSentinel;
    ULONG    ulArea;
    ULONG    i;

    ASSERTDD(ppdev != NULL,"Bad ppdev TotalAvailVideoMemory");

    ulArea   = 0;
    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");
            ulArea += poh->cx * poh->cy;
        }
        // Second time through, loop through the list of discardable
        // rectangles:
        pohSentinel = &ppdev->heap.ohDiscardable;
    }
    return ulArea * ppdev->cjPelSize;
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDirectDraw
*
* This function is called by GDI to enable DirectDraw when a DirectDraw
* program is started and DirectDraw is not already active.
*
\**************************************************************************/

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    pCallBacks->WaitForVerticalBlank  = DdWaitForVerticalBlank;
    pCallBacks->MapMemory             = DdMapMemory;
    pCallBacks->CanCreateSurface      = DdCanCreateSurface;
    pCallBacks->CreateSurface         = DdCreateSurface;
    pCallBacks->GetScanLine           = DdGetScanLine;
    pCallBacks->dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK
                                      | DDHAL_CB32_MAPMEMORY
                                      | DDHAL_CB32_CANCREATESURFACE
                                      | DDHAL_CB32_CREATESURFACE
                                      | DDHAL_CB32_GETSCANLINE;

    pSurfaceCallBacks->Blt            = DdBlt;
    pSurfaceCallBacks->Flip           = DdFlip;
    pSurfaceCallBacks->Lock           = DdLock;
    pSurfaceCallBacks->GetBltStatus   = DdGetBltStatus;
    pSurfaceCallBacks->GetFlipStatus  = DdGetFlipStatus;
    pSurfaceCallBacks->DestroySurface = DdDestroySurface;
    pSurfaceCallBacks->dwFlags        = DDHAL_SURFCB32_BLT
                                      | DDHAL_SURFCB32_FLIP
                                      | DDHAL_SURFCB32_LOCK
                                      | DDHAL_SURFCB32_GETBLTSTATUS
                                      | DDHAL_SURFCB32_GETFLIPSTATUS
                                      | DDHAL_SURFCB32_DESTROYSURFACE;

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.


    // Added for GetAvailDriverMemory callback
    ppdev->ulTotalAvailVideoMemory = TotalAvailVideoMemory(ppdev);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDirectDraw
*
* This function is called by GDI when the last active DirectDraw program
* is quit and DirectDraw will no longer be active.
*
\**************************************************************************/

VOID DrvDisableDirectDraw(
DHPDEV      dhpdev)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModeDirectDraw
*
* This function is called by enable.c when entering or leaving the
* DOS full-screen character mode.
*
\**************************************************************************/

VOID vAssertModeDirectDraw(
PDEV*   ppdev,
BOOL    bEnabled)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableDirectDraw
*
* This function is called by enable.c when the mode is first initialized,
* right after the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableDirectDraw(
PDEV*   ppdev)
{
    // We're not going to bother to support accelerated DirectDraw on
    // the Impression or earlier, because they don't have linear frame
    // buffers.

    if (ppdev->ulBoardId == MGA_STORM)
    {
        // Accurately measure the refresh rate for later:

        vGetDisplayDuration(ppdev);

        // DirectDraw is all set to be used on this card:

        ppdev->flStatus |= STAT_DIRECTDRAW;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableDirectDraw
*
* This function is called by enable.c when the driver is shutting down.
*
\**************************************************************************/

VOID vDisableDirectDraw(
PDEV*   ppdev)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);// # of vertices with more
                                                //than zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\bltmil24.c ===
/******************************Module*Header*******************************\
* Module Name: bltmil24.c
*
* Contains the low-level blt functions for the Millenium at 24bpp.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMilPatRealize24bpp
*
* Download the Color Brush to the Color brush cache in the Storm offscreen
* memory.  We download a 16x8 brush.  We'll use direct frame buffer access.
*
* There are some hardware restrictions concerning the way that a pattern
* must be stored in memory:
* - the first pixel of the pattern must be stored so that the first pixel
*   address mod 256 is 0 or 16;
* - each line of 16 pixels is stored continuously, but there must be a
*   difference of 32 in the pixel addresses of successive pattern lines.
* This means that we will store patterns in the following way:
*
* +----+---------------+---------------+---------------+---------------+
* |    |           Pattern 0           |           Pattern 1           |
* |Line|               |               |1 1 1 1 1 1 1 1|1 1 1 1 1 1 1 1|
* |    |0 1 2 3 4 5 6 7|8 9 a b c d e f|0 1 2 3 4 5 6 7|8 9 a b c d e f|
* +----+---------------+---------------+---------------+---------------+
* |  0 |*   *   *   *   *   *   *   *  |      o       o       o       o|
* |  1 |  *   *   *   *   *   *   *   *|    o       o       o       o  |
* |  2 |*   *   *   *   *   *   *   *  |  o       o       o       o    |
* |  3 |  *   *   *   *   *   *   *   *|o       o       o       o      |
* |  4 |*   *   *   *   *   *   *   *  |      o       o       o       o|
* |  5 |  *   *   *   *   *   *   *   *|    o       o       o       o  |
* |  6 |*   *   *   *   *   *   *   *  |  o       o       o       o    |
* |  7 |  *   *   *   *   *   *   *   *|o       o       o       o      |
* +----+---------------+---------------+---------------+---------------+
*
* where a given pixel address is
*  FirstPixelAddress + Line*0x20 + Pattern*0x10 + xPat.
*
\**************************************************************************/

VOID vMilPatRealize24bpp(
    PDEV*   ppdev,
    RBRUSH* prb)
{
    BYTE*       pjBase;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    ULONG       i;
    ULONG       j;
    ULONG*      pulBrush;
    ULONG*      pulDst;
    ULONG       lDeltaPat;

    pjBase = ppdev->pjBase;

    // Allocate a new off-screen cache brush entry for the brush.
    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->pbe[iBrushCache];

    iBrushCache++;
    if (iBrushCache >= ppdev->cBrushCache)
        iBrushCache = 0;

    ppdev->iBrushCache = iBrushCache;

    // Update our links.
    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    // Point to the pattern bits.
    pulBrush = prb->aulPattern;

    pulDst = (ULONG*) (pbe->pvScan0);
    pulDst = (ULONG*) (ppdev->pjScreen + (pbe->ulLinear * 3));

    DISPDBG((1,"pulBrush = %x", pulBrush));
    DISPDBG((1,"pulDst =   %x", pulDst));

    {
        ULONG y;
        for (y = 0; y < 8; y++)
        {
            DISPDBG((2, "%02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x %02x%02x%02x",

                ((BYTE*)pulBrush)[y*48 + 0],
                ((BYTE*)pulBrush)[y*48 + 1],
                ((BYTE*)pulBrush)[y*48 + 2],
                ((BYTE*)pulBrush)[y*48 + 3],
                ((BYTE*)pulBrush)[y*48 + 4],
                ((BYTE*)pulBrush)[y*48 + 5],
                ((BYTE*)pulBrush)[y*48 + 6],
                ((BYTE*)pulBrush)[y*48 + 7],
                ((BYTE*)pulBrush)[y*48 + 8],
                ((BYTE*)pulBrush)[y*48 + 9],
                ((BYTE*)pulBrush)[y*48 + 10],
                ((BYTE*)pulBrush)[y*48 + 11],
                ((BYTE*)pulBrush)[y*48 + 12],
                ((BYTE*)pulBrush)[y*48 + 13],
                ((BYTE*)pulBrush)[y*48 + 14],
                ((BYTE*)pulBrush)[y*48 + 15],
                ((BYTE*)pulBrush)[y*48 + 16],
                ((BYTE*)pulBrush)[y*48 + 17],
                ((BYTE*)pulBrush)[y*48 + 18],
                ((BYTE*)pulBrush)[y*48 + 19],
                ((BYTE*)pulBrush)[y*48 + 20],
                ((BYTE*)pulBrush)[y*48 + 21],
                ((BYTE*)pulBrush)[y*48 + 22],
                ((BYTE*)pulBrush)[y*48 + 23],
                ((BYTE*)pulBrush)[y*48 + 24],
                ((BYTE*)pulBrush)[y*48 + 25],
                ((BYTE*)pulBrush)[y*48 + 26],
                ((BYTE*)pulBrush)[y*48 + 27],
                ((BYTE*)pulBrush)[y*48 + 28],
                ((BYTE*)pulBrush)[y*48 + 29],
                ((BYTE*)pulBrush)[y*48 + 30],
                ((BYTE*)pulBrush)[y*48 + 31],
                ((BYTE*)pulBrush)[y*48 + 32],
                ((BYTE*)pulBrush)[y*48 + 33],
                ((BYTE*)pulBrush)[y*48 + 34],
                ((BYTE*)pulBrush)[y*48 + 35],
                ((BYTE*)pulBrush)[y*48 + 36],
                ((BYTE*)pulBrush)[y*48 + 37],
                ((BYTE*)pulBrush)[y*48 + 38],
                ((BYTE*)pulBrush)[y*48 + 39],
                ((BYTE*)pulBrush)[y*48 + 40],
                ((BYTE*)pulBrush)[y*48 + 41],
                ((BYTE*)pulBrush)[y*48 + 42],
                ((BYTE*)pulBrush)[y*48 + 43],
                ((BYTE*)pulBrush)[y*48 + 44],
                ((BYTE*)pulBrush)[y*48 + 45],
                ((BYTE*)pulBrush)[y*48 + 46],
                ((BYTE*)pulBrush)[y*48 + 47]
                ));
        }
    }

    START_DIRECT_ACCESS_STORM(ppdev, pjBase);

    for (i = 8; i != 0 ; i--)
    {
        for (j = 0; j < 12; j++)
        {
            pulDst[j] = *pulBrush++;
        }
        pulDst += (8 * 3);  // dwords!
    }

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);
}

/*****************************************************************************
 * VOID vMilFillPat24bpp
 *
 * 24bpp patterned color fills for Storm.
 ****************************************************************************/

VOID vMilFillPat24bpp(
    PDEV*           ppdev,
    LONG            c,          // Can't be zero
    RECTL*          prcl,       // List of rectangles to be filled, in relative
                                //   coordinates
    ULONG           rop4,       // Rop4
    RBRUSH_COLOR    rbc,        // rbc.prb points to brush realization structure
    POINTL*         pptlBrush)  // Pattern alignment
{
    BRUSHENTRY* pbe;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    LONG        xBrush;
    LONG        yBrush;
    LONG        lSrcAdd;
    ULONG       ulLinear;
    BYTE*       pjBase;
    ULONG       ulHwMix;

    ASSERTDD(!(rbc.prb->fl & RBRUSH_2COLOR), "Can't do 2 colour brushes here");

    // We have to ensure that no other brush took our spot in off-screen
    // memory, or we might have to realize the brush for the first time.
    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if (pbe->prbVerify != rbc.prb)
    {
        vMilPatRealize24bpp(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjBase = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    lSrcAdd = ppdev->lPatSrcAdd;

    CHECK_FIFO_SPACE(pjBase, 6);

    CP_WRITE(pjBase, DWG_AR5, 32);   // Source (pattern) pitch.

    ppdev->HopeFlags = SIGN_CACHE;

    if ((rop4 & 0x000000FF) == 0x000000F0)
    {
        // The rop is PATCOPY.
        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + sgnzero_ZERO +
                                   shftzero_ZERO + bop_SRCCOPY +
                                   bltmod_BFCOL + pattern_ON +
                                   transc_BG_OPAQUE));
    }
    else
    {
        ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + sgnzero_ZERO +
                                   shftzero_ZERO + bltmod_BFCOL + pattern_ON +
                                   transc_BG_OPAQUE +
                                   (ulHwMix << 16)));
    }

    // The pattern setup is complete.
    while(TRUE)
    {
        // Take into account the brush origin.  The upper left pel of the
        // brush should be aligned here in the destination surface.
        yTop     = prcl->top;
        xLeft    = prcl->left;
        xBrush   = (xLeft - pptlBrush->x) & 7;
        yBrush   = (yTop  - pptlBrush->y) & 7;
        ulLinear = pbe->ulLinear + (yBrush << 5) + xBrush;

        CP_WRITE(pjBase, DWG_AR3, ulLinear);
        CP_WRITE(pjBase, DWG_AR0, (ulLinear +7));

        CP_WRITE(pjBase, DWG_FXBNDRY,
                    (((prcl->right + xOffset - 1) << bfxright_SHIFT) |
                     ((xLeft       + xOffset) & bfxleft_MASK)));

        // ylength_MASK not is needed since coordinates are within range

        CP_START(pjBase, DWG_YDSTLEN,
                    (((yTop + yOffset     ) << yval_SHIFT) |
                     ((prcl->bottom - yTop))));

        if (--c == 0)
            return;

        CHECK_FIFO_SPACE(pjBase, 4);
        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\***************************************************************************/

VOID vCheckFifoSpace(BYTE*, ULONG);
CHAR cGetFifoSpace(BYTE*);
VOID vWriteDword(BYTE*, ULONG);
VOID vWriteByte(BYTE*, UCHAR);

#if DBG

VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1996 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

LONG DebugLevel = 0;
LONG gcFifo = 0;                // Number of currently free FIFO entries

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

////////////////////////////////////////////////////////////////////////////

VOID vCheckFifoSpace(
BYTE*   pjBase,
ULONG   level)
{
    gcFifo = level;

    CP_EIEIO();
    do {} while ((ULONG) CP_READ_REGISTER_BYTE(pjBase + HST_FIFOSTATUS) < level);
}

CHAR cGetFifoSpace(
BYTE*   pjBase)
{
    CHAR c;

    CP_EIEIO();
    c = CP_READ_REGISTER_BYTE(pjBase + HST_FIFOSTATUS);

    gcFifo = c;

    return(c);
}

VOID vWriteDword(
BYTE*   pj,
ULONG   ul)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_ULONG(pj, ul);
}

VOID vWriteByte(
BYTE*   pj,
BYTE    j)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_UCHAR(pj, j);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          7
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"MGA"      // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "Mga: "     // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               'agmD'      // Dmga
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // 16  // Size of the DriverExtra information
                                //   in the DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);
VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vMgaGetBits8bpp(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vMgaGetBits16bpp(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vMgaGetBits24bpp(PDEV*, SURFOBJ*, RECTL*, POINTL*);

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DIRECTDRAW         = 0x0004,   // DirectDraw is enabled
} STATUSFLAGS;

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_HEIGHT  47  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cy;         // Glyph height
    LONG            cxLessOne;  // Glyph width, less one
    ULONG           ulLinearStart;
                                // Linear start address of glyph in off-screen
                                //   memory
    ULONG           ulLinearEnd;// Linear end address
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Brush stuff

#define BRUSH_CACHE_HEIGHT  2   // Number of scans to allocate for brush cache

#define RBRUSH_2COLOR       1   // Monochrome brush

#define TOTAL_BRUSH_SIZE    64  // We'll only ever handle 8x8 patterns,
                                //   and this is the number of pels

typedef union _RBRUSH_COLOR RBRUSH_COLOR;
typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);

typedef struct _BRUSHENTRY BRUSHENTRY;

typedef struct _RBRUSH {
    FLONG       fl;             // RBRUSH_ type flags
    ULONG       ulColor[2];     // 0 -- background colour if 2-colour brush
                                // 1 -- foreground colour if 2-colour brush
    FNFILL*     pfnFillPat;     // Fill routine to be called for this brush
    BRUSHENTRY* apbe[MAX_BOARDS];// Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    ULONG       ulLeft;         // 'FXLEFT' coordinate for writing pattern
                                //   assuming a stride of 32
    ULONG       ulYDst;         // 'YDST' coordinate for writing pattern,
                                //   assuming a stride of 32
    ULONG       ulLinear;       // Linear start address of brush
    VOID*       pvScan0;        // Address of pattern (brush)

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

VOID vMgaPatRealize8bpp(PDEV*, RBRUSH*);

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vMgaDirectStretch8Narrow(STR_BLT*);
VOID vMgaDirectStretch8(STR_BLT*);
VOID vMgaDirectStretch16(STR_BLT*);

VOID vMilDirectStretch8Narrow(STR_BLT*);
VOID vMilDirectStretch8(STR_BLT*);
VOID vMilDirectStretch16(STR_BLT*);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);
VOID            vRealize4ColorDither(RBRUSH*, ULONG);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OH_FREE = 0,        // The off-screen allocation is available for use
    OH_DISCARDABLE,     // The allocation is occupied by a discardable bitmap
                        //   that may be moved out of off-screen memory
    OH_PERMANENT,       // The allocation is occupied by a permanent bitmap
                        //   that cannot be moved out of off-screen memory
} OHSTATE;

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHSTATE  ohState;       // State of off-screen allocation
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    LONG     cxReserved;    // Dimensions of original reserved rectangle;
    LONG     cyReserved;    //   zero if rectangle is not 'reserved'
    OH*      pohNext;       // When OH_FREE or OH_RESERVE, points to the next
                            //   free node, in ascending cxcy value.  This is
                            //   kept as a circular doubly-linked list with a
                            //   sentinel at the end.
                            // When OH_DISCARDABLE, points to the next most
                            //   recently created allocation.  This is kept as
                            //   a circular doubly-linked list.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    LONG     cxBounds;      // Largest possible bounding rectangle
    LONG     cyBounds;
    OH       ohFree;        // Head of the free list, containing those
                            //   rectangles in off-screen memory that are
                            //   available for use.  pohNext points to
                            //   hte smallest available rectangle, and pohPrev
                            //   points to the largest available rectangle,
                            //   sorted by cxcy.
    OH       ohDiscardable; // Head of the discardable list that contains all
                            //   bitmaps located in offscreen memory that
                            //   are eligible to be tossed out of the heap.
                            //   It is kept in order of creation: pohNext
                            //   points to the most recently created; pohPrev
                            //   points to the least recently created.
    OH       ohPermanent;   // List of permanently allocated rectangles
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    BOOL      bDirectDraw;  // TRUE if this is a DSURF wrapped around a
                            //   DirectDraw surface
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Max number of WRAM boundaries that can't be crossed by the FASTBLT
// hardware on the STORM (Millennium).

#define MAX_WRAM_BARRIERS   3

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x0001,   // Don't kick stuff out of off-
                                        //   screen memory to make room
    FLOH_MAKE_PERMANENT     = 0x0002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x0004,   // Allocate an off-screen entry,
                                        //   but let it be used by discardable
                                        //   bitmaps until it's needed
} FLOH;

// Publicly callable heap APIs:

OH*  pohAllocate(PDEV*, POINTL*, LONG, LONG, FLOH);
BOOL bOhCommit(PDEV*, OH*, BOOL);
OH*  pohFree(PDEV*, OH*);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette();
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

typedef struct _FLIPRECORD
{
    LONGLONG        liFlipDuration; // Exact duration of a vertical refresh
                                    //   cycle
    LONGLONG        liFlipTime;     // Exact time at which the flip command
                                    //   was given
    FLATPTR         fpFlipFrom;     // Identifies the surface which was
                                    //   'flipped from'.  We have to prevent
                                    //   all drawing to this surface until we
                                    //   know that a vertical retrace has
                                    //   happened since the command was given,
                                    //   so it's now non-visible and thus safe
                                    //   to draw on.
    DWORD           dwScanLine;     // Scan line that was current the last time
                                    //   we sampled whether the flip was
                                    //   complete
    BOOL            bFlipFlag;      // Indicates whether a flip is pending

} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

BOOL bEnableMCD(PDEV*);
VOID vDisableMCD(PDEV*);
VOID vAssertModeMCD(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef BOOL (FNBITBLT)(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                        RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);

typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef BOOL (FNFASTFILL)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*,
                          POINTL*, RECTL*);
typedef VOID (FNPATREALIZE)(PDEV*, RBRUSH*);

FNFILL              vFillPat1bpp;
FNXFER              vXfer4bpp;
FNXFER              vXfer8bpp;
FNXFER              vXferNative;
FNFASTFILL          bFastFill;

FNBITBLT            bMilPuntBlt;
FNPATREALIZE        vMilPatRealize;
FNPATREALIZE        vMilPatRealize24bpp;
FNFILL              vMilFillPat;
FNFILL              vMilFillPat24bpp;
FNFILL              vMilFillSolid;
FNXFER              vMilXfer1bpp;
FNCOPY              vMilCopyBlt;

FNBITBLT            bMgaPuntBlt;
FNFILL              vMgaFillPat8bpp;
FNFILL              vMgaFillPat16bpp;
FNFILL              vMgaFillPat24bpp;
FNFILL              vMgaFillSolid;
FNXFER              vMgaXfer1bpp;
FNCOPY              vMgaCopyBlt;

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the miniport's header!

typedef enum {
} CAPS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;                // DFB offset for current surface
    LONG        yOffset;                // DFB offset for current surface
    LONG        cxMemory;               // Width of video RAM
    LONG        cyMemory;               // Height of video RAM
    BYTE*       pjBase;                 // Points to coprocessor base address
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    ULONG       ulYDstOrg;              // Offset in pixels to be factored in
                                        //   whenever computing an MGA linear
                                        //   address

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    LONG        cjMemAvail;             // Amount of video memory in bytes.
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)
    ULONG       iBitmapFormat;          // BMF_8BPP, BMF_16BPP, BMF_24BPP or
                                        //   BMF_32BPP (our current colour
                                        //   depth)
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)

    BOOL        bEnabled;               // In graphics mode (not full-screen)
    CAPS        flCaps;                 // Capabilities flags
    ULONG       flFeatures;

    STATUSFLAGS flStatus;               // Status flags
    ULONG       cjDmaOffset;            // Current offset for next write into
                                        //   DMA window, used to avoid memory
                                        //   barriers on the Alpha
    ULONG       ulPlnWt;                // Default write mask for mode
    ULONG       ulAccess;               // Default MACCESS register state
    ULONG       ulBoardId;              // MGA product ID

    ULONG       HopeFlags;              // For register accelerations

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    LONG        cjPelSize;              // Number of bytes per pel, according
                                        //   to GDI
    LONG        cjHwPel;                // Number of bytes per pel, as stored
                                        //   in the frame buffer
    ULONG       ulRefresh;              // For debug output

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;           // Call this function for solid fills
    FNFILL*     pfnFillPatNative;
    FNXFER*     pfnXfer1bpp;
    FNCOPY*     pfnCopyBlt;
    FNBITBLT*   pfnPuntBlt;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Off-screen heap structure for the
                                        //   visible screen
    POINTL      ptlOrg;                 // Where the screen 0,0 is anchored
                                        //   in the virtual display.

    ////////// Pointer stuff:

    ULONG       RamDacFlags;            // Ramdac pointer type
    SIZEL       szlPointerOverscan;     // Pointer overscan x and y
    BOOL        bHwPointerActive;       // Currently using the h/w pointer?
    POINTL      ptlHotSpot;             // For remembering pointer hot spot
    LONG        cyPointerHeight;        // Current pointer-height

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY* pbe;                    // Keeps track of brush cache
    BRUSHENTRY  beUnrealizedBrush;      // Place holder for unrealized brushes
    LONG        lPatSrcAdd;             // Bug fix for the Storm
    ULONG       ulBrushSize;            // Size of a brush realization in bytes

    ////////// Line stuff:

    ULONG       ulLineControl;          // Control register for current line
                                        //   command

    ////////// Text stuff:

    ULONG       ulTextControl;          // MGA DwgCtl setting for bltting
                                        //   text
    ULONG       ulGlyphCurrent;         // Linear address of next glyph to be
                                        //   cached in off-screen memory
    ULONG       ulGlyphStart;           // Linear address of start of glyph
                                        //   cache
    ULONG       ulGlyphEnd;             // Linear address of end of glyph
                                        //   cache
    CACHEDFONT  cfSentinel;             // Sentinel for the doubly-linked list
                                        //   we use to keep track of all
                                        //   cached font allocations

    /////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track VBlank status

    /////////// WRAM fast copy stuff:

    LONG        ayBreak[MAX_WRAM_BARRIERS]; // Array of the precalculated
                                            //   WRAM breaks in y.
    LONG        cyBreak;                // Number of WRAM breaks in y.

    ////////// OpenGL MCD stuff:

    ULONG       iUniqueness;            // display uniqueness for tracking
                                        // resolution changes
    LONG        cDoubleBufferRef;       // Reference count for current number
                                        //   of RC's that have active double-
                                        //   buffers
    OH*         pohBackBuffer;          // Our 2-d heap allocation structure
                                        //   for the back-buffer
    ULONG       ulBackBuffer;           // Byte offset in the frame buffer
                                        //   to the start of the back-buffer
    LONG        cZBufferRef;            // Reference count for current number
                                        //   of RC's that have active z-buffers
                                        //   (which, on Athenta, is all RC's)
    OH*         pohZBuffer;             // Our 2-d heap allocation structure
                                        //   for the z-buffer
    ULONG       ulFrontZBuffer;         // Byte offset in the frame buffer
                                        //   to the start of the front z-buffer
                                        //   (the MGA sometimes has to have
                                        //   separate z-buffers for front and
                                        //   back)
    ULONG       ulBackZBuffer;          // Byte offset in the frame buffer
                                        //   to the start of the back z-buffer

    HANDLE      hMCD;                   // Handle to MCD engine dll
    MCDENGESCFILTERFUNC pMCDFilterFunc; // MCD engine filter function

    // Added to support GetAvailDriverMemory callback in DDraw
    ULONG ulTotalAvailVideoMemory;
} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

VOID vStretchDIB(PDEV*, RECTL*, VOID*, LONG, RECTL*, RECTL*);
BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);
BOOL bSelectMode(HANDLE, DEVMODEW*, VIDEO_MODE_INFORMATION*, ULONG*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gaRop3FromMix[];
extern BYTE gajFlip[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

// Prototype to handle display (resolution) uniqueness for MCD:

ULONG GetDisplayUniqueness(PDEV *);

//////////////////////////////////////////////////////////////////////
// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
ULONG   MulEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
BOOL    DbgOffset(SURFOBJ*,LONG,LONG,FLONG);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);
BOOL    DbgResetPDEV(DHPDEV, DHPDEV);
BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*,
                             DWORD*, DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);
BOOL    DbgIcmSetDeviceGammaRamp(DHPDEV, ULONG, LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

#define DBG_MCD   0

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER     |
     GCAPS_DIRECTDRAW       |
     GCAPS_ASYNCMOVE),          // NOTE: Only enable ASYNCMOVE if your code
                                //   and hardware can handle DrvMovePointer
                                //   calls at any time, even while another
                                //   thread is in the middle of a drawing
                                //   call such as DrvBitBlt.

                                                // flGraphicsCaps
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0,                                          // hpalDefault (filled in later)
    GCAPS2_CHANGEGAMMARAMP                      // flGraphicsCaps2
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if MULTI_BOARDS

// Multi-board support has its own thunks...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
    // Note that DrvStretchBlt is not supported for multi-boards
    // Note that DrvCreateDeviceBitmap is not supported for multi-boards
    // Note that DrvDeleteDeviceBitmap is not supported for multi-boards
    // Note that DrvEscape is not supported for multi-boards
    // Note that DrvLineTo is not supported for multi-boards
    // Note that DrvDirectDraw functions are not supported for multi-boards
};

#elif DBG

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvOffset,                (PFN) DbgOffset             },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DbgGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DbgEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DbgDisableDirectDraw  },
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },
    {   INDEX_DrvResetPDEV,             (PFN) DbgResetPDEV          },
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DbgIcmSetDeviceGammaRamp },
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvOffset,                (PFN) DrvOffset             },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* ULONG GetDisplayUniqueness(PDEV *ppdev)
*
* Returns the display uniqueness.
*
\**************************************************************************/


ULONG GetDisplayUniqueness(PDEV *ppdev)
{
    return ppdev->iUniqueness;
}


/******************************Public*Routine******************************\
* BOOL DrvResetPDEV
*
* Notifies the driver of a dynamic mode change.
*
\**************************************************************************/

BOOL DrvResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    PDEV* ppdevNew = (PDEV*) dhpdevNew;
    PDEV* ppdevOld = (PDEV*) dhpdevOld;

    ppdevNew->iUniqueness = ppdevOld->iUniqueness + 1;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    DISPDBG((1, "DrvEnablePDEV - Entry"));

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*           ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*       ppdev;
    HSURF       hsurf;
    SIZEL       sizl;
    DSURF*      pdsurf;
    VOID*       pvTmpBuffer;
    SURFOBJ*    pso;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    if (!bEnableMCD(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh     = ppdev->pohScreen;     // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;            // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Since we can map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it is
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBoardId == MGA_STORM) {

        // We should have a linear frame buffer, so create an
        // engine managed surface.

        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        BMF_TOPDOWN,
                                        ppdev->pjScreen +
                                        (ppdev->ulYDstOrg * ppdev->cjPelSize));

        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateBitmap"));
            goto ReturnFailure;
        }

        // Set it up so that the when we are passed a SURFOBJ for the
        // screen, the 'dhsurf' will point to the screen's surface structure:
        // !!! Grody?

        pso = EngLockSurface(hsurf);
        if (pso == NULL)
        {
            DISPDBG((0, "DrvEnableSurface - Couldn't lock our surface"));
            goto ReturnFailure;
        }
        pso->dhsurf = (DHSURF) pdsurf;
        EngUnlockSurface(pso);

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
            goto ReturnFailure;
        }


    } else {

        // Device-managed surface:

        hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
            goto ReturnFailure;
        }

        /////////////////////////////////////////////////////////////////////
        // Now associate the surface and the PDEV.
        //
        // We have to associate the surface we just created with our physical
        // device so that GDI can get information related to the PDEV when
        // it's drawing to the surface (such as, for example, the length of
        // styles on the device when simulating styled lines).

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
            goto ReturnFailure;
        }

    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableMCD(ppdev);
    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    EngFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    EngFreeMem(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvOffset
*
* DescriptionText
*
\**************************************************************************/

BOOL DrvOffset(
SURFOBJ*    pso,
LONG        x,
LONG        y,
FLONG       flReserved)
{
    PDEV*   ppdev = (PDEV*) pso->dhpdev;
    OH*     poh = ppdev->pohScreen;

    LONG    dx = x - poh->x;
    LONG    dy = y - poh->y;

    poh->x -= dx;
    poh->y -= dy;
    (BYTE*)poh->pvScan0 -= ((dy * ppdev->lDelta) +
                            (dx * ppdev->cjPelSize));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeMCD(ppdev, FALSE);

        vAssertModeDirectDraw(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

        vAssertModeDirectDraw(ppdev, TRUE);

        vAssertModeMCD(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            vAssertModeDirectDraw(ppdev, TRUE);

            vAssertModeMCD(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;
    VIDEO_MODE_INFORMATION DefaultMode;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Fill in some DriverExtra information if necessary
                //

                // *((PDWORD)(pdm+1))      = 0x11111111;
                // *(((PDWORD)(pdm+1))+1)  = 0x22222222;
                // *(((PDWORD)(pdm+1))+2)  = 0x33333333;
                // *(((PDWORD)(pdm+1))+3)  = 0x44444444;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bSetModeAndWarmupHardware
*
* Sets the requested actual mode and initializes the hardware to a known
* state.
*
\**************************************************************************/

BOOL bSetModeAndWarmupHardware(
PDEV*   ppdev)
{
    BYTE*   pjBase;
    DWORD   ReturnedDataLength;
    ULONG   ulReturn;
    HW_DATA HwData;

    pjBase = ppdev->pjBase;

    // Call the miniport via a public IOCTL to set the graphics mode.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         &ppdev->ulMode,            // Input
                         sizeof(DWORD),
                         NULL,                      // Output
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bSetModeAndWarmupHardware - Failed VIDEO_SET_CURRENT_MODE"));
        goto ReturnFalse;
    }

    if (ppdev->ulBoardId == MGA_STORM)
    {
        // There might be multiple MGA boards installed in the system.  Since
        // we're here only when a single board is required by the selected
        // resolution, we should make sure that the miniport knows that the
        // current board is board 0.

        LONG    lHwBoard;

        lHwBoard = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT,
                             &lHwBoard,             // input buffer
                             sizeof(LONG),
                             NULL,                  // output buffer
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bSetModeAndWarmupHardware - Failed MTX_MAKE_BOARD_CURRENT"));
            goto ReturnFalse;
        }
    }

    // Get the MGA's linear offset using a private IOCTL:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MTX_QUERY_HW_DATA,
                         NULL,                              // Input
                         0,
                         &HwData,                           // Output
                         sizeof(HW_DATA),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bSetModeAndWarmupHardware -- failed MTX_QUERY_HW_DATA"));
        goto ReturnFalse;
    }

    ppdev->ulYDstOrg = HwData.YDstOrg;
    ppdev->flFeatures = HwData.Features;

    if (ppdev->ulBoardId == MGA_STORM)
    {
        ppdev->cjMemAvail = HwData.MemAvail;

        // Floor((4M-(ulYDstOrg*cBpp))/(1600*3)) == scan where 4M break occurs.
        // This array would be stored on pdev or at least calculated in a temp

        if (ppdev->flFeatures & INTERLEAVE_MODE)
        {
            DISPDBG((1, "This mode is interleaved"));

            ppdev->ayBreak[0] = (0x400000 - ppdev->ulYDstOrg)/(ppdev->lDelta);

            if ((HwData.MemAvail == 0x200000)||
                (HwData.MemAvail == 0x400000))
            {
                ppdev->cyBreak = 0;
            }
            else
            {
                ASSERTDD (HwData.MemAvail == 0x800000, "HwData.MemAvail is invalid");
                ppdev->cyBreak = 1;
            }
        }
        else
        {
            DISPDBG((1,"This mode is non-interleaved"));

            ppdev->ayBreak[0] = (0x200000 - ppdev->ulYDstOrg)/(ppdev->lDelta);
            ppdev->ayBreak[1] = (0x400000 - ppdev->ulYDstOrg)/(ppdev->lDelta);
            ppdev->ayBreak[2] = (0x600000 - ppdev->ulYDstOrg)/(ppdev->lDelta);

            if (HwData.MemAvail == 0x200000)
            {
                ppdev->cyBreak = 0;
            }
            else if (HwData.MemAvail == 0x400000)
            {
                ppdev->cyBreak = 1;
            }
            else
            {
                ASSERTDD (HwData.MemAvail == 0x800000, "HwData.MemAvail is invalid");
                ppdev->cyBreak = 3;
            }
        }

        DISPDBG((1, "cyBreak = %d", ppdev->cyBreak));
    }
    else
    {
        //
        // This field is uninitliazed on non-storm boards.
        //

        ppdev->cjMemAvail = HwData.MemAvail;
    }

    ppdev->HopeFlags = 0;

    CHECK_FIFO_SPACE(pjBase, 5);
    CP_WRITE(pjBase, DWG_MACCESS, ppdev->ulAccess);
    CP_WRITE(pjBase, DWG_SHIFT,   0);
    CP_WRITE(pjBase, DWG_YDSTORG, ppdev->ulYDstOrg);
    CP_WRITE(pjBase, DWG_PLNWT,   ppdev->ulPlnWt);
    CP_WRITE(pjBase, DWG_PITCH,   ppdev->cxMemory);

    if (ppdev->ulBoardId != MGA_STORM)
    {
        CP_WRITE_REGISTER(pjBase + HST_OPMODE,
            CP_READ_REGISTER(pjBase + HST_OPMODE) | 0x01000000);
    }

    vResetClipping(ppdev);

    // At this point, the RAMDAC should be okay, but it looks
    // like it's not quite ready to accept data, particularly
    // on VL boards.  Adding a delay seems to fix things.
    // Sleep(100);

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

VOID
DrvSynchronize(
    IN DHPDEV dhpdev,
    IN RECTL *prcl
    )
{
    PDEV *ppdev = (PDEV *) dhpdev;

    //
    // We need to do a wait for blt complete before we
    // let the engine party on our frame buffer
    //

    WAIT_NOT_BUSY(ppdev->pjBase)
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state when entering or leaving graphics
* mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    ULONG   ulNewFileSize;
    DWORD   ReturnedDataLength;
    ULONG   ulReturn;

    if (bEnable)
    {
        // The MGA miniport requires that the screen must be reenabled
        // and reinitialized to a clean state.  This should not be done
        // for more than one board when supporting multiple boards:

        if (IBOARD(ppdev) == 0)
        {
            // Re-enable the MGA's screen via a private IOCTL:

            if (EngDeviceIoControl(ppdev->hDriver,
                                 IOCTL_VIDEO_MTX_INITIALIZE_MGA,
                                 NULL,
                                 0,
                                 &ulNewFileSize,
                                 sizeof(ULONG),
                                 &ReturnedDataLength))
            {
                DISPDBG((0, "bAssertModeHardware - Failed VIDEO_MTX_INITAILIZE_MGA"));
                goto ReturnFalse;
            }

            // The miniport should also build a new mode table, via a
            // private IOCTL:

            if (EngDeviceIoControl(ppdev->hDriver,
                                 IOCTL_VIDEO_MTX_INIT_MODE_LIST,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &ReturnedDataLength))
            {
                DISPDBG((0, "bAssertModeHardware - Failed VIDEO_MTX_INIT_MODE_LIST"));
                goto ReturnFalse;
            }
        }

        if (!bSetModeAndWarmupHardware(ppdev))
        {
            DISPDBG((0, "bAssertModeHardware - Failed bSetModeAndWarmupHardware"));
            goto ReturnFalse;
        }
    }
    else
    {
        // Wait for all pending accelerator operations to finish:

        CHECK_FIFO_SPACE(ppdev->pjBase, FIFOSIZE);

        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there.  One reset will affect
        // all boards:

        if (IBOARD(ppdev) == 0)
        {
            if (EngDeviceIoControl(ppdev->hDriver,
                                 IOCTL_VIDEO_RESET_DEVICE,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &ulReturn))
            {
                DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
                return(FALSE);
            }
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_PUBLIC_ACCESS_RANGES      VideoPublicAccessRanges;
    VIDEO_MEMORY                    VideoMemory;
    VIDEO_MEMORY_INFORMATION        VideoMemoryInfo;
    ULONG                           ReturnedDataLength;

    // Get the coprocessor address range using a public IOCTL:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                              // Input
                         0,
                         (VOID*) &VideoPublicAccessRanges,  // Output
                         sizeof(VideoPublicAccessRanges),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware -- failed QUERY_PUBLIC_ACESS_RANGES"));
        return(FALSE);
    }

    ppdev->pjBase = (BYTE*) VideoPublicAccessRanges.VirtualAddress;


    if (ppdev->ulBoardId == MGA_STORM)
    {
        // Get an address for our frame buffer.
        VideoMemory.RequestedVirtualAddress = NULL;
        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                             &VideoMemory,                      // Input
                             sizeof(VIDEO_MEMORY),
                             &VideoMemoryInfo,                  // Output
                             sizeof(VideoMemoryInfo),
                             &ReturnedDataLength))
        {
            DISPDBG(( 0, "bEnableHardware - Failed VIDEO_MAP_VIDEO_MEMORY"));
            return(FALSE);
        }

        // Record the mapped location of the MGA registers.
        // We can now access the board!
        ppdev->pjScreen = VideoMemoryInfo.FrameBufferBase;
    }
    else
    {
        // This should probably just be done in the IOCTL call

        DISPDBG((2, "Video chip is not an MGA_STORM"));
        ppdev->pjScreen = NULL;
    }

    DISPDBG((1, "bEnableHardware -- pjScreen = %x", ppdev->pjScreen));

    ///////////////////////////////////////////////////////////////////

    // Now we can set the mode, unlock the accelerator, and reset the
    // clipping:

    if (!bSetModeAndWarmupHardware(ppdev))
        goto ReturnFalse;

    DISPDBG((0, "Memory: %lix%li  YDstOrg: %li",
        ppdev->cxMemory, ppdev->cyMemory, ppdev->ulYDstOrg));

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY    VideoMemory;
    ULONG           ReturnedDataLength;

    VideoMemory.RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           &VideoMemory,
                           sizeof(VideoMemory),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory.RequestedVirtualAddress = ppdev->pjBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         &VideoMemory,                  // Input
                         sizeof(VideoMemory),
                         NULL,                          // Output
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware -- failed FREE_PUBLIC_ACCESS_RANGES"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeOffscreenFields
*
\**************************************************************************/

BOOL bInitializeOffscreenFields(
PDEV*                   ppdev,
VIDEO_MODE_INFORMATION* pVideoModeInformation)
{
    VIDEO_NUM_OFFSCREEN_BLOCKS  NumOffscreenBlocks;
    OFFSCREEN_BLOCK*            pOffscreenBlock;
    OFFSCREEN_BLOCK*            pBuffer;
    ULONG                       ReturnedDataLength;
    ULONG                       cjOffscreenBlock;
    LONG                        i;

    // Ask the MGA miniport about the number of offscreen areas available
    // for our selected mode, using a private IOCTL:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MTX_QUERY_NUM_OFFSCREEN_BLOCKS,
                         pVideoModeInformation,             // Input
                         sizeof(VIDEO_MODE_INFORMATION),
                         &NumOffscreenBlocks,               // Output
                         sizeof(VIDEO_NUM_OFFSCREEN_BLOCKS),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bInitializeOffscreenFields -- failed QUERY_NUM_OFFSCREEN_BLOCKS"));
        goto ReturnFalse;
    }

    cjOffscreenBlock = NumOffscreenBlocks.NumBlocks
                     * NumOffscreenBlocks.OffscreenBlockLength;

    pBuffer = pOffscreenBlock = (OFFSCREEN_BLOCK*) EngAllocMem(FL_ZERO_MEMORY,
                                                    cjOffscreenBlock, ALLOC_TAG);
    if (pOffscreenBlock == NULL)
    {
        DISPDBG((0, "bInitializeOffscreenFields -- failed pOffscreenBlock EngAllocMem"));
        goto ReturnFalse;
    }

    // Ask the MGA miniport to fill in the available offscreen areas using
    // a private IOCTL:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MTX_QUERY_OFFSCREEN_BLOCKS,
                         pVideoModeInformation,             // Input
                         sizeof(VIDEO_MODE_INFORMATION),
                         pOffscreenBlock,                   // Output
                         cjOffscreenBlock,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bInitializeOffscreenFields -- failed QUERY_OFFSCREEN_BLOCKS"));
        EngFreeMem(pOffscreenBlock);
        goto ReturnFalse;
    }

    ppdev->cyMemory = ppdev->cyScreen;

    for (i = NumOffscreenBlocks.NumBlocks; i != 0; i--, pOffscreenBlock++)
    {
        // We are just looking to add the offscreen block that immediately follows
        // the screen block.

        DISPDBG((1, "Offscreen blocks:"));
        DISPDBG((1, "  (%li, %li) at (%li, %li) Type: %li Planes: %lx ZOffset: %li",
                    pOffscreenBlock->Width,  pOffscreenBlock->Height,
                    pOffscreenBlock->XStart, pOffscreenBlock->YStart,
                    pOffscreenBlock->Type,   pOffscreenBlock->SafePlanes,
                    pOffscreenBlock->ZOffset));

        // The miniport seems to be giving us garbage for some fields:

        if ((pOffscreenBlock->YStart == (ULONG) ppdev->cyScreen) &&
            (pOffscreenBlock->Width  >= (ULONG) ppdev->cxScreen))
        {
            // Found the right one.

            ppdev->cyMemory = ppdev->cyScreen + pOffscreenBlock->Height;
        }
    }

    EngFreeMem(pBuffer);

    // u The MGA miniport should be changed to never reserve space for 'Z'
    // or the back buffer -- we want to do that ourselves.  Right now,
    // it does so for the only 3d enabled mode it thinks we can do,
    // namely 5-5-5 on a 4MB Impression Plus:

    if ((ppdev->ulBoardId == MGA_PCI_4M) &&
        (ppdev->flGreen == 0x3e0))
    {
        // The total count of scans is the floor of 4MB divided by the
        // screen stride, less one to account for a possible ulYDstOrg that
        // we don't yet know:

        ppdev->cyMemory = (4096 * 1024) / (ppdev->cxMemory * 2);
    }

    // On an Impression Lite (Atlas) card, we found that we couldn't use
    // the last scan for keeping brush caches.  We'll assume this is the
    // same for other operations, as well, and simply decrease the amount of
    // available off-screen by that many scans:

    if (ppdev->cyMemory > ppdev->cyScreen)
    {
        ppdev->cyMemory--;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bSelectMode
*
* Negotiates the video mode with the miniport.
*
\**************************************************************************/

BOOL bSelectMode(
HANDLE                  hDriver,
DEVMODEW*               pdm,                    // Requested mode
VIDEO_MODE_INFORMATION* pVideoModeInformation,  // Returns requested mode
ULONG*                  pulBoardId)             // Returns MGA board ID
{
    ULONG                           cModes;
    PVIDEO_MODE_INFORMATION         pVideoBuffer;
    PVIDEO_MODE_INFORMATION         pVideoModeSelected;
    PVIDEO_MODE_INFORMATION         pVideoTemp;
    BOOL                            bSelectDefault;
    VIDEO_MODE_INFORMATION          VideoModeInformation;
    VIDEO_PUBLIC_ACCESS_RANGES      VideoPublicAccessRanges;
    ULONG                           cbModeSize;
    DWORD                           ReturnedDataLength;
    ULONG                           ulBoardId;
    ULONG                           cDefaultBitsPerPel;

    if (EngDeviceIoControl(hDriver,
                         IOCTL_VIDEO_MTX_QUERY_BOARD_ID,
                         NULL,                      // Input
                         0,
                         &ulBoardId,
                         sizeof(ULONG),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bSelectMode -- failed MTX_QUERY_BOARD_ID"));
        goto ReturnFailure0;
    }

    // Use the driver's lowest pixel depth for the default mode:

    *pulBoardId = ulBoardId;

    DISPDBG((2, "ulBoardId = %x", ulBoardId));

    if ((ulBoardId == MGA_PRO_4M5) || (ulBoardId == MGA_PRO_4M5_Z))
    {
        cDefaultBitsPerPel = 24;
    }
    else
    {
        cDefaultBitsPerPel = 8;
    }

    // Call the miniport to get mode information:

    cModes = getAvailableModes(hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFailure0;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (((bSelectDefault) &&
                 (pVideoTemp->BitsPerPlane == cDefaultBitsPerPel)) ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error:

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        goto ReturnFailure1;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    *pVideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    return(TRUE);

ReturnFailure1:

    EngFreeMem(pVideoBuffer);

ReturnFailure0:

    DISPDBG((0, "Failed bSelectMode"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                           cModes;
    PVIDEO_MODE_INFORMATION         pVideoBuffer;
    PVIDEO_MODE_INFORMATION         pVideoModeSelected;
    PVIDEO_MODE_INFORMATION         pVideoTemp;
    BOOL                            bSelectDefault;
    VIDEO_MODE_INFORMATION          VideoModeInformation;
    VIDEO_PUBLIC_ACCESS_RANGES      VideoPublicAccessRanges;
    ULONG                           cbModeSize;
    DWORD                           ReturnedDataLength;
    ULONG                           ulBoardId;
    ULONG                           cDefaultBitsPerPel;

    // Tell the miniport what mode we want:

    if (!bSelectMode(ppdev->hDriver,
                     pdm,
                     &VideoModeInformation,
                     &ppdev->ulBoardId))
    {
        DISPDBG((0, "bInitializeModeFields -- failed bSelectMode"));
        goto ReturnFalse;
    }

    ppdev->ulMode       = VideoModeInformation.ModeIndex;
    ppdev->cxScreen     = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen     = VideoModeInformation.VisScreenHeight;
    ppdev->cxMemory     = VideoModeInformation.VideoMemoryBitmapWidth;

    ppdev->flRed        = VideoModeInformation.RedMask;
    ppdev->flGreen      = VideoModeInformation.GreenMask;
    ppdev->flBlue       = VideoModeInformation.BlueMask;

    ppdev->flHooks      = (HOOK_BITBLT           |
                           HOOK_TEXTOUT          |
                           HOOK_FILLPATH         |
                           HOOK_COPYBITS         |
                           HOOK_STROKEPATH       |
                           HOOK_LINETO           |
                           HOOK_PAINT            |
                           HOOK_STRETCHBLT       |
                           HOOK_SYNCHRONIZE);

    if (!bInitializeOffscreenFields(ppdev, &VideoModeInformation))
    {
        DISPDBG((0, "bInitializeModeFields -- failed bInitializeOffscreenFields"));
        goto ReturnFalse;
    }

#if DBG_MCD
    if ((VideoModeInformation.VisScreenWidth == 1024) &&
        (VideoModeInformation.BitsPerPlane > 16))
    {
        VideoModeInformation.VisScreenHeight = 256;
        ppdev->cyScreen = VideoModeInformation.VisScreenHeight;
    }
#endif

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    ppdev->ulRefresh = pgdi->ulVRefresh;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cjPelSize        = 1;
        ppdev->cjHwPel          = 1;
        ppdev->lDelta           = ppdev->cxMemory;
        ppdev->iBitmapFormat    = BMF_8BPP;
        ppdev->ulWhite          = 0xff;
        ppdev->ulPlnWt          = plnwt_MASK_8BPP;
        ppdev->ulAccess         = pwidth_PW8;
        ppdev->ulBrushSize      = (TOTAL_BRUSH_SIZE * 1);

        if (ppdev->ulBoardId == MGA_STORM)
        {
            ppdev->pfnFillPatNative = vMilFillPat;
            ppdev->pfnFillSolid     = vMilFillSolid;
        }
        else
        {
            ppdev->pfnFillPatNative = vMgaFillPat8bpp;
            ppdev->pfnFillSolid     = vMgaFillSolid;
        }

        ppdev->cPaletteShift    = 8 - pgdi->ulDACRed;
        ppdev->lPatSrcAdd       = 2;

        // Device GammaRamp can not be changed on 8bpp mode

        pdi->flGraphicsCaps2    &= ~GCAPS2_CHANGEGAMMARAMP;
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cjPelSize        = 2;
        ppdev->cjHwPel          = 2;
        ppdev->lDelta           = 2 * ppdev->cxMemory;
        ppdev->iBitmapFormat    = BMF_16BPP;
        ppdev->ulWhite          = (VideoModeInformation.BitsPerPlane == 16)
                                ? 0xffff : 0x7fff;
        pgdi->ulNumColors       = (ULONG) -1;
        pgdi->ulNumPalReg       = 0;
        pgdi->ulHTOutputFormat  = HT_FORMAT_16BPP;
        ppdev->ulPlnWt          = plnwt_MASK_16BPP;
        ppdev->ulAccess         = pwidth_PW16;
        ppdev->ulBrushSize      = (TOTAL_BRUSH_SIZE * 2);

        if (ppdev->ulBoardId == MGA_STORM)
        {
            ppdev->pfnFillPatNative = vMilFillPat;
            ppdev->pfnFillSolid     = vMilFillSolid;

            if (ppdev->flGreen != 0x7e0)    // not 565
                ppdev->ulAccess |= dither_555;
        }
        else
        {
            ppdev->pfnFillPatNative = vMgaFillPat16bpp;
            ppdev->pfnFillSolid     = vMgaFillSolid;

            // Device GammaRamp can not be changed on non-Millenium board

            pdi->flGraphicsCaps2    &= ~GCAPS2_CHANGEGAMMARAMP;
        }

        pdi->iDitherFormat      = BMF_16BPP;
        pdi->flGraphicsCaps    &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
        ppdev->lPatSrcAdd       = 4;
    }
    else if (ppdev->ulBoardId == MGA_STORM)
    {
        if (VideoModeInformation.BitsPerPlane == 24)
        {
            ppdev->cjPelSize        = 3;
            ppdev->cjHwPel          = 3;
            ppdev->lDelta           = 3 * ppdev->cxMemory;
            ppdev->iBitmapFormat    = BMF_24BPP;
            ppdev->ulWhite          = 0xffffff;
            pgdi->ulNumColors       = (ULONG) -1;
            pgdi->ulNumPalReg       = 0;
            pgdi->ulHTOutputFormat  = HT_FORMAT_24BPP;
            ppdev->ulPlnWt          = plnwt_MASK_24BPP;
            ppdev->ulAccess         = pwidth_PW24;
            ppdev->ulBrushSize      = (TOTAL_BRUSH_SIZE * 6);
            ppdev->pfnFillPatNative = vMilFillPat24bpp;
            ppdev->pfnFillSolid     = vMilFillSolid;

            pdi->iDitherFormat      = BMF_24BPP;
            pdi->flGraphicsCaps    &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            ppdev->lPatSrcAdd       = 7;
        }
        else
        {
            ASSERTDD((VideoModeInformation.BitsPerPlane == 32),
                     "This driver supports only 8, 16, 24, and 32bpp");

            ppdev->cjPelSize        = 4;
            ppdev->cjHwPel          = 4;
            ppdev->lDelta           = 4 * ppdev->cxMemory;
            ppdev->iBitmapFormat    = BMF_32BPP;
            ppdev->ulWhite          = 0xffffff;
            pgdi->ulNumColors       = (ULONG) -1;
            pgdi->ulNumPalReg       = 0;
            pgdi->ulHTOutputFormat  = HT_FORMAT_32BPP;
            ppdev->ulPlnWt          = plnwt_MASK_32BPP;
            ppdev->ulAccess         = pwidth_PW32;
            ppdev->ulBrushSize      = (TOTAL_BRUSH_SIZE * 4);
            ppdev->pfnFillPatNative = vMilFillPat;
            ppdev->pfnFillSolid     = vMilFillSolid;

            pdi->iDitherFormat      = BMF_32BPP;
            pdi->flGraphicsCaps    &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            ppdev->lPatSrcAdd       = 6;
        }
    }
    else
    {
        ASSERTDD((VideoModeInformation.BitsPerPlane == 32) ||
                 (VideoModeInformation.BitsPerPlane == 24),
                 "This driver supports only 8, 16, 24, and 32bpp");

        // The miniport may think it's 32bpp, but we're going to tell GDI
        // that it's 24bpp.  We do this so that out bitmap transfers will
        // be more efficient, and compatible bitmaps will be smaller.
        //
        // Note that we also have to fudge the results returned from
        // 'GetModes' if we're going to do this.

        pgdi->cBitsPixel        = 24;

        ppdev->cjPelSize        = 3;
        ppdev->cjHwPel          = 4;
        ppdev->lDelta           = 4 * ppdev->cxMemory;
        ppdev->iBitmapFormat    = BMF_24BPP;
        ppdev->ulWhite          = 0xffffff;
        pgdi->ulNumColors       = (ULONG) -1;
        pgdi->ulNumPalReg       = 0;
        pgdi->ulHTOutputFormat  = HT_FORMAT_24BPP;
        ppdev->ulPlnWt          = plnwt_MASK_24BPP;
        ppdev->ulAccess         = pwidth_PW32;
        ppdev->ulBrushSize      = (TOTAL_BRUSH_SIZE * 3);
        ppdev->pfnFillPatNative = vMgaFillPat24bpp;
        ppdev->pfnFillSolid     = vMgaFillSolid;

        pdi->iDitherFormat      = BMF_24BPP;
        pdi->flGraphicsCaps    &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        // Device GammaRamp can not be changed on non-Millenium board.

        pdi->flGraphicsCaps2    &= ~GCAPS2_CHANGEGAMMARAMP;

        ppdev->lPatSrcAdd       = 0;    // not used for old MGA cards
    }

    // Several MIPS machines are broken in that 64 bit accesses to the
    // framebuffer don't work.

    if (VideoModeInformation.AttributeFlags & VIDEO_MODE_NO_64_BIT_ACCESS)
    {
        DISPDBG((0, "Disable 64 bit access on this device !\n"));
        pdi->flGraphicsCaps |= GCAPS_NO64BITMEMACCESS;
    }

    // The following are the same for all color depths

    if (ppdev->ulBoardId == MGA_STORM)
    {
        ppdev->pfnXfer1bpp      = vMilXfer1bpp;
        ppdev->pfnCopyBlt       = vMilCopyBlt;
        ppdev->pfnPuntBlt       = bMilPuntBlt;
    }
    else
    {
        ppdev->pfnXfer1bpp      = vMgaXfer1bpp;
        ppdev->pfnCopyBlt       = vMgaCopyBlt;
        ppdev->pfnPuntBlt       = bMgaPuntBlt;
    }

    DISPDBG((1, "Current mode: %dx%d %dbpp %dHz", ppdev->cxScreen,
                                                  ppdev->cyScreen,
                                                  ppdev->cjPelSize * 8,
                                                  ppdev->ulRefresh));

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,       // Must be freed by caller
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16, 24, or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      4           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = EngAllocMem(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ohState            = -1;
}

/******************************Public*Routine******************************\
* VOID vCalculateMaximumNonPermanent
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximumNonPermanent(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    cxBounds;
    LONG    cyBounds;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;
    cxBounds = 0;
    cyBounds = 0;

    // First time through, loop through the list of free available
    // rectangles:

    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");

            if (poh->cx > cxBounds)
                cxBounds = poh->cx;
            if (poh->cy > cyBounds)
                cyBounds = poh->cy;

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of discardable
        // rectangles:

        pohSentinel = &ppdev->heap.ohDiscardable;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
    ppdev->heap.cxBounds = cxBounds;
    ppdev->heap.cyBounds = cyBounds;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG   cxcy;
    OH*     pohBeside;
    OH*     pohNext;
    OH*     pohPrev;
    OHSTATE oldState;

    if (poh == NULL)
        return(NULL);

    DISPDBG((1, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    oldState = poh->ohState;
    if (oldState != OH_DISCARDABLE)
    {
        // We can remove the 'reserved' status unless we are merely
        // deleting a discardable rectangle that was temporarily
        // placed in a reserve rectangle:

        poh->cxReserved = 0;
        poh->cyReserved = 0;
    }

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((poh->cxReserved    != poh->cx)         &&
        (pohBeside->ohState == OH_FREE)         &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the free list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((poh->cyReserved     != poh->cy)        &&
        (pohBeside->ohState  == OH_FREE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Don't do any more merge this rectangle into anything to the
    // top or to the left if it's reserved:

    if (!poh->cxReserved)
    {
        // Try merging with the left sibling:

        pohBeside = poh->pohLeft;
        if ((pohBeside->cxReserved != pohBeside->cx) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cy         == poh->cy)       &&
            (pohBeside->pohUp      == poh->pohUp)    &&
            (pohBeside->pohDown    == poh->pohDown)  &&
            (pohBeside->pohRight   == poh)           &&
            (poh->pohRight->pohLeft != poh))
        {
            // We add our rectangle to the one to the left:

            pohBeside->cx      += poh->cx;
            pohBeside->pohRight = poh->pohRight;

            // Remove 'poh' from whatever list it was in (if we were
            // asked to free a 'permanent' node, it will have been in
            // the permanent list) and free it:

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }

        // Try merging with the upper sibling:

        pohBeside = poh->pohUp;
        if ((pohBeside->cyReserved != pohBeside->cy) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cx         == poh->cx)       &&
            (pohBeside->pohLeft    == poh->pohLeft)  &&
            (pohBeside->pohRight   == poh->pohRight) &&
            (pohBeside->pohDown    == poh)           &&
            (poh->pohDown->pohUp != poh))
        {
            pohBeside->cy      += poh->cy;
            pohBeside->pohDown  = poh->pohDown;

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }
    }

    // Remove this node from whatever list it's in:

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node, in order, into the free list:

    pohNext = ppdev->heap.ohFree.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->cxcy        = cxcy;
    poh->ohState     = OH_FREE;

    if (oldState == OH_PERMANENT)
    {
        // Removing the permanent entry means that we may be able to
        // enlarge the maximum possible rectangle we can allow:

        vCalculateMaximumNonPermanent(ppdev);
    }

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bDiscardEverythingInRectangle
*
* Throws out of the heap any discardable bitmaps that intersect with the
* specified rectangle.
*
\**************************************************************************/

BOOL bDiscardEverythingInRectangle(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    cx,
LONG    cy)
{
    BOOL bRet;
    OH*  poh;
    OH*  pohNext;

    bRet = TRUE;        // Assume success

    poh = ppdev->heap.ohDiscardable.pohNext;
    while (poh != &ppdev->heap.ohDiscardable)
    {
        ASSERTDD(poh->ohState == OH_DISCARDABLE,
                 "Non-discardable node in discardable list");

        pohNext = poh->pohNext;

        if ((poh->x < x + cx) &&
            (poh->y < y + cy) &&
            (poh->x + poh->cx > x) &&
            (poh->y + poh->cy > y))
        {
            // The two rectangles intersect.  Give the boot to the
            // discardable bitmap:

            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bFreeRightAndBottomSpace
*
* Given a free off-screen rectangle, allocates the upper-left part of
* the rectangle to hold the allocation request, and puts the two rectangles
* comprising the unused right and bottom portions on the free list.
*
\**************************************************************************/

BOOL bFreeRightAndBottomSpace(
PDEV*   ppdev,
OH*     pohThis,
LONG    cxThis,
LONG    cyThis,
BOOL    bQuantum)           // Set if inifitely small allocations should be
                            //   allowed
{
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;
    LONG  cxRem;
    LONG  cyRem;
    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;
    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;
    LONG  cQuantum;

    // We're going to use the upper-left corner of our given rectangle,
    // and divide the unused remainder into two rectangles which will
    // go on the free list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // If 'bQuantum' is set, we only make new available rectangles of
    // the unused right and bottom portions if they're greater in
    // dimension than OH_QUANTUM (it hardly makes sense to do the
    // book-work to keep around a 2-pixel wide available space, for
    // example):

    cQuantum = (bQuantum) ? 1 : OH_QUANTUM;

    pohBeside = NULL;
    if (cxBeside >= cQuantum)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(FALSE);
    }

    pohBelow = NULL;
    if (cyBelow >= cQuantum)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(FALSE);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxReserved = 0;
        pohBelow->cyReserved = 0;
        pohBelow->cxcy       = cxcy;
        pohBelow->ohState    = OH_FREE;
        pohBelow->x          = pohThis->x;
        pohBelow->y          = pohThis->y + cyThis;
        pohBelow->cx         = cxBelow;
        pohBelow->cy         = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= cQuantum)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxReserved = 0;
        pohBeside->cyReserved = 0;
        pohBeside->cxcy       = cxcy;
        pohBeside->ohState    = OH_FREE;
        pohBeside->x          = pohThis->x + cxThis;
        pohBeside->y          = pohThis->y;
        pohBeside->cx         = cxBeside;
        pohBeside->cy         = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->cxcy = CXCY(pohThis->cx, pohThis->cy);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAtLocation
*
* Attempts to allocate a rectangle at a specific position.
*
\**************************************************************************/

OH* pohMakeRoomAtLocation(
PDEV*   ppdev,
POINTL* pptl,               // Requested position for the rectangle
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // Allocation flags
{
    OH*     poh;
    OH*     pohTop;
    OH*     pohLeft;
    LONG    cxLeft;
    LONG    cyTop;
    OH*     pohRight;

    if (!(floh & FLOH_ONLY_IF_ROOM))
    {
        // First off, discard any bitmaps that overlap the requested
        // rectangle, assuming we're allowed to:

        if (!bDiscardEverythingInRectangle(ppdev, pptl->x, pptl->y, cxThis, cyThis))
            return(NULL);
    }

    // Now see if there is a free rectangle that entirely contains the
    // requested rectangle.

    for (poh = ppdev->heap.ohFree.pohNext;
         poh != &ppdev->heap.ohFree;
         poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState == OH_FREE, "Non-free node in free list");

        // See if the current free rectangle completely contains the
        // requested rectangle:

        if ((poh->x <= pptl->x) &&
            (poh->y <= pptl->y) &&
            (poh->x + poh->cx >= pptl->x + cxThis) &&
            (poh->y + poh->cy >= pptl->y + cyThis))
        {
            // We can't reserve this rectangle, or make it permanent, if it's
            // already been reserved:

            if ((!poh->cxReserved) ||
                ((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0))
            {
                // The 'poh' rectangle entirely contains the requested
                // rectangle.  We may have a situation like this, where
                // the smaller rectangle is the requested rectangle, and
                // the larger rectangle is the available rectangle:
                //
                //     +-------------------+
                //     |                   |
                //     |    +---------+    |
                //     |    |Requested|    |
                //     |    |         |    |
                //     |    +---------+    |
                //     |                   |
                //     +-------------------+
                //
                // We want to make the space to the left and to the top of
                // the requested rectangle available to the heap.  Our
                // free-space routine only knows how to free space to the
                // right and bottom of an allocation, though.  So we will
                // temporarily allocate temporary rectangles to subdivide
                // our rectangle like the following:
                //
                //     +-------------------+
                //     |Top                |
                //     +----+--------------+
                //     |Left|Free          |
                //     |    |              |
                //     |    |              |
                //     |    |              |
                //     +----+--------------+
                //
                // Then, in the resulting 'Free' space, we will allocate the
                // upper-left corner for our requested rectangle, after which
                // we will go back and free the 'Top' and 'Left' temporary
                // rectangles.

                pohTop  = NULL;
                pohLeft = NULL;
                cxLeft  = pptl->x - poh->x;
                cyTop   = pptl->y - poh->y;

                if (cyTop > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, poh->cx, cyTop,
                                                  TRUE))
                    {
                        return(NULL);
                    }

                    pohTop = poh;
                    poh    = pohTop->pohDown;
                }

                if (cxLeft > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, cxLeft, poh->cy,
                                                  TRUE))
                    {
                        pohFree(ppdev, pohTop);
                        return(NULL);
                    }

                    pohLeft = poh;
                    poh     = pohLeft->pohRight;
                }

                ASSERTDD((poh->x == pptl->x) &&
                         (poh->y == pptl->y) &&
                         (poh->x + poh->cx >= poh->x + cxThis) &&
                         (poh->y + poh->cy >= poh->y + cyThis),
                        "poh must properly fit requested rectangle");

                // Finally, we can subdivide to get our requested rectangle:

                if (!bFreeRightAndBottomSpace(ppdev, poh, cxThis, cyThis, FALSE))
                    poh = NULL;         // Fail this call

                // Free our temporary rectangles, if there are any:

                pohFree(ppdev, pohTop);
                pohFree(ppdev, pohLeft);

                return(poh);
            }
        }
    }

    // There was no free rectangle that completely contains the requested
    // rectangle:

    return(NULL);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAnywhere
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohMakeRoomAnywhere(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // May have FLOH_ONLY_IF_ROOM set
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxBounds) || (cyThis > ppdev->heap.cyBounds))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohFree.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        DISPDBG((1, "> Making room for %li x %li allocation...", cxThis, cyThis));

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room, oldest allocations first:

        do {
            pohThis = ppdev->heap.ohDiscardable.pohPrev;  // Least-recently created
            if (pohThis == &ppdev->heap.ohDiscardable)
                return(NULL);

            ASSERTDD(pohThis != &ppdev->heap.ohDiscardable,
                     "Ran out of discardable entries -- Max not set correctly");
            ASSERTDD(pohThis->ohState == OH_DISCARDABLE,
                     "Non-discardable node in discardable list");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    if ((pohThis->cxReserved) && (floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)))
    {
        // We can't reserve this rectangle, or make it permanent, if it's
        // already been reserved.  So throw absolutely everything out and
        // search the free list.
        //
        // NOTE: This is extremely painful!  A better approach would be to
        //       keep separate 'cxMax' and 'cyMax' variables kept for free
        //       rectangles that are not reserved (cxMax and cyMax
        //       currently include reserved free rectangles).

        if (!bDiscardEverythingInRectangle(ppdev, 0, 0,
                                           ppdev->cxMemory, ppdev->cyMemory))
        {
            return(NULL);
        }

        pohThis = &ppdev->heap.ohFree;
        do {
            pohThis = pohThis->pohNext;

            if (pohThis == &ppdev->heap.ohFree)
                return(NULL);

        } while ((pohThis->cxReserved)  ||
                 (pohThis->cx < cxThis) ||
                 (pohThis->cy < cyThis));
    }

    if (!bFreeRightAndBottomSpace(ppdev, pohThis, cxThis, cyThis, FALSE))
        return(NULL);

    return(pohThis);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates a rectangle in off-screen memory.
*
* Types:
*
*   FLOH_RESERVE
*
*     Reserves an off-screen rectangle.  The space may still be used by
*     discardable bitmaps until the rectangle is committed via 'bOhCommit'.
*
*   FLOH_MAKE_PERMANENT
*
*     Allocates an off-screen rectangle that can never be booted
*     of the heap.   It's the caller's responsibility to manage
*     the rectangle, which includes what to do with the memory in
*     DrvAssertMode when the display is changed to full-screen
*     mode.
*
*   Default
*
*     Allocates a 'discardable' off-screen rectangle for a DFB that may
*     be  kicked out of off-screen if the space is needed.
*
* Options:
*
*   FLOH_ONLY_IF_ROOM
*
*     Allocates an off-screen rectangle only if there is free space
*     available -- i.e., no discardable rectangles will be moved out of
*     off-screen to make room.
*
*   Default
*
*     May move discardable rectangles out of off-screen to make room.
*
* Arguments:
*
*   pptl
*
*     If NULL, the rectangle will be allocated anywhere in un-used offscreen
*     memory.
*
*     If non-NULL, is a requested position for the rectangle.
*
*     NOTE: The heap will quickly fragment if arbitrary positions are
*           requested.  This position option works best if there is only
*           one specific rectangle ever requested, or if the allocations
*           are always wider than they are high.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
POINTL* pptl,           // Optional requested position of rectangle
LONG    cxThis,         // Width of rectangle to be allocated
LONG    cyThis,         // Height of rectangle to be allocated
FLOH    floh)           // Allocation flags
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;    // Point to root of list where we'll insert node
    ULONG   cxcy;
    OH*     pohNext;
    OH*     pohPrev;

    ASSERTDD((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT))
             != (FLOH_RESERVE | FLOH_MAKE_PERMANENT),
             "Illegal flags -- can't set both FLOH_RESERVE and FLOH_MAKE_PERMANENT");

    DISPDBG((1, "pohAllocate: size  %d %d", cxThis, cyThis));

    if (pptl == NULL)
    {
        pohThis = pohMakeRoomAnywhere(ppdev, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((1, "Can't allocate %li x %li with flags %li",
                        cxThis, cyThis, floh));
    }
    else
    {
        pohThis = pohMakeRoomAtLocation(ppdev, pptl, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((1, "Can't allocate %li x %li at %li, %li with flags %li",
                        cxThis, cyThis, pptl->x, pptl->y, floh));
    }

    if (pohThis == NULL)
        return(NULL);

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + ((pohThis->x + ppdev->ulYDstOrg) *
                                           ppdev->cjPelSize);

    // The caller is responsible for setting this field:

    pohThis->pdsurf = NULL;

    // Our 'reserve' logic expects the node to have 'free' status:

    ASSERTDD(pohThis->ohState == OH_FREE, "Node not free after making room");
    ASSERTDD(((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0) ||
             (pohThis->cxReserved == 0),
             "Can't reserve a rectangle that's already reserved");

    if (floh & FLOH_RESERVE)
    {
        // A non-zero value for 'cxReserved' means it's reserved:

        pohThis->cxReserved = pohThis->cx;
        pohThis->cyReserved = pohThis->cy;

        // Remove this node from its place in the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        // Now insert the node, in order, back into the free list:

        cxcy = pohThis->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext = pohThis;
        pohNext->pohPrev = pohThis;
        pohThis->pohPrev = pohPrev;
        pohThis->pohNext = pohNext;
    }
    else
    {
        // Remove this node from the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        if (floh & FLOH_MAKE_PERMANENT)
        {
            // Change status of node and insert into permanent list:

            pohThis->ohState = OH_PERMANENT;
            pohRoot = &ppdev->heap.ohPermanent;

            // Calculate the new maximum size rectangle available
            // for allocation:

            vCalculateMaximumNonPermanent(ppdev);
        }
        else
        {
            // Change status of node and insert into discardable list:

            pohThis->ohState = OH_DISCARDABLE;
            pohRoot = &ppdev->heap.ohDiscardable;
        }

        // Now insert the node at the head of the appropriate list:

        pohThis->pohNext = pohRoot->pohNext;
        pohThis->pohPrev = pohRoot;

        pohRoot->pohNext->pohPrev = pohThis;
        pohRoot->pohNext          = pohThis;
    }

    DISPDBG((1, "   Allocated (%li x %li) at (%li, %li) with flags %li",
                cxThis, cyThis, pohThis->x, pohThis->y, floh));

    return(pohThis);
}

/******************************Public*Routine******************************\
* BOOL bOhCommit
*
* If 'bCommit' is TRUE, converts a 'reserved' allocation to 'permanent,'
* moving from off-screen memory any discardable allocations that may have
* been using the space.
*
* If 'bCommit' is FALSE, converts a 'permanent' allocation to 'reserved,'
* allowing the space to be used by discardable allocations.
*
\**************************************************************************/

BOOL bOhCommit(
PDEV*   ppdev,
OH*     poh,
BOOL    bCommit)
{
    BOOL    bRet;
    LONG    cx;
    LONG    cy;
    ULONG   cxcy;
    OH*     pohRoot;
    OH*     pohNext;
    OH*     pohPrev;

    bRet = FALSE;       // Assume failure

    if (poh == NULL)
        return(bRet);

    if ((bCommit) && (poh->cxReserved))
    {
        if (bDiscardEverythingInRectangle(ppdev, poh->x, poh->y,
                                          poh->cxReserved, poh->cyReserved))
        {
            DISPDBG((1, "Commited %li x %li at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

            poh->ohState = OH_PERMANENT;

            // Remove this node from the free list:

            poh->pohPrev->pohNext = poh->pohNext;
            poh->pohNext->pohPrev = poh->pohPrev;

            // Now insert the node at the head of the permanent list:

            pohRoot = &ppdev->heap.ohPermanent;

            poh->pohNext = pohRoot->pohNext;
            poh->pohPrev = pohRoot;

            pohRoot->pohNext->pohPrev = poh;
            pohRoot->pohNext          = poh;

            bRet = TRUE;
        }
    }
    else if ((!bCommit) && (poh->ohState == OH_PERMANENT))
    {
        DISPDBG((1, "Decommited %li x %li at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

        poh->ohState    = OH_FREE;
        poh->cxReserved = poh->cx;
        poh->cyReserved = poh->cy;

        // Remove this node from the permanent list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;

        // Now insert the node, in order, into the free list:

        cxcy = poh->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = poh;
        pohNext->pohPrev    = poh;
        poh->pohPrev        = pohPrev;
        poh->pohNext        = pohNext;

        bRet = TRUE;
    }

    // Recalculate the biggest rectangle available for allocation:

    vCalculateMaximumNonPermanent(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, NULL, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    vPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((1, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                vGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    // Throw out any discardable bitmaps over the entire surface:

    return(bDiscardEverythingInRectangle(ppdev, 0, 0,
                                         ppdev->cxMemory, ppdev->cyMemory));
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    poh = pohAllocate(ppdev, NULL, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                if (EngAssociateSurface((HSURF) hbmDevice, 
                                        ppdev->hdevEng,
                                        ppdev->flHooks))
                {
                    pdsurf->bDirectDraw = FALSE;
                    pdsurf->dt          = DT_SCREEN;
                    pdsurf->poh         = poh;
                    pdsurf->sizl        = sizl;
                    pdsurf->ppdev       = ppdev;
                    poh->pdsurf         = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* HBITMAP DrvDeriveSurface
*
* This function is new to NT5, and allows the driver to accelerate any
* GDI drawing to a DirectDraw surface.
*
* Note the similarity of this function to DrvCreateDeviceBitmap.
*
\**************************************************************************/

HBITMAP DrvDeriveSurface(
DD_DIRECTDRAW_GLOBAL*   lpDirectDraw,
DD_SURFACE_LOCAL*       lpLocal)
{
    PDEV*               ppdev;
    DSURF*              pdsurf;
    OH*                 poh;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  lpSurface;
    SIZEL               sizl;

    ppdev = (PDEV*) lpDirectDraw->dhpdev;

    lpSurface = lpLocal->lpGbl;

    // The 'OH' structure is our own, MGA-specific data structure describing
    // where we originally allocated the memory in DdCreateSurface:

    poh = (OH*) lpSurface->dwReserved1;

    // Watch for the special case of a primary surface:

    if (poh == NULL)
    {
        poh = ppdev->pdsurfScreen->poh;
    }

    // GDI should never call us for a non-RGB surface, but let's assert just
    // to make sure they're doing their job properly.

    ASSERTDD(!(lpSurface->ddpfSurface.dwFlags & DDPF_FOURCC),
        "GDI called us with a non-RGB surface!");

    // The rest of our driver expects GDI calls to come in with the same
    // format as the primary surface.  So we'd better not wrap a device
    // bitmap around an RGB format that the rest of our driver doesn't
    // understand.

    if (lpSurface->ddpfSurface.dwRGBBitCount == (DWORD) ppdev->cjHwPel * 8)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            sizl.cx = lpSurface->wWidth;
            sizl.cy = lpSurface->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, 
                                              sizl, 
                                              ppdev->iBitmapFormat);
            if (hbmDevice != NULL)
            {
                if (EngAssociateSurface((HSURF) hbmDevice, 
                                        ppdev->hdevEng,
                                        ppdev->flHooks))
                {
                    pdsurf->bDirectDraw = TRUE;
                    pdsurf->dt          = DT_SCREEN;
                    pdsurf->poh         = poh;
                    pdsurf->sizl        = sizl;
                    pdsurf->ppdev       = ppdev;
                    poh->pdsurf         = pdsurf;
    
                    return(hbmDevice);
                }
    
                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a device-format-bitmap.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        // Note that we don't delete the actual 'OH' off-screen surface
        // structure here for DirectDraw surfaces.  This is because DirectDraw 
        // will still call our DdDestroySurface routine with the actual 
        // DirectDraw surface.

        if (!pdsurf->bDirectDraw)
        {
            pohFree(ppdev, pdsurf->poh);
        }
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        EngFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    POINTL      ptlScreen;

    DISPDBG((1, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ASSERTDD((ppdev->cxScreen <= ppdev->cxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext      = &ppdev->heap.ohFree;
    poh->pohPrev      = &ppdev->heap.ohFree;
    poh->ohState      = OH_FREE;
    poh->x            = 0;
    poh->y            = 0;
    poh->cx           = ppdev->cxMemory;
    poh->cy           = ppdev->cyMemory;
    poh->cxcy         = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft      = &ppdev->heap.ohFree;
    poh->pohUp        = &ppdev->heap.ohFree;
    poh->pohRight     = &ppdev->heap.ohFree;
    poh->pohDown      = &ppdev->heap.ohFree;
    poh->pvScan0      = ppdev->pjScreen + (ppdev->ulYDstOrg * ppdev->cjPelSize);

    // The second node is our free list sentinel:

    ppdev->heap.ohFree.pohNext         = poh;
    ppdev->heap.ohFree.pohPrev         = poh;
    ppdev->heap.ohFree.cxcy            = CXCY_SENTINEL;
    ppdev->heap.ohFree.cx              = 0x7fffffff;
    ppdev->heap.ohFree.cy              = 0x7fffffff;
    ppdev->heap.ohFree.ohState         = OH_FREE;

    // Initialize the discardable list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.
    // This node is also used for the screen-surface, for its offset:

    ppdev->heap.ohDiscardable.pohNext = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.pohPrev = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.ohState = OH_DISCARDABLE;

    // Initialize the permanent list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.

    ppdev->heap.ohPermanent.pohNext = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.pohPrev = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.ohState = OH_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    ptlScreen.x = 0;
    ptlScreen.y = 0;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocate(ppdev, &ptlScreen, ppdev->cxScreen, ppdev->cyScreen,
                      FLOH_MAKE_PERMANENT);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0) &&
             (poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen),
             "Screen allocation messed up");

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    // We do NOT want to hook any of the drawing functions.  Once we
    // send this surface into the engine, we don't want the driver to
    // get called with it again.  Otherwise we could get into a situation
    // where both the source and dest SURFOBJs for a blt were marked as DIBs.

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* Contains the DrvFillPath routine, which is used for drawing polygons.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        rop4;           // Hardware mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;
    RECTL*       prclClip;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    RECTFX       rcfxBounds;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;

    pfnFill = ppdev->pfnFillSolid;
    iSolidColor = 0;                            // Assume we won't need a pattern

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (iSolidColor == -1)
        {
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = rbc.prb->pfnFillPat;
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    {
        prclClip = NULL;
        if (jClipping == DC_RECT)
        {
            prclClip = &ClipRect;

            // Our FastFill routine does cross products and intersection
            // calculations assuming it can use 32 bit math and not
            // overflow.  As such, we have to ensure that the bounds of
            // the polygon fit in a 15 bit space, including the 4 bit fix
            // point fraction.  Note that we don't have to do this check
            // for trivial clipping, because we'll assume the screen
            // dimensions are 2048 x 2048 or smaller:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            if (((rcfxBounds.xRight - rcfxBounds.xLeft) > 0x7fff) ||
                ((rcfxBounds.yBottom - rcfxBounds.yTop) > 0x7fff))
                goto SkipFastFill;
        }

        if (iSolidColor == (ULONG) -1)
        {
            // Fastfill handles patterns only when running at 8bpp,
            // because hardware bugs make it difficult to write
            // efficient trapezoid routines at 16bpp and higher:

            if (ppdev->iBitmapFormat != BMF_8BPP)
                goto SkipFastFill;

            // Fastfill doesn't handle non-patcopy rops at 8bpp because
            // of a hardware bug:

            if (mix != 0x0d0d)
                goto SkipFastFill;
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, rop4, iSolidColor,
                       rbc.prb, pptlBrush, prclClip))
        {
            return(TRUE);
        }
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, rop4,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\escape.c ===
/******************************Module*Header*******************************\
* Module Name: escape.c
*
* Escape handler for MCD drivers and other escapes.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

//****************************************************************************
// ULONG DrvEscape(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut, VOID *pvOut)
//
// Driver escape entry point.  This function should return TRUE for any
// supported escapes in response to QUERYESCSUPPORT, and FALSE for any
// others.  All supported escapes are called from this routine.
//****************************************************************************

BOOL MCDrvGetEntryPoints(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);

ULONG DrvEscape(SURFOBJ *pso, ULONG iEsc,
                ULONG cjIn, VOID *pvIn,
                ULONG cjOut, VOID *pvOut)
{
    ULONG retVal;
    PDEV *ppdev;

    if (iEsc == MCDFUNCS) {

	ppdev = (PDEV *)pso->dhpdev;

        if (!ppdev->hMCD) {
            WCHAR uDllName[50];
            UCHAR dllName[50];
            ULONG nameSize;

            EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
                                   MCDENGDLLNAME, sizeof(MCDENGDLLNAME));

            if (ppdev->hMCD = EngLoadImage(uDllName)) {
                MCDENGINITFUNC pMCDEngInit =  EngFindImageProcAddress(ppdev->hMCD,
                                                 (LPSTR)MCDENGINITFUNCNAME);

                if (pMCDEngInit) {
                    (*pMCDEngInit)(pso, MCDrvGetEntryPoints);
                    ppdev->pMCDFilterFunc = EngFindImageProcAddress(ppdev->hMCD,
                                                (LPSTR)MCDENGESCFILTERNAME);
                }
            }
        }

        if (ppdev->pMCDFilterFunc) {
            if ((*ppdev->pMCDFilterFunc)(pso, iEsc, cjIn, pvIn,
                                         cjOut, pvOut, &retVal))
                return retVal;
        }
    }

    return (ULONG)FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast convex rectangles.
*
* Copyright (c) 1993-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      dN;               // Signed delta-y in fixed point form (also known
                            //   as the DDA error adjustment, and used to be
                            //   called 'lErrorDown')
LONG      dM;               // Signed delta-x in fixed point form
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
LONG      bNew;             // Set to TRUE when a new DDA must be started
                            //   for the edge.
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine,
                            //   or trapezoid clip routine
FNTRAPEZOID*    pfnTrapClip;// Pointer to appropriate trapezoid drawing routine
                            //   if doing clipping
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
POINTL          ptlBrush;   // Brush alignment
LONG            yClipTop;   // Top of clip rectangle
LONG            yClipBottom;// Bottom of clip rectangle

// MGA specific stuff below here:

ULONG           ulMgaSgn;   // Current sign register, MGA specific
ULONG           ulLinear;   // Linear offset to brush in off-screen memory
} TRAPEZOIDDATA;                    /* td, ptd */



/******************************Public*Routine******************************\
* VOID vClipTrapezoid
*
* Clips a trapezoid.
*
* NOTE: This routine assumes that the polygon's dimensions are small
*       enough that its QUOTIENT_REMAINDER calculations won't overflow.
*       This means that large polygons must never make it here.
*
\**************************************************************************/

VOID vClipTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapTop,
LONG            cyTrapezoid)
{
    LONG    yTrapBottom;
    LONG    dN;
    LONG    lNum;
    LONG    xDelta;
    LONG    lError;

    yTrapBottom = yTrapTop + cyTrapezoid;

    if (yTrapTop < ptd->yClipTop)
    {
        if ((ptd->aed[LEFT].bNew) &&
            (yTrapBottom + ptd->aed[LEFT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[LEFT].dN;
            lNum = ptd->aed[LEFT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[LEFT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[LEFT].x     += xDelta;
            ptd->aed[LEFT].lError = lError - dN;
        }

        if ((ptd->aed[RIGHT].bNew) &&
            (yTrapBottom + ptd->aed[RIGHT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[RIGHT].dN;
            lNum = ptd->aed[RIGHT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[RIGHT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[RIGHT].x     += xDelta;
            ptd->aed[RIGHT].lError = lError - dN;
        }
    }

    // If this trapezoid vertically intersects our clip rectangle, draw it:

    if ((yTrapBottom > ptd->yClipTop) &&
        (yTrapTop    < ptd->yClipBottom))
    {
        if (yTrapTop <= ptd->yClipTop)
        {
            yTrapTop = ptd->yClipTop;

            // Have to let trapezoid drawer know that it has to load
            // its DDAs for very first trapezoid drawn:

            ptd->aed[RIGHT].bNew = TRUE;
            ptd->aed[LEFT].bNew  = TRUE;
        }

        if (yTrapBottom >= ptd->yClipBottom)
        {
            yTrapBottom = ptd->yClipBottom;
        }

        ptd->pfnTrapClip(ptd, yTrapTop, yTrapBottom - yTrapTop);
    }
}


/******************************Public*Routine******************************\
* VOID vHardwareTrapezoid
*
* Uses the MGA's hardware trapezoid capability to draw solid or two-colour
* pattern trapezoids.
*
\**************************************************************************/

VOID vHardwareTrapezoid(
    TRAPEZOIDDATA*  ptd,
    LONG            yTrapezoid,
    LONG            cyTrapezoid)
{
    PDEV*   ppdev;
    LONG    dM;
    LONG    lError;
    BYTE*   pjBase;

    ppdev   = ptd->ppdev;
    pjBase = ppdev->pjBase;

    if (ptd->aed[LEFT].bNew)
    {
        dM = ptd->aed[LEFT].dM;
        if (dM >= 0)
        {
            ptd->ulMgaSgn &= ~sdxl_SUB;
            lError = -dM - ptd->aed[LEFT].lError - 1;
            dM = -dM;
        }
        else
        {
            ptd->ulMgaSgn |= sdxl_SUB;
            lError = dM + ptd->aed[LEFT].dN + ptd->aed[LEFT].lError;
        }

        CHECK_FIFO_SPACE(pjBase, 6);

        CP_WRITE(pjBase, DWG_AR2,     dM);
        CP_WRITE(pjBase, DWG_AR1,     lError);
        CP_WRITE(pjBase, DWG_AR0,     ptd->aed[LEFT].dN);
        CP_WRITE(pjBase, DWG_FXLEFT,  ptd->aed[LEFT].x + ppdev->xOffset);
    }

    if (ptd->aed[RIGHT].bNew)
    {
        dM = ptd->aed[RIGHT].dM;
        if (dM >= 0)
        {
            ptd->ulMgaSgn &= ~sdxr_DEC;
            lError = -dM - ptd->aed[RIGHT].lError - 1;
            dM = -dM;
        }
        else
        {
            ptd->ulMgaSgn |= sdxr_DEC;
            lError = dM + ptd->aed[RIGHT].dN + ptd->aed[RIGHT].lError;
        }

        CHECK_FIFO_SPACE(pjBase, 6);

        CP_WRITE(pjBase, DWG_AR5,     dM);
        CP_WRITE(pjBase, DWG_AR4,     lError);
        CP_WRITE(pjBase, DWG_AR6,     ptd->aed[RIGHT].dN);
        CP_WRITE(pjBase, DWG_FXRIGHT, ptd->aed[RIGHT].x + ppdev->xOffset);
    }

    CP_WRITE(pjBase, DWG_SGN, ptd->ulMgaSgn);
    CP_START(pjBase, DWG_LEN, cyTrapezoid);
}

/******************************Public*Routine******************************\
* VOID vMilSoftwareTrapezoid
*
* Draws a trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMilSoftwareTrapezoid(
    TRAPEZOIDDATA*  ptd,
    LONG            yTrapezoid,
    LONG            cyTrapezoid)
{
    PDEV*   ppdev;
    LONG    xOffset;
    LONG    xBrush;
    ULONG   ulOffset;
    ULONG   ulLinear;
    ULONG   ulScan;
    CHAR    cFifo;
    LONG    lLeftError;
    LONG    xLeft;
    LONG    lRightError;
    LONG    xRight;
    ULONG   ulAr0Adj;
    BYTE*   pjBase;

    ppdev    = ptd->ppdev;
    pjBase  = ppdev->pjBase;

    xBrush   = ptd->ptlBrush.x;

    ulOffset = ((yTrapezoid - ptd->ptlBrush.y) & 7) << PATTERN_PITCH_SHIFT;
    ulLinear = ptd->ulLinear;

    // For cjPelSize = 1, 2, 3, or 4,
    //      ulAr0Adj = 2, 4, 0, or 6.
    if (ppdev->cjPelSize == 3)
    {
        ulAr0Adj = 0;
    }
    else
    {
        ulAr0Adj = (ppdev->cjPelSize + 2) & 0xfffffffe;
    }

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle.

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset - 1;   // Inclusive of edge
        if (xLeft <= xRight)
        {
            CHECK_FIFO_SPACE(pjBase, 4);

            ulScan = ulLinear + ulOffset + ((xLeft - xBrush) & 7);
            CP_WRITE(pjBase, DWG_AR3, ulScan);

            if (ulAr0Adj)
            {
                CP_WRITE(pjBase, DWG_AR0, ((ulScan & 0xfffffff8) |
                                       ((ulScan + ulAr0Adj) & 7)));
            }
            else
            {
                CP_WRITE(pjBase, DWG_AR0, (ulScan + 7));
            }
            CP_WRITE(pjBase, DWG_FXBNDRY,
                                    (xRight << bfxright_SHIFT) |
                                    (xLeft & bfxleft_MASK));

            CP_START(pjBase, DWG_YDSTLEN, (yTrapezoid << yval_SHIFT) |
                                             (cyTrapezoid & ylength_MASK));
        }
    }
    else
    {
        cFifo       = 0;
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset - 1;  // Inclusive of edge

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft <= xRight)
            {
                // We get a little tricky here and try to amortize the cost of
                // the read for checking the FIFO count on the MGA.  Doing
                // so got us a 25% win on large triangles on a P90.

                cFifo -= 4;
                if (cFifo < 0)
                {
                    do
                    {
                        cFifo = GET_FIFO_SPACE(pjBase) - 4;
                    } while (cFifo < 0);
                }

                ulScan = ulLinear + ulOffset + ((xLeft - xBrush) & 7);
                CP_WRITE(pjBase, DWG_AR3,  ulScan);
                if (ulAr0Adj)
                {
                    CP_WRITE(pjBase, DWG_AR0, ((ulScan & 0xfffffff8) |
                                           ((ulScan + ulAr0Adj) & 7)));
                }
                else
                {
                    CP_WRITE(pjBase, DWG_AR0, (ulScan + 7));
                }
                CP_WRITE(pjBase, DWG_FXBNDRY, (xRight << bfxright_SHIFT) |
                                           (xLeft & bfxleft_MASK));

                CP_START(pjBase, DWG_YDSTLEN, (yTrapezoid << yval_SHIFT) |
                                                 (1 & ylength_MASK));
            }

            ulOffset = (ulOffset + (1 << PATTERN_PITCH_SHIFT)) &
                                            (7 << PATTERN_PITCH_SHIFT);
            yTrapezoid++;

            // Advance the right wall.
            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall.
            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset + 1;
    }
}

/******************************Public*Routine******************************\
* VOID vMilTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vMilTrapezoidSetup(
    PDEV*           ppdev,
    ULONG           rop4,
    ULONG           iSolidColor,
    RBRUSH*         prb,
    POINTL*         pptlBrush,
    TRAPEZOIDDATA*  ptd,
    LONG            yStart,         // First scan for drawing
    RECTL*          prclClip)       // NULL if no clipping
{
    ULONG       ulHwMix;
    ULONG       ulDwg;
    LONG        xOffset;
    LONG        yOffset;
    BRUSHENTRY* pbe;
    BYTE*       pjBase;

    pjBase      = ppdev->pjBase;
    ptd->ppdev   = ppdev;
    ptd->ulMgaSgn = 0;

    xOffset      = ppdev->xOffset;
    yOffset      = ppdev->yOffset;

    if ((prclClip != NULL) && (prclClip->top > yStart))
        yStart = prclClip->top;

    if (iSolidColor != -1)
    {
        // Solid fill.
        ptd->pfnTrap = vHardwareTrapezoid;

        CHECK_FIFO_SPACE(pjBase, 3);

        if (rop4 == 0xf0f0)
        {
            CP_WRITE(pjBase, DWG_DWGCTL, (opcode_TRAP + atype_RPL +
                                       solid_SOLID + bop_SRCCOPY +
                                       transc_BG_OPAQUE));
        }
        else
        {
            ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);
            CP_WRITE(pjBase, DWG_DWGCTL, (opcode_TRAP + atype_RSTR +
                                       solid_SOLID + (ulHwMix << 16) +
                                       transc_BG_OPAQUE));
        }

        CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, iSolidColor));
        CP_WRITE(pjBase, DWG_YDST, yStart + yOffset);

        ppdev->HopeFlags = PATTERN_CACHE;
    }
    else
    {
        // Pattern fill.
        if (prb->fl & RBRUSH_2COLOR)
        {
            // Monochrome brush.
            ptd->pfnTrap = vHardwareTrapezoid;

            if ((rop4 & 0xff) == 0xf0)
            {
                ulDwg = opcode_TRAP + atype_RPL + bop_SRCCOPY;
            }
            else
            {
                ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);
                ulDwg = opcode_TRAP + atype_RSTR + (ulHwMix << 16);
            }

            if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                // Normal opaque mode.
                ulDwg |= transc_BG_OPAQUE;
            }
            else
            {
                // GDI guarantees us that if the foreground and background
                // ROPs are different, the background rop is LEAVEALONE.
                ulDwg |= transc_BG_TRANSP;
            }

            CHECK_FIFO_SPACE(pjBase, 9);
            CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);
            CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, prb->ulColor[1]));
            CP_WRITE(pjBase, DWG_BCOL, COLOR_REPLICATE(ppdev, prb->ulColor[0]));
            CP_WRITE(pjBase, DWG_SRC0, prb->aulPattern[0]);
            CP_WRITE(pjBase, DWG_SRC1, prb->aulPattern[1]);
            CP_WRITE(pjBase, DWG_SRC2, prb->aulPattern[2]);
            CP_WRITE(pjBase, DWG_SRC3, prb->aulPattern[3]);

            CP_WRITE(pjBase, DWG_YDST, yStart + yOffset);
            CP_WRITE(pjBase, DWG_SHIFT,
                ((-(pptlBrush->y + ppdev->yOffset) & 7) << 4) |
                 (-(pptlBrush->x + ppdev->xOffset) & 7));
        }
        else
        {
            // Color brush.
            // We have to ensure that no other brush took our spot in
            // off-screen memory.
            pbe = prb->apbe[IBOARD(ppdev)];
            if (pbe->prbVerify != prb)
            {
                // Download the brush into the cache.
                if (ppdev->cjPelSize != 3)
                {
                    vMilPatRealize(ppdev, prb);
                }
                else
                {
                    vMilPatRealize24bpp(ppdev, prb);
                }
                pbe = prb->apbe[IBOARD(ppdev)];
            }

            ptd->pfnTrap  = vMilSoftwareTrapezoid;
            ptd->ulLinear = pbe->ulLinear;
            ptd->ptlBrush = *pptlBrush;

            CHECK_FIFO_SPACE(pjBase, 2);

            if (rop4 == 0xf0f0)         // PATCOPY
            {
                CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL +
                                           sgnzero_ZERO + shftzero_ZERO +
                                           bop_SRCCOPY + bltmod_BFCOL +
                                           pattern_ON + transc_BG_OPAQUE));
            }
            else
            {
                ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);
                CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR +
                                           sgnzero_ZERO + shftzero_ZERO +
                                           (ulHwMix << 16) +
                                           bltmod_BFCOL + pattern_ON +
                                           transc_BG_OPAQUE));
            }
            CP_WRITE(pjBase, DWG_AR5, PATTERN_PITCH);
        }

        ppdev->HopeFlags = 0;
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_CXLEFT,  prclClip->left  + xOffset);
        CP_WRITE(pjBase, DWG_CXRIGHT, prclClip->right + xOffset - 1);
    }
}

/******************************Public*Routine******************************\
* VOID vMgaSoftwareTrapezoid
*
* Draws a trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMgaSoftwareTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*   ppdev;
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    xBrush;
    ULONG   ulOffset;
    ULONG   ulLinear;
    ULONG   ulScan;
    CHAR    cFifo;
    LONG    lLeftError;
    LONG    xLeft;
    LONG    lRightError;
    LONG    xRight;

    ppdev    = ptd->ppdev;
    pjBase   = ppdev->pjBase;
    xBrush   = ptd->ptlBrush.x;

    ulOffset = ((yTrapezoid - ptd->ptlBrush.y) & 7) << 5;
    ulLinear = ptd->ulLinear;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset - 1;   // Inclusive of edge
        if (xLeft <= xRight)
        {
            CHECK_FIFO_SPACE(pjBase, 6);

            CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);   // xOffset already added in
            CP_WRITE(pjBase, DWG_FXRIGHT, xRight);

            ulScan = ulLinear + ulOffset;
            CP_WRITE(pjBase, DWG_AR3,  ulScan + ((xLeft - xBrush) & 7));
            CP_WRITE(pjBase, DWG_AR0,  ulScan + 15);
            CP_WRITE(pjBase, DWG_LEN,  cyTrapezoid);
            CP_START(pjBase, DWG_YDST, yTrapezoid);
        }
    }
    else
    {
        cFifo       = 0;
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset - 1;  // Inclusive of edge

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft <= xRight)
            {
                // We get a little tricky here and try to amortize the cost of
                // the read for checking the FIFO count on the MGA.  Doing
                // so got us a 25% win on large triangles on a P90:

                cFifo -= 6;
                if (cFifo < 0)
                {
                    do {
                        cFifo = GET_FIFO_SPACE(pjBase) - 6;
                    } while (cFifo < 0);
                }

                CP_WRITE(pjBase, DWG_FXLEFT,  xLeft);
                CP_WRITE(pjBase, DWG_FXRIGHT, xRight);

                ulScan = ulLinear + ulOffset;
                CP_WRITE(pjBase, DWG_AR0,  ulScan + 15);
                CP_WRITE(pjBase, DWG_AR3,  ulScan + ((xLeft - xBrush) & 7));
                CP_WRITE(pjBase, DWG_LEN,  1);
                CP_START(pjBase, DWG_YDST, yTrapezoid);
            }

            ulOffset = (ulOffset + (1 << 5)) & (7 << 5);
            yTrapezoid++;

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset + 1;
    }
}

/******************************Public*Routine******************************\
* VOID vMgaTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vMgaTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
LONG            yStart,         // First scan for drawing
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjBase;
    ULONG       ulHwMix;
    ULONG       ulDwg;
    BRUSHENTRY* pbe;

    ptd->ppdev    = ppdev;
    ptd->ulMgaSgn = 0;
    pjBase        = ppdev->pjBase;

    if ((prclClip != NULL) && (prclClip->top > yStart))
        yStart = prclClip->top;

    if (iSolidColor != -1)
    {
        ptd->pfnTrap = vHardwareTrapezoid;

        CHECK_FIFO_SPACE(pjBase, 7);

        if (rop4 == 0xf0f0)
        {
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP + transc_BG_OPAQUE +
                                            blockm_ON + atype_RPL + bop_SRCCOPY);
        }
        else
        {
            ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

            CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP + transc_BG_OPAQUE +
                                            blockm_OFF + atype_RSTR +
                                            (ulHwMix << 16));
        }

        CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, iSolidColor));
        CP_WRITE(pjBase, DWG_YDST, yStart + ppdev->yOffset);

        if (!(GET_CACHE_FLAGS(ppdev, PATTERN_CACHE)))
        {
            CP_WRITE(pjBase, DWG_SRC0, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC1, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC2, 0xFFFFFFFF);
            CP_WRITE(pjBase, DWG_SRC3, 0xFFFFFFFF);
        }

        ppdev->HopeFlags = PATTERN_CACHE;
    }
    else
    {
        if (prb->fl & RBRUSH_2COLOR)
        {
            ptd->pfnTrap = vHardwareTrapezoid;

            if ((rop4 & 0xff) == 0xf0)
            {
                ulDwg = opcode_TRAP + blockm_OFF + atype_RPL + bop_SRCCOPY;
            }
            else
            {
                ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

                ulDwg = opcode_TRAP + blockm_OFF + atype_RSTR + (ulHwMix << 16);
            }

            if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                // Normal opaque mode:

                ulDwg |= transc_BG_OPAQUE;
            }
            else
            {
                // GDI guarantees us that if the foreground and background
                // ROPs are different, the background rop is LEAVEALONE:

                ulDwg |= transc_BG_TRANSP;
            }

            CHECK_FIFO_SPACE(pjBase, 9);
            CP_WRITE(pjBase, DWG_DWGCTL, ulDwg);
            CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, prb->ulColor[1]));
            CP_WRITE(pjBase, DWG_BCOL, COLOR_REPLICATE(ppdev, prb->ulColor[0]));
            CP_WRITE(pjBase, DWG_SRC0, prb->aulPattern[0]);
            CP_WRITE(pjBase, DWG_SRC1, prb->aulPattern[1]);
            CP_WRITE(pjBase, DWG_SRC2, prb->aulPattern[2]);
            CP_WRITE(pjBase, DWG_SRC3, prb->aulPattern[3]);
            CP_WRITE(pjBase, DWG_YDST, yStart + ppdev->yOffset);
            CP_WRITE(pjBase, DWG_SHIFT,
                ((-(pptlBrush->y + ppdev->yOffset) & 7) << 4) |
                 (-(pptlBrush->x + ppdev->xOffset) & 7));

            ppdev->HopeFlags = 0;
        }
        else
        {
            // We have to ensure that no other brush took our spot in off-screen
            // memory:

            ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP,
                     "Can only do 8bpp patterned fastfills");

            if (prb->apbe[IBOARD(ppdev)]->prbVerify != prb)
            {
                vMgaPatRealize8bpp(ppdev, prb);
            }

            pjBase  = ppdev->pjBase;
            pbe     = prb->apbe[IBOARD(ppdev)];

            ptd->pfnTrap  = vMgaSoftwareTrapezoid;
            ptd->ulLinear = pbe->ulLinear;
            ptd->ptlBrush = *pptlBrush;

            CHECK_FIFO_SPACE(pjBase, 4);

            if (rop4 == 0xf0f0)         // PATCOPY
            {
                CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RPL + blockm_OFF +
                                              trans_0 + bltmod_BFCOL + pattern_ON +
                                              transc_BG_OPAQUE + bop_SRCCOPY));
            }
            else
            {
                RIP("Shouldn't allow ROPs for now, because of h/w bug!");

                ulHwMix = (rop4 & 0x03) + ((rop4 & 0x30) >> 2);

                CP_WRITE(pjBase, DWG_DWGCTL, (opcode_BITBLT + atype_RSTR + blockm_OFF +
                                              trans_0 + bltmod_BFCOL + pattern_ON +
                                              transc_BG_OPAQUE + (ulHwMix << 16)));
            }

            if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
            {
                CP_WRITE(pjBase, DWG_SGN, 0);
            }

            ppdev->HopeFlags = SIGN_CACHE;

            CP_WRITE(pjBase, DWG_SHIFT, 0);
            CP_WRITE(pjBase, DWG_AR5, 32);
        }
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_CXLEFT,  ppdev->xOffset + prclClip->left);
        CP_WRITE(pjBase, DWG_CXRIGHT, ppdev->xOffset + prclClip->right - 1);
    }
}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or Win95.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush,
RECTL*      prclClip)       // NULL if no clipping
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    LONG      lCross;       // Cross-product result
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;
    BYTE*     pjBase;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is convex

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // Watch for close figure points, because we have the later restriction
    // that we won't allow coincident vertices:

    if ((pptfxLast->x == pptfxFirst->x) && (pptfxLast->y == pptfxFirst->y))
    {
        pptfxLast--;
        cEdges--;
    }

    if (cEdges <= 2)
        goto ReturnTrue;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        goto ReturnFalse;
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        goto ReturnFalse;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    pptfxScan  = pptfxFirst;
    cScanEdges = cEdges - 2;

    // NOTE: For a bit of speed and simplicity, we will assume that
    //       our cross product calculations will not overflow.  A
    //       consequence of this is that the caller MUST ensure that
    //       the bounds of the polygon are small enough that there
    //       will be no overflow.

    lCross = (((pptfxScan + 1)->x - (pptfxScan + 0)->x)
            * ((pptfxScan + 2)->y - (pptfxScan + 1)->y)
            - ((pptfxScan + 1)->y - (pptfxScan + 0)->y)
            * ((pptfxScan + 2)->x - (pptfxScan + 1)->x));

    if (lCross == 0)
    {
        // We don't allow any colinear points into FastFill.  We do this
        // here because we would need a non-zero cross product to determine
        // which direction the rest of the edges should go.  We do this
        // later so that coincident vertices will never mess us up by
        // hiding a cross product sign change.

        goto ReturnFalse;
    }
    else if (lCross > 0)
    {
        // Make sure all cross products are positive:

        pptfxScan++;
        while (--cScanEdges != 0)
        {
            if (((pptfxScan + 1)->x - (pptfxScan + 0)->x)
              * ((pptfxScan + 2)->y - (pptfxScan + 1)->y)
              - ((pptfxScan + 1)->y - (pptfxScan + 0)->y)
              * ((pptfxScan + 2)->x - (pptfxScan + 1)->x) <= 0)
            {
                goto ReturnFalse;
            }
            pptfxScan++;
        }

        // Check the angles formed by the closefigure edge:

        if (((pptfxScan + 1)->x - (pptfxScan + 0)->x)
          * ((pptfxFirst   )->y - (pptfxScan + 1)->y)
          - ((pptfxScan + 1)->y - (pptfxScan + 0)->y)
          * ((pptfxFirst   )->x - (pptfxScan + 1)->x) <= 0)
        {
            goto ReturnFalse;
        }

        if (((pptfxFirst    )->x - (pptfxScan + 1)->x)
          * ((pptfxFirst + 1)->y - (pptfxFirst   )->y)
          - ((pptfxFirst    )->y - (pptfxScan + 1)->y)
          * ((pptfxFirst + 1)->x - (pptfxFirst   )->x) <= 0)
        {
            goto ReturnFalse;
        }

        // The figure has its points ordered in a clockwise direction:

        td.aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
        td.aed[RIGHT].dptfx = sizeof(POINTFIX);
    }
    else
    {
        // Make sure all cross products are negative:

        pptfxScan++;
        while (--cScanEdges != 0)
        {
            if (((pptfxScan + 1)->x - (pptfxScan + 0)->x)
              * ((pptfxScan + 2)->y - (pptfxScan + 1)->y)
              - ((pptfxScan + 1)->y - (pptfxScan + 0)->y)
              * ((pptfxScan + 2)->x - (pptfxScan + 1)->x) >= 0)
            {
                goto ReturnFalse;
            }
            pptfxScan++;
        }

        // Check the angles formed by the closefigure edge:

        if (((pptfxScan + 1)->x - (pptfxScan + 0)->x)
          * ((pptfxFirst   )->y - (pptfxScan + 1)->y)
          - ((pptfxScan + 1)->y - (pptfxScan + 0)->y)
          * ((pptfxFirst   )->x - (pptfxScan + 1)->x) >= 0)
        {
            goto ReturnFalse;
        }

        if (((pptfxFirst    )->x - (pptfxScan + 1)->x)
          * ((pptfxFirst + 1)->y - (pptfxFirst   )->y)
          - ((pptfxFirst    )->y - (pptfxScan + 1)->y)
          * ((pptfxFirst + 1)->x - (pptfxFirst   )->x) >= 0)
        {
            goto ReturnFalse;
        }

        // The figure has its points ordered in a counter-clockwise direction:

        td.aed[LEFT].dptfx  = sizeof(POINTFIX);
        td.aed[RIGHT].dptfx = -(LONG) sizeof(POINTFIX);
    }

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    if (ppdev->ulBoardId == MGA_STORM)
    {
        vMilTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                           yTrapezoid, prclClip);
    }
    else
    {
        vMgaTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                           yTrapezoid, prclClip);
    }

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped       = &td.aed[iEdge];
        ped->bNew = FALSE;
        if (ped->cy == 0)
        {
            // Our trapezoid drawing routine may want to be notified when
            // it will have to reset its DDA to start a new edge:

            ped->bNew = TRUE;

            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    goto ResetClippingAndReturnTrue;

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            ped->dM = dM;                   // Not used for software trapezoid

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->dN = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->dN;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->dN * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;

ResetClippingAndReturnTrue:

    if (prclClip != NULL)
    {
        pjBase = ppdev->pjBase;

        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_CXLEFT, 0);
        CP_WRITE(pjBase, DWG_CXRIGHT, ppdev->cxMemory - 1);
    }

ReturnTrue:

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

// The following is used to define the MGA memory map.

// MGA map

#define     SrcWin          0x0000
#define     IntReg          0x1c00
#define     DstWin          0x2000
#define     ExtDev          0x3c00

// Internal registers

#define     VgaReg          0x0000
#define     DwgReg          0x0000
#define     StartDwgReg     0x0100
#define     HstReg          0x0200

// External devices

#define     RamDac          0x0000
#define     Dubic           0x0080
#define     Viwic           0x0100
#define     ClkGen          0x0180
#define     ExpDev          0x0200

// TITAN registers

#define     DWGCTL          0x0000
#define     MACCESS         0x0004
#define     MCTLWTST        0x0008
#define     ZORG            0x000C
#define     DST0            0x0010
#define     DST1            0x0014
#define     ZMSK            0x0018
#define     PLNWT           0x001C
#define     BCOL            0x0020
#define     FCOL            0x0024
#define     SRCBLT          0x002C
#define     SRC0            0x0030
#define     SRC1            0x0034
#define     SRC2            0x0038
#define     SRC3            0x003C
#define     XYSTRT          0x0040
#define     XYEND           0x0044
#define     SHIFT           0x0050
#define     SGN             0x0058
#define     LEN             0x005C
#define     AR0             0x0060
#define     AR1             0x0064
#define     AR2             0x0068
#define     AR3             0x006C
#define     AR4             0x0070
#define     AR5             0x0074
#define     AR6             0x0078
#define     CXBNDRY         0x0080
#define     FXBNDRY         0x0084
#define     YDSTLEN         0x0088
#define     PITCH           0x008C
#define     YDST            0x0090
#define     YDSTORG         0x0094
#define     CYTOP           0x0098
#define     CYBOT           0x009C
#define     CXLEFT          0x00A0
#define     CXRIGHT         0x00A4
#define     FXLEFT          0x00A8
#define     FXRIGHT         0x00AC
#define     XDST            0x00B0
#define     DR0             0x00C0
#define     DR1             0x00C4
#define     DR2             0x00C8
#define     DR3             0x00CC
#define     DR4             0x00D0
#define     DR5             0x00D4
#define     DR6             0x00D8
#define     DR7             0x00DC
#define     DR8             0x00E0
#define     DR9             0x00E4
#define     DR10            0x00E8
#define     DR11            0x00EC
#define     DR12            0x00F0
#define     DR13            0x00F4
#define     DR14            0x00F8
#define     DR15            0x00FC

// VGA registers

#define     CRTC_INDEX      0x03D4
#define     CRTC_DATA       0x03D5
#define     CRTCEXT_INDEX   0x03DE
#define     CRTCEXT_DATA    0x03DF
#define     INSTS1          0x03DA

// Host registers

#define     SRCPAGE         0x0000
#define     DSTPAGE         0x0004
#define     BYTACCDATA      0x0008
#define     ADRGEN          0x000C
#define     FIFOSTATUS      0x0010
#define     STATUS          0x0014
#define     ICLEAR          0x0018
#define     IEN             0x001C
#define     RST             0x0040
#define     TEST            0x0044
#define     REV             0x0048
#define     CONFIG_REG      0x0050
#define     OPMODE          0x0054
#define     CRTC_CTRL       0x005C
#define     VCOUNT          0x0020

// Bt485

#define     BT485_PAL_OR_CURS_RAM_WRITE     0x0000
#define     BT485_COLOR_PAL_DATA            0x0004
#define     BT485_PIXEL_MASK                0x0008
#define     BT485_PAL_OR_CURS_RAM_READ      0x000C
#define     BT485_OVS_OR_CURS_COLOR_WRITE   0x0010
#define     BT485_OVS_OR_CURS_COLOR_DATA    0x0014
#define     BT485_COMMAND_0                 0x0018
#define     BT485_OVS_OR_CURS_COLOR_READ    0x001C
#define     BT485_COMMAND_1                 0x0020
#define     BT485_COMMAND_2                 0x0024
#define     BT485_COMMAND_3_OR_STATUS       0x0028
#define     BT485_CURS_RAM_ARRAY            0x002C
#define     BT485_CURS_X_LOW                0x0030
#define     BT485_CURS_X_HIGH               0x0034
#define     BT485_CURS_Y_LOW                0x0038
#define     BT485_CURS_Y_HIGH               0x003C

// Bt482
#define     BT482_PAL_OR_CURS_RAM_WRITE     0x0000
#define     BT482_COLOR_PAL_DATA            0x0004
#define     BT482_PIXEL_MASK                0x0008
#define     BT482_PAL_OR_CURS_RAM_READ      0x000C
#define     BT482_OVS_OR_CURS_COLOR_WRITE   0x0010
#define     BT482_OVS_OR_CURS_COLOR_DATA    0x0014
#define     BT482_COMMAND_A                 0x0018
#define     BT482_OVS_OR_CURS_COLOR_READ    0x001C

// ViewPoint

#define     VPOINT_PAL_ADDR_WRITE           0x0000
#define     VPOINT_PAL_COLOR                0x0004
#define     VPOINT_PIX_READ_MASK            0x0008
#define     VPOINT_PAL_ADDR_READ            0x000c
#define     VPOINT_RESERVED_4               0x0010
#define     VPOINT_RESERVED_5               0x0014
#define     VPOINT_INDEX                    0x0018
#define     VPOINT_DATA                     0x001c

// Dubic

#define     DUB_SEL         0x0080
#define     NDX_PTR         0x0081
#define     DUB_DATA        0x0082
#define     LASER           0x0083
#define     MOUSE0          0x0084
#define     MOUSE1          0x0085
#define     MOUSE2          0x0086
#define     MOUSE3          0x0087

// Index within NDX_PTR to access the following registers through DUB_DATA

#define     DUB_CTL     0x00
#define     KEY_COL     0x01
#define     KEY_MSK     0x02
#define     DBX_MIN     0x03
#define     DBX_MAX     0x04
#define     DBY_MIN     0x05
#define     DBY_MAX     0x06
#define     OVS_COL     0x07
#define     CUR_X       0x08
#define     CUR_Y       0x09
#define     DUB_CTL2    0x0A
#define     DUB_UnDef   0x0B
#define     CUR_COL0    0x0C
#define     CUR_COL1    0x0D
#define     CRC_CTL     0x0E
#define     CRC_DAT     0x0F


// **************************************************************************
// Titan registers:  fields definitions

// DWGCTRL - Drawing Control Register

#define     opcode_LINE_OPEN        0x00000000
#define     opcode_AUTOLINE_OPEN    0x00000001
#define     opcode_LINE_CLOSE       0x00000002
#define     opcode_AUTOLINE_CLOSE   0x00000003
#define     opcode_AUTO             0x00000001
#define     opcode_TRAP             0x00000004
#define     opcode_TEXTURE_TRAP     0x00000005
#define     opcode_RESERVED_1       0x00000006
#define     opcode_RESERVED_2       0x00000007
#define     opcode_BITBLT           0x00000008
#define     opcode_ILOAD            0x00000009
#define     opcode_IDUMP            0x0000000a
#define     opcode_RESERVED_3       0x0000000b
#define     opcode_FBITBLT          0x0000000c
#define     opcode_ILOAD_SCALE      0x0000000d
#define     opcode_RESERVED_4       0x0000000e
#define     opcode_ILOAD_FILTER     0x0000000f

#define     atype_RPL               0x00000000
#define     atype_RSTR              0x00000010
#define     atype_ANTI              0x00000020
#define     atype_ZI                0x00000030
#define     atype_I                 0x00000070

#define     blockm_ON               0x00000040
#define     blockm_OFF              0x00000000

#define     linear_XY_BITBLT        0x00000000
#define     linear_LINEAR_BITBLT    0x00000080

#define     zmode_NOZCMP            0x00000000
#define     zmode_RESERVED_1        0x00000100
#define     zmode_ZE                0x00000200
#define     zmode_ZNE               0x00000300
#define     zmode_ZLT               0x00000400
#define     zmode_ZLTE              0x00000500
#define     zmode_ZGT               0x00000600
#define     zmode_ZGTE              0x00000700

#define     solid_NO_SOLID          0x00000000
#define     solid_SOLID             0x00000800

#define     arzero_NO_ZERO          0x00000000
#define     arzero_ZERO             0x00001000

#define     sgnzero_NO_ZERO         0x00000000
#define     sgnzero_ZERO            0x00002000

#define     shftzero_NO_ZERO        0x00000000
#define     shftzero_ZERO           0x00004000

#define     bop_BLACK               0x00000000  // 0             0
#define     bop_BLACKNESS           0x00000000  // 0             0
#define     bop_NOTMERGEPEN         0x00010000  // DPon      ~(D | S)
#define     bop_MASKNOTPEN          0x00020000  // DPna       D & ~S
#define     bop_NOTCOPYPEN          0x00030000  // Pn        ~S
#define     bop_MASKPENNOT          0x00040000  // PDna      (~D) &  S
#define     bop_NOT                 0x00050000  // Dn        ~D
#define     bop_XORPEN              0x00060000  // DPx        D ^  S
#define     bop_NOTMASKPEN          0x00070000  // DPan      ~(D & S)
#define     bop_MASKPEN             0x00080000  // DPa         D &  S
#define     bop_NOTXORPEN           0x00090000  // DPxn       ~(D ^ S)
#define     bop_NOP                 0x000a0000  // D           D
#define     bop_MERGENOTPEN         0x000b0000  // DPno        D | ~S
#define     bop_COPYPEN             0x000c0000  // P           S
#define     bop_SRCCOPY             0x000c0000  // P           S
#define     bop_MERGEPENNOT         0x000d0000  // PDno      (~D)| S
#define     bop_MERGEPEN            0x000e0000  // DPo         D |  S
#define     bop_MASK                0x000f0000
#define     bop_WHITE               0x000f0000  // 1             1
#define     bop_WHITENESS           0x000f0000  // 1             1

#define     trans_0                 0x00000000
#define     trans_1                 0x00100000
#define     trans_2                 0x00200000
#define     trans_3                 0x00300000
#define     trans_4                 0x00400000
#define     trans_5                 0x00500000
#define     trans_6                 0x00600000
#define     trans_7                 0x00700000
#define     trans_8                 0x00800000
#define     trans_9                 0x00900000
#define     trans_10                0x00a00000
#define     trans_11                0x00b00000
#define     trans_12                0x00c00000
#define     trans_13                0x00d00000
#define     trans_14                0x00e00000
#define     trans_15                0x00f00000

#define     alphadit_FOREGROUND     0x00000000
#define     alphadit_RED            0x01000000

#define     bltmod_BMONO            0x00000000
#define     bltmod_BPLAN            0x02000000
#define     bltmod_BFCOL            0x04000000
#define     bltmod_BUCOL            0x06000000
#define     bltmod_BU32BGR          0x06000000
#define     bltmod_BMONOWF          0x08000000
#define     bltmod_BU32RGB          0x0e000000
#define     bltmod_BU24BGR          0x16000000
#define     bltmod_BU24RGB          0x1e000000
#define     bltmod_BUYUV            0x1c000000

#define     zdrwen_NO_DEPTH         0x00000000
#define     zdrwen_DEPTH            0x02000000

#define     zlte_LESS_THEN          0x00000000
#define     zlte_LESS_THEN_OR_EQUAL 0x04000000

#define     afor_DATA_ALU           0x00000000
#define     afor_FORE_COL           0x08000000

#define     hbgr_SRC_RGB            0x00000000
#define     hbgr_SRC_BGR            0x08000000
#define     hbgr_SRC_EG3            0x00000000
#define     hbgr_SRC_WINDOWS        0x08000000

#define     abac_OLD_DATA           0x00000000
#define     abac_BG_COLOR           0x10000000

#define     hcprs_SRC_32_BPP        0x00000000
#define     hcprs_SRC_24_BPP        0x10000000

#define     pattern_OFF             0x00000000
#define     pattern_ON              0x20000000

#define     transc_BIT                      30  // bit #30
#define     transc_BG_OPAQUE        0x00000000
#define     transc_BG_TRANSP        0x40000000

// MACCESS - Memory Access Register

#define     pwidth_PW8              0x00000000
#define     pwidth_PW16             0x00000001
#define     pwidth_PW32             0x00000002
#define     pwidth_PW24             0x00000003

#define     dither_DISABLE          0x40000000
#define     dither_555              0x80000000
#define     dither_565              0x00000000

#define     fbc_SBUF                0x00000000
#define     fbc_RESERVED            0x00000004
#define     fbc_DBUFA               0x00000008
#define     fbc_DBUFB               0x0000000c

// MCTLWTST - Memory Control Wait State Register

// DST0, DST1 - Destination in Register

// ZMASK - Z Mask Control Register

// PLNWT - Plane Write Mask

#define     plnwt_MASK_8BPP         0xffffffff
#define     plnwt_MASK_15BPP        0x7fff7fff
#define     plnwt_MASK_16BPP        0xffffffff
#define     plnwt_MASK_24BPP        0xffffffff
#define     plnwt_MASK_32BPP        0xffffffff
#define     plnwt_ALL               0xffffffff
#define     plnwt_FREE              0xff000000
#define     plnwt_RED               0x00ff0000
#define     plnwt_GREEN             0x0000ff00
#define     plnwt_BLUE              0x000000ff

// BCOL - Background Color

// FCOL - ForeGround Color

// SRCBLT - Source Register for Blit

// SRC0, SRC1, SRC2, SRC3 - Source Register

// XYSTART - X Y Start Address

// XYEND - X Y End Address

// SHIFT - Funnel Shifter Control Register

#define     funoff_MASK             0xffc0ffff
#define     funoff_RED_TO_FREE      0x00380000      //  -8
#define     funoff_GREEN_TO_FREE    0x00300000      // -16
#define     funoff_BLUE_TO_FREE     0x00280000      // -24
#define     funoff_FREE_TO_RED      0x00080000      //   8
#define     funoff_FREE_TO_GREEN    0x00100000      //  16
#define     funoff_FREE_TO_BLUE     0x00180000      //  24

#define     funoff_X_TO_FREE_STEP   0x00080000
#define     funoff_FREE_TO_X_STEP   0x00080000

// SGN - Sign Register

#define     sdydxl_MAJOR_Y          0x00000000
#define     sdydxl_MAJOR_X          0x00000001
#define     scanleft_LEFT           0x00000001
#define     scanleft_RIGHT          0x00000000
#define     sdxl_ADD                0x00000000
#define     sdxl_SUB                0x00000002
#define     sdy_ADD                 0x00000000
#define     sdy_SUB                 0x00000004
#define     sdxr_INC                0x00000000
#define     sdxr_DEC                0x00000020
#define     scanleft_LEFT_TO_RIGHT  0x00000000
#define     scanleft_RIGHT_TO_LEFT  0x00000001
#define     sdy_TOP_TO_BOTTOM       0x00000000
#define     sdy_BOTTOM_TO_TOP       0x00000004

#define     DRAWING_DIR_TBLR        sdy_TOP_TO_BOTTOM+scanleft_RIGHT  // 0x00
#define     DRAWING_DIR_TBRL        sdy_TOP_TO_BOTTOM+scanleft_LEFT   // 0x01
#define     DRAWING_DIR_BTLR        sdy_BOTTOM_TO_TOP+scanleft_RIGHT  // 0x04
#define     DRAWING_DIR_BTRL        sdy_BOTTOM_TO_TOP+scanleft_LEFT   // 0x05

// LEN - length register

// AR0

#define ARX_BIT_MASK    0x0001ffff

// AR1

// AR2

// AR3

// AR4

// AR5

// AR6

// CXBNDRY

#define     bcxleft_MASK            0x000007ff
#define     bcxleft_SHIFT                    0
#define     bcxright_MASK           0x07ff0000
#define     bcxright_SHIFT                  16

// FXBNDRY

#define     bfxleft_MASK            0x0000ffff
#define     bfxleft_SHIFT                    0
#define     bfxright_MASK           0xffff0000
#define     bfxright_SHIFT                  16

// YDSTLEN

#define     ylength_MASK            0x0000ffff
#define     ylength_SHIFT                    0
#define     yval_MASK               0xffff0000
#define     yval_SHIFT                      16

// PITCH - Memory Pitch

#define     iy_512                  0x00000200
#define     iy_640                  0x00000280
#define     iy_768                  0x00000300
#define     iy_800                  0x00000320
#define     iy_1024                 0x00000400
#define     iy_1152                 0x00000480
#define     iy_1280                 0x00000500
#define     iy_1536                 0x00000600
#define     iy_1600                 0x00000640
#define     ylin_LINEARIZE          0x00000000
#define     ylin_LINEARIZE_NOT      0x00008000
#define     iy_MASK                 0x00001fe0

// YDST - Y Address Register

// YDSTORG - memory origin register

// YTOP - Clipper Y Top Boundary

// YBOT - Clipper Y Bottom Boundary

// CXLEFT - Clipper X Minimum Boundary

// CXRIGHT - Clipper X Maximum Boundary

// FXLEFT - X Address Register (Left)

// FXRIGHT - X Address Register (Right)

// XDST - X Destination Address Register

// DR0

// DR1

// DR2

// DR3

// DR4

// DR5

// DR6

// DR7

// DR8

// DR9

// DR10

// DR11

// DR12

// DR13

// DR14

// DR15

// **************************************************************************
// Host registers:  fields definitions

// SRCPAGE - Source Page Register

// DSTPAGE - Destination Page Register

// BYTEACCDATA - Byte Accumulator Data

// ADRGEN - Address Generator Register

// FIFOSTATUS - Bus FIFO Status Register

#define     fifocount_MASK          0x0000007f
#define     bfull_MASK              0x00000100
#define     bempty_MASK             0x00000200
#define     byteaccaddr_MASK        0x007f0000
#define     addrgenstate_MASK       0x3f000000

// STATUS - Status Register

#define     bferrists_MASK          0x00000001
#define     dmatcists_MASK          0x00000002
#define     pickists_MASK           0x00000004
#define     vsyncsts_MASK           0x00000008
#define     byteflag_MASK           0x00000f00
#define     dwgengsts_MASK          0x00010000

// ICLEAR - Interrupt Clear Register

#define     bferriclr_OFF           0x00000000
#define     bferriclr_ON            0x00000001
#define     dmactciclr_OFF          0x00000000
#define     dmactciclr_ON           0x00000002
#define     pickiclr_OFF            0x00000000
#define     pickiclr_ON             0x00000004

// IEN - Interrupt Enable Register

#define     bferrien_OFF            0x00000000
#define     bferrien_ON             0x00000001
#define     dmactien_OFF            0x00000000
#define     dmactien_ON             0x00000002
#define     pickien_OFF             0x00000000
#define     pickien_ON              0x00000004
#define     vsyncien_OFF            0x00000000
#define     vsyncien_ON             0x00000008

// RST - Reset Register

#define     softreset               0x00000001

// TEST - Test Register

#define     vgatest                 0x00000001
#define     robitwren               0x00000100

// REV - Revision Register

// CONFIG_REG - Configuration Register

// OPMODE - Operating Mode Register

#define     OPMODE_OTHER_INFO       0xfffffff0
#define     pseudodma_OFF           0x00000000
#define     pseudodma_ON            0x00000001
#define     dmaact_OFF              0x00000000
#define     dmaact_ON               0x00000002
#define     dmamod_GENERAL_PURPOSE  0x00000000
#define     dmamod_BLIT_WRITE       0x00000004
#define     dmamod_VECTOR_WRITE     0x00000008
#define     dmamod_BLIT_READ        0x0000000c

// CRTC_CTRL - CRTC Control

// VCOUNT - VCOUNT Register

// COLOR PATTERN

#define     PATTERN_PITCH           32
#define     PATTERN_PITCH_SHIFT     5

// DMA

#define     DMAWINSIZE              7*1024 / 4      // 7k in DWORDS

// FIFO

#define     FIFOSIZE                32
#define     INTEL_PAGESIZE          4*1024          // 4k bytes per page
#define     INTEL_PAGESIZE_DW       4*1024/4        // 1k dwords per page

// Accelerator flags

#define     NO_CACHE            0
#define     SIGN_CACHE          1   // 1 is also the nb of registers affected
#define     ARX_CACHE           2
#define     PATTERN_CACHE       4   // 4 is also the nb of registers affected

#define     GET_CACHE_FLAGS(ppdev,fl)  (ppdev->HopeFlags & (fl))

// MGA Rop definitions

#define     MGA_BLACKNESS           0x0000      // 0             0
#define     MGA_NOTMERGEPEN         0x0001      // DPon      ~(D | S)
#define     MGA_MASKNOTPEN          0x0002      // DPna       D & ~S
#define     MGA_NOTCOPYPEN          0x0003      // Pn        ~S
#define     MGA_MASKPENNOT          0x0004      // PDna      (~D) &  S
#define     MGA_NOT                 0x0005      // Dn        ~D
#define     MGA_XORPEN              0x0006      // DPx        D ^  S
#define     MGA_NOTMASKPEN          0x0007      // DPan      ~(D & S)
#define     MGA_MASKPEN             0x0008      // DPa         D &  S
#define     MGA_NOTXORPEN           0x0009      // DPxn       ~(D ^ S)
#define     MGA_NOP                 0x000a      // D           D
#define     MGA_MERGENOTPEN         0x000b      // DPno        D | ~S
#define     MGA_SRCCOPY             0x000c      // P           S
#define     MGA_MERGEPENNOT         0x000d      // PDno      (~D)| S
#define     MGA_MERGEPEN            0x000e      // DPo         D |  S
#define     MGA_WHITENESS           0x000f      // 1             1


// Special MCTLWTST value for IDUMPs

#define     IDUMP_MCTLWTST          0xc4001000


// **************************************************************************
// Explicit register offsets.

#define DMAWND                      SrcWin
#define SRCWND                      SrcWin
#define DSTWND                      DstWin

#define DWG_DWGCTL                  IntReg+DwgReg+DWGCTL
#define DWG_MACCESS                 IntReg+DwgReg+MACCESS
#define DWG_MCTLWTST                IntReg+DwgReg+MCTLWTST
#define DWG_ZORG                    IntReg+DwgReg+ZORG
#define DWG_DST0                    IntReg+DwgReg+DST0
#define DWG_DST1                    IntReg+DwgReg+DST1
#define DWG_ZMSK                    IntReg+DwgReg+ZMSK
#define DWG_PLNWT                   IntReg+DwgReg+PLNWT
#define DWG_BCOL                    IntReg+DwgReg+BCOL
#define DWG_FCOL                    IntReg+DwgReg+FCOL
#define DWG_SRCBLT                  IntReg+DwgReg+SRCBLT
#define DWG_SRC0                    IntReg+DwgReg+SRC0
#define DWG_SRC1                    IntReg+DwgReg+SRC1
#define DWG_SRC2                    IntReg+DwgReg+SRC2
#define DWG_SRC3                    IntReg+DwgReg+SRC3
#define DWG_XYSTRT                  IntReg+DwgReg+XYSTRT
#define DWG_XYEND                   IntReg+DwgReg+XYEND
#define DWG_SHIFT                   IntReg+DwgReg+SHIFT
#define DWG_SGN                     IntReg+DwgReg+SGN
#define DWG_LEN                     IntReg+DwgReg+LEN
#define DWG_AR0                     IntReg+DwgReg+AR0
#define DWG_AR1                     IntReg+DwgReg+AR1
#define DWG_AR2                     IntReg+DwgReg+AR2
#define DWG_AR3                     IntReg+DwgReg+AR3
#define DWG_AR4                     IntReg+DwgReg+AR4
#define DWG_AR5                     IntReg+DwgReg+AR5
#define DWG_AR6                     IntReg+DwgReg+AR6
#define DWG_PITCH                   IntReg+DwgReg+PITCH
#define DWG_YDST                    IntReg+DwgReg+YDST
#define DWG_YDSTLEN                 IntReg+DwgReg+YDSTLEN
#define DWG_YDSTORG                 IntReg+DwgReg+YDSTORG
#define DWG_CYTOP                   IntReg+DwgReg+CYTOP
#define DWG_CYBOT                   IntReg+DwgReg+CYBOT
#define DWG_CXBNDRY                 IntReg+DwgReg+CXBNDRY
#define DWG_CXLEFT                  IntReg+DwgReg+CXLEFT
#define DWG_CXRIGHT                 IntReg+DwgReg+CXRIGHT
#define DWG_FXBNDRY                 IntReg+DwgReg+FXBNDRY
#define DWG_FXLEFT                  IntReg+DwgReg+FXLEFT
#define DWG_FXRIGHT                 IntReg+DwgReg+FXRIGHT
#define DWG_XDST                    IntReg+DwgReg+XDST
#define DWG_DR0                     IntReg+DwgReg+DR0
#define DWG_DR1                     IntReg+DwgReg+DR1
#define DWG_DR2                     IntReg+DwgReg+DR2
#define DWG_DR3                     IntReg+DwgReg+DR3
#define DWG_DR4                     IntReg+DwgReg+DR4
#define DWG_DR5                     IntReg+DwgReg+DR5
#define DWG_DR6                     IntReg+DwgReg+DR6
#define DWG_DR7                     IntReg+DwgReg+DR7
#define DWG_DR8                     IntReg+DwgReg+DR8
#define DWG_DR9                     IntReg+DwgReg+DR9
#define DWG_DR10                    IntReg+DwgReg+DR10
#define DWG_DR11                    IntReg+DwgReg+DR11
#define DWG_DR12                    IntReg+DwgReg+DR12
#define DWG_DR13                    IntReg+DwgReg+DR13
#define DWG_DR14                    IntReg+DwgReg+DR14
#define DWG_DR15                    IntReg+DwgReg+DR15

#define HST_SRCPAGE                 IntReg+HstReg+SRCPAGE
#define HST_DSTPAGE                 IntReg+HstReg+DSTPAGE
#define HST_BYTACCDATA              IntReg+HstReg+BYTACCDATA
#define HST_ADRGEN                  IntReg+HstReg+ADRGEN
#define HST_FIFOSTATUS              IntReg+HstReg+FIFOSTATUS
#define HST_STATUS                  IntReg+HstReg+STATUS
#define HST_ICLEAR                  IntReg+HstReg+ICLEAR
#define HST_IEN                     IntReg+HstReg+IEN
#define HST_RST                     IntReg+HstReg+RST
#define HST_TEST                    IntReg+HstReg+TEST
#define HST_REV                     IntReg+HstReg+REV
#define HST_CONFIG_REG              IntReg+HstReg+CONFIG_REG
#define HST_OPMODE                  IntReg+HstReg+OPMODE
#define HST_CRTC_CTRL               IntReg+HstReg+CRTC_CTRL
#define HST_VCOUNT                  IntReg+HstReg+VCOUNT

#define VGA_CRTC_INDEX              IntReg+VgaReg+CRTC_INDEX
#define VGA_CRTC_DATA               IntReg+VgaReg+CRTC_DATA
#define VGA_CRTCEXT_INDEX           IntReg+VgaReg+CRTCEXT_INDEX
#define VGA_CRTCEXT_DATA            IntReg+VgaReg+CRTCEXT_DATA
#define VGA_INSTS1                  IntReg+VgaReg+INSTS1

#define BT485_PALETTE_RAM_WRITE     ExtDev+RamDac+BT485_PAL_OR_CURS_RAM_WRITE
#define BT485_CURSOR_RAM_WRITE      ExtDev+RamDac+BT485_PAL_OR_CURS_RAM_WRITE
#define BT485_PALETTE_DATA          ExtDev+RamDac+BT485_COLOR_PAL_DATA
#define BT485_PEL_MASK              ExtDev+RamDac+BT485_PIXEL_MASK
#define BT485_PALETTE_RAM_READ      ExtDev+RamDac+BT485_PAL_OR_CURS_RAM_READ
#define BT485_CURSOR_RAM_READ       ExtDev+RamDac+BT485_PAL_OR_CURS_RAM_READ
#define BT485_CURSOR_COLOR_WRITE    ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_WRITE
#define BT485_OVSCAN_COLOR_WRITE    ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_WRITE
#define BT485_CURSOR_COLOR_DATA     ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_DATA
#define BT485_OVSCAN_COLOR_DATA     ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_DATA
#define BT485_COMMAND_REG0          ExtDev+RamDac+BT485_COMMAND_0
#define BT485_CURSOR_COLOR_READ     ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_READ
#define BT485_OVSCAN_COLOR_READ     ExtDev+RamDac+BT485_OVS_OR_CURS_COLOR_READ
#define BT485_COMMAND_REG1          ExtDev+RamDac+BT485_COMMAND_1
#define BT485_COMMAND_REG2          ExtDev+RamDac+BT485_COMMAND_2
#define BT485_COMMAND_REG3          ExtDev+RamDac+BT485_COMMAND_3_OR_STATUS
#define BT485_STATUS                ExtDev+RamDac+BT485_COMMAND_3_OR_STATUS
#define BT485_CURSOR_RAM_DATA       ExtDev+RamDac+BT485_CURS_RAM_ARRAY
#define BT485_CURSOR_X_LOW          ExtDev+RamDac+BT485_CURS_X_LOW
#define BT485_CURSOR_X_HIGH         ExtDev+RamDac+BT485_CURS_X_HIGH
#define BT485_CURSOR_Y_LOW          ExtDev+RamDac+BT485_CURS_Y_LOW
#define BT485_CURSOR_Y_HIGH         ExtDev+RamDac+BT485_CURS_Y_HIGH

#define BT482_PALETTE_RAM_WRITE     ExtDev+RamDac+BT482_PAL_OR_CURS_RAM_WRITE
#define BT482_CURSOR_RAM_WRITE      ExtDev+RamDac+BT482_PAL_OR_CURS_RAM_WRITE
#define BT482_PALETTE_DATA          ExtDev+RamDac+BT482_COLOR_PAL_DATA
#define BT482_PEL_MASK              ExtDev+RamDac+BT482_PIXEL_MASK
#define BT482_PALETTE_RAM_READ      ExtDev+RamDac+BT482_PAL_OR_CURS_RAM_READ
#define BT482_CURSOR_RAM_READ       ExtDev+RamDac+BT482_PAL_OR_CURS_RAM_READ
#define BT482_CURSOR_COLOR_WRITE    ExtDev+RamDac+BT482_OVS_OR_CURS_COLOR_WRITE
#define BT482_OVRLAY_COLOR_WRITE    ExtDev+RamDac+BT482_OVS_OR_CURS_COLOR_WRITE
#define BT482_OVRLAY_REGS           ExtDev+RamDac+BT482_OVS_OR_CURS_COLOR_DATA
#define BT482_COMMAND_REGA          ExtDev+RamDac+BT482_COMMAND_A
#define BT482_CURSOR_COLOR_READ     ExtDev+RamDac+BT482_OVS_OR_CURS_COLOR_READ
#define BT482_OVRLAY_COLOR_READ     ExtDev+RamDac+BT482_OVS_OR_CURS_COLOR_READ

#define VIEWPOINT_PAL_ADDR_WRITE    ExtDev+RamDac+VPOINT_PAL_ADDR_WRITE
#define VIEWPOINT_PAL_COLOR         ExtDev+RamDac+VPOINT_PAL_COLOR
#define VIEWPOINT_PIX_READ_MASK     ExtDev+RamDac+VPOINT_PIX_READ_MASK
#define VIEWPOINT_PAL_ADDR_READ     ExtDev+RamDac+VPOINT_PAL_ADDR_READ
#define VIEWPOINT_RESERVED_4        ExtDev+RamDac+VPOINT_RESERVED_4
#define VIEWPOINT_RESERVED_5        ExtDev+RamDac+VPOINT_RESERVED_5
#define VIEWPOINT_INDEX             ExtDev+RamDac+VPOINT_INDEX
#define VIEWPOINT_DATA              ExtDev+RamDac+VPOINT_DATA

#define DUBIC_DUB_SEL               ExtDev+Dubic+DUB_SEL
#define DUBIC_NDX_PTR               ExtDev+Dubic+NDX_PTR
#define DUBIC_DUB_DATA              ExtDev+Dubic+DUB_DATA
#define DUBIC_LASER                 ExtDev+Dubic+LASER
#define DUBIC_MOUSE0                ExtDev+Dubic+MOUSE0
#define DUBIC_MOUSE1                ExtDev+Dubic+MOUSE1
#define DUBIC_MOUSE2                ExtDev+Dubic+MOUSE2
#define DUBIC_MOUSE3                ExtDev+Dubic+MOUSE3


// **************************************************************************
// RAMDAC registers fields

// Bt482 --------------------------------------------------------------------

// Extended registers

#define READ_MASK_REG                           0x00
#define OVERLAY_MASK_REG                        0x01
#define COMMAND_B_REG                           0x02
#define CURS_REG                                0x03
#define CURS_X_LOW_REG                          0x04
#define CURS_X_HIGH_REG                         0x05
#define CURS_Y_LOW_REG                          0x06
#define CURS_Y_HIGH_REG                         0x07

// COMMAND_A

#define BT482_PSEUDO_COLOR                      0x00
#define BT482_DUAL_EDGE_CLOCK_555               0x80
#define BT482_DUAL_EDGE_CLOCK_565               0xc0
#define BT482_SINGLE_EDGE_CLOCK_555             0xa0
#define BT482_SINGLE_EDGE_CLOCK_565             0xe0
#define BT482_DUAL_EDGE_CLOCK_888OL             0x90
#define BT482_SINGLE_EDGE_CLOCK_888             0xF0

#define BT482_EXTENDED_REG_SELECT               0x01
#define BT482_EXTENDED_REG_UNSELECT             0x00

// COMMAND_B_REG

#define BT482_OVERLAY_REG_DISABLED              0x00
#define BT482_OVERLAY_REG_ENABLED               0x40

#define BT482_SETUP_00_IRE                      0x00
#define BT482_SETUP_75_IRE                      0x20

#define BT482_NO_SYNC_ON_BLUE                   0x00
#define BT482_SYNC_ON_BLUE                      0x10
#define BT482_NO_SYNC_ON_GREEN                  0x00
#define BT482_SYNC_ON_GREEN                     0x08
#define BT482_NO_SYNC_ON_RED                    0x00
#define BT482_SYNC_ON_RED                       0x04

#define BT482_COLOR_6_BIT                       0x00
#define BT482_COLOR_8_BIT                       0x02

#define BT482_SLEEP_UNSELECT                    0x00
#define BT482_SLEEP_SELECT                      0x01

// CURSOR_REG

#define BT482_INTERNAL_CURSOR                   0x00
#define BT482_EXTERNAL_CURSOR                   0x20

#define BT482_NONINTERLACED_DISPLAY             0x00
#define BT482_INTERLACED_DISPLAY                0x10

#define BT482_CURSOR_COLOR_PALETTE_SELECT       0x00
#define BT482_CURSOR_RAM_SELECT                 0x08

#define BT482_CURSOR_OP_ENABLED                 0x00
#define BT482_CURSOR_OP_DISABLED                0x04

#define BT482_CURSOR_FIELDS                     0x03
#define BT482_CURSOR_DISABLED                   0x00
#define BT482_CURSOR_3_COLOR                    0x01
#define BT482_CURSOR_WINDOWS                    0x02
#define BT482_CURSOR_XWINDOWS                   0x03


// Bt485 --------------------------------------------------------------------

// COMMAND_0

#define BT485_REG3_UNSELECT                     0x00
#define BT485_REG3_SELECT                       0x80

#define BT485_INT_CLOCK_ENABLED                 0x00
#define BT485_INT_CLOCK_DISABLED                0x40

#define BT485_SETUP_00_IRE                      0x00
#define BT485_SETUP_75_IRE                      0x20

#define BT485_NO_SYNC_ON_BLUE                   0x00
#define BT485_SYNC_ON_BLUE                      0x10
#define BT485_NO_SYNC_ON_GREEN                  0x00
#define BT485_SYNC_ON_GREEN                     0x08
#define BT485_NO_SYNC_ON_RED                    0x00
#define BT485_SYNC_ON_RED                       0x04

#define BT485_COLOR_6_BIT                       0x00
#define BT485_COLOR_8_BIT                       0x02

#define BT485_SLEEP_UNSELECT                    0x00
#define BT485_SLEEP_SELECT                      0x01

// COMMAND_1

#define BT485_24BPP                             0x00
#define BT485_16BPP                             0x20
#define BT485_8BPP                              0x40
#define BT485_4BPP                              0x60

#define BT485_TRUECOLOR_BYPASS_DISABLED         0x00
#define BT485_TRUECOLOR_BYPASS_ENABLED          0x10

#define BT485_RGB_555                           0x00
#define BT485_RGB_565                           0x08

#define BT485_2_1_MUX                           0x00
#define BT485_1_1_MUX                           0x04

#define BT485_MUX_PORT_CR10                     0x00
#define BT485_MUX_PORT_P7D                      0x02

#define BT485_MUX_PORT_B_A                      0x00
#define BT485_MUX_PORT_D_C                      0x01

// COMMAND_2

#define BT485_SCLK_ENABLED                      0x00
#define BT485_SCLK_DISABLED                     0x80

#define BT485_TEST_PATH_DISABLED                0x00
#define BT485_TEST_PATH_ENABLED                 0x40

#define BT485_PORTSEL_MASKED                    0x00
#define BT485_PORTSEL_NONMASKED                 0x20

#define BT485_PCLK0_SELECT                      0x00
#define BT485_PCLK1_SELECT                      0x10

#define BT485_NONINTERLACED_DISPLAY             0x00
#define BT485_INTERLACED_DISPLAY                0x08

#define BT485_SPARSE_INDEXING                   0x00
#define BT485_CONTIGUOUS_INDEXING               0x04

#define BT485_CURSOR_FIELDS                     0x03
#define BT485_CURSOR_DISABLED                   0x00
#define BT485_CURSOR_3_COLOR                    0x01
#define BT485_CURSOR_WINDOWS                    0x02
#define BT485_CURSOR_XWINDOWS                   0x03

// COMMAND_3

#define BT485_2X_CLOCK_DISABLED                 0x00
#define BT485_2X_CLOCK_ENABLED                  0x08

#define BT485_CURSOR_32X32                      0x00
#define BT485_CURSOR_64X64                      0x04

#define BT485_CURSOR_64X64_FIELDS               0x03
#define BT485_CURSOR_64X64_XOR_000              0x00
#define BT485_CURSOR_64X64_XOR_100              0x01
#define BT485_CURSOR_64X64_AND_000              0x02
#define BT485_CURSOR_64X64_AND_100              0x03

// ViewPoint ----------------------------------------------------------------

// Indirect register map

#define VPOINT_CUR_X_LSB                        0x00
#define VPOINT_CUR_X_MSB                        0x01
#define VPOINT_CUR_Y_LSB                        0x02
#define VPOINT_CUR_Y_MSB                        0x03
#define VPOINT_SPRITE_X                         0x04
#define VPOINT_SPRITE_Y                         0x05
#define VPOINT_CUR_CTL                          0x06
#define VPOINT_RESERVED_07                      0x07
#define VPOINT_CUR_RAM_LSB                      0x08
#define VPOINT_CUR_RAM_MSB                      0x09
#define VPOINT_CUR_RAM_DATA                     0x0a
#define VPOINT_RESERVED_0b                      0x0b
#define VPOINT_RESERVED_0c                      0x0c
#define VPOINT_RESERVED_0d                      0x0d
#define VPOINT_RESERVED_0e                      0x0e
#define VPOINT_RESERVED_0f                      0x0f
#define VPOINT_WIN_XSTART_LSB                   0x10
#define VPOINT_WIN_XSTART_MSB                   0x11
#define VPOINT_WIN_XSTOP_LSB                    0x12
#define VPOINT_WIN_XSTOP_MSB                    0x13
#define VPOINT_WIN_YSTART_LSB                   0x14
#define VPOINT_WIN_YSTART_MSB                   0x15
#define VPOINT_WIN_YSTOP_LSB                    0x16
#define VPOINT_WIN_YSTOP_MSB                    0x17
#define VPOINT_MUX_CTL1                         0x18
#define VPOINT_MUX_CTL2                         0x19
#define VPOINT_INPUT_CLK                        0x1a
#define VPOINT_OUTPUT_CLK                       0x1b
#define VPOINT_PAL_PAGE                         0x1c
#define VPOINT_GEN_CTL                          0x1d
#define VPOINT_RESERVED_1e                      0x1e
#define VPOINT_RESERVED_1f                      0x1f
#define VPOINT_OVS_RED                          0x20
#define VPOINT_OVS_GREEN                        0x21
#define VPOINT_OVS_BLUE                         0x22
#define VPOINT_CUR_COL0_RED                     0x23
#define VPOINT_CUR_COL0_GREEN                   0x24
#define VPOINT_CUR_COL0_BLUE                    0x25
#define VPOINT_CUR_COL1_RED                     0x26
#define VPOINT_CUR_COL1_GREEN                   0x27
#define VPOINT_CUR_COL1_BLUE                    0x28
#define VPOINT_AUX_CTL                          0x29
#define VPOINT_GEN_IO_CTL                       0x2a
#define VPOINT_GEN_IO_DATA                      0x2b
#define VPOINT_RESERVED_2c                      0x2c
#define VPOINT_RESERVED_2d                      0x2d
#define VPOINT_RESERVED_2e                      0x2e
#define VPOINT_RESERVED_2f                      0x2f
#define VPOINT_KEY_OLVGA_LOW                    0x30
#define VPOINT_KEY_OLVGA_HIGH                   0x31
#define VPOINT_KEY_RED_LOW                      0x32
#define VPOINT_KEY_RED_HI                       0x33
#define VPOINT_KEY_GREEN_LOW                    0x34
#define VPOINT_KEY_GREEN_HI                     0x35
#define VPOINT_KEY_BLUE_LOW                     0x36
#define VPOINT_KEY_BLUE_HI                      0x37
#define VPOINT_KEY_CTL                          0x38
#define VPOINT_RESERVED_39                      0x39
#define VPOINT_SENSE_TEST                       0x3a
#define VPOINT_TEST_DATA                        0x3b
#define VPOINT_CRC_LSB                          0x3c
#define VPOINT_CRC_MSB                          0x3d
#define VPOINT_CRC_CTL                          0x3e
#define VPOINT_ID                               0x3f
#define VPOINT_RESET                            0xff

#define VIEWPOINT_CURSOR_ON                     0x40    //enable XGA + enable sprite
#define VIEWPOINT_CURSOR_OFF                    0x00    //disable XGA cursor

// TVP3026 ------------------------------------------------------------------

// Direct Register Map

// For the Millenium, scale will be 0, for older chips, scale will be 2

#define TVP3026_PAL_ADDR_WR(scale)          ExtDev+RamDac+(0x00<<scale)  //Palette RAM Address Write
#define TVP3026_CUR_ADDR_WR(scale)          ExtDev+RamDac+(0x00<<scale)  //Cursor RAM Address Write
#define TVP3026_INDIRECT_INDEX(scale)       ExtDev+RamDac+(0x00<<scale)  //Indirect Index
#define TVP3026_PAL_DATA(scale)             ExtDev+RamDac+(0x01<<scale)  //Palette RAM Data
#define TVP3026_PIX_RD_MSK(scale)           ExtDev+RamDac+(0x02<<scale)  //Pixel Read Mask
#define TVP3026_PAL_ADDR_RD(scale)          ExtDev+RamDac+(0x03<<scale)  //Palette RAM A.address Read
#define TVP3026_CUR_ADDR_RD(scale)          ExtDev+RamDac+(0x03<<scale)  //Cursor RAM Address Read
#define TVP3026_CUR_COLOR_ADDR_WR(scale)    ExtDev+RamDac+(0x04<<scale)  //Cursor Color Address Write
#define TVP3026_OVS_COLOR_ADDR_WR(scale)    ExtDev+RamDac+(0x04<<scale)  //Overscan Color Address Write
#define TVP3026_CUR_COLOR_DATA(scale)       ExtDev+RamDac+(0x05<<scale)  //Cursor Color Data
#define TVP3026_OVS_COLOR_DATA(scale)       ExtDev+RamDac+(0x05<<scale)  //Overscan Color Data
#define TVP3026_RESERVED_0(scale)           ExtDev+RamDac+(0x06<<scale)  //Reserved
#define TVP3026_CUR_COLOR_ADDR_RD(scale)    ExtDev+RamDac+(0x07<<scale)  //Cursor Color Address Read
#define TVP3026_OVS_COLOR_ADDR_RD(scale)    ExtDev+RamDac+(0x07<<scale)  //Overscan Color Address Read
#define TVP3026_RESERVED_1(scale)           ExtDev+RamDac+(0x08<<scale)  //Reserved
#define TVP3026_RESERVED_2(scale)           ExtDev+RamDac+(0x09<<scale)  //Reserved
#define TVP3026_INDEXED_DATA(scale)         ExtDev+RamDac+(0x0a<<scale)  //Indexed Data
#define TVP3026_CUR_DATA(scale)             ExtDev+RamDac+(0x0b<<scale)  //Cursor RAM Data
#define TVP3026_CUR_X_LSB(scale)            ExtDev+RamDac+(0x0c<<scale)  //Cursor Position X LSB
#define TVP3026_CUR_X_MSB(scale)            ExtDev+RamDac+(0x0d<<scale)  //Cursor Position X MSB
#define TVP3026_CUR_Y_LSB(scale)            ExtDev+RamDac+(0x0e<<scale)  //Cursor Position Y LSB
#define TVP3026_CUR_Y_MSB(scale)            ExtDev+RamDac+(0x0f<<scale)  //Cursor Position Y MSB

// Indirect Register Map

#define TVP3026_I_PAL_STATUS        0x000
#define TVP3026_I_REV               0x001
#define TVP3026_I_RES_02            0x002
#define TVP3026_I_RES_03            0x003
#define TVP3026_I_RES_04            0x004
#define TVP3026_I_RES_05            0x005
#define TVP3026_I_CUR_CTL           0x006
#define TVP3026_I_RES_07            0x007
#define TVP3026_I_RES_08            0x008
#define TVP3026_I_RES_09            0x009
#define TVP3026_I_RES_0A            0x00a
#define TVP3026_I_RES_0B            0x00b
#define TVP3026_I_RES_0C            0x00c
#define TVP3026_I_RES_0D            0x00d
#define TVP3026_I_RES_0E            0x00e
#define TVP3026_I_LATCH_CTL         0x00f
#define TVP3026_I_RES_10            0x010
#define TVP3026_I_RES_11            0x011
#define TVP3026_I_RES_12            0x012
#define TVP3026_I_RES_13            0x013
#define TVP3026_I_RES_14            0x014
#define TVP3026_I_RES_15            0x015
#define TVP3026_I_RES_16            0x016
#define TVP3026_I_RES_17            0x017
#define TVP3026_I_TRUE_COL_CTL      0x018
#define TVP3026_I_MPX_CTL           0x019
#define TVP3026_I_CLK_SEL           0x01a
#define TVP3026_I_RES_1B            0x01b
#define TVP3026_I_PAL_PAGE          0x01c
#define TVP3026_I_GENERAL_CTL       0x01d
#define TVP3026_I_MISC_CTL          0x01e
#define TVP3026_I_RES_1F            0x01f
#define TVP3026_I_RES_20            0x020
#define TVP3026_I_RES_21            0x021
#define TVP3026_I_RES_22            0x022
#define TVP3026_I_RES_23            0x023
#define TVP3026_I_RES_24            0x024
#define TVP3026_I_RES_25            0x025
#define TVP3026_I_RES_26            0x026
#define TVP3026_I_RES_27            0x027
#define TVP3026_I_RES_28            0x028
#define TVP3026_I_RES_29            0x029
#define TVP3026_I_GEN_IO_CTL        0x02a
#define TVP3026_I_GEN_IO_DATA       0x02b
#define TVP3026_I_PLL_ADDR          0x02c
#define TVP3026_I_PEL_CLK_PLL_DATA  0x02d
#define TVP3026_I_MEM_CLK_PLL_DATA  0x02e
#define TVP3026_I_LOAD_CLK_PLL_DATA 0x02f
#define TVP3026_I_COL_KEY_OVL_LO    0x030
#define TVP3026_I_COL_KEY_OVL_HI    0x031
#define TVP3026_I_COL_KEY_R_LO      0x032
#define TVP3026_I_COL_KEY_R_HI      0x033
#define TVP3026_I_COL_KEY_G_LO      0x034
#define TVP3026_I_COL_KEY_G_HI      0x035
#define TVP3026_I_COL_KEY_B_LO      0x036
#define TVP3026_I_COL_KEY_B_HI      0x037
#define TVP3026_I_COL_KEY_CTL       0x038
#define TVP3026_I_MCLK_CTL          0x039
#define TVP3026_I_SENSE_TEST        0x03a
#define TVP3026_I_TEST_DATA         0x03b
#define TVP3026_I_CRC_REM_LSB       0x03c
#define TVP3026_I_CRC_REM_MSB       0x03d
#define TVP3026_I_CRC_BIT_SEL       0x03e
#define TVP3026_I_ID                0x03f
#define TVP3026_I_SOFT_RESET        0x0ff

#define TVP3026_D_CURSOR_ON         0x02       //00000010b  enable XGA cursor
#define TVP3026_D_CURSOR_OFF        0x00       //00000000b  disable cursor
#define TVP3026_D_CURSOR_MASK       0x03

                                               //access cursor bitmap:
#define TVP3026_D_CURSOR_RAM_00     0x00       //00000000b access bytes 000-0FF
#define TVP3026_D_CURSOR_RAM_01     0x04       //00000100b access bytes 100-1FF
#define TVP3026_D_CURSOR_RAM_10     0x08       //00001000b access bytes 200-2FF
#define TVP3026_D_CURSOR_RAM_11     0x0c       //00001100b access bytes 300-3FF
#define TVP3026_D_CURSOR_RAM_MASK   0x0c

#define TVP3026_D_OVS_COLOR         0x00       //00000000b  Overscan color
#define TVP3026_D_CUR_COLOR_0       0x01       //00000001b  Cursor color 0
#define TVP3026_D_CUR_COLOR_1       0x02       //00000010b  Cursor color 1
#define TVP3026_D_CUR_COLOR_2       0x03       //00000011b  Cursor color 2

// --------------------------------------------------------------------------

// MGA PRODUCT ID (from DEFBIND.H in miniport driver)

#define  MGA_ULT_1M     1
#define  MGA_ULT_2M     2
#define  MGA_IMP_3M     3
#define  MGA_IMP_3M_Z   4
#define  MGA_PRO_4M5    5
#define  MGA_PRO_4M5_Z  6
#define  MGA_PCI_2M     7
#define  MGA_PCI_4M     8

#define  MGA_STORM      10

////////////////////////////////////////////////////////////////////////

// Private IOCTL call definitions

#define COMMON_FLAG     0x80000000
#define CUSTOM_FLAG     0x00002000

#define IOCTL_VIDEO_MTX_QUERY_NUM_OFFSCREEN_BLOCKS                        \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_OFFSCREEN_BLOCKS                            \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_INITIALIZE_MGA                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO                                 \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_GET_UPDATED_INF                                   \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_BOARD_ID                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_HW_DATA                                     \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_BOARD_ARRAY                                 \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT                                \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_INIT_MODE_LIST                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

// This structure is used with VIDEO_IOCTL_MTX_QUERY_NUM_OFFSCREEN_BLOCKS.

typedef struct _VIDEO_NUM_OFFSCREEN_BLOCKS
{
    ULONG       NumBlocks;              // number of offscreen blocks
    ULONG       OffscreenBlockLength;   // size of OFFSCREEN_BLOCK structure
} VIDEO_NUM_OFFSCREEN_BLOCKS;

// This structure is used with VIDEO_IOCTL_MTX_QUERY_OFFSCREEN_BLOCKS.

typedef struct _OFFSCREEN_BLOCK
{
    ULONG       Type;           // N_VRAM, N_DRAM, Z_VRAM, or Z_DRAM
    ULONG       XStart;         // X origin of offscreen memory area
    ULONG       YStart;         // Y origin of offscreen memory area
    ULONG       Width;          // offscreen width, in pixels
    ULONG       Height;         // offscreen height, in pixels
    ULONG       SafePlanes;     // offscreen available planes
    ULONG       ZOffset;        // Z start offset, if any Z
} OFFSCREEN_BLOCK;

// This structure is used with IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO.

typedef struct _RAMDAC_INFO
{
    ULONG       Flags;          // Ramdac type
    ULONG       Width;          // Maximum cursor width
    ULONG       Height;         // Maximum cursor height
    ULONG       OverScanX;      // X overscan
    ULONG       OverScanY;      // Y overscan
} RAMDAC_INFO, *PRAMDAC_INFO;

// Definitions for 'Type' field.

#define N_VRAM      0   // Normal offscreen in VRAM, supports block mode
#define N_DRAM      6   // Normal offscreen in DRAM, no support for block mode
#define Z_VRAM      1   // Z-buffer memory in VRAM, supports block mode
#define Z_DRAM      7   // Z-buffer memory in DRAM, no support for block mode

// These structures are used with IOCTL_VIDEO_MTX_QUERY_HW_DATA.  They should
// be kept in sync with the CursorInfo and HwData structures defined in the
// miniport driver.

typedef struct _CURSOR_INFO
{
    ULONG   MaxWidth;
    ULONG   MaxHeight;
    ULONG   MaxDepth;
    ULONG   MaxColors;
    ULONG   CurWidth;
    ULONG   CurHeight;
    LONG    cHotSX;
    LONG    cHotSY;
    LONG    HotSX;
    LONG    HotSY;
} CURSOR_INFO, *PCURSOR_INFO;

// Defines for HwData.Features flags

#define DDC_MONITOR_SUPPORT     0x0001
#define STORM_ON_MOTHERBOARD    0x0002
#define MEDIA_EXCEL             0x0004
#define INTERLEAVE_MODE         0x0008

typedef struct _HW_DATA
{
    ULONG       StructLength;   /* Structure length in bytes */
    ULONG       MapAddress;     /* Memory map address */
    ULONG       MapAddress2;    /* Physical base address, frame buffer */
    ULONG       RomAddress;     /* Physical base address, flash EPROM */
    ULONG       ProductType;    /* MGA Ultima ID, MGA Impression ID, ... */
    ULONG       ProductRev;     /* 4 bit revision codes as follows */
                                /* 0  - 3  : pcb   revision */
                                /* 4  - 7  : Titan revision */
                                /* 8  - 11 : Dubic revision */
                                /* 12 - 31 : all 1's indicating no other device
                                             present */
    ULONG       ShellRev;       /* Shell revision */
    ULONG       BindingRev;     /* Binding revision */

    ULONG       MemAvail;       /* Frame buffer memory in bytes */
    BYTE        VGAEnable;      /* 0 = vga disabled, 1 = vga enabled */
    BYTE        Sync;           /* relects the hardware straps  */
    BYTE        Device8_16;     /* relects the hardware straps */

    BYTE        PortCfg;        /* 0-Disabled, 1-Mouse Port, 2-Laser Port */
    BYTE        PortIRQ;        /* IRQ level number, -1 = interrupts disabled */
    ULONG       MouseMap;       /* Mouse I/O map base if PortCfg = Mouse Port else don't care */
    BYTE        MouseIRate;     /* Mouse interrupt rate in Hz */
    BYTE        DacType;        /* 0 = BT482, 3 = BT485 */
    CURSOR_INFO cursorInfo;
    ULONG       VramAvail;      /* VRAM memory available on board in bytes */
    ULONG       DramAvail;      /* DRAM memory available on board in bytes */
    ULONG       CurrentOverScanX; /* Left overscan in pixels */
    ULONG       CurrentOverScanY; /* Top overscan in pixels */
    ULONG       YDstOrg;          /* Physical offset of display start */
    ULONG       YDstOrg_DB;     /* Starting offset for double buffer */
    ULONG       CurrentZoomFactor;
    ULONG       CurrentXStart;
    ULONG       CurrentYStart;
    ULONG       CurrentPanXGran;    /* X Panning granularity */
    ULONG       CurrentPanYGran;    /* Y Panning granularity */
    ULONG       Features;           /* Bit 0: 0 = DDC monitor not available */
                                    /*        1 = DDC monitor available     */
    BYTE        Reserved[64];

    ULONG       MgaBase1;           /* MGA control aperture */
    ULONG       MgaBase2;           /* Direct frame buffer */
    ULONG       RomBase;            /* BIOS flash EPROM */
    ULONG       PresentMCLK;
} HW_DATA, *PHW_DATA;

// Definitions for RamDacType field.

#define RAMDAC_FIELDS       0xf000
#define RAMDAC_NONE         0x0000
#define RAMDAC_BT482        0x1000
#define RAMDAC_BT485        0x2000
#define RAMDAC_VIEWPOINT    0x3000
#define RAMDAC_TVP3026      0x4000
#define RAMDAC_PX2085       0x5000
#define RAMDAC_TVP3030      0x6000

//////////////////////////////////////////////////////////////////////
// PowerPC considerations
//
// The PowerPC does not guarantee that I/O to separate addresses will
// be executed in order.  However, the PowerPC guarantees that
// output to the same address will be executed in order.
//
// Consequently, we use the following synchronization macros.  They
// are relatively expensive in terms of performance, so we try to avoid
// them whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution or 'collapsing' of I/O to
//      the same address.  We used to have to do this separately for
//      the Alpha because unlike the PowerPC it did not guarantee that
//      output to the same address will be exectued in order.  However,
//      with the move to kernel-mode, on Alpha we are now calling HAL
//      routines for every port I/O which ensure that this is not a
//      problem.

#if defined(_PPC_)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()

#elif defined(_ALPHA_)

    // On Alpha, since we must do all non-frame-buffer I/O through HAL
    // routines, which automatically do memory-barriers, we don't have
    // to do memory barriers ourselves (and should not, because it's a
    // performance hit).

    #define CP_EIEIO()
    #define CP_MEMORY_BARRIER()

#else

    // On other systems, both CP_EIEIO and CP_MEMORY_BARRIER don't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER() MEMORY_BARRIER()

#endif

////////////////////////////////////////////////////////////////////////
// Unsafe direct access macros
//
// These are macros for directly accessing the MGA's accelerator
// registers.  They should be used with care, because they always
// ignore memory barriers:

#define CP_WRITE_DIRECT(pjBase, addr, dw)                           \
    WRITE_REGISTER_ULONG((BYTE*) (pjBase) + (addr), (ULONG) (dw))

#define CP_WRITE_DIRECT_BYTE(pjBase, addr, j)                       \
    WRITE_REGISTER_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j))

#define CP_READ_REGISTER(p)                                         \
    READ_REGISTER_ULONG((BYTE*) (p))

#define CP_READ_REGISTER_BYTE(p)                                    \
    READ_REGISTER_UCHAR((BYTE*) (p))

////////////////////////////////////////////////////////////////////////
// 'Safe' direct access macros
//
// These are the 'safe' slow versions for directly writing to a port,
// because they automatically always handle memory barriers:

#define CP_WRITE_REGISTER(p, dw)                                    \
{                                                                   \
    CP_EIEIO();                                                     \
    WRITE_REGISTER_ULONG(p, (ULONG) (dw));                          \
    CP_EIEIO();                                                     \
}

#define CP_WRITE_REGISTER_WORD(p, w)                                \
{                                                                   \
    CP_EIEIO();                                                     \
    WRITE_REGISTER_USHORT(p, (USHORT) (w));                         \
    CP_EIEIO();                                                     \
}

#define CP_WRITE_REGISTER_BYTE(p, j)                                \
{                                                                   \
    CP_EIEIO();                                                     \
    WRITE_REGISTER_UCHAR(p, (UCHAR) (j));                           \
    CP_EIEIO();                                                     \
}

////////////////////////////////////////////////////////////////////////
// MGA direct access macros
//
// These macros abstract some MGA register accesses.

#define CP_WRITE_SRC(pjBase, dw)                                    \
{                                                                   \
    CP_WRITE_DIRECT((pjBase), DWG_SRC0, (dw));                      \
    CP_MEMORY_BARRIER();                                            \
}

#define CP_READ_STATUS(pjBase)                                      \
    CP_READ_REGISTER_BYTE((BYTE*) (pjBase) + HST_STATUS + 2)

#define CP_READ(pjBase, addr)                                       \
    CP_READ_REGISTER((BYTE*) (pjBase) + (addr))

#if DBG

    #define CP_START(pjBase, addr, dw)                              \
    {                                                               \
        CP_EIEIO();                                                 \
        vWriteDword((BYTE*) (pjBase) + (addr) + (StartDwgReg), (ULONG) (dw)); \
        CP_EIEIO();                                                 \
    }

    #define CP_WRITE(pjBase, addr, dw)                              \
        vWriteDword((BYTE*) (pjBase) + (addr), (ULONG) (dw))

    #define CP_WRITE_BYTE(pjBase, addr, j)                          \
        vWriteByte((BYTE*) (pjBase) + (addr), (UCHAR) (j))

    #define CHECK_FIFO_SPACE(pjBase, level)                         \
        vCheckFifoSpace((pjBase), (level))

    #define GET_FIFO_SPACE(pjBase)                                  \
        cGetFifoSpace((pjBase))

#else

    #define CP_START(pjBase, addr, dw)                              \
    {                                                               \
        CP_EIEIO();                                                 \
        WRITE_REGISTER_ULONG((BYTE*) (pjBase) + (addr) + (StartDwgReg), (ULONG) (dw)); \
        CP_EIEIO();                                                 \
    }

    #define CP_WRITE(pjBase, addr, dw)                              \
        WRITE_REGISTER_ULONG((BYTE*) (pjBase) + (addr), (ULONG) (dw))

    #define CP_WRITE_BYTE(pjBase, addr, j)                          \
        WRITE_REGISTER_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j))

    #define CHECK_FIFO_SPACE(pjBase, level)                         \
    {                                                               \
        CP_EIEIO();                                                 \
        do {} while (CP_READ_REGISTER_BYTE((pjBase) + HST_FIFOSTATUS) < (level)); \
    }

    __inline CHAR GET_FIFO_SPACE(BYTE* pjBase)                      \
    {                                                               \
        CP_EIEIO();                                                 \
        return(CP_READ_REGISTER_BYTE((pjBase) + HST_FIFOSTATUS));   \
    }

#endif

// It used to be that we had to worry about the Alpha collapsing writes
// to the same address.  Not any more!  With NT 4.0, all I/O on the
// Alpha goes through HAL calls that automatically ensure that
// collapsed writes will not be a problem.

#define CP_WRITE_DMA(ppdev, pjDma, dw)                              \
    CP_WRITE((pjDma), 0, (dw))

#define CP_READ_DMA(ppdev, pjDma)                                   \
    CP_READ((pjDma), 0)

#define CHECK_FIFO_FREE(pjBase, cFifo, needed)                      \
{                                                                   \
    (cFifo) -= (needed);                                            \
    while ((CHAR) (cFifo) < 0)                                      \
    {                                                               \
        (cFifo) = GET_FIFO_SPACE(pjBase) - (needed);                \
    }                                                               \
}

/////////////////////////////////////////////////////////////////

__inline ULONG COLOR_REPLICATE(PDEV* ppdev, ULONG x)
{
    ULONG ulResult = x;
    if (ppdev->cjPelSize == 1)
    {
        ulResult |= (ulResult << 8);
        ulResult |= (ulResult << 16);
    }
    else if (ppdev->cjPelSize == 2)
    {
        ulResult |= (ulResult << 16);
    }
    return(ulResult);
}

// The PACKXY macro is used for line drawing, and is safe for
// negative 'x' values:

#define PACKXY(x, y)        (((y) << 16) | (x) & 0xffff)

// This one isn't safe for negative 'x' values:

#define PACKXY_QUICK(x, y)  (((y) << 16) | (x))

/////////////////////////////////////////////////////////////////
// DirectDraw stuff

__inline BOOL VBLANK_IS_ACTIVE(BYTE* pjBase)
{
    CP_EIEIO();
    return(CP_READ_REGISTER_BYTE((BYTE*) (pjBase) + VGA_INSTS1) & 0x08);
}

__inline BOOL DISPLAY_IS_ACTIVE(BYTE* pjBase)
{
    CP_EIEIO();
    return(!(CP_READ_REGISTER_BYTE((BYTE*) (pjBase) + VGA_INSTS1) & 0x01));
}

__inline ULONG GET_SCANLINE(BYTE* pjBase)
{
    CP_EIEIO();
    return(CP_READ_REGISTER((pjBase) + HST_VCOUNT));
}

//////////////////////////////////////////////////////////////////////////
// START_ and END_DIRECT_ACCESS should bracket direct frame buffer
// access so that memory barriers are performed correctly on the
// PowerPC and Alpha.

#define START_DIRECT_ACCESS_MGA_NO_WAIT(ppdev, pjBase)\
    CP_EIEIO()

#define START_DIRECT_ACCESS_MGA(ppdev, pjBase)\
    CP_EIEIO();WAIT_NOT_BUSY(pjBase)

#define END_DIRECT_ACCESS_MGA(ppdev, pjBase)\
    CP_EIEIO()

#define START_DIRECT_ACCESS_STORM(ppdev, pjBase)\
{\
    CP_EIEIO();\
    WAIT_NOT_BUSY(pjBase);\
}

//////////////////////////////////////////////////////////////////////////
// The STORM has an ugly framebuffer read coherency bug -- it does not
// invalidate its frame buffer cache when an accelerator operation is
// done.  To work around this, we do some extra reads to make sure the
// data in the cache is currently valid.
//
// This problem was most evident with USWC turned on with a Pentium Pro,
// when using a software cursor and selecting text using 'QuickEdit' mode
// in a console window -- cursor turds would be left around the screen.

#define START_DIRECT_ACCESS_STORM_FOR_READ(ppdev, pjBase)       \
{                                                               \
    volatile ULONG ulTmp;                                       \
    CP_EIEIO();                                                 \
    WAIT_NOT_BUSY(pjBase);                                      \
    ulTmp = *(volatile ULONG *)(ppdev->pjScreen);               \
    ulTmp = *(volatile ULONG *)(ppdev->pjScreen + 32);          \
    CHECK_FIFO_SPACE(pjBase, 1);/* Done to flush USWC cache */  \
}

// The STORM has an ugly framebuffer cache coherency bug.  We need to
// do some extra reads to make sure that data written to the
// framebuffer are actually flushed from the cache into video memory.
//
// This problem was evident when running OpenGL conformance tests.

#define END_DIRECT_ACCESS_STORM(ppdev, pjBase)                  \
{                                                               \
    volatile ULONG ulTmp;                                       \
    CP_EIEIO();                                                 \
    ulTmp = *(volatile ULONG *)(ppdev->pjScreen);               \
    ulTmp = *(volatile ULONG *)(ppdev->pjScreen + 128);         \
}

#define BLT_WRITE_ON(ppdev, pjBase)                             \
{                                                               \
    ULONG ul;                                                   \
                                                                \
    ul = CP_READ_REGISTER(pjBase + HST_OPMODE) & OPMODE_OTHER_INFO; \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ul | (dmamod_BLIT_WRITE)); \
    CP_MEMORY_BARRIER();                                        \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ul | (dmamod_BLIT_WRITE | pseudodma_ON)); \
    CP_EIEIO();                                                 \
    CP_READ_REGISTER(pjBase + HST_OPMODE);                      \
}

#define BLT_WRITE_OFF(ppdev, pjBase)                            \
{                                                               \
    ULONG ul;                                                   \
                                                                \
    ul = CP_READ_REGISTER(pjBase + HST_OPMODE) & OPMODE_OTHER_INFO; \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ul | (pseudodma_OFF)); \
    CP_EIEIO();                                                 \
}

#define BLT_READ_ON(ppdev, pjBase)                              \
{                                                               \
    ULONG ul;                                                   \
                                                                \
    ul = CP_READ_REGISTER(pjBase + HST_OPMODE) & OPMODE_OTHER_INFO; \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ul | (dmamod_BLIT_READ)); \
    CP_MEMORY_BARRIER();                                        \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ul | (dmamod_BLIT_READ | pseudodma_ON)); \
    CP_EIEIO();                                                 \
}

#define BLT_READ_OFF(ppdev, pjBase)                             \
    BLT_WRITE_OFF((ppdev), (pjBase))

#define IS_BUSY(pjBase)                                         \
    ((CP_READ_STATUS(pjBase) & (dwgengsts_MASK >> 16)) != 0)

#define WAIT_NOT_BUSY(pjBase)                                   \
{                                                               \
    do {} while (IS_BUSY(pjBase));                              \
}

#define DATA_TRANSFER(pjBase, pjSrc, cdSrc)                     \
{                                                               \
    LONG    i      = (LONG) (cdSrc);                            \
    ULONG*  pulSrcTmp = (ULONG*) (pjSrc);                       \
    do {                                                        \
        CP_WRITE_DIRECT(pjBase, DWG_SRC0, *pulSrcTmp);          \
        pulSrcTmp++;                                            \
    } while (--i != 0);                                         \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains most of the required GDI line support.  Supports drawing
* lines in short 'strips' when clipping is complex or coordinates
* are too large to be drawn by the line hardware.
*
* Copyright (c) 1990-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

// The MGA's hardware coordinates are limited to 16-bit signed values:

#define MIN_INTEGER_BOUND (-32767)
#define MAX_INTEGER_BOUND (32767)

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// MGA specific defines

// The MGA's hardware can have 16 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 16

ULONG gaiSign[] = {
    sdydxl_MAJOR_X | sdy_ADD | sdxl_ADD,  //          |      |      |
    sdydxl_MAJOR_Y | sdy_ADD | sdxl_ADD,  //          |      |      |FLIP_D
    sdydxl_MAJOR_X | sdy_SUB | sdxl_ADD,  //          |      |FLIP_V|
    sdydxl_MAJOR_Y | sdy_SUB | sdxl_ADD,  //          |      |FLIP_V|FLIP_D
    sdydxl_MAJOR_X | sdy_ADD | sdxl_SUB,  //          |FLIP_H|      |
    sdydxl_MAJOR_Y | sdy_ADD | sdxl_SUB,  //          |FLIP_H|      |FLIP_D
    sdydxl_MAJOR_X | sdy_SUB | sdxl_SUB,  //          |FLIP_H|FLIP_V|
    sdydxl_MAJOR_Y | sdy_SUB | sdxl_SUB,  //          |FLIP_H|FLIP_V|FLIP_D
    sdydxl_MAJOR_X | sdy_ADD | sdxl_ADD,  // SLOPE_ONE|      |      |
    0xffffffff,                           // SLOPE_ONE|      |      |FLIP_D
    sdydxl_MAJOR_X | sdy_SUB | sdxl_ADD,  // SLOPE_ONE|      |FLIP_V|
    0xffffffff,                           // SLOPE_ONE|      |FLIP_V|FLIP_D
    sdydxl_MAJOR_X | sdy_ADD | sdxl_SUB,  // SLOPE_ONE|FLIP_H|      |
    0xffffffff,                           // SLOPE_ONE|FLIP_H|      |FLIP_D
    sdydxl_MAJOR_X | sdy_SUB | sdxl_SUB,  // SLOPE_ONE|FLIP_H|FLIP_V|
    0xffffffff                            // SLOPE_ONE|FLIP_H|FLIP_V|FLIP_D
};

/******************************Public*Routine******************************\
* BOOL bLinesComplex(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLinesComplex(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line
    BYTE*     pjBase;

    pjBase = ppdev->pjBase;

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-clipped, non-styled integer endpoint lines

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Integer end-point lines will probably account for 90% of
            // all lines drawn (curves rendered by GDI will be an
            // exception, and will have fractional GIQ coordinates).
            //
            // As such, we try to special-case integer lines as soon as
            // possible.
            //
            // Unfortunately, the MGA's point-to-point line capability has
            // a rounding convention for rendering tie-breaker pixels that
            // doesn't match that of GDI's, so we can't use it for
            // arbitrary integer lines, otherwise we would fail HCTs.  But
            // since horizontal and vertical lines have no tie-breakers,
            // and probably account for 60% of all lines drawn, we special
            // case them here.  (The 'bHardwareLine' special case a little
            // lower down will handle arbitrary direction lines.)
            //
            // Note: If your hardware can't handle GIQ lines ala
            //       'bHardwareLine,' but can handle the correct rounding
            //       convention, I strongly recommend special-casing
            //       integer lines of arbitrary slope here, too.
            //
            // How can you tell if you have the correct rounding convention?
            // Implement integer lines (they're easy), run Guiman and draw a
            // bunch of Polyline lines in random directions, and then press
            // the 'X' xor button -- if you see random pixels lit up, you've
            // got the wrong convention...

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                // MGA specific code follows:

                LONG    x0;
                LONG    y0;
                LONG    x1;
                LONG    y1;

                if (N0 == dN)
                {
                    // Horizontal integer line:

                    y0 = (N0 >> FLOG2) + ppdev->yOffset;
                    x0 = (M0 >> FLOG2) + ppdev->xOffset;
                    x1 = (dM >> FLOG2) + ppdev->xOffset;

                    CHECK_FIFO_SPACE(pjBase, 2);
                    CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x0, y0));
                    CP_START(pjBase, DWG_XYEND, PACKXY(x1, y0));
                    goto Next_Line;
                }
                else if (M0 == dM)
                {
                    // Vertical integer line:

                    x0 = (M0 >> FLOG2) + ppdev->xOffset;
                    y0 = (N0 >> FLOG2) + ppdev->yOffset;
                    y1 = (dN >> FLOG2) + ppdev->yOffset;

                    CHECK_FIFO_SPACE(pjBase, 2);
                    CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x0, y0));
                    CP_START(pjBase, DWG_XYEND, PACKXY(x0, y1));
                    goto Next_Line;
                }
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf))
                goto Next_Line;
        }

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);
        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vLinesSimple
*
* Historically, NT has used funky 'GIQ' coordinates that have 4 bits of
* fraction, and is very picky about which pixels are lit even for lines
* whose coordinates are all integers.  But as of NT 4.0 Service-Pack 1,
* NT now informs us when all the coordinates in a path are integers (via
* the PO_ALL_INTEGERS flag), and what's more it allows us to request that
* the path coordinates before returned as integers instead of the funky
* 28.4 (by setting the PO_ENUM_AS_INTEGERS flag).
*
* But the best part is that GDI now allows us to choose which pixel we'll
* light for tie-breaker cases, when the error term is exactly 0.5 (the
* lines must still be last-pixel exclusive, of course).
*
* So we can now use the hardware's auto-Bresenham-setup (point-to-point
* lines) capability!  And that's exactly what we do here...
*
* Unfortunately, this code is complicated by the funky format for the MGA's
* auto-line mechanism -- we have to send down batches composed of a 1 dword
* flag, followed by 32 vertices.  The dword flag indicates which of the
* following vertices should be considered the disjoint from the rest (i.e.,
* indicates PD_BEGINSUBPATH to the hardware).
*
\**************************************************************************/

// !!! These defines should be retrieved from winddi.h

#define PO_ALL_INTEGERS     0x00000004
#define PO_ENUM_AS_INTEGERS 0x00000008

#define VECTOR_WRITE_ON(ppdev, pjBase, ulOpmodeOut)             \
{                                                               \
    ulOpmodeOut = CP_READ_REGISTER(pjBase + HST_OPMODE) & OPMODE_OTHER_INFO; \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ulOpmodeOut | (dmamod_VECTOR_WRITE)); \
    CP_MEMORY_BARRIER();                                        \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ulOpmodeOut | (dmamod_VECTOR_WRITE | pseudodma_ON)); \
    CP_EIEIO();                                                 \
    CP_READ_REGISTER(pjBase + HST_OPMODE);                      \
}

#define VECTOR_WRITE_OFF(ppdev, pjBase, ulOpmodeIn)             \
{                                                               \
    CP_WRITE_DIRECT_BYTE(pjBase, HST_OPMODE, ulOpmodeIn | (pseudodma_OFF)); \
    CP_EIEIO();                                                 \
}

// To use the MGA's pseudo-DMA vector transfer, we have to do everything
// in batches of one dword 'tag' followed by 32 vertices:

#define VECTOR_BATCH_SIZE 32

VOID vLinesSimple(
PDEV*       ppdev,
PATHOBJ*    ppo)
{
    BYTE*       pjBase;
    BYTE*       pjDma;
    ULONG*      pulDma;
    LONG        xOffset;
    LONG        yOffset;
    BOOL        bMore;
    PATHDATA    pd;
    LONG        cLines;
    POINTFIX*   pptfx;
    POINTFIX    ptfxStartFigure;
    ULONG       axyBuf[VECTOR_BATCH_SIZE];
    ULONG*      pxy;
    LONG        cxy;
    ULONG       ulTag;
    ULONG       ulOpmode;

    // Notify GDI that we want the path enumerated as integers instead of
    // fixed coordinates.  Note that we can only do this when GDI has set
    // the PO_ALL_INTEGERS flag:

    ppo->fl |= PO_ENUM_AS_INTEGERS;

    pjBase  = ppdev->pjBase;
    pjDma   = pjBase + DMAWND;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    pxy = axyBuf;
    cxy = VECTOR_BATCH_SIZE;

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    VECTOR_WRITE_ON(ppdev, pjBase, ulOpmode);

    do {
        bMore  = PATHOBJ_bEnum(ppo, &pd);
        cLines = pd.count;
        pptfx  = pd.pptfx;

        if (pd.flags & PD_BEGINSUBPATH)
        {
            cLines--;
            ptfxStartFigure.x = pptfx->x;
            ptfxStartFigure.y = pptfx->y;

            *pxy = PACKXY(pptfx->x + xOffset, pptfx->y + yOffset);
            pxy++;
            pptfx++;

            // Set the high bit to zero, and move all the other bits down:

            ulTag >>= 1;

            if (--cxy == 0)
            {
                // Flush the buffer!

                pxy    = axyBuf;
                cxy    = VECTOR_BATCH_SIZE;
                pulDma = (ULONG*) pjDma;

                CHECK_FIFO_SPACE(pjBase, 1);
                CP_WRITE_DMA(ppdev, pulDma, ulTag);
                pulDma++;

                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                do {
                    CP_WRITE_DMA(ppdev, pulDma, *pxy);
                    pulDma++;
                    pxy++;

                } while (--cxy != 0);

                pxy = axyBuf;
                cxy = VECTOR_BATCH_SIZE;
            }
        }

PolylineSegments:

        while (cLines-- > 0)
        {
            *pxy = PACKXY(pptfx->x + xOffset, pptfx->y + yOffset);
            pxy++;
            pptfx++;

            // Set the high bit to one, and move all the other bits down:

            ulTag = 0x80000000 | (ulTag >> 1);

            if (--cxy == 0)
            {
                // Flush the buffer!

                pxy    = axyBuf;
                cxy    = VECTOR_BATCH_SIZE;
                pulDma = (ULONG*) pjDma;

                CHECK_FIFO_SPACE(pjBase, 1);
                CP_WRITE_DMA(ppdev, pulDma, ulTag);
                pulDma++;

                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                do {
                    CP_WRITE_DMA(ppdev, pulDma, *pxy);
                    pulDma++;
                    pxy++;

                } while (--cxy != 0);

                pxy = axyBuf;
                cxy = VECTOR_BATCH_SIZE;
            }
        }

        if (pd.flags & PD_CLOSEFIGURE)
        {
            pd.flags &= ~PD_CLOSEFIGURE;
            pptfx = &ptfxStartFigure;
            goto PolylineSegments;
        }

    } while (bMore);

    // Flush the buffer if there's anything left:

    if (cxy != VECTOR_BATCH_SIZE)
    {
        ulTag >>= cxy;
        pxy    = axyBuf;
        cxy    = VECTOR_BATCH_SIZE - cxy;
        pulDma = (ULONG*) pjDma;

        CHECK_FIFO_SPACE(pjBase, 1);
        CP_WRITE_DMA(ppdev, pulDma, ulTag);
        pulDma++;

        CHECK_FIFO_SPACE(pjBase, cxy);
        do {
            CP_WRITE_DMA(ppdev, pulDma, *pxy);
            pulDma++;
            pxy++;

        } while (--cxy != 0);
    }

    VECTOR_WRITE_OFF(ppdev, pjBase, ulOpmode);
}

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line
    BYTE* pjBase;

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  MGA specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        pjBase = ppdev->pjBase;

        CHECK_FIFO_SPACE(pjBase, 9);

        // Turn off MGA's autolines:

        CP_WRITE(pjBase, DWG_DWGCTL, ppdev->ulLineControl & ~opcode_AUTO);
        CP_WRITE(pjBase, DWG_LEN,    cPels);
        CP_WRITE(pjBase, DWG_SGN,    gaiSign[fl & HW_FLIP_MASK]);
        CP_WRITE(pjBase, DWG_AR0,    dN);
        CP_WRITE(pjBase, DWG_AR1,    dN + lGamma);
        CP_WRITE(pjBase, DWG_AR2,    dN - dM);
        CP_WRITE(pjBase, DWG_XDST,   x + ppdev->xOffset);
        CP_START(pjBase, DWG_YDST,   y + ppdev->yOffset);

        // Turn MGA's autolines back on, because strip code and horizontal
        // and vertical line special cases expect it to be on:

        CP_WRITE(pjBase, DWG_DWGCTL, ppdev->ulLineControl);
    }

    return(TRUE);
}

/*******************************Public*Table*******************************\
* gapfnStrip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vStripSolidHorizontal,
    vStripSolidVertical,
    vStripSolidDiagonalHorizontal,
    vStripSolidDiagonalVertical,

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BYTE*     pjBase;
    RECTL*    prclClip;
    ULONG     ulLinePattern;
    ULONG     ulHwMix;
    PATHDATA  pd;
    BOOL      bMore;
    LONG      cptfx;
    POINTFIX  ptfxStartFigure;
    POINTFIX  ptfxLast;
    POINTFIX* pptfxFirst;
    POINTFIX* pptfxBuf;
    RECTFX    rcfxBounds;
    CLIPENUM  ce;
    LONG      i;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

// Pass the surface off to GDI if it's a device bitmap that we've
// converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;

//////////////////////////////////////////////////////////////////////
// MGA specific initialization:

    pjBase = ppdev->pjBase;

    CHECK_FIFO_SPACE(pjBase, 6);

    if (mix == 0x0d0d)      // R2_COPYPEN
    {
        ppdev->ulLineControl = (blockm_OFF + pattern_OFF + bltmod_BFCOL +
                                transc_BG_TRANSP + atype_RPL +
                                opcode_AUTOLINE_OPEN + bop_SRCCOPY +
                                solid_SOLID);
    }
    else
    {
        ulHwMix = (mix & 0xff) - 1;

        ppdev->ulLineControl = (blockm_OFF + pattern_OFF + bltmod_BFCOL +
                                transc_BG_TRANSP + atype_RSTR +
                                opcode_AUTOLINE_OPEN + solid_SOLID +
                                (ulHwMix << 16));
    }

    CP_WRITE(pjBase, DWG_DWGCTL, ppdev->ulLineControl);
    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, pbo->iSolidColor));

    if ((ppdev->ulBoardId != MGA_STORM) &&
        !(GET_CACHE_FLAGS(ppdev, PATTERN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SRC0, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC1, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC2, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC3, 0xFFFFFFFF);
    }

    ppdev->HopeFlags = PATTERN_CACHE;

//////////////////////////////////////////////////////////////////////
// Special case solid integer lines:

    if ((ppo->fl & PO_ALL_INTEGERS) &&
        !(pla->fl & LA_STYLED))
    {
    // As of NT 4.0 SP2, the rasterization convention has been loosened
    // for paths that have the PO_ALL_INTEGERS flag set.  For those paths,
    // you may do the 'tie-breaker' pixels anyway you like, which usually
    // means that you can use the point-to-point line drawing capabilities
    // of the hardware.
    //
    // HOWEVER: Your implementation must be invariant, regardless of clipping!
    //          This means that if you choose to deviate from the standard NT
    //          line convention, you MUST draw the same thing for DC_TRIVIAL,
    //          DC_RECT, *and* DC_COMPLEX clipping.

        if (pco->iDComplexity == DC_TRIVIAL)
        {
            vLinesSimple(ppdev, ppo);
            return(TRUE);
        }
        else
        {
        // We have to make sure that the path coordinates would not
        // overflow our hardware precision!  Note that the path's
        // bounds are still expressed as 28.4 coordinates even if
        // PO_ALL_INTEGERS or PO_ENUM_AS_INTEGERS is set:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);
            if ((rcfxBounds.xLeft   >= 16 * MIN_INTEGER_BOUND) &&
                (rcfxBounds.yTop    >= 16 * MIN_INTEGER_BOUND) &&
                (rcfxBounds.xRight  <= 16 * MAX_INTEGER_BOUND) &&
                (rcfxBounds.yBottom <= 16 * MAX_INTEGER_BOUND))
            {
                // NOTE that if you deviate from the standard NT line
                // convention for PO_ALL_INTEGERS flags, you must support
                // all clipping types!

                if (pco->iDComplexity == DC_RECT)
                {
                    vSetClipping(ppdev, &pco->rclBounds);
                    vLinesSimple(ppdev, ppo);
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                                       0);

                    do {
                        // Get a batch of region rectangles:

                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);
                        for (i = 0; i < ce.c; i++)
                        {
                            vSetClipping(ppdev, &ce.arcl[i]);
                            vLinesSimple(ppdev, ppo);
                        }
                    } while (bMore);
                }

                vResetClipping(ppdev);
                return(TRUE);
            }
        }
    }

    prclClip      = NULL;
    fl            = 0;
    ulLinePattern = (ULONG) -1;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if (pco->iDComplexity == DC_RECT)
    {
        fl |= FL_SIMPLE_CLIP;

        arclClip[0]        =  pco->rclBounds;

    // FL_FLIP_D:

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[1].right  =  pco->rclBounds.bottom;

    // FL_FLIP_V:

        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[2].right  =  pco->rclBounds.right;

    // FL_FLIP_V | FL_FLIP_D:

        arclClip[3].top    =  pco->rclBounds.left;
        arclClip[3].left   = -pco->rclBounds.bottom + 1;
        arclClip[3].bottom =  pco->rclBounds.right;
        arclClip[3].right  = -pco->rclBounds.top + 1;

        prclClip = arclClip;
    }

    apfn = &gapfnStrip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];


//////////////////////////////////////////////////////////////////////
// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
                break;

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLinesComplex(ppdev,
                                  pptfxFirst,
                                  pptfxBuf,
                                  (RUN*) NULL,
                                  cptfx,
                                  &ls,
                                  prclClip,
                                  apfn,
                                  fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLinesComplex(ppdev,
                                   &ptfxLast,
                                   &ptfxStartFigure,
                                   (RUN*) NULL,
                                   1,
                                   &ls,
                                   prclClip,
                                   apfn,
                                   fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLinesComplex(ppdev,
                                   &cl.cl.ptfxA,
                                   &cl.cl.ptfxB,
                                   &cl.cl.arun[0],
                                   cl.cl.c,
                                   &ls,
                                   (RECTL*) NULL,
                                   apfn,
                                   fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vStripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidDiagonalHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidDiagonalVertical(PDEV*, STRIP*, LINESTATE*);
VOID vStripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripStyledVertical(PDEV*, STRIP*, LINESTATE*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\lineto.c ===
/******************************Module*Header*******************************\
* Module Name: Lineto.c
*
* DrvLineTo for the driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// The MGA's hardware coordinates are limited to 16-bit signed values:

#define MIN_INTEGER_BOUND (-32767)
#define MAX_INTEGER_BOUND (32767)

/**************************************************************************
* Line Rasterization
*
* The 3D DDI's line rasterization rules are not as strict as are GDI's.
* In particular, the 3D DDI doesn't care how we handle 'tie-breakers,'
* where the true line falls exactly mid-way between two pixels, as long
* as we're consistent, particularly between unclipped and clipped lines.
*
* For this implementation, I've chosen to match GDI's convention so that
* I can share clipping code with the GDI line drawing routines.
*
* For integer lines, GDI's rule is that when a line falls exactly mid-way
* between two pixels, the upper or left pixel should be left.  For
* standard Bresenham, this means that we should bias the error term down
* by an infinitesimal amount in the following octants:
*
*         \   0 | 1   /
*           \   |   /
*         0   \ | /   0
*         -------------        1 - Indicates the quadrants in which
*         1   / | \   1            the error term should be biased
*           /   |   \
*         /   0 | 1   \
*
* The MGA's convention for numbering the qudrants is as follows, where
* 'sdydxl_MAJOR_X' = 1, 'sdxl_SUB' = 2, 'sdy_SUB' = 4:
*
*         \   2 | 0   /
*           \   |   /
*         3   \ | /   1
*         -------------
*         7   / | \   5
*           /   |   \
*         /   6 | 4   \
*
**************************************************************************/

LONG gaiLineBias[] = { 1, 1, 0, 1, 1, 0, 0, 0 };

/******************************Public*Routine******************************\
* VOID vLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line.
*
* We can't use the point-to-point capabilities of the MGA because its
* tie-breaker convention doesn't match that of NT's in two octants,
* and would cause us to fail HCTs.
*
\**************************************************************************/

VOID vLineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,
MIX         mix)
{
    BYTE*   pjBase;
    FLONG   flQuadrant;
    ULONG   ulHwMix;

    pjBase = ppdev->pjBase;

    CHECK_FIFO_SPACE(pjBase, 13);

    if (mix == 0x0d0d)      // R2_COPYPEN
    {
        CP_WRITE(pjBase, DWG_DWGCTL, blockm_OFF + pattern_OFF + bltmod_BFCOL +
                         transc_BG_TRANSP + atype_RPL + bop_SRCCOPY);
    }
    else
    {
        ulHwMix = (mix & 0xff) - 1;

        CP_WRITE(pjBase, DWG_DWGCTL, blockm_OFF + pattern_OFF + bltmod_BFCOL +
                         transc_BG_TRANSP + atype_RSTR + (ulHwMix << 16));
    }

    CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, iSolidColor));

    if (!(GET_CACHE_FLAGS(ppdev, PATTERN_CACHE)))
    {
        CP_WRITE(pjBase, DWG_SRC0, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC1, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC2, 0xFFFFFFFF);
        CP_WRITE(pjBase, DWG_SRC3, 0xFFFFFFFF);
    }

    ppdev->HopeFlags = PATTERN_CACHE;

    CP_START(pjBase, DWG_XDST, x);
    CP_START(pjBase, DWG_YDST, y);

    flQuadrant = sdydxl_MAJOR_X;

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant |= sdxl_SUB;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant |= sdy_SUB;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant &= ~sdydxl_MAJOR_X;
    }

    CP_WRITE(pjBase, DWG_SGN, flQuadrant);
    CP_WRITE(pjBase, DWG_LEN, dx);
    CP_WRITE(pjBase, DWG_AR0, dy);
    CP_WRITE(pjBase, DWG_AR2, dy - dx);
    CP_START(pjBase, DWG_AR1, (dy + dy - dx - gaiLineBias[flQuadrant]) >> 1);
}

/******************************Public*Routine******************************\
* VOID vLineToClipped
*
* Draws a single solid integer-only clipped cosmetic line using
* 'New MM I/O'.
*
\**************************************************************************/

VOID vLineToClipped(
PDEV*       ppdev,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
ULONG       iSolidColor,
MIX         mix,
RECTL*      prclClip)
{
    vSetClipping(ppdev, prclClip);
    vLineToTrivial(ppdev, x1, y1, x2, y2, iSolidColor, mix);
    vResetClipping(ppdev);
}

/******************************Public*Routine******************************\
* BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* Draws a single solid integer-only cosmetic line.
*
\**************************************************************************/

BOOL DrvLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    OH*     poh;
    LONG    xOffset;
    LONG    yOffset;
    BOOL    bRet;

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;

    xOffset = poh->x;
    yOffset = poh->y;

    x1 += xOffset;
    x2 += xOffset;
    y1 += yOffset;
    y2 += yOffset;

    bRet = TRUE;

    if (pco == NULL)
    {
        vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
    }
    else if ((pco->iDComplexity <= DC_RECT) &&
             (prclBounds->left   >= MIN_INTEGER_BOUND) &&
             (prclBounds->top    >= MIN_INTEGER_BOUND) &&
             (prclBounds->right  <= MAX_INTEGER_BOUND) &&
             (prclBounds->bottom <= MAX_INTEGER_BOUND))
    {
        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;

        vLineToClipped(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix,
                                  &pco->rclBounds);
    }
    else
    {
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcd.c ===
/******************************Module*Header*******************************\
* Module Name: mcd.c
*
* Main file for the Matrox Millenium OpenGL MCD driver.  This file contains
* the entry points needed for an MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include <excpt.h>
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#define FAIL_ALL_DRAWING    0
#define FORCE_SYNC          0

#define TOTAL_PIXEL_FORMATS (2 * 2)     // double-buffers * z-buffers


// Base color pixel formats

static DRVPIXELFORMAT drvFormats[] = { {8,   3, 3, 2, 0,    5, 2, 0, 0},
                                       {16,  5, 5, 5, 0,   10, 5, 0, 0},
                                       {16,  5, 6, 5, 0,   11, 5, 0, 0},
                                       {24,  8, 8, 8, 0,   16, 8, 0, 0},
                                       {32,  8, 8, 8, 0,   16, 8, 0, 0},
                                     };


LONG MCDrvDescribePixelFormat(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                              ULONG nBytes, MCDPIXELFORMAT *pMCDPixelFormat,
                              ULONG flags)
{
    BOOL zEnabled;
    BOOL doubleBufferEnabled;
    DRVPIXELFORMAT *pDrvPixelFormat;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

//    MCDBG_PRINT("MCDrvDescribePixelFormat");

    if (!pMCDPixelFormat) {

        // We don't support 24bpp or the older MGA:

        if ((ppdev->ulBoardId != MGA_STORM) ||
            (ppdev->iBitmapFormat == BMF_24BPP))
            return 0;

        return TOTAL_PIXEL_FORMATS;
    }

    if (nBytes < sizeof(MCDPIXELFORMAT))
        return 0;

    if (iPixelFormat > TOTAL_PIXEL_FORMATS)
        return 0;

    // We don't support the older MGA in this driver:

    if (ppdev->ulBoardId != MGA_STORM)
        return 0;

    iPixelFormat--;

    zEnabled = iPixelFormat >= (TOTAL_PIXEL_FORMATS / 2);
    doubleBufferEnabled = (iPixelFormat % (TOTAL_PIXEL_FORMATS / 2) ) >=
                          (TOTAL_PIXEL_FORMATS / 4);

    pMCDPixelFormat->nSize = sizeof(MCDPIXELFORMAT);
    pMCDPixelFormat->dwFlags = PFD_SWAP_COPY;
    if (doubleBufferEnabled)
        pMCDPixelFormat->dwFlags |= PFD_DOUBLEBUFFER;
    pMCDPixelFormat->iPixelType = PFD_TYPE_RGBA;

    switch (ppdev->iBitmapFormat) {
        default:
        case BMF_8BPP:
            pDrvPixelFormat = &drvFormats[0];
            pMCDPixelFormat->dwFlags |= (PFD_NEED_SYSTEM_PALETTE | PFD_NEED_PALETTE);
            break;
        case BMF_16BPP:
            if (ppdev->flGreen != 0x7e0)    // not 565
                pDrvPixelFormat = &drvFormats[1];
            else
                pDrvPixelFormat = &drvFormats[2];
            break;
        case BMF_24BPP:     // The Millenium doesn't do 3D at 24bpp!
            return 0;
        case BMF_32BPP:
            pDrvPixelFormat = &drvFormats[4];
            break;
    }

    pMCDPixelFormat->cColorBits  = pDrvPixelFormat->cColorBits;
    pMCDPixelFormat->cRedBits    = pDrvPixelFormat->rBits;
    pMCDPixelFormat->cGreenBits  = pDrvPixelFormat->gBits;
    pMCDPixelFormat->cBlueBits   = pDrvPixelFormat->bBits;
    pMCDPixelFormat->cAlphaBits  = pDrvPixelFormat->aBits;
    pMCDPixelFormat->cRedShift   = pDrvPixelFormat->rShift;
    pMCDPixelFormat->cGreenShift = pDrvPixelFormat->gShift;
    pMCDPixelFormat->cBlueShift  = pDrvPixelFormat->bShift;
    pMCDPixelFormat->cAlphaShift = pDrvPixelFormat->aShift;

    if (zEnabled)
    {
        pMCDPixelFormat->cDepthBits       = 16;
        pMCDPixelFormat->cDepthBufferBits = 16;
        pMCDPixelFormat->cDepthShift      = 16;
    }
    else
    {
        pMCDPixelFormat->cDepthBits       = 0;
        pMCDPixelFormat->cDepthBufferBits = 0;
        pMCDPixelFormat->cDepthShift      = 0;
    }

    // MGA does not support stencil; generic will supply a software
    // implementation as necessary.

    pMCDPixelFormat->cStencilBits = 0;

    pMCDPixelFormat->cOverlayPlanes = 0;
    pMCDPixelFormat->cUnderlayPlanes = 0;
    pMCDPixelFormat->dwTransparentColor = 0;

    return TOTAL_PIXEL_FORMATS;
}


BOOL MCDrvDescribeLayerPlane(MCDSURFACE *pMCDSurface,
                             LONG iPixelFormat, LONG iLayerPlane,
                             ULONG nBytes, MCDLAYERPLANE *pMCDLayerPlane,
                             ULONG flags)
{
    //MCDBG_PRINT("MCDrvDescribeLayerPlane");

    return FALSE;
}


LONG MCDrvSetLayerPalette(MCDSURFACE *pMCDSurface, LONG iLayerPlane,
                          BOOL bRealize, LONG cEntries, COLORREF *pcr)
{
    //MCDBG_PRINT("MCDrvSetLayerPalette");

    return 0;
}


BOOL MCDrvInfo(MCDSURFACE *pMCDSurface, MCDDRIVERINFO *pMCDDriverInfo)
{
//    MCDBG_PRINT("MCDrvInfo");

    pMCDDriverInfo->verMajor = MCD_VER_MAJOR;
    pMCDDriverInfo->verMinor = MCD_VER_MINOR;
    pMCDDriverInfo->verDriver = 0x10000;
    strcpy(pMCDDriverInfo->idStr, "Matrox STORM (Microsoft)");
    pMCDDriverInfo->drvMemFlags = 0;
    pMCDDriverInfo->drvBatchMemSizeMax = 128000;

    return TRUE;
}


ULONG MCDrvCreateContext(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                         MCDRCINFO *pRcInfo)
{
    DEVRC *pRc;
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    DRVPIXELFORMAT *pDrvPixelFormat;
    MCDVERTEX *pv;
    BOOL zEnabled;
    BOOL doubleBufferEnabled;
    ULONG i, maxVi;

//    MCDBG_PRINT("MCDrvCreateContext");

    // We only support window surfaces:

    if (! (pMCDSurface->surfaceFlags & MCDSURFACE_HWND) )
        return FALSE;

    // We don't support the older MGA in this driver:

    if (ppdev->ulBoardId != MGA_STORM)
        return FALSE;

    if ((pMCDRc->iPixelFormat > TOTAL_PIXEL_FORMATS) ||
        (pMCDRc->iPixelFormat < 0)) {
        MCDBG_PRINT("MCDrvCreateContext: bad pixel format");
        return FALSE;
    }

    // We don't support overlay planes:

    if (pMCDRc->iLayerPlane)
        return FALSE;

    pRc = pMCDRc->pvUser = (DEVRC *)MCDAlloc(sizeof(DEVRC));

    if (!pRc) {
        MCDBG_PRINT("MCDrvCreateContext: couldn't allocate DEVRC");
        return FALSE;
    }

    zEnabled = (pMCDRc->iPixelFormat - 1) >= (TOTAL_PIXEL_FORMATS / 2);
    doubleBufferEnabled = ((pMCDRc->iPixelFormat - 1) % (TOTAL_PIXEL_FORMATS / 2) ) >=
                          (TOTAL_PIXEL_FORMATS / 4);

    pRc->zBufEnabled = zEnabled;
    pRc->backBufEnabled = doubleBufferEnabled;

    switch (ppdev->iBitmapFormat) {
        default:
        case BMF_8BPP:
            pDrvPixelFormat = &drvFormats[0];
            pRc->hwBpp = 1;
            break;
        case BMF_16BPP:
            if (ppdev->flGreen != 0x7e0)    // not 565
                pDrvPixelFormat = &drvFormats[1];
            else
                pDrvPixelFormat = &drvFormats[2];
            pRc->hwBpp = 2;
            break;
        case BMF_24BPP:     // The Millenium doesn't do 3D at 24bpp!
            MCDFree(pMCDRc->pvUser);
            pMCDRc->pvUser = NULL;
            MCDBG_PRINT("MCDrvCreateContext: device doesn't support 24 bpp");
            return FALSE;
        case BMF_32BPP:
            pDrvPixelFormat = &drvFormats[4];
            pRc->hwBpp = 4;
            break;
    }

    pRc->pixelFormat = *pDrvPixelFormat;

    // If we're not yet tracking this window, allocate the per-window DEVWND
    // structure for maintaining per-window info such as front/back/z buffer
    // resources:

    if (!pMCDWnd->pvUser) {
        pDevWnd = pMCDWnd->pvUser = (DEVWND *)MCDAlloc(sizeof(DEVWND));
        if (!pDevWnd) {
            MCDFree(pMCDRc->pvUser);
            pMCDRc->pvUser = NULL;
            MCDBG_PRINT("MCDrvCreateContext: couldn't allocate DEVWND");
            return FALSE;
        }
        pDevWnd->createFlags = pMCDRc->createFlags;
        pDevWnd->iPixelFormat = pMCDRc->iPixelFormat;
        pDevWnd->dispUnique = GetDisplayUniqueness(ppdev);
    } else {

        // We already have a per-window DEVWND structure tracking this window.
        // In this case, do a sanity-check on the pixel format for this
        // context, since a window's pixel format can not changed once it has
        // set (by the first context bound to the window).  So, if the pixel
        // format for the incoming context doesn't match the current pixel
        // format for the window, we have to fail context creation:

        pDevWnd = pMCDWnd->pvUser;

        if (pDevWnd->iPixelFormat != pMCDRc->iPixelFormat) {
            MCDFree(pMCDRc->pvUser);
            pMCDRc->pvUser = NULL;
            MCDBG_PRINT("MCDrvCreateContext: mismatched pixel formats, window = %d, context = %d",
                        pDevWnd->iPixelFormat, pMCDRc->iPixelFormat);
            return FALSE;
        }
    }

    pRc->pEnumClip = pMCDSurface->pWnd->pClip;

    // Set up our color scale values so that color components are
    // normalized to 0..7fffff

    // We also need to make sure we don't fault due to bad FL data as well...

    try {

    if (pRcInfo->redScale != (MCDFLOAT)0.0)
        pRc->rScale = (MCDFLOAT)(0x7fffff) / pRcInfo->redScale;
    else
        pRc->rScale = (MCDFLOAT)0.0;

    if (pRcInfo->greenScale != (MCDFLOAT)0.0)
        pRc->gScale = (MCDFLOAT)(0x7fffff) / pRcInfo->greenScale;
    else
        pRc->gScale = (MCDFLOAT)0.0;

    if (pRcInfo->blueScale != (MCDFLOAT)0.0)
        pRc->bScale = (MCDFLOAT)(0x7fffff) / pRcInfo->blueScale;
    else
        pRc->bScale = (MCDFLOAT)0.0;

    // Normalize alpha to 0..ff0000

    if (pRcInfo->alphaScale != (MCDFLOAT)0.0)
        pRc->aScale = (MCDFLOAT)(0xff0000) / pRcInfo->alphaScale;
    else
        pRc->aScale = (MCDFLOAT)0.0;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvCreateContext!!");
        return FALSE;
    }

    pRc->zScale = (MCDFLOAT)32767.0;

    pRc->pickNeeded = TRUE;         // We'll definitely need to re-pick
                                    // our rendering functions
    pRc->bRGBMode = TRUE;           // We only support RGB mode

    pRc->zero = __MCDZERO;

    // Initialize the pColor pointer in the clip buffer:

    for (i = 0, pv = &pRc->clipTemp[0],
         maxVi = sizeof(pRc->clipTemp) / sizeof(MCDVERTEX);
         i < maxVi; i++, pv++) {
        pv->pColor = &pv->colors[__MCD_FRONTFACE];
    }

    // Set up those rendering functions which are state-invariant:

    pRc->clipLine = __MCDClipLine;
    pRc->clipTri = __MCDClipTriangle;
    pRc->clipPoly = __MCDClipPolygon;
    pRc->doClippedPoly = __MCDDoClippedPolygon;

    pRc->beginPointDrawing = __MCDPointBegin;

    pRc->beginLineDrawing = __MCDLineBegin;
    pRc->endLineDrawing = __MCDLineEnd;

    pRc->viewportXAdjust = pRcInfo->viewportXAdjust;
    pRc->viewportYAdjust = pRcInfo->viewportYAdjust;

#ifdef TEST_REQ_FLAGS
    pRcInfo->requestFlags = MCDRCINFO_NOVIEWPORTADJUST |
                            MCDRCINFO_Y_LOWER_LEFT |
                            MCDRCINFO_DEVCOLORSCALE |
                            MCDRCINFO_DEVZSCALE;

    pRcInfo->redScale = (MCDFLOAT)1.0;
    pRcInfo->greenScale = (MCDFLOAT)1.0;
    pRcInfo->blueScale = (MCDFLOAT)1.0;
    pRcInfo->alphaScale = (MCDFLOAT)1.0;

    pRcInfo->zScale = 0.99991;
#endif

    return TRUE;
}


ULONG MCDrvDeleteContext(MCDRC *pRc, DHPDEV dhpdev)
{
//    MCDBG_PRINT("MCDrvDeleteContext");

    if (pRc->pvUser) {
        MCDFree(pRc->pvUser);
        pRc->pvUser = NULL;
    }

    return (ULONG)TRUE;
}


ULONG MCDrvAllocBuffers(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    BOOL bZBuffer = (pDevWnd->pohZBuffer != NULL);
    BOOL bBackBuffer = (pDevWnd->pohBackBuffer != NULL);

//    MCDBG_PRINT("MCDrvAllocBuffers");

    // Reject the call if we've already done an allocation for this window:

    if ((bZBuffer || bBackBuffer) &&
        ((DEVWND *)pMCDWnd->pvUser)->dispUnique == GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev)) {

//        MCDBG_PRINT("MCDrvAllocBuffer: warning-attemp to allocate buffers \
//without a matching free");
        return (bZBuffer == pRc->zBufEnabled) &&
               (bBackBuffer == pRc->backBufEnabled);
    }

    // Update the display resolution uniqueness for this window:

    ((DEVWND *)pMCDWnd->pvUser)->dispUnique = GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev);

    return (ULONG)HWAllocResources(pMCDSurface->pWnd, pMCDSurface->pso,
                                   pRc->zBufEnabled, pRc->backBufEnabled);
}


ULONG MCDrvGetBuffers(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                      MCDBUFFERS *pMCDBuffers)
{
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

//    MCDBG_PRINT("MCDrvGetBuffers");

    if (pMCDRc) {
        MCD_CHECK_BUFFERS_VALID(pMCDSurface, (DEVRC *)pMCDRc->pvUser, FALSE);
    } else {
        MCD_CHECK_DEVWND(pMCDSurface, pDevWnd, FALSE);
    }

    pMCDBuffers->mcdFrontBuf.bufFlags = MCDBUF_ENABLED;
    pMCDBuffers->mcdFrontBuf.bufOffset =
        (pMCDWnd->clientRect.top * ppdev->lDelta) +
        (pMCDWnd->clientRect.left * ppdev->cjHwPel);
    pMCDBuffers->mcdFrontBuf.bufStride = ppdev->lDelta;

    if (pDevWnd->bValidBackBuffer) {
        pMCDBuffers->mcdBackBuf.bufFlags = MCDBUF_ENABLED;
        if ((ppdev->cDoubleBufferRef == 1) || (pMCDWnd->pClip->c == 1))
            pMCDBuffers->mcdBackBuf.bufFlags |= MCDBUF_NOCLIP;
    } else {
        pMCDBuffers->mcdBackBuf.bufFlags = 0;
    }
    if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {
        pMCDBuffers->mcdBackBuf.bufOffset =
            (pMCDWnd->clientRect.top * ppdev->lDelta) +
            (pMCDWnd->clientRect.left * ppdev->cjHwPel) +
            pDevWnd->backBufferOffset;
    } else {
        pMCDBuffers->mcdBackBuf.bufOffset =
            (pMCDWnd->clientRect.left * ppdev->cjHwPel) +
            pDevWnd->backBufferOffset;
    }
    pMCDBuffers->mcdBackBuf.bufStride = ppdev->lDelta;

    if (pDevWnd->bValidZBuffer) {
        pMCDBuffers->mcdDepthBuf.bufFlags = MCDBUF_ENABLED;
        if ((ppdev->cZBufferRef == 1) || (pMCDWnd->pClip->c == 1))
            pMCDBuffers->mcdDepthBuf.bufFlags |= MCDBUF_NOCLIP;
    } else {
        pMCDBuffers->mcdDepthBuf.bufFlags = 0;
    }
    if (ppdev->pohZBuffer == pDevWnd->pohZBuffer) {
        pMCDBuffers->mcdDepthBuf.bufOffset =
            ((pMCDWnd->clientRect.top * ppdev->cxMemory) +
             pMCDWnd->clientRect.left) * 2 +
            pDevWnd->zBufferOffset;
    } else {
        pMCDBuffers->mcdDepthBuf.bufOffset =
            (pMCDWnd->clientRect.left * 2) + pDevWnd->zBufferOffset;
    }

    // The pointer to the start of the frame buffer is adjusted for ulYDstOrg,
    // so we have to redo that adjustment for the depth buffer:

    if (ppdev->ulYDstOrg) {
        pMCDBuffers->mcdDepthBuf.bufOffset +=
            (ppdev->ulYDstOrg * 2) - (ppdev->ulYDstOrg * ppdev->cjHwPel);
    }

    pMCDBuffers->mcdDepthBuf.bufStride = ppdev->cxMemory * 2;

    return (ULONG)TRUE;
}


ULONG MCDrvCreateMem(MCDSURFACE *pMCDSurface, MCDMEM *pMCDMem)
{
//    MCDBG_PRINT("MCDrvCreateMem");
    return (ULONG)TRUE;
}


ULONG MCDrvDeleteMem(MCDMEM *pMCDMem, DHPDEV dhpdev)
{
//    MCDBG_PRINT("MCDrvDeleteMem");
    return (ULONG)TRUE;
}


ULONG_PTR MCDrvDraw(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *prxExecMem,
                UCHAR *pStart, UCHAR *pEnd)
{
    MCDCOMMAND *pCmd = (MCDCOMMAND *)pStart;
    MCDCOMMAND *pCmdNext;
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);

    CHOP_ROUND_ON();

#if TEST_3D_NO_DRAW
    CHOP_ROUND_OFF();
    return (ULONG)0;
#endif


//    MCDBG_PRINT("MCDrvDraw");

    // Make sure we have both a valid RC and window structure:

    if (!pRc || !pDevWnd)
        goto DrawExit;

    pRc->ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

#if FAIL_ALL_DRAWING
    goto DrawExit;
#endif

    //
    // If the resolution has changed and we have not yet updated our
    // buffers, fail the call gracefully since the client won't be
    // able to perform any software simulations at this point either.
    // This applies to any of the other drawing functions as well (such
    // as spans and clears).
    //

    if (pDevWnd->dispUnique != GetDisplayUniqueness(pRc->ppdev)) {

        MCDBG_PRINT("MCDrvDraw: invalid (changed) resolution");

        CHOP_ROUND_OFF();
        return (ULONG)0;
    }

    if ((pRc->zBufEnabled && !pDevWnd->bValidZBuffer) ||
        (pRc->backBufEnabled && !pDevWnd->bValidBackBuffer)) {

        MCDBG_PRINT("MCDrvDraw has invalid buffers");

        goto DrawExit;
    }

    // re-pick the rendering functions if we've have a state change:

    if (pRc->pickNeeded) {
        __MCDPickRenderingFuncs(pRc, pDevWnd);
        __MCDPickClipFuncs(pRc);
        pRc->pickNeeded = FALSE;
    }

    // If we're completely clipped, return success:

    pRc->pEnumClip = pMCDSurface->pWnd->pClip;

    if (!pRc->pEnumClip->c) {
        CHOP_ROUND_OFF();
        return (ULONG)0;
    }

    // return here if we can't draw any primitives:

    if (pRc->allPrimFail) {
        goto DrawExit;
    }

    // Set these up in the device's RC so we can just pass a single pointer
    // to do everything:

    pRc->pMCDSurface = pMCDSurface;
    pRc->pMCDRc = pMCDRc;

    pRc->xOffset = pMCDSurface->pWnd->clientRect.left -
                   pRc->viewportXAdjust;

    pRc->yOffset = (pMCDSurface->pWnd->clientRect.top -
                    pMCDSurface->pWnd->clipBoundsRect.top) -
                   pRc->viewportYAdjust;

    pRc->pMemMin = pStart;
    pRc->pvProvoking = (MCDVERTEX *)pStart;     // bulletproofing
    pRc->pMemMax = pEnd - sizeof(MCDVERTEX);

    // warm up the hardware for drawing primitives:

    HW_INIT_DRAWING_STATE(pMCDSurface, pMCDSurface->pWnd, pRc);
    HW_INIT_PRIMITIVE_STATE(pMCDSurface, pRc);

    // If we have a single clipping rectangle, set it up in the hardware once
    // for this batch:

    if (pRc->pEnumClip->c == 1)
        (*pRc->HWSetupClipRect)(pRc, &pRc->pEnumClip->arcl[0]);

    // Now, loop through the commands and process the batch:


    try {
        while (pCmd && (UCHAR *)pCmd < pEnd) {

            volatile ULONG command = pCmd->command;

            // Make sure we can read at least the command header:

            if ((pEnd - (UCHAR *)pCmd) < sizeof(MCDCOMMAND))
                goto DrawExit;

            if (command <= GL_POLYGON) {

                if (pCmd->flags & MCDCOMMAND_RENDER_PRIMITIVE)
                    pCmdNext = (*pRc->primFunc[command])(pRc, pCmd);
                else
                    pCmdNext = pCmd->pNextCmd;

                if (pCmdNext == pCmd)
                    goto DrawExit;           // primitive failed
                if (!(pCmd = pCmdNext)) {    // we're done with the batch
                    CHOP_ROUND_OFF();
                    HW_DEFAULT_STATE(pMCDSurface);
#if FORCE_SYNC
                    HW_WAIT_DRAWING_DONE(pRc);
#endif
                    return (ULONG)0;
                }
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvDraw!!");

        CHOP_ROUND_OFF();
        HW_DEFAULT_STATE(pMCDSurface);
        HW_WAIT_DRAWING_DONE(pRc);

        return (ULONG_PTR)pCmd;
    }

DrawExit:
    CHOP_ROUND_OFF();

    // restore the hardware state:

    HW_DEFAULT_STATE(pMCDSurface);
    HW_WAIT_DRAWING_DONE(pRc);

    return (ULONG_PTR)pCmd;    // some sort of overrun has occurred
}


ULONG MCDrvClear(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, ULONG buffers)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDWINDOW *pWnd;
    ULONG cClip;
    RECTL *pClip;

//    MCDBG_PRINT("MCDrvClear");

    MCD_CHECK_RC(pRc);

    pWnd = pMCDSurface->pWnd;

    MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, TRUE);

    pRc->ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

#if FAIL_ALL_DRAWING && OKOK
    {
        HW_WAIT_DRAWING_DONE(pRc);
        return FALSE;
    }
#endif

    if (buffers & ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                    GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)) {
        HW_WAIT_DRAWING_DONE(pRc);
        return FALSE;
    }

    if ((buffers & GL_DEPTH_BUFFER_BIT) && (!pRc->zBufEnabled))
    {
        MCDBG_PRINT("MCDrvClear: clear z requested with z-buffer disabled.");
        HW_WAIT_DRAWING_DONE(pRc);
        return FALSE;
    }

    if (buffers & (GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)) {
        HW_WAIT_DRAWING_DONE(pRc);
        return FALSE;
    }

    // Return if we have nothing to clear:

    if (!(cClip = pWnd->pClip->c))
        return TRUE;

    // Initialize hardware state for filling operation:

    HW_INIT_DRAWING_STATE(pMCDSurface, pMCDSurface->pWnd, pRc);

    // We have to protect against bad clear colors since this can
    // potentially cause an FP exception:

    try {

        HW_START_FILL_RECT(pMCDSurface, pMCDRc, pRc, buffers);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvClear!!");
        return FALSE;
    }


    for (pClip = &pWnd->pClip->arcl[0]; cClip; cClip--,
         pClip++)
    {
        // Do the fill:

        HW_FILL_RECT(pMCDSurface, pRc, pClip);
    }

    HW_DEFAULT_STATE(pMCDSurface);

#if FORCE_SYNC
    HW_WAIT_DRAWING_DONE(pRc);
#endif

    return (ULONG)TRUE;
}


ULONG MCDrvSwap(MCDSURFACE *pMCDSurface, ULONG flags)
{
    MCDWINDOW *pWnd;
    ULONG cClip;
    RECTL *pClip;
    POINTL ptSrc;
    ULONG vCount, vCountLast;
    ULONG scanTarget;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    ULONG scanMax;
    ULONG maxScanOffset;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    LONG hwBufferYBias;

//    MCDBG_PRINT("MCDrvSwap");

    pWnd = pMCDSurface->pWnd;

    // If we're not tracking this window, just return...

    if (!pWnd) {
        MCDBG_PRINT("MCDrvSwap: trying to swap an untracked window");\
        return FALSE;
    }

    if (!pDevWnd) {
        MCDBG_PRINT("MCDrvSwap: NULL buffers.");\
        return FALSE;
    }

    if (!pDevWnd->bValidBackBuffer) {
        MCDBG_PRINT("MCDrvSwap: back buffer invalid");
        return FALSE;
    }

    if (pDevWnd->dispUnique != GetDisplayUniqueness(ppdev)) {
        MCDBG_PRINT("MCDrvSwap: resolution changed but not updated");
        return FALSE;
    }

    // Just return if we have nothing to swap:
    //
    //      - no visible rectangle
    //      - per-plane swap, but none of the specified planes
    //        are supported by driver

    if (!(cClip = pWnd->pClipUnscissored->c) ||
        (flags && !(flags & MCDSWAP_MAIN_PLANE)))
        return TRUE;

    HW_START_SWAP_BUFFERS(pMCDSurface, &hwBufferYBias, flags);

    // Wait for sync if we can do a fast blt:

    if ((pDevWnd->createFlags & MCDCONTEXT_SWAPSYNC) &&
        ((pWnd->clientRect.bottom + pDevWnd->backBufferY) <= (ULONG)ppdev->ayBreak[0])) {

        LONG vCount, vCountLast;
        LONG scanTarget = pWnd->clientRect.bottom;
        LONG scanMax = ppdev->cyScreen - 1;

        scanTarget = min(scanTarget, scanMax);

        vCount = vCountLast = HW_GET_VCOUNT(ppdev->pjBase);

        while ((vCount < scanTarget) && ((vCount - vCountLast) >= 0)) {
            vCountLast = vCount;
            vCount = HW_GET_VCOUNT(ppdev->pjBase);
        }
    }

    pClip = &pWnd->pClipUnscissored->arcl[0];
    ptSrc.x = pWnd->clipBoundsRect.left;
    ptSrc.y = pWnd->clipBoundsRect.top + hwBufferYBias;

    // Swap all of the clip rectangles in the backbuffer to the front:

    ppdev->xOffset = 0;
    ppdev->yOffset = 0;

    vMilCopyBlt(ppdev, cClip, pClip, 0xcccc,
                &ptSrc, &pWnd->clipBoundsRect);

    HW_DEFAULT_STATE(pMCDSurface);

    return (ULONG)TRUE;
}


ULONG MCDrvState(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *pMCDMem,
                     UCHAR *pStart, LONG length, ULONG numStates)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDSTATE *pState = (MCDSTATE *)pStart;
    MCDSTATE *pStateEnd = (MCDSTATE *)(pStart + length);

//    MCDBG_PRINT("MCDrvState");

    MCD_CHECK_RC(pRc);

    while (pState < pStateEnd) {

        if (((UCHAR *)pStateEnd - (UCHAR *)pState) < sizeof(MCDSTATE)) {
            MCDBG_PRINT("MCDrvState: buffer too small");
            return FALSE;
        }

        switch (pState->state) {
            case MCD_RENDER_STATE:
                if (((UCHAR *)pState + sizeof(MCDRENDERSTATE)) >
                    (UCHAR *)pStateEnd)
                    return FALSE;

                memcpy(&pRc->MCDState, &pState->stateValue,
                       sizeof(MCDRENDERSTATE));

                // Flag the fact that we need to re-pick the
                // rendering functions:

                pRc->pickNeeded = TRUE;

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_RENDER));
                break;

            case MCD_PIXEL_STATE:
                // Not accelerated in this driver, so we can ignore this state
                // (which implies that we do not need to set the pick flag).

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_PIXEL));
                break;

            case MCD_SCISSOR_RECT_STATE:
                // Not needed in this driver, so we can ignore this state
                // (which implies that we do not need to set the pick flag).

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_SCISSOR_RECT));
                break;

            default:
                MCDBG_PRINT("MCDrvState: Unrecognized state %d.", pState->state);
                return FALSE;
        }
    }

    return (ULONG)TRUE;
}


ULONG MCDrvViewport(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                    MCDVIEWPORT *pMCDViewport)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;

//    MCDBG_PRINT("MCDrvViewport");

    MCD_CHECK_RC(pRc);

    pRc->MCDViewport = *pMCDViewport;

    return (ULONG)TRUE;
}

HDEV  MCDrvGetHdev(MCDSURFACE *pMCDSurface)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

//    MCDBG_PRINT("MCDrvGetHdev");

    return ppdev->hdevEng;
}


ULONG MCDrvSpan(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *pMCDMem,
                MCDSPAN *pMCDSpan, BOOL bRead)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    UCHAR *pScreen;
    UCHAR *pPixels;
    MCDWINDOW *pWnd;
    DEVWND *pDevWnd;
    LONG xLeftOrg, xLeft, xRight, y;
    LONG bufferYBias;
    ULONG bytesNeeded;
    ULONG cjHwPel;

//    MCDBG_PRINT("MCDrvSpan: read %d, (%d, %d) type %d", bRead, pMCDSpan->x, pMCDSpan->y, pMCDSpan->type);

    MCD_CHECK_RC(pRc);

    pWnd = pMCDSurface->pWnd;

    // Return if we have nothing to clip:

    if (!pWnd->pClip->c)
        return TRUE;

    // Fail if number of pixels is negative:

    if (pMCDSpan->numPixels < 0) {
        MCDBG_PRINT("MCDrvSpan: numPixels < 0");
        return FALSE;
    }

    MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, TRUE);

    pDevWnd = (DEVWND *)pWnd->pvUser;

    xLeft = xLeftOrg = (pMCDSpan->x + pWnd->clientRect.left);
    xRight = (xLeft + pMCDSpan->numPixels);
    y = pMCDSpan->y + pWnd->clientRect.top;

    // Early-out spans which are not visible:

    if ((y < pWnd->clipBoundsRect.top) ||
        (y >= pWnd->clipBoundsRect.bottom))
        return TRUE;

    xLeft   = max(xLeft, pWnd->clipBoundsRect.left);
    xRight  = min(xRight, pWnd->clipBoundsRect.right);

    // Return if empty:

    if (xLeft >= xRight)
        return TRUE;

    switch (pMCDSpan->type) {
        case MCDSPAN_FRONT:
//MCDBG_PRINT("MCDrvSpan: MCDSPAN_FRONT");
            cjHwPel = ppdev->cjHwPel;
            pScreen = ppdev->pjScreen + (ppdev->ulYDstOrg * cjHwPel);
            bytesNeeded = pMCDSpan->numPixels * cjHwPel;
            pScreen += ((y * ppdev->lDelta) +
                        (xLeft * cjHwPel));
            break;

        case MCDSPAN_BACK:
//MCDBG_PRINT("MCDrvSpan: MCDSPAN_BACK");
            cjHwPel = ppdev->cjHwPel;
            pScreen = ppdev->pjScreen + (ppdev->ulYDstOrg * cjHwPel);
            bytesNeeded = pMCDSpan->numPixels * cjHwPel;
            if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {
                pScreen += ((y * ppdev->lDelta) +
                            (xLeft * cjHwPel) +
                            pDevWnd->backBufferOffset);
            } else {
                pScreen += (((y - pWnd->clipBoundsRect.top) * ppdev->lDelta) +
                            (xLeft * cjHwPel) +
                            pDevWnd->backBufferOffset);
            }

            break;

        case MCDSPAN_DEPTH:
//MCDBG_PRINT("MCDrvSpan: MCDSPAN_DEPTH");
            cjHwPel = 2;                                // Z is always 16bpp
            pScreen = ppdev->pjScreen + (ppdev->ulYDstOrg << 1);
            bytesNeeded = pMCDSpan->numPixels * 2;
            if (ppdev->pohZBuffer == pDevWnd->pohZBuffer) {
                pScreen += (((y * ppdev->cxScreen + xLeft) * 2) +
                            pDevWnd->zBufferOffset);
            } else {
                pScreen += (((((y - pWnd->clipBoundsRect.top) * ppdev->cxScreen) + xLeft) * 2) +
                             pDevWnd->zBufferOffset);
            }

            break;
        default:
            MCDBG_PRINT("MCDrvReadSpan: Unrecognized buffer %d", pMCDSpan->type);
            return FALSE;
    }

    // Make sure we don't read past the end of the buffer:

    if (((char *)pMCDSpan->pPixels + bytesNeeded) >
        ((char *)pMCDMem->pMemBase + pMCDMem->memSize)) {
        MCDBG_PRINT("MCDrvSpan: Buffer too small");
        return FALSE;
    }

    WAIT_NOT_BUSY(ppdev->pjBase);

    pPixels = pMCDSpan->pPixels;

    if (bRead) {
        if (xLeftOrg != xLeft)
            pPixels = (UCHAR *)pMCDSpan->pPixels + ((xLeft - xLeftOrg) * cjHwPel);

        RtlCopyMemory(pPixels, pScreen, (xRight - xLeft) * cjHwPel);
    } else {
        LONG xLeftClip, xRightClip, yClip;
        RECTL *pClip;
        ULONG cClip;

        for (pClip = &pWnd->pClip->arcl[0], cClip = pWnd->pClip->c; cClip;
             cClip--, pClip++)
        {
            UCHAR *pScreenClip;

            // Test for trivial cases:

            if (y < pClip->top)
                break;

            // Determine trivial rejection for just this span

            if ((xLeft >= pClip->right) ||
                (y >= pClip->bottom) ||
                (xRight <= pClip->left))
                continue;

            // Intersect current clip rect with the span:

            xLeftClip   = max(xLeft, pClip->left);
            xRightClip  = min(xRight, pClip->right);

            if (xLeftClip >= xRightClip)
                continue;

            if (xLeftOrg != xLeftClip)
                pPixels = (UCHAR *)pMCDSpan->pPixels +
                          ((xLeftClip - xLeftOrg) * cjHwPel);

            pScreenClip = pScreen + ((xLeftClip - xLeft) * cjHwPel);

            // Write the span:

            RtlCopyMemory(pScreenClip, pPixels, (xRightClip - xLeftClip) * cjHwPel);
        }
    }

    return (ULONG)TRUE;
}


VOID MCDrvTrackWindow(WNDOBJ *pWndObj, MCDWINDOW *pMCDWnd, ULONG flags)
{
//    MCDBG_PRINT("MCDrvTrackWindow");

    SURFOBJ *pso = pWndObj->psoOwner;

    //
    // Note: pMCDWnd is NULL for surface notifications, so if needed
    // they should be handled before this check:
    //

    if (!pMCDWnd)
        return;

    if (!pMCDWnd->pvUser) {
        MCDBG_PRINT("MCDrvTrackWindow: NULL pDevWnd");
        return;
    }

    switch (flags) {
        case WOC_DELETE:

            //MCDBG_PRINT("MCDrvTrackWindow: WOC_DELETE");

            // If the display resoultion has changed, the resources we had
            // bound to the tracked window are gone, so don't try to delete
            // the back- and z-buffer resources which are no longer present:

            if (((DEVWND *)pMCDWnd->pvUser)->dispUnique ==
                GetDisplayUniqueness((PDEV *)pso->dhpdev))
                HWFreeResources(pMCDWnd, pso);

            MCDFree((VOID *)pMCDWnd->pvUser);
            pMCDWnd->pvUser = NULL;

            break;

        case WOC_RGN_CLIENT:

            // The resources we had  bound to the tracked window have moved,
            // so update them:

            {
                DEVWND *pWnd = (DEVWND *)pMCDWnd->pvUser;
                BOOL bZBuffer = (pWnd->pohZBuffer != NULL);
                BOOL bBackBuffer = (pWnd->pohBackBuffer != NULL);
                PDEV *ppdev = (PDEV *)pso->dhpdev;
                ULONG height = pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top;
                BOOL bWindowBuffer = (bZBuffer && (pWnd->pohZBuffer != ppdev->pohZBuffer)) ||
                                     (bBackBuffer && (pWnd->pohBackBuffer != ppdev->pohBackBuffer));

                // If the window is using a window-sized back/z resource,
                // we need to reallocate it if there has been a size change:

                if (pWnd->dispUnique == GetDisplayUniqueness(ppdev)) {
                    if ((height != pWnd->allocatedBufferHeight) &&
                        (bWindowBuffer)) {
                        HWFreeResources(pMCDWnd, pso);
                        HWAllocResources(pMCDWnd, pso, bZBuffer, bBackBuffer);
                    }
                } else {
                    // In this case, the display has been re-initialized due
                    // to some event such as a resolution change, so we need
                    // to create our buffes from scratch:

                    pWnd->dispUnique = GetDisplayUniqueness((PDEV *)pso->dhpdev);
                    HWAllocResources(pMCDWnd, pso, bZBuffer, bBackBuffer);
                }
            }

            break;

        default:
            break;
    }
    return;
}


ULONG MCDrvBindContext(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc)
{
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

    // OK, this is a new binding, so create the per-window structure and
    // set the pixel format:

    if (!pDevWnd) {

        pDevWnd = pMCDSurface->pWnd->pvUser = (DEVWND *)MCDAlloc(sizeof(DEVWND));
        if (!pDevWnd) {
            MCDBG_PRINT("MCDrvBindContext: couldn't allocate DEVWND");
            return FALSE;
        }
        pDevWnd->createFlags = pMCDRc->createFlags;
        pDevWnd->iPixelFormat = pMCDRc->iPixelFormat;
        pDevWnd->dispUnique = GetDisplayUniqueness(ppdev);

        return TRUE;
    }

    if (pMCDRc->iPixelFormat != pDevWnd->iPixelFormat) {
        MCDBG_PRINT("MCDrvBindContext: tried to bind unmatched pixel formats");
        return FALSE;
    }

    HWUpdateBufferPos(pMCDSurface->pWnd, pMCDSurface->pso, TRUE);
    return TRUE;
}


ULONG MCDrvSync(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;

    pRc->ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    HW_WAIT_DRAWING_DONE(pRc);

    return TRUE;
}


ULONG MCDrvCreateTexture(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex)
{
    //MCDBG_PRINT("MCDrvCreateTexture");

#ifdef TEST_TEXTURE
    pTex->textureKey = 0x1000;

    return 1;
#else
    return 0;
#endif
}


ULONG MCDrvUpdateSubTexture(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                            MCDTEXTURE *pTex, ULONG lod, RECTL *pRect)
{
    //MCDBG_PRINT("MCDrvUpdateSubTexture");

    return TRUE;
}


ULONG MCDrvUpdateTexturePalette(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                                MCDTEXTURE *pTex, ULONG start,
                                ULONG numEntries)
{
    //MCDBG_PRINT("MCDrvUpdateTexturePalette");

    return TRUE;
}


ULONG MCDrvUpdateTexturePriority(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                                 MCDTEXTURE *pTex)
{
    //MCDBG_PRINT("MCDrvUpdateTexturePriority");

    return TRUE;
}


ULONG MCDrvUpdateTextureState(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                              MCDTEXTURE *pTex)
{
    //MCDBG_PRINT("MCDrvUpdateTextureState");

    return TRUE;
}


ULONG MCDrvTextureStatus(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                         MCDTEXTURE *pTex)
{
    //MCDBG_PRINT("MCDrvTextureStatus");

    return MCDRV_TEXTURE_RESIDENT;
}

ULONG MCDrvDeleteTexture(MCDTEXTURE *pTex, DHPDEV dhpdev)
{
    //MCDBG_PRINT("MCDrvDeleteTexture");

    return TRUE;
}

ULONG MCDrvDrawPixels(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                      ULONG width, ULONG height, ULONG format,
                      ULONG type, VOID *pPixels, BOOL packed)
{
    //MCDBG_PRINT("MCDrvDrawPixels");

    return FALSE;
}

ULONG MCDrvReadPixels(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                      LONG x, LONG y, ULONG width, ULONG height,
                      ULONG format, ULONG type, VOID *pPixels)
{
    //MCDBG_PRINT("MCDrvReadPixels");

    return FALSE;
}

ULONG MCDrvCopyPixels(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                      LONG x, LONG y, ULONG width, ULONG height, ULONG type)
{
    //MCDBG_PRINT("MCDrvCopyPixels");

    return FALSE;
}

ULONG MCDrvPixelMap(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                    ULONG mapType, ULONG mapSize, VOID *pMap)
{
    //MCDBG_PRINT("MCDrvPixelMap");

    return TRUE;
}

BOOL MCDrvGetEntryPoints(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver)
{
    if (pMCDDriver->ulSize < sizeof(MCDDRIVER))
        return FALSE;

    pMCDDriver->pMCDrvInfo = MCDrvInfo;
    pMCDDriver->pMCDrvDescribePixelFormat = MCDrvDescribePixelFormat;
    pMCDDriver->pMCDrvDescribeLayerPlane = MCDrvDescribeLayerPlane;
    pMCDDriver->pMCDrvSetLayerPalette = MCDrvSetLayerPalette;
    pMCDDriver->pMCDrvCreateContext = MCDrvCreateContext;
    pMCDDriver->pMCDrvDeleteContext = MCDrvDeleteContext;
    pMCDDriver->pMCDrvCreateTexture = MCDrvCreateTexture;
    pMCDDriver->pMCDrvDeleteTexture = MCDrvDeleteTexture;
    pMCDDriver->pMCDrvCreateMem = MCDrvCreateMem;
    pMCDDriver->pMCDrvDeleteMem = MCDrvDeleteMem;
    pMCDDriver->pMCDrvDraw = MCDrvDraw;
    pMCDDriver->pMCDrvClear = MCDrvClear;
    pMCDDriver->pMCDrvSwap = MCDrvSwap;
    pMCDDriver->pMCDrvState = MCDrvState;
    pMCDDriver->pMCDrvViewport = MCDrvViewport;
    pMCDDriver->pMCDrvGetHdev = MCDrvGetHdev;
    pMCDDriver->pMCDrvSpan = MCDrvSpan;
    pMCDDriver->pMCDrvTrackWindow = MCDrvTrackWindow;
    pMCDDriver->pMCDrvAllocBuffers = MCDrvAllocBuffers;
    pMCDDriver->pMCDrvGetBuffers = MCDrvGetBuffers;
    pMCDDriver->pMCDrvBindContext = MCDrvBindContext;
    pMCDDriver->pMCDrvSync = MCDrvSync;
    pMCDDriver->pMCDrvCreateTexture = MCDrvCreateTexture;
    pMCDDriver->pMCDrvDeleteTexture = MCDrvDeleteTexture;
    pMCDDriver->pMCDrvUpdateSubTexture = MCDrvUpdateSubTexture;
    pMCDDriver->pMCDrvUpdateTexturePalette = MCDrvUpdateTexturePalette;
    pMCDDriver->pMCDrvUpdateTexturePriority = MCDrvUpdateTexturePriority;
    pMCDDriver->pMCDrvUpdateTextureState = MCDrvUpdateTextureState;
    pMCDDriver->pMCDrvTextureStatus = MCDrvTextureStatus;
    pMCDDriver->pMCDrvDrawPixels = MCDrvDrawPixels;
    pMCDDriver->pMCDrvReadPixels = MCDrvReadPixels;
    pMCDDriver->pMCDrvCopyPixels = MCDrvCopyPixels;
    pMCDDriver->pMCDrvPixelMap = MCDrvPixelMap;

    return TRUE;
}

/******************************Public*Routine******************************\
* VOID vAssertModeMCD
*
* This function is called by enable.c when entering or leaving the
* DOS full-screen character mode.
*
\**************************************************************************/

VOID vAssertModeMCD(
PDEV*   ppdev,
BOOL    bEnabled)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableMCD
*
* This function is called by enable.c when the mode is first initialized,
* right after the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableMCD(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableMCD
*
* This function is called by enable.c when the driver is shutting down.
*
\**************************************************************************/

VOID vDisableMCD(
PDEV*   ppdev)
{
    if (ppdev->hMCD)
    {
        EngUnloadImage(ppdev->hMCD);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdmath.h ===
/******************************Module*Header*******************************\
* Module Name: mcdmath.h
*
* Various useful defines and macros to do efficient floating-point
* processing for MCD drivers.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#define CASTINT(a)              (*((LONG *)&(a)))

#define ZERO (MCDFLOAT)0.0

#define __MCDZERO       ZERO
#define __MCDONE        (MCDFLOAT)1.0
#define __MCDHALF       (MCDFLOAT)0.5
#define __MCDFIXSCALE   (MCDFLOAT)65536.0

#define __MCD_MAX_WINDOW_SIZE_LOG2       14
#define __MCD_VERTEX_FIX_POINT   (__MCD_MAX_WINDOW_SIZE_LOG2+1)
#define __MCD_VERTEX_X_FIX	(1 << __MCD_VERTEX_FIX_POINT)
#define __MCD_VERTEX_Y_FIX	__MCD_VERTEX_X_FIX

#define __MCD_FLOAT_MANTISSA_BITS	23
#define __MCD_FLOAT_MANTISSA_SHIFT	0
#define __MCD_FLOAT_EXPONENT_BIAS	127
#define __MCD_FLOAT_EXPONENT_BITS	8
#define __MCD_FLOAT_EXPONENT_SHIFT	23
#define __MCD_FLOAT_SIGN_SHIFT		31

// If the MSB of a FP number is known then float-to-int conversion
// becomes a simple shift and mask
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_INT(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS-(shift)))-1) | \
     (1 << (__MCD_FLOAT_MANTISSA_BITS-(shift))))

// Same as above except without the MSB, which can be useful
// for getting unbiased numbers when the bias is only the MSB
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_INT_NO_MSB(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS-(shift)))-1))

// Produces the fixed-point form
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_FIXED(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1) | \
     (1 << (__MCD_FLOAT_MANTISSA_BITS)))

#define __MCD_FIXED_FLOAT_TO_FIXED_NO_MSB(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1))

// The fixed-point fraction as an integer
// The value must be positive
#define __MCD_FIXED_FLOAT_FRACTION(flt, shift) \
    (*(LONG *)&(flt) & ((1 << (shift))-1))

// Converts the fixed-point form to an IEEE float, but still typed
// as an int because a cast to float would cause the compiler to do
// an int-float conversion
// The value must be positive
#define __MCD_FIXED_TO_FIXED_FLOAT(fxed, shift) \
    ((fxed) & ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1) | \
     ((__MCD_FLOAT_EXPONENT_BIAS+(shift)) << __MCD_FLOAT_EXPONENT_SHIFT))
      

#ifdef _X86_
#define __MCD_FLOAT_GTZ(flt)             (*(LONG *)&(flt) > 0)
#define __MCD_FLOAT_LTZ(flt)             (*(LONG *)&(flt) < 0)
#define __MCD_FLOAT_EQZ(flt)             (*(LONG *)&(flt) == 0)
#define __MCD_FLOAT_LEZ(flt)             (*(LONG *)&(flt) <= 0)
#define __MCD_FLOAT_NEQZ(flt)            (*(LONG *)&(flt) != 0)
#define __MCD_FLOAT_EQUAL(f1, f2)        (*(LONG *)&(f1) == *(LONG *)&(f2))
#define __MCD_FLOAT_NEQUAL(f1, f2)       (*(LONG *)&(f1) != *(LONG *)&(f2))
#else
#define __MCD_FLOAT_GTZ(flt)             ((flt) > __MCDZERO)
#define __MCD_FLOAT_LTZ(flt)             ((flt) < __MCDZERO)
#define __MCD_FLOAT_EQZ(flt)             ((flt) == __MCDZERO)
#define __MCD_FLOAT_LEZ(flt)             ((flt) <= __MCDZERO)
#define __MCD_FLOAT_NEQZ(flt)            ((flt) != __MCDZERO)
#define __MCD_FLOAT_EQUAL(f1, f2)        ((f1) == (f2))
#define __MCD_FLOAT_NEQUAL(f1, f2)       ((f1) != (f2))
#endif // _X86_


// Macro to start an FP divide in the FPU, used to overlap a
// divide with integer operations
// Can't just use C because it stores the result immediately
#ifdef _X86_

#define __MCD_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    __asm fld num \
    __asm fdiv den
#define __MCD_FLOAT_SIMPLE_END_DIVIDE(result) \
    __asm fstp DWORD PTR result

//USED
__inline void __MCD_FLOAT_BEGIN_DIVIDE(MCDFLOAT num, MCDFLOAT den,
                                      MCDFLOAT *result)
{
    __asm fld num
    __asm fdiv den
}
__inline void __MCD_FLOAT_END_DIVIDE(MCDFLOAT *result)
{
    __asm mov eax, result
    __asm fstp DWORD PTR [eax]
}
#else
#define __MCD_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    ((result) = (num)/(den))
#define __MCD_FLOAT_SIMPLE_END_DIVIDE(result)
#define __MCD_FLOAT_BEGIN_DIVIDE(num, den, result) (*(result) = (num)/(den))
#define __MCD_FLOAT_END_DIVIDE(result)
#endif // _X86_





#ifdef _X86_

#pragma warning(disable:4035) // Function doesn't return a value

// Convert float to int 15.16
__inline LONG __fastcall FLT_TO_FIX(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 15.16, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_TO_FIX(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31
__inline LONG __fastcall FLT_FRACTION(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_FRACTION(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

#pragma warning(default:4035) // Function doesn't return a value

// Convert float*scale to int
__inline LONG __fastcall FLT_TO_FIX_SCALE(
    float a,
    float b)
{
    LARGE_INTEGER li;

    __asm {
        fld     a
        fmul    b
        fistp   li
    }

    return li.LowPart;
}

#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)FLT_TO_FIX_SCALE(value_in, scale))

__inline LONG __fastcall FTOL(
    float a)
{
    LARGE_INTEGER li;

    _asm {
        fld     a
        fistp   li
    }

    return li.LowPart;
}

// Can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FTOL(
    float a)
{
    LONG l;

    _asm {
        fld     a
        fistp   l
    }

    return l;
}

// Requires R-G-B to be FP stack 2-1-0
// Requires gc in edx
#define FLT_STACK_RGB_TO_GC_FIXED(rOffset, gOffset, bOffset)	              \
    __asm fld __glVal65536						      \
    __asm fmul st(3), st(0)						      \
    __asm fmul st(2), st(0)						      \
    __asm fmulp st(1), st(0)						      \
    __asm fistp DWORD PTR [edx+bOffset]					      \
    __asm fistp DWORD PTR [edx+gOffset]					      \
    __asm fistp DWORD PTR [edx+rOffset]					      

#define CHOP_ROUND_ON() \
    WORD cwSave;                 \
    WORD cwTemp;                 \
                                 \
    __asm {                      \
        _asm wait                \
        _asm fstcw   cwSave      \
        _asm wait                \
        _asm mov     ax, cwSave  \
        _asm or      ah,0xc      \
        _asm and     ah,0xfc     \
        _asm mov     cwTemp,ax   \
        _asm fldcw   cwTemp      \
    }

#define CHOP_ROUND_OFF()         \
    __asm {                      \
        _asm wait                \
        _asm fldcw   cwSave      \
    }


#else // _X86_

#define FTOL(value) \
    ((GLint)(value))
#define UNSAFE_FTOL(value) \
    FTOL(value)
#define FLT_TO_FIX_SCALE(value_in, scale) \
    ((GLint)((MCDFLOAT)(value_in) * scale))
#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)((GLint)((MCDFLOAT)(value_in) * scale)))
#define FLT_TO_FIX(value_in) \
    ((GLint)((MCDFLOAT)(value_in) * __MCDFIXSCALE))
#define UNSAFE_FLT_TO_FIX(value_in) \
    FLT_TO_FIX(value_in)
#define FLT_FRACTION(f) \
    FTOL((f) * __glVal2147483648)
#define UNSAFE_FLT_FRACTION(f) \
    FLT_FRACTION(f)

#define CHOP_ROUND_ON()
#define CHOP_ROUND_OFF()
#define ASSERT_CHOP_ROUND()

#endif  //_X86_














#define __MCD_VERTEX_FRAC_BITS \
    (__MCD_FLOAT_MANTISSA_BITS-__MCD_VERTEX_FIX_POINT)

//USED
#define __MCD_VERTEX_FRAC_HALF \
    (1 << (__MCD_VERTEX_FRAC_BITS-1))
#define __MCD_VERTEX_FRAC_ONE \
    (1 << __MCD_VERTEX_FRAC_BITS)


// Converts a floating-point window coordinate to integer
#define __MCD_VERTEX_FLOAT_TO_INT(windowCoord) \
    __MCD_FIXED_FLOAT_TO_INT(windowCoord, __MCD_VERTEX_FRAC_BITS)

//USED
// To fixed point
#define __MCD_VERTEX_FLOAT_TO_FIXED(windowCoord) \
    __MCD_FIXED_FLOAT_TO_FIXED(windowCoord)
// And back
#define __MCD_VERTEX_FIXED_TO_FLOAT(fxWindowCoord) \
    __MCD_FIXED_TO_FIXED_FLOAT(fxWindowCoord, __MCD_VERTEX_FRAC_BITS)

//USED
// Fixed-point to integer
#define __MCD_VERTEX_FIXED_TO_INT(fxWindowCoord) \
    ((fxWindowCoord) >> __MCD_VERTEX_FRAC_BITS)

// Returns the fraction from a FP window coordinate as an N
// bit integer, where N depends on the FP mantissa size and the
// FIX size
#define __MCD_VERTEX_FLOAT_FRACTION(windowCoord) \
    __MCD_FIXED_FLOAT_FRACTION(windowCoord, __MCD_VERTEX_FRAC_BITS)

// Scale the fraction to 2^31 for step values
#define __MCD_VERTEX_PROMOTE_FRACTION(frac) \
    ((frac) << (31-__MCD_VERTEX_FRAC_BITS))
#define __MCD_VERTEX_PROMOTED_FRACTION(windowCoord) \
    __MCD_VERTEX_PROMOTE_FRACTION(__MCD_VERTEX_FLOAT_FRACTION(windowCoord))

// Compare two window coordinates.  Since window coordinates
// are fixed-point numbers, they can be compared directly as
// integers
#define __MCD_VERTEX_COMPARE(a, op, b) \
    ((*(LONG *)&(a)) op (*(LONG *)&(b)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdline.c ===
/******************************Module*Header*******************************\
* Module Name: mcdline.c
*
* Contains all of the line-rendering routines for the Millenium MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

//#undef CHECK_FIFO_FREE
//#define CHECK_FIFO_FREE 


VOID FASTCALL __MCDRenderFlatLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, BOOL resetLine)
{
    PDEV *ppdev = pRc->ppdev;
    BYTE *pjBase = ppdev->pjBase;
    ULONG clipNum;
    RECTL *pClip;
    MCDFLOAT invLength;
    MCDCOLOR *ac;
    LONG ix0, ix1, iy0, iy1;
    LONG idx, idy;
    LONG absIdx, absIdy;
    LONG x0frac, x1frac, y0frac, y1frac, totDist;
    LONG numPixels;
    LARGE_INTEGER idz, iZStart;
    LONG err;
    ULONG signs;
    ULONG adjust = 0;
    LONG majorInc;
    LONG minorInc;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    x0frac = __MCD_VERTEX_FLOAT_FRACTION(a->windowCoord.x);
    y0frac = __MCD_VERTEX_FLOAT_FRACTION(a->windowCoord.y);
    ix0 = __MCD_VERTEX_FLOAT_TO_INT(a->windowCoord.x);
    iy0 = __MCD_VERTEX_FLOAT_TO_INT(a->windowCoord.y);

    x1frac = __MCD_VERTEX_FLOAT_FRACTION(b->windowCoord.x);
    y1frac = __MCD_VERTEX_FLOAT_FRACTION(b->windowCoord.y);
    ix1 = __MCD_VERTEX_FLOAT_TO_INT(b->windowCoord.x);
    iy1 = __MCD_VERTEX_FLOAT_TO_INT(b->windowCoord.y);

    absIdx = idx = ix1 - ix0;
    if (absIdx < 0)
        absIdx = -absIdx;

    absIdy = idy = iy1 - iy0;
    if (absIdy < 0)
        absIdy = -absIdy;

    if (absIdx > absIdy) {

        signs = sdydxl_MAJOR_X;

        if (idx > 0) {

            signs |= sdxl_ADD;

            if (pRc->privateEnables & __MCDENABLE_Z) {
                __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, 
                                         b->windowCoord.x - a->windowCoord.x,
                                         &invLength);
            }

            y0frac -= __MCD_VERTEX_FRAC_HALF;
            if (y0frac < 0) y0frac = -y0frac;

            totDist = y0frac + x0frac - __MCD_VERTEX_FRAC_ONE;

            if (totDist > 0) {
                ix0++;
                adjust++;
            }

            y1frac -= __MCD_VERTEX_FRAC_HALF;
            if (y1frac < 0) y1frac = -y1frac;

            totDist = y1frac + x1frac - __MCD_VERTEX_FRAC_ONE;
            if (totDist > 0) ix1++;

            numPixels = ix1 - ix0;

        } else {

            signs |= sdxl_SUB;

            if (pRc->privateEnables & __MCDENABLE_Z) {
                __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                         a->windowCoord.x - b->windowCoord.x,
                                         &invLength);

            }

            y0frac -= __MCD_VERTEX_FRAC_HALF;
            if (y0frac < 0) y0frac = -y0frac;

            totDist = y0frac - x0frac;

            if (totDist > 0) {
                ix0--;
                adjust++;
            }

            y1frac -= __MCD_VERTEX_FRAC_HALF;
            if (y1frac < 0) y1frac = -y1frac;

            totDist = y1frac - x1frac;
            if (totDist > 0) ix1--;

            numPixels = ix0 - ix1;

        }

        if (numPixels <= 0) {
            if (pRc->privateEnables & __MCDENABLE_Z)
                __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);
            return;
        }

        majorInc = (absIdy << 1);
        minorInc = ((LONG)absIdy - (LONG)absIdx) << 1;

        if (idy < 0) {
            signs |= sdy_SUB;
            err = majorInc - (LONG)absIdx - 1;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    iy0--;
                    err += minorInc;
                }
            }

        } else {

            signs |= sdy_ADD;
            err = majorInc - (LONG)absIdx;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    iy0++;
                    err += minorInc;
                }
            }
        }

    } else {

        signs = sdydxl_MAJOR_Y;

        if (idy > 0) {

            signs |= sdy_ADD;

            if (pRc->privateEnables & __MCDENABLE_Z) {
                __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                         b->windowCoord.y - a->windowCoord.y,
                                         &invLength);
            }
                    
            x0frac -= __MCD_VERTEX_FRAC_HALF;
            if (x0frac < 0) x0frac = -x0frac;

            totDist = y0frac + x0frac - __MCD_VERTEX_FRAC_ONE;

            if (totDist > 0) {
                iy0++;
                adjust++;
            }

            x1frac -= __MCD_VERTEX_FRAC_HALF;
            if (x1frac < 0) x1frac = -x1frac;

            totDist = y1frac + x1frac - __MCD_VERTEX_FRAC_ONE;
            if (totDist > 0) iy1++;

            numPixels = iy1 - iy0;

        } else {

            signs |= sdy_SUB;

            if (pRc->privateEnables & __MCDENABLE_Z) {
                __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                         a->windowCoord.y - b->windowCoord.y,
                                         &invLength);

            }

            x0frac -= __MCD_VERTEX_FRAC_HALF;
            if (x0frac < 0) x0frac = -x0frac;

            totDist = x0frac - y0frac;

            if (totDist > 0) {
                iy0--;
                adjust++;
            }

            x1frac -= __MCD_VERTEX_FRAC_HALF;
            if (x1frac < 0) x1frac = -x1frac;

            totDist = x1frac - y1frac;
            if (totDist > 0) iy1--;

            numPixels = iy0 - iy1;

        }

        if (numPixels <= 0) {
            if (pRc->privateEnables & __MCDENABLE_Z)
                __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);
            return;
        }

        majorInc = (absIdx << 1);
        minorInc = ((LONG)absIdx - (LONG)absIdy) << 1;

        if (idx < 0) {

            signs |= sdxl_SUB;
            err = majorInc - (LONG)absIdy - 1;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    ix0--;
                    err += minorInc;
                }
            }
        } else {
            signs |= sdxl_ADD;
            err = majorInc - (LONG)absIdy;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    ix0++;
                    err += minorInc;
                }
            }
        }
    }

    if (pRc->privateEnables & __MCDENABLE_Z) {

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3+3+6);

#if _X86_ && ASM_ACCEL
        _asm{

        mov     ebx, b
        mov     eax, a
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ebx]
        fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]    // dz len
        mov     ebx, pRc
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]    // a.z dz len
        fxch    ST(2)                                               // len dz a.z
        fmulp   ST(1), ST                                      //+1 // dzL a.z
        fxch    ST(1)                                               // a.z dzL
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]               // azS dzL
        fxch    ST(1)                                               // dzL azS
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]          //+1 // dzLS azS
        fxch    ST(1)                                               // azS dzLS
        fistp   iZStart
        fistp   idz
        }
#else
        __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);
        idz.LowPart = FTOL((b->windowCoord.z - a->windowCoord.z) * invLength * pRc->zScale);
        iZStart.LowPart = FTOL(a->windowCoord.z * pRc->zScale);

#endif
        CP_WRITE(pjBase, DWG_DR2, idz.LowPart);
        CP_WRITE(pjBase, DWG_DR3, idz.LowPart);
        CP_WRITE(pjBase, DWG_DR0, iZStart.LowPart);
    } else {
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3+6);
    }

    CP_WRITE(pjBase, DWG_AR0, majorInc);
    CP_WRITE(pjBase, DWG_AR1, err);
    CP_WRITE(pjBase, DWG_AR2, minorInc);
    CP_WRITE(pjBase, DWG_SGN, signs);
    CP_WRITE(pjBase, DWG_XDST, (ix0 + pRc->xOffset) & 0xffff);
    CP_WRITE(pjBase, DWG_YDSTLEN, ((iy0 + pRc->yOffset) << 16) | numPixels);


#if _X86_ && ASM_ACCEL
    {
    LONG rTemp, gTemp, bTemp;

    _asm{

    mov     eax, a
    mov     ebx, pRc
    lea     eax, [OFFSET(MCDVERTEX.colors) + eax]

    fld     DWORD PTR [OFFSET(DEVRC.rScale)][ebx]
    fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
    fld     DWORD PTR [OFFSET(DEVRC.gScale)][ebx]
    fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
    fld     DWORD PTR [OFFSET(DEVRC.bScale)][ebx]     // B G R
    fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]

    fxch    ST(2)                                     // R G B
    fistp   rTemp                                     // G B
    fistp   gTemp
    fistp   bTemp
        
    }

    CP_WRITE(pjBase, DWG_DR4,  rTemp);
    CP_WRITE(pjBase, DWG_DR8,  gTemp);
    CP_START(pjBase, DWG_DR12, bTemp);
    }

#else
    ac = &a->colors[0];

    CP_WRITE(pjBase, DWG_DR4,  FTOL(ac->r * pRc->rScale));
    CP_WRITE(pjBase, DWG_DR8,  FTOL(ac->g * pRc->gScale));
    CP_START(pjBase, DWG_DR12, FTOL(ac->b * pRc->bScale));
#endif

    while (--clipNum) {
        (*pRc->HWSetupClipRect)(pRc, pClip++);

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 4);

        CP_WRITE(pjBase, DWG_DR0,  iZStart.LowPart);
        CP_WRITE(pjBase, DWG_AR1, err);
        CP_WRITE(pjBase, DWG_XDST, (ix0 + pRc->xOffset) & 0xffff);
        CP_START(pjBase, DWG_YDSTLEN, ((iy0 + pRc->yOffset) << 16) | numPixels);
    }
}


VOID FASTCALL __MCDRenderSmoothLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, BOOL resetLine)
{
    PDEV *ppdev = pRc->ppdev;
    BYTE *pjBase = ppdev->pjBase;
    ULONG clipNum;
    RECTL *pClip;
    MCDFLOAT dr, dg, db;
    ULONG idr, idg, idb;
    LONG iRStart, iGStart, iBStart;
    MCDFLOAT length, invLength;
    MCDCOLOR *ac, *bc;
    LONG ix0, ix1, iy0, iy1;
    LONG idx, idy;
    LONG absIdx, absIdy;
    LONG x0frac, x1frac, y0frac, y1frac, totDist;
    LONG numPixels;
    LARGE_INTEGER idz, iZStart;
    LONG err;
    ULONG signs;
    ULONG adjust = 0;
    LONG majorInc;
    LONG minorInc;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    x0frac = __MCD_VERTEX_FLOAT_FRACTION(a->windowCoord.x);
    y0frac = __MCD_VERTEX_FLOAT_FRACTION(a->windowCoord.y);
    ix0 = __MCD_VERTEX_FLOAT_TO_INT(a->windowCoord.x);
    iy0 = __MCD_VERTEX_FLOAT_TO_INT(a->windowCoord.y);

    x1frac = __MCD_VERTEX_FLOAT_FRACTION(b->windowCoord.x);
    y1frac = __MCD_VERTEX_FLOAT_FRACTION(b->windowCoord.y);
    ix1 = __MCD_VERTEX_FLOAT_TO_INT(b->windowCoord.x);
    iy1 = __MCD_VERTEX_FLOAT_TO_INT(b->windowCoord.y);

    absIdx = idx = ix1 - ix0;
    if (absIdx < 0)
        absIdx = -absIdx;

    absIdy = idy = iy1 - iy0;
    if (absIdy < 0)
        absIdy = -absIdy;

    if (absIdx > absIdy) {

        signs = sdydxl_MAJOR_X;

        if (idx > 0) {

            signs |= sdxl_ADD;

            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, 
                                     b->windowCoord.x - a->windowCoord.x,
                                     &invLength);

            y0frac -= __MCD_VERTEX_FRAC_HALF;
            if (y0frac < 0) y0frac = -y0frac;

            totDist = y0frac + x0frac - __MCD_VERTEX_FRAC_ONE;

            if (totDist > 0) {
                ix0++;
                adjust++;
            }

            y1frac -= __MCD_VERTEX_FRAC_HALF;
            if (y1frac < 0) y1frac = -y1frac;

            totDist = y1frac + x1frac - __MCD_VERTEX_FRAC_ONE;
            if (totDist > 0) ix1++;

            numPixels = ix1 - ix0;

        } else {

            signs |= sdxl_SUB;

            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                     a->windowCoord.x - b->windowCoord.x,
                                     &invLength);

            y0frac -= __MCD_VERTEX_FRAC_HALF;
            if (y0frac < 0) y0frac = -y0frac;

            totDist = y0frac - x0frac;

            if (totDist > 0) {
                ix0--;
                adjust++;
            }

            y1frac -= __MCD_VERTEX_FRAC_HALF;
            if (y1frac < 0) y1frac = -y1frac;

            totDist = y1frac - x1frac;
            if (totDist > 0) ix1--;

            numPixels = ix0 - ix1;

        }

        if (numPixels <= 0) {
            __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);
            return;
        }

        if (numPixels == 1)
            goto shortLine;

        majorInc = (absIdy << 1);
        minorInc = ((LONG)absIdy - (LONG)absIdx) << 1;

        if (idy < 0) {
            signs |= sdy_SUB;
            err = majorInc - (LONG)absIdx - 1;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    iy0--;
                    err += minorInc;
                }
            }

        } else {

            signs |= sdy_ADD;
            err = majorInc - (LONG)absIdx;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    iy0++;
                    err += minorInc;
                }
            }
        }

    } else {

        signs = sdydxl_MAJOR_Y;

        if (idy > 0) {

            signs |= sdy_ADD;

            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                     b->windowCoord.y - a->windowCoord.y,
                                     &invLength);
                    
            x0frac -= __MCD_VERTEX_FRAC_HALF;
            if (x0frac < 0) x0frac = -x0frac;

            totDist = y0frac + x0frac - __MCD_VERTEX_FRAC_ONE;

            if (totDist > 0) {
                iy0++;
                adjust++;
            }

            x1frac -= __MCD_VERTEX_FRAC_HALF;
            if (x1frac < 0) x1frac = -x1frac;

            totDist = y1frac + x1frac - __MCD_VERTEX_FRAC_ONE;
            if (totDist > 0) iy1++;

            numPixels = iy1 - iy0;

        } else {

            signs |= sdy_SUB;

            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE,
                                     a->windowCoord.y - b->windowCoord.y,
                                     &invLength);

            x0frac -= __MCD_VERTEX_FRAC_HALF;
            if (x0frac < 0) x0frac = -x0frac;

            totDist = x0frac - y0frac;

            if (totDist > 0) {
                iy0--;
                adjust++;
            }

            x1frac -= __MCD_VERTEX_FRAC_HALF;
            if (x1frac < 0) x1frac = -x1frac;

            totDist = x1frac - y1frac;
            if (totDist > 0) iy1--;

            numPixels = iy0 - iy1;

        }

        if (numPixels <= 0) {
            __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);
            return;
        }

        if (numPixels == 1)
            goto shortLine;

        majorInc = (absIdx << 1);
        minorInc = ((LONG)absIdx - (LONG)absIdy) << 1;

        if (idx < 0) {

            signs |= sdxl_SUB;
            err = majorInc - (LONG)absIdy - 1;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    ix0--;
                    err += minorInc;
                }
            }
        } else {
            signs |= sdxl_ADD;
            err = majorInc - (LONG)absIdy;

            if (adjust) {
                if (err <= 0)
                    err += majorInc;
                else {
                    ix0++;
                    err += minorInc;
                }
            }
        }
    }

    __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);

    if (pRc->privateEnables & __MCDENABLE_Z) {
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 18);

#if _X86_ && ASM_ACCEL
        _asm{

        mov     ebx, b
        mov     eax, a
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ebx]
        fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]    // dz
        mov     ebx, pRc
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]    // a.z dz
        fxch    ST(1)                                               // dz  a.z
        fmul    invLength                                      //+1 // dzL
        fxch    ST(1)                                               // a.z dzL
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]               // azS dzL
        fxch    ST(1)                                               // dzL azS
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]          //+1 // dzLS azS
        fxch    ST(1)                                               // azS dzLS
        fistp   iZStart
        fistp   idz
        }
#else
        idz.LowPart = FTOL((b->windowCoord.z - a->windowCoord.z) * invLength * pRc->zScale);
        iZStart.LowPart = FTOL(a->windowCoord.z * pRc->zScale);

#endif
        CP_WRITE(pjBase, DWG_DR2, idz.LowPart);
        CP_WRITE(pjBase, DWG_DR3, idz.LowPart);
        CP_WRITE(pjBase, DWG_DR0, iZStart.LowPart);
    } else {
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 15);
    }

    CP_WRITE(pjBase, DWG_AR0, majorInc);
    CP_WRITE(pjBase, DWG_AR1, err);
    CP_WRITE(pjBase, DWG_AR2, minorInc);
    CP_WRITE(pjBase, DWG_SGN, signs);
    CP_WRITE(pjBase, DWG_XDST, (ix0 + pRc->xOffset) & 0xffff);
    CP_WRITE(pjBase, DWG_YDSTLEN, ((iy0 + pRc->yOffset) << 16) | numPixels);

#if _X86_ && ASM_ACCEL

    _asm{
    mov     ebx, b
    mov     eax, a
    mov     edx, pRc
    lea     ebx, [OFFSET(MCDVERTEX.colors) + ebx]
    lea     eax, [OFFSET(MCDVERTEX.colors) + eax]

    fld     DWORD PTR [OFFSET(MCDCOLOR.r)][ebx]
    fsub    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]     // dr
    fld     DWORD PTR [OFFSET(MCDCOLOR.g)][ebx]
    fsub    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]     // dg   dr
    fxch    ST(1)                                   // dr   dg
    fmul    invLength                               // drL  dg
    fld     DWORD PTR [OFFSET(MCDCOLOR.b)][ebx]
    fsub    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]     // db   drL  dg
    fxch    ST(2)                                   // dg   drL  db
    fmul    invLength                               // dgL  drL  db
    fxch    ST(1)                                   // drL  dgL  db
    fmul    DWORD PTR [OFFSET(DEVRC.rScale)][edx]   // drLS dgL  db
    fxch    ST(2)                                   // db   dgL  drLS
    fmul    invLength                               // dbL  dgL  drLS
    fxch    ST(1)                                   // dgL  dbL  drLS
    fmul    DWORD PTR [OFFSET(DEVRC.gScale)][edx]   // dgLS dbL  drLS
    fxch    ST(1)                                   // dbL  dgLS drLS
    fld     DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
    fmul    DWORD PTR [OFFSET(DEVRC.rScale)][edx]   // r dbL  dgLS drLS
    fxch    ST(1)                                   // dbL  r dgLS drLS
    fmul    DWORD PTR [OFFSET(DEVRC.bScale)][edx]   // dbLS r dgLS drLS
    fxch    ST(1)                                   // r dbLS dgLS drLS
    fld     DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
    fmul    DWORD PTR [OFFSET(DEVRC.gScale)][edx]   // g r dbLS dgLS drLS
    fld     DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
    fmul    DWORD PTR [OFFSET(DEVRC.bScale)][edx]   // b g r dbLS dgLS drLS
    fxch    ST(2)                                   // r g b dbLS dgLS drLS
    fistp   iRStart
    fistp   iGStart
    fistp   iBStart
    fistp   idb
    fistp   idg
    fistp   idr
    }
    
#else
    ac = &a->colors[0];
    bc = &b->colors[0];

    dr = (bc->r - ac->r) * invLength * pRc->rScale;
    dg = (bc->g - ac->g) * invLength * pRc->gScale;
    db = (bc->b - ac->b) * invLength * pRc->bScale;
    iRStart = FTOL(ac->r * pRc->rScale);
    iGStart = FTOL(ac->g * pRc->gScale);
    iBStart = FTOL(ac->b * pRc->bScale);
    idr = FTOL(dr);
    idg = FTOL(dg);
    idb = FTOL(db);
#endif

    CP_WRITE(pjBase, DWG_DR6,  idr);
    CP_WRITE(pjBase, DWG_DR7,  idr);
    CP_WRITE(pjBase, DWG_DR10, idg);
    CP_WRITE(pjBase, DWG_DR11, idg);
    CP_WRITE(pjBase, DWG_DR14, idb);
    CP_WRITE(pjBase, DWG_DR15, idb);

    CP_WRITE(pjBase, DWG_DR4,  iRStart);
    CP_WRITE(pjBase, DWG_DR8,  iGStart);
    CP_START(pjBase, DWG_DR12, iBStart);

clipLine:

    while (--clipNum) {
        (*pRc->HWSetupClipRect)(pRc, pClip++);

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 7);

        CP_WRITE(pjBase, DWG_DR4,  iRStart);
        CP_WRITE(pjBase, DWG_DR8,  iGStart);
        CP_WRITE(pjBase, DWG_DR12, iBStart);
        CP_WRITE(pjBase, DWG_DR0,  iZStart.LowPart);
        CP_WRITE(pjBase, DWG_AR1, err);
        CP_WRITE(pjBase, DWG_XDST, (ix0 + pRc->xOffset) & 0xffff);
        CP_START(pjBase, DWG_YDSTLEN, ((iy0 + pRc->yOffset) << 16) | numPixels);
    }

    return;

shortLine:

    __MCD_FLOAT_SIMPLE_END_DIVIDE(invLength);

    // all we will be drawing is a single pixel, so don't bother with
    // the color or z interpolants:

    if (pRc->privateEnables & __MCDENABLE_Z) {
#if _X86_ && ASM_ACCEL
        _asm {
        mov     ecx, a
        mov     edx, pRc
        lea     eax, [OFFSET(MCDVERTEX.colors) + ecx]
        fld     DWORD PTR [OFFSET(DEVRC.rScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.gScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.bScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ecx]
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][edx]   // z b g r
        fxch    ST(3)                                   // r b g z
        fistp   iRStart
        fistp   iBStart
        fistp   iGStart
        fistp   iZStart
        }
#else
        ac = &a->colors[0];
        iRStart = FTOL(ac->r * pRc->rScale);
        iGStart = FTOL(ac->g * pRc->gScale);
        iBStart = FTOL(ac->b * pRc->bScale);
        iZStart.LowPart = FTOL(a->windowCoord.z * pRc->zScale);
#endif
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 6);
        CP_WRITE(pjBase, DWG_DR0, iZStart.LowPart);

    } else {
#if _X86_ && ASM_ACCEL
        _asm{
        mov     eax, a
        mov     edx, pRc
        lea     eax, [OFFSET(MCDVERTEX.colors) + eax]
        fld     DWORD PTr [OFFSET(DEVRC.rScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fld     DWORD PTr [OFFSET(DEVRC.gScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fld     DWORD PTr [OFFSET(DEVRC.bScale)][edx]   // b g r
        fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
        fxch    ST(2)                                   // r g b
        fistp   iRStart
        fistp   iGStart
        fistp   iBStart
        }
#else
        ac = &a->colors[0];

        iRStart = FTOL(ac->r * pRc->rScale);
        iGStart = FTOL(ac->g * pRc->gScale);
        iBStart = FTOL(ac->b * pRc->bScale);
#endif
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 5);
    }

    CP_WRITE(pjBase, DWG_XDST, (ix0 + pRc->xOffset) & 0xffff);
    CP_START(pjBase, DWG_YDSTLEN, ((iy0 + pRc->yOffset) << 16) + 1);
    CP_WRITE(pjBase, DWG_DR4,  iRStart);
    CP_WRITE(pjBase, DWG_DR8,  iGStart);
    CP_START(pjBase, DWG_DR12, iBStart);

    if (clipNum)
        goto clipLine;

}

VOID FASTCALL __MCDRenderGenLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine)
{
    MCDBG_PRINT("__MCDRenderGenLine");
}

VOID FASTCALL __MCDRenderFlatFogLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine)
{
    MCDCOLOR c1, c2;

    c1 = pv1->colors[0];
    c2 = pv2->colors[0];
    __MCDCalcFogColor(pRc, pv1, &pv1->colors[0], &c1);
    __MCDCalcFogColor(pRc, pv2, &pv2->colors[0], &c2);
    (*pRc->renderLineX)(pRc, pv1, pv2, resetLine);
    pv1->colors[0] = c1;
    pv2->colors[0] = c2;
    
}

VOID FASTCALL __MCDLineBegin(DEVRC *pRc)
{
    BYTE *pjBase = ((PDEV *)pRc->ppdev)->pjBase;

    CHECK_FIFO_FREE(pjBase, pRc->cFifo, 1);

    CP_WRITE(pjBase, DWG_DWGCTL, pRc->hwLineFunc);
}

VOID FASTCALL __MCDLineEnd(DEVRC *pRc)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdhw.h ===
/******************************Module*Header*******************************\
* Module Name: mcdhw.h
*
* Driver-specific structures and defines for the Millenium MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#if DBG
    #define FASTCALL 
#else
    #ifdef _X86_
    #define FASTCALL    __fastcall
    #else
    #define FASTCALL 
    #endif
#endif

#define	ASM_ACCEL         1     // Enable/disable asm code

#define __MCD_USER_CLIP_MASK	((1 << MCD_MAX_USER_CLIP_PLANES) - 1)

#define __MCD_CW          0
#define __MCD_CCW         1

#define __MCD_FRONTFACE   MCDVERTEX_FRONTFACE
#define __MCD_BACKFACE    MCDVERTEX_BACKFACE
#define __MCD_NOFACE      -1

#define __MCDENABLE_TWOSIDED	0x0001
#define __MCDENABLE_Z	        0x0002
#define __MCDENABLE_SMOOTH      0x0004
#define __MCDENABLE_GRAY_FOG    0x0008

typedef LONG MCDFIXED;

typedef struct _RGBACOLOR {
    MCDFIXED r, g, b, a;
} RGBACOLOR;

#define SWAP_COLOR(p)\
{\
    MCDFLOAT tempR, tempG, tempB;\
\
    tempR = (p)->colors[0].r;\
    (p)->colors[0].r = (p)->colors[1].r;\
    (p)->colors[1].r = tempR;\
\
    tempG = (p)->colors[0].g;\
    (p)->colors[0].g = (p)->colors[1].g;\
    (p)->colors[1].g = tempG;\
\
    tempB = (p)->colors[0].b;\
    (p)->colors[0].b = (p)->colors[1].b;\
    (p)->colors[1].b = tempB;\
}

#define SAVE_COLOR(temp, p)\
{\
    temp.r = (p)->colors[0].r;\
    temp.g = (p)->colors[0].g;\
    temp.b = (p)->colors[0].b;\
}

#define RESTORE_COLOR(temp, p)\
{\
    (p)->colors[0].r = temp.r;\
    (p)->colors[0].g = temp.g;\
    (p)->colors[0].b = temp.b;\
}

#define COPY_COLOR(pDst, pSrc)\
{\
    pDst.r = pSrc.r;\
    pDst.g = pSrc.g;\
    pDst.b = pSrc.b;\
}

#define MCDCLAMPCOUNT(value) ((ULONG)(value) & 0x00007fff)

#define MCDFIXEDRGB(fixColor, fltColor)\
    fixColor.r = (MCDFIXED)(fltColor.r * pRc->rScale);\
    fixColor.g = (MCDFIXED)(fltColor.g * pRc->gScale);\
    fixColor.b = (MCDFIXED)(fltColor.b * pRc->bScale);

typedef struct _DRVPIXELFORMAT {
    UCHAR cColorBits;
    UCHAR rBits;
    UCHAR gBits;
    UCHAR bBits;
    UCHAR aBits;
    UCHAR rShift;
    UCHAR gShift;
    UCHAR bShift;
    UCHAR aShift;
} DRVPIXELFORMAT;

typedef struct _DEVWND {
    ULONG createFlags;              // (RC) creation flags
    LONG iPixelFormat;              // pixel format ID for this window
    ULONG dispUnique;               // display resolution uniqueness

    ULONG frontBufferPitch;         // pitch in bytes
    ULONG allocatedBufferHeight;    // Same for back and z on Millenium

    BOOL bValidBackBuffer;          // back buffer validity
    ULONG backBufferBase;           // byte offset to start of back buffer pool
    ULONG backBufferBaseY;          // y value for start of back buffer pool
    ULONG backBufferOffset;         // byte offset to start of back buffer
    ULONG backBufferY;              // y value for start of active back buffer
    ULONG backBufferPitch;          // back buffer pitch in bytes

    BOOL bValidZBuffer;             // z buffer validity
    ULONG zBufferBase;              // byte offset to start of z buffer pool
    ULONG zBufferBaseY;             // y value for start of z buffer pool
    ULONG zBufferOffset;            // byte offset to start of z buffer
    ULONG zPitch;                   // z buffer pitch in bytes

    ULONG numPadScans;              // number of pad scan lines in buffers

    OH* pohBackBuffer;              // ofscreen pools
    OH* pohZBuffer;
} DEVWND;

typedef struct _DEVRC DEVRC;

typedef struct _DEVRC
{
    MCDRENDERSTATE MCDState;
    MCDVIEWPORT MCDViewport;
    MCDSURFACE *pMCDSurface;    // Valid for primitives only
    MCDRC *pMCDRc;              // Valid for primitives only
    PDEV* ppdev;                // Valid for primitives only
    ENUMRECTS *pEnumClip;       // Valid for primitives only
    
    MCDVERTEX *pvProvoking;     // provoking vertex
    UCHAR *pMemMax;             // command-buffer memory bounds
    UCHAR *pMemMin;

    LONG iPixelFormat;          // valid pixel format ID for this RC

    // storage and pointers for clip processing:

    MCDVERTEX clipTemp[6 + MCD_MAX_USER_CLIP_PLANES];
    MCDVERTEX *pNextClipTemp;
    VOID (FASTCALL *lineClipParam)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);
    VOID (FASTCALL *polyClipParam)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    // Rendering functions:

    VOID (FASTCALL *renderPoint)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *renderLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *renderTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
    VOID (FASTCALL *clipLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);
    VOID (FASTCALL *clipTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, ULONG clipFlags);
    VOID (FASTCALL *clipPoly)(DEVRC *pRc, MCDVERTEX *pv, ULONG numVert);
    VOID (FASTCALL *doClippedPoly)(DEVRC *pRc, MCDVERTEX **pv, ULONG numVert, ULONG clipFlags);
    VOID (FASTCALL *renderPointX)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *renderLineX)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *renderTriX)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);

// Primitive-rendering function table:

    MCDCOMMAND * (FASTCALL *primFunc[10])(DEVRC *pRc, MCDCOMMAND *pCommand);

// Internal table of rendering functions:

    VOID (FASTCALL *drawPoint)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *drawLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *drawTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, BOOL bCCW);

// Rendering helper functions:

    VOID (FASTCALL *HWSetupClipRect)(DEVRC *pRc, RECTL *pRect);
    VOID (FASTCALL *HWDrawTrap)(DEVRC *pRc, MCDFLOAT dxLeft, MCDFLOAT dxRight,
                                LONG y, LONG dy);
    VOID (FASTCALL *HWSetupDeltas)(DEVRC *pRc);
    

    VOID (FASTCALL *beginLineDrawing)(DEVRC *pRc);
    VOID (FASTCALL *endLineDrawing)(DEVRC *pRc);

    VOID (FASTCALL *beginPointDrawing)(DEVRC *pRc);    

    VOID (FASTCALL *calcDeltas)(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c);
    VOID (FASTCALL *adjustLeftEdge)(DEVRC *pRc, MCDVERTEX *p, MCDFLOAT dxLeft,
            MCDFLOAT dyLeft, MCDFLOAT xFrac, MCDFLOAT yFrac, MCDFLOAT xErr);
    VOID (FASTCALL *adjustRightEdge)(DEVRC *pRc, MCDVERTEX *p, MCDFLOAT dxRight,
                                     MCDFLOAT dyRight, MCDFLOAT xErr);

    BOOL bCheapFog;
    BOOL allPrimFail;           // TRUE is the driver can't draw *any*
                                // primitives for current state
    BOOL pickNeeded;
    BOOL resetLineStipple;

    RGBACOLOR fillColor;

    ULONG polygonFace[2];       // front/back face tables
    ULONG polygonMode[2];

// Polygon-filling parameters and state:

    MCDFLOAT halfArea;
    MCDFLOAT invHalfArea;
    MCDFLOAT dxAC;
    MCDFLOAT dxAB;
    MCDFLOAT dxBC;
    MCDFLOAT dyAC;
    MCDFLOAT dyAB;
    MCDFLOAT dyBC;
    LONG cullFlag;
    MCDFLOAT drdx, drdy;	    // delta values
    MCDFLOAT dgdx, dgdy;
    MCDFLOAT dbdx, dbdy;
    MCDFLOAT dzdx, dzdy;
    MCDFIXED fxdrdx, fxdrdy;	    // fixed-point delta values
    MCDFIXED fxdgdx, fxdgdy;
    MCDFIXED fxdbdx, fxdbdy;
    MCDFIXED fxdzdx, fxdzdy;
    MCDFIXED rStart;
    MCDFIXED gStart;
    MCDFIXED bStart;
    ULONG ixLeft;
    ULONG ixRight;
    ULONG xOffset, yOffset;
    LONG viewportXAdjust;
    LONG viewportYAdjust;

// Hardware-specific state and other information. Modifications will
// not affect high-level code:

    LONG cFifo;

    BOOL bRGBMode;
    BOOL zBufEnabled;
    BOOL backBufEnabled;

    ULONG hwPlaneMask;
    ULONG hwZFunc;
    ULONG hwRop;
    ULONG ulAccess;

    ULONG hwStipple;

    ULONG hwLineFunc;
    ULONG hwIntLineFunc;
    ULONG hwTrapFunc;
    ULONG hwSpanFunc;
    ULONG hwSolidColor;
    ULONG hwPatternLength;
    ULONG hwPatternStart;
    ULONG hwPatternPos;

    ULONG hwBpp;
    LONG hwBufferYBias;     // bias to convert window to buffer coord
    ULONG hwYOrgBias;       // bias to convert window to 0-relative coord

    ULONG privateEnables;

    MCDFLOAT rScale;
    MCDFLOAT gScale;
    MCDFLOAT bScale;
    MCDFLOAT aScale;
    MCDFLOAT zScale;

// shifts for converting to native bit depth

    ULONG rShift;
    ULONG gShift;
    ULONG bShift;
    ULONG aShift;

// shifts for converting to hardware format

    ULONG hwRShift;
    ULONG hwGShift;
    ULONG hwBShift;
    ULONG hwAShift;

// Not used in this driver, but good information to have around:

    ULONG hwZPitch;
    ULONG hwZBytesPerPixel;
    ULONG hwCPitch;
    ULONG hwCBytesPerPixel;

    MCDFLOAT zero;

    DRVPIXELFORMAT pixelFormat;

} DEVRC;


// External declarations

MCDCOMMAND * FASTCALL __MCDPrimDrawPoints(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLines(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLineLoop(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLineStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangles(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleFan(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawQuads(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawQuadStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawPolygon(DEVRC *pRc, MCDCOMMAND *_pCmd);

// High-level rendering functions:

VOID __MCDPickRenderingFuncs(DEVRC *pRc, DEVWND *pDevWnd);

VOID FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *pv);
VOID FASTCALL __MCDRenderFogPoint(DEVRC *pRc, MCDVERTEX *pv);
VOID FASTCALL __MCDRenderGenPoint(DEVRC *pRc, MCDVERTEX *pv);

VOID FASTCALL __MCDRenderFlatLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
VOID FASTCALL __MCDRenderFlatFogLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
VOID FASTCALL __MCDRenderSmoothLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
VOID FASTCALL __MCDRenderGenLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);

VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
VOID FASTCALL __MCDRenderFlatFogTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);

// Low-level drawing functions:

VOID FASTCALL __MCDPointBegin(DEVRC *pRc);
VOID FASTCALL __MCDLineBegin(DEVRC *pRc);
VOID FASTCALL __MCDLineEnd(DEVRC *pRc);

VOID FASTCALL __MCDFillTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2,
                                MCDVERTEX *pv3, BOOL bCCW);

// Clipping functions:

VOID FASTCALL __MCDPickClipFuncs(DEVRC *pRc);
VOID FASTCALL __MCDClipLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                            BOOL bResetLine);
VOID FASTCALL __MCDClipTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c, ULONG orClipCode);
VOID FASTCALL __MCDClipPolygon(DEVRC *pRc, MCDVERTEX *v0, ULONG nv);
VOID FASTCALL __MCDDoClippedPolygon(DEVRC *pRc, MCDVERTEX **iv, ULONG nout,
                                    ULONG allClipCodes);
VOID FASTCALL __HWAdjustLeftEdgeRGBZ(DEVRC *pRc, MCDVERTEX *p,
                                     MCDFLOAT fdxLeft, MCDFLOAT fdyLeft,
                                     MCDFLOAT xFrac, MCDFLOAT yFrac,
                                     MCDFLOAT xErr);
VOID FASTCALL __HWAdjustRightEdge(DEVRC *pRc, MCDVERTEX *p,
                                  MCDFLOAT fdxRight, MCDFLOAT fdyRight, 
                                  MCDFLOAT xErr);
VOID FASTCALL __MCDCalcDeltaRGBZ(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                 MCDVERTEX *c);
MCDFLOAT FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc);

// Fog function

VOID __MCDCalcFogColor(DEVRC *pRc, MCDVERTEX *a, MCDCOLOR *pResult, MCDCOLOR *pColor);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdclip.c ===
/******************************Module*Header*******************************\
* Module Name: mcdclip.c
*
* Contains the line and polygon clipping routines for an MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

MCDCOORD __MCD_frustumClipPlanes[6] = {
    {(MCDFLOAT) 1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // left
    {(MCDFLOAT)-1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // right
    {(MCDFLOAT) 0.0, (MCDFLOAT) 1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // bottom
    {(MCDFLOAT) 0.0, (MCDFLOAT)-1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // top
    {(MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0, (MCDFLOAT) 1.0 }, // zNear
    {(MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT)-1.0, (MCDFLOAT) 1.0 }, // zFar
};


////////////////////////////////////////////////////////////////////////
// Clipping macros used to build clip functions below.
////////////////////////////////////////////////////////////////////////


#define __MCD_CLIP_POS(v, a, b, t) \
    v->clipCoord.x = t*(a->clipCoord.x - b->clipCoord.x) + b->clipCoord.x;  \
    v->clipCoord.y = t*(a->clipCoord.y - b->clipCoord.y) + b->clipCoord.y;  \
    v->clipCoord.z = t*(a->clipCoord.z - b->clipCoord.z) + b->clipCoord.z;  \
    v->clipCoord.w = t*(a->clipCoord.w - b->clipCoord.w) + b->clipCoord.w

// Note that we compute the values needed for both "cheap" fog only...

#define __MCD_CLIP_FOG(v, a, b, t) \
    v->fog = t * (a->fog - b->fog) + b->fog;

#define __MCD_CLIP_COLOR(v, a, b, t) \
    v->colors[__MCD_FRONTFACE].r = t*(a->colors[__MCD_FRONTFACE].r      \
        - b->colors[__MCD_FRONTFACE].r) + b->colors[__MCD_FRONTFACE].r; \
    v->colors[__MCD_FRONTFACE].g = t*(a->colors[__MCD_FRONTFACE].g      \
        - b->colors[__MCD_FRONTFACE].g) + b->colors[__MCD_FRONTFACE].g; \
    v->colors[__MCD_FRONTFACE].b = t*(a->colors[__MCD_FRONTFACE].b      \
        - b->colors[__MCD_FRONTFACE].b) + b->colors[__MCD_FRONTFACE].b; \
    v->colors[__MCD_FRONTFACE].a = t*(a->colors[__MCD_FRONTFACE].a      \
        - b->colors[__MCD_FRONTFACE].a) + b->colors[__MCD_FRONTFACE].a

#define __MCD_CLIP_BACKCOLOR(v, a, b, t) \
    v->colors[__MCD_BACKFACE].r = t*(a->colors[__MCD_BACKFACE].r        \
        - b->colors[__MCD_BACKFACE].r) + b->colors[__MCD_BACKFACE].r;   \
    v->colors[__MCD_BACKFACE].g = t*(a->colors[__MCD_BACKFACE].g        \
        - b->colors[__MCD_BACKFACE].g) + b->colors[__MCD_BACKFACE].g;   \
    v->colors[__MCD_BACKFACE].b = t*(a->colors[__MCD_BACKFACE].b        \
        - b->colors[__MCD_BACKFACE].b) + b->colors[__MCD_BACKFACE].b;   \
    v->colors[__MCD_BACKFACE].a = t*(a->colors[__MCD_BACKFACE].a        \
        - b->colors[__MCD_BACKFACE].a) + b->colors[__MCD_BACKFACE].a

#define __MCD_CLIP_INDEX(v, a, b, t) \
    v->colors[__MCD_FRONTFACE].r = t*(a->colors[__MCD_FRONTFACE].r      \
        - b->colors[__MCD_FRONTFACE].r) + b->colors[__MCD_FRONTFACE].r

#define __MCD_CLIP_BACKINDEX(v, a, b, t) \
    v->colors[__MCD_BACKFACE].r = t*(a->colors[__MCD_BACKFACE].r        \
        - b->colors[__MCD_BACKFACE].r) + b->colors[__MCD_BACKFACE].r

#define __MCD_CLIP_TEXTURE(v, a, b, t) \
    v->texCoord.x = t*(a->texCoord.x - b->texCoord.x) + b->texCoord.x; \
    v->texCoord.y = t*(a->texCoord.y - b->texCoord.y) + b->texCoord.y;
#ifdef CLIP_TEXTURE_XFORM
    v->texCoord.z = t*(a->texCoord.z - b->texCoord.z) + b->texCoord.z; \
    v->texCoord.w = t*(a->texCoord.w - b->texCoord.w) + b->texCoord.w
#endif

////////////////////////////////////////////////////////////////////////
// Clipping functions to clip vertices:
////////////////////////////////////////////////////////////////////////

static VOID FASTCALL Clip(MCDVERTEX *dst, const MCDVERTEX *a,
                          const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
}

static VOID FASTCALL ClipC(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
}

static VOID FASTCALL ClipI(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
}

static VOID FASTCALL ClipBC(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
}

static VOID FASTCALL ClipBI(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
}

static VOID FASTCALL ClipT(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipIT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBIT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipCT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}


static VOID FASTCALL ClipBCT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipF(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipIF(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipCF(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipBCF(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipBIF(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipIFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBIFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                              const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}


static VOID FASTCALL ClipCFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBCFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                              const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID (FASTCALL *clipProcs[20])(MCDVERTEX*, const MCDVERTEX*, 
                                      const MCDVERTEX*, MCDFLOAT) =
{
    Clip,   ClipI,   ClipC,   ClipBI,   ClipBC,
    ClipF,  ClipIF,  ClipCF,  ClipBIF,  ClipBCF,
    ClipT,  ClipIT,  ClipCT,  ClipBIT,  ClipBCT,
    ClipFT, ClipIFT, ClipCFT, ClipBIFT, ClipBCFT,
};


VOID FASTCALL __MCDPickClipFuncs(DEVRC *pRc)
{
    LONG line = 0, poly = 0;
    BOOL twoSided = (pRc->MCDState.enables & MCD_LIGHTING_ENABLE) &&
	            (pRc->MCDState.twoSided);

    if (pRc->bRGBMode) {
	if (pRc->MCDState.shadeModel != GL_FLAT) {
	    line = 2;
            poly = (twoSided ? 4 : 2);
	}
    } else {
	if (pRc->MCDState.shadeModel != GL_FLAT) {
	    line = 1;
            poly = (twoSided ? 3 : 1);
	}
    }
    if ((pRc->bCheapFog) && !(pRc->MCDState.shadeModel == GL_SMOOTH)) {
	{
	    line += 5;
	    poly += 5;
	}
    }

    if (pRc->MCDState.textureEnabled) {
	line += 10;
	poly += 10;
    }

    pRc->lineClipParam = clipProcs[line];
    pRc->polyClipParam = clipProcs[poly];
}


////////////////////////////////////////////////////////////////////////
// The real primitive clippers:
////////////////////////////////////////////////////////////////////////

/*
** The following is a discussion of the math used to do edge clipping against
** a clipping plane.
** 
**     P1 is an end point of the edge
**     P2 is the other end point of the edge
** 
**     Q = t*P1 + (1 - t)*P2
**     That is, Q lies somewhere on the line formed by P1 and P2.
** 
**     0 <= t <= 1
**     This constrains Q to lie between P1 and P2.
** 
**     C is the plane equation for the clipping plane
** 
**     D1 = P1 dot C
**     D1 is the distance between P1 and C.  If P1 lies on the plane
**     then D1 will be zero.  The sign of D1 will determine which side
**     of the plane that P1 is on, with negative being outside.
** 
**     D2 = P2 dot C
**     D2 is the distance between P2 and C.  If P2 lies on the plane
**     then D2 will be zero.  The sign of D2 will determine which side
**     of the plane that P2 is on, with negative being outside.
** 
** Because we are trying to find the intersection of the P1 P2 line
** segment with the clipping plane we require that:
** 
**     Q dot C = 0
** 
** Therefore
** 
**     (t*P1 + (1 - t)*P2) dot C = 0
** 
**     (t*P1 + P2 - t*P2) dot C = 0
** 
**     t*P1 dot C + P2 dot C - t*P2 dot C = 0
** 
** Substituting D1 and D2 in
** 
**     t*D1 + D2 - t*D2 = 0
** 
** Solving for t
** 
**     t = -D2 / (D1 - D2)
** 
**     t = D2 / (D2 - D1)
*/


static LONG clipToPlane(DEVRC *pRc, MCDVERTEX **iv, LONG niv,
                        MCDVERTEX **ov, MCDCOORD *plane)
{
    LONG i, nout, generated;
    MCDVERTEX *s, *p, *newVertex, *temp;
    MCDFLOAT pDist, sDist, t;
    MCDFLOAT zero = ZERO;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    nout = 0;
    generated = 0;
    temp = pRc->pNextClipTemp;
    clip = pRc->polyClipParam;

    s = iv[niv-1];
    sDist = (s->clipCoord.x * plane->x) + (s->clipCoord.y * plane->y) +
	    (s->clipCoord.z * plane->z) + (s->clipCoord.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->clipCoord.x * plane->x) + (p->clipCoord.y * plane->y) +
		(p->clipCoord.z * plane->z) + (p->clipCoord.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = pDist / (pDist - sDist);
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
                newVertex->flags = s->flags;
                newVertex->clipCode = s->clipCode;
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __MCDDoClip.
		*/
		t = sDist / (sDist - pDist);
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		newVertex->flags = s->flags | MCDVERTEX_EDGEFLAG;
                newVertex->clipCode = p->clipCode;
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    pRc->pNextClipTemp = temp;
    return nout;
}

/* 
** Identical to clipToPlane(), except that the clipping is done in eye
** space.
*/
static LONG clipToPlaneEye(DEVRC *pRc, MCDVERTEX **iv, LONG niv,
			   MCDVERTEX **ov, MCDCOORD *plane)
{
    LONG i, nout, generated;
    MCDVERTEX *s, *p, *newVertex, *temp;
    MCDFLOAT pDist, sDist, t;
    MCDFLOAT zero = __MCDZERO;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    nout = 0;
    generated = 0;
    temp = pRc->pNextClipTemp;
    clip = pRc->polyClipParam;

    s = iv[niv-1];
    sDist = (s->eyeCoord.x * plane->x) +
	    (s->eyeCoord.y * plane->y) +
	    (s->eyeCoord.z * plane->z) +
	    (s->eyeCoord.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->eyeCoord.x * plane->x) +
		(p->eyeCoord.y * plane->y) +
		(p->eyeCoord.z * plane->z) +
		(p->eyeCoord.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = pDist / (pDist - sDist);
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
		newVertex->eyeCoord.x = t*(s->eyeCoord.x - p->eyeCoord.x) + p->eyeCoord.x;
		newVertex->eyeCoord.y = t*(s->eyeCoord.y - p->eyeCoord.y) + p->eyeCoord.y;
		newVertex->eyeCoord.z = t*(s->eyeCoord.z - p->eyeCoord.z) + p->eyeCoord.z;
		newVertex->eyeCoord.w = t*(s->eyeCoord.w - p->eyeCoord.w) + p->eyeCoord.w;
		newVertex->flags = s->flags;
                newVertex->clipCode = s->clipCode;      //!!!!
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __MCDDoClip.
		*/
		t = sDist / (sDist - pDist);
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		newVertex->eyeCoord.x = t*(p->eyeCoord.x - s->eyeCoord.x) + s->eyeCoord.x;
		newVertex->eyeCoord.y = t*(p->eyeCoord.y - s->eyeCoord.y) + s->eyeCoord.y;
		newVertex->eyeCoord.z = t*(p->eyeCoord.z - s->eyeCoord.z) + s->eyeCoord.z;
		newVertex->eyeCoord.w = t*(p->eyeCoord.w - s->eyeCoord.w) + s->eyeCoord.w;
		newVertex->flags = s->flags | MCDVERTEX_EDGEFLAG;
                newVertex->clipCode = p->clipCode;
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    pRc->pNextClipTemp = temp;
    return nout;
}

/*
** Each clipping plane can add at most one vertex to a convex polygon (it may
** remove up to all of the vertices).  The clipping will leave a polygon
** convex.  Because of this the maximum number of verticies output from
** the clipToPlane procedure will be total number of clip planes (assuming
** each plane adds one new vertex) plus the original number of verticies
** (3 since this if for triangles).
*/

#define __MCD_TOTAL_CLIP_PLANES 6 + MCD_MAX_USER_CLIP_PLANES
#define __MCD_MAX_POLYGON_CLIP_SIZE     256

#define	__MCD_MAX_CLIP_VERTEX (__MCD_TOTAL_CLIP_PLANES + __MCD_MAX_POLYGON_CLIP_SIZE)


void FASTCALL __MCDDoClippedPolygon(DEVRC *pRc, MCDVERTEX **iv, ULONG nout,
                                    ULONG allClipCodes)
{
    MCDVERTEX *ov[__MCD_TOTAL_CLIP_PLANES][__MCD_MAX_CLIP_VERTEX];
    MCDVERTEX **ivp;
    MCDVERTEX **ovp;
    MCDVERTEX *p0, *p1, *p2;
    MCDCOORD *plane;
    LONG i;
    MCDFLOAT one;
    VOID (FASTCALL *rt)(DEVRC*, MCDVERTEX*, MCDVERTEX*, MCDVERTEX*);
    MCDFLOAT llx, lly, urx, ury;
    MCDFLOAT winx, winy;
    ULONG clipCodes;

    /*
    ** Reset nextClipTemp pointer for any new verticies that are generated
    ** during the clipping.
    */

    pRc->pNextClipTemp = &pRc->clipTemp[0];

    ivp = &iv[0];

    /*
    ** Check each of the clipping planes by examining the allClipCodes
    ** mask. Note that no bits will be set in allClipCodes for clip
    ** planes that are not enabled.
    */
    if (allClipCodes) {

	/* Now clip against the clipping planes */
	ovp = &ov[0][0];

	/* 
	** Do user clip planes first, because we will maintain eye coordinates
	** only while doing user clip planes.  They are ignored for the 
	** frustum clipping planes.
	*/
	clipCodes = (allClipCodes >> 6) & __MCD_USER_CLIP_MASK;
	if (clipCodes) {
	    plane = &pRc->MCDState.userClipPlanes[0];
	    do {
		if (clipCodes & 1) {
		    nout = clipToPlaneEye(pRc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __MCD_MAX_CLIP_VERTEX;
		}
		clipCodes >>= 1;
		plane++;
	    } while (clipCodes);
	}

	allClipCodes &= MCD_CLIP_MASK;
	if (allClipCodes) {
	    plane = &__MCD_frustumClipPlanes[0];
	    do {
		if (allClipCodes & 1) {
		    nout = clipToPlane(pRc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __MCD_MAX_CLIP_VERTEX;
		}
		allClipCodes >>= 1;
		plane++;
	    } while (allClipCodes);
	}

	/*
	** Calculate final screen coordinates.  Next phase of polygon
	** processing assumes that window coordinates are already computed.
	*/

	ovp = ivp;
	one = __MCDONE;

	llx = pRc->MCDViewport.xCenter - pRc->MCDViewport.xScale;
	urx = pRc->MCDViewport.xCenter + pRc->MCDViewport.xScale;

	if (pRc->MCDViewport.yScale > 0) {
	    lly = pRc->MCDViewport.yCenter - pRc->MCDViewport.yScale;
	    ury = pRc->MCDViewport.yCenter + pRc->MCDViewport.yScale;
	} else {
	    lly = pRc->MCDViewport.yCenter + pRc->MCDViewport.yScale;
	    ury = pRc->MCDViewport.yCenter - pRc->MCDViewport.yScale;
	}

	for (i = nout; --i >= 0; ) {
	    MCDFLOAT wInv;

	    p0 = *ovp++;

	    if (p0->clipCoord.w == (MCDFLOAT) 0.0)
		wInv = (MCDFLOAT) 0.0; 
	    else 
		wInv = one / p0->clipCoord.w;

	    winx = p0->clipCoord.x * pRc->MCDViewport.xScale * wInv + 
                   pRc->MCDViewport.xCenter;

	    winy = p0->clipCoord.y * pRc->MCDViewport.yScale * wInv + 
                   pRc->MCDViewport.yCenter;

	    /* 
	    ** Check if these window coordinates are legal.  At this 
	    ** point, it is quite possible that they are not.  Trivially
	    ** pull them into the legal viewport region if necessary.
	    */

	    if (winx < llx) winx = llx;
	    else if (winx > urx) winx = urx;
	    if (winy < lly) winy = lly;
	    else if (winy > ury) winy = ury;

	    p0->windowCoord.x = winx;
	    p0->windowCoord.y = winy;
	    p0->windowCoord.z = p0->clipCoord.z * pRc->MCDViewport.zScale * wInv + 
                                pRc->MCDViewport.zCenter;
	    p0->windowCoord.w = wInv;
	}
    }

    /*
    ** Subdivide the clipped polygon into triangles.  Only convex polys
    ** are supported so this is okay to do.  Non-convex polys will do
    ** something odd here, but thats the clients fault.
    */
    p0 = *ivp++;
    p1 = *ivp++;
    p2 = *ivp++;
    rt = pRc->renderTri;
    if (nout == 3) {
	(*rt)(pRc, p0, p1, p2);
    } else {
	for (i = 0; i < (LONG)nout - 2; i++) {
	    ULONG t1, t2;
	    if (i == 0) {
		/*
		** Third edge of first sub-triangle is always non-boundary
		*/
		t1 = p2->flags & MCDVERTEX_EDGEFLAG;
		p2->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p2->flags |= t1;
	    } else
	    if (i == (LONG)nout - 3) {
		/*
		** First edge of last sub-triangle is always non-boundary
		*/
		t1 = p0->flags & MCDVERTEX_EDGEFLAG;
		p0->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p0->flags |= t1;
	    } else {
		/*
		** Interior sub-triangles have the first and last edge
		** marked non-boundary
		*/

		t1 = p0->flags & MCDVERTEX_EDGEFLAG;
		t2 = p2->flags & MCDVERTEX_EDGEFLAG;
		p0->flags &= ~MCDVERTEX_EDGEFLAG;
		p2->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p0->flags |= t1;
		p2->flags |= t2;
	    }
	    p1 = p2;
	    p2 = (MCDVERTEX *) *ivp++;
	}
    }
}


VOID FASTCALL __MCDClipPolygon(DEVRC *pRc, MCDVERTEX *v0, ULONG nv)
{
    MCDVERTEX *iv[__MCD_MAX_POLYGON_CLIP_SIZE];

    MCDVERTEX **ivp;
    LONG i;
    ULONG andCodes, orCodes;

    pRc->pvProvoking = v0;

    /*
    ** Generate array of addresses of the verticies.  And all the
    ** clip codes together while we are at it.
    */
    ivp = &iv[0];
    andCodes = 0;
    orCodes = 0;
    for (i = nv; --i >= 0; ) {
	andCodes &= v0->clipCode;
	orCodes |= v0->clipCode;
	*ivp++ = v0++;
    }

    if (andCodes != 0) {
	/*
	** Trivially reject the polygon.  If andCodes is non-zero then
	** every vertex in the polygon is outside of the same set of
	** clipping planes (at least one).
	*/
	return;
    }
    __MCDDoClippedPolygon(pRc, &iv[0], nv, orCodes);
}

void FASTCALL __MCDClipTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c, ULONG orCodes)
{
    MCDVERTEX *iv[3];

    iv[0] = a;
    iv[1] = b;
    iv[2] = c;

    __MCDDoClippedPolygon(pRc, &iv[0], 3, orCodes);
}


////////////////////////////////////////////////////////////////////////
// Line clipping:
////////////////////////////////////////////////////////////////////////

//
// Clip a line against the frustum clip planes and any user clipping planes.
// If an edge remains after clipping then compute the window coordinates
// and invoke the renderer.
//
// Notice:  This algorithim is an example of an implementation that is
// different than what the spec says.  This is equivalent in functionality
// and meets the spec, but doesn't clip in eye space.  This clipper clips
// in NTVP (clip) space.
//
// Trivial accept/reject has already been dealt with.
//

VOID FASTCALL __MCDClipLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                           BOOL bResetLine)
{
    MCDVERTEX *provokingA = a;
    MCDVERTEX *provokingB = b;
    MCDVERTEX np1, np2;
    MCDCOORD *plane;
    ULONG needs, allClipCodes, clipCodes;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);
    MCDFLOAT zero;
    MCDFLOAT winx, winy;
    MCDFLOAT vpXCenter, vpYCenter, vpZCenter;
    MCDFLOAT vpXScale, vpYScale, vpZScale;
    MCDVIEWPORT *vp;
    MCDFLOAT x, y, z, wInv;

    allClipCodes = a->clipCode | b->clipCode;

    /*
    ** For each clipping plane that something is out on, clip
    ** check the verticies.  Note that no bits will be set in
    ** allClipCodes for clip planes that are not enabled.
    */
    zero = __MCDZERO;
    clip = pRc->lineClipParam;

    /* 
    ** Do user clip planes first, because we will maintain eye coordinates
    ** only while doing user clip planes.  They are ignored for the
    ** frustum clipping planes.
    */
    clipCodes = (allClipCodes >> 6) & __MCD_USER_CLIP_MASK;
    if (clipCodes) {
        plane = &pRc->MCDState.userClipPlanes[0];
        do {
            /*
            ** See if this clip plane has anything out of it.  If not,
            ** press onward to check the next plane.  Note that we
            ** shift this mask to the right at the bottom of the loop.
            */
            if (clipCodes & 1) {
                MCDFLOAT t, d1, d2;

                d1 = (plane->x * a->eyeCoord.x) + 
                     (plane->y * a->eyeCoord.y) +
                     (plane->z * a->eyeCoord.z) + 
                     (plane->w * a->eyeCoord.w);
                d2 = (plane->x * b->eyeCoord.x) + 
                     (plane->y * b->eyeCoord.y) +
                     (plane->z * b->eyeCoord.z) + 
                     (plane->w * b->eyeCoord.w);
                if (d1 < zero) {
                    /* a is out */
                    if (d2 < zero) {
                        /* a & b are out */
                        return;
                    }

                    /*
                    ** A is out and B is in.  Compute new A coordinate
                    ** clipped to the plane.
                    */
                    t = d2 / (d2 - d1);
                    (*clip)(&np1, a, b, t);
                    (&np1)->eyeCoord.x = 
                        t*(a->eyeCoord.x - b->eyeCoord.x) + b->eyeCoord.x;
                    (&np1)->eyeCoord.y = 
                        t*(a->eyeCoord.y - b->eyeCoord.y) + b->eyeCoord.y;
                    (&np1)->eyeCoord.z = 
                        t*(a->eyeCoord.z - b->eyeCoord.z) + b->eyeCoord.z;
                    (&np1)->eyeCoord.w = 
                        t*(a->eyeCoord.w - b->eyeCoord.w) + b->eyeCoord.w;
                    a = &np1;
                    a->flags = b->flags;

                    if (pRc->MCDState.shadeModel == GL_FLAT)
                    {
                        COPY_COLOR(a->colors[0], provokingA->colors[0]);
                    }

                } else {
                    /* a is in */
                    if (d2 < zero) {
                        /*
                        ** A is in and B is out.  Compute new B
                        ** coordinate clipped to the plane.
                        **
                        ** NOTE: To avoid cracking in polygons with
                        ** shared clipped edges we always compute "t"
                        ** from the out vertex to the in vertex.  The
                        ** above clipping code gets this for free (b is
                        ** in and a is out).  In this code b is out and a
                        ** is in, so we reverse the t computation and the
                        ** argument order to (*clip).
                        */
                        t = d1 / (d1 - d2);
                        (*clip)(&np2, b, a, t);
                        (&np2)->eyeCoord.x =
                            t*(b->eyeCoord.x - a->eyeCoord.x) + a->eyeCoord.x;
                        (&np2)->eyeCoord.y =
                            t*(b->eyeCoord.y - a->eyeCoord.y) + a->eyeCoord.y;
                        (&np2)->eyeCoord.z =
                            t*(b->eyeCoord.z - a->eyeCoord.z) + a->eyeCoord.z;
                        (&np2)->eyeCoord.w =
                            t*(b->eyeCoord.w - a->eyeCoord.w) + a->eyeCoord.w;
                        b = &np2;
                        b->flags = a->flags;

                        if (pRc->MCDState.shadeModel == GL_FLAT)
                        {
                            COPY_COLOR(b->colors[0], provokingB->colors[0]);
                        }

                    } else {
                        /* A and B are in */
                    }
                }
            }
            plane++;
            clipCodes >>= 1;
        } while (clipCodes);
    }

    allClipCodes &= MCD_CLIP_MASK;
    if (allClipCodes) {
        plane = &__MCD_frustumClipPlanes[0];
        do {
            /*
            ** See if this clip plane has anything out of it.  If not,
            ** press onward to check the next plane.  Note that we
            ** shift this mask to the right at the bottom of the loop.
            */
            if (allClipCodes & 1) {
                MCDFLOAT t, d1, d2;

                d1 = (plane->x * a->clipCoord.x) + (plane->y * a->clipCoord.y) +
                     (plane->z * a->clipCoord.z) + (plane->w * a->clipCoord.w);
                d2 = (plane->x * b->clipCoord.x) + (plane->y * b->clipCoord.y) +
                     (plane->z * b->clipCoord.z) + (plane->w * b->clipCoord.w);
                if (d1 < zero) {
                    /* a is out */
                    if (d2 < zero) {
                        /* a & b are out */
                        return;
                    }

                    /*
                    ** A is out and B is in.  Compute new A coordinate
                    ** clipped to the plane.
                    */
                    t = d2 / (d2 - d1);
                    (*clip)(&np1, a, b, t);
                    a = &np1;
                    a->flags = b->flags;

                    if (pRc->MCDState.shadeModel == GL_FLAT)
                    {
                        COPY_COLOR(a->colors[0], provokingA->colors[0]);
                    }

                } else {
                    /* a is in */
                    if (d2 < zero) {
                        /*
                        ** A is in and B is out.  Compute new B
                        ** coordinate clipped to the plane.
                        **
                        ** NOTE: To avoid cracking in polygons with
                        ** shared clipped edges we always compute "t"
                        ** from the out vertex to the in vertex.  The
                        ** above clipping code gets this for free (b is
                        ** in and a is out).  In this code b is out and a
                        ** is in, so we reverse the t computation and the
                        ** argument order to (*clip).
                        */
                        t = d1 / (d1 - d2);
                        (*clip)(&np2, b, a, t);
                        b = &np2;
                        b->flags = a->flags;

                        if (pRc->MCDState.shadeModel == GL_FLAT)
                        {
                            COPY_COLOR(b->colors[0], provokingB->colors[0]);
                        }

                    } else {
                        /* A and B are in */
                    }
                }
            }
            plane++;
            allClipCodes >>= 1;
        } while (allClipCodes);
    }

    vp = &pRc->MCDViewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    /* Compute window coordinates for both vertices. */
    wInv = __MCDONE / a->clipCoord.w;
    x = a->clipCoord.x; 
    y = a->clipCoord.y; 
    z = a->clipCoord.z;
    winx = x * vpXScale * wInv + vpXCenter;
    winy = y * vpYScale * wInv + vpYCenter;
    a->windowCoord.z = z * vpZScale * wInv + vpZCenter;
    a->windowCoord.w = wInv;
    a->windowCoord.x = winx;
    a->windowCoord.y = winy;

    wInv = __MCDONE / b->clipCoord.w;
    x = b->clipCoord.x; 
    y = b->clipCoord.y; 
    z = b->clipCoord.z;
    winx = x * vpXScale * wInv + vpXCenter;
    winy = y * vpYScale * wInv + vpYCenter;
    b->windowCoord.z = z * vpZScale * wInv + vpZCenter;
    b->windowCoord.w = wInv;
    b->windowCoord.x = winx;
    b->windowCoord.y = winy;

    /* Validate line state */
    if (pRc->MCDState.shadeModel == GL_FLAT) {

        // Add the vertices then restore the b color pointer
        //
        // Note that although b is the only new vertex, up
        // to two vertices can be added because each new vertex
        // generated by clipping must be added.  For a line where
        // both endpoints are out of the clipping region, both
        // an entry and an exit vertex must be added
        if (provokingA->clipCode != 0)
        {
            // a was out so a new vertex was added at the point of
            // entry
            bResetLine = TRUE;
        }
        // b is always added since either:
        // b was in and is new so it needs to be added
        // b was out so a new vertex was added at the exit point

        (*pRc->renderLine)(pRc, a, b, bResetLine);
        
    } else {

        if (provokingA->clipCode != 0)
        {
            bResetLine = TRUE;
        }
        (*pRc->renderLine)(pRc, a, b, bResetLine);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdpoint.c ===
/******************************Module*Header*******************************\
* Module Name: mcdpoint.c
*
* Contains the point-rendering routines for the Millenium MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#define TRUNCCOORD(value, intValue)\
    intValue = __MCD_VERTEX_FIXED_TO_INT(__MCD_VERTEX_FLOAT_TO_FIXED(value))


VOID FASTCALL __MCDPointBegin(DEVRC *pRc)
{
    BYTE *pjBase = ((PDEV *)pRc->ppdev)->pjBase;

    if ((pRc->pEnumClip->c) <= 1) {
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 1);
        CP_WRITE(pjBase, DWG_DWGCTL, pRc->hwLineFunc);
    } else {

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 9);
    
        CP_WRITE(pjBase, DWG_DWGCTL, pRc->hwLineFunc);

        // ?? Theoretically just need to clear y deltas, not both:

        CP_WRITE(pjBase, DWG_DR6, 0);
        CP_WRITE(pjBase, DWG_DR7, 0);

        CP_WRITE(pjBase, DWG_DR10, 0);
        CP_WRITE(pjBase, DWG_DR11, 0);

        CP_WRITE(pjBase, DWG_DR14, 0);
        CP_WRITE(pjBase, DWG_DR15, 0);

        CP_WRITE(pjBase, DWG_DR2, 0);
        CP_WRITE(pjBase, DWG_DR3, 0);
    }
}


VOID FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *a)
{
    PDEV *ppdev = pRc->ppdev;
    BYTE *pjBase = ppdev->pjBase;
    LONG ix, iy;
    LONG iRStart, iGStart, iBStart;
    LARGE_INTEGER iZStart;
    ULONG clipNum;
    RECTL *pClip;
    MCDCOLOR *ac;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    if (pRc->privateEnables & __MCDENABLE_Z) {

#if _X86_ && ASM_ACCEL
        _asm {
        mov     ecx, a
        mov     edx, pRc
        lea     eax, [OFFSET(MCDVERTEX.colors) + ecx]
        fld     DWORD PTR [OFFSET(DEVRC.rScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.gScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.bScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ecx]
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][edx]   // z b g r
        fxch    ST(3)                                   // r b g z
        fistp   iRStart
        fistp   iBStart
        fistp   iGStart
        fistp   iZStart
        }
#else
        ac = &a->colors[0];
        iRStart = FTOL(ac->r * pRc->rScale);
        iGStart = FTOL(ac->g * pRc->gScale);
        iBStart = FTOL(ac->b * pRc->bScale);
        iZStart.LowPart = FTOL(a->windowCoord.z * pRc->zScale);
#endif
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 6);
        CP_WRITE(pjBase, DWG_DR0, iZStart.LowPart);

    } else {
#if _X86_ && ASM_ACCEL
        _asm{
        mov     eax, a
        mov     edx, pRc
        lea     eax, [OFFSET(MCDVERTEX.colors) + eax]
        fld     DWORD PTr [OFFSET(DEVRC.rScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fld     DWORD PTr [OFFSET(DEVRC.gScale)][edx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fld     DWORD PTr [OFFSET(DEVRC.bScale)][edx]   // b g r
        fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
        fxch    ST(2)                                   // r g b
        fistp   iRStart
        fistp   iGStart
        fistp   iBStart
        }
#else
        ac = &a->colors[0];

        iRStart = FTOL(ac->r * pRc->rScale);
        iGStart = FTOL(ac->g * pRc->gScale);
        iBStart = FTOL(ac->b * pRc->bScale);
#endif

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 5);
    }

    TRUNCCOORD(a->windowCoord.x, ix);
    TRUNCCOORD(a->windowCoord.y, iy);

    CP_WRITE(pjBase, DWG_XDST, (ix + pRc->xOffset) & 0xffff);
    CP_WRITE(pjBase, DWG_YDSTLEN, ((iy + pRc->yOffset) << 16) + 1);
    CP_WRITE(pjBase, DWG_DR4,  iRStart);
    CP_WRITE(pjBase, DWG_DR8,  iGStart);
    CP_START(pjBase, DWG_DR12, iBStart);

    while (--clipNum) {
        (*pRc->HWSetupClipRect)(pRc, pClip++);

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 2);

        CP_WRITE(pjBase, DWG_XDST, (ix + pRc->xOffset) & 0xffff);
        CP_START(pjBase, DWG_YDSTLEN, ((iy + pRc->yOffset) << 16) + 1);
    }

}

VOID FASTCALL __MCDRenderGenPoint(DEVRC *pRc, MCDVERTEX *pv)
{
    MCDBG_PRINT("__MCDRenderGenPoint");
}

VOID FASTCALL __MCDRenderFogPoint(DEVRC *pRc, MCDVERTEX *pv)
{
    MCDCOLOR c;

    c = pv->colors[0];
    __MCDCalcFogColor(pRc, pv, &pv->colors[0], &c);
    (*pRc->renderPointX)(pRc, pv);
    pv->colors[0] = c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdrend.c ===
/******************************Module*Header*******************************\
* Module Name: mcdrend.c
*
* This file contains routines to do high-level triangle rendering for the
* Millenium MCD driver, including culling and face computations.  Note that
* in this driver, we don't use vertex color pointer at all since all pointer
* references need to be checked to avoid the possibility of an invalid
* memory reference.  Instead, we copy the color data in the cases where we
* need to during two-sided operation.  This is not the common case, and even
* in the case where the color data needs to be copied to colors[0] (and back),
* the copy only needs to be done for (on average) half the faces.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"
#include "math.h"

#if _X86_

#define GET_HALF_AREA(pRc, a, b, c)\
\
__asm{ mov     ecx, c                                                                           };\
__asm{ mov     eax, a                                                                           };\
__asm{ mov     ebx, b                                                                           };\
__asm{ mov     edx, pRc                                                                         };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ecx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][eax]  /* dxAC                     */ };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ecx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ebx]  /* dyBC dxAC                */ };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ecx]  /* dxBC dyBC dxAC           */ };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ebx]                                 };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ecx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][eax]  /* dyAC dxBC dyBC dxAC      */ };\
__asm{ fxch    ST(2)                                             /* dyBC dxBC dyAC dxAC      */ };\
__asm{ fst     DWORD PTR [OFFSET(DEVRC.dyBC)][edx]                                              };\
__asm{ fmul    ST, ST(3)                                         /* dxACdyBC dxBC dyAC dxAC  */ };\
__asm{ fxch    ST(2)                                             /* dyAC dxBC dxACdyBC dxAC  */ };\
__asm{ fst     DWORD PTR [OFFSET(DEVRC.dyAC)][edx]                                              };\
__asm{ fmul    ST, ST(1)                                         /* dxBCdyAC dxBC dxACdyBC dxAC */ };\
__asm{ fxch    ST(1)                                             /* dxBC dxBCdyAC dxACdyBC dxAC */ };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxBC)][edx]               /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ebx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][eax]  /* dxAB dxBCdyAC dxACdyBC dxAC  */ };\
__asm{ fxch    ST(1)                                             /* dxBCdyAC dxAB dxACdyBC  dxAC */ };\
__asm{ fsubp   ST(2), ST                                         /* dxAB area dxAC */           };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ebx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][eax]  /* dyAB dxAB area  dxAC */     };\
__asm{ fxch    ST(3)                                             /* dxAC dxAB area  dyAB */     };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxAC)][edx]               /* dxAB area  dyAB */          };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxAB)][edx]               /* area  dyAB */               };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.halfArea)][edx]           /* dyAB */                     };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dyAB)][edx]               /* (empty) */                  };

#else

#define GET_HALF_AREA(pRc, a, b, c)\
    /* Compute signed half-area of the triangle */                          \
    (pRc)->dxAC = (c)->windowCoord.x - (a)->windowCoord.x;                  \
    (pRc)->dxBC = (c)->windowCoord.x - (b)->windowCoord.x;                  \
    (pRc)->dyAC = (c)->windowCoord.y - (a)->windowCoord.y;                  \
    (pRc)->dyBC = (c)->windowCoord.y - (b)->windowCoord.y;                  \
    (pRc)->dxAB = (b)->windowCoord.x - (a)->windowCoord.x;                  \
    (pRc)->dyAB = (b)->windowCoord.y - (a)->windowCoord.y;                  \
                                                                            \
    (pRc)->halfArea = (pRc)->dxAC * (pRc)->dyBC - (pRc)->dxBC * (pRc)->dyAC;

#endif


#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
{                                                                           \
    LONG reversed;                                                          \
    MCDVERTEX *temp;                                                        \
                                                                            \
                                                                            \
    reversed = 0;                                                           \
    if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (b)->windowCoord.y)) {      \
        if (__MCD_VERTEX_COMPARE((b)->windowCoord.y, <, (c)->windowCoord.y)) {  \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (c)->windowCoord.y)) {\
                temp=(b); (b)=(c); (c)=temp;                                \
                reversed = 1;                                               \
            } else {                                                        \
                temp=(a); (a)=(c); (c)=(b); (b)=temp;                       \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__MCD_VERTEX_COMPARE((b)->windowCoord.y, <, (c)->windowCoord.y)) {  \
            if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (c)->windowCoord.y)) {\
                temp=(a); (a)=(b); (b)=temp;                                \
                reversed = 1;                                               \
            } else {                                                        \
                temp=(a); (a)=(b); (b)=(c); (c)=temp;                       \
            }                                                               \
        } else {                                                            \
            temp=(a); (a)=(c); (c)=temp;                                    \
            reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(pRc, (a), (b), (c));                                      \
                                                                            \
    (ccw) = !__MCD_FLOAT_LTZ(pRc->halfArea);                                \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    **          ccw     reversed                xor                         \
    **          ---     --------                ---                         \
    **          0       0                       0 (remain !ccw)             \
    **          1       0                       1 (remain ccw)              \
    **          0       1                       1 (become ccw)              \
    **          1       1                       0 (become cw)               \
    */                                                                      \
    (face) = pRc->polygonFace[(ccw) ^ reversed];                            \
    if ((face) == pRc->cullFlag) {                                          \
        /* Culled */                                                        \
        return;                                                             \
    }                                                                       \
}

////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDCalcZSlope(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c)
//
// Local helper routine to calculate z slopes for z-offseting primitives.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDCalcZSlope(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c)
{
    MCDFLOAT oneOverArea, t1, t2, t3, t4;
    MCDFLOAT dzAC, dzBC;

    if (CASTINT(pRc->halfArea) == 0) {
        pRc->dzdx = __MCDZERO;
        pRc->dzdy = __MCDZERO;
        return;
    }

    oneOverArea =  __MCDONE / pRc->halfArea;

    t1 = pRc->dyAC * oneOverArea;
    t2 = pRc->dyBC * oneOverArea;
    t3 = pRc->dxAC * oneOverArea;
    t4 = pRc->dxBC * oneOverArea;

    dzAC = c->windowCoord.z - a->windowCoord.z;
    dzBC = c->windowCoord.z - b->windowCoord.z;
    pRc->dzdx = (dzAC * t2 - dzBC * t1);
    pRc->dzdy = (dzBC * t3 - dzAC * t4);
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc)
//
// Returns required z offset value for current primitive.  Assumes that
// z deltas are already in RC.
//
////////////////////////////////////////////////////////////////////////


MCDFLOAT FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc)
{
#define FABS(f)  ((MCDFLOAT)fabs((double) (f)))
    MCDFLOAT maxdZ;

    // Find maximum x or y slope:

    if(FABS(pRc->dzdx) > FABS(pRc->dzdy))
        maxdZ = FABS(pRc->dzdx);
    else
        maxdZ = FABS(pRc->dzdy);

    return (pRc->MCDState.zOffsetFactor * maxdZ);
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                      MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the generic triangle-rendering routine.  This is used if either
// of the polygon faces are not GL_FILL.
//
////////////////////////////////////////////////////////////////////////

//!! Fix clipping logic, add startXXX logic

VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                     MCDVERTEX *c)
{
    LONG ccw, face;
    MCDVERTEX *oa, *ob, *oc;
    RECTL *pClip;
    ULONG clipNum;
    MCDFLOAT zOffset;
    MCDCOLOR tempA, tempB, tempC;
    ULONG polygonMode;
    BOOL backFace;
    MCDVERTEX *pv;

//!!    MCDBG_PRINT("__MCDRenderGenTriangle");

    /*
    ** Save old vertex pointers in case we end up not doing a fill.
    */

    oa = a; ob = b; oc = c;

    SORT_AND_CULL_FACE(a, b, c, face, ccw);

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
        (*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    polygonMode = pRc->polygonMode[face];
    backFace = (pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
               (face == __MCD_BACKFACE);

    // Pick correct face color and render the triangle:

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

        if (backFace) {
            SWAP_COLOR(a);
            SWAP_COLOR(b);
            SWAP_COLOR(c);
        }

    } else { // Flat shading

        pv = pRc->pvProvoking;

        if (polygonMode == GL_FILL) {
            if (backFace) {
                SWAP_COLOR(pv);
            }
        } else {

            SAVE_COLOR(tempA, a);
            SAVE_COLOR(tempB, b);
            SAVE_COLOR(tempC, c);

            if (backFace) {
                SWAP_COLOR(pv);
            }

            a->colors[0] = pv->colors[0];
            b->colors[0] = pv->colors[0];
            c->colors[0] = pv->colors[0];
        }
    }

    // Render triangle using the current polygon mode for the face:

    switch (pRc->polygonMode[face]) {
        case GL_FILL:
            if (CASTINT(pRc->halfArea) != 0) {
                (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
                while (--clipNum) {
                    (*pRc->HWSetupClipRect)(pRc, pClip++);
                    (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
                }
            }
            break;
        case GL_POINT:

            (*pRc->beginPointDrawing)(pRc);

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_POINT_ENABLE) {
                __MCDCalcZSlope(pRc, a, b, c);
                zOffset = __MCDGetZOffsetDelta(pRc) + pRc->MCDState.zOffsetUnits;
                oa->windowCoord.z += zOffset;
                ob->windowCoord.z += zOffset;
                oc->windowCoord.z += zOffset;
            }

            if (oa->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, oa);
            }
            if (ob->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, ob);
            }
            if (oc->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, oc);
            }

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_POINT_ENABLE) {
                oa->windowCoord.z -= zOffset;
                ob->windowCoord.z -= zOffset;
                oc->windowCoord.z -= zOffset;
            }

            break;

        case GL_LINE:
            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_LINE_ENABLE) {
                __MCDCalcZSlope(pRc, a, b, c);
                zOffset = __MCDGetZOffsetDelta(pRc) + pRc->MCDState.zOffsetUnits;
                oa->windowCoord.z += zOffset;
                ob->windowCoord.z += zOffset;
                oc->windowCoord.z += zOffset;
            }

           (*pRc->beginLineDrawing)(pRc);

           if ((oa->flags & MCDVERTEX_EDGEFLAG) &&
                (ob->flags & MCDVERTEX_EDGEFLAG) &&
                (oc->flags & MCDVERTEX_EDGEFLAG)) {

                (*pRc->drawLine)(pRc, oa, ob, TRUE);
                (*pRc->drawLine)(pRc, ob, oc, 0);
                (*pRc->drawLine)(pRc, oc, oa, 0);

            } else {

                if (oa->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, oa, ob, TRUE);
                if (ob->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, ob, oc, TRUE);
                if (oc->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, oc, oa, TRUE);
            }

            (*pRc->endLineDrawing)(pRc);

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_LINE_ENABLE) {
                oa->windowCoord.z -= zOffset;
                ob->windowCoord.z -= zOffset;
                oc->windowCoord.z -= zOffset;
            }

            break;

        default:
            break;
    }

    // Restore original colors if needed:

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

        if (backFace) {

            SWAP_COLOR(a);
            SWAP_COLOR(b);
            SWAP_COLOR(c);
        }
    } else { // Flat shading

        if (polygonMode == GL_FILL) {
            if (backFace) {
                SWAP_COLOR(pv);
            }
        } else {

            if (backFace) {
                SWAP_COLOR(pv);
            }

            RESTORE_COLOR(tempA, a);
            RESTORE_COLOR(tempB, b);
            RESTORE_COLOR(tempC, c);
        }
    }
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                       MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the top-level flat-shaded triangle renderer.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                      MCDVERTEX *c)
{
    LONG ccw, face;
    RECTL *pClip;
    ULONG clipNum;

//!!    MCDBG_PRINT("__MCDRenderFlatTriangle");

    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (CASTINT(pRc->halfArea) == 0)
        return;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
        (*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    // Pick correct face color and render the triangle:

    if ((pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
        (face == __MCD_BACKFACE))
    {
        MCDVERTEX *pv = pRc->pvProvoking;

        SWAP_COLOR(pv);

        (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        }

        SWAP_COLOR(pv);
    }
    else
    {
        (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        }
    }
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                         MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the top-level smooth triangle renderer.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                        MCDVERTEX *c)
{
    LONG ccw, face;
    RECTL *pClip;
    ULONG clipNum;

//!!    MCDBG_PRINT("__MCDRenderSmoothTriangle");

    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (CASTINT(pRc->halfArea) == 0)
        return;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
        (*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    // Pick correct face color and render the triangle:

    if ((pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
        (face == __MCD_BACKFACE))
    {
        SWAP_COLOR(a);
        SWAP_COLOR(b);
        SWAP_COLOR(c);

        (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        }

        SWAP_COLOR(a);
        SWAP_COLOR(b);
        SWAP_COLOR(c);
    }
    else
    {
        (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, (BOOL) ccw);
        }
    }
}


VOID FASTCALL __MCDRenderFlatFogTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2,
                                         MCDVERTEX *pv3)
{
    MCDCOLOR c1, c2, c3;
    MCDCOLOR bc1, bc2, bc3;
    MCDCOLOR cProvoking;

    c1 = pv1->colors[0];
    c2 = pv2->colors[0];
    c3 = pv3->colors[0];

    // We have to save a copy of the provoking color since we
    // can overwrite it!

    cProvoking = pRc->pvProvoking->colors[0];

    __MCDCalcFogColor(pRc, pv1, &pv1->colors[0], &cProvoking);
    __MCDCalcFogColor(pRc, pv2, &pv2->colors[0], &cProvoking);
    __MCDCalcFogColor(pRc, pv3, &pv3->colors[0], &cProvoking);

    if (pRc->privateEnables & __MCDENABLE_TWOSIDED) {
        cProvoking = pRc->pvProvoking->colors[1];
        bc1 = pv1->colors[1];
        bc2 = pv2->colors[1];
        bc3 = pv3->colors[1];
        __MCDCalcFogColor(pRc, pv1, &pv1->colors[1], &cProvoking);
        __MCDCalcFogColor(pRc, pv2, &pv2->colors[1], &cProvoking);
        __MCDCalcFogColor(pRc, pv3, &pv3->colors[1], &cProvoking);
    }

    (*pRc->renderTriX)(pRc, pv1, pv2, pv3);

    pv1->colors[0] = c1;
    pv2->colors[0] = c2;
    pv3->colors[0] = c3;
    if (pRc->privateEnables & __MCDENABLE_TWOSIDED) {
        pv1->colors[1] = bc1;
        pv2->colors[1] = bc2;
        pv3->colors[1] = bc3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdtri.c ===
/******************************Module*Header*******************************\
* Module Name: rxtri.c
*
* Contains the low-level (rasterization) triangle-rendering routines for the
* Millenium MCD driver.
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

//#undef CHECK_FIFO_FREE
//#define CHECK_FIFO_FREE 

static MCDFLOAT fixScale = __MCDFIXSCALE;
                   

VOID FASTCALL __MCDCalcDeltaRGBZ(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                 MCDVERTEX *c)
{
    MCDFLOAT oneOverArea, t1, t2, t3, t4;
    LARGE_INTEGER temp;

    /*
    ** t1-4 are delta values for unit changes in x or y for each
    ** parameter.
    */

#if !(_X86_ && ASM_ACCEL)
    if (pRc->privateEnables & (__MCDENABLE_SMOOTH | __MCDENABLE_Z)) {
        __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, pRc->halfArea, &oneOverArea);
    }
#endif
    
    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

            MCDFLOAT drAC, dgAC, dbAC, daAC;
            MCDFLOAT drBC, dgBC, dbBC, daBC;
            MCDCOLOR *ac, *bc, *cc;

#if _X86_ && ASM_ACCEL
            __asm{

            mov     edx, pRc

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(DEVRC.dyAC)][edx]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(DEVRC.dyBC)][edx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(DEVRC.dxAC)][edx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(DEVRC.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4

            // Now, calculate deltas:

            mov     eax, a
            mov     ecx, c
            mov     ebx, b
            lea     eax, [OFFSET(MCDVERTEX.colors) + eax]
            lea     ecx, [OFFSET(MCDVERTEX.colors) + ecx]
            lea     ebx, [OFFSET(MCDVERTEX.colors) + ebx]

            fld     DWORD PTR [OFFSET(MCDCOLOR.r)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
            fld     DWORD PTR [OFFSET(MCDCOLOR.r)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.r)][ebx]
                                // drBC drAC
            fld     ST(1)       // drAC drBC drAC
            fmul    t2          // drACt2 drBC drAC
            fld     ST(1)       // drBC drACt2 drBC drAC
            fmul    t1          // drBCt1 drACt2 drBC drAC
            fxch    ST(2)       // drBC  drACt2 drBCt1 drAC
            fmul    t3          // drBCt3  drACt2 drBCt1 drAC
            fxch    ST(3)       // drAC drACt2 drBCt1 drBCt3
            fmul    t4          // drACt4 drACt2 drBCt1 drBCt3
            fxch    ST(2)       // drBCt1 drACt2 drACt4 drBCt3
            fsubp   ST(1), ST   // drACBC drACt4 drBCt3

            fld     DWORD PTR [OFFSET(MCDCOLOR.g)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.g)][ebx]
                                // dgBC drACBC drACt4 drBCt3

            fxch    ST(2)       // drACt4 drACBC dgBC drBCt3
            fsubp   ST(3), ST   // drACBC dgBC drBCAC
            fmul    DWORD PTR [OFFSET(DEVRC.rScale)][edx]
                                // DRACBC dgBC drBCAC
            fxch    ST(2)       // drBCAC dgBC DRACBC
            fmul    DWORD PTR [OFFSET(DEVRC.rScale)][edx]
                                // DRBCAC dgBC DRACBC
            
            fld     DWORD PTR [OFFSET(MCDCOLOR.g)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
                                // dgAC DRBCAC dgBC DRACBC
            fxch    ST(3)
                                // DRACBC DRBCAC dgBC dgAC

            fst     DWORD PTR [OFFSET(DEVRC.drdx)][edx]
            fistp   DWORD PTR [OFFSET(DEVRC.fxdrdx)][edx]
            fst     DWORD PTR [OFFSET(DEVRC.drdy)][edx]
            fistp   DWORD PTR [OFFSET(DEVRC.fxdrdy)][edx]

                                // dgBC dgAC
            fld     ST(1)       // dgAC dgBC dgAC
            fmul    t2          // dgACt2 dgBC dgAC
            fld     ST(1)       // dgBC dgACt2 dgBC dgAC
            fmul    t1          // dgBCt1 dgACt2 dgBC dgAC
            fxch    ST(2)       // dgBC  dgACt2 dgBCt1 dgAC
            fmul    t3          // dgBCt3  dgACt2 dgBCt1 dgAC
            fxch    ST(3)       // dgAC dgACt2 dgBCt1 dgBCt3
            fmul    t4          // dgACt4 dgACt2 dgBCt1 dgBCt3
            fxch    ST(2)       // dgBCt1 dgACt2 dgACt4 dgBCt3
            fsubp   ST(1), ST   // dgACBC dgACt4 dgBCt3

            fld     DWORD PTR [OFFSET(MCDCOLOR.b)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.b)][ebx]
                                // dbBC dgACBC dgACt4 dgBCt3

            fxch    ST(2)       // dgACt4 dgACBC dbBC dgBCt3
            fsubp   ST(3), ST   // dgACBC dbBC dgBCAC
            fmul    DWORD PTR [OFFSET(DEVRC.gScale)][edx]
                                // DGACBC dbBC dgBCAC
            fxch    ST(2)       // dgBCAC dbBC DGACBC
            fmul    DWORD PTR [OFFSET(DEVRC.gScale)][edx]
                                // DGBCAC dbBC DGACBC
            
            fld     DWORD PTR [OFFSET(MCDCOLOR.b)][ecx]
            fsub    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
                                // dbAC DGBCAC dbBC DGACBC
            fxch    ST(3)
                                // DGACBC DGBCAC dbBC dbAC

            fst     DWORD PTR [OFFSET(DEVRC.dgdx)][edx]
            fistp   DWORD PTR [OFFSET(DEVRC.fxdgdx)][edx]
            fst     DWORD PTR [OFFSET(DEVRC.dgdy)][edx]
            fistp   DWORD PTR [OFFSET(DEVRC.fxdgdy)][edx]

                                // dbBC dbAC
            fld     ST(1)       // dbAC dbBC dbAC
            fmul    t2          // dbACt2 dbBC dbAC
            fld     ST(1)       // dbBC dbACt2 dbBC dbAC
            fmul    t1          // dbBCt1 dbACt2 dbBC dbAC
            fxch    ST(2)       // dbBC  dbACt2 dbBCt1 dbAC
            fmul    t3          // dbBCt3  dbACt2 dbBCt1 dbAC
            fxch    ST(3)       // dbAC dbACt2 dbBCt1 dbBCt3
            fmul    t4          // dbACt4 dbACt2 dbBCt1 dbBCt3
            fxch    ST(2)       // dbBCt1 dbACt2 dbACt4 dbBCt3
            fsubp   ST(1), ST   // dbACBC dbACt4 dbBCt3

            fxch    ST(1)       // dbACt4 dbACBC dbBCt3
            fsubp   ST(2), ST   // dbACBC dbBCAC (+1) 
            fmul    DWORD PTR [OFFSET(DEVRC.bScale)][edx]
                                // DBACBC dbBCAC
            fxch    ST(1)       // dbBCAC DBACBC
            fmul    DWORD PTR [OFFSET(DEVRC.bScale)][edx]
                                // DBBCAC DBACBC
            fxch    ST(1)       // DBACBC DBBCAC

            fst     DWORD PTR [OFFSET(DEVRC.dbdx)][edx] //(+1)
            fistp   DWORD PTR [OFFSET(DEVRC.fxdbdx)][edx]
            fst     DWORD PTR [OFFSET(DEVRC.dbdy)][edx]
            fistp   DWORD PTR [OFFSET(DEVRC.fxdbdy)][edx]

            }
#else

            ac = &a->colors[0];
            bc = &b->colors[0];
            cc = &c->colors[0];

            drAC = cc->r - ac->r;
            drBC = cc->r - bc->r;
            dgAC = cc->g - ac->g;
            dgBC = cc->g - bc->g;
            dbAC = cc->b - ac->b;
            dbBC = cc->b - bc->b;

            __MCD_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);

            t1 = pRc->dyAC * oneOverArea;
            t2 = pRc->dyBC * oneOverArea;
            t3 = pRc->dxAC * oneOverArea;
            t4 = pRc->dxBC * oneOverArea;

            pRc->drdx = (drAC * t2 - drBC * t1) * pRc->rScale;
            pRc->drdy = (drBC * t3 - drAC * t4) * pRc->rScale;
            pRc->dgdx = (dgAC * t2 - dgBC * t1) * pRc->gScale;
            pRc->dgdy = (dgBC * t3 - dgAC * t4) * pRc->gScale;
            pRc->dbdx = (dbAC * t2 - dbBC * t1) * pRc->bScale;
            pRc->dbdy = (dbBC * t3 - dbAC * t4) * pRc->bScale;

            pRc->fxdrdx = FTOL(pRc->drdx);
            pRc->fxdrdy = FTOL(pRc->drdy);
            pRc->fxdgdx = FTOL(pRc->dgdx);
            pRc->fxdgdy = FTOL(pRc->dgdy);
            pRc->fxdbdx = FTOL(pRc->dbdx);
            pRc->fxdbdy = FTOL(pRc->dbdy);

#endif

    } else {

        // In this case, we're not smooth shading, but we still need
        // to set up the color registers:

        BYTE *pjBase;
#if _X86_ && ASM_ACCEL
        LONG rTemp, gTemp, bTemp;

        _asm{

        mov     ebx, pRc
        mov     eax, [OFFSET(DEVRC.pvProvoking)][ebx]       // AGI
        lea     eax, [OFFSET(MCDVERTEX.colors) + eax]

        fld     DWORD PTR [OFFSET(DEVRC.rScale)][ebx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.gScale)][ebx]
        fmul    DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fld     DWORD PTR [OFFSET(DEVRC.bScale)][ebx]     // B G R
        fmul    DWORD PTR [OFFSET(MCDCOLOR.b)][eax]

        fxch    ST(2)                                     // R G B
        fistp   rTemp                                     // G B
        fistp   gTemp
        fistp   bTemp
        
        }

        pjBase = pRc->ppdev->pjBase;
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3);
        CP_WRITE(pjBase, DWG_DR4,  rTemp);
        CP_WRITE(pjBase, DWG_DR8,  gTemp);
        CP_WRITE(pjBase, DWG_DR12, bTemp);

#else
        MCDCOLOR *pColor = &pRc->pvProvoking->colors[0];

        pjBase = pRc->ppdev->pjBase;
        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3);
        CP_WRITE(pjBase, DWG_DR4,  FTOL(pColor->r * pRc->rScale));
        CP_WRITE(pjBase, DWG_DR8,  FTOL(pColor->g * pRc->gScale));
        CP_WRITE(pjBase, DWG_DR12, FTOL(pColor->b * pRc->bScale));
#endif
    }

    if (pRc->privateEnables & __MCDENABLE_Z)
    {
        MCDFLOAT dzAC, dzBC;

        if (!(pRc->privateEnables & __MCDENABLE_SMOOTH))
        {
#if _X86_ && ASM_ACCEL
            _asm {

            mov     eax, pRc

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(DEVRC.dyAC)][eax]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(DEVRC.dyBC)][eax]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(DEVRC.dxAC)][eax]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(DEVRC.dxBC)][eax]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4
            }
#else
            __MCD_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);

            t1 = pRc->dyAC * oneOverArea;
            t2 = pRc->dyBC * oneOverArea;
            t3 = pRc->dxAC * oneOverArea;
            t4 = pRc->dxBC * oneOverArea;
#endif

        }

#if _X86_ && ASM_ACCEL

        _asm {

        mov     ecx, c
        mov     eax, a
        mov     ebx, b
        mov     edx, pRc

        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ecx]
        fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]
        fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ecx]
        fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][ebx]  
                                                        // dzBC dzAC
        fld     ST(1)                                   // dzAC dzBC dzAC
        fmul    t2                                      // ACt2 dzBC dzAC
        fld     ST(1)                                   // dzBC ACt2 dzBC dzAC
        fmul    t1                                      // BCt1 ACt2 dzBC dzAC
        fxch    ST(3)                                   // dzAC ACt2 dzBC BCt1
        fmul    t4                                      // ACt4 ACt2 dzBC BCt1
        fxch    ST(2)                                   // dzBC ACt2 ACt4 BCt1
        fmul    t3                                      // BCt3 ACt2 ACt4 BCt1
        fsubrp  ST(2),ST                                // ACt2 BCAC BCt1
        fsubrp  ST(2),ST                                // BCAC ACBC
        fxch    ST(1)                                   // ACBC BCAC
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][edx]   // dzdx BCAC (1 cycle hit!)
        fxch    ST(1)                                   // BCAC dzdx
        fmul    DWORD PTR [OFFSET(DEVRC.zScale)][edx]   // dzdy dzdx
        fxch    ST(1)                                   // dzdx dzdy
        fst     DWORD PTR [OFFSET(DEVRC.dzdx)][edx]     // (1 cycle hit!)
        fistp   temp
        mov     ebx, DWORD PTR temp
        fst     DWORD PTR [OFFSET(DEVRC.dzdy)][edx]
        mov     [OFFSET(DEVRC.fxdzdx)][edx], ebx
        fistp   temp
        mov     ebx, DWORD PTR temp
        mov     [OFFSET(DEVRC.fxdzdy)][edx], ebx
        
        }
#else

        dzAC = c->windowCoord.z - a->windowCoord.z;
        dzBC = c->windowCoord.z - b->windowCoord.z;
        pRc->dzdx = (dzAC * t2 - dzBC * t1) * pRc->zScale;
        pRc->dzdy = (dzBC * t3 - dzAC * t4) * pRc->zScale;

        pRc->fxdzdx = FTOL(pRc->dzdx);
        pRc->fxdzdy = FTOL(pRc->dzdy);

#endif
        
    }
}


VOID FASTCALL __HWSetupDeltas(DEVRC *pRc)
{
    BYTE *pjBase = pRc->ppdev->pjBase;

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 9);

        CP_WRITE(pjBase, DWG_DWGCTL, pRc->hwTrapFunc);

        CP_WRITE(pjBase, DWG_DR2, pRc->fxdzdx);
        CP_WRITE(pjBase, DWG_DR3, pRc->fxdzdy);

        CP_WRITE(pjBase, DWG_DR6, pRc->fxdrdx);
        CP_WRITE(pjBase, DWG_DR7, pRc->fxdrdy);

        CP_WRITE(pjBase, DWG_DR10, pRc->fxdgdx);
        CP_WRITE(pjBase, DWG_DR11, pRc->fxdgdy);

        CP_WRITE(pjBase, DWG_DR14, pRc->fxdbdx);
        CP_WRITE(pjBase, DWG_DR15, pRc->fxdbdy);

    } else {

        CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3);

        CP_WRITE(pjBase, DWG_DWGCTL, pRc->hwTrapFunc);
        CP_WRITE(pjBase, DWG_DR2, pRc->fxdzdx);
        CP_WRITE(pjBase, DWG_DR3, pRc->fxdzdy);
    }
}

#define SNAPCOORD(value, intValue)\
    intValue = __MCD_VERTEX_FIXED_TO_INT(__MCD_VERTEX_FLOAT_TO_FIXED(value)+\
                                         __MCD_VERTEX_FRAC_HALF);

void FASTCALL __HWDrawTrap(DEVRC *pRc, MCDFLOAT dxLeft, MCDFLOAT dxRight,
                           LONG y, LONG dy)
{
    BYTE *pjBase = pRc->ppdev->pjBase;
    ULONG signs = 0;

    if (*((ULONG *)&dxLeft) & 0x80000000) {
        signs |= sdxl_SUB;
    }

    if (*((ULONG *)&dxRight) & 0x80000000) {
        signs |= sdxr_DEC;
    }

    CHECK_FIFO_FREE(pjBase, pRc->cFifo, 3);
    CP_WRITE(pjBase, DWG_SGN, (scanleft_RIGHT | sdy_ADD | signs));
    CP_WRITE(pjBase, DWG_LEN, dy);
    CP_START(pjBase, DWG_YDST, y + pRc->yOffset);
}


VOID FASTCALL __HWAdjustLeftEdgeRGBZ(DEVRC *pRc, MCDVERTEX *p,
                                     MCDFLOAT fdxLeft, MCDFLOAT fdyLeft,
                                     MCDFLOAT xFrac, MCDFLOAT yFrac,
                                     MCDFLOAT xErr)
{
    BYTE *pjBase = pRc->ppdev->pjBase;
    LONG dxLeft, dyLeft, dyLeftErr;
    MCDCOLOR *pColor;

#if _X86_ && ASM_ACCEL
    _asm {
    fld     fdxLeft
    fmul    fixScale
    fld     fdyLeft
    fmul    fixScale       // leave these on the stack...
    }
#else
    dxLeft = FLT_TO_FIX(fdxLeft);
    dyLeft = FLT_TO_FIX(fdyLeft);
#endif

    CHECK_FIFO_FREE(pjBase, pRc->cFifo, 8);

    // Adjust the color and z values for the first pixel drawn on the left
    // edge to be on the pixel center.  This is especially important to
    // perform accurate z-buffering.

    // We will need to set up the hardware color interpolators:

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

#if _X86_ && ASM_ACCEL
        LONG rTemp, gTemp, bTemp;

        // Compute the following in assembly:
        // 
        // rTemp = (r * rScale) + (drdx * xFrac) + (drdy * yFrac);
        // gTemp = (g * gScale) + (dgdx * xFrac) + (dgdy * yFrac);
        // bTemp = (b * bScale) + (dbdx * xFrac) + (dbdy * yFrac);

        _asm{
        mov     eax, p
        mov     ebx, pRc
        fld     xFrac
        fmul    DWORD PTR [OFFSET(DEVRC.drdx)][ebx]
        lea     eax, [OFFSET(MCDVERTEX.colors) + eax]
        fld     yFrac
        fmul    DWORD PTR [OFFSET(DEVRC.drdy)][ebx]
        fld     DWORD PTR [OFFSET(MCDCOLOR.r)][eax]
        fmul    DWORD PTR [OFFSET(DEVRC.rScale)][ebx]
        fxch    ST(2)
        faddp   ST(1), ST           // R R

        fld     xFrac
        fmul    DWORD PTR [OFFSET(DEVRC.dgdx)][ebx]
        fld     yFrac
        fmul    DWORD PTR [OFFSET(DEVRC.dgdy)][ebx]
        fld     DWORD PTR [OFFSET(MCDCOLOR.g)][eax]
        fmul    DWORD PTR [OFFSET(DEVRC.gScale)][ebx]
        fxch    ST(2)	            // G G G R R
        faddp   ST(1), ST           // G G R R
        fxch    ST(2)               // R G G R
        faddp   ST(3), ST           // G G R

        fld     xFrac
        fmul    DWORD PTR [OFFSET(DEVRC.dbdx)][ebx]
        fld     yFrac
        fmul    DWORD PTR [OFFSET(DEVRC.dbdy)][ebx]
        fld     DWORD PTR [OFFSET(MCDCOLOR.b)][eax]
        fmul    DWORD PTR [OFFSET(DEVRC.bScale)][ebx]
        fxch    ST(2)
        faddp   ST(1), ST           // B B G G R
        fxch    ST(2)               // G B B G R
        faddp   ST(3), ST           // B B G R

        fxch    ST(2)               // G B B R
        fistp   gTemp               // B B R
        faddp   ST(1), ST           // B R
        fxch    ST(1)               // R B
        fistp   rTemp               // B
        fistp   bTemp               // not quite empty, still have dy, dx

        }

        CP_WRITE(pjBase, DWG_DR4,  rTemp + 0x0800);
        CP_WRITE(pjBase, DWG_DR8,  gTemp + 0x0800);
        CP_WRITE(pjBase, DWG_DR12, bTemp + 0x0800);
#else
        pColor = &p->colors[0];

        CP_WRITE(pjBase, DWG_DR4,
                 FTOL((pColor->r * pRc->rScale) + 
                      (pRc->drdx * xFrac) + (pRc->drdy * yFrac)) + 0x0800);
        CP_WRITE(pjBase, DWG_DR8,
                 FTOL((pColor->g * pRc->gScale) + 
                      (pRc->dgdx * xFrac) + (pRc->dgdy * yFrac)) + 0x0800);

        CP_WRITE(pjBase, DWG_DR12,
                 FTOL((pColor->b * pRc->bScale) + 
                      (pRc->dbdx * xFrac) + (pRc->dbdy * yFrac)) + 0x0800);
#endif

    }

    // Now, sub-pixel correct the z-buffer:

    if (pRc->privateEnables & __MCDENABLE_Z) {

#if _X86_ && ASM_ACCEL

        LARGE_INTEGER zTemp;

        if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_FILL_ENABLE) {
            MCDFLOAT zOffset;

            zOffset = __MCDGetZOffsetDelta(pRc) +
                      (pRc->MCDState.zOffsetUnits * pRc->zScale);

            // zTemp = (z * zScale) + (dzdx * xFrac) + (dzdy * yFrac) + zOffset;

            _asm{

            mov     eax, p
            mov     ebx, pRc
            fld     xFrac
            fmul    DWORD PTR [OFFSET(DEVRC.dzdx)][ebx]
            fld     yFrac
            fmul    DWORD PTR [OFFSET(DEVRC.dzdy)][ebx]
            fxch    ST(1)
            fadd    zOffset
            fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]
            fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]
            fxch    ST(2)
            faddp   ST(1), ST   // OUCH!!
            faddp   ST(1), ST
            fistp   zTemp       // OUCH!!!
            }            

           CP_WRITE(pjBase, DWG_DR0, zTemp.LowPart);

        } else {

            // zTemp = (z * zScale) + (dzdx * xFrac) + (dzdy * yFrac);

            _asm{

            mov     eax, p
            mov     ebx, pRc
            fld     xFrac
            fmul    DWORD PTR [OFFSET(DEVRC.dzdx)][ebx]
            fld     yFrac
            fmul    DWORD PTR [OFFSET(DEVRC.dzdy)][ebx]
            fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.z)][eax]
            fmul    DWORD PTR [OFFSET(DEVRC.zScale)][ebx]
            fxch    ST(2)
            faddp   ST(1), ST
            faddp   ST(1), ST   // OUCH!!!
            fistp   zTemp       // OUCH!!!
            }

           CP_WRITE(pjBase, DWG_DR0, zTemp.LowPart);
        }

#else
        if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_FILL_ENABLE) {
            MCDFLOAT zOffset;

            zOffset = __MCDGetZOffsetDelta(pRc) +
                      (pRc->MCDState.zOffsetUnits * pRc->zScale);

            CP_WRITE(pjBase, DWG_DR0,
                     FTOL((p->windowCoord.z * pRc->zScale) + zOffset +
                          (pRc->dzdx * xFrac) + (pRc->dzdy * yFrac)));
        } else {

            CP_WRITE(pjBase, DWG_DR0,
                     FTOL((p->windowCoord.z * pRc->zScale) +
                          (pRc->dzdx * xFrac) + (pRc->dzdy * yFrac)));
        }
#endif

    }

    // We've handled the color and z setup.  Now, take care of the actual
    // DDA.

#if _X86_ && ASM_ACCEL

    // convert dxLeft and dyLeft to integer:

    _asm{
    fistp   dyLeft
    fistp   dxLeft
    }
#endif

    if (dxLeft >= 0) {

        ULONG size = (dxLeft | dyLeft) >> 16;

        if (size <= 0xff) {
            dxLeft >>= (8 + 1);
            dyLeft >>= (8 + 1);
        } else if (size <= 0xfff) {
            dxLeft >>= (12 + 1);
            dyLeft >>= (12 + 1);
        } else {
            dxLeft >>= (16 + 1);
            dyLeft >>= (16 + 1);
        }

        dyLeftErr = FTOL(xErr * (MCDFLOAT)dyLeft);

        CP_WRITE(pjBase, DWG_AR1, -dxLeft + dyLeftErr);
        CP_WRITE(pjBase, DWG_AR2, -dxLeft);
    } else {

        ULONG size = (-dxLeft | dyLeft) >> 16;

        if (size <= 0xff) {
            dxLeft >>= (8 + 1);
            dyLeft >>= (8 + 1);
        } else if (size <= 0xfff) {
            dxLeft >>= (12 + 1);
            dyLeft >>= (12 + 1);
        } else {
            dxLeft >>= (16 + 1);
            dyLeft >>= (16 + 1);
        }

        dyLeftErr = FTOL(xErr * (MCDFLOAT)dyLeft);

        CP_WRITE(pjBase, DWG_AR1, dxLeft + dyLeft - 1 - dyLeftErr);
        CP_WRITE(pjBase, DWG_AR2, dxLeft);
    }

    if (!dyLeft)
        dyLeft++;

//MCDBG_PRINT("LeftEdge: dxLeft = %x, dyLeft = %x, dyLeftErr = %x", dxLeft, dyLeft, dyLeftErr);

    CP_WRITE(pjBase, DWG_AR0, dyLeft);
    CP_WRITE(pjBase, DWG_FXLEFT, pRc->ixLeft + pRc->xOffset);
}


VOID FASTCALL __HWAdjustRightEdge(DEVRC *pRc, MCDVERTEX *p,
                                  MCDFLOAT fdxRight, MCDFLOAT fdyRight, 
                                  MCDFLOAT xErr)
{
    PDEV *ppdev = pRc->ppdev;
    BYTE *pjBase = ppdev->pjBase;
    LONG dxRight, dyRight, dyRightErr;

#if _X86_ && ASM_ACCEL
    _asm {
    fld     fdxRight
    fmul    fixScale
    fld     fdyRight
    fmul    fixScale       // leave these on the stack...
    }
#else
    dxRight = FLT_TO_FIX(fdxRight);
    dyRight = FLT_TO_FIX(fdyRight);
#endif

    CHECK_FIFO_FREE(pjBase, pRc->cFifo, 4);

#if _X86_ && ASM_ACCEL
    _asm{
    fistp   dyRight
    fistp   dxRight
    }
#endif

    if (dxRight >= 0) {

        ULONG size = (dxRight | dyRight) >> 16;

        if (size <= 0xff) {
            dxRight >>= (8 + 1);
            dyRight >>= (8 + 1);
        } else if (size <= 0xfff) {
            dxRight >>= (12 + 1);
            dyRight >>= (12 + 1);
        } else {
            dxRight >>= (16 + 1);
            dyRight >>= (16 + 1);
        }

#if _X86_ && ASM_ACCEL
        _asm{
        fild    dyRight
        fmul    xErr
        }
#else
        dyRightErr = FTOL(xErr * (MCDFLOAT)dyRight);
#endif

        CP_WRITE(pjBase, DWG_AR5, -dxRight);

#if _X86_ && ASM_ACCEL
        _asm{
        fistp   dyRightErr
        }
#endif

        CP_WRITE(pjBase, DWG_AR4, -dxRight + dyRightErr);
    } else {

        ULONG size = (-dxRight | dyRight) >> 16;

        if (size <= 0xff) {
            dxRight >>= (8 + 1);
            dyRight >>= (8 + 1);
        } else if (size <= 0xfff) {
            dxRight >>= (12 + 1);
            dyRight >>= (12 + 1);
        } else {
            dxRight >>= (16 + 1);
            dyRight >>= (16 + 1);
        }

#if _X86_ && ASM_ACCEL
        _asm{
        fild    dyRight
        fmul    xErr
        }
#else
        dyRightErr = FTOL(xErr * (MCDFLOAT)dyRight);
#endif

        CP_WRITE(pjBase, DWG_AR5, dxRight);

#if _X86_ && ASM_ACCEL
        _asm{
        fistp   dyRightErr
        }
#endif

        CP_WRITE(pjBase, DWG_AR4, dxRight + dyRight - 1 - dyRightErr);
    }

    if (!dyRight)
        dyRight++;

    CP_WRITE(pjBase, DWG_AR6, dyRight);
    CP_WRITE(pjBase, DWG_FXRIGHT, pRc->ixRight + pRc->xOffset);
}



VOID FASTCALL __MCDFillTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c, BOOL bCCW)
{
    LONG aIY, bIY, cIY;
    MCDFLOAT dxdyAC, dxdyBC, dxdyAB;
    MCDFLOAT dx, dy, errX;
    MCDFLOAT xLeft, xRight;
    MCDFLOAT xLeftRound;

#if _X86_ && ASM_ACCEL
    if (pRc->privateEnables & (__MCDENABLE_SMOOTH | __MCDENABLE_Z)) {
        // Pre-compute one over polygon half-area

        __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, pRc->halfArea, &pRc->invHalfArea);
    }
#endif

    //
    // Snap each y coordinate to its pixel center
    //

    SNAPCOORD(a->windowCoord.y, aIY);
    SNAPCOORD(b->windowCoord.y, bIY);
    SNAPCOORD(c->windowCoord.y, cIY);

    //
    // Calculate delta values for unit changes in x or y
    //

    (*pRc->calcDeltas)(pRc, a, b, c);

    __MCD_FLOAT_BEGIN_DIVIDE(pRc->dxAC, pRc->dyAC, &dxdyAC);

    (*pRc->HWSetupDeltas)(pRc);

    //
    // Fill the two triangle halves.  Note that the edge parameters
    // don't need to be recomputed for counter-clockwise triangles,
    // making them slightly faster...
    //

    if (bCCW)
    {
        __MCD_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

        dy = (aIY + __MCDHALF) - a->windowCoord.y;
        xLeft = a->windowCoord.x + dy*dxdyAC;      
        SNAPCOORD(xLeft, pRc->ixLeft);
        xLeftRound = pRc->ixLeft + __MCDHALF;
        dx = xLeftRound - a->windowCoord.x;
        errX = xLeftRound - xLeft;

        (*pRc->adjustLeftEdge)(pRc, a, pRc->dxAC, pRc->dyAC, dx, dy, errX);
        
        if (aIY != bIY)
        {
            dxdyAB = pRc->dxAB / pRc->dyAB;

            xRight = a->windowCoord.x + dy*dxdyAB;
            SNAPCOORD(xRight, pRc->ixRight);
            errX = (pRc->ixRight + __MCDHALF) - xRight;
            (*pRc->adjustRightEdge)(pRc, a, pRc->dxAB, pRc->dyAB, errX);

            if (bIY != cIY) {
                __MCD_FLOAT_BEGIN_DIVIDE(pRc->dxBC, pRc->dyBC, &dxdyBC);
            }

            (*pRc->HWDrawTrap)(pRc, pRc->dxAC, pRc->dxAB, aIY, bIY - aIY);

        } else if (bIY != cIY) {
            __MCD_FLOAT_BEGIN_DIVIDE(pRc->dxBC, pRc->dyBC, &dxdyBC);
        }

        if (bIY != cIY) {

            __MCD_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);
                
            dy = (bIY + __MCDHALF) - b->windowCoord.y;
            xRight = b->windowCoord.x + dy*dxdyBC;
            SNAPCOORD(xRight, pRc->ixRight);
            errX = (pRc->ixRight + __MCDHALF) - xRight;
            (*pRc->adjustRightEdge)(pRc, b, pRc->dxBC, pRc->dyBC, errX);
            
            (*pRc->HWDrawTrap)(pRc, pRc->dxAC, pRc->dxBC, bIY, cIY - bIY);
        }

    } else {

        __MCD_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
            
        dy = (aIY + __MCDHALF) - a->windowCoord.y;
        xRight = a->windowCoord.x + dy*dxdyAC;
        SNAPCOORD(xRight, pRc->ixRight);
         errX = (pRc->ixRight + __MCDHALF) - xRight;
        (*pRc->adjustRightEdge)(pRc, a, pRc->dxAC, pRc->dyAC, errX);
        
        if (aIY != bIY)
        {
            dxdyAB = pRc->dxAB / pRc->dyAB;

            xLeft = a->windowCoord.x + dy*dxdyAB;
            SNAPCOORD(xLeft, pRc->ixLeft);
            xLeftRound = pRc->ixLeft + __MCDHALF;
            dx = xLeftRound - a->windowCoord.x;
            errX = xLeftRound - xLeft;

            (*pRc->adjustLeftEdge)(pRc, a, pRc->dxAB, pRc->dyAB, dx, dy, errX);

            if (bIY != cIY) {
                __MCD_FLOAT_BEGIN_DIVIDE(pRc->dxBC, pRc->dyBC, &dxdyBC);
            }
            
            (*pRc->HWDrawTrap)(pRc, pRc->dxAB, pRc->dxAC, aIY, bIY - aIY);

        } else if (bIY != cIY) {
            __MCD_FLOAT_BEGIN_DIVIDE(pRc->dxBC, pRc->dyBC, &dxdyBC);
        }

        if (bIY != cIY)
        {
            __MCD_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);
            
            dy = (bIY + __MCDHALF) - b->windowCoord.y;
            xLeft = b->windowCoord.x + dy*dxdyBC;
            SNAPCOORD(xLeft, pRc->ixLeft);
            xLeftRound = pRc->ixLeft + __MCDHALF;
            dx = xLeftRound - b->windowCoord.x;
            errX = xLeftRound - xLeft;

            (*pRc->adjustLeftEdge)(pRc, b, pRc->dxBC, pRc->dyBC, dx, dy, errX);

            (*pRc->HWDrawTrap)(pRc, pRc->dxBC, pRc->dxAC, bIY, cIY - bIY);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdprim.c ===
/******************************Module*Header*******************************\
* Module Name: mcdprim.c
*
* These routines process the OpenGL rendering commands that appear in an
* MCDrvDraw() batch.  Note that the only OpenGL primitive which is invalid
* is LineLoop.  This gets decomposed by the caller into a LineStrip command.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#include "mcdhw.h"
#include "mcdutil.h"

#define MEMCHECK_VERTEX(p)\
    if (((UCHAR *)p < pRc->pMemMin) ||\
        ((UCHAR *)p > pRc->pMemMax)) {\
        MCDBG_PRINT("Invalid MCD vertex pointer!");\
        return NULL;\
    }

////////////////////////////////////////////////////////////////////////
//
// The functions below are local rendering-helper functions which call
// the real rendering routines in the driver.
//
////////////////////////////////////////////////////////////////////////


VOID static FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *v)
{
    if (v->clipCode == 0)
	(*pRc->renderPoint)(pRc, v);
}

VOID static FASTCALL __MCDRenderLine(DEVRC *pRc, MCDVERTEX *v0,
                                     MCDVERTEX *v1, BOOL bResetLine)
{
    if (v0->clipCode | v1->clipCode)
    {
	/*
	 * The line must be clipped more carefully.  Cannot
	 * trivially accept the lines.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the line is outside of the same set of clipping
	 * planes (at least one).  Trivially reject the line.  
	 */
	if ((v0->clipCode & v1->clipCode) == 0)
	    (*pRc->clipLine)(pRc, v0, v1, bResetLine);
    }
    else
    {
	// Line is trivially accepted so render it
        (*pRc->renderLine)(pRc, v0, v1, bResetLine);
    }
}

VOID static FASTCALL __MCDRenderTriangle(DEVRC *pRc, MCDVERTEX *v0, 
                                         MCDVERTEX *v1, MCDVERTEX *v2)
{
    ULONG orCodes;

    /* Clip check */
    orCodes = v0->clipCode | v1->clipCode | v2->clipCode;
    if (orCodes)
    {
	/* Some kind of clipping is needed.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the triangle is outside of the same set of
	 * clipping planes (at least one).  Trivially reject
	 * the triangle.
	 */
	if (!(v0->clipCode & v1->clipCode & v2->clipCode))
	    (*pRc->clipTri)(pRc, v0, v1, v2, orCodes);
    }
    else
    {
	(*pRc->renderTri)(pRc, v0, v1, v2);
    }
}

VOID static FASTCALL __MCDRenderQuad(DEVRC *pRc, MCDVERTEX *v0, 
                                     MCDVERTEX *v1, MCDVERTEX *v2, MCDVERTEX *v3)
{
// Vertex ordering is important.  Line stippling uses it.

    ULONG savedTag;

    /* Render the quad as two triangles */
    savedTag = v2->flags & MCDVERTEX_EDGEFLAG;
    v2->flags &= ~MCDVERTEX_EDGEFLAG;
    (*pRc->renderTri)(pRc, v0, v1, v2);
    v2->flags |= savedTag;
    savedTag = v0->flags & MCDVERTEX_EDGEFLAG;
    v0->flags &= ~MCDVERTEX_EDGEFLAG;
    (*pRc->renderTri)(pRc, v2, v3, v0);
    v0->flags |= savedTag;
}

VOID static FASTCALL __MCDRenderClippedQuad(DEVRC *pRc, MCDVERTEX *v0, 
                                            MCDVERTEX *v1, MCDVERTEX *v2, MCDVERTEX *v3)
{
    ULONG orCodes;

    orCodes = v0->clipCode | v1->clipCode | v2->clipCode | v3->clipCode;

    if (orCodes)
    {
	/* Some kind of clipping is needed.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the quad is outside of the same set of
	 * clipping planes (at least one).  Trivially reject
	 * the quad.
	 */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode & v3->clipCode))
        {
            /* Clip the quad as a polygon */
            MCDVERTEX *iv[4];

            iv[0] = v0;
            iv[1] = v1;
            iv[2] = v2;
            iv[3] = v3;
            (pRc->doClippedPoly)(pRc, &iv[0], 4, orCodes);
        }
    }
    else
    {
	__MCDRenderQuad(pRc, v0, v1, v2, v3);
    }
}

////////////////////////////////////////////////////////////////////////
//
// The functions below handle the processing of all of the primitives
// which may appear in an MCDCOMMAND.  This includes all of the OpenGL
// primitives, with the exception of line loops which are handled as
// line strips.
//
////////////////////////////////////////////////////////////////////////


MCDCOMMAND * FASTCALL __MCDPrimDrawPoints(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, nIndices;
    MCDVERTEX *pv;
    VOID (FASTCALL *rp)(DEVRC *pRc, MCDVERTEX *v);

// Index mapping is always identity in Points.

//    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    if (pCmd->clipCodes)
	rp = __MCDRenderPoint;
    else
	rp = pRc->renderPoint;

    (*pRc->beginPointDrawing)(pRc);

    // Render the points:

    pv = pCmd->pStartVertex;
    MEMCHECK_VERTEX(pv);
    i = pCmd->numIndices;
    MEMCHECK_VERTEX(pv + (i - 1));

    for (; i > 0; i--, pv++)
	(*rp)(pRc, pv);

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLines(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast2;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1;
    VOID (FASTCALL *rl)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);

    iLast2 = pCmd->numIndices - 2;
    pv     = pCmd->pStartVertex;
    rl = pCmd->clipCodes ? __MCDRenderLine : pRc->renderLine;

    (*pRc->beginLineDrawing)(pRc);

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast2 + 1));
   
	for (i = 0; i <= iLast2; i += 2)
	{
	    /* setup for rendering this line */

            pRc->resetLineStipple = TRUE;

	    (*rl)(pRc, &pv[i], &pv[i+1], TRUE);
	}
    }
    else
    {
	for (i = 0; i <= iLast2; i += 2)
	{
            pv0 = &pv[pIndices[i]];
            pv1 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv0);
            MEMCHECK_VERTEX(pv1);

	    /* setup for rendering this line */

            pRc->resetLineStipple = TRUE;

	    (*rl)(pRc, pv0, pv1, TRUE);
	}
    }

    (*pRc->endLineDrawing)(pRc);

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLineLoop(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    // NOTE:
    // Line loops are always converted tp line strips at the OpenGL
    // API level.  This routine is currently not used.

    MCDBG_PRINT("MCDPrimLineLoop: Invalid MCD command!");

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLineStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1;
    MCDVERTEX *vOld;
    VOID (FASTCALL *rl)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);

    iLast = pCmd->numIndices - 1;
    pv    = pCmd->pStartVertex;
    rl = pCmd->clipCodes ? __MCDRenderLine : pRc->renderLine;
    if (iLast <= 0)
	return pCmd->pNextCmd;

    if (pCmd->flags & MCDCOMMAND_RESET_STIPPLE)
        pRc->resetLineStipple = TRUE;

    (*pRc->beginLineDrawing)(pRc);

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping
	// Add first line segment (NOTE: 0, 1)
       
        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + iLast);

	(*rl)(pRc, &pv[0], &pv[1], TRUE);

	// Add subsequent line segments (NOTE: i, i+1)
	for (i = 1; i < iLast; i++) {
	    (*rl)(pRc, &pv[i], &pv[i+1], FALSE);
        }
    }
    else
    {
	// Add first line segment (NOTE: 0, 1)

        pv0 = &pv[pIndices[0]];
        pv1 = &pv[pIndices[1]];
	(*rl)(pRc, pv0, pv1, TRUE);

	// Add subsequent line segments (NOTE: i, i+1)

	for (i = 1; i < iLast; i++) {
            pv0 = pv1;
            pv1 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv1);
	    (*rl)(pRc, pv0, pv1, FALSE);
        }
    }

    (*pRc->endLineDrawing)(pRc);

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangles(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast3;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast3 = pCmd->numIndices - 3;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;


    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast3 + 2));

	for (i = 0; i <= iLast3; i += 3)
	{
	    /* setup for rendering this triangle */

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, &pv[i], &pv[i+1], &pv[i+2]);
	}
    }
    else
    {
	for (i = 0; i <= iLast3; i += 3)
	{
	    /* setup for rendering this triangle */

            pv0 = &pv[pIndices[i  ]];
            pv1 = &pv[pIndices[i+1]];
            pv2 = &pv[pIndices[i+2]];

            MEMCHECK_VERTEX(pv0);
            MEMCHECK_VERTEX(pv1);
            MEMCHECK_VERTEX(pv2);

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, pv0, pv1, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast3;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast3 = pCmd->numIndices - 3;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;

    if (iLast3 < 0)
	return pCmd->pNextCmd;

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast3 + 2));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast3; i++)
	{
	    /* setup for rendering this triangle */

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, &pv[i], &pv[i+1], &pv[i+2]);

	    if (++i > iLast3)
		break;

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: i+1, i, i+2) */
	    (*rt)(pRc, &pv[i+1], &pv[i], &pv[i+2]);
	}
    }
    else
    {

	pv1 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv1);
        pv1->flags |= MCDVERTEX_EDGEFLAG;

	pv2 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv2);
        pv2->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast3; i++)
	{
	    /* setup for rendering this triangle */

            pRc->resetLineStipple = TRUE;

            pv0 = pv1;
            pv1 = pv2;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
	    pv2->flags |= MCDVERTEX_EDGEFLAG;

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, pv0, pv1, pv2);

	    if (++i > iLast3)
		break;

            pv0 = pv1;
            pv1 = pv2;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
	    pv2->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this triangle */

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i+1, i, i+2) */
	    (*rt)(pRc, pv1, pv0, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleFan(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast2;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast2 = pCmd->numIndices - 2;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;

    if (iLast2 <= 0)
	return pCmd->pNextCmd;

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast2 + 1));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 1; i <= iLast2; i++)
	{
	    /* setup for rendering this triangle */

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+1];
            pv[i+1].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: 0, i, i+1) */
	    (*rt)(pRc, &pv[0], &pv[i], &pv[i+1]);
	}
    }
    else
    {
	// Initialize first 2 vertices so we can start rendering the tfan
	// below.  The edge flags are not modified by our lower level routines.

        pv0 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv0);
	pv0->flags |= MCDVERTEX_EDGEFLAG;

        pv2 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv2);
	pv2->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 1; i <= iLast2; i++)
	{
            pv1 = pv2;

            pv2 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv2);
            pv2->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this triangle */
            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: 0, i, i+1) */
	    (*rt)(pRc, pv0, pv1, pv2);
	}
    }

    return pCmd->pNextCmd;    
}


MCDCOMMAND * FASTCALL __MCDPrimDrawQuads(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast4;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2, *pv3;
    VOID (FASTCALL *rq)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2,
                        MCDVERTEX *v3);

    iLast4 = pCmd->numIndices - 4;
    pv     = pCmd->pStartVertex;

    if (pCmd->clipCodes)
	rq = __MCDRenderClippedQuad;
    else
	rq = __MCDRenderQuad;

    if (!(pIndices = pCmd->pIndices))
    {

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast4 + 3));

	// Identity mapping
	for (i = 0; i <= iLast4; i += 4)
	{
            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+3];

	    /* Render the quad (NOTE: i, i+1, i+2, i+3) */
	    (*rq)(pRc, &pv[i], &pv[i+1], &pv[i+2], &pv[i+3]);
	}
    }
    else
    {
	for (i = 0; i <= iLast4; i += 4)
	{

            pv0 = &pv[pIndices[i  ]];
            pv1 = &pv[pIndices[i+1]];
            pv2 = &pv[pIndices[i+2]];
            pv3 = &pv[pIndices[i+3]];

            MEMCHECK_VERTEX(pv0);
            MEMCHECK_VERTEX(pv1);
            MEMCHECK_VERTEX(pv2);
            MEMCHECK_VERTEX(pv3);


            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv3;

	    /* Render the quad (NOTE: i, i+1, i+2, i+3) */
	    (*rq)(pRc, pv0, pv1, pv2, pv3);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawQuadStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    ULONG i, iLast4;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2, *pv3;
    VOID (FASTCALL *rq)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2,
	MCDVERTEX *v3);

    iLast4 = pCmd->numIndices - 4;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rq = __MCDRenderClippedQuad;
    else
	rq = __MCDRenderQuad;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast4 + 3));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast4; i += 2)
	{
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;
            pv[i+3].flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this quad */

            pRc->pvProvoking = &pv[i+3];
            pRc->resetLineStipple = TRUE;

	    /* Render the quad (NOTE: i, i+1, i+3, i+2) */
	    (*rq)(pRc, &pv[i], &pv[i+1], &pv[i+3], &pv[i+2]);
	}
    }
    else
    {
	// Initialize first 2 vertices so we can start rendering the quad
	// below.  The edge flags are not modified by our lower level routines.

        pv2 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv2);
        pv2->flags |= MCDVERTEX_EDGEFLAG;

        pv3 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv3);
        pv3->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast4; i += 2)
	{

            pv0 = pv2;
            pv1 = pv3;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
            pv2->flags |= MCDVERTEX_EDGEFLAG;

            pv3 = &pv[pIndices[i+3]];
            MEMCHECK_VERTEX(pv3);
            pv3->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this quad */

            pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv3;

	    /* Render the quad (NOTE: i, i+1, i+3, i+2) */

	    (*rq)(pRc, pv0, pv1, pv3, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawPolygon(DEVRC *pRc, MCDCOMMAND *pCmd)
{

//    ASSERTOPENGL(!pCmd->pIndices, "Index mapping must be identity\n");

    // Reset the line stipple if this is a new polygon:

    if (pCmd->flags & MCDCOMMAND_RESET_STIPPLE)
        pRc->resetLineStipple = TRUE;

    // Note that the provoking vertex is set in clipPolygon:

    MEMCHECK_VERTEX(pCmd->pStartVertex);
    MEMCHECK_VERTEX(pCmd->pStartVertex + (pCmd->numIndices-1));

    (*pRc->clipPoly)(pRc, pCmd->pStartVertex, pCmd->numIndices);

    return pCmd->pNextCmd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdutil.h ===
/******************************Module*Header*******************************\
* Module Name: mcdutil.h
*
* Include file which indirects all of the hardware-dependent functionality
* in the MCD driver code.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef _MCDUTIL_H
#define _MCDUTIL_H

// Function prorotypes:

VOID PickRenderingFuncs(DEVRC *pRc);



#if DBG
UCHAR *MCDDbgAlloc(UINT);
VOID MCDDbgFree(UCHAR *);

#define MCDAlloc   MCDDbgAlloc
#define MCDFree    MCDDbgFree

VOID MCDrvDebugPrint(char *, ...);

#define MCDBG_PRINT             MCDrvDebugPrint

#else

UCHAR *MCDAlloc(UINT);
VOID MCDFree(UCHAR *);
#define MCDBG_PRINT

#endif


#define INTERSECTRECT(RectInter, pRect, Rect)\
{\
    RectInter.left   = max(pRect->left, Rect.left);\
    RectInter.right  = min(pRect->right, Rect.right);\
    RectInter.top    = max(pRect->top, Rect.top);\
    RectInter.bottom = min(pRect->bottom, Rect.bottom);\
}

#define MCD_CHECK_RC(pRc)\
    if (pRc == NULL) {\
        MCDBG_PRINT("NULL device RC");\
        return FALSE;\
    }

#define MCD_CHECK_DEVWND(pMCDSurface, pDevWnd, resChangedRet)\
{\
    if (!pDevWnd) {\
        MCDBG_PRINT("MCD_CHECK_DEVWND: NULL DEVWND");\
        return FALSE;\
    }\
\
    if (pDevWnd->dispUnique != GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev)) {\
        MCDBG_PRINT("MCD_CHECK_DEVWND: resolution changed but not updated");\
        return resChangedRet;\
    }\
}

#define MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, resChangedRet)\
{\
    DEVWND *pDevWnd = (DEVWND *)pMCDSurface->pWnd->pvUser;\
\
    MCD_CHECK_DEVWND(pMCDSurface, pDevWnd, resChangedRet);\
\
    if (((pRc)->backBufEnabled) &&\
        (!pDevWnd->bValidBackBuffer)) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: back buffer invalid");\
        return FALSE;\
    }\
\
    if (((pRc)->zBufEnabled) &&\
        (!pDevWnd->bValidZBuffer)) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: z buffer invalid");\
        return FALSE;\
    }\
\
}

#define MCD_INIT_BUFFER_PARAMS(pMCDSurface, pMCDWnd, pDevWnd, pRc)\
{\
    pRc->hwYOrgBias = pMCDWnd->clipBoundsRect.top;\
\
    if ((pRc)->MCDState.drawBuffer == GL_FRONT) {\
        (pRc)->hwBufferYBias = 0;\
    } else if ((pRc)->MCDState.drawBuffer == GL_BACK) {\
        if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {\
            pRc->hwBufferYBias = pDevWnd->backBufferY;\
        } else {\
            pRc->hwBufferYBias = pDevWnd->backBufferY - \
                                  pMCDWnd->clipBoundsRect.top;\
        }\
    }\
}

__inline ULONG HW_GET_VCOUNT(BYTE *pjBase)
{
    CP_EIEIO();
    return(CP_READ_REGISTER((pjBase) + HST_VCOUNT));
}

__inline void HW_WAIT_DRAWING_DONE(DEVRC *pRc)
{
    BYTE *pjBase = pRc->ppdev->pjBase;
    ULONG *pScreen;
    volatile ULONG read;

    while ((GET_FIFO_SPACE(pjBase) < FIFOSIZE) || IS_BUSY(pjBase))
        ;

    pScreen = (ULONG *)pRc->ppdev->pjScreen;

    read = *pScreen;
    read |= *(pScreen+32);
}

__inline void HW_INIT_DRAWING_STATE(MCDSURFACE *pMCDSurface, MCDWINDOW *pMCDWnd,
                                    DEVRC *pRc)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;
    ULONG ulAccess;
    LONG yOrg;

    CHECK_FIFO_SPACE(pjBase, 4);

    ulAccess = ppdev->ulAccess;

    if (!(pRc->MCDState.enables & MCD_DITHER_ENABLE))
        ulAccess |= dither_DISABLE;

    pRc->ulAccess = ulAccess;

    CP_WRITE(pjBase, DWG_MACCESS, ulAccess);

    // Stash the upper-left y away in the context:

    pRc->hwYOrgBias = pMCDWnd->clipBoundsRect.top;

    // Note:  zBufferOffset is maintained in MCDrvTrackWindow

    if (pRc->MCDState.drawBuffer == GL_FRONT) {

        if (pDevWnd->pohZBuffer) {
            LONG zDiff;

            if (ppdev->pohZBuffer == pDevWnd->pohZBuffer)
                zDiff = pDevWnd->zBufferOffset;
            else
                zDiff = pDevWnd->zBufferOffset -
                        (pMCDWnd->clipBoundsRect.top * pDevWnd->zPitch);

            if (zDiff < 0)
                zDiff = 0x800000 + zDiff;

            ASSERTDD((zDiff & 0x1ff) == 0,
                 "Front and Z buffers are not a multiple of 512 apart.");

            CP_WRITE(pjBase, DWG_ZORG, zDiff);
        }

        pRc->hwBufferYBias = 0;
        yOrg = pMCDWnd->clipBoundsRect.top;
    } else if (pRc->MCDState.drawBuffer == GL_BACK) {

        if (pDevWnd->pohZBuffer) {
            LONG zDiff;

            zDiff = pDevWnd->zBufferOffset -
                    (pDevWnd->backBufferY * pDevWnd->zPitch);

            ASSERTDD((zDiff & 0x1ff) == 0,
                 "Back and Z buffers are not a multiple of 512 apart.");

            if (zDiff < 0)
                zDiff = 0x800000 + zDiff;

            CP_WRITE(pjBase, DWG_ZORG, zDiff);
        }

        if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {
            yOrg = pMCDWnd->clipBoundsRect.top + pDevWnd->backBufferY;
            pRc->hwBufferYBias = pDevWnd->backBufferY;
        } else {
            yOrg = pDevWnd->backBufferY;
            pRc->hwBufferYBias = pDevWnd->backBufferY -
                                 pMCDWnd->clipBoundsRect.top;
        }

    }

    // We have to adjust the stipple pattern on each batch since the window
    // may have moved, and the HW stipple pattern is screen-relative whereas
    // OpenGL's is window-relative.  We can't do the update in the tracking
    // function since we don't have an RC.  Note that we only deal with simple
    // (101010) checkerboard stipples which are the most common.

    if (pRc->hwStipple) {
        LONG ofsAdj = (pMCDSurface->pWnd->clientRect.bottom & 0x1) ^
                      (pMCDSurface->pWnd->clientRect.left & 0x1);

        pRc->hwTrapFunc &= ~((ULONG)trans_15);

        if (ofsAdj)
            pRc->hwTrapFunc |= (pRc->hwStipple ^ (trans_1 | trans_2));
        else
            pRc->hwTrapFunc |= pRc->hwStipple;
    }

    CP_WRITE(pjBase, DWG_YDSTORG, (yOrg * ppdev->cxMemory) + ppdev->ulYDstOrg);
    CP_WRITE(pjBase, DWG_PLNWT, pRc->hwPlaneMask);
}


__inline void HW_INIT_PRIMITIVE_STATE(MCDSURFACE *pMCDSurface, DEVRC *pRc)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;

    if (!(pRc->privateEnables & __MCDENABLE_SMOOTH)) {

        // We will be using the interpolation mode of the hardware, but we'll
        // only be interpolation Z, so set the color deltas to 0.

        CHECK_FIFO_SPACE(pjBase, 6);

        CP_WRITE(pjBase, DWG_DR6, 0);
        CP_WRITE(pjBase, DWG_DR7, 0);

        CP_WRITE(pjBase, DWG_DR10, 0);
        CP_WRITE(pjBase, DWG_DR11, 0);

        CP_WRITE(pjBase, DWG_DR14, 0);
        CP_WRITE(pjBase, DWG_DR15, 0);
    }

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    pRc->cFifo = 32;
}


__inline void HW_DEFAULT_STATE(MCDSURFACE *pMCDSurface)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;

    CHECK_FIFO_SPACE(pjBase, 7);

    // restore default clipping, sign register, plane mask, pitch

    CP_WRITE(pjBase, DWG_MACCESS, ppdev->ulAccess);
    CP_WRITE(pjBase, DWG_SGN, 0);
    CP_WRITE(pjBase, DWG_PITCH, ppdev->cxMemory | ylin_LINEARIZE);
    CP_WRITE(pjBase, DWG_PLNWT, ppdev->ulPlnWt);
    CP_WRITE(pjBase, DWG_YDSTORG, ppdev->ulYDstOrg);

    vResetClipping(ppdev);

    ppdev->HopeFlags = 0;       // brute-force this
}

__inline void HW_GET_PLANE_MASK(DEVRC *pRc)
{
    if (pRc->MCDState.colorWritemask[0] &&
        pRc->MCDState.colorWritemask[1] &&
        pRc->MCDState.colorWritemask[2] &&
        pRc->MCDState.colorWritemask[3])
        pRc->hwPlaneMask = ~((ULONG)0);
    else {
        ULONG mask = 0;

        if (pRc->MCDState.colorWritemask[0])
            mask |= ((1 << pRc->pixelFormat.rBits) - 1) <<
                    pRc->pixelFormat.rShift;

        if (pRc->MCDState.colorWritemask[1])
            mask |= ((1 << pRc->pixelFormat.gBits) - 1) <<
                    pRc->pixelFormat.gShift;

        if (pRc->MCDState.colorWritemask[2])
            mask |= ((1 << pRc->pixelFormat.bBits) - 1) <<
                    pRc->pixelFormat.bShift;

        switch (pRc->pixelFormat.cColorBits) {
            case 8:
                pRc->hwPlaneMask = mask | (mask << 8) | (mask << 16) | (mask << 24);
                break;
            case 15:
            case 16:
                pRc->hwPlaneMask = mask | (mask << 16);
                break;
            default:
                pRc->hwPlaneMask = mask;
                break;
        }
    }
}

__inline void HW_START_FILL_RECT(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                                 DEVRC *pRc, ULONG buffers)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;
    DEVWND *pDevWnd = (DEVWND *)pMCDSurface->pWnd->pvUser;
    ULONG hwOp;
    BOOL bFillC = (buffers & GL_COLOR_BUFFER_BIT) != 0;
    BOOL bFillZ = (buffers & GL_DEPTH_BUFFER_BIT) &&
                  pRc->MCDState.depthWritemask;
    RGBACOLOR color;
    ULONG zFillValue;
    ULONG sumColor;

//MCDBG_PRINT("HW_START_FILL_RECT: bFillC = %d, bFillZ = %d", bFillC, bFillZ);

    // This is a little slimy, but we don't know whether or not the plane
    // mask has changed since the last drawing batch:

    if (pRc->pickNeeded)
        HW_GET_PLANE_MASK(pRc);

    if (!bFillZ && (pRc->MCDState.colorClearValue.r == (MCDFLOAT)0.0) &&
                   (pRc->MCDState.colorClearValue.g == (MCDFLOAT)0.0) &&
                   (pRc->MCDState.colorClearValue.b == (MCDFLOAT)0.0)) {
        CHECK_FIFO_SPACE(pjBase, 3);

        CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP | atype_RPL | bop_SRCCOPY |
                 zdrwen_NO_DEPTH | blockm_ON | solid_SOLID | arzero_ZERO |
                 sgnzero_ZERO);
        CP_WRITE(pjBase, DWG_FCOL, 0);
        CP_WRITE(pjBase, DWG_PLNWT, pRc->hwPlaneMask);
    } else {

        CHECK_FIFO_SPACE(pjBase, 16);

        MCDFIXEDRGB(color, pRc->MCDState.colorClearValue);

        // This logic is needed to pass conformance, since dithering
        // with pure white will cause problems on the Millenium.

        sumColor = (color.r | color.g | color.b) & ~(0x7fff);

        if ((sumColor == 0x7f8000) || (sumColor == 0)) {
            CP_WRITE(pjBase, DWG_MACCESS, pRc->ulAccess | dither_DISABLE);
        }

//MCDBG_PRINT("fixcolor = %x, %x, %x, %x", color.r, color.g, color.b, color.a);
//color.b = 0x3f0000;
//!!MCDBG_PRINT("realcolor = %f, %f, %f, %f", pRc->MCDState.colorClearValue.r,
//!!                                          pRc->MCDState.colorClearValue.g,
//!!                                          pRc->MCDState.colorClearValue.b,
//!!                                          pRc->MCDState.colorClearValue.a);

        // NOTE: For Storm, assuming it's fixed so that the z-buffer isn't
        //       always written, regardless of the 'zdrwen' bit, we will
        //       have to clear the z-buffer using a 2-d blt (don't forget
        //       to reset clipping!).  But with the Athena, we get this
        //       functionality by default.

        zFillValue = (ULONG)(pRc->MCDState.depthClearValue);

//MCDBG_PRINT("zFillValue = %x", zFillValue);

        if (bFillZ) {
//MCDBG_PRINT("Fill Rect with Color+Z");
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP | atype_ZI | bop_SRCCOPY |
                     solid_SOLID | arzero_ZERO | sgnzero_ZERO);
            CP_WRITE(pjBase, DWG_DR0, zFillValue << 15);
        } else {
//MCDBG_PRINT("Fill Rect with Color");
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP | atype_I | bop_SRCCOPY |
                     solid_SOLID | arzero_ZERO | sgnzero_ZERO);
        }

        // If we're filling the z-buffer only, zero the plane mask:

        if (bFillZ && !bFillC)
            CP_WRITE(pjBase, DWG_PLNWT, 0);
        else
            CP_WRITE(pjBase, DWG_PLNWT, pRc->hwPlaneMask);

        CP_WRITE(pjBase, DWG_DR4,  color.r);
        CP_WRITE(pjBase, DWG_DR8,  color.g);
        CP_WRITE(pjBase, DWG_DR12, color.b);

        // Set all deltas to 0

        CP_WRITE(pjBase, DWG_DR2, 0);
        CP_WRITE(pjBase, DWG_DR3, 0);

        CP_WRITE(pjBase, DWG_DR6, 0);
        CP_WRITE(pjBase, DWG_DR7, 0);

        CP_WRITE(pjBase, DWG_DR10, 0);
        CP_WRITE(pjBase, DWG_DR11, 0);

        CP_WRITE(pjBase, DWG_DR14, 0);
        CP_WRITE(pjBase, DWG_DR15, 0);
    }

    CHECK_FIFO_SPACE(pjBase, 4);

    CP_WRITE(pjBase, DWG_CYTOP,
                  ((pMCDSurface->pWnd->clipBoundsRect.top + pRc->hwBufferYBias) * ppdev->cxMemory) +
                  ppdev->ulYDstOrg);
    CP_WRITE(pjBase, DWG_CXLEFT, pMCDSurface->pWnd->clipBoundsRect.left);
    CP_WRITE(pjBase, DWG_CXRIGHT, pMCDSurface->pWnd->clipBoundsRect.right - 1);
    CP_WRITE(pjBase, DWG_CYBOT,
             ((pMCDSurface->pWnd->clipBoundsRect.bottom + pRc->hwBufferYBias - 1) * ppdev->cxMemory) +
             ppdev->ulYDstOrg);

}

__inline void HW_FILL_RECT(MCDSURFACE *pMCDSurface, DEVRC *pRc, RECTL *pRecl)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;

//MCDBG_PRINT("fill rect = %d, %d, %d, %d", pRecl->left,
//                                          pRecl->top,
//                                          pRecl->right,
//                                          pRecl->bottom);

    CHECK_FIFO_SPACE(pjBase, 5);
    CP_WRITE(pjBase, DWG_YDST, pRecl->top - pRc->hwYOrgBias);
    CP_WRITE(pjBase, DWG_YDST, pRecl->top - pRc->hwYOrgBias);
    CP_WRITE(pjBase, DWG_FXLEFT, pRecl->left);
    CP_WRITE(pjBase, DWG_LEN, pRecl->bottom - pRecl->top);
    CP_START(pjBase, DWG_FXRIGHT, pRecl->right);
}

__inline void HW_START_SWAP_BUFFERS(MCDSURFACE *pMCDSurface,
                                    LONG *hwBufferYBias,
                                    ULONG flags)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    BYTE *pjBase = ppdev->pjBase;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);

    CHECK_FIFO_SPACE(pjBase, 4);
    CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT + atype_RPL + blockm_OFF +
                                 bltmod_BFCOL + pattern_OFF + transc_BG_OPAQUE +
                                 bop_SRCCOPY);
    CP_WRITE(pjBase, DWG_SHIFT, 0);
    CP_WRITE(pjBase, DWG_SGN, 0);
    CP_WRITE(pjBase, DWG_AR5, ppdev->cxMemory);

    if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {
        *hwBufferYBias = pDevWnd->backBufferY;
    } else {
        *hwBufferYBias = pDevWnd->backBufferY -
                         pMCDSurface->pWnd->clipBoundsRect.top;
    }
}

void SETUPTRIANGLEDRAWING(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc);
void DrawTriangle(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                  MCDVERTEX *pMCDVertex);

// External declarations

void FASTCALL __HWDrawTrap(DEVRC *pRc, MCDFLOAT dxLeft, MCDFLOAT dxRight,
                           LONG y, LONG dy);
VOID FASTCALL __HWSetupDeltas(DEVRC *pRc);
BOOL HWAllocResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL zEnabled,
                      BOOL backBufferEnabled);
VOID HWUpdateBufferPos(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL bForce);
VOID HWFreeResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso);
VOID vMilCopyBlt3D(PDEV* ppdev, POINTL* pptlSrc, RECTL* prclDst);


#endif /* _MCDUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vResetClipping
*
\**************************************************************************/

VOID vResetClipping(
PDEV*   ppdev)
{
    BYTE*   pjBase;
    ULONG   ulYDstOrg;

    pjBase    = ppdev->pjBase;
    ulYDstOrg = ppdev->ulYDstOrg;   // MGA's linear offset

    CHECK_FIFO_SPACE(pjBase, 4);

    CP_WRITE(pjBase, DWG_CXLEFT,  0);
    CP_WRITE(pjBase, DWG_CXRIGHT, ppdev->cxMemory - 1);
    CP_WRITE(pjBase, DWG_CYTOP,   ulYDstOrg);
    CP_WRITE(pjBase, DWG_CYBOT,
        (ppdev->cyMemory - 1) * ppdev->cxMemory + ulYDstOrg);
}

/******************************Public*Routine******************************\
* VOID vSetClipping
*
\**************************************************************************/

VOID vSetClipping(
PDEV*   ppdev,
RECTL*  prclClip)           // In relative coordinates
{
    BYTE*   pjBase;
    ULONG   ulYDstOrg;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cxMemory;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;

    CHECK_FIFO_SPACE(pjBase, 4);

    CP_WRITE(pjBase, DWG_CXLEFT,  xOffset + prclClip->left);
    CP_WRITE(pjBase, DWG_CXRIGHT, xOffset + prclClip->right - 1);

    ulYDstOrg = ppdev->ulYDstOrg;   // MGA's linear offset
    yOffset   = ppdev->yOffset;
    cxMemory  = ppdev->cxMemory;

    CP_WRITE(pjBase, DWG_CYTOP,
        (yOffset + prclClip->top) * cxMemory + ulYDstOrg);
    CP_WRITE(pjBase, DWG_CYBOT,
        (yOffset + prclClip->bottom - 1) * cxMemory + ulYDstOrg);
}

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;
    LONG  i;
    BYTE* pjBase;

    pjBase= ppdev->pjBase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (LONG)((0 - ((bDstIsScreen) ? (ULONG_PTR) pjDst
                                               : (ULONG_PTR) pjSrc)) & 3);
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    ///////////////////////////////////////////////////////////////////
    // Portable bus-aligned copy
    //
    // 'memcpy' usually aligns to the destination, so we could call
    // it for that case, but unfortunately we can't be sure.  We
    // always want to align to the frame buffer:

    if (bDstIsScreen)
    {
        START_DIRECT_ACCESS_STORM(ppdev, pjBase);

        // Align to the destination (implying that the source may be
        // unaligned):

        for (; cyScan > 0; cyScan--)
        {
            for (i = cjStartPhase; i > 0; i--)
            {
                *pjDst++ = *pjSrc++;
            }

            for (i = culMiddle; i > 0; i--)
            {
                *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
            }

            for (i = cjEndPhase; i > 0; i--)
            {
                *pjDst++ = *pjSrc++;
            }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
        }
    }
    else
    {
        START_DIRECT_ACCESS_STORM_FOR_READ(ppdev, pjBase);

        // Align to the source (implying that the destination may be
        // unaligned):

        for (; cyScan > 0; cyScan--)
        {
            for (i = cjStartPhase; i > 0; i--)
            {
                *pjDst++ = *pjSrc++;
            }

            for (i = culMiddle; i > 0; i--)
            {
                *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));

                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
            }

            for (i = cjEndPhase; i > 0; i--)
            {
                *pjDst++ = *pjSrc++;
            }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
        }
    }

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);

    *ppjSrc = pjSrc;            // Save the updated pointers
    *ppjDst = pjDst;

}

/******************************Public*Routine******************************\
* VOID vMilGetBitsLinear
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vMilGetBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    cjRemainder;

    DISPDBG((5, "vGetBitsLinear -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vGetBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + (ppdev->cjPelSize * (rclDraw.left + ppdev->ulYDstOrg));

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + (ppdev->cjPelSize * prclDst->left);

    cjScan = ppdev->cjPelSize * (rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 FALSE);            // Screen is the source
    DISPDBG((5, "vGetBitsLinear -- exit"));
}

/******************************Public*Routine******************************\
* VOID vMilPutBitsLinear
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vMilPutBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    cjRemainder;

    DISPDBG((5, "vPutBitsLinear -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vPutBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + (ppdev->cjPelSize * (rclDraw.left + ppdev->ulYDstOrg));

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + (pptlSrc->y  * lSrcDelta)
                                        + (ppdev->cjPelSize * pptlSrc->x);

    cjScan = ppdev->cjPelSize * (rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 TRUE);            // Screen is the dest
    DISPDBG((5, "vPutBitsLinear -- exit"));
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    if (ppdev->ulBoardId == MGA_STORM)
    {
        vMilGetBitsLinear(ppdev, psoDst, prclDst, pptlSrc);
    }
    else if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        vMgaGetBits8bpp(ppdev, psoDst, prclDst, pptlSrc);
    }
    else if (ppdev->iBitmapFormat == BMF_16BPP)
    {
        vMgaGetBits16bpp(ppdev, psoDst, prclDst, pptlSrc);
    }
    else
    {
        vMgaGetBits24bpp(ppdev, psoDst, prclDst, pptlSrc);
    }
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    LONG xOffset;
    LONG yOffset;

    if (ppdev->ulBoardId == MGA_STORM)
    {
        vMilPutBitsLinear(ppdev, psoSrc, prclDst, pptlSrc);
    }
    else
    {
        // 'vXferNative' takes relative coordinates, but we have absolute
        // coordinates here.  Temporarily adjust our offset variables:

        xOffset = ppdev->xOffset;
        yOffset = ppdev->yOffset;

        ppdev->xOffset = 0;
        ppdev->yOffset = 0;

        vXferNative(ppdev, 1, prclDst, 0xCCCC, psoSrc, pptlSrc, prclDst, NULL);

        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\mcdutil.c ===
/******************************Module*Header*******************************\
* Module Name: mcdutil.c
*
* Contains various utility routines for the Millenium MCD driver such as
* rendering-procedure picking functionality and buffer management.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"
#include "stdio.h"

static ULONG xlatRop[16] = {bop_BLACKNESS,    // GL_CLEAR         0
                            bop_MASKPEN,      // GL_AND           S & D
                            bop_MASKPENNOT,   // GL_AND_REVERSE   S & ~D
                            bop_SRCCOPY,      // GL_COPY          S
                            bop_MASKNOTPEN,   // GL_AND_INVERTED  ~S & D
                            bop_NOP,          // GL_NOOP          D
                            bop_XORPEN,       // GL_XOR           S ^ D
                            bop_MERGEPEN,     // GL_OR            S | D
                            bop_NOTMERGEPEN,  // GL_NOR           ~(S | D)
                            bop_NOTXORPEN,    // GL_EQUIV         ~(S ^ D)
                            bop_NOT,          // GL_INVERT        ~D
                            bop_MERGEPENNOT,  // GL_OR_REVERSE    S | ~D
                            bop_NOTCOPYPEN,   // GL_COPY_INVERTED ~S
                            bop_MERGENOTPEN,  // GL_OR_INVERTED   ~S | D
                            bop_NOTMASKPEN,   // GL_NAND          ~(S & D)
                            bop_WHITENESS,    // GL_SET           1
                        };   

// Function prototypes:

VOID FASTCALL HWSetupClipping(DEVRC *pRc, RECTL *pClip);

#define MCD_ALLOC_TAG   'dDCM'

#if DBG

//#define DEVDBG

ULONG MCDrvAllocMemSize = 0;

UCHAR *MCDDbgAlloc(UINT size)
{
    UCHAR *pRet;

    if (pRet = (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size + sizeof(ULONG),
                                    MCD_ALLOC_TAG)) {
        MCDrvAllocMemSize += size;
        *((ULONG *)pRet) = size;
        return (pRet + sizeof(ULONG));
    } else
        return (UCHAR *)NULL;
}

VOID MCDDbgFree(UCHAR *pMem)
{
    if (!pMem) {
        MCDBG_PRINT("MCDFree: Attempt to free NULL pointer.");
        return;
    }

    pMem -= sizeof(ULONG);

    MCDrvAllocMemSize -= *((ULONG *)pMem);

#ifdef DEVDBG
    MCDBG_PRINT("MCDFree: %x bytes in use.", MCDrvAllocMemSize);
#endif

    EngFreeMem((VOID *)pMem);
}

VOID MCDrvDebugPrint(char *pMessage, ...)
{
    va_list ap;
    va_start(ap, pMessage);

    EngDebugPrint("[MCD DRIVER] ", pMessage, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}

#else


UCHAR *MCDAlloc(UINT size)
{
    return (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size, MCD_ALLOC_TAG);
}


VOID MCDFree(UCHAR *pMem)
{
    EngFreeMem((VOID *)pMem);
}


#endif /* DBG */

VOID FASTCALL NullRenderPoint(DEVRC *pRc, MCDVERTEX *pv)
{
}

VOID FASTCALL NullRenderLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bReset)
{
}

VOID FASTCALL NullRenderTri(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3)
{
}

MCDCOMMAND * FASTCALL FailPrimDraw(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    HW_WAIT_DRAWING_DONE(pRc);
    return pCmd;
}

BOOL PickPointFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    pRc->drawPoint = NULL;   // assume failure

    if (enables & (MCD_POINT_SMOOTH_ENABLE))
        return FALSE;

    if ((enables & MCD_FOG_ENABLE) && (!pRc->bCheapFog))
        return FALSE;

    if (pRc->MCDState.pointSize != __MCDONE)
        return FALSE;

// First, get high-level rendering functions:

    if (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK) {
        pRc->renderPoint = __MCDRenderPoint;
    } else {
        pRc->renderPoint = __MCDRenderGenPoint;
    }

    if ((pRc->bCheapFog) && (pRc->MCDState.shadeModel != GL_SMOOTH)) {
        pRc->renderPointX = pRc->renderPoint;
        pRc->renderPoint = __MCDRenderFogPoint;
    }

// Handle any lower-level rendering if needed:

    pRc->drawPoint = pRc->renderPoint;

    return TRUE;
}

BOOL PickLineFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    pRc->drawLine = NULL;   // assume failure

    if (enables & (MCD_LINE_SMOOTH_ENABLE | 
                   MCD_LINE_STIPPLE_ENABLE))
        return FALSE;

    if ((enables & MCD_FOG_ENABLE) && (!pRc->bCheapFog))
        return FALSE;

    if (pRc->MCDState.lineWidth != __MCDONE)
        return FALSE;

// First, get high-level rendering functions:

    if (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK) {
        if (pRc->MCDState.shadeModel == GL_SMOOTH)
            pRc->renderLine = __MCDRenderSmoothLine;
        else
            pRc->renderLine = __MCDRenderFlatLine;
    } else {
        pRc->renderLine = __MCDRenderGenLine;
    }

    if ((pRc->bCheapFog) && (pRc->MCDState.shadeModel != GL_SMOOTH)) {
        pRc->renderLineX = __MCDRenderSmoothLine;
        pRc->renderLine = __MCDRenderFlatFogLine;
    }

// Handle any lower-level rendering if needed:

    pRc->drawLine = pRc->renderLine;

    return TRUE;
}

BOOL PickTriangleFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    if (enables & MCD_POLYGON_STIPPLE_ENABLE) {
        ULONG *pStipple = (ULONG *)pRc->MCDState.polygonStipple;
        LONG i;

        for (pRc->hwStipple = trans_2, i = 0; i < 16; i += 2) {
            if ((pStipple[i]   != 0xaaaaaaaa) ||
                (pStipple[i+1] != 0x55555555)) {
                pRc->hwStipple = 0;
                break;
            }
        }

        if (!pRc->hwStipple) {
            for (pRc->hwStipple = trans_1, i = 0; i < 16; i += 2) {
                if ((pStipple[i]   != 0x55555555) ||
                    (pStipple[i+1] != 0xaaaaaaaa)) {
                    pRc->hwStipple = 0;
                    break;
                }
            }
        }
        
        if (!pRc->hwStipple)
            return FALSE;
    } else
        pRc->hwStipple = 0;

    if (enables & (MCD_POLYGON_SMOOTH_ENABLE | 
                   MCD_COLOR_LOGIC_OP_ENABLE))
        return FALSE;

    if ((enables & MCD_FOG_ENABLE) && (!pRc->bCheapFog))
        return FALSE;

// First, get high-level rendering functions.  If we're not GL_FILL'ing
// both sides of our polygons, use the "generic" function.

    if (((pRc->MCDState.polygonModeFront == GL_FILL) &&
         (pRc->MCDState.polygonModeBack == GL_FILL)) &&
        (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK)
        ) {
        if ((pRc->MCDState.shadeModel == GL_SMOOTH) ||
            (pRc->bCheapFog))
            pRc->renderTri = __MCDRenderSmoothTriangle;
        else
            pRc->renderTri = __MCDRenderFlatTriangle;
    } else {
        pRc->renderTri = __MCDRenderGenTriangle;

        // In this case, we must handle the various fill modes.  We must
        // fail triangle drawing if we can't handle the types of primitives
        // that may have to be drawn.  This logic depends on the line and
        // point pick routines 

        if (((pRc->MCDState.polygonModeFront == GL_POINT) && (!pRc->drawPoint)) ||
            ((pRc->MCDState.polygonModeFront == GL_LINE) && (!pRc->drawLine)))
            return FALSE;
        if (pRc->privateEnables & __MCDENABLE_TWOSIDED) {
            if (((pRc->MCDState.polygonModeBack == GL_POINT) && (!pRc->drawPoint)) ||
                ((pRc->MCDState.polygonModeBack == GL_LINE) && (!pRc->drawLine)))
                return FALSE;
        }
    }

    if ((pRc->bCheapFog) && (pRc->MCDState.shadeModel != GL_SMOOTH)) {
        pRc->renderTriX = pRc->renderTri;
        pRc->renderTri = __MCDRenderFlatFogTriangle;
    }

// Handle lower-level triangle rendering:

    pRc->drawTri = __MCDFillTriangle;

    pRc->HWDrawTrap = __HWDrawTrap;
    pRc->HWSetupDeltas = __HWSetupDeltas;
    pRc->calcDeltas = __MCDCalcDeltaRGBZ;
    pRc->adjustLeftEdge = __HWAdjustLeftEdgeRGBZ;
    pRc->adjustRightEdge = __HWAdjustRightEdge;

    return TRUE;
}

VOID __MCDPickRenderingFuncs(DEVRC *pRc, DEVWND *pDevWnd)
{
    BOOL bSupportedZFunc = TRUE;
        
    pRc->primFunc[GL_POINTS] = __MCDPrimDrawPoints;
    pRc->primFunc[GL_LINES] = __MCDPrimDrawLines;
    pRc->primFunc[GL_LINE_LOOP] = __MCDPrimDrawLineLoop;
    pRc->primFunc[GL_LINE_STRIP] = __MCDPrimDrawLineStrip;
    pRc->primFunc[GL_TRIANGLES] = __MCDPrimDrawTriangles;
    pRc->primFunc[GL_TRIANGLE_STRIP] = __MCDPrimDrawTriangleStrip;
    pRc->primFunc[GL_TRIANGLE_FAN] = __MCDPrimDrawTriangleFan;
    pRc->primFunc[GL_QUADS] = __MCDPrimDrawQuads;
    pRc->primFunc[GL_QUAD_STRIP] = __MCDPrimDrawQuadStrip;
    pRc->primFunc[GL_POLYGON] = __MCDPrimDrawPolygon;

    // Set up the privateEnables flags:

    switch (pRc->MCDState.depthTestFunc) {
        default:
        case GL_NEVER:
            bSupportedZFunc = FALSE;
            break;
        case GL_LESS:
            pRc->hwZFunc = zmode_ZLT;
            break;
        case GL_EQUAL:
            pRc->hwZFunc = zmode_ZE;
            break;
        case GL_LEQUAL:
            pRc->hwZFunc = zmode_ZLTE;
            break;
        case GL_GREATER:
            pRc->hwZFunc = zmode_ZGT;
            break;
        case GL_NOTEQUAL:
            pRc->hwZFunc = zmode_ZNE;
            break;
        case GL_GEQUAL:
            pRc->hwZFunc = zmode_ZGTE;
            break;
        case GL_ALWAYS:
            pRc->hwZFunc = zmode_NOZCMP;
            break;
    }

    if (pRc->MCDState.enables & MCD_COLOR_LOGIC_OP_ENABLE) {
        pRc->hwRop = xlatRop[pRc->MCDState.logicOpMode & 0xf];
    } else
        pRc->hwRop = bop_SRCCOPY;

    HW_GET_PLANE_MASK(pRc);

    pRc->privateEnables = 0;

    if ((pRc->MCDState.twoSided) &&
        (pRc->MCDState.enables & MCD_LIGHTING_ENABLE))
        pRc->privateEnables |= __MCDENABLE_TWOSIDED;        
    if (pDevWnd->bValidZBuffer && 
        (pRc->MCDState.enables & MCD_DEPTH_TEST_ENABLE))
        pRc->privateEnables |= __MCDENABLE_Z;
    if (pRc->MCDState.shadeModel == GL_SMOOTH)
        pRc->privateEnables |= __MCDENABLE_SMOOTH;
   
    // Bail out if we can't support the requested z-buffer function:

    if (pRc->privateEnables & __MCDENABLE_Z) {
        if (!bSupportedZFunc) {
            pRc->allPrimFail = TRUE;
            return;
        }

        if ((pRc->MCDState.depthWritemask) && (pRc->zBufEnabled)) {
            pRc->hwTrapFunc = pRc->hwLineFunc = atype_ZI;
        } else {
            pRc->hwTrapFunc = pRc->hwLineFunc = atype_I;
        }

        pRc->hwTrapFunc |= opcode_TRAP | pRc->hwRop | pRc->hwZFunc;
        pRc->hwLineFunc |= opcode_LINE_OPEN | pRc->hwRop | pRc->hwZFunc;

    } else {
        pRc->hwTrapFunc = opcode_TRAP | atype_I | bop_SRCCOPY;
        pRc->hwLineFunc = opcode_LINE_OPEN | atype_I | bop_SRCCOPY;
    }

    pRc->HWSetupClipRect = HWSetupClipping;

    // Even though we're set up to handle this in the primitive pick
    // functions, we'll exit early here since we don't actually handle
    // this in the primitive routines themselves:

    if (pRc->MCDState.drawBuffer == GL_FRONT_AND_BACK) {
        pRc->allPrimFail = TRUE;
        return;
    }
        
    // If we're culling everything or not updating any of our buffers, just
    // return for all primitives:

    if (((pRc->MCDState.enables & MCD_CULL_FACE_ENABLE) &&
         (pRc->MCDState.cullFaceMode == GL_FRONT_AND_BACK)) ||
        ((pRc->MCDState.drawBuffer == GL_NONE) && 
         ((!pRc->MCDState.depthWritemask) || (!pDevWnd->bValidZBuffer)))
       ) {
        pRc->renderPoint = NullRenderPoint;
        pRc->renderLine = NullRenderLine;
        pRc->renderTri = NullRenderTri;
        pRc->allPrimFail = FALSE;
        return;
    }

    // Build lookup table for face direction

    switch (pRc->MCDState.frontFace) {
        case GL_CW:
            pRc->polygonFace[__MCD_CW] = __MCD_BACKFACE;
            pRc->polygonFace[__MCD_CCW] = __MCD_FRONTFACE;
            break;
        case GL_CCW:
            pRc->polygonFace[__MCD_CW] = __MCD_FRONTFACE;
            pRc->polygonFace[__MCD_CCW] = __MCD_BACKFACE;
            break;
    }

    // Build lookup table for face filling modes:

    pRc->polygonMode[__MCD_FRONTFACE] = pRc->MCDState.polygonModeFront;
    pRc->polygonMode[__MCD_BACKFACE] = pRc->MCDState.polygonModeBack;

    if (pRc->MCDState.enables & MCD_CULL_FACE_ENABLE)
        pRc->cullFlag = (pRc->MCDState.cullFaceMode == GL_FRONT ? __MCD_FRONTFACE :
                                                                  __MCD_BACKFACE);
    else
        pRc->cullFlag = __MCD_NOFACE;

    // Assume that we fail everything:
        
    pRc->allPrimFail = TRUE;

    // Determine if we have "cheap" fog:

    pRc->bCheapFog = FALSE;

    if (pRc->MCDState.enables & MCD_FOG_ENABLE) {
        if (!(pRc->MCDState.textureEnabled) &&
             (pRc->MCDState.fogHint != GL_NICEST)) {
            pRc->bCheapFog = TRUE;
            pRc->privateEnables |= __MCDENABLE_SMOOTH;
            if ((pRc->MCDState.fogColor.r == pRc->MCDState.fogColor.g) &&
                (pRc->MCDState.fogColor.r == pRc->MCDState.fogColor.b))
                pRc->privateEnables |= __MCDENABLE_GRAY_FOG;                
        }
    }
    
    if (pRc->MCDState.textureEnabled)
        return;

    if (pRc->MCDState.enables & (MCD_ALPHA_TEST_ENABLE |
                                 MCD_BLEND_ENABLE |
                                 MCD_STENCIL_TEST_ENABLE))
        return;
                                

// Get rendering functions for points:

    if (!PickPointFuncs(pRc)) {
        pRc->primFunc[GL_POINTS] = FailPrimDraw;
    } else
        pRc->allPrimFail = FALSE;

// Get rendering functions for lines:

    if (!PickLineFuncs(pRc)) {
        pRc->primFunc[GL_LINES] = FailPrimDraw;
        pRc->primFunc[GL_LINE_LOOP] = FailPrimDraw;
        pRc->primFunc[GL_LINE_STRIP] = FailPrimDraw;
    } else
        pRc->allPrimFail = FALSE;

// Get rendering functions for triangles:

    if (!PickTriangleFuncs(pRc)) {
        pRc->primFunc[GL_TRIANGLES] = FailPrimDraw;
        pRc->primFunc[GL_TRIANGLE_STRIP] = FailPrimDraw;
        pRc->primFunc[GL_TRIANGLE_FAN] = FailPrimDraw;
        pRc->primFunc[GL_QUADS] = FailPrimDraw;
        pRc->primFunc[GL_QUAD_STRIP] = FailPrimDraw;
        pRc->primFunc[GL_POLYGON] = FailPrimDraw;
    } else
        pRc->allPrimFail = FALSE;       
}

////////////////////////////////////////////////////////////////////////
// Hardware-specific utility functions:
////////////////////////////////////////////////////////////////////////


VOID FASTCALL HWSetupClipping(DEVRC *pRc, RECTL *pClip)
{
    PDEV *ppdev = pRc->ppdev;
    BYTE *pjBase = ppdev->pjBase;

    CHECK_FIFO_FREE(pjBase, pRc->cFifo, 4);

    CP_WRITE(pjBase, DWG_CYTOP,
                  ((pClip->top + pRc->hwBufferYBias) * ppdev->cxMemory) +
                  ppdev->ulYDstOrg);
    CP_WRITE(pjBase, DWG_CXLEFT, pClip->left);
    CP_WRITE(pjBase, DWG_CXRIGHT, pClip->right - 1);
    CP_WRITE(pjBase, DWG_CYBOT,
                 ((pClip->bottom + pRc->hwBufferYBias - 1) * ppdev->cxMemory) +
                  ppdev->ulYDstOrg);

}

//#define DEBUG_OFFSCREEN 1
//#define DEBUG_OFFSSCREEN_PARTIAL 1

#if DEBUG_OFFSCREEN

#undef pohAllocate
#undef pohFree
#define pohAllocate 
#define pohFree 

#endif

VOID HWUpdateBufferPos(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL bForce)
{
    PDEV *ppdev = (PDEV *)pso->dhpdev;
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    ULONG height;

    if (pDevWnd->pohZBuffer && 
        ((ppdev->pohZBuffer != pDevWnd->pohZBuffer) ||
         (bForce))) {

        LONG offset;
        LONG offsetAdj;
        ULONG y;

        // First, re-adjust the z buffer so that its offset from
        // the front buffer window rectangle (in z) is a multiple of 512:

        if (ppdev->pohZBuffer != pDevWnd->pohZBuffer)
            offset = pDevWnd->zBufferBase - 
                     (pMCDWnd->clipBoundsRect.top * pDevWnd->zPitch);
        else
            offset = pDevWnd->zBufferBase;

        if (offset < 0) {

            offset = -offset;

            for (y = 0, offsetAdj = 0; 
                 (y < pDevWnd->numPadScans) && (offset & 0x1ff);
                 offset -= pDevWnd->zPitch, offsetAdj += pDevWnd->zPitch)
                ;

        } else {
            for (y = 0, offsetAdj = 0; 
                 (y < pDevWnd->numPadScans) && (offset & 0x1ff);
                 offset += pDevWnd->zPitch, offsetAdj += pDevWnd->zPitch)
                ;
        }
    
        ASSERTDD((offset & 0x1ff) == 0, "Z scan not on a 512-byte boundary.");
        ASSERTDD(y <= pDevWnd->numPadScans, "Z scan adjustment too large");

        pDevWnd->zBufferOffset = pDevWnd->zBufferBase + offsetAdj;

        // Now, re-adjust the back buffer so that its offset (in z) from
        // the new z buffer offset is also a multiple of 512 bytes.  Note
        // that zBufferOffset is always a multiple of zPitch:

        if (pDevWnd->pohBackBuffer) {

            offset = (pDevWnd->backBufferBaseY * pDevWnd->zPitch) - 
                     pDevWnd->zBufferOffset;

            for (y = 0; (y < pDevWnd->numPadScans) && (offset & 0x1ff); y++)
                offset += pDevWnd->zPitch;

            ASSERTDD((offset & 0x1ff) == 0, "Scan not on a 512-byte boundary.");
            ASSERTDD(y <= pDevWnd->numPadScans, "Scan adjustment too large");

            pDevWnd->backBufferY = y + pDevWnd->backBufferBaseY;
            pDevWnd->backBufferOffset = (pDevWnd->backBufferY * ppdev->lDelta);
        }
    }

    height = pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top;    

    if (height > pDevWnd->allocatedBufferHeight) {
#ifdef DEVDBG
        MCDBG_PRINT("HWUpdateBufferPos: buffers are now an invalid size.");
#endif

        pDevWnd->bValidBackBuffer = FALSE;
        pDevWnd->bValidZBuffer = FALSE;
    }
}

BOOL HWAllocResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso,
                      BOOL zBufferEnabled,
                      BOOL backBufferEnabled)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV *ppdev = (PDEV *)pso->dhpdev;
    ULONG w, width, height, fullHeight, zHeight, zFullHeight;
    BOOL needFullZBuffer, needFullBackBuffer;
    ULONG bufferExtra;
    ULONG wPow2;
    ULONG zPitch;
    BOOL bFullScreen = FALSE;
    OH* pohBackBuffer = NULL;
    OH* pohZBuffer = NULL;
#if DEBUG_OFFSCREEN
    static OH fakeOh[2];

    pohBackBuffer = &fakeOh[0];
    pohZBuffer = &fakeOh[1];

    pohBackBuffer->y = 512;
    pohZBuffer->y = 256;
#endif

#ifdef DEVDBG
    MCDBG_PRINT("HWAllocResources");
#endif

#if DEBUG_OFFSCREEN
    width = ppdev->cxScreen;
    height = 256;
#else
    width = ppdev->cxScreen;
    height = min(pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top,
                 ppdev->cyScreen);
#endif

    // Assume failure:

    pDevWnd->allocatedBufferHeight = 0;
    pDevWnd->bValidBackBuffer = FALSE;
    pDevWnd->bValidZBuffer = FALSE;
    pDevWnd->pohBackBuffer = NULL;
    pDevWnd->pohZBuffer = NULL;

    fullHeight = ppdev->cyScreen;

    switch (ppdev->iBitmapFormat) {
        case BMF_8BPP:
            zPitch = ppdev->lDelta * 2;            
            break;
        case BMF_16BPP:
            zPitch = ppdev->lDelta;
            break;
        case BMF_24BPP:
        case BMF_32BPP:
            zPitch = ppdev->lDelta / 2;
            break;
        default:
            return FALSE;
    }


    // We have to be able to keep our buffers 512-byte aligned, so calculate
    // extra scan lines needed to aligned scan on a 512-byte boundary:

    for (wPow2 = 1, w = zPitch;
         (w) && !(w & 1); w >>= 1, wPow2 *= 2)
        ;

    bufferExtra = 512 / wPow2;  // z buffer granularity is 512 bytes...

    // Now adjust the number of extra scan lines needed for the pixel format
    // we're using, since the z and color stride may be different...

    switch (ppdev->iBitmapFormat) {
        case BMF_8BPP:
            zHeight = ((height + bufferExtra) * 2) + 1;
            zFullHeight = ((fullHeight + bufferExtra) * 2) + 1;
            break;
        case BMF_16BPP:
            zHeight = height + bufferExtra;
            zFullHeight = fullHeight + bufferExtra;
            break;
        case BMF_24BPP:
        case BMF_32BPP:
            zHeight = (height + bufferExtra + 1) / 2;
            zFullHeight = (fullHeight + bufferExtra + 1) / 2;
            break;
        default:
            return FALSE;
    }

    pDevWnd->numPadScans = bufferExtra;

    // Add extra scans for alignment:

    height += bufferExtra;
    fullHeight += bufferExtra;

    if ((backBufferEnabled) && (!ppdev->cDoubleBufferRef))
        needFullBackBuffer = TRUE;
    else
        needFullBackBuffer = FALSE;

    if ((zBufferEnabled) && (!ppdev->cZBufferRef))
        needFullZBuffer = TRUE;
    else
        needFullZBuffer = FALSE;

// debugging - force parial window allocation

#if DEBUG_OFFSCREEN && DEBUG_OFFSCREEN_PARTIAL
    pohBackBuffer = NULL;
    pohZBuffer = NULL;
#endif

    // Before we begin, boot all the discardable stuff from offscreen
    // memory:

    bMoveAllDfbsFromOffscreenToDibs(ppdev);

    // If we need a back buffer, first try to allocate a fullscreen one:

    if (needFullBackBuffer) {
#ifndef DEBUG_OFFSCREEN
        pohBackBuffer = pohAllocate(ppdev, NULL, width, fullHeight,
                                    FLOH_MAKE_PERMANENT);
#endif
        if (pohBackBuffer) {
            ppdev->pohBackBuffer = pohBackBuffer;
            ppdev->cDoubleBufferRef = 0;
        }
    }

    // If we need a z buffer, first try to allocate a fullscreen z:

    if (needFullZBuffer) {
#ifndef DEBUG_OFFSCREEN
        pohZBuffer = pohAllocate(ppdev, NULL, width, zFullHeight,
                                 FLOH_MAKE_PERMANENT);
#endif
        if (pohZBuffer) {
            ppdev->pohZBuffer = pohZBuffer;
            ppdev->cZBufferRef = 0;
        } else
            needFullBackBuffer = FALSE;
    }

    // One of our full-screen allocations failed:

    if ((needFullZBuffer && !pohZBuffer) ||
        (needFullBackBuffer && !pohBackBuffer)) {

        // Free any resources allocated so far:

        if (pohZBuffer) {
            pohFree(ppdev, pohZBuffer);
            ppdev->pohZBuffer = NULL;
            ppdev->cZBufferRef = 0;
        }
        if (pohBackBuffer) {
            pohFree(ppdev, pohBackBuffer);
            ppdev->pohBackBuffer = NULL;
            ppdev->cDoubleBufferRef = 0;
        }

        // Now, try to allocate per-window resources:

        if (backBufferEnabled) {
#ifndef DEBUG_OFFSCREEN
            pohBackBuffer = pohAllocate(ppdev, NULL, width, height,
                                        FLOH_MAKE_PERMANENT);
#else
            pohBackBuffer = &fakeOh[0];
#endif

            if (!pohBackBuffer) {
                return FALSE;
            }
        }

        if (zBufferEnabled) {
#ifndef DEBUG_OFFSCREEN
            pohZBuffer = pohAllocate(ppdev, NULL, width, zHeight,
                                     FLOH_MAKE_PERMANENT);
#else
            pohZBuffer = &fakeOh[1];
#endif

            if (!pohZBuffer) {
                if (pohBackBuffer)
                    pohFree(ppdev, pohBackBuffer);
                return FALSE;
            }
        }

#ifdef DEVDBG
        if (zBufferEnabled)
            MCDBG_PRINT("HWAllocResources: Allocated window-sized z buffer");
        if (backBufferEnabled)
            MCDBG_PRINT("HWAllocResources: Allocated window-sized back buffer");
#endif

    } else {
        // Our full-screen allocations worked, or the resources existed
        // already:

        bFullScreen = TRUE;

#ifdef DEVDBG
        if (zBufferEnabled && !ppdev->cZBufferRef)
            MCDBG_PRINT("HWAllocResources: Allocated full-screen z buffer");
        if (backBufferEnabled && !ppdev->cDoubleBufferRef)
            MCDBG_PRINT("HWAllocResources: Allocated full-screen back buffer");
#endif

        if (zBufferEnabled) {
            pohZBuffer = ppdev->pohZBuffer;
            ppdev->cZBufferRef++;
        }

        if (backBufferEnabled) {
            pohBackBuffer = ppdev->pohBackBuffer;
            ppdev->cDoubleBufferRef++;
        }
    }

    pDevWnd->pohBackBuffer = pohBackBuffer;
    pDevWnd->pohZBuffer = pohZBuffer;

    pDevWnd->frontBufferPitch = ppdev->lDelta;

    // Calculate back buffer variables:

    if (backBufferEnabled) {
        ULONG y;
        ULONG offset;

        ASSERTDD(pohBackBuffer->x == 0,
                 "Back buffer should be 0-aligned");

        // Set up base position, etc.

        pDevWnd->backBufferY = pDevWnd->backBufferBaseY = pohBackBuffer->y;
        pDevWnd->backBufferOffset = pDevWnd->backBufferBase = 
            pohBackBuffer->y * ppdev->lDelta;
        pDevWnd->backBufferPitch = ppdev->lDelta;
        pDevWnd->bValidBackBuffer = TRUE;
    }

    if (zBufferEnabled) {
        ULONG y = pohZBuffer->y;

        ASSERTDD(pohZBuffer->x == 0,
                 "Z buffer should be 0-aligned");

        pDevWnd->zBufferBaseY = pohZBuffer->y;

        // Make sure out z buffer starts on a valid z scan line.  The only
        // case where this may not happen is 8bpp, which is why we add one
        // the the number if z scan lines allocated above.

        if (ppdev->iBitmapFormat == BMF_8BPP)
            pDevWnd->zBufferBase = (pohZBuffer->y & ~1) * ppdev->lDelta;
        else
            pDevWnd->zBufferBase = pohZBuffer->y * ppdev->lDelta;

        pDevWnd->zPitch = zPitch;
        pDevWnd->bValidZBuffer = TRUE;
    }

    if (bFullScreen)
        pDevWnd->allocatedBufferHeight = ppdev->cyMemory;
    else
        pDevWnd->allocatedBufferHeight = min(pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top,
                                             ppdev->cyScreen);

    // Update position-dependant buffer information:
 
    HWUpdateBufferPos(pMCDWnd, pso, TRUE);

#ifdef DEVDBG
    MCDBG_PRINT("HWAllocResources OK");
#endif

    return TRUE;
}

VOID HWFreeResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV *ppdev = (PDEV *)pso->dhpdev;

    if (pDevWnd->pohZBuffer) {
        if (ppdev->cZBufferRef) {
            if (!--ppdev->cZBufferRef) {
#ifdef DEVDBG
                MCDBG_PRINT("MCDrvTrackWindow: Free global z buffer");
#endif
                pohFree(ppdev, ppdev->pohZBuffer);
                ppdev->pohZBuffer = NULL;
            }
        } else {
#ifdef DEVDBG
            MCDBG_PRINT("MCDrvTrackWindow: Free local z buffer");
#endif
            pohFree(ppdev, pDevWnd->pohZBuffer);
        }
    }

    if (pDevWnd->pohBackBuffer) {
        if (ppdev->cDoubleBufferRef) {
            if (!--ppdev->cDoubleBufferRef) {
#ifdef DEVDBG
                MCDBG_PRINT("MCDrvTrackWindow: Free global color buffer");
#endif
                pohFree(ppdev, ppdev->pohBackBuffer);
                ppdev->pohBackBuffer = NULL;
            }
        } else {
#ifdef DEVDBG
            MCDBG_PRINT("MCDrvTrackWindow: Free local color buffer");
#endif
            pohFree(ppdev, pDevWnd->pohBackBuffer);
        }
    }
}

VOID __MCDCalcFogColor(DEVRC *pRc, MCDVERTEX *a, MCDCOLOR *pResult, 
                       MCDCOLOR *pColor)
{
    MCDFLOAT oneMinusFog;
    MCDCOLOR *pFogColor;

    pFogColor = (MCDCOLOR *)&pRc->MCDState.fogColor; 
    oneMinusFog = (MCDFLOAT)1.0 - a->fog;

    if (pRc->privateEnables & __MCDENABLE_GRAY_FOG) {
        MCDFLOAT delta = oneMinusFog * pFogColor->r;

        pResult->r = a->fog * pColor->r + delta;
        pResult->g = a->fog * pColor->g + delta;
        pResult->b = a->fog * pColor->b + delta;
    } else {
       pResult->r = (a->fog * pColor->r) + (oneMinusFog * pFogColor->r);
       pResult->g = (a->fog * pColor->g) + (oneMinusFog * pFogColor->g);
       pResult->b = (a->fog * pColor->b) + (oneMinusFog * pFogColor->b);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Copyright (c) 1993-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

#define GO_BOARD(pmdev, pmb) { (pmdev)->pmbCurrent = (pmb); }

#define MAKE_BOARD_CURRENT(pmdev, pmb)                              \
{                                                                   \
    ULONG ReturnedDataLength;                                       \
                                                                    \
    if (EngDeviceIoControl((pmdev)->hDriver,                        \
                         IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT,        \
                         &(pmb)->iBoard,            /* Input */     \
                         sizeof(LONG),                              \
                         NULL,                      /* Output */    \
                         0,                                         \
                         &ReturnedDataLength))                      \
    {                                                               \
        RIP("Failed MTX_MAKE_BOARD_CURRENT");                       \
    }                                                               \
}

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HANDLE          hDriver;        // Our handle to miniport
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking
    ULONG           ulMode;         // 'Super' mode for each screen

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* BOOL bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* BOOL bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* BOOL bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
 