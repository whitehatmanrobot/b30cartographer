changes:
        This routine will allocate memory and assign pointer in the
        temporary structure.

Arguments:

    ppString            :  Points to a pointer in the temporary sturucture
    pNewValue           : New value to be set
    pOldValue           : Value in the original strucutre
    bCaseSensitive      : Determines whether case-sensitive string compare is performed
    pbFail              :     On error set this to TRUE (Note: it could already be TRUE)
    *pbIdentical        : If the strings are diferent this is set to FALSE. 
                          (Could already be false).

Return Value:

    TRUE on success, else FALSE

--*/
BOOL
AllocOrUpdateStringAndTestSame(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail,
    IN  OUT BOOL        *pbIdentical      
    )
{
    BOOL    bReturn = TRUE;
    int     iReturn;

    if ( *pbFail )
        return FALSE;


    if (wstrcmpEx(pNewValue, pOldValue, bCaseSensitive)) {

        *pbIdentical = FALSE;

        if ( pNewValue && *pNewValue ) {

            if ( !(*ppString = AllocSplStr(pNewValue)) ) {

                *pbFail   = TRUE;
                bReturn = FALSE;
            }
        } else {

            *ppString = NULL;
        }
    }

    return bReturn;
}

/*++

Routine Name:

    AllocOrUpdateString

Routine Description:

    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and copy the old structure to it.
    Then call this routine for all LPWSTR fields to check and update strings

    If the value changes:
        This routine will allocate memory and assign pointer in the
        temporary structure.

Arguments:

    ppString            :  Points to a pointer in the temporary sturucture
    pNewValue           : New value to be set
    pOldValue           : Value in the original strucutre
    bCaseSensitive      : Determines whether case-sensitive string compare is performed
    pbFail              :     On error set this to TRUE (Note: it could already be TRUE)

Return Value:

    TRUE on success, else FALSE

--*/
BOOL
AllocOrUpdateString(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail
    )
{
    BOOL    bIdentical = FALSE;

    return AllocOrUpdateStringAndTestSame(ppString, pNewValue, pOldValue, bCaseSensitive, pbFail, &bIdentical);
}

VOID
CopyNewOffsets(
    LPBYTE  pStruct,
    LPBYTE  pTempStruct,
    LPDWORD lpOffsets)
/*++

Routine Description:
    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and allocate memory for values which
    are being updated in it, and set the remaining pointers to those in
    the original.

    This routine is called at the end to update the structure.

Arguments:
    pStruct:        Pointer to the structure
    pTempStruct:    Pointer to the temporary structure
    lpOffsets:      An array of DWORDS givings offsets within the stuctures

Return Value:
    nothing

History:
    MuhuntS -- Aug 95

--*/
{
    register INT i;

    for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

        if ( *(LPBYTE *) (pStruct+lpOffsets[i]) !=
                *(LPBYTE *) (pTempStruct+lpOffsets[i]) ) {

            if ( *(LPBYTE *) (pStruct+lpOffsets[i]) )
                FreeSplMem(*(LPBYTE *) (pStruct+lpOffsets[i]));

            *(LPBYTE *) (pStruct+lpOffsets[i]) = *(LPBYTE *) (pTempStruct+lpOffsets[i]);
        }
    }
}


DWORD
GetIniDriverAndDirForThisMachine(
    IN  PINIPRINTER     pIniPrinter,
    OUT LPWSTR          pszDriverDir,
    OUT PINIDRIVER     *ppIniDriver
    )
/*++

Description:
    Gets the path to the driver directory for the printer on the local machine

Arguments:
    pIniPrinter     - Points to IniPrinter
    pszDriverDir    - A buffer of size MAX_PATH to get the directory path

Return Vlaue:
    Number of characters copied (0 on failure)

--*/
{
    PINIVERSION         pIniVersion = NULL;
    PINIENVIRONMENT     pIniEnvironment;
    PINISPOOLER         pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD               dwIndex;

    EnterSplSem();
    //
    // Find driver file for the given driver and then get it's fullpath
    //
    SPLASSERT(pIniPrinter && pIniPrinter->pIniDriver && pIniPrinter->pIniDriver->pName);


    pIniEnvironment = FindEnvironment(szEnvironment, pIniSpooler);
    *ppIniDriver    = FindCompatibleDriver(pIniEnvironment,
                                           &pIniVersion,
                                           pIniPrinter->pIniDriver->pName,
                                           dwMajorVersion,
                                           dwUpgradeFlag);


    SPLASSERT(*ppIniDriver);

    dwIndex = GetDriverVersionDirectory(pszDriverDir,
                                        MAX_PATH - 2,
                                        pIniPrinter->pIniSpooler,
                                        pIniEnvironment,
                                        pIniVersion,
                                        *ppIniDriver,
                                        NULL);

    pszDriverDir[dwIndex++] = L'\\';
    pszDriverDir[dwIndex] = L'\0';

    LeaveSplSem();

    return dwIndex;

}


LPWSTR
GetConfigFilePath(
    IN PINIPRINTER  pIniPrinter
    )
/*++

Description:
    Gets the full path to the config file (driver ui file) associated with the
    driver. Memory is allocated

Arguments:
    pIniPrinter - Points to IniPrinter

Return Vlaue:
    Pointer to the printer name buffer (NULL on error)

--*/
{
    DWORD       dwIndex;
    WCHAR       szDriverPath[MAX_PATH + 1];
    PINIDRIVER  pIniDriver;

    if ( dwIndex = GetIniDriverAndDirForThisMachine(pIniPrinter,
                                                    szDriverPath,
                                                    &pIniDriver) )
        wcscpy(szDriverPath+dwIndex, pIniDriver->pConfigFile);

    return AllocSplStr(szDriverPath);
}


PDEVMODE
ConvertDevModeToSpecifiedVersion(
    IN  PINIPRINTER pIniPrinter,
    IN  PDEVMODE    pDevMode,
    IN  LPWSTR      pszConfigFile,              OPTIONAL
    IN  LPWSTR      pszPrinterNameWithToken,    OPTIONAL
    IN  BOOL        bNt35xVersion
    )
/*++

Description:
    Calls driver UI routines to get the default devmode and then converts given devmode
    to that version. If the input devmode is in IniPrinter routine makes a copy before
    converting it.

    This routine needs to be called from inside spooler semaphore

Arguments:
    pIniPrinter     - Points to IniPrinter

    pDevMode        -  Devmode to convert to current version

    pConfigFile     - Full path to driver UI file to do LoadLibrary (optional)

    pszPrinterNameWithToken - Name of printer with token (optional)

    bToNt3xVersion          - If TRUE devmode is converted to Nt3x format, else to current version

Return Vlaue:
    Pointer to new devmode on success, NULL on failure

--*/
{
    LPWSTR          pszLocalConfigFile = pszConfigFile;
    LPWSTR          pszLocalPrinterNameWithToken = pszPrinterNameWithToken;
    LPDEVMODE       pNewDevMode = NULL, pOldDevMode = NULL;
    DWORD           dwNeeded, dwLastError;
    LONG            lNeeded;
    HANDLE          hDevModeConvert = NULL,hPrinter = NULL;
    BOOL            bCallDocumentProperties = FALSE;

    SplInSem();

    //
    // If ConfigFile or PrinterNameWithToken is not given allocate it locally
    //
    if ( !pszLocalConfigFile ) {

        pszLocalConfigFile = GetConfigFilePath(pIniPrinter);
        if ( !pszLocalConfigFile )
            goto Cleanup;
    }

    if ( !pszLocalPrinterNameWithToken ) {

        pszLocalPrinterNameWithToken = pszGetPrinterName( pIniPrinter,
                                                          TRUE,
                                                          pszLocalOnlyToken );
        if ( !pszLocalPrinterNameWithToken )
            goto Cleanup;

    }

    //
    // If we are trying to convert pIniPrinter->pDevMode make a copy since we are going to leave SplSem
    //
    if ( pDevMode  ) {

        if ( pDevMode == pIniPrinter->pDevMode ) {

            dwNeeded = pDevMode->dmSize + pDevMode->dmDriverExtra;
            SPLASSERT(dwNeeded == pIniPrinter->cbDevMode);
            pOldDevMode = AllocSplMem(dwNeeded);
            if ( !pOldDevMode )
                goto Cleanup;
            CopyMemory((LPBYTE)pOldDevMode, (LPBYTE)pDevMode, dwNeeded);

        } else {

            pOldDevMode = pDevMode;
        }
    }

    //
    // Driver is going to call OpenPrinter, so leave SplSem
    //
    LeaveSplSem();
    SplOutSem();

    hDevModeConvert = LoadDriverFiletoConvertDevmode(pszLocalConfigFile);

    if ( !hDevModeConvert ) {

        // If the function is not exported and 3.5x conversion is not required
        // the devmode can be got from DocumentProperties

        if ( bNt35xVersion != NT3X_VERSION ) {
           bCallDocumentProperties = TRUE;
        }
        goto CleanupFromOutsideSplSem;
    }


    dwNeeded = 0;
    if ( bNt35xVersion == NT3X_VERSION ) {

        //
        // Call CallDrvDevModeConversion to allocate memory and return 351 devmode
        //
        dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                               pszLocalPrinterNameWithToken,
                                               (LPBYTE)pOldDevMode,
                                               (LPBYTE *)&pNewDevMode,
                                               &dwNeeded,
                                               CDM_CONVERT351,
                                               TRUE);

        SPLASSERT(dwLastError == ERROR_SUCCESS || !pNewDevMode);
    } else {

        //
        // Call CallDrvDevModeConversion to allocate memory and give default devmode
        dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                               pszLocalPrinterNameWithToken,
                                               NULL,
                                               (LPBYTE *)&pNewDevMode,
                                               &dwNeeded,
                                               CDM_DRIVER_DEFAULT,
                                               TRUE);

        if ( dwLastError != ERROR_SUCCESS ) {

            SPLASSERT(!pNewDevMode);

            // Call DocumentProperties to get the default devmode
            bCallDocumentProperties = TRUE;

            goto CleanupFromOutsideSplSem;
        }

        //
        // If we have an input devmode to convert to current mode call driver again
        //
        if ( pOldDevMode ) {

            dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                                   pszLocalPrinterNameWithToken,
                                                   (LPBYTE)pOldDevMode,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwNeeded,
                                                   CDM_CONVERT,
                                                   FALSE);

            //
            // If call failed free devmode which was allocated by previous call
            //
            if ( dwLastError != ERROR_SUCCESS ) {

                // Call DocumentProperties to get the default devmode
                bCallDocumentProperties = TRUE;

                goto CleanupFromOutsideSplSem;
            }
        }
    }


CleanupFromOutsideSplSem:

    if (bCallDocumentProperties) {

       // Get a client side printer handle to pass to the driver
       if (!(* pfnOpenPrinter)(pszLocalPrinterNameWithToken, &hPrinter, NULL)) {
           goto ReEnterSplSem;
       }

       if (!pNewDevMode) {
          // Get the default devmode
          lNeeded = (* pfnDocumentProperties)(NULL,
                                              hPrinter,
                                              pszLocalPrinterNameWithToken,
                                              NULL,
                                              NULL,
                                              0);

          if (lNeeded <= 0  ||
              !(pNewDevMode = (LPDEVMODEW) AllocSplMem(lNeeded)) ||
              (* pfnDocumentProperties)(NULL,
                                        hPrinter,
                                        pszLocalPrinterNameWithToken,
                                        pNewDevMode,
                                        NULL,
                                        DM_OUT_BUFFER) < 0) {

               if (pNewDevMode) {
                  FreeSplMem(pNewDevMode);
                  pNewDevMode = NULL;
                  goto ReEnterSplSem;
               }
          }
       }

       if (pOldDevMode) {
          // Convert to Current mode
          if ((* pfnDocumentProperties)(NULL,
                                        hPrinter,
                                        pszLocalPrinterNameWithToken,
                                        pNewDevMode,
                                        pOldDevMode,
                                        DM_IN_BUFFER | DM_OUT_BUFFER) < 0) {

              FreeSplMem(pNewDevMode);
              pNewDevMode = NULL;
              goto ReEnterSplSem;
          }
       }
    }

ReEnterSplSem:

    if (hPrinter) {
        (* pfnClosePrinter)(hPrinter);
    }

    SplOutSem();
    EnterSplSem();

Cleanup:

    if ( hDevModeConvert )
        UnloadDriverFile(hDevModeConvert);

    if ( pszLocalConfigFile != pszConfigFile )
        FreeSplStr(pszLocalConfigFile);

    if ( pszPrinterNameWithToken != pszLocalPrinterNameWithToken )
        FreeSplStr(pszLocalPrinterNameWithToken);

    if ( pOldDevMode != pDevMode )
        FreeSplMem(pOldDevMode);

    return pNewDevMode;
}


BOOL
IsPortType(
    LPWSTR pPort,
    LPWSTR pPrefix
)
{
    DWORD   dwLen;

    SPLASSERT(pPort && *pPort && pPrefix && *pPrefix);

    dwLen = wcslen(pPrefix);

    if ( wcslen(pPort) < dwLen ) {

        return FALSE;
    }

    if ( _wcsnicmp(pPort, pPrefix, dwLen) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 *
 * Notes:
 *      With DBCS enabled, we will allocate twice the size of the
 *      buffer including the null terminator to take care of double
 *      byte character strings - KrishnaG
 *
 *      pUnicode is truncated to StringLength characters.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR  pAnsi,
    DWORD  StringLength)
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }


    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //
    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //
    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = AllocSplMem(StringLength*2);
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_THREAD_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength*2,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf )
    {
        if( rc > 0 )
        {
            pAnsi = (LPSTR)pUnicode;
            strcpy( pAnsi, pTempBuf );
        }

        FreeSplMem(pTempBuf);
    }

    return rc;
}


LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
/*++

Description:
    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:
    pAnsi    - Points to the ANSI string

Return Vlaue:
    Pointer to UNICODE string

--*/
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}

VOID
FreeIniSpoolerOtherNames(
    PINISPOOLER pIniSpooler
    )
{
    DWORD   Index = 0;

    if ( pIniSpooler->ppszOtherNames ) {

        for ( Index = 0 ; Index < pIniSpooler->cOtherNames ; ++Index ) {

            FreeSplMem(pIniSpooler->ppszOtherNames[Index]);
        }

        FreeSplMem(pIniSpooler->ppszOtherNames);
    }

    pIniSpooler->cOtherNames = 0;
}

BOOL
SplMonitorIsInstalled(
    LPWSTR  pMonitorName
    )
{
    BOOL    bRet;

    EnterSplSem();
    bRet = FindMonitor(pMonitorName, pLocalIniSpooler) != NULL;
    LeaveSplSem();

    return bRet;
}




BOOL
PrinterDriverEvent(
    PINIPRINTER pIniPrinter,
    INT     PrinterEvent,
    LPARAM  lParam
)
/*++

--*/
{
    BOOL    ReturnValue = FALSE;
    LPWSTR  pPrinterName = NULL;
    BOOL    InSpoolSem = TRUE;

    SplOutSem();
    EnterSplSem();

    //
    //  We have to Clone the name string, incase someone does a
    //  rename whilst outside criticalsection.
    //

    pPrinterName = pszGetPrinterName( pIniPrinter, TRUE, pszLocalsplOnlyToken);

    LeaveSplSem();
    SplOutSem();


    if ( (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_PRINTER_DRIVER_EVENT) &&
     pPrinterName != NULL ) {

        ReturnValue = SplDriverEvent( pPrinterName, PrinterEvent, lParam );

    }

    FreeSplStr( pPrinterName );

    return  ReturnValue;
}




BOOL
SplDriverEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    LPARAM  lParam
)
{
    BOOL    ReturnValue = FALSE;

    if ( pfnPrinterEvent != NULL ) {

        SplOutSem();

        SPLASSERT( pName && PrinterEvent );

        DBGMSG(DBG_INFO, ("SplDriverEvent %ws %d %x\n", pName, PrinterEvent, lParam));

        ReturnValue = (*pfnPrinterEvent)( pName, PrinterEvent, PRINTER_EVENT_FLAG_NO_UI, lParam );
    }

    return ReturnValue;
}


DWORD
OpenPrinterKey(
    PINIPRINTER pIniPrinter,
    REGSAM      samDesired,
    HANDLE      *phKey,
    LPCWSTR     pKeyName,
    BOOL        bOpen
    )

/*++

Description:    OpenPrinterKey

     Opens "Printers" and IniPrinter->pName keys, then opens
     specified subkey "pKeyName" if pKeyName is not NULL

     This routine needs to be called from inside spooler semaphore

Arguments:
    pIniPrinter     - Points to IniPrinter

    *phPrinterRootKey -  Handle to "Printers" key on return

    *phPrinterKey -     Handle to IniPrinter->pName key on return

    *hKey -             Handle to pKeyName key on return

    pKeyName -          Points to SubKey to open

Return Value:

    Success or failure status

Author: Steve Wilson (NT)

--*/

{
    LPWSTR pThisKeyName = NULL;
    LPWSTR pPrinterKeyName = NULL;
    DWORD rc;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;

    SplInSem();

    if (!(pPrinterKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        rc = GetLastError();
        goto error;
    }

    if (pKeyName && *pKeyName){

        pThisKeyName = AllocSplMem(( wcslen(pPrinterKeyName) +
                                     wcslen(pKeyName) + 2 ) * sizeof(WCHAR) );
        if (!pThisKeyName) {
            rc = GetLastError();
            goto error;
        }

        wsprintf(pThisKeyName, L"%ws\\%ws", pPrinterKeyName, pKeyName);

    } else {
        pThisKeyName = pPrinterKeyName;
    }

    if (bOpen) {    // Open
        rc = SplRegOpenKey( pIniSpooler->hckPrinters,
                            pThisKeyName,
                            samDesired,
                            phKey,
                            pIniSpooler );
    }
    else {  // Create
        rc = SplRegCreateKey( pIniSpooler->hckPrinters,
                              pThisKeyName,
                              0,
                              samDesired,
                              NULL,
                              phKey,
                              NULL,
                              pIniSpooler );
    }

error:

    if (pThisKeyName != pPrinterKeyName) {
        FreeSplMem(pThisKeyName);
    }
    FreeSplStr(pPrinterKeyName);

    return rc;
}

BOOL
SplGetDriverDir(
    HANDLE      hIniSpooler,
    LPWSTR      pszDir,
    LPDWORD     pcchDir
    )
{
    DWORD           dwSize;
    PINISPOOLER     pIniSpooler = (PINISPOOLER)hIniSpooler;

    SPLASSERT(pIniSpooler && pIniSpooler->signature == ISP_SIGNATURE);

    dwSize      = *pcchDir;
    *pcchDir    = wcslen(pIniSpooler->pDir) + wcslen(szDriverDir) + 2;
    if ( *pcchDir > dwSize ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    wsprintf(pszDir, L"%ws\\%ws", pIniSpooler->pDir, szDriverDir);
    return TRUE;
}

VOID
GetRegistryLocation(
    IN HANDLE hKey,
    IN LPCWSTR pszPath,
    OUT PHANDLE phKeyOut,
    OUT LPCWSTR *ppszPathOut
    )

/*++

Routine Description:

    Take a registry path and detect whether it should be absolute (rooted
    from HKEY_LOCAL_MACHINE), or if it should be branched off of the
    subkey that is passed in hKey.

    By convention, if it starts with "\" then it is an absolute path.
    Otherwise it is relative off hKey.

Arguments:

    hKey - Print hKey

    pszPath - Path to parse.  If the pszPath starts with a
        backslash, then it is absolute.

    phKeyOut - New key that should be used.

    ppszPathOut - New path that should be used.

Return Value:

--*/

{
    if( pszPath && ( pszPath[0] == TEXT( '\\' ))){
        *phKeyOut = HKEY_LOCAL_MACHINE;
        *ppszPathOut = &pszPath[1];

        return;
    }
    *phKeyOut = hKey;
    *ppszPathOut = pszPath;
}


DWORD
DeletePrinterSubkey(
    PINIPRINTER pIniPrinter,
    PWSTR       pKeyName
)
{
    HKEY hKey, hPrinterKey;
    DWORD dwError;

    dwError = OpenPrinterKey(pIniPrinter, KEY_WRITE | KEY_READ, &hPrinterKey, NULL, TRUE);
    if (dwError == ERROR_SUCCESS) {
        dwError = OpenPrinterKey(   pIniPrinter,
                                    KEY_WRITE | KEY_READ,
                                    &hKey,
                                    pKeyName,
                                    TRUE);
        if (dwError == ERROR_SUCCESS) {
            dwError = SplDeleteThisKey( hPrinterKey,
                                        hKey,
                                        pKeyName,
                                        FALSE,
                                        pIniPrinter->pIniSpooler);
        }

        SplRegCloseKey(hPrinterKey, pIniPrinter->pIniSpooler);
    }

    return dwError;
}


PWSTR
FixDelim(
    PCWSTR    pszInBuffer,
    WCHAR    wcDelim
)
/*++

Routine Description:

    Removes duplicate delimiters from a set of delimited strings

Arguments:

    pszInBuffer - Input list of comma delimited strings

    wcDelim - The delimit character

Return Value:

    Returns a fixed string

--*/
{
    PWSTR    pszIn, pszOut, pszOutBuffer;
    BOOL    bFoundDelim = TRUE;

    pszOutBuffer = (PWSTR) AllocSplMem((wcslen(pszInBuffer) + 1)*sizeof(WCHAR));

    if (pszOutBuffer) {

        for(pszOut = pszOutBuffer, pszIn = (PWSTR) pszInBuffer ; *pszIn ; ++pszIn) {
            if (*pszIn == wcDelim) {
                if (!bFoundDelim) {
                    bFoundDelim = TRUE;
                    *pszOut++ = *pszIn;
                }
            } else {
                bFoundDelim = FALSE;
                *pszOut++ = *pszIn;
            }
        }

        // Check for trailing delimiter
        if (pszOut != pszOutBuffer && *(pszOut - 1) == wcDelim) {
            *(pszOut - 1) = L'\0';
        }

        *pszOut = L'\0';
    }

    return pszOutBuffer;
}

PWSTR
Array2DelimString(
    PSTRINGS    pStringArray,
    WCHAR        wcDelim
)
/*++

Routine Description:

    Converts a PSTRINGS structure to a set of delimited strings

Arguments:

    pStringArray - Input PSTRINGS structure

    wcDelim - The delimit character

Return Value:

    Delimited string buffer

--*/
{
    DWORD    i, nBytes;
    PWSTR    pszDelimString;
    WCHAR    szDelimString[2];


    if (!pStringArray || pStringArray->nElements == 0)
        return NULL;

    szDelimString[0] = wcDelim;
    szDelimString[1] = L'\0';

    // Determine memory requirement
    for (i = nBytes = 0 ; i < pStringArray->nElements  ; ++i) {
        //
        // allocate extra space for the delimiter
        //
        if (pStringArray->ppszString[i])
            nBytes += (wcslen(pStringArray->ppszString[i]) + 1)*sizeof (WCHAR);
    }

    pszDelimString = (PWSTR) AllocSplMem(nBytes);
    if (!pszDelimString)
        return NULL;

    for (i = 0 ; i < pStringArray->nElements - 1 ; ++i) {
        if (pStringArray->ppszString[i]) {
            wcscat(pszDelimString, pStringArray->ppszString[i]);
            wcscat(pszDelimString, szDelimString);
        }
    }

    if (pStringArray->ppszString[i])
        wcscat(pszDelimString, pStringArray->ppszString[i]);

    return pszDelimString;
}




PSTRINGS
ShortNameArray2LongNameArray(
    PSTRINGS pShortNames
)
/*++

Routine Description:

    Converts a PSTRINGS structure containing short names to a PSTRINGS struct containing the dns
    equivalents

Arguments:

    pStringArray - Input PSTRINGS structure

Return Value:

    PSTRINGS struct containing the dns equivalents of the input short name PSTRINGS struct.

--*/
{
    PSTRINGS    pLongNames;
    DWORD        i;

    if (!pShortNames) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }


    // Allocate LongNameArray
    pLongNames = AllocStringArray(pShortNames->nElements);
    if (!pLongNames)
        return NULL;


    for (i = 0 ; i < pShortNames->nElements ; ++i) {
        // GetDNSMachineName may fail, leaving the LongNameArray element empty.  This is okay.
        GetDNSMachineName(pShortNames->ppszString[i], &pLongNames->ppszString[i]);
    }
    pLongNames->nElements = pShortNames->nElements;

    return pLongNames;
}


PSTRINGS
DelimString2Array(
    PCWSTR    pszDelimString,
    WCHAR    wcDelim
)
/*++

Routine Description:

    Converts a delimited string to a PSTRINGS structure

Arguments:

    pszDelimString - Input, delimited strings

    wcDelim - The delimit character

Return Value:

    PSTRINGS structure

--*/
{
    PWSTR        psz, pszDelim;
    PSTRINGS     pStrings = NULL;
    ULONG        i, cChar, nStrings;

    // Get number of names
    for (psz = (PWSTR) pszDelimString, nStrings = 0 ; psz++ ; psz = wcschr(psz, wcDelim))
        ++nStrings;

    pStrings = AllocStringArray(nStrings);
    if (!pStrings)
        goto error;


    // Copy delimited string to array

    for (i = 0, psz = (PWSTR) pszDelimString ; i < nStrings && psz ; ++i, psz = pszDelim + 1) {

        pszDelim = wcschr(psz, wcDelim);

        if (pszDelim) {
            cChar = (ULONG) (pszDelim - psz);
            pStrings->ppszString[i] = (PWSTR) AllocSplMem((cChar + 1)*sizeof(WCHAR));
        } else {
            pStrings->ppszString[i] = (PWSTR) AllocSplMem((wcslen(psz) + 1)*sizeof(WCHAR));
        }

        if (!pStrings->ppszString[i]) {
            pStrings->nElements = i;
            FreeStringArray(pStrings);
            pStrings = NULL;
            goto error;
        }

        if (pszDelim) {
            wcsncpy(pStrings->ppszString[i], psz, cChar);
            *(pStrings->ppszString[i] + cChar) = L'\0';
        } else {
            wcscpy(pStrings->ppszString[i], psz);
        }
    }

    pStrings->nElements = nStrings;


error:

    return pStrings;

}


VOID
FreeStringArray(
    PSTRINGS pString
)
/*++

Routine Description:

    Frees a PSTRINGS structure

Arguments:

    pString - PSTRINGS structure to free

Return Value:

--*/
{
    DWORD    i;

    if (pString) {
        for (i = 0 ; i < pString->nElements ; ++i) {
            if (pString->ppszString[i])
                FreeSplMem(pString->ppszString[i]);
        }

        FreeSplMem(pString);
    }
}


PSTRINGS
AllocStringArray(
    DWORD    nStrings
)
/*++

Routine Description:

    Allocates a PSTRINGS structure

Arguments:

    nStrings - number of strings in the structure

Return Value:

    pointer to allocated PSTRINGS structure, if any

 --*/
{
    PSTRINGS    pStrings;

    // Allocate the STRINGS struct
    pStrings = (PSTRINGS) AllocSplMem(sizeof(STRINGS) + (nStrings - 1)*sizeof *pStrings->ppszString);

    return pStrings;
}

BOOL
SplDeleteFile(
    LPCTSTR lpFileName
)
/*++

Routine Name
    SplDeleteFile

Routine Description:
    Removes SFP protection and Deletes a file.
    If the file is protected and I fail to remove protection,
    the user will get warned with a system pop up.

Arguments:
    lpFileName - file full path requested

Return Value:
    DeleteFile's return value

--*/
{


    HANDLE RpcHandle = INVALID_HANDLE_VALUE;

    RpcHandle = SfcConnectToServer( NULL );

    if( RpcHandle != INVALID_HANDLE_VALUE ){

        SfcFileException( RpcHandle,
                          (PWSTR)lpFileName,
                          FILE_ACTION_REMOVED
                        );
        SfcClose(RpcHandle);
    }

    //
    // SfcFileException might fail with ERROR_FILE_NOT_FOUND because the file is
    // not in the protected file list.That's why I call DeleteFile anyway.
    //


    return DeleteFile( lpFileName );

}


BOOL
SplMoveFileEx(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName,
    DWORD dwFlags
)
/*++

Routine Name
    SplMoveFileEx

Routine Description:
    Removes SFP protection and move a file;
    If the file is protected and I fail to remove protection,
    the user will get warned with a system pop up.

Arguments:
    lpExistingFileName - pointer to the name of the existing file
    lpNewFileName      - pointer to the new name for the file
    dwFlags            - flag that specifies how to move file

Return Value:
    MoveFileEx's return value

--*/
{


    HANDLE RpcHandle = INVALID_HANDLE_VALUE;

    RpcHandle = SfcConnectToServer( NULL );

    if( RpcHandle != INVALID_HANDLE_VALUE ){

        SfcFileException( RpcHandle,
                          (PWSTR)lpExistingFileName,
                          FILE_ACTION_REMOVED
                        );

        SfcClose(RpcHandle);
    }

    //
    // SfcFileException might fail with ERROR_FILE_NOT_FOUND because the file is
    // not in the protected file list.That's why I call MoveFileEx anyway.
    //


    return MoveFileEx( lpExistingFileName, lpNewFileName, dwFlags );
}


BOOL
GetSpoolerPolicy(
    PWSTR   pszValue,
    PBYTE   pData,
    PDWORD  pcbData
)
{
    HKEY           hPrintPublishKey = NULL;
    DWORD          dwType, dwData, cbData;
    BOOL           bReturn = FALSE;

    // NOTE: This fcn currently only works if type is REG_DWORD.  Expand fcn as needed.

    cbData = sizeof(DWORD);

    // Open the registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szPrintPublishPolicy,
                     0,
                     KEY_READ,
                     &hPrintPublishKey) == ERROR_SUCCESS) {

        // Query for the policy bits
        if (RegQueryValueEx(hPrintPublishKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (LPBYTE) pData,
                            pcbData) == ERROR_SUCCESS)
            bReturn = TRUE;

        RegCloseKey(hPrintPublishKey);
    }

    return bReturn;
}


DWORD
GetDwPolicy(
    PWSTR pszName,
    DWORD dwDefault
)
{
    DWORD dwData, cbData = sizeof(DWORD);
    return GetSpoolerPolicy(pszName, (PBYTE) &dwData, &cbData) ? dwData : dwDefault;
}


DWORD
GetDefaultForKMPrintersBlockedPolicy (
)
{
    DWORD   Default = KM_PRINTERS_ARE_BLOCKED;
    BOOL    bIsNTWorkstation;
    NT_PRODUCT_TYPE  NtProductType;

    //
    // DEFAULT_KM_PRINTERS_ARE_BLOCKED is "blocked"
    //

    if ( RtlGetNtProductType(&NtProductType) ) {

        bIsNTWorkstation = NtProductType == NtProductWinNt;

        Default =   bIsNTWorkstation  ?
                    WKS_DEFAULT_KM_PRINTERS_ARE_BLOCKED :
                    SERVER_DEFAULT_KM_PRINTERS_ARE_BLOCKED;
    }

    return Default;
}

DWORD
GetServerInstallTimeOut(
)
{
    HKEY    hKey;
    DWORD   dwDummy;
    DWORD   dwTimeOut   = DEFAULT_MAX_TIMEOUT;
    DWORD   dwSize      = sizeof(dwTimeOut);
    LPCWSTR cszPrintKey = L"SYSTEM\\CurrentControlSet\\Control\\Print";
    LPCWSTR cszTimeOut  = L"ServerInstallTimeOut";

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszPrintKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        if(RegQueryValueEx( hKey, cszTimeOut, 0, &dwDummy, (LPBYTE)&dwTimeOut, &dwSize ) != ERROR_SUCCESS)
        {
            dwTimeOut = DEFAULT_MAX_TIMEOUT;
        }
        RegCloseKey( hKey );
    }
    return dwTimeOut;
}

DWORD
ReadOverlapped( HANDLE  hFile,
                LPVOID  lpBuffer,
                DWORD   nNumberOfBytesToRead,
                LPDWORD lpNumberOfBytesRead )
{
    DWORD dwLastError = ERROR_SUCCESS;
    if( hFile != INVALID_HANDLE_VALUE )
    {
        OVERLAPPED Ov;

        ZeroMemory( &Ov,sizeof(Ov));

        if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if( !ReadFile( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, &Ov ) &&
            GetLastError() != ERROR_IO_PENDING )
        {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if( WaitForSingleObject(Ov.hEvent, gdwServerInstallTimeOut) == WAIT_TIMEOUT )
        {
            CancelIo(hFile);
            WaitForSingleObject(Ov.hEvent, INFINITE);
        }

        if( !GetOverlappedResult(hFile, &Ov, lpNumberOfBytesRead, FALSE) )
            dwLastError = GetLastError();

Cleanup:
        if ( Ov.hEvent )
            CloseHandle(Ov.hEvent);
    }
    else
    {
        dwLastError = ERROR_INVALID_HANDLE;
        SetLastError( dwLastError );
    }

    return dwLastError;
}

BOOL
WriteOverlapped( HANDLE  hFile,
                 LPVOID  lpBuffer,
                 DWORD   nNumberOfBytesToRead,
                 LPDWORD lpNumberOfBytesRead )
{
    DWORD dwLastError = ERROR_SUCCESS;
    if( hFile != INVALID_HANDLE_VALUE )
    {
        OVERLAPPED Ov;

        ZeroMemory( &Ov,sizeof(Ov));

        if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if( !WriteFile( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, &Ov ) &&
            GetLastError() != ERROR_IO_PENDING )
        {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if( WaitForSingleObject(Ov.hEvent, gdwServerInstallTimeOut) == WAIT_TIMEOUT )
        {
            CancelIo(hFile);
            WaitForSingleObject(Ov.hEvent, INFINITE);
        }

        if( !GetOverlappedResult(hFile, &Ov, lpNumberOfBytesRead, FALSE) )
            dwLastError = GetLastError();

Cleanup:
        if ( Ov.hEvent )
            CloseHandle(Ov.hEvent);
    }
    else
    {
        dwLastError = ERROR_INVALID_HANDLE;
        SetLastError(dwLastError);
    }

    return (dwLastError == ERROR_SUCCESS);
}

ULONG_PTR
AlignToRegType(
    IN  ULONG_PTR   Data,
    IN  DWORD       RegType
    )
{
    //
    // Alings the value if Data to the boundary
    // dictated by the type of data read from registry.
    //

    ULONG_PTR Boundary;

    switch ( RegType )
    {
    //
    // Binary data could store any kind of data. The pointer is casted
    // to LPDWORD or LPBOOL so make sure it is native aligned.
    //
    case REG_BINARY:
        {
            Boundary = sizeof(ULONG_PTR);
        }
        break;
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_MULTI_SZ:
        {
            Boundary = sizeof(WCHAR);
        }
        break;
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
        {
            Boundary = sizeof(DWORD32);
        }
        break;
    case REG_QWORD:
        {
            Boundary = sizeof(DWORD64);
        }
        break;
    case REG_NONE:
    default:
        {
            Boundary = sizeof(ULONG_PTR);
        }
    }

    return (Data + (Boundary - 1))&~(Boundary - 1);
}

/*++

Routine Name

    BuildAclStruct

Routine Description:

    Helper function. Builds a vector of ACEs to allow all
    access to administrators and system. The caller has to
    free the pstrName fields

Arguments:
    cElements - number of elements in the array
    pExplAcc  - vector of aces

Return Value:

    WIN32 error code

--*/
DWORD
BuildAclStruct(
    IN     DWORD            cElements,
    IN OUT EXPLICIT_ACCESS *pExplAcc
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pExplAcc && cElements==2)
    {
        PSID                     pAdminSid   = NULL;
        PSID                     pSystemSid  = NULL;
        SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
        
        //
        // Get SID for the built in system account
        //
        dwError = AllocateAndInitializeSid(&NtAuthority,
                                           1,
                                           SECURITY_LOCAL_SYSTEM_RID,
                                           0, 0, 0, 0, 0, 0, 0,
                                           &pSystemSid) &&
                  AllocateAndInitializeSid(&NtAuthority, 
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           &pAdminSid) ? ERROR_SUCCESS : GetLastError();

        if (dwError == ERROR_SUCCESS)
        {
            //
            // Initialize the EXPLICIT_ACCESS with information about administrators
            //
            pExplAcc[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pExplAcc[0].Trustee.pMultipleTrustee         = NULL;
            pExplAcc[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            pExplAcc[0].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            pExplAcc[0].Trustee.ptstrName                = (PTSTR)pAdminSid;
            pExplAcc[0].grfAccessMode                    = GRANT_ACCESS;
            pExplAcc[0].grfAccessPermissions             = GENERIC_ALL;
            pExplAcc[0].grfInheritance                   = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

            //
            // Initialize the EXPLICIT_ACCESS with information about the system
            //
            pExplAcc[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pExplAcc[1].Trustee.pMultipleTrustee         = NULL;
            pExplAcc[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            pExplAcc[1].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            pExplAcc[1].Trustee.ptstrName                = (PTSTR)pSystemSid;
            pExplAcc[1].grfAccessMode                    = GRANT_ACCESS;
            pExplAcc[1].grfAccessPermissions             = GENERIC_ALL;
            pExplAcc[1].grfInheritance                   = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
        }
        else
        {
            //
            // Note that we never end up here and have pAdminSid not NULL. However, for the
            // sake of consisentcy and extensibility we attempt to clean up both strcutures
            //
            if (pSystemSid) FreeSid(pSystemSid);
            if (pAdminSid)  FreeSid(pAdminSid);
        }
    }

    return dwError;
}

/*++

Routine Name

    CreateProtectedDirectory

Routine Description:

    Creates a directory with full access only to admins and to
    the system. Contained objects inherit these permissions.

Arguments:

    pszDir - directory name

Return Value:

    WIN32 error code

--*/
DWORD
CreateProtectedDirectory(
    IN LPCWSTR pszDir
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDir)
    {
        SECURITY_DESCRIPTOR  SecDesc;
        SECURITY_ATTRIBUTES  SecAttr;
        PACL                 pDacl                   = NULL;
        EXPLICIT_ACCESS      ExplicitAccessVector[2] = {0};

        if ((dwError = InitializeSecurityDescriptor(&SecDesc,
                                                    SECURITY_DESCRIPTOR_REVISION) ?
                                                    ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
            //
            // Initialize the ExplicitAccessVector
            //
            (dwError = BuildAclStruct(COUNTOF(ExplicitAccessVector),
                                      ExplicitAccessVector)) == ERROR_SUCCESS &&
            //
            // Initialize the DACL
            //
            (dwError = SetEntriesInAcl(COUNTOF(ExplicitAccessVector),
                                       ExplicitAccessVector,
                                       NULL,
                                       &pDacl)) == ERROR_SUCCESS &&
            //
            // Set the DACL in the security descriptor
            //
            (dwError = SetSecurityDescriptorDacl(&SecDesc,
                                                 TRUE,
                                                 pDacl,
                                                 FALSE) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
            //
            // Check if the security descriptor is valid. Function does not set last error
            //
            (dwError = IsValidSecurityDescriptor(&SecDesc) ?
                       ERROR_SUCCESS : ERROR_INVALID_SECURITY_DESCR) == ERROR_SUCCESS)
        {
            //
            // Put the security descriptor in the security attribute
            //
            SecAttr.bInheritHandle       = FALSE;
            SecAttr.nLength              = sizeof(SecAttr);
            SecAttr.lpSecurityDescriptor = &SecDesc;

            dwError = CreateDirectory(pszDir, &SecAttr) ? ERROR_SUCCESS : GetLastError();
        }

        //
        // The ptstrName here points to a sid obtained via AllocAndInitializeSid
        //
        if (ExplicitAccessVector[0].Trustee.ptstrName)
        {
            FreeSid(ExplicitAccessVector[0].Trustee.ptstrName);
        }

        //
        // The ptstrName here points to a sid obtained via AllocAndInitializeSid
        //
        if (ExplicitAccessVector[1].Trustee.ptstrName)
        {
            FreeSid((PSID)ExplicitAccessVector[1].Trustee.ptstrName);
        }
    }

    DBGMSG(DBG_CLUSTER, ("CreateProtectedDirectory returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyFileToDirectory

Routine Description:

    Copies a file to a directory. File is fully qualified.
    The function takes a pszDestDir and up to 3 directories.
    It will create the dir: pszRoot\pszDir1\pszDir2\pszDir3
    and copy the file over there. This is a helper function
    for installing drivers on clusters. The directory strcuture
    is created with special privileges. Only the system and
    administrators have access to it.

Arguments:
    pssDestDirt     - destination directory
    pszDir1         - optional
    pszDir2         - optional
    pszdir3         - optional
    pszFullFileName - qualified file path

Return Value:

    WIN32 error code

--*/
DWORD
CopyFileToDirectory(
    IN LPCWSTR pszFullFileName,
    IN LPCWSTR pszDestDir,
    IN LPCWSTR pszDir1,
    IN LPCWSTR pszDir2,
    IN LPCWSTR pszDir3
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;
    LPWSTR pszFile = NULL;

    //
    // Our pszfullFileName must contain at least one "\"
    //
    if (pszFullFileName &&
        pszDestDir      &&
        (pszFile = wcsrchr(pszFullFileName, L'\\')))
    {
        LPCWSTR ppszArray[] = {pszDir1, pszDir2, pszDir3};
        WCHAR   szNewPath[MAX_PATH];
        DWORD   uIndex;

        DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory\n\tpszFullFile "TSTR"\n\tpszDest "TSTR"\n\tDir1 "TSTR"\n\tDir2 "TSTR"\n\tDir3 "TSTR"\n",
                             pszFullFileName, pszDestDir, pszDir1, pszDir2, pszDir3));

        //
        // Prepare buffer for the loop (initialize to pszDestDir)
        // Create destination root directory, if not existing
        //
        if ((dwError = StrNCatBuff(szNewPath,
                                   MAX_PATH,
                                   pszDestDir,
                                   NULL)) == ERROR_SUCCESS &&
            (DirectoryExists((LPWSTR)pszDestDir) ||
            (dwError = CreateProtectedDirectory(pszDestDir)) == ERROR_SUCCESS))
        {
            for (uIndex = 0;
                 uIndex < COUNTOF(ppszArray) && dwError == ERROR_SUCCESS;
                 uIndex++)
            {
                //
                // Append the first directory to the path and
                // Create the directory if not existing
                //
                if (ppszArray[uIndex] &&
                    (dwError = StrNCatBuff(szNewPath,
                                           MAX_PATH,
                                           szNewPath,
                                           L"\\",
                                           ppszArray[uIndex],
                                           NULL)) == ERROR_SUCCESS &&
                    !DirectoryExists(szNewPath) &&
                    !CreateDirectoryWithoutImpersonatingUser(szNewPath))
                {
                    dwError = GetLastError();
                }
            }

            //
            // Create the destination file full name and copy the file
            //
            if (dwError == ERROR_SUCCESS &&
                (dwError = StrNCatBuff(szNewPath,
                                       MAX_PATH,
                                       szNewPath,
                                       pszFile,
                                       NULL)) == ERROR_SUCCESS)
            {
                 dwError = CopyFile(pszFullFileName, szNewPath, FALSE) ? ERROR_SUCCESS : GetLastError();
            }

            DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory szNewPath "TSTR"\n", szNewPath));
        }
    }

    DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    PropagateMonitorToCluster

Routine Description:

    For a cluster we keep the following printing resources in the
    cluster data base: drivers, printers, ports, procs. We can also
    have cluster aware port monitors. When the spooler initializes
    those objects, it reads the data from the cluster data base.
    When we write those objects we pass a handle to a key to some
    spooler functions. (Ex WriteDriverIni) The handle is either to the
    local registry or to the cluster database. This procedure is not safe
    with language monitors. LMs keep data in the registry so you need
    to supply a handle to a key in the reg. They don't work with clusters.
    This function will do this:
    1) write an association key in the cluster data base. We will have
    information like (lm name, dll name) (see below where we store this)
    2) copy the lm dll to the cluster disk.
    When we fail over we have all it take to install the lm on the local
    node if needed.

    Theoretically this function works for both language and port monitors.
    But it is useless when applied to port monitors.

Arguments:
    pszName      - monitor name
    pszDllName   - dll name of the monitor
    pszEnvName   - envionment string Ex "Windows NT x86"
    pszEnvDir    - the path on disk for the environement Ex w32x86
    pIniSpooler  - cluster spooler

Return Value:

    WIN32 error code

--*/
DWORD
PropagateMonitorToCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszDLLName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    HKEY  hKeyEnvironments;
    HKEY  hKeyCurrentEnv;
    HKEY  hKeyMonitors;
    HKEY  hKeyCurrentMon;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_PRINT && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if (pszName && pszDLLName && pszEnvName && pszEnvDir)
    {
        //
        // Check if we added an entry for this lang monitor already
        // The cluster database for the spooler resource looks like:
        //
        // Parameters
        // |
        // +- Environments
        // |  |
        // |  +- Windows NT x86
        //       |
        //       +- OtherMonitors
        //          |
        //          +- Foo
        //          |  |
        //          |  +- Driver = Foo.dll
        //          |
        //          +- Bar
        //             |
        //             +- Driver = Bar.dll
        //
        if ((dwError = SplRegCreateKey(pIniSpooler->hckRoot,
                                       ipszClusterDatabaseEnvironments,
                                       0,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &hKeyEnvironments,
                                       NULL,
                                       pIniSpooler)) == ERROR_SUCCESS)
        {
            if ((dwError = SplRegCreateKey(hKeyEnvironments,
                                           pszEnvName,
                                           0,
                                           KEY_READ | KEY_WRITE,
                                           NULL,
                                           &hKeyCurrentEnv,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS)
            {
                if ((dwError = SplRegCreateKey(hKeyCurrentEnv,
                                               szClusterNonAwareMonitors,
                                               0,
                                               KEY_READ | KEY_WRITE,
                                               NULL,
                                               &hKeyMonitors,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS)
                {
                    if ((dwError = SplRegCreateKey(hKeyMonitors,
                                                   pszName,
                                                   0,
                                                   KEY_READ | KEY_WRITE,
                                                   NULL,
                                                   &hKeyCurrentMon,
                                                   NULL,
                                                   pIniSpooler)) == ERROR_SUCCESS)
                    {
                        DWORD cbNeeded = 0;

                        //
                        // Check if this driver already exists in the database
                        //
                        if ((dwError=SplRegQueryValue(hKeyCurrentMon,
                                                      L"Driver",
                                                      NULL,
                                                      NULL,
                                                      &cbNeeded,
                                                      pIniSpooler))==ERROR_MORE_DATA)
                        {
                            DBGMSG(DBG_CLUSTER, ("CopyMonitorToClusterDisks "TSTR" already exists in cluster DB\n", pszName));
                        }
                        else
                        {
                            if (RegSetString(hKeyCurrentMon,
                                             (LPWSTR)L"Driver",
                                             (LPWSTR)pszDLLName,
                                             &dwError,
                                             pIniSpooler))
                            {
                                //
                                // Copy monitor file to cluster disk
                                //
                                WCHAR szMonitor[MAX_PATH];
                                WCHAR szDestDir[MAX_PATH];

                                if (GetSystemDirectory(szMonitor, COUNTOF(szMonitor)))
                                {
                                    if ((dwError = StrNCatBuff(szMonitor,
                                                               COUNTOF(szMonitor),
                                                               szMonitor,
                                                               L"\\",
                                                               pszDLLName,
                                                               NULL)) == ERROR_SUCCESS &&
                                        (dwError = StrNCatBuff(szDestDir,
                                                               COUNTOF(szDestDir),
                                                               pIniSpooler->pszClusResDriveLetter,
                                                               L"\\",
                                                               szClusterDriverRoot,
                                                               NULL)) == ERROR_SUCCESS)
                                    {
                                        dwError = CopyFileToDirectory(szMonitor, szDestDir, pszEnvDir, NULL, NULL);
                                    }
                                }
                                else
                                {
                                    dwError = GetLastError();
                                }
                            }

                            //
                            // If anything failed, delete the entry from the database
                            //
                            if (dwError != ERROR_SUCCESS)
                            {
                                dwError = SplRegDeleteKey(hKeyMonitors, pszName, pIniSpooler);

                                DBGMSG(DBG_CLUSTER, ("CopyMonitorToClusterDisks Error %u cleaned up cluster DB\n", dwError));
                            }
                        }

                        SplRegCloseKey(hKeyCurrentMon, pIniSpooler);
                    }

                    SplRegCloseKey(hKeyMonitors, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }

            SplRegCloseKey(hKeyEnvironments, pIniSpooler);
        }
    }

    DBGMSG(DBG_CLUSTER, ("PropagateMonitorToCluster returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    InstallMonitorFromCluster

Routine Description:

    For a cluster we keep the following printing resources in the
    cluster data base: drivers, printers, ports, procs. We can also
    have cluster aware port monitors. When the spooler initializes
    those objects, it reads the data from the cluster data base.
    When we write those objects we pass a handle to a key to some
    spooler functions. (Ex WriteDriverIni) The handle is either to the
    local registry or to the cluster database. This procedure is not safe
    with language monitors. LMs keep data in the registry so you need
    to supply a handle to a key in the reg. They don't work with clusters.
    This function will do this:
    1) read an association key in the cluster data base. We will have
    information like (lm name, dll name) (see below where we store this)
    2) copy the lm dll from the cluster disk to the local disk.
    3) install the monitor with the local spooler

    Theoretically this function works for both language and port monitors.
    But it is useless when applied to port monitors.

Arguments:
    pszName      - monitor name
    pszEnvName   - envionment string Ex "Windows NT x86"
    pszEnvDir    - the path on disk for the environement Ex w32x86
    pIniSpooler  - cluster spooler

Return Value:

    WIN32 error code

--*/
DWORD
InstallMonitorFromCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    HKEY hKeyParent;
    HKEY hKeyMon;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if (pszName && pszEnvName && pszEnvDir)
    {
        HKEY hKeyEnvironments;
        HKEY hKeyCurrentEnv;
        HKEY hKeyMonitors;
        HKEY hKeyCurrentMon;

        //
        // Check if we added an entry for this lang monitor already
        // The cluster database for the spooler resource looks like:
        //
        // Parameters
        // |
        // +- Environments
        // |  |
        // |  +- Windows NT x86
        //       |
        //       +- OtherMonitors
        //          |
        //          +- Foo
        //          |  |
        //          |  +- Driver = Foo.dll
        //          |
        //          +- Bar
        //             |
        //             +- Driver = Bar.dll
        //
        if ((dwError = SplRegOpenKey(pIniSpooler->hckRoot,
                                     ipszClusterDatabaseEnvironments,
                                     KEY_READ,
                                     &hKeyEnvironments,
                                     pIniSpooler)) == ERROR_SUCCESS)
        {
            if ((dwError = SplRegOpenKey(hKeyEnvironments,
                                         pszEnvName,
                                         KEY_READ,
                                         &hKeyCurrentEnv,
                                         pIniSpooler)) == ERROR_SUCCESS)
            {
                if ((dwError = SplRegOpenKey(hKeyCurrentEnv,
                                             szClusterNonAwareMonitors,
                                             KEY_READ,
                                             &hKeyMonitors,
                                             pIniSpooler)) == ERROR_SUCCESS)
                {
                    if ((dwError = SplRegOpenKey(hKeyMonitors,
                                                 pszName,
                                                 KEY_READ,
                                                 &hKeyCurrentMon,
                                                 pIniSpooler)) == ERROR_SUCCESS)
                    {
                        LPWSTR pszDLLName = NULL;
                        DWORD  cchDLLName = 0;

                        if (RegGetString(hKeyCurrentMon,
                                         (LPWSTR)L"Driver",
                                         &pszDLLName,
                                         &cchDLLName,
                                         &dwError,
                                         TRUE,
                                         pIniSpooler))
                        {
                            //
                            // We found the monitor entry in the cluster DB
                            //
                            WCHAR szSource[MAX_PATH];
                            WCHAR szDest[MAX_PATH];

                            if (GetSystemDirectory(szDest, COUNTOF(szDest)))
                            {
                                if ((dwError = StrNCatBuff(szDest,
                                                           COUNTOF(szDest),
                                                           szDest,
                                                           L"\\",
                                                           pszDLLName,
                                                           NULL)) == ERROR_SUCCESS &&
                                    (dwError = StrNCatBuff(szSource,
                                                           COUNTOF(szSource),
                                                           pIniSpooler->pszClusResDriveLetter,
                                                           L"\\",
                                                           szClusterDriverRoot,
                                                           L"\\",
                                                           pszEnvDir,
                                                           L"\\",
                                                           pszDLLName,
                                                           NULL)) == ERROR_SUCCESS)
                                {
                                    //
                                    // Copy file from K:\PrinterDrivers\W32x86\foo.dll to
                                    // WINDIR\system32\foo.dll
                                    //
                                    if (CopyFile(szSource, szDest, FALSE))
                                    {
                                        MONITOR_INFO_2 Monitor;

                                        Monitor.pDLLName     = pszDLLName;
                                        Monitor.pName        = (LPWSTR)pszName;
                                        Monitor.pEnvironment = (LPWSTR)pszEnvName;

                                        DBGMSG(DBG_CLUSTER, ("InstallMonitorFromCluster "TSTR" copied\n", pszDLLName));

                                        //
                                        // Call AddMonitor to the local spooler
                                        //
                                        if (!SplAddMonitor(NULL, 2, (LPBYTE)&Monitor, pLocalIniSpooler))
                                        {
                                            dwError = GetLastError();
                                        }
                                    }
                                    else
                                    {
                                        dwError = GetLastError();
                                    }
                                }
                            }
                            else
                            {
                                dwError = GetLastError();
                            }
                        }

                        SplRegCloseKey(hKeyCurrentMon, pIniSpooler);
                    }

                    SplRegCloseKey(hKeyMonitors, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }

            SplRegCloseKey(hKeyEnvironments, pIniSpooler);
        }
    }

    DBGMSG(DBG_CLUSTER, ("InstallMonitorFromCluster returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyNewerOrOlderFiles

Routine Description:

    Copies all newer or older files from the source directory to the dest dir.
    If you supply a bool function that takes 2 parameters, it will apply that
    function for each copied file. func(NULL, file.) This is useful when I have
    to caopy over ICM profiles. Then I can resuse this function and have it
    install those profiles as it copies them.

Arguments:

    pszSourceDir - source directory string
    pszDestDir   - destination directory string
    pfn          - optional functin to be applied on each copied file

Return Value:

    WIN32 error code

--*/
DWORD
CopyNewerOrOlderFiles(
    IN LPCWSTR pszSourceDir,
    IN LPCWSTR pszDestDir,
    IN BOOL    (WINAPI *pfn)(LPWSTR, LPWSTR)
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszSourceDir && pszDestDir)
    {
        WCHAR szSearchPath[MAX_PATH];

        //
        // Build the search path. We look for all files
        //
        if ((dwError = StrNCatBuff(szSearchPath,
                                   COUNTOF(szSearchPath),
                                   pszSourceDir,
                                   L"\\*",
                                   NULL)) == ERROR_SUCCESS)
        {
            WIN32_FIND_DATA SourceFindData;
            HANDLE          hSourceFind;

            //
            // Find first file that meets the criteria
            //
            if ((hSourceFind = FindFirstFile(szSearchPath, &SourceFindData)) != INVALID_HANDLE_VALUE)
            {
                do
                {
                    WCHAR szMasterPath[MAX_PATH];

                    //
                    // Search for the rest of the files. We are interested in files that are not directories
                    //
                    if (!(SourceFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (dwError = StrNCatBuff(szMasterPath,
                                               COUNTOF(szMasterPath),
                                               pszDestDir,
                                               L"\\",
                                               SourceFindData.cFileName,
                                               NULL)) == ERROR_SUCCESS)
                    {
                        WIN32_FIND_DATA MasterFindData;
                        HANDLE          hMasterFind;
                        BOOL            bCopyFile = TRUE;
                        WCHAR           szFile[MAX_PATH];

                        //
                        // Check if the file found in source dir exists in the dest dir
                        //
                        if ((hMasterFind = FindFirstFile(szMasterPath, &MasterFindData)) != INVALID_HANDLE_VALUE)
                        {
                            //
                            // Do not copy file if source and dest have same time stamp
                            //
                            if (!CompareFileTime(&SourceFindData.ftLastWriteTime, &MasterFindData.ftLastWriteTime))
                            {
                                bCopyFile = FALSE;
                            }

                            FindClose(hMasterFind);
                        }

                        //
                        // File either not found in dest dir, or it has a different timp stamp
                        //
                        if (bCopyFile &&
                            (dwError = StrNCatBuff(szFile,
                                                   COUNTOF(szFile),
                                                   pszSourceDir,
                                                   L"\\",
                                                   SourceFindData.cFileName,
                                                   NULL)) == ERROR_SUCCESS &&
                            (dwError = CopyFile(szFile,
                                                szMasterPath,
                                                FALSE) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
                            pfn)
                        {
                            dwError = (*pfn)(NULL, szFile) ? ERROR_SUCCESS : GetLastError();
                        }
                    }

                } while (dwError == ERROR_SUCCESS && FindNextFile(hSourceFind, &SourceFindData));

                FindClose(hSourceFind);
            }
            else if ((dwError = GetLastError()) == ERROR_PATH_NOT_FOUND || dwError == ERROR_FILE_NOT_FOUND)
            {
                //
                // No directory or files, success
                //
                dwError = ERROR_SUCCESS;
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("CopyNewerOrOlderFiles returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyICMFromClusterDiskToLocalDisk

Routine Description:

    Copies all newer or older files from the source directory to the destination
    directory. The source directory is the ICM directory on the cluster disk
    and the destination is the ICM directory on the local machine for the
    cluster spooler. This function will also install the icm profiles with the
    local machine/

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CopyICMFromClusterDiskToLocalDisk(
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szSource[MAX_PATH];
    WCHAR szDest[MAX_PATH];

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = StrNCatBuff(szDest,
                               COUNTOF(szDest),
                               pIniSpooler->pDir,
                               L"\\Drivers\\Color",
                               NULL)) == ERROR_SUCCESS &&
        (dwError = StrNCatBuff(szSource,
                               COUNTOF(szSource),
                               pIniSpooler->pszClusResDriveLetter,
                               L"\\",
                               szClusterDriverRoot,
                               L"\\",
                               L"Color",
                               NULL)) == ERROR_SUCCESS)
    {
        HMODULE hLib;
        typedef BOOL (WINAPI *PFN)(LPWSTR, LPWSTR);
        PFN pfn;

        //
        // Make sure the directory on the local disk exists. We will copy files
        // from K:\Printerdrivers\Color to
        // WINDIR\system32\spool\drivers\clus-spl-guid\drivers\color
        //
        CreateCompleteDirectory(szDest);

        if ((hLib = LoadLibrary(L"mscms.dll")) &&
            (pfn = (PFN)GetProcAddress(hLib, "InstallColorProfileW")))
        {
            dwError = CopyNewerOrOlderFiles(szSource, szDest, pfn);
        }
        else
        {
            dwError = GetLastError();
        }

        if (hLib)
        {
            FreeLibrary(hLib);
        }

        DBGMSG(DBG_CLUSTER, ("CopyICMFromClusterDiskToLocalDisk "TSTR" "TSTR" Error %u\n", szSource, szDest, dwError));
    }

    return dwError;
}

/*++

Routine Name

    CopyICMFromLocalDiskToClusterDisk

Routine Description:

    Copies all newer or older files from the source directory to the destination
    directory. The source directory is the ICM directory on the local machine for
    the cluster spooler. The destination is the ICM directory on the cluster disk

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CopyICMFromLocalDiskToClusterDisk(
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szSource[MAX_PATH];
    WCHAR szDest[MAX_PATH];

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = StrNCatBuff(szSource,
                               COUNTOF(szSource),
                               pIniSpooler->pDir,
                               L"\\Drivers\\Color",
                               NULL)) == ERROR_SUCCESS &&
        (dwError = StrNCatBuff(szDest,
                               COUNTOF(szDest),
                               pIniSpooler->pszClusResDriveLetter,
                               L"\\",
                               szClusterDriverRoot,
                               L"\\",
                               L"Color",
                               NULL)) == ERROR_SUCCESS &&
        //
        // Make sure the destination on the cluster disk exists. We need to create
        // it with special access rights. (only admins and system can read/write)
        //
        ((dwError = CreateProtectedDirectory(szDest)) == ERROR_SUCCESS ||
         dwError == ERROR_ALREADY_EXISTS))
    {
        dwError = CopyNewerOrOlderFiles(szSource, szDest, NULL);

        DBGMSG(DBG_CLUSTER, ("CopyICMFromLocalDiskToClusterDisk "TSTR" "TSTR" Error %u\n", szSource, szDest, dwError));
    }

    return dwError;
}

/*++

Routine Name

    CreateClusterSpoolerEnvironmentsStructure

Routine Description:

    A pIniSpooler needs a list of all possible pIniEnvironemnts. For the local
    spooler the setup creates the necessary environments keys in the registry under
    HKLM\System\CCS\Control\Print\Environments. We need to propagate the same
    structure for each cluster spooler in the cluster data base.

    Relies on the fact that pLocalIniSpooler is initialized fisrt (among all
    pinispoolers)

    This function builds the following strucutre in the cluster database

    Parameters
    |
    +- Environments
    |  |
    |  +- Windows NT x86
    |  |     (Directory = w32x86)
    |  |
    |  +- Windows 4.0
    |  |     (Directory = win40)
    |  |

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CreateClusterSpoolerEnvironmentsStructure(
    IN PINISPOOLER pIniSpooler
    )
{
    HKEY  hEnvironmentsKey;
    DWORD dwError;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = SplRegCreateKey(pIniSpooler->hckRoot,
                                   pIniSpooler->pszRegistryEnvironments,
                                   0,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hEnvironmentsKey,
                                   NULL,
                                   pIniSpooler)) == ERROR_SUCCESS)
    {
        PINIENVIRONMENT pIniEnvironment;

        //
        // Loop through the environments of the local spooler
        //
        for (pIniEnvironment = pLocalIniSpooler->pIniEnvironment;
             pIniEnvironment && dwError == ERROR_SUCCESS;
             pIniEnvironment = pIniEnvironment->pNext)
        {
            HKEY hKeyCurrentEnv;

            if ((dwError = SplRegCreateKey(hEnvironmentsKey,
                                           pIniEnvironment->pName,
                                           0,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hKeyCurrentEnv,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS)
            {
                HKEY hKeyPrtProc;

                //
                // Set the value Directory (ex. = W32X86) and create
                // the print processor key
                //
                if (RegSetString(hKeyCurrentEnv,
                                 szDirectory,
                                 pIniEnvironment->pDirectory,
                                 &dwError,
                                 pIniSpooler) &&
                    (dwError = SplRegCreateKey(hKeyCurrentEnv,
                                               szPrintProcKey,
                                               0,
                                               KEY_ALL_ACCESS,
                                               NULL,
                                               &hKeyPrtProc,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS)
                {
                    SplRegCloseKey(hKeyPrtProc, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }
        }

        SplRegCloseKey(hEnvironmentsKey, pIniSpooler);
    }

    DBGMSG(DBG_CLUSTER, ("CreateClusterSpoolerEnvironmentsStructure returns dwError %u\n\n", dwError));

    return dwError;
}

/*++

Routine Name

    AddLocalDriverToClusterSpooler

Routine Description:

    Adds a driver that exists on the local inispooler to the cluster spooler.
    It will also add all versions of that driver. We use this function in the
    upgrade scenario. For a certain printer, we need to propage the driver
    (and all the versions of that driver) to the cluster data base and cluster
    disk.

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
AddLocalDriverToClusterSpooler(
    IN LPCWSTR     pszDriver,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD           dwError = ERROR_SUCCESS;
    PINIENVIRONMENT pIniEnv;
    PINIVERSION     pIniVer;

    SplInSem();

    //
    // Traverse all environments and versions
    //
    for (pIniEnv=pLocalIniSpooler->pIniEnvironment; pIniEnv; pIniEnv=pIniEnv->pNext)
    {
        for (pIniVer=pIniEnv->pIniVersion; pIniVer; pIniVer=pIniVer->pNext)
        {
            PINIDRIVER pIniDriver = (PINIDRIVER)FindIniKey((PINIENTRY)pIniVer->pIniDriver, (LPWSTR)pszDriver);

            if (pIniDriver)
            {
                DRIVER_INFO_6 DriverInfo        = {0};
                WCHAR         szDriverFile[MAX_PATH];
                WCHAR         szDataFile[MAX_PATH];
                WCHAR         szConfigFile[MAX_PATH];
                WCHAR         szHelpFile[MAX_PATH];
                WCHAR         szPrefix[MAX_PATH];
                LPWSTR        pszzDependentFiles = NULL;

                //
                // Get fully qualified driver file paths. We will call add printer
                // driver without using the scratch directory
                //
                if ((dwError = StrNCatBuff(szDriverFile,
                                           COUNTOF(szDriverFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,   L"\\",
                                           pIniEnv->pDirectory,  L"\\",
                                           pIniVer->szDirectory, L"\\",
                                           pIniDriver->pDriverFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szDataFile,
                                           COUNTOF(szDataFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,    L"\\",
                                           pIniEnv->pDirectory,   L"\\",
                                           pIniVer->szDirectory,  L"\\",
                                           pIniDriver->pDataFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szConfigFile,
                                           COUNTOF(szConfigFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,      L"\\",
                                           pIniEnv->pDirectory,     L"\\",
                                           pIniVer->szDirectory,    L"\\",
                                           pIniDriver->pConfigFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szHelpFile,
                                           COUNTOF(szHelpFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,    L"\\",
                                           pIniEnv->pDirectory,   L"\\",
                                           pIniVer->szDirectory,  L"\\",
                                           pIniDriver->pHelpFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szPrefix,
                                           COUNTOF(szPrefix),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,   L"\\",
                                           pIniEnv->pDirectory,  L"\\",
                                           pIniVer->szDirectory, L"\\",
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrCatPrefixMsz(szPrefix,
                                               pIniDriver->pDependentFiles,
                                               &pszzDependentFiles)) == ERROR_SUCCESS)
                {
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szDriverFile "TSTR"\n", szDriverFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szDataFile   "TSTR"\n", szDataFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szConfigFile "TSTR"\n", szConfigFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szHelpFile   "TSTR"\n", szHelpFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szPrefix     "TSTR"\n", szPrefix));

                    DriverInfo.pDriverPath        = szDriverFile;
                    DriverInfo.pName              = pIniDriver->pName;
                    DriverInfo.pEnvironment       = pIniEnv->pName;
                    DriverInfo.pDataFile          = szDataFile;
                    DriverInfo.pConfigFile        = szConfigFile;
                    DriverInfo.cVersion           = pIniDriver->cVersion;
                    DriverInfo.pHelpFile          = szHelpFile;
                    DriverInfo.pMonitorName       = pIniDriver->pMonitorName;
                    DriverInfo.pDefaultDataType   = pIniDriver->pDefaultDataType;
                    DriverInfo.pDependentFiles    = pszzDependentFiles;
                    DriverInfo.pszzPreviousNames  = pIniDriver->pszzPreviousNames;
                    DriverInfo.pszMfgName         = pIniDriver->pszMfgName;
                    DriverInfo.pszOEMUrl          = pIniDriver->pszOEMUrl;
                    DriverInfo.pszHardwareID      = pIniDriver->pszHardwareID;
                    DriverInfo.pszProvider        = pIniDriver->pszProvider;
                    DriverInfo.dwlDriverVersion   = pIniDriver->dwlDriverVersion;
                    DriverInfo.ftDriverDate       = pIniDriver->ftDriverDate;

                    LeaveSplSem();

                    if (!SplAddPrinterDriverEx(NULL,
                                               6,
                                               (LPBYTE)&DriverInfo,
                                               APD_COPY_NEW_FILES,
                                               pIniSpooler,
                                               FALSE,
                                               DO_NOT_IMPERSONATE_USER))
                    {
                        dwError = GetLastError();
                    }

                    EnterSplSem();
                }

                FreeSplMem(pszzDependentFiles);

                DBGMSG(DBG_CLUSTER, ("AddLocalDrv Env "TSTR" Ver "TSTR" Name "TSTR" Error %u\n",
                                     pIniEnv->pName, pIniVer->pName, pszDriver, dwError));
            }
        }
    }

    return dwError;
}

/*++

Routine Name

    StrCatPerfixMsz

Routine Description:

    Take a prefix which is a string Ex "C:\windows\" and a multi sz Ex: "a0b00"
    It will create: c:\windows\a0c:\windows\b00
    The prefix must have a trailing "\".

Arguments:

    pszPrefix - string to prefix all the strings in the msz
    pszzFiles - msz of files
    ppszzFullPathFiles - out param

Return Value:

    WIN32 error code

--*/
DWORD
StrCatPrefixMsz(
    IN  LPCWSTR  pszPrefix,
    IN  LPWSTR   pszzFiles,
    OUT LPWSTR  *ppszzFullPathFiles
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrefix && ppszzFullPathFiles)
    {
        *ppszzFullPathFiles = NULL;

        if (pszzFiles)
        {
            WCHAR  szNewPath[MAX_PATH] = {0};
            LPWSTR psz;
            LPWSTR pszReturn;
            LPWSTR pszTemp;
            DWORD  cbNeeded   = 0;
            DWORD  dwPrifxLen = wcslen(pszPrefix);

            //
            // We count the number of character of the string
            // that we need to allocate
            //
            for (psz = pszzFiles; psz && *psz;)
            {
                DWORD dwLen = wcslen(psz);

                cbNeeded += dwPrifxLen + dwLen + 1;

                psz += dwLen + 1;
            }

            //
            // Final \0 of the multi sz
            //
            cbNeeded++;

            //
            // Convert to number of bytes
            //
            cbNeeded *= sizeof(WCHAR);

            if (pszReturn = AllocSplMem(cbNeeded))
            {
                for (psz = pszzFiles, pszTemp = pszReturn; psz && *psz; )
                {
                    wcscpy(pszTemp, pszPrefix);
                    wcscat(pszTemp, psz);

                    pszTemp += wcslen(pszTemp);

                    *pszTemp = L'\0';

                    pszTemp++;

                    psz += wcslen(psz) + 1;
                }

                pszTemp = L'\0';

                //
                // Set out param
                //
                *ppszzFullPathFiles = pszReturn;

                dwError = ERROR_SUCCESS;
            }
            else
            {
                dwError = GetLastError();
            }
        }
        else
        {
            //
            // NULL input multi sz, nothing to do
            //
            dwError = ERROR_SUCCESS;
        }
    }

    DBGMSG(DBG_CLUSTER, ("StrCatPerfixMsz returns %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ClusterSplReadUpgradeKey

Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may
    not be actie at all. Thus the resdll writes a value in the local
    registry. The vaue name is the GUID for the spooler resource, the
    value is DWORD 1. When the cluster spooler resource fails over on this
    machine it (i.e. now) it queries for that value to know if it needs
    to preform post upgrade operations, like upgrading the printer drivers.

Arguments:

    pszResource - string respresenation of GUID for the cluster resource
    pdwVlaue    - will contain the value in the registry for the GUID

Return Value:

    WIN32 error code

--*/
DWORD
ClusterSplReadUpgradeKey(
    IN  LPCWSTR pszResourceID,
    OUT LPDWORD pdwValue
    )
{
    DWORD dwError   = ERROR_INVALID_PARAMETER;
    HKEY  hkRoot    = NULL;
    HKEY  hkUpgrade = NULL;

    if (pszResourceID && pdwValue)
    {
        *pdwValue = 0;

        if ((dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                    0,
                                    KEY_READ,
                                    &hkRoot)) == ERROR_SUCCESS &&
            (dwError = RegOpenKeyEx(hkRoot,
                                    SPLREG_CLUSTER_UPGRADE_KEY,
                                    0,
                                    KEY_READ,
                                    &hkUpgrade)) == ERROR_SUCCESS)
        {
            DWORD cbNeeded = sizeof(DWORD);

            dwError = RegQueryValueEx(hkUpgrade, pszResourceID, NULL, NULL, (LPBYTE)pdwValue, &cbNeeded);
        }

        if (hkUpgrade) RegCloseKey(hkUpgrade);
        if (hkRoot)    RegCloseKey(hkRoot);

        //
        // Regardless of what happened, return success
        //
        dwError = ERROR_SUCCESS;
    }

    return dwError;

}

/*++

Routine Name

    ClusterSplReadUpgradeKey

Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may
    not be actie at all. Thus the resdll writes a value in the local
    registry. The vaue name is the GUID for the spooler resource, the
    value is DWORD 1. When the cluster spooler resource fails over on this
    machine it (i.e. now) it queries for that value to know if it needs
    to preform post upgrade operations, like upgrading the printer drivers.
    After the spooler preforms upgrade taks, it will delete the value
    corresponding to its GUID. Also if that value is the only one under the
    SPLREG_CLUSTER_UPGRADE_KEY key, it will delete that key.

Arguments:

    pszResource - string respresenation of GUID for the cluster resource

Return Value:

    WIN32 error code

--*/
DWORD
ClusterSplDeleteUpgradeKey(
    IN LPCWSTR pszResourceID
    )
{
    DWORD dwError   = ERROR_INVALID_PARAMETER;
    HKEY  hkRoot    = NULL;
    HKEY  hkUpgrade = NULL;

    if ((dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                0,
                                KEY_READ,
                                &hkRoot)) == ERROR_SUCCESS &&
        (dwError = RegOpenKeyEx(hkRoot,
                                SPLREG_CLUSTER_UPGRADE_KEY,
                                0,
                                KEY_ALL_ACCESS,
                                &hkUpgrade)) == ERROR_SUCCESS)
    {
        DWORD cValues = 0;

        dwError = RegDeleteValue(hkUpgrade, pszResourceID);

        if (RegQueryInfoKey(hkUpgrade,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &cValues,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS && !cValues)
        {
            RegDeleteKey(hkRoot, SPLREG_CLUSTER_UPGRADE_KEY);
        }

        if (hkUpgrade) RegCloseKey(hkUpgrade);
        if (hkRoot)    RegCloseKey(hkRoot);
    }

    return dwError;
}

/*++

Routine Name

    RunProcess

Routine Description:

    Creates a process. Waits for it to terminate.

Arguments:

    pszExe      - program to execute (muist be fully qualfied)
    pszCommand  - command line to execute
    dwTimeOut   - time to wait for the process to terminate
    pszExitCode - pointer to reveice exit code of process

Return Value:

    WIN32 error code

--*/
DWORD
RunProcess(
    IN  LPCWSTR pszExe,
    IN  LPCWSTR pszCommand,
    IN  DWORD   dwTimeOut,
    OUT LPDWORD pdwExitCode OPTIONAL
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszCommand && pszExe)
    {
        PROCESS_INFORMATION ProcInfo  = {0};
        STARTUPINFO         StartInfo = {0};

        StartInfo.cb = sizeof(StartInfo);
        StartInfo.dwFlags = 0;

        if (!CreateProcess(pszExe,
                           (LPWSTR)pszCommand,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_NO_WINDOW,
                           NULL,
                           NULL,
                           &StartInfo,
                           &ProcInfo))
        {
            dwError = GetLastError();
        }
        else
        {
            if (WaitForSingleObject(ProcInfo.hProcess, dwTimeOut) == WAIT_OBJECT_0)
            {
                //
                // Process executed fine
                //
                dwError = ERROR_SUCCESS;
            }

            if (pdwExitCode && !GetExitCodeProcess(ProcInfo.hProcess, pdwExitCode))
            {
                *pdwExitCode = 0;
            }

            CloseHandle(ProcInfo.hThread);
            CloseHandle(ProcInfo.hProcess);
        }
    }

    return dwError;
}

/*++

Routine Name

    GetLocalArchEnv

Routine Description:

    Helper function. Returns a pointer to the environment
    that matches the architecture of the local machine.
    The environemnt is taken off the pInSpooler passed as
    argument

Arguments:

    pIniSpooler - pointer to spooler structure

Return Value:

    PINIENVIRONMENT

--*/
PINIENVIRONMENT
GetLocalArchEnv(
    IN PINISPOOLER pIniSpooler
    )
{
    SplInSem();

    //
    // The local spooler and cluster spooler do not share the same Environment structures.
    //
    return pIniSpooler && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ?
           FindEnvironment(szEnvironment, pIniSpooler) : pThisEnvironment;
}

/*++

Routine Name

    ClusterFindLanguageMonitor

Routine Description:

    If a valid monitor name is specified and the monitor
    is not found in the specified pIniSpooler, then the
    function will try to install the monitor from the
    cluster disk.

Arguments:

    pszMonitor  - monitor name
    pszEnvName  - name of environment of the lm
    pIniSpooler - pointer to cluster spooler structure

Return Value:

    Win32 error code

--*/
DWORD
ClusterFindLanguageMonitor(
    IN LPCWSTR     pszMonitor,
    IN LPCWSTR     pszEnvName,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // This is the moment where we check if we need to add the monitor
    //
    if (pszMonitor && *pszMonitor)
    {
        PINIMONITOR pIniLangMonitor;

        EnterSplSem();

        //
        // We need to find the language monitor in pLocalIniSpooler
        // LMs are not cluster aware, so the cluster pIniSpooler doesn't know about them
        //
        pIniLangMonitor = FindMonitor(pszMonitor, pLocalIniSpooler);

        LeaveSplSem();

        if (!pIniLangMonitor)
        {
            PINIENVIRONMENT pIniEnvironment;

            EnterSplSem();
            pIniEnvironment = FindEnvironment(pszEnvName, pIniSpooler);
            LeaveSplSem();

            if (pIniEnvironment)
            {
                DBGMSG(DBG_CLUSTER, ("ClusterFindLanguageMonitor Trying to install LangMonitor "TSTR"\n", pszMonitor));

                //
                // We try to install the monitor from the cluster disk to the local spooler
                //
                dwError = InstallMonitorFromCluster(pszMonitor,
                                                    pIniEnvironment->pName,
                                                    pIniEnvironment->pDirectory,
                                                    pIniSpooler);
            }
            else
            {
                dwError = ERROR_INVALID_ENVIRONMENT;
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterFindLanguageMonitor LangMonitor "TSTR" return Win32 error %u\n", pszMonitor, dwError));

    return dwError;
}

/*++

Routine Name

    WriteTimeStamp

Routine Description:

    Opens the key hkRoot\pszSubkey1\...\pszSubKey5
    and writes the value of szClusDrvTimeStamp (binary
    data representing a system time)

Arguments:
    hkRoot      - handle to driver key
    SysTime     - system time structure
    pszSubKey1  - subkey of the root key
    pszSubKey2  - subkey of key1, can be null
    pszSubKey3  - subkey of key2, can be null
    pszSubKey4  - subkey of key3, can be null
    pszSubKey5  - subkey of key4, can be null
    pIniSpooler - spooler, can be NULL

Return Value:

    WIN32 error code

--*/
DWORD
WriteTimeStamp(
    IN HKEY        hkRoot,
    IN SYSTEMTIME  SysTime,
    IN LPCWSTR     pszSubKey1,
    IN LPCWSTR     pszSubKey2,
    IN LPCWSTR     pszSubKey3,
    IN LPCWSTR     pszSubKey4,
    IN LPCWSTR     pszSubKey5,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (hkRoot)
    {
        LPCWSTR ppszKeyNames[] = {NULL,   pszSubKey1, pszSubKey2, pszSubKey3, pszSubKey4, pszSubKey5};
        HKEY    pKeyHandles[]  = {hkRoot, NULL,       NULL,       NULL,       NULL,       NULL};
        DWORD   uIndex;

        dwError = ERROR_SUCCESS;

        //
        // Open all the keys
        //
        for (uIndex = 1;
             uIndex < COUNTOF(ppszKeyNames) &&
             dwError == ERROR_SUCCESS       &&
             ppszKeyNames[uIndex];
             uIndex++)
        {
            DBGMSG(DBG_CLUSTER, ("KEY "TSTR"\n", ppszKeyNames[uIndex]));

            dwError = SplRegCreateKey(pKeyHandles[uIndex-1],
                                      ppszKeyNames[uIndex],
                                      0,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &pKeyHandles[uIndex],
                                      NULL,
                                      pIniSpooler);
        }

        //
        // If we opened successfully the keys that we wanted, write the value
        //
        if (dwError == ERROR_SUCCESS &&
            !RegSetBinaryData(pKeyHandles[uIndex-1],
                              szClusDrvTimeStamp,
                              (LPBYTE)&SysTime,
                              sizeof(SysTime),
                              &dwError,
                              pIniSpooler))
        {
            dwError = GetLastError();
        }

        //
        // Close any keys that we opened
        //
        for (uIndex = 1; uIndex < COUNTOF(ppszKeyNames); uIndex++)
        {
            if (pKeyHandles[uIndex])
            {
                SplRegCloseKey(pKeyHandles[uIndex], pIniSpooler);
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("WriteTimeStamp returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ReadTimeStamp

Routine Description:

    Opens the key hkRoot\pszSubkey1\...\pszSubKey5
    and reads the value of szClusDrvTimeStamp (binary
    data representing a system time)

Arguments:
    hkRoot      - handle to driver key
    pSysTime    - pointer to allocated system time structure
    pszSubKey1  - subkey of the root key
    pszSubKey2  - subkey of key1, can be null
    pszSubKey3  - subkey of key2, can be null
    pszSubKey4  - subkey of key3, can be null
    pszSubKey5  - subkey of key4, can be null
    pIniSpooler - spooler, can be NULL

Return Value:

    WIN32 error code

--*/
DWORD
ReadTimeStamp(
    IN     HKEY        hkRoot,
    IN OUT SYSTEMTIME *pSysTime,
    IN     LPCWSTR     pszSubKey1,
    IN     LPCWSTR     pszSubKey2,
    IN     LPCWSTR     pszSubKey3,
    IN     LPCWSTR     pszSubKey4,
    IN     LPCWSTR     pszSubKey5,
    IN     PINISPOOLER pIniSpooler
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (hkRoot && pSysTime)
    {
        LPCWSTR ppszKeyNames[] = {NULL,   pszSubKey1, pszSubKey2, pszSubKey3, pszSubKey4, pszSubKey5};
        HKEY    pKeyHandles[]  = {hkRoot, NULL,       NULL,       NULL,       NULL,       NULL};
        DWORD   uIndex;

        dwError = ERROR_SUCCESS;

        //
        // Open all the keys
        //
        for (uIndex = 1;
             uIndex < COUNTOF(ppszKeyNames) &&
             dwError == ERROR_SUCCESS       &&
             ppszKeyNames[uIndex];
             uIndex++)
        {
            dwError = SplRegCreateKey(pKeyHandles[uIndex-1],
                                      ppszKeyNames[uIndex],
                                      0,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &pKeyHandles[uIndex],
                                      NULL,
                                      pIniSpooler);
        }

        //
        // If we opened successfully the keys that we wanted, write the value
        //
        if (dwError == ERROR_SUCCESS)
        {
            DWORD   cbSize = sizeof(SYSTEMTIME);

            dwError = SplRegQueryValue(pKeyHandles[uIndex-1],
                                       szClusDrvTimeStamp,
                                       NULL,
                                       (LPBYTE)pSysTime,
                                       &cbSize,
                                       pIniSpooler);
        }

        //
        // Close any keys that we opened
        //
        for (uIndex = 1; uIndex < COUNTOF(ppszKeyNames); uIndex++)
        {
            if (pKeyHandles[uIndex])
            {
                SplRegCloseKey(pKeyHandles[uIndex], pIniSpooler);
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("ReadTimeStamp returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ClusterCheckDriverChanged

Routine Description:

    Helper function for spooler start up. When we have a cluster spooler
    and we build the environments and drivers, we need to check if the
    drivers on the local machine (in print$\GUID) are in sync with the
    drivers on the cluster disk. We store a time stamp in the cluster
    data base. The time stamp indicate when the last update on the driver
    occured. The same type of time stamp is stroed in the lcoal registry
    (for our cluster spooler). If the 2 time stamp are different, then
    we need to call an add printer driver and use data from the cluster
    disk. The drivers on the cluster spooler were updated while it was
    running on a different node.

Arguments:

    hClusterVersionKey - handle to the driver version key
    pszDriver          - driver name
    pszEnv             - driver environment name
    pszVer             - driver version name
    pIniSpooler        - spooler

Return Value:

    TRUE  - if the driver on the cluster disk is updated and we need to
            call add printer driver. If anything fails in this function,
            then we also return TRUE, to force our caller to update/add
            the driver in question.
    FALSE - if the drivers on the local mahcine and the cluster spooler
            are in sync

--*/
BOOL
ClusterCheckDriverChanged(
    IN HKEY        hClusterVersionKey,
    IN LPCWSTR     pszDriver,
    IN LPCWSTR     pszEnv,
    IN LPCWSTR     pszVer,
    IN PINISPOOLER pIniSpooler
    )
{
    BOOL bReturn = TRUE;

    if (hClusterVersionKey &&
        pszDriver &&
        pszEnv &&
        pszVer)
    {
        SYSTEMTIME ClusterTime;
        SYSTEMTIME NodeTime;

        if (ReadTimeStamp(hClusterVersionKey,
                          &ClusterTime,
                          pszDriver,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          pIniSpooler) == ERROR_SUCCESS &&
            ReadTimeStamp(HKEY_LOCAL_MACHINE,
                          &NodeTime,
                          ipszRegistryClusRepository,
                          pIniSpooler->pszClusResID,
                          pszEnv,
                          pszVer,
                          pszDriver,
                          NULL) == ERROR_SUCCESS &&
            !memcmp(&ClusterTime, &NodeTime, sizeof(SYSTEMTIME)))
        {
            bReturn = FALSE;
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterCheckDriverChanged returns bool %u\n", bReturn));

    return bReturn;
}


/*++

Routine Name

    IsLocalFile

Routine Description:

    Checks if a file is on the local machine. If the file path is
    "\\machinename\sharename\...\filename" then machinename is checked
    against pIniSpooler->pMachineName and pIniSpooler->ppszOtherNames.

Arguments:

    pszFileName  - file name
    pIniSpooler  - INISPOOLER structure

Return Value:

    TRUE if the file is placed locally.
    FALSE if the file is placed remotely.

--*/
BOOL
IsLocalFile (
    IN  LPCWSTR     pszFileName,
    IN  PINISPOOLER pIniSpooler
    )
{
    LPWSTR  pEndOfMachineName, pMachineName;
    BOOL    bRetValue = TRUE;

    if (pszFileName &&
        *pszFileName == L'\\' &&
        *(pszFileName+1) == L'\\')
    {
        //
        // If first 2 charactes in pszFileName are '\\',
        // then search for the next '\\'. If found, then set it to 0,
        // to isolate the machine name.
        //

        pMachineName = (LPWSTR)pszFileName;

        if (pEndOfMachineName = wcschr(pszFileName + 2, L'\\'))
        {
            *pEndOfMachineName = 0;
        }

        bRetValue = CheckMyName(pMachineName, pIniSpooler);
        //
        // Restore pszFileName.
        //
        if (pEndOfMachineName)
        {
            *pEndOfMachineName = L'\\';
        }
    }

    return bRetValue;
}

/*++

Routine Name

    IsEXEFile

Routine Description:

    Checks if a file is a executable.
    The check is made against file extension, which isn't quite
    accurate.

Arguments:

    pszFileName  - file name

Return Value:

    TRUE if the file extension is either .EXE or .DLL

--*/
BOOL
IsEXEFile(
    IN  LPCWSTR  pszFileName
    )
{
    BOOL    bRetValue = FALSE;
    DWORD   dwLength;
    LPWSTR  pszExtension;

    if (pszFileName && *pszFileName)
    {
        dwLength = wcslen(pszFileName);

        if (dwLength > COUNTOF(L".EXE") - 1)
        {
            pszExtension = (LPWSTR)pszFileName + dwLength - (COUNTOF(L".EXE") - 1);

            if (_wcsicmp(pszExtension , L".EXE") == 0 ||
                _wcsicmp(pszExtension , L".DLL") == 0)
            {
                bRetValue = TRUE;
            }
        }
    }

    return bRetValue;
}


/*++

Routine Name

    PackStringToEOB

Routine Description:

    Copies a string to the end of buffer.
    The buffer must be big enough so that it can hold the string.
    This function is called by Get/Enum APIs that build BLOB buffers to
    send them with RPC.

Arguments:

    pszSource  - string to by copied to the end of buffer
    pEnd       - a pointer to the end of a pre-allocated buffer.

Return Value:

    The pointer to the end of buffer after the sting was appended.
    NULL if an error occured.

--*/
LPBYTE
PackStringToEOB(
    IN  LPWSTR pszSource,
    IN  LPBYTE pEnd
    )
{
    DWORD cbStr;

    //
    // Align the end of buffer to WORD boundaries.
    //
    WORD_ALIGN_DOWN(pEnd);

    if (pszSource && pEnd)
    {
        cbStr = (wcslen(pszSource) + 1) * sizeof(WCHAR);

        pEnd -= cbStr;

        CopyMemory(pEnd, pszSource, cbStr);
    }
    else
    {
        pEnd = NULL;
    }
    return pEnd;

}


LPVOID
MakePTR (
    IN  LPVOID pBuf,
    IN  DWORD  Quantity
    )

/*++

Routine Name

    MakePTR

Routine Description:

   Makes a pointer by adding a quantity to the beginning of a buffer.

Arguments:

    pBuf    -   pointer to buffer
    DWORD   -   quantity

Return Value:

   LPVOID pointer

--*/
{
    return (LPVOID)((ULONG_PTR)pBuf + (ULONG_PTR)Quantity);
}

DWORD
MakeOffset (
    IN  LPVOID pFirst,
    IN  LPVOID pSecond
    )

/*++

Routine Name

    MakeOffset

Routine Description:

    Substarcts two pointers.

Arguments:

    pFirst    -   pointer to buffer
    pSecond   -   pointer to buffer

Return Value:

    DWORD

--*/
{
    return (DWORD)((ULONG_PTR)pFirst - (ULONG_PTR)pSecond);
}

/*++

Routine Name

    IsValidPrinterName

Routine Description:

    Checks if a string is a valid printer name.

Arguments:

    pszPrinter - pointer to string
    cchMax     - max number of chars to scan

Return Value:

    TRUE  - the string is a valid printer name
    FALSE - the string is a invalid printer name. The function set the last error
            to ERROR_INVALID_PRINTER_NAME in this case

--*/
BOOL
IsValidPrinterName(
    IN LPCWSTR pszPrinter,
    IN DWORD   cchMax
    )
{
    DWORD Error = ERROR_INVALID_PRINTER_NAME;

    //
    // A printer name is of the form:
    //
    // \\s\p or p
    //
    // The name cannot contain the , character. Note that the add printer
    // wizard doesn't accept "!" as a valid printer name. We wanted to do
    // the same here, but we regressed in app compat with 9x apps.
    // The number of \ in the name is 0 or 3
    // If the name contains \, then the fist 2 chars must be \.
    // The printer name cannot end in \.
    // After leading "\\" then next char must not be \
    // The minimum length is 1 character
    // The maximum length is MAX_UNC_PRINTER_NAME
    //
    if (!IsBadStringPtr(pszPrinter, cchMax) && pszPrinter && *pszPrinter)
    {
        UINT    uSlashCount = 0;
        UINT    uLen        = 0;
        LPCWSTR p;

        Error = ERROR_SUCCESS;

        //
        // Count characters
        //
        for (p = pszPrinter; *p && uLen <= cchMax; p++, uLen++)
        {
            if (*p == L',')
            {
                Error = ERROR_INVALID_PRINTER_NAME;
                break;
            }
            else if (*p == L'\\')
            {
                uSlashCount++;
            }
        }

        //
        // Perform validation
        //
        if (Error == ERROR_SUCCESS &&

             //
             // Validate length
             //
            (uLen > cchMax ||

             //
             // The printer name has either no \, or exactly 3 \.
             //
             uSlashCount && uSlashCount != 3 ||

             //
             // A printer name that contains 3 \, must have the first 2 chars \ and the 3 not \.
             // The last char cannot be \.
             // Ex "\Foo", "F\oo", "\\\Foo", "\\Foo\" are invalid.
             // Ex. "\\srv\bar" is valid.
             //
             uSlashCount == 3 && (pszPrinter[0]      != L'\\' ||
                                  pszPrinter[1]      != L'\\' ||
                                  pszPrinter[2]      == L'\\' ||
                                  pszPrinter[uLen-1] == L'\\')))
        {
            Error = ERROR_INVALID_PRINTER_NAME;
        }
    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}

/*++

Routine Name

    SplPowerEvent

Routine Description:

    Checks if the spooler is ready for power management events like hibernation/stand by.
    If we have printing jobs that are not in an error state or offline, then we deny the 
    powering down request.

Arguments:

    Event - power management event

Return Value:

    TRUE  - the spooler allowd the system to be powered down
    FALSE - the spooler denies the request for powering down

--*/
BOOL
SplPowerEvent(
    DWORD Event
    )
{
    BOOL bAllow = TRUE;

    EnterSplSem();

    switch (Event)
    {
        case PBT_APMQUERYSUSPEND:
        {
            PINISPOOLER pIniSpooler;

            for (pIniSpooler = pLocalIniSpooler;
                 pIniSpooler && bAllow;
                 pIniSpooler = pIniSpooler->pIniNextSpooler)
            {
                PINIPRINTER pIniPrinter;

                for (pIniPrinter = pIniSpooler->pIniPrinter;
                     pIniPrinter && bAllow;
                     pIniPrinter = pIniPrinter->pNext)
                {
                    PINIJOB pIniJob;

                    for (pIniJob = pIniPrinter->pIniFirstJob;
                         pIniJob && bAllow;
                         pIniJob = pIniJob->pIniNextJob)
                    {
                        if (pIniJob->Status & JOB_PRINTING &&
                            !(pIniJob->Status & JOB_ERROR | pIniJob->Status & JOB_OFFLINE))
                        {
                            bAllow = FALSE;
                        }
                    }
                }
            }

            //
            // If we allow system power down, then we need to stop scheduling jobs
            //
            if (bAllow)
            {
                ResetEvent(PowerManagementSignal);
            }

            break;
        }

        case PBT_APMQUERYSUSPENDFAILED:
        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMEAUTOMATIC:

            //
            // Set the event to allow the spooler to continue scheudling jobs
            //
            SetEvent(PowerManagementSignal);
            break;

        default:

            //
            // We ignore any other power management event
            //
            break;
    }

    LeaveSplSem();

    return bAllow;
}

/*++

Routine Name

    IsCallViaRPC

Routine Description:

    Checks if the caller of this function came in the spooler server via RPC or not.
    
Arguments:

    None

Return Value:

    TRUE  - the caller came in via RPC
    FALSE - the caller did not come via RPC

--*/
BOOL
IsCallViaRPC(
    IN VOID
    )
{
    UINT uType;

    return I_RpcBindingInqTransportType(NULL, &uType) == RPC_S_NO_CALL_ACTIVE ? FALSE : TRUE;
}

/*++

Routine Name

    MergeMultiSz

Routine Description:

    This merges two multisz strings such that there is a resulting multisz 
    strings that has no duplicate strings internal. This algorithm is 
    currently N^2 which could be improved. It is currently being called from
    the driver code and the dependent files are not a large set.
    
Arguments:

    pszMultiSz1         -   The first multi-sz string. 
    cchMultiSz1         -   The length of the multi-sz string.
    pszMultiSz2         -   The second multi-sz string.
    cchMultiSz2         -   The length of the second multi-sz string.
    ppszMultiSzMerge    -   The merged multi-sz string.
    pcchMultiSzMerge    -   The number of characters in the merge, this could be
                            less than the allocated buffer size.

Return Value:

    FALSE on failure, LastError is set.

--*/
BOOL
MergeMultiSz(
    IN      PCWSTR              pszMultiSz1,
    IN      DWORD               cchMultiSz1,
    IN      PCWSTR              pszMultiSz2,
    IN      DWORD               cchMultiSz2,
        OUT PWSTR               *ppszMultiSzMerge,
        OUT DWORD               *pcchMultiSzMerge       OPTIONAL
    )
{
    BOOL    bRet          = FALSE;
    PWSTR   pszNewMultiSz = NULL;
    DWORD   cchNewMultiSz = 0;

    *ppszMultiSzMerge = NULL;
    
    if (pcchMultiSzMerge)
    {
        *pcchMultiSzMerge = 0;
    }

    if (cchMultiSz1 || cchMultiSz2)
    {
        //
        // Code assumes that these are at least 1 in the allocation size.
        // 
        cchMultiSz1 = cchMultiSz1 == 0 ? 1 : cchMultiSz1;
        cchMultiSz2 = cchMultiSz2 == 0 ? 1 : cchMultiSz2;

        //
        // The merged strings will be at most the size of both of them (if there are
        // no duplicates).
        // 
        pszNewMultiSz = AllocSplMem((cchMultiSz1 + cchMultiSz2 - 1) * sizeof(WCHAR));

        bRet = pszNewMultiSz != NULL;

        if (bRet)
        {
            //
            // Ensure that the multi-sz string is at least empty.
            // 
            *pszNewMultiSz = L'\0';
        }

        if (bRet && pszMultiSz1)
        {
            AddMultiSzNoDuplicates(pszMultiSz1, pszNewMultiSz);
        }

        if (bRet && pszMultiSz2)
        {
            AddMultiSzNoDuplicates(pszMultiSz2, pszNewMultiSz);
        }

        if (bRet)
        {
            cchNewMultiSz = GetMultiSZLen(pszNewMultiSz);
        }        
    }

    if (bRet)
    {        
        *ppszMultiSzMerge = pszNewMultiSz;

        if (pcchMultiSzMerge)
        {
            *pcchMultiSzMerge = cchNewMultiSz;
        }

        pszNewMultiSz = NULL;
    }

    FreeSplMem(pszNewMultiSz);

    return bRet;
}

/*++

Routine Name

    AddMultiSzNoDuplicates

Routine Description:

    This adds all of the strings in a multisz string to a buffer (the buffer 
    must be guaranteed to be large enough to accept the strings), it makes
    sure that there are no case insensitive duplicates in the list.
    
Arguments:

    pszMultiSzIn    -   The multi-sz whose elements are being added.
    pszNewMultiSz   -   The buffer in which we are filling up the multi-sz    
    
Return Value:

    None.

--*/
VOID
AddMultiSzNoDuplicates(
    IN      PCWSTR              pszMultiSzIn,
    IN  OUT PWSTR               pszNewMultiSz        
    )
{
    PCWSTR pszIn         = NULL;
    
    for(pszIn = pszMultiSzIn; *pszIn; pszIn += wcslen(pszIn) + 1)
    {
        BOOL            bStringFound = FALSE;
        PWSTR           pszMerge     = NULL;

        //
        // For each input string, run the merged multi-sz string and add it if
        // it is not already there.
        // 
        for(pszMerge = pszNewMultiSz; *pszMerge; pszMerge += wcslen(pszMerge) + 1)
        {
            if (!_wcsicmp(pszIn, pszMerge))
            {
                bStringFound = TRUE;
                break;
            }            
        }

        //
        // If the string was not found in the multisz string, then add it to the end.
        // 
        if (!bStringFound)
        {
            wcscpy(pszMerge, pszIn);

            pszMerge += wcslen(pszIn) + 1;

            //
            // Add the extra null terminator for now.
            // 
            *pszMerge = '\0';
        }
    }
}

/*++

Routine Name

    GetMultiSZLen

Routine Description:

    This returns the number of characters in a multisz string, including NULLs.
    
Arguments:

    pMultiSzSrc     -   The multisz string to search.

Return Value:

    The number of characters in the string.

--*/
DWORD 
GetMultiSZLen( 
    IN      LPWSTR              pMultiSzSrc 
    )
{
    DWORD  dwLen = 0;
    LPWSTR pTmp = pMultiSzSrc;

    while( TRUE ) {
        dwLen += wcslen(pTmp) + 1;     // Incude the terminating NULL char

        pTmp = pMultiSzSrc + dwLen;           // Point to the beginning of the next string in the MULTI_SZ

        if( !*pTmp )
            return ++dwLen;     // Reached the end of the MULTI_SZ string. Add 1 to the count for the last NULL char.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\varconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  varconv.c
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    SWilson     Nov 1996
//----------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop


HRESULT
PackString2Variant(
    LPCWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;
    WCHAR String[] = L"";
    LPCWSTR pStr;

    pStr = lpszData ? lpszData : (LPCWSTR) String;

    VariantInit(pvData);
    V_VT(pvData) = VT_BSTR;

    bstrData = SysAllocString(pStr);

    if (!bstrData) {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_WIN32,
                            ERROR_OUTOFMEMORY);
    }

    V_VT(pvData) = VT_BSTR;
    V_BSTR(pvData) = bstrData;

    return ERROR_SUCCESS;
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( V_VT(&varSrcData) != VT_BSTR) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        return S_OK;
    }

    *pbstrDestString = SysAllocString(V_BSTR(&varSrcData));

    return hr;
}


HRESULT
UnpackDispatchfromVariant(
    VARIANT varSrcData,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;

    if( V_VT(&varSrcData) != VT_DISPATCH) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_DISPATCH(&varSrcData)) {
        *ppDispatch = NULL;
        return S_OK;
    }

    *ppDispatch = V_DISPATCH(&varSrcData);

    return hr;
}



HRESULT
PackDispatch2Variant(
    IDispatch *pDispatch,
    VARIANT *pvData
)
{
    if (!pvData)
        return E_FAIL;

    V_VT(pvData) = VT_DISPATCH;
    V_DISPATCH(pvData) = pDispatch;

    return S_OK;
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }

    V_VT(pvData) = VT_I4;
    V_I4(pvData) = dwData;

    return S_OK;
}

HRESULT
UnpackDWORDfromVariant(
    VARIANT varSrcData,
    DWORD   *pdwData
)
{
    if( V_VT(&varSrcData) != VT_I4) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    *pdwData = V_I4(&varSrcData);
    return S_OK;
}

HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    V_VT(pvData) = VT_BOOL;
    V_BOOL(pvData) = (BYTE) fData;

    return S_OK;
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT *pvarInputData
    )
{
    VariantInit(pvarInputData);

    V_VT(pvarInputData) = VT_VARIANT;
    return VariantCopy( pvarInputData, &vaValue );
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i = 0;
    long j = 0;
    long nCount;

    if ( (bstrList != NULL) && (*bstrList != 0) ) {

        for (nCount = 0 ;  bstrList[nCount] ; ++nCount)
            ;

        if ( nCount == 1 ) {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            if (!(V_BSTR(pvVariant) = SysAllocString( bstrList[0]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            return hr;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = 0 ;  bstrList[i] ; ++i) {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (!(V_BSTR(&v) = SysAllocString(bstrList[i]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    } else {

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


HRESULT
PrintVariantArray(VARIANT var)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    if ( !( (V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is only one dimension in this array

    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is atleast one element in this array

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // We know that this is a valid single dimension array

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {
        VariantInit(&v);

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, &v);
        if ( FAILED(hr) )
            continue;

        DBGMSG(DBG_INFO,("%ws\n", v.bstrVal));
    }

    hr = S_OK;

error:

    return hr;
}




HRESULT
UI1Array2IID(
    VARIANT var,
    IID *pIID
)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    UCHAR pGUID[16];

    if ( !( (V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is only one dimension in this array

    //DBGMSG(DBG_TRACE,("UI1Array, cDims = %d\n", (V_ARRAY(&var))->cDims));
    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is at least one element in this array

    if ((V_ARRAY(&var))->rgsabound[0].cElements != 16) {
        DBGMSG(DBG_ERROR,("UI1Array, cElements != 16\n", (V_ARRAY(&var))->rgsabound[0].cElements));
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // We know that this is a valid single dimension array

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, pGUID + i - dwSLBound);
        if ( FAILED(hr) )
            continue;

        //DBGMSG(DBG_TRACE,("UI1Array, GUID: %0x\n", pGUID[i - dwSLBound]));
    }

    *pIID = *(IID *) pGUID;

    hr = S_OK;

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\version.c ===
/*++

Copyright (c) 1994 - 1995  Microsoft Corporation

Module Name:

    version.c

Abstract:
   This module contains code that determines what the driver major
   version is.

Author:

    Krishna Ganugapati (KrishnaG) 15-Mar-1994

Revision History:

--*/

#include <precomp.h>

#define     X86_ENVIRONMENT             L"Windows NT x86"
#define     IA64_ENVIRONMENT            L"Windows IA64"
#define     MIPS_ENVIRONMENT            L"Windows NT R4000"
#define     ALPHA_ENVIRONMENT           L"Windows NT Alpha_AXP"
#define     PPC_ENVIRONMENT             L"Windows NT PowerPC"
#define     WIN95_ENVIRONMENT           L"Windows 4.0"

DWORD
GetDriverMajorVersion(
    LPWSTR pFileName
    )
{
     DWORD dwSize = 0;
     LPVOID pFileVersion;
     UINT  uLen = 0;
     LPVOID pMem;
     DWORD dwFileOS;
     DWORD dwFileVersionMS;
     DWORD dwFileVersionLS;
     DWORD dwProductVersionMS;
     DWORD dwProductVersionLS;


     if (!(dwSize = GetFileVersionInfoSize(pFileName, 0))) {
         DBGMSG(DBG_TRACE, ("Error: GetFileVersionInfoSize failed with %d\n", GetLastError()));
         DBGMSG(DBG_TRACE, ("Returning back a version # 0\n"));
         return(0);
     }
     if (!(pMem = AllocSplMem(dwSize))) {
         DBGMSG(DBG_TRACE, ("AllocMem  failed \n"));
         DBGMSG(DBG_TRACE, ("Returning back a version # 0\n"));
         return(0);
     }
     if (!GetFileVersionInfo(pFileName, 0, dwSize, pMem)) {
         FreeSplMem(pMem);
         DBGMSG(DBG_TRACE, ("GetFileVersionInfo failed\n"));
         DBGMSG(DBG_TRACE, ("Returning back a version # 0\n"));
         return(0);
     }
     if (!VerQueryValue(pMem, L"\\",
                            &pFileVersion, &uLen)) {
        FreeSplMem(pMem);
        DBGMSG(DBG_TRACE, ("VerQueryValue failed \n"));
        DBGMSG(DBG_TRACE, ("Returning back a version # 0\n"));
        return(0);
     }

     //
     // We could determine the Version Information
     //

     DBGMSG(DBG_TRACE, ("dwFileVersionMS =  %d\n", ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS));
     DBGMSG(DBG_TRACE, ("dwFileVersionLS = %d\n", ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS));

     DBGMSG(DBG_TRACE, ("dwProductVersionMS = %d\n", ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionMS));
     DBGMSG(DBG_TRACE, ("dwProductVersionLS =  %d\n", ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionLS));

     dwFileOS = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileOS;
     dwFileVersionMS = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS;
     dwFileVersionLS = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS;

     dwProductVersionMS = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionMS;
     dwProductVersionLS = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionLS;

     FreeSplMem(pMem);

     if (dwFileOS != VOS_NT_WINDOWS32) {
         DBGMSG(DBG_TRACE,("Returning back a version # 0\n"));
         return(0);
     }

     if (dwProductVersionMS == dwFileVersionMS) {

         //
         // This means this hold for all dlls Pre-Daytona
         // after Daytona, printer driver writers must support
         // version control or we'll dump them as Version 0
         // drivers


         DBGMSG(DBG_TRACE,("Returning back a version # 0\n"));
         return(0);
     }

     //
     // Bug-Bug: suppose a third-party vendor uses a different system
     // methinks we should use the lower dword to have  specific value
     // which implies he/she supports spooler version -- check with MattFe

     DBGMSG(DBG_TRACE,("Returning back a version # %d\n", dwFileVersionMS));

     return(dwFileVersionMS);
}

BOOL
GetPrintDriverVersion(
    IN  LPCWSTR pszFileName,
    OUT LPDWORD pdwFileMajorVersion,
    OUT LPDWORD pdwFileMinorVersion
)
/*++

Routine Name:

    GetPrintDriverVersion

Routine Description:

    Gets version information about an executable file.
    If the file is not an executable, it will return 0
    for both major and minor version.

Arguments:

    pszFileName         -   file name
    pdwFileMajorVersion -   pointer to major version
    pdwFileMinorVersion -   pointer to minor version
    
Return Value:

    TRUE if success.

--*/
{
    DWORD  dwSize = 0;
    LPVOID pFileVersion = NULL;
    UINT   uLen = 0;
    LPVOID pMem = NULL;
    DWORD  dwFileVersionLS;
    DWORD  dwFileVersionMS;
    DWORD  dwProductVersionMS;
    DWORD  dwProductVersionLS;
    DWORD  dwFileOS, dwFileType, dwFileSubType;
    BOOL   bRetValue = FALSE;

    if (pdwFileMajorVersion) 
    {
        *pdwFileMajorVersion = 0;
    }

    if (pdwFileMinorVersion) 
    {
        *pdwFileMinorVersion = 0;
    }

    try 
    {
        if (pszFileName && *pszFileName) 
        {
            dwSize = GetFileVersionInfoSize((LPWSTR)pszFileName, 0);

            if (dwSize == 0)
            {
                //
                // Return version 0 for files without a version resource
                //
                bRetValue = TRUE;
            } 
            else if ((pMem = AllocSplMem(dwSize)) &&
                     GetFileVersionInfo((LPWSTR)pszFileName, 0, dwSize, pMem) &&
                     VerQueryValue(pMem, L"\\", &pFileVersion, &uLen)) 
            {
                dwFileOS            = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileOS;
                dwFileType          = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileType;
                dwFileSubType       = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileSubtype;
                dwFileVersionMS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS;
                dwFileVersionLS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS;
                dwProductVersionMS  = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionMS;
                dwProductVersionLS  = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionLS;

                //
                //  Return versions for drivers designed for Windows NT/Windows 2000,
                //  marked as printer drivers.
                //  Hold for all dlls Pre-Daytona.
                //  After Daytona, printer driver writers must support
                //  version control or we'll dump them as Version 0 drivers.
                //
                if (dwFileOS == VOS_NT_WINDOWS32)                  
                {
                    if (dwFileType == VFT_DRV &&
                        dwFileSubType == VFT2_DRV_VERSIONED_PRINTER) 
                    {
                        if (pdwFileMinorVersion)
                        {
                            *pdwFileMinorVersion = dwFileVersionLS;       
                        }

                        if (pdwFileMajorVersion)
                        {
                            *pdwFileMajorVersion = dwFileVersionMS;       
                        }
                    } 
                    else
                    {
                        if (pdwFileMajorVersion)
                        {
                            if (dwProductVersionMS == dwFileVersionMS) 
                            {
                                 //
                                 // Hold for all dlls Pre-Daytona.
                                 // After Daytona, printer driver writers must support
                                 // version control or we'll dump them as Version 0
                                 // drivers.
                                 //
                                 *pdwFileMajorVersion = 0;
                            }
                            else
                            {
                                *pdwFileMajorVersion = dwFileVersionMS;
                            }
                        }
                    }
                }

                bRetValue = TRUE;
            }
        }
    }
    finally
    {
        FreeSplMem(pMem);
    }

    return bRetValue;
}


BOOL
CheckFilePlatform(
    IN  LPWSTR  pszFileName,
    IN  LPWSTR  pszEnvironment
    )
{
    HANDLE              hFile, hMapping;
    LPVOID              BaseAddress = NULL;
    PIMAGE_NT_HEADERS   pImgHdr;
    BOOL                bRet = FALSE;

    try {

        hFile = CreateFile(pszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile == INVALID_HANDLE_VALUE )
            leave;

        hMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL);

        if ( !hMapping )
            leave;

        BaseAddress = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);

        CloseHandle(hMapping);

        if ( !BaseAddress )
            leave;

        pImgHdr = RtlImageNtHeader(BaseAddress);

        if ( !pImgHdr ) {

            //
            // This happens for Win95 drivers. The second part of || is for
            // any environments we may add in the future
            //
            bRet = !_wcsicmp(pszEnvironment, WIN95_ENVIRONMENT) ||
                   !( _wcsicmp(pszEnvironment, X86_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, IA64_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT)  &&
                     _wcsicmp(pszEnvironment, PPC_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, MIPS_ENVIRONMENT) );
            leave;
        }

        switch (pImgHdr->FileHeader.Machine) {

            case IMAGE_FILE_MACHINE_I386:
                bRet = !_wcsicmp(pszEnvironment, X86_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_ALPHA:
                bRet = !_wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_IA64:
                bRet = !_wcsicmp(pszEnvironment, IA64_ENVIRONMENT);
                break;                

            case IMAGE_FILE_MACHINE_POWERPC:
                bRet = !_wcsicmp(pszEnvironment, PPC_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
            case IMAGE_FILE_MACHINE_R10000:
                bRet = !_wcsicmp(pszEnvironment, MIPS_ENVIRONMENT);
                break;

            default:
                //
                // For any environments we may add in the future.
                //
                bRet = !(_wcsicmp(pszEnvironment, X86_ENVIRONMENT)    &&
                         _wcsicmp(pszEnvironment, IA64_ENVIRONMENT)   &&
                         _wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT)  &&
                         _wcsicmp(pszEnvironment, PPC_ENVIRONMENT)    &&
                         _wcsicmp(pszEnvironment, MIPS_ENVIRONMENT) );
        }

    } finally {

        if ( hFile != INVALID_HANDLE_VALUE ) {

            if ( BaseAddress )
                UnmapViewOfFile(BaseAddress);
            CloseHandle(hFile);
        }
    }

    return bRet;
}

/*++

Routine Name:

    GetBinaryVersion

Routine Description:

    Gets version information about an executable file.
    If the file is not an executable, it will return 0
    for both major and minor version. This function does 
    not are if the file is a printer driver or anything
    else as long as it has a resource.

Arguments:

    pszFileName         -   file name
    pdwFileMajorVersion -   pointer to major version
    pdwFileMinorVersion -   pointer to minor version
    
Return Value:

    TRUE if success.

--*/
BOOL
GetBinaryVersion(
    IN  PCWSTR pszFileName,
    OUT PDWORD pdwFileMajorVersion,
    OUT PDWORD pdwFileMinorVersion
    )
{
    DWORD  dwSize = 0;
    LPVOID pFileVersion = NULL;
    UINT   uLen = 0;
    LPVOID pMem = NULL;
    DWORD  dwFileVersionLS;
    DWORD  dwFileVersionMS;
    BOOL   bRetValue = FALSE;

    if (pdwFileMajorVersion && pdwFileMinorVersion && pszFileName && *pszFileName)
    {
        *pdwFileMajorVersion = 0;
        *pdwFileMinorVersion = 0;
        
        try 
        {
            dwSize = GetFileVersionInfoSize((LPWSTR)pszFileName, 0);
    
            if (dwSize == 0)
            {
                //
                // Return version 0 for files without a version resource
                //
                bRetValue = TRUE;
            } 
            else if ((pMem = AllocSplMem(dwSize)) &&
                     GetFileVersionInfo((LPWSTR)pszFileName, 0, dwSize, pMem) &&
                     VerQueryValue(pMem, L"\\", &pFileVersion, &uLen)) 
            {
                dwFileVersionMS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS;
                dwFileVersionLS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS;
                    
                *pdwFileMinorVersion = dwFileVersionLS;       
                *pdwFileMajorVersion = dwFileVersionMS;       
                    
                bRetValue = TRUE;
            }
        }
        finally
        {
            FreeSplMem(pMem);
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetValue;
}

typedef struct 
{
    PCWSTR pszDriver;
    DWORD  DrvMajor;
    DWORD  DrvMinor;
    PCWSTR pszProc;
    DWORD  ProcMajor;
    DWORD  ProcMinor;
} SPECIALDRIVER;

typedef struct
{
    PCWSTR pszPrintProcFile;
    DWORD  PrintProcMajVer;
    DWORD  PrintProcMinVer;
} NOIMPERSONATEPRINTPROCS;


NOIMPERSONATEPRINTPROCS NoImpPrintProcs[] = 
{
    {L"lxaspp.dll",   0x00010000, 0x00000001},
    {L"lxarpp.dll",   0x00010000, 0x00000001},
    {L"lxampp.dll",   0x00010000, 0x00000001},
    {L"lxaupp.dll",   0x00010000, 0x00000001},
    {L"lxatpp.dll",   0x00010000, 0x00000001},
    {L"lxacpp.dll",   0x00010000, 0x00000001},
    {L"lxaapp.dll",   0x00010000, 0x00000001},
    {L"lxaepp.dll",   0x00010000, 0x00000001},
    {L"lxadpp.dll",   0x00010000, 0x00000001},
    {L"lxcapp.dll",   0x00010000, 0x00000001},
    {L"lexepp.dll",   0x00010000, 0x00000001},
    {L"lexfpp.dll",   0x00010000, 0x00000001},
    {L"jw61pp.dll",   0x00010000, 0x00000001},
    {L"fxj4pp.dll",   0x00010000, 0x00000001},
    {L"lxalpp5c.dll", 0x00020000, 0x00020000},
    {L"lxalpp5c.dll", 0x00010000, 0x00060000},
    {L"lxalpp5c.dll", 0x00020000, 0x00010000},
    {L"lxalpp5c.dll", 0x00010000, 0x00050000},
    {L"lxakpp5c.dll", 0x00020000, 0x00010000},
    {L"lxakpp5c.dll", 0x00010000, 0x00050001},
    {L"lxazpp5c.dll", 0x00010000, 0x00040002},
    {L"lxazpp5c.dll", 0x00010000, 0x00050001},
    {L"lxaxpp5c.dll", 0x00010000, 0x00060008},
    {L"lxaipp5c.dll", 0x00020000, 0x00020002},
    {L"lxaipp5c.dll", 0x00030000, 0x00020001},
    {L"lxajpp5c.dll", 0x00030000, 0x00010000},
    {L"lxajpp5c.dll", 0x00010000, 0x00020001},
    {L"lxavpp5c.dll", 0x00010000, 0x000A0000},
    {L"lxavpp5c.dll", 0x00010000, 0x00060000},
    {L"lg24pp5c.dll", 0x00010000, 0x00010008},
    {L"lg24pp5c.dll", 0x00010000, 0x00070002},
    {L"lgl2pp5c.dll", 0x00010000, 0x00010006},
    {L"lgaxpp5c.dll", 0x00010000, 0x00020001},
    {L"smaxpp5c.dll", 0x00010000, 0x00030000},
    {L"smazpp5c.dll", 0x00010000, 0x00020000},
    {L"lxbhpp5c.dll", 0x00010000, 0x00050000},
};


PCWSTR ArraySpecialDriversInbox[] =
{
    L"Lexmark 3200 Color Jetprinter",
    L"Lexmark 5700 Color Jetprinter",
    L"Lexmark Z11 Color Jetprinter",
    L"Lexmark Z12 Color Jetprinter",
    L"Lexmark Z22-Z32 Color Jetprinter",
    L"Lexmark Z31 Color Jetprinter",
    L"Lexmark Z42 Color Jetprinter",
    L"Lexmark Z51 Color Jetprinter",
    L"Lexmark Z52 Color Jetprinter",
    L"Compaq IJ300 Inkjet Printer",
    L"Compaq IJ600 Inkjet Printer",
    L"Compaq IJ700 Inkjet Printer",
    L"Compaq IJ750 Inkjet Printer",
    L"Compaq IJ900 Inkjet Printer",
    L"Compaq IJ1200 Inkjet Printer"
};

/*++

Name:

    FillInVersionInfo

Description:

    We have the following 2 DWORD fields in INIDRIVER: DriverFileMajorVersion and DriverFileMinorVersion
    They are not filled in when a driver is added or when the spooler starts. The reason for the 
    existence of these 2 fields is that we cannot always rely on the informatin in dwlDriverVersion
    (part of driver-info_6). Not all driver packages supply this information. 
    
    So when we print for the first time using a certain INIDRIVER, we call this function to look at
    the resource of the driver DLL and populate DriverFileMajorVersion and DriverFileMinorVersion.
    The numbers come from VS_FIXEDFILEINFO.FileVer

Arguments:

    pIniDriver  - pinidriver to fill in the major and minor versions
    pIniSpooler - pinispooler to which the driver belongs

Return Value:

    Win32 error code

--*/
DWORD
FillInVersionInfo(
    IN PINIDRIVER  pIniDriver,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD            Error = ERROR_INVALID_ENVIRONMENT;
    WCHAR            szPath[MAX_PATH];
    DWORD            cbNeeded;
    PINIENVIRONMENT  pIniEnvironment;

    EnterSplSem();

    pIniEnvironment = FindEnvironment(LOCAL_ENVIRONMENT, pIniSpooler);

    if (pIniEnvironment) 
    {
        Error = StrNCatBuff(szPath,
                            MAX_PATH,
                            pIniSpooler->pDir,
                            L"\\",
                            szDriverDir,
                            L"\\",
                            pIniEnvironment->pDirectory,
                            L"\\3\\",
                            pIniDriver->pDriverFile,
                            NULL);
    }
    
    LeaveSplSem();

    if (Error == ERROR_SUCCESS)
    {
        Error = GetBinaryVersion(szPath, 
                                 &pIniDriver->DriverFileMajorVersion, 
                                 &pIniDriver->DriverFileMinorVersion) ? ERROR_SUCCESS : GetLastError();                
    }
    
    SPLASSERT(Error == ERROR_SUCCESS);

    return Error;
}

/*++

Name:

    IsSpecialDriver

Description:

    Checks whether a printer driver (and print processor) needs to be special 
    cased. Some print processors want to be loaded in local system context.
    The are listed in the tables above. some are inbox, some are IHV.
    
Arguments:

    pIniDriver  - pinidriver for the current job
    pIniProc    - piniprintproc for the current job
    pIniSpooler - pinispooler for current job

Return Value:

    TRUE - this print processor needs to be loaded in local system context
    FALSE - load print processor in impersonation context

--*/
BOOL
IsSpecialDriver(
    IN PINIDRIVER    pIniDriver,
    IN PINIPRINTPROC pIniProc,
    IN PINISPOOLER   pIniSpooler
    )
{
    BOOL  bSpecial = FALSE;
    DWORD i;

    //
    // Check if it is an inbox driver that needs to be special cased
    //
    for (i = 0; i < COUNTOF(ArraySpecialDriversInbox); i++)
    {
        if (!_wcsicmp(pIniDriver->pName, ArraySpecialDriversInbox[i]))
        {
            bSpecial = TRUE; 

            break;
        }
    }

    //
    // Check if it is an IHV driver that needs to be special cased
    //
    if (!bSpecial)
    {
        if (pIniDriver->DriverFileMajorVersion == 0 && pIniDriver->DriverFileMinorVersion == 0)
        {
            //
            // We fill in on demand the major and minor file version 
            //
            FillInVersionInfo(pIniDriver, pIniSpooler);
        }

        for (i = 0; i < COUNTOF(NoImpPrintProcs); i++)
        {
            if (!_wcsicmp(pIniProc->pDLLName, NoImpPrintProcs[i].pszPrintProcFile)   &&
                pIniProc->FileMajorVersion == NoImpPrintProcs[i].PrintProcMajVer     &&
                pIniProc->FileMinorVersion == NoImpPrintProcs[i].PrintProcMinVer)
            {
                bSpecial = TRUE; 
    
                break;
            }
        }
    }

    return bSpecial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\hydra\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\xcv.c ===
/*++


Copyright (c) 1997  Microsoft Corporation

Module Name:

    xcv.c

Author:

    Steve Wilson (SWilson) March 25, 1997

Revision History:


--*/

#include <precomp.h>
#include <offsets.h>


PINIXCV
CreateXcvEntry(
    PCWSTR  pszMachine,
    PCWSTR  pszName,
    PMONITOR2 pMonitor2,
    PINISPOOLER pIniSpooler,
    HANDLE  hXcv
);

VOID
DeleteXcvEntry(
    PINIXCV pIniXcv
    );

BOOL
SplXcvOpenPort(
    PCWSTR              pszMachine,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
);



INIXCV IniXcvStart;


typedef struct {
    PWSTR    pszMethod;
    BOOL     (*pfn)(PINIXCV pIniXcv,
                    PCWSTR pszDataName,
                    PBYTE  pInputData,
                    DWORD  cbInputData,
                    PBYTE  pOutputData,
                    DWORD  cbOutputData,
                    PDWORD pcbOutputNeeded,
                    PDWORD pdwStatus,
                    PINISPOOLER pIniSpooler
                    );
} XCV_METHOD, *PXCV_METHOD;


XCV_METHOD  gpXcvMethod[] = {
                            {L"DeletePort", XcvDeletePort},
                            {L"AddPort", XcvAddPort},
                            {NULL, NULL}
                            };


BOOL
LocalXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    PINIXCV     pIniXcv = ((PSPOOL) hXcv)->pIniXcv;
    BOOL bReturn;

    if (!ValidateXcvHandle(pIniXcv))
        return ROUTER_UNKNOWN;

    bReturn = SplXcvData(hXcv,
                         pszDataName,
                         pInputData,
                         cbInputData,
                         pOutputData,
                         cbOutputData,
                         pcbOutputNeeded,
                         pdwStatus,
                         pIniXcv->pIniSpooler);

    return bReturn;
}



BOOL
SplXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc;
    PINIXCV     pIniXcv = ((PSPOOL) hXcv)->pIniXcv;
    DWORD       i;


    SPLASSERT(pIniXcv->pMonitor2->pfnXcvDataPort);

    // Execute well-known methods
    for(i = 0 ; gpXcvMethod[i].pszMethod &&
                wcscmp(gpXcvMethod[i].pszMethod, pszDataName) ; ++i)
        ;

    if (gpXcvMethod[i].pszMethod) {

        PINIPORT pIniPort = NULL;

        if (!_wcsicmp(gpXcvMethod[i].pszMethod, L"AddPort")) {

            EnterSplSem();

            //
            // Port name is the first field in the input structure
            //
            pIniPort = FindPort(pInputData, pIniSpooler);

            LeaveSplSem();

            //
            // If this pIniPort doesn't have a monitor associated with it, it is
            // a temporary port. We will allow it to be added, if there still is
            // no monitor associated with it later, we will simply use this 
            // structure again.
            // 
            if (pIniPort && !(pIniPort->Status & PP_PLACEHOLDER)) {
                rc = TRUE;
                *pdwStatus = ERROR_ALREADY_EXISTS;                
            }
        }

        //
        // Don't make the function call if we do AddPort and the port already exists.
        // If it is a placeholder, that's OK.
        //
        if (!pIniPort || pIniPort->Status & PP_PLACEHOLDER) {
            
            rc = (*gpXcvMethod[i].pfn)( pIniXcv,
                                        pszDataName,
                                        pInputData,
                                        cbInputData,
                                        pOutputData,
                                        cbOutputData,
                                        pcbOutputNeeded,
                                        pdwStatus,
                                        pIniSpooler);
        }

    } else {
        *pdwStatus = (*pIniXcv->pMonitor2->pfnXcvDataPort)( pIniXcv->hXcv,
                                                            pszDataName,
                                                            pInputData,
                                                            cbInputData,
                                                            pOutputData,
                                                            cbOutputData,
                                                            pcbOutputNeeded );
        rc = TRUE;
    }

    return rc;
}


DWORD
XcvOpen(
    PCWSTR              pszServer,
    PCWSTR              pszObject,
    DWORD               dwObjectType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
)
{
    BOOL        bRet;
    DWORD       dwRet;
    DWORD       dwLastError;


    if (dwObjectType == XCVPORT || dwObjectType == XCVMONITOR) {
        bRet = SplXcvOpenPort( pszServer,
                               pszObject,
                               dwObjectType,
                               pDefault,
                               phXcv,
                               pIniSpooler);

        if (!bRet) {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_INVALID_NAME)
                dwRet = ROUTER_UNKNOWN;
            else if (dwLastError == ERROR_UNKNOWN_PORT) 
                
                // This is a case where a port exists without an associated port monitor
                // (i.e. a masq port), we need to give the partial print provider a chance
                // to intercept the XCV call
                //

                dwRet = ROUTER_UNKNOWN;
            else
                dwRet = ROUTER_STOP_ROUTING;
        }
        else {
            dwRet = ROUTER_SUCCESS;
        }

    } else {
        dwRet = ROUTER_UNKNOWN;
    }

    return dwRet;
}


BOOL
SplXcvOpenPort(
    PCWSTR              pszMachine,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
)
{
    PINIMONITOR pIniMonitor = NULL;
    PINIPORT    pIniPort;
    BOOL        rc = FALSE;
    DWORD       dwStatus;
    HANDLE      hMonitor;
    PSPOOL      pSpool;
    PINIXCV     pIniXcv = NULL;


   EnterSplSem();

    if (dwType == XCVMONITOR) {
        pIniMonitor = FindMonitor(pszObject, pIniSpooler);
    }
    else {
        pIniPort = FindPort(pszObject, pIniSpooler);

        if(pIniPort && (pIniPort->Status & PP_MONITOR))
            pIniMonitor = pIniPort->pIniMonitor;
    }

    if (pIniMonitor) {

        if (!pIniMonitor->Monitor2.pfnXcvOpenPort ||
            !pIniMonitor->Monitor2.pfnXcvDataPort ||
            !pIniMonitor->Monitor2.pfnXcvClosePort) {

            SetLastError(ERROR_INVALID_PRINT_MONITOR);

        } else {

            LeaveSplSem();

            dwStatus = CreateServerHandle( (PWSTR) pszMachine,
                                           phXcv,
                                           pDefault,
                                           pIniSpooler,
                                           PRINTER_HANDLE_XCV_PORT);

            EnterSplSem();

            if (dwStatus == ROUTER_SUCCESS) {       // Create port handle

                pSpool = *(PSPOOL *) phXcv; // *phXcv is pSpool

                rc = (*pIniMonitor->Monitor2.pfnXcvOpenPort)(
                           pIniMonitor->hMonitor,
                           pszObject,
                           pSpool->GrantedAccess,
                           &hMonitor);

                if (rc) {   // Create Spooler XCV entry

                    pIniXcv = CreateXcvEntry( pszMachine,
                                              pszObject,
                                              &pIniMonitor->Monitor2,
                                              pIniSpooler,
                                              hMonitor);

                    if (pIniXcv) {

                        pSpool->pIniXcv = pIniXcv;

                    } else {

                        (*pIniMonitor->Monitor2.pfnXcvClosePort)(hMonitor);
                        rc = FALSE;
                    }
                }
            }
        }
    } else {

        SetLastError(ERROR_UNKNOWN_PORT);
        rc = FALSE;
    }


   LeaveSplSem();

    return rc;
}




PINIXCV
CreateXcvEntry(
    PCWSTR  pszMachine,
    PCWSTR  pszName,
    PMONITOR2 pMonitor2,
    PINISPOOLER pIniSpooler,
    HANDLE  hXcv
)
{
    PINIXCV pIniXcvPrev = &IniXcvStart;
    PINIXCV pIniXcv = IniXcvStart.pNext;


    for(; pIniXcv ; pIniXcv = pIniXcv->pNext)
        pIniXcvPrev = pIniXcv;


    if (!(pIniXcv = (PINIXCV) AllocSplMem(sizeof(INIXCV))))
        goto Cleanup;

    pIniXcv->hXcv = hXcv;
    pIniXcv->signature = XCV_SIGNATURE;

    pIniXcv->pIniSpooler = pIniSpooler;
    INCSPOOLERREF( pIniSpooler );

    if (pszMachine && !(pIniXcv->pszMachineName = AllocSplStr(pszMachine)))
        goto Cleanup;

    if (pszName && !(pIniXcv->pszName = AllocSplStr(pszName)))
        goto Cleanup;

    pIniXcv->pMonitor2 = pMonitor2;

    return pIniXcvPrev->pNext = pIniXcv;


Cleanup:

    DeleteXcvEntry( pIniXcv );
    return NULL;
}

VOID
DeleteXcvEntry(
    PINIXCV pIniXcv
    )
{
    if( pIniXcv ){

        if( pIniXcv->pIniSpooler ){
            DECSPOOLERREF( pIniXcv->pIniSpooler );
        }

        FreeSplStr(pIniXcv->pszMachineName);
        FreeSplStr(pIniXcv->pszName);
        FreeSplMem(pIniXcv);
    }
}

BOOL
XcvClose(
    PINIXCV pIniXcvIn
)
{
    PINIXCV pIniXcvPrev = &IniXcvStart;
    PINIXCV pIniXcv = IniXcvStart.pNext;
    BOOL    bRet;


    for(; pIniXcv ; pIniXcv = pIniXcv->pNext) {

        if (pIniXcv == pIniXcvIn) {

            bRet = pIniXcv->pMonitor2->pfnXcvClosePort(pIniXcv->hXcv);

            if (bRet) {
                pIniXcvPrev->pNext = pIniXcv->pNext;

                DeleteXcvEntry( pIniXcv );
            }
            return bRet;
        }

        pIniXcvPrev = pIniXcv;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return FALSE;
}




BOOL
XcvDeletePort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc = FALSE;
    PWSTR       pPortName = (PWSTR) pInputData;

    EnterSplSem();
    
    pIniPort = FindPort(pPortName, pIniSpooler);

    if ( !pIniPort || !(pIniPort->Status & PP_MONITOR) ) {
        SetLastError (*pdwStatus = ERROR_UNKNOWN_PORT);
        LeaveSplSem();
        return FALSE;
    }

    rc = DeletePortFromSpoolerStart( pIniPort );
    *pdwStatus = GetLastError ();

    LeaveSplSem();

    if (!rc)
        goto Cleanup;

    *pdwStatus = (*pIniXcv->pMonitor2->pfnXcvDataPort)( pIniXcv->hXcv,
                                                        pszDataName,
                                                        pInputData,
                                                        cbInputData,
                                                        pOutputData,
                                                        cbOutputData,
                                                        pcbOutputNeeded);

    DeletePortFromSpoolerEnd(pIniPort, pIniSpooler, *pdwStatus == ERROR_SUCCESS);
    rc = TRUE;

Cleanup:

    return rc;
}




BOOL
XcvAddPort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    BOOL        rc;
    PINIMONITOR pIniMonitor = NULL;
    PINIPORT    pIniPort    = NULL;


    EnterSplSem();
    pIniMonitor = FindMonitor(pIniXcv->pszName, pIniSpooler);
    LeaveSplSem();


    if (pIniMonitor) {
        *pdwStatus = (*pIniXcv->pMonitor2->pfnXcvDataPort)( pIniXcv->hXcv,
                                                            pszDataName,
                                                            pInputData,
                                                            cbInputData,
                                                            pOutputData,
                                                            cbOutputData,
                                                            pcbOutputNeeded);

        if (*pdwStatus == ERROR_SUCCESS) {
            EnterSplSem();

            //
            // Check to see if we have a placeholder port by the same name. If we
            // do this set this as the monitor and revoke its placeholder status.
            // 
            pIniPort = FindPort(pInputData, pIniSpooler);

            if (pIniPort && pIniPort->Status & PP_PLACEHOLDER)
            {
                pIniPort->pIniMonitor =     pIniMonitor;
                pIniPort->Status      |=    PP_MONITOR;
                pIniPort->Status      &=    ~PP_PLACEHOLDER;
            }
            else
            {
                CreatePortEntry((PWSTR) pInputData, pIniMonitor, pIniSpooler);
            }
                         
            LeaveSplSem();
        }

        rc = TRUE;

    } else {
        SetLastError(ERROR_INVALID_NAME);
        rc = FALSE;
    }

    return rc;
}


BOOL
ValidateXcvHandle(
    PINIXCV pIniXcv
)
{
    BOOL    ReturnValue;

    try {
        if (!pIniXcv || pIniXcv->signature != XCV_SIGNATURE) {
            ReturnValue = FALSE;
        } else {
            ReturnValue = TRUE;
        }
    }except (1) {
        ReturnValue = FALSE;
    }

    if ( !ReturnValue )
        SetLastError( ERROR_INVALID_HANDLE );

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:

    DDK version of local.h

Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#endif
// @@END_DDKSPLIT


#define READTHREADTIMEOUT                5000
#define READ_THREAD_EOJ_TIMEOUT         60000   // 1 min
#define READ_THREAD_ERROR_WAITTIME       5000   // 5 sec
#define READ_THREAD_IDLE_WAITTIME       30000   // 30 sec

#define ALL_JOBS                    0xFFFFFFFF


// ---------------------------------------------------------------------
// EXTERN VARIABLES
// ---------------------------------------------------------------------
extern  HANDLE              hInst;
extern  DWORD               dwReadThreadErrorTimeout;
extern  DWORD               dwReadThreadEOJTimeout;
extern  DWORD               dwReadThreadIdleTimeoutOther;

extern  CRITICAL_SECTION    pjlMonSection;
extern  DWORD SplDbgLevel;


// ---------------------------------------------------------------------
// FUNCTION PROTOTYPE
// ---------------------------------------------------------------------
VOID
EnterSplSem(
   VOID
    );

VOID
LeaveSplSem(
   VOID
    );

VOID
SplInSem(
   VOID
    );

VOID
SplOutSem(
    VOID
    );

DWORD
UpdateTimeoutsFromRegistry(      
    IN HANDLE      hPrinter,
    IN HKEY        hKey,
    IN PMONITORREG pMonitorReg
    );

PINIPORT
FindIniPort(
   IN LPTSTR pszName
    );

PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    );

VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    );

VOID
FreeIniJobs(
    PINIPORT pIniPort
    );

VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    );
VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    );

// @@BEGIN_DDKSPLIT
// ---------------------------------------------------------------------
// UNICODE TO ANSI MACRO
// ??? !!! we should get rid of these sooner or later
// ---------------------------------------------------------------------
// @@END_DDKSPLIT
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

LPSTR
mystrrchr(
    LPSTR cs,
    char c
);

LPSTR
mystrchr(
    LPSTR cs,
    char c
);

int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
);


// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

extern  CRITICAL_SECTION    pjlMonSection;

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT

/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DEBUG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}


#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define SPLASSERT(exp)
#endif

#endif
// @@END_DDKSPLIT

//
// Needed by DDK
//
// @@BEGIN_DDKSPLIT
/*
// @@END_DDKSPLIT
#define DBGMSG(x,y)
#define SPLASSERT(exp)
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\parsepjl.c ===
/* dhi - When stable remove all #if DAN and #if FOR_WIN_TESTING sections 
   and leave in #if FOR_WIN sections.  Then get rid of these defines.
*/
#define DEBUGOUTPUT 0
#define FOR_WIN 1

/*++

Copyright (c) 1994 - 1996  Microsoft Corporation

Module Name:
    PARSEPJL.C
Abstract:
    Handles parsing of PJL printer response streams into token\value pairs.

--*/


/*
Currently returns tokens for (see enum in parsepjl.h for token values):
@PJL ECHO MSSYNC # ->#

@PJL INFO MEMORY
TOTAL=#   ->#
LARGEST=# ->#

@PJL INFO STATUS
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

@PJL INQUIRE INTRAY?SIZE   (? is 1,2,3 or 4)
LEGAL(or other PJL paper size) ->constant from DM... list in PRINT.H 

@PJL INFO CONFIG
MEMORY=# ->#
  
@PJL USTATUS JOB
END -> returns token with zero for value
  
@PJL USTATUS JOB
NAME="MSJOB #" ->#

added

@PJL USTATUS DEVICE
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

*/

#include "precomp.h"

// VOID cdecl DbgMsg( LPSTR MsgFormat, ... );


#define FF 12
#define CR 13
#define LF 10
#define TAB 9
#define SPACE 32

#define OK_IF_FF_FOUND    TRUE
#define ERROR_IF_FF_FOUND FALSE
#define TOKEN_BASE_NOT_USED 0
#define ACTION_NOT_USED 0
#define PARAM_NOT_USED 0
/* returned as value for TOKEN_USTATUS_JOB_END */
#define VALUE_RETURED_FOR_VALUELESS_TOKENS  0  

extern KeywordType readBackCommandKeywords[]; 
extern KeywordType infoCatagoryKeywords[]; 
extern KeywordType inquireVariableKeywords[];
extern KeywordType traySizeKeywords[];
extern KeywordType echoKeywords[];
extern KeywordType infoConfigKeywords[];
extern KeywordType ustatusKeywords[];
extern KeywordType ustatusJobKeywords[];
extern KeywordType ustatusDeviceKeywords[];

/* Fuctions called when a string in keyword is found */
void TokenFromParamValueFromNumberFF
   (ParseVarsType *pParseVars, ParamType);
void SetNewList(ParseVarsType *pParseVars,
   ParamType);
void GetTotalAndLargestFF(ParseVarsType *pParseVars,ParamType param);
void GetCodeAndOnlineFF(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParamFF(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromNumberEOLFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromBooleanEOL(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromStringEOL(ParseVarsType *pParseVars,ParamType param);


/* Fuctions called when no string in a keywords list is found */
void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars);
void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars);


/* Helper Functions */
void StoreToken(ParseVarsType *pParseVars, DWORD dwToken);
BOOL StoreTokenValueAndAdvancePointer
   (ParseVarsType *pParseVars, UINT_PTR dwValue);
void  ExpectFinalCRLFFF(ParseVarsType *pParseVars);
BOOL  SkipPastNextCRLF(ParseVarsType *pParseVars);
int GetPositiveInteger(ParseVarsType *pParseVars);
BOOL AdvancePointerPastString
   (ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipOverSpaces(ParseVarsType *pParseVars);
int LookForKeyword(ParseVarsType *pParseVars);
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipPastFF(ParseVarsType *pParseVars);
void ExpectFinalFF(ParseVarsType *pParseVars);

/* Helper Strings */
char lpCRLF[] = "\r\n";
char lpQuoteCRLF[] = "\"\r\n";

/*
Below are the Lists that drive the parsing.  The main loop of this 
parser looks through the keywords in the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If a FF is found in the input stream rather than a keyword, then the 
parser returns.  The return value is determined using the bFormFeedOk 
element of the ListType structure.

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

The tokenBaseValue element is a number to which the index in the
keyword's list of strings will added to calculate the token number 
corresponding to the indexed string.
*/

ListType readBackCommandList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   readBackCommandKeywords /* INFO, ECHO, INQUIRE ... */
   };

ListType infoCatagoryList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   infoCatagoryKeywords  /* MEMORY STATUS CONFIG ... */
   };


ListType infoConfigList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES, 
   PJL_TOKEN_INFO_CONFIG_BASE, 
   infoConfigKeywords  /* MEMORY= ... */
   };

ListType inquireVariableList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_INQUIRE_BASE, 
   inquireVariableKeywords /* INTRAY1SIZE ...*/
   };


ListType echoList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   echoKeywords /* MSSYNC ...*/
   };


ListType traySizeList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   traySizeKeywords /* LEGAL, C5 ...*/
   };

ListType ustatusList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusKeywords  /* JOB ... */
   };


ListType ustatusJobList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusJobKeywords  /* END ... */
   };

ListType ustatusDeviceList =
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_DEVICE_BASE,
   ustatusDeviceKeywords  /* END ... */
   };


/* Command strings that can follow @PJL USTATUS */
KeywordType ustatusKeywords[] = 
   {
      {"JOB\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusJobList},
      {"DEVICE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
//    {"DEVICE\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"TIMED\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
      NULL
   };                


/* Command strings that can follow @PJL USTATUS JOB */
KeywordType ustatusJobKeywords[] = 
   {
      {"END\r\n", ACTION_SET_VALUE_FROM_PARAM, VALUE_RETURED_FOR_VALUELESS_TOKENS},
      {"NAME=\"MSJOB ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpQuoteCRLF},
      NULL
   };                


/* command strings that can follow @PJL USTATUS DEVICE */
KeywordType ustatusDeviceKeywords[] =
   {
      {"CODE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DISPLAY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL, (struct ListTypeTag *)lpCRLF},
      {"ONLINE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL, (struct ListTypeTag *)lpCRLF},
      NULL
   };


/* Command strings that can follow @PJL */
KeywordType readBackCommandKeywords[] = 
   {
      {"INFO", ACTION_SET_NEW_LIST, &infoCatagoryList},
      {"ECHO", ACTION_SET_NEW_LIST, &echoList},
      {"INQUIRE", ACTION_SET_NEW_LIST, &inquireVariableList},
      {"USTATUS", ACTION_SET_NEW_LIST, &ustatusList},
      NULL
   };                


/* Command strings that can follow @PJL ECHO (Microsoft specific-NOT PJL!) */
KeywordType echoKeywords[] = 
   {
      {"MSSYNC", ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF, 
         (struct ListTypeTag *)TOKEN_ECHO_MSSYNC_NUMBER},
      NULL
   };                

/* Catagory strings that can follow @PJL INFO */
KeywordType infoCatagoryKeywords[] = 
   {
      {"MEMORY\r\n", ACTION_GET_TOTAL_AND_LARGEST_FF, PARAM_NOT_USED},
      {"STATUS\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"CONFIG\r\n", ACTION_SET_NEW_LIST, &infoConfigList},
      NULL
   };

/* Catagory strings that can follow @PJL INFO */
KeywordType infoConfigKeywords[] = 
   {
      {"MEMORY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"MEMORY = ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DUPLEX", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)TRUE},
      NULL
   };

/* TRUE or FALSE strings */
KeywordType FALSEandTRUEKeywords[] = 
   {
      {"FALSE", ACTION_NOT_USED, PARAM_NOT_USED},
      {"TRUE",  ACTION_NOT_USED, PARAM_NOT_USED},
      NULL
   };

/* strings that can follow @PJL INQUIRE */
KeywordType inquireVariableKeywords[] = 
   {
      {"INTRAY1SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY2SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY3SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY4SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      NULL
   };

/* strings that can follow @PJL INQUIRE INTRAY?SIZE */
/* the parameters are the Microsoft defined token values for paper size */
KeywordType traySizeKeywords[] =
   {
      {"LETTER",    ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LETTER},
      {"LEGAL",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LEGAL},
      {"A4",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_A4},
      {"EXECUTIVE", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_EXECUTIVE},
      {"COM10",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_10},
      {"MONARCH",   ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_MONARCH},
      {"C5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_C5},
      {"DL",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_DL},
      {"B5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_B5},
      NULL
   };

void (*pfnNotFoundActions[])(ParseVarsType *pParseVars) = 
   {
   ActionNotFoundSkipPastFF,
   ActionNotFoundSkipCFLFandIndentedLines
   };


void (*pfnFoundActions[])(ParseVarsType *pParseVars, ParamType param) = 
   {
   TokenFromParamValueFromNumberFF,
   SetNewList,
   GetTotalAndLargestFF,
   GetCodeAndOnlineFF,
   GetTokenFromIndexSetNewList,
   SetValueFromParamFF,
   GetTokenFromIndexValueFromNumberEOLFromParam,
   SetValueFromParam,
   GetTokenFromIndexValueFromBooleanEOL,
   GetTokenFromIndexValueFromStringEOL
   };

PJLTOPRINTERSTATUS PJLToStatus[] =
{
    { 10001,0x0 },  // clear status - printer is ready
    { 10002,0x0 },  // clear status - check ONLINE=TRUE or FALSE
    { 11002,0x0 },  // LJ4 sends this code for 00 READY
    { 40022,PORT_STATUS_PAPER_JAM    },
    { 40034,PORT_STATUS_PAPER_PROBLEM},
    { 40079,PORT_STATUS_OFFLINE      },
    { 40019,PORT_STATUS_OUTPUT_BIN_FULL},

    { 10003,PORT_STATUS_WARMING_UP   },
    { 10006,PORT_STATUS_TONER_LOW    },
    { 40038,PORT_STATUS_TONER_LOW    },

    { 30016,PORT_STATUS_OUT_OF_MEMORY},
    { 40021,PORT_STATUS_DOOR_OPEN    },
    { 30078,PORT_STATUS_POWER_SAVE   },

    //
    // Entries added by MuhuntS
    //
    { 41002, PORT_STATUS_PAPER_PROBLEM}, // Load plain
    { 35078, PORT_STATUS_POWER_SAVE},
    {0, 0}

};


#if FOR_WIN
#else
/*
test not enough room for tokens
test no FF
test zero before end
*/
main ()
{
char pInString[] = "@PJL USTATUS DEVICE\r\nCODE=25008\r\n\f\
@PJL USTATUS DEVICE\r\n\CODE=20020\r\n\f\
@PJL ECHO MSSYNC 1234567\r\n\f\
@PJL INFO CONFIG\r\n\
IN TRAYS [1 ENUMERATED]\r\n\
\tINTRAY1 PC\r\n\
OUT TRAYS [1 ENUMERATED]\r\n\
\tNORMAL FACEDOWN\r\n\
PAPERS [10 ENUMERATED]\r\n\
\tLETTER\r\n\
\tLEGAL\r\n\
\tA4\r\n\
LANGUAGES [1 ENUMERATED]\r\n\
\tPCL\r\n\
MEMORY=2097152\r\n\
DISPLAY LINES=1\r\n\
DISPLAY CHARACTER SIZE=16\r\n\f\
@PJL INQ";



//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"MSJOB 3\"\r\nPAGES=3\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"JOB 14993\"\r\nPAGES=3\r\n\f$"; //good command 1 token
/*
char pInString[] = "@PJL INFO CONFIG\r\nINTRAYS [3 ENUMERATED]\r\n\tINTRAY1\
 MP\r\n\tINTRAY2 PC\r\n\tINTRAY3 LC\r\nENVELOPE TRAY\r\nMEMORY=2087152\r\n\
DISPLAY LINES=1\r\n\f$"; //good command 1 token
*/
//char pInString[] = "@PJL INQUIRE INTRAY3SIZE\r\nC5\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL INFO STATUS\r\nCODE=10001\r\n\DISPLAY=\"00 READY\"\r\nONLINE=TRUE\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJL INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJG INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\f$"; //bad command Fail
//char pInString[] = "@PJG ECHO MSSYNC 12T4567\r\n\f$";     //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\000\f$"; //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\f$";     //bad MS command Fail
//char pInString[] = "@PJL ECHO MSSYNC 1234567\r\n\f$";     //good command Success 1 token
//char pInString[] = "@PJL ECHO 124567\r\n\f$";             //good command Success 0 token
TokenPairType tokenPairs[20];
DWORD nTokenParsedRet;
LPSTR lpRet;
DWORD i;
DWORD status;


status = GetPJLTokens(pInString, 20, tokenPairs, &nTokenParsedRet, &lpRet);

switch (status)
   {
   case STATUS_REACHED_END_OF_COMMAND_OK:
      {
      printf("STATUS_REACHED_END_OF_COMMAND_OK\n");
      break;
      }
   case STATUS_CONTINUE:
      {
      printf("STATUS_CONTINUE\n");
      break;
      }
   case STATUS_REACHED_FF:
      {
      printf("STATUS_REACHED_FF\n");
      break;
      }
   case STATUS_END_OF_STRING;
      {
      printf("STATUS_END_OF_STRING\n");
      break;
      }
   case STATUS_SYNTAX_ERROR:
      {
      printf("STATUS_SYNTAX_ERROR\n");
      break;
      }
   case STATUS_ATPJL_NOT_FOUND:
      {
      printf("STATUS_ATPJL_NOT_FOUND\n");
      break;
      }
   case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
      {
      printf("STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n");
      break;
      }
   default:
      {
      printf("INVALID STATUS RETURNED!!!!!!\n");
      break;
      }
   };

printf(" length of command=%d, numberOfTokens=%d\n", lpRet-pInString, nTokenParsedRet);
for (i=0; i<nTokenParsedRet; i++)
   {
   printf("  Token=0x%x, Value=%d\n", tokenPairs[i].token, tokenPairs[i].value);
   }

if (*lpRet==0)
   {
   printf(" Next char is terminator\n");
   }
else
   {
   printf(" Next char=%c\n", *lpRet);
   }

exit(0);
}
#endif


/* GetPJLTokens 
This function parses a single ASCII PJL command and returns token/value pairs.
Complete PJL commands must begin with '@PJL' and end with a <FF>.

The function result returns one of the following values:
   0 = STATUS_REACHED_END_OF_COMMAND_OK
   1 = STATUS_END_OF_STRING
   2 = STATUS_SYNTAX_ERROR
   3 = STATUS_ATPJL_NOT_FOUND,
   4 = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS

Also returned through the parameters are:
 1] *plpInPJL:
    If STATUS_REACHED_END_OF_COMMAND_OK
      will point to the character past the first <FF> (FF = form feed).
    If STATUS_END_OF_STRING
      will point to the terminator that was found before any <FF>.
    Else
      undefined 
  
 2] *pnTokenParsed will contain the number of pairs returned in *pToken.

 3] pToken will contain *pnTokenParsed  token pairs  

If there are characters belonging to another command trailing the first
then the caller should call again for the new command.  If only part of
the new command may be present, then the caller may want to copy the 
characters of the new command to the beginning of the buffer, and then read 
the necessary additional characters onto the end before resubmitting the
complete command to this function for parsing.  Note that the *plpInPJL
tells the caller where the next command would begin.


If the end of the string is encountered before the trailing <FF> is found then
the function returns with *plpInPJL pointing to the terminator.
If the caller wants the command parsed into
token\value pairs it should resubmit the string once the characters 
which complete the command have been appended.


Operation:
----------
Lists drive the parsing.  The main loop of this 
parser looks through the keywords of the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

*/

DWORD GetPJLTokens(
    LPSTR lpInPJL,
    DWORD nTokenInBuffer,
    TokenPairType *pToken, 
    DWORD *pnTokenParsed,
    LPSTR *plpInPJL
)
{
   /* The parseVars variables are put into a structure so that they can be
      passed efficiently to all the helper functions.
    */
   ParseVarsType parseVars;
   BOOL bFoundKeyword;
   DWORD i, keywordIndex;
   KeywordType *pKeyword;
   DWORD dwNotFoundAction;

   /* The first list to look for is the commands that can follow
      @PJL
    */
   parseVars.arrayOfLists[0] = &readBackCommandList;
   parseVars.arrayOfLists[1] = NULL;      

   parseVars.pInPJL_Local = lpInPJL;
   parseVars.nTokenInBuffer_Local = 0;
   parseVars.nTokenLeft = nTokenInBuffer;
   parseVars.pToken_Local = pToken;
   parseVars.status = STATUS_CONTINUE;

   if (!AdvancePointerPastString(&parseVars, "@PJL"))
      {
      parseVars.status = STATUS_ATPJL_NOT_FOUND;
      }
                     
   while (parseVars.status == STATUS_CONTINUE)
      {
      /* Look for next input keyword in currently valid lists.
         Sometimes may need to look for the next input keyword in more
         then one list.
       */
      bFoundKeyword = FALSE;
      for (i=0; (parseVars.pCurrentList = parseVars.arrayOfLists[i])!=NULL; i++)
         {
         dwNotFoundAction = parseVars.pCurrentList->dwNotFoundAction;
         /* Skip over spaces to start of next keyword string */
         if ( !SkipOverSpaces(&parseVars) )
            {
            /* Either the input stream has ended or FF was found */
            if (parseVars.status == STATUS_REACHED_FF)
               {
               /* Finding a FF here may or may not be an error,
                  the field in the current list tells us which
                */  

               if ( parseVars.pCurrentList->bFormFeedOK )
                  {
                  parseVars.status = STATUS_REACHED_END_OF_COMMAND_OK;
                  }
               else
                  {
                  parseVars.status = STATUS_SYNTAX_ERROR;
                  }
               }
            break;
            }
         /* Look for keyword in current keywords */
         parseVars.pCurrentKeywords = parseVars.pCurrentList->pListOfKeywords;
         keywordIndex = LookForKeyword(&parseVars);
         if ( keywordIndex!=-1 )
            {
            bFoundKeyword = TRUE;
            break;
            }
         }

      if ( parseVars.status!=STATUS_CONTINUE )
         {
         /* We are finished processing commands */
         break;
         }

      if ( bFoundKeyword )
         /* do action from keyword */
         {
         pKeyword = &parseVars.pCurrentKeywords[keywordIndex];
         (*pfnFoundActions[pKeyword->dwAction])(&parseVars, pKeyword->param);
         }
      else
         /* do not found action from list */
         {
         (*pfnNotFoundActions[dwNotFoundAction])(&parseVars);
         }
      } 

   /* We are done parsing the input command, now we return the information */
#if DEBUGOUTPUTDEBUG
 DbgMsg("ParseVars.status = %d\n", parseVars.status);
#endif

   /* Fill in returned values and return with success */
   *pnTokenParsed = parseVars.nTokenInBuffer_Local;
   *plpInPJL = parseVars.pInPJL_Local;

   return(parseVars.status);
}


/* 
int LookForKeyword(ParseVarsType *pParseVars)

This function looks through the current keyword list in search of a 
keyword that matches the characters in the input stream pointed to 
by pParseVars->pInPJL_Local.

If a match is found:
        The index of the match in the pKeyword is returned.
        pParseVars->pInPJL_Local is advanced past the last matching character.
        pParseVars->dwKeywordIndex is set to item number in list

If no match is found:
        The return value is -1.
        pParseVars->pInPJL_Local is unchanged.
*/
int LookForKeyword(ParseVarsType *pParseVars)
{
LPSTR   pInStart = pParseVars->pInPJL_Local;
LPSTR   pIn;
DWORD   dwKeywordIndex = 0;
BOOL    bFoundMatch = FALSE;
BYTE    c;
KeywordType *pKeywords = pParseVars->pCurrentKeywords;
LPSTR   pKeywordString;

while ( (pKeywordString=pKeywords[dwKeywordIndex++].lpsz)!=NULL )
   {
#if DEBUGOUTPUT
 DbgMsg("LookForIn=%hs\n", pInStart);
 DbgMsg(" Keyword=%hs\n", pKeywordString);
#endif
   pIn = pInStart;
   while ( (c=*pKeywordString++)!=0 )
      {
      if ( c!=*pIn++ )
         {
         break;
         }
      }

   if ( c==0 )
      {
      bFoundMatch = TRUE;
      pParseVars->pInPJL_Local = pIn;
      pParseVars->dwFoundIndex = dwKeywordIndex-1;
      break;
      }
   }
#if DEBUGOUTPUT
 DbgMsg("LookForOut=%hs\n", pParseVars->pInPJL_Local);
#endif
return( (bFoundMatch)?dwKeywordIndex-1:-1 );
}


/*
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)

This function looks through the input stream for a match with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
*/
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) )
      {
      if ( s==in )
         {
         pS++; /* point to next char in string to look for match */
         }
      else
         {
         pS = pString; /* start over looking for start of string */
         }
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }

   if ( in==FF )
      {
      pParseVars->status = STATUS_REACHED_FF;
      pParseVars->pInPJL_Local = pIn+1;
      }
   else
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      } 

   return(FALSE);
}



/*
BOOL SkipOverSpaces(ParseVarsType &parseVars) 
This function skips over spaces in the input stream until a non-space
character (FF and NULL are special cases) is found.

If a non-space character is found then 
   pParseVars->pInPJL_Local is set to point to the first non-space char.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before a non-space char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered before a non-space character is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipOverSpaces(ParseVarsType *pParseVars) 
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)==SPACE)&&(in!=0)&&(in!=FF) )
      {
      pIn++;
      }
   
   switch (in)
      {
      case FF:
         {
         pParseVars->status = STATUS_REACHED_FF;
         pParseVars->pInPJL_Local = pIn+1;
         return(FALSE);
         }
      case 0:
         {
         pParseVars->status = STATUS_END_OF_STRING;
         pParseVars->pInPJL_Local = pIn;
         return(FALSE);
         }
      default:
         {
         /* point to character after string in input */
         pParseVars->pInPJL_Local = pIn;
         return(TRUE);
         }
      }
}


void TokenFromParamValueFromNumberFF(
   ParseVarsType *pParseVars,ParamType param)
{
   int value;

   StoreToken(pParseVars, param.token);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars)
{
   if ( SkipPastFF(pParseVars) )
      {
      pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK;
      }
   return;
}

/*
BOOL SkipPastFF(ParseVarsType *pParseVars)
This function skips over all characters until either a zero is found or
FF is found.

If the end of input is encountered before an FF char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered 
   the return value is TRUE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipPastFF(ParseVarsType *pParseVars)
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)!=FF)&&(in!=0) )
      {
      pIn++;
      }
   
   if ( in==0 )
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      return(FALSE);
      }
   pParseVars->pInPJL_Local = pIn+1;
   pParseVars->status = STATUS_REACHED_FF;
   return(TRUE);
}

void ExpectFinalCRLFFF(ParseVarsType *pParseVars)
{
   char c;

   if ( pParseVars->status==STATUS_CONTINUE )
      {
      c=*pParseVars->pInPJL_Local;
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         return;
         }
   
      if ( !AdvancePointerPastString(pParseVars, lpCRLF) )
         {
         if ( pParseVars->status==STATUS_REACHED_FF )
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         return;
         }
      ExpectFinalFF(pParseVars);
      }
   return;
}



void ExpectFinalFF(ParseVarsType *pParseVars)
{
   if ( pParseVars->status==STATUS_CONTINUE )
      {
      if ( *pParseVars->pInPJL_Local==FF )
         {
         pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK; 
         pParseVars->pInPJL_Local++;
         }
      else
         {
         if ( *pParseVars->pInPJL_Local==0 )
            {
            pParseVars->status = STATUS_END_OF_STRING;
            }
         else
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         }
      }
   return;
}


/*
int GetPositiveInteger(ParseVarsType *pParseVars)
This function skips spaces and then interprets all the digits in input stream
as a positive integer.

If digits follow any spaces and they are not terminated by a zero then
   the return value is the positive integer.

If the first character following spaces in not a digit or the end of 
string is encountered then 
   -1 is returned as the value 
   pParseVars->status is set to STATUS_SYNTAX_ERROR
   
Note: does not check for overflow
*/
int GetPositiveInteger(ParseVarsType *pParseVars)
{
   int   value;
   LPSTR pIn; 
   BYTE  c;

   if ( !SkipOverSpaces(pParseVars) )
      {
      if ( pParseVars->status == STATUS_REACHED_FF )
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(-1);
      }
   
   pIn = pParseVars->pInPJL_Local;
   for ( value=0; ((c=*pIn++)>='0')&&(c<='9'); value=value*10+(c-'0') );
   if ( (c==0)||(pIn==pParseVars->pInPJL_Local+1) )
      {
      /* either end of string encountered or no digits found */
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         }
      else
         {   
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      pParseVars->pInPJL_Local = pIn-1;
      return(-1);
      }
   pParseVars->pInPJL_Local = pIn-1;
   return(value);
}



void SetNewList(ParseVarsType *pParseVars, ParamType param)
{
   pParseVars->arrayOfLists[0] = param.pList;
   pParseVars->arrayOfLists[1] = NULL;
   return;
}  

void StoreToken(ParseVarsType *pParseVars, DWORD dwToken)
{
   pParseVars->dwNextToken = dwToken;
   return;
}

BOOL StoreTokenValueAndAdvancePointer(ParseVarsType *pParseVars, UINT_PTR dwValue)
{
   if ( pParseVars->nTokenLeft==0 )
      {
      pParseVars->status = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS;
      return(FALSE);
      }
   pParseVars->pToken_Local->token = pParseVars->dwNextToken;
   pParseVars->pToken_Local->value = dwValue;
   pParseVars->pToken_Local++;
   pParseVars->nTokenInBuffer_Local++;
   pParseVars->nTokenLeft--;
   return(TRUE);
}


void GetTotalAndLargestFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars, "TOTAL=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_TOTAL);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nLARGEST=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_LARGEST);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void GetCodeAndOnlineFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars,"CODE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_CODE);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nDISPLAY=") )
      {
      return;
      }
   if ( !SkipPastNextCRLF(pParseVars) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "ONLINE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_ONLINE);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;
   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


/*
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)

This function looks for a match of the current stream 
position with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) && (s==in) )
      {
      pS++; 
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }
   
   pParseVars->status = ( in!=0 )?
      STATUS_SYNTAX_ERROR:STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
   return(FALSE);
}




/*
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)

This function positions the stream pointer past the next
CRLF.

If a CRLF is found:
   pParseVars->pInPJL_Local is set to point just past the CRLF.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the CRLF is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the CRLF is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)
{
   if ( !AdvancePointerPastString(pParseVars, "\r\n") )
      {
      if ( pParseVars->status == STATUS_REACHED_FF)
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(FALSE);
      }
   return(TRUE);
}


void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars, ParamType param)
{
   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   SetNewList(pParseVars, param);
   return;
}


void SetValueFromParamFF(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


void SetValueFromParam(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   return;
}

void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars)
{
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF In=%hs\n", pParseVars->pInPJL_Local);
#endif
   do
      {
      if ( !SkipPastNextCRLF(pParseVars) )
         {
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF error skipping\n");
#endif
         return;
         }
      } while (*pParseVars->pInPJL_Local==TAB);
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF Out=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;      
}

void GetTokenFromIndexValueFromNumberEOLFromParam
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromNumberIn=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
#if DEBUGOUTPUT
 DbgMsg("error getting number\n");
#endif
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
#if DEBUGOUTPUT
 DbgMsg("error storing value\n");
#endif
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromNumberOut=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}

void GetTokenFromIndexValueFromBooleanEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromBooleanEOLin=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;

   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromBooleanEOLout=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}

void GetTokenFromIndexValueFromStringEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromStringEOLin=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);

   if ( !StoreTokenValueAndAdvancePointer(pParseVars, (UINT_PTR)pParseVars->pInPJL_Local))
      {
      return;
      }
   SkipPastNextCRLF(pParseVars);
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromStringEOLout=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\parsepjl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved

Module Name:

    parsepjl.h

Abstract:

    Header file for PJL parser

--*/

#define MAX_POSSIBLE_LISTS_IN_BRANCH 2

/* Note: new actions must be added at end, and new functions at the
end of the function pointer array defined later in this file */
enum ParseActionsEnumTag 
   {
   ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF,
   ACTION_SET_NEW_LIST,
   ACTION_GET_TOTAL_AND_LARGEST_FF,
   ACTION_GET_CODE_AND_ONLINE_FF,
   ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST,
   ACTION_SET_VALUE_FROM_PARAM_FF,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM,   
   ACTION_SET_VALUE_FROM_PARAM,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL
   };



/* Note: new actions must be added at end, and new functions at the
   end of the function pointer array defined later in this file 
*/
enum ParseNotFoundActionsEnumTag 
   {
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES
   };



/* Note: The order of some of the Token values is related to 
   indexes in the keyword lists.  Always add new token values
   to the end of BASE group.
*/
enum pjl_token_variables_tag
   {

   PJL_TOKEN_INQUIRE_BASE = 0x10000,
   TOKEN_INQUIRE_TRAY1SIZE = 0x10000,
   TOKEN_INQUIRE_TRAY2SIZE,
   TOKEN_INQUIRE_TRAY3SIZE,
   TOKEN_INQUIRE_TRAY4SIZE,

   PJL_TOKEN_ECHO_BASE = 0x20000,
   TOKEN_ECHO_MSSYNC_NUMBER = 0x20000,

   PJL_TOKEN_INFO_MEMORY_BASE = 0x30000,
   TOKEN_INFO_MEMORY_TOTAL   = 0x30000,
   TOKEN_INFO_MEMORY_LARGEST,

   PJL_TOKEN_INFO_STATUS_BASE = 0x40000,
   TOKEN_INFO_STATUS_CODE = 0x40000,
   TOKEN_INFO_STATUS_ONLINE,

   PJL_TOKEN_INFO_CONFIG_BASE = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY_SPACE,

   PJL_TOKEN_USTATUS_JOB_BASE = 0x60000,
   TOKEN_USTATUS_JOB_END = 0x60000,
   TOKEN_USTATUS_JOB_NAME_MSJOB,

   PJL_TOKEN_USTATUS_DEVICE_BASE = 0x70000,
   TOKEN_USTATUS_DEVICE_CODE = 0x70000,
   TOKEN_USTATUS_DEVICE_DISPLAY,
   TOKEN_USTATUS_DEVICE_ONLINE,
   };

/* The first 5 values are the possible return values for GetPJLTokens() */
/* The last 2 values are used internally */
enum status_tag
   {
   STATUS_REACHED_END_OF_COMMAND_OK,
   STATUS_END_OF_STRING,
   STATUS_SYNTAX_ERROR,
   STATUS_ATPJL_NOT_FOUND,
   STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS,

   STATUS_REACHED_FF,
   STATUS_CONTINUE
   };

typedef struct
   {
   DWORD    token;
   UINT_PTR value;
   } TOKENPAIR, * PTOKENPAIR, TokenPairType;

typedef struct ParamTypeTag
   {
   union 
      {
      struct ListTypeTag *pList;
      DWORD token;
      DWORD value;
      struct KeywordTypeTag *pListOfKeywords; 
      LPSTR lpstr;
      };  
   } ParamType;

typedef struct KeywordTypeTag 
   {
   LPSTR lpsz;
   DWORD dwAction;
   ParamType param;
   } KeywordType;

typedef struct ListTypeTag
   {
   BOOL  bFormFeedOK;
   DWORD dwNotFoundAction;
   DWORD tokenBaseValue;
   KeywordType *pListOfKeywords; 
   } ListType;

typedef struct parseVarsTag
   {
   LPSTR        pInPJL_Local;
   DWORD        nTokenLeft;
   DWORD        nTokenInBuffer_Local;
   TokenPairType *pToken_Local;
   DWORD        dwNextToken;
   DWORD        dwFoundIndex;
   DWORD        status; 
   ListType     *pCurrentList;
   KeywordType  *pCurrentKeywords;
   ListType     *arrayOfLists[MAX_POSSIBLE_LISTS_IN_BRANCH+1]; 
   } ParseVarsType;



extern DWORD GetPJLTokens(LPSTR lpInPJL, DWORD nTokenInBuffer, 
   TokenPairType *pToken, DWORD *pnTokenParsed, LPSTR *plpInPJL);

typedef struct
    {
    DWORD   pjl;
    DWORD   status;
    } PJLTOPRINTERSTATUS;

extern PJLTOPRINTERSTATUS PJLToStatus[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\precomp.h ===
/*++

Copyright (c) 1994 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include "spltypes.h"
#include "local.h"
#include "parsepjl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\1394port.cpp ===
// 1394Port.cpp: implementation of the C1394Port class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

C1394Port::C1394Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, csz1394PortDesc )

{
   // Basically let the default constructor do the work.
}

C1394Port::~C1394Port()
{

}

PORTTYPE C1394Port::getPortType()
{
   return P1394PORT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\pjlmon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved


Module Name:

Abstract:

Author:

Revision History:

--*/

#define USECOMM

#include "precomp.h"
#include <winioctl.h>
#include <ntddpar.h>


// ---------------------------------------------------------------------
// PROTO, CONSTANT, and GLOBAL
//
// ---------------------------------------------------------------------

DWORD   ProcessPJLString(PINIPORT, CHAR *, DWORD *);
VOID    ProcessParserError(DWORD);
VOID    InterpreteTokens(PINIPORT, PTOKENPAIR, DWORD);
BOOL    IsPJL(PINIPORT);
BOOL    WriteCommand(HANDLE, LPSTR);
BOOL    ReadCommand(HANDLE);

#define WAIT_FOR_WRITE                  100 // 0.1 sec
#define WAIT_FOR_DATA_TIMEOUT           100 // 0.1 sec
#define WAIT_FOR_USTATUS_THREAD_TIMEOUT 500 // 0.5 sec
#define GETDEVICEID                     IOCTL_PAR_QUERY_DEVICE_ID
#define MAX_DEVID                       1024

static TCHAR   cszInstalledMemory[]    = TEXT("Installed Memory");
static TCHAR   cszAvailableMemory[]    = TEXT("Available Memory");

BOOL
DllMain(
    IN HANDLE   hModule,
    IN DWORD    dwReason,
    IN LPVOID   lpRes
    )
/*++

Routine Description:
    Dll entry point

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&pjlMonSection);
            DisableThreadLibraryCalls(hModule);
            break;

        default:
            // do nothing
            ;
    }

    return TRUE;
}


VOID
ClearPrinterStatusAndIniJobs(
    PINIPORT    pIniPort
    )
{
    PORT_INFO_3 PortInfo3;

    if ( pIniPort->PrinterStatus ||
         (pIniPort->status & PP_PRINTER_OFFLINE) ) {

        pIniPort->PrinterStatus = 0;
        pIniPort->status &= ~PP_PRINTER_OFFLINE;

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        SetPort(NULL, pIniPort->pszPortName, 3, (LPBYTE)&PortInfo3);
    }

    SendJobLastPageEjected(pIniPort, ALL_JOBS, FALSE);
}


VOID
RefreshPrinterInfo(
    PINIPORT    pIniPort
    )
{
    //
    // Only one thread should write to the printer at a time
    //
    if ( WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->DoneWriting,
                                              WAIT_FOR_WRITE) ) {

        return;
    }

    //
    // If printer is power cycled and it does not talk back (but answers
    // PnP id) we got to clear the error on spooler to send jobs
    //
    ClearPrinterStatusAndIniJobs(pIniPort);
    if ( !IsPJL(pIniPort) ) {

        pIniPort->status &= ~PP_IS_PJL;
    }

    SetEvent(pIniPort->DoneWriting);
}


VOID
UstatusThread(
    HANDLE hPort
)
/*++

Routine Description:
    Unsolicited status information thread. This thread will continue to
    read unsolicited until it's asked to terminate, which will happen
    under one of these conditions:
        1) Receive EOJ confirmation from the printer.
        2) Timeout waiting for EOJ confirmation.
        3) The port is been closed.

Arguments:
    hPort   : IniPort structure for the port

Return Value:

--*/
{
    PINIPORT        pIniPort = (PINIPORT)((INIPORT *)hPort);
    HANDLE          hToken;

    DBGMSG (DBG_TRACE, ("Enter UstatusThread hPort=%x\n", hPort));

    SPLASSERT(pIniPort                              &&
              pIniPort->signature == PJ_SIGNATURE   &&
              (pIniPort->status & PP_THREAD_RUNNING) == 0);

    if ( IsPJL(pIniPort) )
        pIniPort->status |= PP_IS_PJL;


    SetEvent(pIniPort->DoneWriting);

    if ( !(pIniPort->status & PP_IS_PJL) )
        goto StopThread;

    //
    // manual-reset event, initially signal state
    //
    pIniPort->DoneReading = CreateEvent(NULL, TRUE, TRUE, NULL);

    if ( !pIniPort->DoneReading )
        goto StopThread;

    pIniPort->status |= PP_THREAD_RUNNING;

    pIniPort->PrinterStatus     = 0;
    pIniPort->status           &= ~PP_PRINTER_OFFLINE;
    pIniPort->dwLastReadTime    = 0;

    for ( ; ; ) {

        //
        // check if PP_RUN_THREAD has been cleared to terminate
        //
        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            if ( pIniPort->status & PP_INSTARTDOC ) {

                //
                // there's an active job, can't end the thread
                //
                pIniPort->status |= PP_RUN_THREAD;
            } else {

                DBGMSG(DBG_INFO,
                       ("PJLMon Read Thread for Port %ws Closing Down.\n",
                       pIniPort->pszPortName));

                pIniPort->status &= ~PP_THREAD_RUNNING;

                ClearPrinterStatusAndIniJobs(pIniPort);
                goto StopThread;
            }
        }

        //
        // check if the printer is bi-di
        //
        if (pIniPort->status & PP_IS_PJL) {

            (VOID)ReadCommand(hPort);

            //
            // If we are under error condition or if we have jobs pending
            // read status back from printer more frequently
            //
            if ( pIniPort->pIniJob                          ||
                 (pIniPort->status & PP_PRINTER_OFFLINE)    ||
                 (pIniPort->status & PP_WRITE_ERROR) ) {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadErrorTimeout);
            } else {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadIdleTimeoutOther);
            }

            if ( pIniPort->pIniJob &&
                 !(pIniPort->status & PP_PRINTER_OFFLINE) &&
                 !(pIniPort->status & PP_WRITE_ERROR) ) {

                //
                // Some printers are PJL bi-di, but do not send
                // EOJ. We want jobs to disappear from printman
                //
                SendJobLastPageEjected(pIniPort,
                                       GetTickCount() - dwReadThreadEOJTimeout,
                                       TRUE);
            }

            //
            // If we did not read from printer for more than a minute
            // and no more jobs talk to printer again
            //
            if ( !(pIniPort->status & PP_INSTARTDOC) &&
                 (GetTickCount() - pIniPort->dwLastReadTime) > 240000
)
                RefreshPrinterInfo(pIniPort);

        } else {

            //
            // exit the thread if printer is not PJL bi-di capable
            //
            Sleep(2000);
            pIniPort->status &= ~PP_RUN_THREAD;
#ifdef  DEBUG
            OutputDebugStringA("Set ~PP_RUN_THREAD because printer is not bi-di\n");
#endif
        }
    }

StopThread:
    pIniPort->status &= ~PP_RUN_THREAD;
    pIniPort->status &= ~PP_THREAD_RUNNING;
    CloseHandle(pIniPort->DoneReading);

    //
    // By closing the handle and then setting it to NULL we know the main
    // thread will not end up setting a wrong event
    //
    CloseHandle(pIniPort->WakeUp);
    pIniPort->WakeUp = NULL;

    DBGMSG (DBG_TRACE, ("Leave UstatusThread\n"));

}


BOOL
CreateUstatusThread(
    PINIPORT pIniPort
)
/*++

Routine Description:
    Creates the Ustatus thread

Arguments:
    pIniPort    : IniPort structure for the port

Return Value:
    TRUE on succesfully creating the thread, else FALSE
--*/
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    DBGMSG(DBG_INFO, ("PJLMon Read Thread for Port %ws Starting.\n",
                      pIniPort->pszPortName));

    pIniPort->status |= PP_RUN_THREAD;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    pIniPort->WakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);

    if ( !pIniPort->WakeUp )
        goto Fail;

    ThreadHandle = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)UstatusThread,
                                pIniPort,
                                0, &ThreadId);

    if ( ThreadHandle ) {

        SetThreadPriority(ThreadHandle, THREAD_PRIORITY_LOWEST);
        CloseHandle(ThreadHandle);
        return TRUE;
    }

Fail:

    if ( pIniPort->WakeUp ) {

        CloseHandle(pIniPort->WakeUp);
        pIniPort->WakeUp = NULL;
    }

    pIniPort->status &= ~PP_RUN_THREAD;
    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave CreateUstatusThread\n"));

    return FALSE;
}


BOOL
WINAPI
PJLMonOpenPortEx(
    IN     HANDLE       hMonitor,
    IN     HANDLE       hMonitorPort,
    IN     LPWSTR       pszPortName,
    IN     LPWSTR       pszPrinterName,
    IN OUT LPHANDLE     pHandle,
    IN OUT LPMONITOR2   pMonitor
)
/*++

Routine Description:
    Opens the port

Arguments:
    pszPortName     : Port name
    pszPrinterName  : Printer name
    pHandle         : Pointer to the handle to return
    pMonitor        : Port monitor function table

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort;
    BOOL        bRet = FALSE;
    BOOL        bInSem = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonOpenPortEx (portname = %s)\n", pszPortName));


    //
    // Validate port monitor
    //
    if ( !pMonitor                  ||
         !pMonitor->pfnOpenPort     ||
         !pMonitor->pfnStartDocPort ||
         !pMonitor->pfnWritePort    ||
         !pMonitor->pfnReadPort     ||
         !pMonitor->pfnClosePort ) {


        DBGMSG(DBG_WARNING,
               ("PjlMon: Invalid port monitors passed to OpenPortEx\n"));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Cleanup;
    }

    EnterSplSem();
    bInSem = TRUE;

    //
    // Is the port open already?
    //
    if ( pIniPort = FindIniPort(pszPortName) ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    pIniPort = CreatePortEntry(pszPortName);
    LeaveSplSem();
    bInSem = FALSE;

    if ( pIniPort &&
         (*pMonitor->pfnOpenPort)(hMonitorPort, pszPortName, &pIniPort->hPort) ) {

        *pHandle = pIniPort;
        CopyMemory((LPBYTE)&pIniPort->fn, (LPBYTE)pMonitor, sizeof(*pMonitor));

        //
        // Create the ustatus thread always
        // If printer is not PJL it will die by itself
        // We do not want to write to the printer in this thread to determine
        //      printer is PJL since that may take several seconds to fail
        //
        CreateUstatusThread(pIniPort);
        bRet = TRUE;
    } else {

        DBGMSG(DBG_WARNING, ("PjlMon: OpenPort %s : Failed\n", pszPortName));
    }

Cleanup:
    if ( bInSem ) {

        LeaveSplSem();
    }
    SplOutSem();

    DBGMSG (DBG_TRACE, ("Leave PJLMonOpenPortEx bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonStartDocPort(
    IN HANDLE  hPort,
    IN LPTSTR  pszPrinterName,
    IN DWORD   dwJobId,
    IN DWORD   dwLevel,
    IN LPBYTE  pDocInfo
)
/*++

Routine Description:
    Language monitor StartDocPort

Arguments:
    hPort           : Port handle
    pszPrinterName  : Printer name
    dwJobId         : Job identifier
    dwLevel         : Level of Doc info strucuture
    pDocInfo        : Pointer to doc info structure

Return Value:
    TRUE on success, FALSE on error

--*/
{

    PINIPORT            pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB             pIniJob = NULL;
    DWORD               cbJob;
    BOOL                bRet = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonStartDocPort hPort=0x%x\n", hPort));

    //
    // Validate parameters
    //
    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ||
         !pDocInfo ||
         !pszPrinterName ||
         !*pszPrinterName ) {

        SPLASSERT(pIniPort &&
                  pIniPort->signature == PJ_SIGNATURE &&
                  pDocInfo);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwLevel != 1 ) {

        SPLASSERT(dwLevel == 1);
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Serialize access to the port
    //
    if ( pIniPort->status & PP_INSTARTDOC ) {

        SetLastError(ERROR_BUSY);
        return FALSE;
    }

    cbJob   = sizeof(*pIniJob) + lstrlen(pszPrinterName) * sizeof(TCHAR)
                               + sizeof(TCHAR);
    pIniJob = (PINIJOB) AllocSplMem(cbJob);
    if ( !pIniJob ) {

        goto Cleanup;
    }

    pIniJob->pszPrinterName = wcscpy((LPTSTR)(pIniJob+1), pszPrinterName);

    if ( !OpenPrinter(pIniJob->pszPrinterName, &pIniJob->hPrinter, NULL) ) {

        DBGMSG(DBG_WARNING,
               ("pjlmon: OpenPrinter failed for %s, last error %d\n",
                pIniJob->pszPrinterName, GetLastError()));

        goto Cleanup;
    }

    pIniPort->status |= PP_INSTARTDOC;

    bRet = (*pIniPort->fn.pfnStartDocPort)(pIniPort->hPort,
                                           pszPrinterName,
                                           dwJobId,
                                           dwLevel,
                                           pDocInfo);

    if ( !bRet ) {

        pIniPort->status &= ~PP_INSTARTDOC;
        goto Cleanup;
    }

    //
    // If Ustatus thread is not running then check if printer understands
    // PJL, unless we determined that printer does not understand PJL earlier
    //
    if ( !(pIniPort->status & PP_RUN_THREAD) &&
         !(pIniPort->status & PP_DONT_TRY_PJL) ) {

        CreateUstatusThread(pIniPort);
    }

    //
    // set PP_SEND_PJL flag here so the first write of the job
    // will try to send PJL command to initiate the job control
    //

    pIniJob->JobId = dwJobId;
    pIniJob->status |= PP_INSTARTDOC;

    EnterSplSem();
    if ( !pIniPort->pIniJob ) {

        pIniPort->pIniJob = pIniJob;
    } else {

        pIniJob->pNext = pIniPort->pIniJob;
        pIniPort->pIniJob = pIniJob;
    }
    LeaveSplSem();

    if ( pIniPort->status & PP_IS_PJL )
        pIniJob->status |= PP_SEND_PJL;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

Cleanup:

    if ( !bRet ) {

        if ( pIniJob )
            FreeIniJob(pIniJob);
    }

    DBGMSG (DBG_TRACE, ("Leave PJLMonEndDocPort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonReadPort(
    IN  HANDLE  hPort,
    OUT LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD pcbRead
)
/*++

Routine Description:
    Language monitor ReadPort

Arguments:
    hPort           : Port handle
    pBuffer         : Buffer to read data to
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return read count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL bRet;

    DBGMSG (DBG_TRACE, ("Enter PJLMonReadPort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    bRet =  (*pIniPort->fn.pfnReadPort)(pIniPort->hPort, pBuffer, cbBuf, pcbRead);

    DBGMSG (DBG_TRACE, ("Leave PJLMonReadPort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
)
/*++

Routine Description:
    Language monitor WritePort

Arguments:
    hPort           : Port handle
    pBuffer         : Data Buffer
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return written count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet;

    DBGMSG (DBG_TRACE, ("Enter PJLMonWritePort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's the fist write of the job
    //
    if ( pIniPort->pIniJob &&
         (pIniPort->pIniJob->status & PP_SEND_PJL) ) {

        // PP_SEND_PJL is set if it's the first write of the job
        char string[256];

        if ( !WriteCommand(hPort, "\033%-12345X@PJL \015\012") ) {

            return FALSE;
        }

        //
        // clear PP_SEND_PJL here if we have successfully send a PJL command.
        //
        pIniPort->pIniJob->status &= ~PP_SEND_PJL;

        //
        // set PP_PJL_SENT meaning that we have successfully sent a
        // PJL command to the printer, though it doesn't mean that
        // we will get a successfully read. PP_PJL_SENT gets cleared in
        // StartDocPort.
        //
        pIniPort->pIniJob->status |= PP_PJL_SENT;

        sprintf(string, "@PJL JOB NAME = \"MSJOB %d\"\015\012",
                    pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        WriteCommand(hPort, "@PJL USTATUS JOB = ON \015\012@PJL USTATUS PAGE = OFF \015\012@PJL USTATUS DEVICE = ON \015\012@PJL USTATUS TIMED = 30 \015\012\033%-12345X");
    }

    //
    // writing to port monitor
    //
    bRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, pBuffer,
                                       cbBuf, pcbWritten);

    if ( bRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
    }

    if ( (!bRet || pIniPort->PrinterStatus) &&
         (pIniPort->status & PP_THREAD_RUNNING) ) {

        //
        // By waiting for the UStatus thread to finish reading if there
        // is an error and printer sends unsolicited status
        // and user gets status on queue view before the win32 popup
        //
        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, INFINITE);
    }

    DBGMSG (DBG_TRACE, ("Leave PJLMonWritePort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonEndDocPort(
   HANDLE   hPort
)
/*++

Routine Description:
    Language monitor EndDocPort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB     pIniJob;

    DBGMSG (DBG_TRACE, ("Enter PJLMonEndDocPort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Find the job (which is the last)
    //
    pIniJob = pIniPort->pIniJob;

    if ( !pIniJob )
        DBGMSG(DBG_ERROR, ("No jobs?\n"));

    //
    // check if we had sent PJL command, i.e. if the printer is bi-di
    //
    if ( pIniJob && (pIniJob->status & PP_PJL_SENT) ) {

        //
        // if the printer is bi-di, tell printer to let us know when the job
        // is don't in the printer and we'll really EndDoc then. this is so
        // that we can continue to monitor the job status until the job is
        // really done in case there's an error occurs.
        // but some cheap printers like 4L, doesn't handle this EOJ command
        // reliably, so we time out if printer doesn't tell us EOJ after a
        // while so that we don't end up having the port open forever in this
        // case.
        //

        char    string[256];

        sprintf(string,
                "\033%%-12345X@PJL EOJ NAME = \"MSJOB %d\"\015\012\033%%-12345X",
                pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        pIniJob->TimeoutCount = GetTickCount();
        pIniJob->status &= ~PP_INSTARTDOC;
    }

    (*pIniPort->fn.pfnEndDocPort)(pIniPort->hPort);

    if ( pIniJob && !(pIniJob->status & PP_PJL_SENT) ) {

        //
        // This is not bi-di printer send EOJ so that spooler deletes it
        //
        SendJobLastPageEjected(pIniPort, pIniJob->JobId, FALSE);
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    // wake up the UStatus read thread if printer is bi-di

    if ( pIniPort->status & PP_THREAD_RUNNING )
        SetEvent(pIniPort->WakeUp);

    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave PJLMonEndDocPort\n"));

    return TRUE;
}


BOOL
WINAPI
PJLMonClosePort(
    HANDLE  hPort
)
/*++

Routine Description:
    Language monitor ClosePort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    DBGMSG (DBG_TRACE, ("Enter PJLMonClosePort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    //
    // Kill Ustatus thread if it is running
    //
    if (pIniPort->status & PP_RUN_THREAD) {

        pIniPort->status &= ~PP_RUN_THREAD;
#ifdef DEBUG
        OutputDebugStringA("Set ~PP_RUN_THREAD from close port\n");
#endif

        SetEvent(pIniPort->WakeUp);

        //
        // if UStatusThread is still running at this point,
        // wait utill it terminates, because we can't DeletePortEntry
        // until it terminates.
        //
        while (pIniPort->WakeUp)
            Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
    }

    if ( pIniPort->fn.pfnClosePort )
        (*pIniPort->fn.pfnClosePort)(pIniPort->hPort);

    EnterSplSem();
    DeletePortEntry(pIniPort);
    LeaveSplSem();

    DBGMSG (DBG_TRACE, ("Leave PJLMonClosePort\n"));

    return TRUE;
}


BOOL
WriteCommand(
    HANDLE hPort,
    LPSTR cmd
)
/*++

Routine Description:
    Write a command to the port

Arguments:
    hPort           : Port handle
    cmd             : Command buffer

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD cbWrite, cbWritten, dwRet;
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    DBGMSG (DBG_TRACE, ("Enter WriteCommand cmd=|%s|\n", cmd));

    cbWrite = strlen(cmd);

    dwRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, (LPBYTE) cmd, cbWrite, &cbWritten);

    if ( dwRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
        DBGMSG(DBG_INFO, ("PJLMON!No data Written\n"));
        if ( pIniPort->status & PP_THREAD_RUNNING )
            SetEvent(pIniPort->WakeUp);
    }

    DBGMSG (DBG_TRACE, ("Leave WriteCommand dwRet=%d\n", dwRet));
    return dwRet;
}


#define CBSTRING 1024

BOOL
ReadCommand(
    HANDLE hPort
)
/*++

Routine Description:
    Read a command from the port

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on successfully reading one or more commands, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    DWORD       cbRead, cbToRead, cbProcessed, cbPrevious;
    char        string[CBSTRING];
    DWORD       status = STATUS_SYNTAX_ERROR; //Value should not matter
    BOOL        bRet=FALSE;

    DBGMSG (DBG_TRACE, ("Enter ReadCommand\n"));

    cbPrevious = 0;

    ResetEvent(pIniPort->DoneReading);

    cbToRead = CBSTRING - 1;

    for ( ; ; ) {

        if ( !PJLMonReadPort(hPort, (LPBYTE) &string[cbPrevious], cbToRead, &cbRead) )
            break;


        if ( cbRead ) {

            string[cbPrevious + cbRead] = '\0';
            DBGMSG(DBG_INFO, ("Read |%s|\n", &string[cbPrevious] ));

            status = ProcessPJLString(pIniPort, string, &cbProcessed);
            if ( cbProcessed )
                bRet = TRUE;

            if (status == STATUS_END_OF_STRING ) {

                if ( cbProcessed )
                    strcpy(string, string+cbProcessed);
                cbPrevious = cbRead + cbPrevious - cbProcessed;
            }
        } else {

            SPLASSERT(!cbPrevious);
        }

        if ( status != STATUS_END_OF_STRING && cbRead != cbToRead )
            break;

        cbToRead = CBSTRING - cbPrevious - 1;
        if ( cbToRead == 0 )
            DBGMSG(DBG_ERROR,
                   ("ReadCommand cbToRead is 0 (buffer too small)\n"));

        Sleep(WAIT_FOR_DATA_TIMEOUT);
    }

    SetEvent(pIniPort->DoneReading);

    //
    // Update the time we last read from printer
    //
    if ( bRet )
        pIniPort->dwLastReadTime = GetTickCount();

    DBGMSG (DBG_TRACE, ("Leave ReadCommand bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonGetPrinterDataFromPort(
    HANDLE   hPort,
    DWORD   ControlID,
    LPTSTR  pValueName,
    LPTSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPTSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
)
/*++

Routine Description:
    GetPrinter data from port. Supports predefined commands/valuenames.

    When we support Value name commands (not supported by DeviceIoControl)
    we should check for startdoc -- MuhuntS

    This monitor function supports the following two functionalities,

         1. Allow spooler or language monitor to call DeviceIoControl to get
            information from the port driver vxd, i.e. ControlID != 0.
            And only port monitor support this functionality, language monitor
            doesn't, so language monitor just pass this kind of calls down to
            port monitor.

         2. Allow app or printer driver query language monitor for some device
            information by specifying some key names that both parties understand,
            i.e. ControlID == 0 && pValueName != 0. So when printer driver call
            DrvGetPrinterData DDI, gdi will call spooler -> language monitor
            to get specific device information, for example, UNIDRV does this
            to get installed printer memory from PJL printers thru PJLMON.
            Only language monitor support this functionality,
            port monitor doesn't.

Arguments:
    hPort           : Port handle
    ControId        : Control id
    pValueName      : Value name
    lpInBuffer      : Input buffer for the command
    cbinBuffer      : Input buffer size
    lpOutBuffer     : Output buffer
    cbOutBuffer     : Output buffer size
    lpcbReturned    : Set to the amount of data in output buffer on success

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonGetPrinterDataFromPort hPort=0x%x\n", hPort));

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
    if ( ControlID ) {

        if ( !pIniPort->fn.pfnGetPrinterDataFromPort ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return (*pIniPort->fn.pfnGetPrinterDataFromPort)(
                        pIniPort->hPort,
                        ControlID,
                        pValueName,
                        lpInBuffer,
                        cbInBuffer,
                        lpOutBuffer,
                        cbOutBuffer,
                        lpcbReturned);
    }

    //
    // Only 2 keys supported
    //
    if ( lstrcmpi(pValueName, cszInstalledMemory)   &&
         lstrcmpi(pValueName, cszAvailableMemory) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Wait for crrent job to print since we can't send a PJL command
    // in the middle of job
    //
    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    // make sure the first write succeeds

    // WIN95C BUG 14299, ccteng, 5/18/95
    //
    // The multi-language printers (4M, 4ML, 4MP, 4V, 4SI), if you print a
    // PS print job, the memory resources claimed by the PS processor are not
    // release until you enter PCL or reset the printer with "EscE".
    //
    // So if we had just printed a PS job, the available memory will be
    // incorrect if we don't have the "EscE" here.

    if ( (pIniPort->status & PP_IS_PJL) &&
         WriteCommand(hPort, "\033E\033%-12345X@PJL INFO CONFIG\015\012") ) {

        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            bStopUstatusThread = TRUE;
            CreateUstatusThread(pIniPort);
        }

        // PJLMON currently only supports the following pValueName
        //  1. installed printer memory
        //  2. available printer memory

        if ( !lstrcmpi(pValueName, cszInstalledMemory) )
            pIniPort->dwInstalledMemory = 0;
        else if (!lstrcmpi(pValueName, cszAvailableMemory))
            pIniPort->dwAvailableMemory = 0;

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        WriteCommand(hPort,
                     "@PJL INFO MEMORY\015\012@PJL INFO STATUS\015\012");

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        if ( bStopUstatusThread ) {

            pIniPort->status &= ~PP_RUN_THREAD;
            SetEvent(pIniPort->WakeUp);
        }

        if ( !lstrcmpi(pValueName, cszInstalledMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                pIniPort->dwInstalledMemory ) {

                *((LPDWORD)lpOutBuffer) = pIniPort->dwInstalledMemory;

                bRet = TRUE;
            }
        } else if ( !lstrcmpi(pValueName, cszAvailableMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                 pIniPort->dwAvailableMemory)
            {
                *((LPDWORD)lpOutBuffer) = pIniPort->dwAvailableMemory;

                bRet = TRUE;
            }
        }

        if ( bStopUstatusThread ) {

            while (pIniPort->WakeUp)
                Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
        }

    }

    if ( !bRet )
        SetLastError(ERROR_INVALID_PARAMETER);

    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave PJLMonGetPrinterDataFromPort bRet=0d\n", bRet));

    return bRet;
}

#if 0
PBIDI_RESPONSE_CONTAINER
AllocResponse (DWORD dwCount)
{
    PBIDI_RESPONSE_CONTAINER pResponse;

    pResponse = (PBIDI_RESPONSE_CONTAINER)
                LocalAlloc (LPTR, sizeof (PBIDI_RESPONSE_CONTAINER) +
                            (dwCount - 1) * sizeof (BIDI_RESPONSE_DATA) );

    pResponse->Version = 1;
    pResponse->Flags = 0;
    pResponse->Count = dwCount;
    return pResponse;

}
#endif


DWORD
WINAPI
PJLMonBidiSendRecv (
    HANDLE                    hPort,
    DWORD                     dwAccessBit,
    LPCWSTR                   pszAction,
    PBIDI_REQUEST_CONTAINER   pRequestContainer,
    PBIDI_RESPONSE_CONTAINER* ppResponse)
/*++

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;
    PBIDI_RESPONSE_CONTAINER pResponse = NULL;



#define BIDI_SCHEMA_DUPLEX          L"/Printer/Installableoption/Duplexunit"
#define BIDI_SCHEMA_MULTICHANNEL    L"/Capability/MultiChannel"
#define BIDI_SCHEMA_VERSION         L"/Communication/Version"
#define BIDI_SCHEMA_BIDIPROTOCOL    L"/Communication/BidiProtocol"
#define BIDI_SCHEMA_INK_LEVEL       L"/Printer/BlackInk1/Level"
#define BIDI_SCHEMA_ALERTS          L"/Printer/Alerts"
#define BIDI_PJL L"PJL"
#define BIDI_ALERTNAME L"/Printer/Alerts/1/Name"
#define BIDI_ALERTVALUE L"CoverOpen"

    static LPWSTR ppszSchema[] = {
        BIDI_SCHEMA_DUPLEX, BIDI_SCHEMA_MULTICHANNEL,
        BIDI_SCHEMA_VERSION,  BIDI_SCHEMA_BIDIPROTOCOL,
        BIDI_SCHEMA_INK_LEVEL, BIDI_SCHEMA_ALERTS
        };
    static DWORD dwSchemaCount = sizeof (ppszSchema) / sizeof (ppszSchema[0]);
    DWORD i, j;
    DWORD dwCount;
    DWORD dwIndex = 0;

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);

    if (!lstrcmpi (pszAction, BIDI_ACTION_ENUM_SCHEMA)) {
        // Enum Schema call

        dwCount = dwSchemaCount;

        pResponse = RouterAllocBidiResponseContainer (dwCount);

        pResponse->Version = 1;
        pResponse->Count = dwCount;


        for (i = 0; i <dwCount; i++ ) {
            pResponse->aData[i].dwReqNumber = 0;
            pResponse->aData[i].dwResult = S_OK;
            pResponse->aData[i].data.dwBidiType = BIDI_TEXT;
            pResponse->aData[i].data.u.sData = (LPTSTR)RouterAllocBidiMem (sizeof (TCHAR) * (1 + lstrlen (ppszSchema[i])));
            SPLASSERT (pResponse->aData[i].data.u.sData);

            lstrcpy (pResponse->aData[i].data.u.sData, ppszSchema[i]);
        }
    }
    else if (!lstrcmpi (pszAction, BIDI_ACTION_GET)) {


        dwCount = pRequestContainer->Count;
        pResponse = RouterAllocBidiResponseContainer (dwCount);
        SPLASSERT (pResponse);

        pResponse->Version = 1;
        pResponse->Count = dwCount;

        for (i = 0; i <dwCount; i++ ) {

            DWORD dwSchemaId = 0xffffffff;

            for (j = 0; j < dwSchemaCount;j++ ) {
                if (!lstrcmpi (ppszSchema[j], pRequestContainer->aData[i].pSchema)) {
                    dwSchemaId = j;
                    break;
                }
            }

            switch (dwSchemaId) {
            case 0:
                // duplex
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_BOOL;
                pResponse->aData[i].data.u.bData = TRUE;
                break;
            case 1:
                // multiple channel
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_BOOL;
                pResponse->aData[i].data.u.bData = FALSE;
                break;
            case 2:
                // Version
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_INT;
                pResponse->aData[i].data.u.iData = 1;
                break;
            case 3:
                // BidiProtocol
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_ENUM;
                pResponse->aData[i].data.u.sData = (LPWSTR) RouterAllocBidiMem (
                    sizeof (WCHAR) * (lstrlen (BIDI_PJL) + 1));;
                lstrcpy (pResponse->aData[i].data.u.sData , BIDI_PJL);
                break;

            case 4:
                // Ink Level
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_FLOAT;
                pResponse->aData[i].data.u.fData = (FLOAT) 0.69;
                break;

            default:
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = E_FAIL;
            }
        }
    }
    else if (!lstrcmpi (pszAction, BIDI_ACTION_GET_ALL)) {

        dwCount = pRequestContainer->Count;
        pResponse = RouterAllocBidiResponseContainer (256);
        SPLASSERT (pResponse);
        pResponse->Version = 1;
        pResponse->Count = 256;

        for (i = 0; i < dwCount; i++) {
            if (!lstrcmpi (pRequestContainer->aData[i].pSchema, ppszSchema[5])) {

                for (j = 0; j < 3; j++) {
                    pResponse->aData[dwIndex].dwReqNumber = i;
                    pResponse->aData[dwIndex].pSchema = (LPTSTR) RouterAllocBidiMem (
                        sizeof (TCHAR) * (lstrlen (BIDI_ALERTNAME) + 1));
                    lstrcpy (pResponse->aData[dwIndex].pSchema, BIDI_ALERTNAME);
                    pResponse->aData[dwIndex].dwResult = S_OK;
                    pResponse->aData[dwIndex].data.dwBidiType = BIDI_ENUM;
                    pResponse->aData[dwIndex].data.u.sData = (LPTSTR) RouterAllocBidiMem (
                        sizeof (TCHAR) * (lstrlen (BIDI_ALERTVALUE) + 1));
                    lstrcpy (pResponse->aData[dwIndex].data.u.sData, BIDI_ALERTVALUE);
                    dwIndex ++;
                }
            }
            else {
                pResponse->aData[dwIndex].dwReqNumber = i;
                pResponse->aData[dwIndex].dwResult = E_FAIL;
                dwIndex++;
            }
        }
        pResponse->Count = dwIndex;
    }
    else {
        pResponse = NULL;
    }

    *ppResponse = pResponse;
    return 0;
}


VOID WINAPI
PJLShutdown (
    HANDLE hMonitor
    )
{
}


MONITOR2 Monitor2 = {
    sizeof(MONITOR2),
    NULL,                           // EnumPrinters not supported
    NULL,                           // OpenPort  not supported
    PJLMonOpenPortEx,
    PJLMonStartDocPort,
    PJLMonWritePort,
    PJLMonReadPort,
    PJLMonEndDocPort,
    PJLMonClosePort,
    NULL,                           // AddPort not supported
    NULL,                           // AddPortEx not supported
    NULL,                           // ConfigurePort not supported
    NULL,                           // DeletePort not supported
    PJLMonGetPrinterDataFromPort,
    NULL,                           // SetPortTimeOuts not supported
    NULL,                           // XcvOpen
    NULL,                           // XcvData
    NULL,                           // XcvClose
    PJLShutdown,                    // Shutdown
    PJLMonBidiSendRecv
};


LPMONITOR2
WINAPI
InitializePrintMonitor2(
    IN     PMONITORINIT pMonitorInit,
    IN     PHANDLE phMonitor

)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll
    lpMonitor       : Pointer to monitor fucntion table to be filled

Return Value:
    TRUE on successfully initializing the monitor, false on error.

--*/
{

    if ( !pMonitorInit || !(pMonitorInit->hckRegistryRoot)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if ( UpdateTimeoutsFromRegistry(pMonitorInit->hSpooler,
                                    pMonitorInit->hckRegistryRoot,
                                    pMonitorInit->pMonitorReg) != ERROR_SUCCESS ) {

        return NULL;
    }

    *phMonitor = NULL;

    return &Monitor2;
}


#define NTOKEN  20

DWORD
ProcessPJLString(
    PINIPORT    pIniPort,
    LPSTR       pInString,
    DWORD      *lpcbProcessed
)
/*++

Routine Description:
    Process a PJL string read from the printer

Arguments:
    pIniPort        : Ini port
    pInString       : Input string to process
    lpcbProcessed   : On return set to the amount of data processed

Return Value:
    Status value of the processing

--*/
{
    TOKENPAIR tokenPairs[NTOKEN];
    DWORD nTokenParsedRet;
    LPSTR lpRet;
    DWORD status = 0;

    lpRet = pInString;

#ifdef DEBUG
    OutputDebugStringA("String to process: <");
    OutputDebugStringA(pInString);
    OutputDebugStringA(">\n");
#endif

    for (*lpcbProcessed = 0; *pInString != 0; pInString = lpRet) {

        //
        // hack to determine if printer is bi-di.  LJ 4 does not have p1284
        // device ID so we do PCL memory query and see if it returns anything
        //
        if (!(pIniPort->status & PP_IS_PJL) &&
            !mystrncmp(pInString, "PCL\015\012INFO MEMORY", 16) )
            pIniPort->status |= PP_IS_PJL;

        status = GetPJLTokens(pInString, NTOKEN, tokenPairs,
                              &nTokenParsedRet, &lpRet);

        if (status == STATUS_REACHED_END_OF_COMMAND_OK) {

            pIniPort->status |= PP_IS_PJL;
            InterpreteTokens(pIniPort, tokenPairs, nTokenParsedRet);
        } else {

            ProcessParserError(status);
        }

        //
        // if a PJL command straddles between buffers
        //
        if (status == STATUS_END_OF_STRING)
            break;

        *lpcbProcessed += (DWORD)(lpRet - pInString);
    }

    return status;
}


DWORD
SeverityFromPjlStatus(
    DWORD   dwPjlStatus
    )
{
    if ( dwPjlStatus >= 10000 && dwPjlStatus < 12000 ) {

        //
        // 10xyz
        // 11xyz : load paper (paper available on another tray)
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus >= 30000 && dwPjlStatus < 31000 ) {

        //
        // 30xyz : Auto continuable errors
        //
        return PORT_STATUS_TYPE_WARNING;

    } else if ( dwPjlStatus >= 35000 && dwPjlStatus < 36000 ) {

        //
        // 35xyz : Potential operator intervention conditions
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus > 40000 && dwPjlStatus < 42000 ) {

        //
        // 40xyz : Operator intervention required
        // 41xyz : Load paper errors
        //
        return PORT_STATUS_TYPE_ERROR;
    }

    DBGMSG(DBG_ERROR,
           ("SeverityFromPjlStatus: Unknown status %d\n", dwPjlStatus));
    return PORT_STATUS_TYPE_INFO;
}


VOID
InterpreteTokens(
    PINIPORT pIniPort,
    PTOKENPAIR tokenPairs,
    DWORD nTokenParsed
)
/*++

Routine Description:
    Interpret succesfully read PJL tokens

Arguments:
    pIniPort        : Ini port
    tokenPairs      : List of token pairs
    nTokenParsed    : Number of token pairs

Return Value:
    None

--*/
{
    DWORD                   i, OldStatus;
    PJLTOPRINTERSTATUS     *pMap;
    PORT_INFO_3             PortInfo3;
    DWORD                   dwSeverity = 0;
    HANDLE                  hToken;

#ifdef DEBUG
    char    msg[CBSTRING];
    msg[0]  = '\0';
#endif

    OldStatus = pIniPort->PrinterStatus;
    pIniPort->PrinterStatus = 0;

    for (i = 0; i < nTokenParsed; i++) {

        // DBGMSG(DBG_INFO, ("pjlmon!Token=0x%x, Value=%d\n",
        //                   tokenPairs[i].token, tokenPairs[i].value));

        switch(tokenPairs[i].token) {

        case TOKEN_INFO_STATUS_CODE:
        case TOKEN_USTATUS_DEVICE_CODE:

            for (pMap = PJLToStatus; pMap->pjl; pMap++) {

                if (pMap->pjl == tokenPairs[i].value) {

                    pIniPort->PrinterStatus = pMap->status;
                    dwSeverity = SeverityFromPjlStatus(pMap->pjl);
                    if ( dwSeverity == PORT_STATUS_TYPE_ERROR )
                        pIniPort->status |= PP_PRINTER_OFFLINE;
                    else
                        pIniPort->status &= ~PP_PRINTER_OFFLINE;
                    break;
                }
            }

            if ( pMap->pjl && pMap->pjl == tokenPairs[i].value )
                break;

            //
            // some printers use this to signal online/ready
            //
            if ( tokenPairs[i].value == 10001  ||
                 tokenPairs[i].value == 10002  ||
                 tokenPairs[i].value == 11002 ) {

                pIniPort->status       &= ~PP_PRINTER_OFFLINE;
                pIniPort->PrinterStatus = 0;
                dwSeverity              = 0;
            }


            //
            // background or foreground paper out
            //
            if ( tokenPairs[i].value > 11101 && tokenPairs[i].value < 12000  ||
                 tokenPairs[i].value > 41101 && tokenPairs[i].value < 42000 ) {

                pIniPort->PrinterStatus  = PORT_STATUS_PAPER_OUT;

                if ( tokenPairs[i].value > 4000 ) {

                    dwSeverity           = PORT_STATUS_TYPE_ERROR;
                    pIniPort->status    |= PP_PRINTER_OFFLINE;
                } else {

                    dwSeverity = PORT_STATUS_TYPE_WARNING;
                }
            } else if (tokenPairs[i].value > 40000) {

                pIniPort->PrinterStatus = PORT_STATUS_USER_INTERVENTION;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }

            break;

        case TOKEN_INFO_STATUS_ONLINE:
        case TOKEN_USTATUS_DEVICE_ONLINE:

            // DBGMSG(DBG_INFO, ("PJLMON:ONLINE = %d\n", tokenPairs[i].value));

            if (tokenPairs[i].value) {

                pIniPort->status        &= ~PP_PRINTER_OFFLINE;
                dwSeverity = pIniPort->PrinterStatus ? PORT_STATUS_TYPE_WARNING :
                                                       0;
            } else {

                if ( !pIniPort->PrinterStatus )
                    pIniPort->PrinterStatus = PORT_STATUS_OFFLINE;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }
            break;

        case TOKEN_USTATUS_JOB_NAME_MSJOB:

#ifdef DEBUG
            sprintf(msg, "EOJ for %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            SendJobLastPageEjected(pIniPort, (DWORD)tokenPairs[i].value, FALSE);
            break;

        case TOKEN_INFO_CONFIG_MEMORY:
        case TOKEN_INFO_CONFIG_MEMORY_SPACE:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

#ifdef DEBUG
            sprintf(msg, "PJLMON installed memory %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            pIniPort->dwInstalledMemory = (DWORD)tokenPairs[i].value;
            break;

        case TOKEN_INFO_MEMORY_TOTAL:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

#ifdef DEBUG
            sprintf(msg, "PJLMON available memory %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            pIniPort->dwAvailableMemory = (DWORD)tokenPairs[i].value;
            break;

        default:
            break;
        }
    }

    if ( OldStatus != pIniPort->PrinterStatus ) {

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        PortInfo3.dwStatus      = pIniPort->PrinterStatus;
        PortInfo3.dwSeverity    = dwSeverity;

        if ( !SetPort(NULL,
                      pIniPort->pszPortName,
                      3,
                      (LPBYTE)&PortInfo3) ) {

            DBGMSG(DBG_WARNING,
                   ("pjlmon: SetPort failed %d (LE: %d)\n",
                    pIniPort->PrinterStatus, GetLastError()));

            pIniPort->PrinterStatus = OldStatus;
        }
    }
}


VOID
ProcessParserError(
    DWORD status
)
/*++

Routine Description:
    Print error messages on parsing error

Arguments:
    status  : status

Return Value:
    None

--*/
{
#ifdef DEBUG
    LPSTR pString;

    switch (status)
    {
    case STATUS_REACHED_END_OF_COMMAND_OK:
        pString = "STATUS_REACHED_END_OF_COMMAND_OK\n";
        break;

    case STATUS_CONTINUE:
        pString = "STATUS_CONTINUE\n";
        break;

    case STATUS_REACHED_FF:
        pString = "STATUS_REACHED_FF\n";
        break;

    case STATUS_END_OF_STRING:
        pString = "STATUS_END_OF_STRING\n";
        break;

    case STATUS_SYNTAX_ERROR:
        pString = "STATUS_SYNTAX_ERROR\n";
        break;

    case STATUS_ATPJL_NOT_FOUND:
        pString = "STATUS_ATPJL_NOT_FOUND\n";
        break;

    case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
        pString = "STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n";
        break;

    default:
        pString = "INVALID STATUS RETURNED!!!!!!\n";
        break;
    };

    OutputDebugStringA(pString);
#endif
}


#define MODEL                       "MODEL:"
#define MDL                         "MDL:"
#define COMMAND                     "COMMAND SET:"
#define CMD                         "CMD:"
#define COLON                       ':'
#define SEMICOLON                   ';'


LPSTR
FindP1284Key(
    PINIPORT    pIniPort,
    LPSTR   lpKey
    )
/*++

Routine Description:
    Find the 1284 key identifying the device id

Arguments:
    status  : status

Return Value:
    Pointer to the command string, NULL if not found.

--*/
{
    LPSTR   lpValue;                // Pointer to the Key's value
    WORD    wKeyLength;             // Length for the Key (for stringcmps)
    LPSTR   bRet = NULL;

    // While there are still keys to look at.
#ifdef DEBUG
    OutputDebugStringA("PJLMon!DeviceId : <");
    OutputDebugStringA(lpKey);
    OutputDebugStringA(">\n");
#endif

    while (lpKey && *lpKey) {

        //
        // Is there a terminating COLON character for the current key?
        //
        if (!(lpValue = mystrchr(lpKey, COLON)) ) {

            //
            // N: OOPS, somthing wrong with the Device ID
            //
            return bRet;
        }

        //
        // The actual start of the Key value is one past the COLON
        //
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (WORD)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        if ( *lpKey == 'C' ) {

            //
            // Look for COMMAND SET or CMD
            //
            if ( !mystrncmp(lpKey, COMMAND, wKeyLength) ||
                 !mystrncmp(lpKey, CMD, wKeyLength) ) {

                bRet = lpValue;
            }
        }

        // Go to the next Key

        if ( lpKey = mystrchr(lpValue, SEMICOLON) ) {

            *lpKey = '\0';
            ++lpKey;
        }
    }

    return bRet;
}


BOOL
IsPJL(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Finds out if the printer is a PJL bi-di printer

Arguments:
    pIniPort  : Points to an INIPORT

Return Value:
    TRUE if printer is PJL bi-di, else FALSE

    On failure PP_DONT_TRY_PJL is set

--*/
{
    char        szID[MAX_DEVID];
    DWORD       cbRet;
    LPSTR       lpCMD;
    HANDLE      hPort = (HANDLE)pIniPort;
    BOOL        bRet = FALSE;

    //
    // for printers that supports P1284 plug and play like LJ 4L, DJ540.
    // we parse the COMMAND string and see if PJL is supported
    //
    if (pIniPort->fn.pfnGetPrinterDataFromPort) {

        //
        // Only try P1284 if port monitor supports DeviceIOCtl
        //
        memset((LPBYTE)szID, 0, sizeof(szID));
        cbRet = 0;
        if ((*pIniPort->fn.pfnGetPrinterDataFromPort)
                (pIniPort->hPort, GETDEVICEID, NULL, NULL,
                    0, (LPWSTR)szID, sizeof(szID), &cbRet)
            && cbRet) {

            //
            // succeeded the P1284 plug and play protocol
            //
            szID[cbRet] = '\0';

            if ( lpCMD = FindP1284Key(pIniPort, szID) ) {

                // found the COMMAND string

                while (*lpCMD) {

                    //
                    // look for "PJL"
                    //
                    if ( lpCMD[0] == 'P' && lpCMD[1] == 'J' && lpCMD[2] == 'L' ){

                        pIniPort->status &= ~PP_DONT_TRY_PJL;
                        bRet = TRUE;
                        goto Cleanup;
                    }

                    lpCMD++;
                }

                pIniPort->status |= PP_DONT_TRY_PJL;
                goto Cleanup;
            }
        }

        //
        // fall thru to try PJL bi-di if we failed the P1284 communication
        // or P1284 didn't return a COMMAND string
        //
    }

    //
    // for printers that don't support P1284 plug and play, but support PJL
    // language command, like LJ 4 and 4M. we try to write/read PJL
    // command and see if it succeeds.
    // if we can't set the time outs we don't want to try to read, just fail.
    //
    if ( pIniPort->fn.pfnSetPortTimeOuts &&
         !(pIniPort->status & PP_DONT_TRY_PJL)) {

        COMMTIMEOUTS CTO;

        memset((LPSTR)&CTO, 0, sizeof(CTO));
        CTO.ReadTotalTimeoutConstant = 5000;
        CTO.ReadIntervalTimeout = 200;
        if ( !(*pIniPort->fn.pfnSetPortTimeOuts)(pIniPort->hPort, &CTO, 0) ) {

            goto Cleanup;
        }

        // This <ESC>*s1M is a PCL5 command to determine the amount of memory
        // in a PCL5 printer, and if the printer is PCL5 and bi-di capable,
        // it will return "PCL\015\012INFO MEMORY".
        // See PJL Tech Ref Manual page 7-21.

        pIniPort->status &= ~PP_IS_PJL;

        if ( !WriteCommand(hPort, "\033*s1M") )
            goto Cleanup;

        // ReadCommand->ProcessPJLString will set PP_IS_PJL
        // if we read any valid PJL command back from the printer

        if ( !ReadCommand(hPort) ) {

            //
            // We have jumped through the hoop to determin if this printer can
            // understand PJL.  It DOES NOT.  We are not going to try again.
            // until there is a printer change.
            //
            pIniPort->status |= PP_DONT_TRY_PJL;
        }

        if (pIniPort->status & PP_IS_PJL) {

            bRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( bRet ) {

        WriteCommand(hPort, "\033%-12345X@PJL \015\012@PJL USTATUS TIMED 30 \015\012\033%-12345X");
        pIniPort->dwLastReadTime = GetTickCount();
    }

    //return bRet;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\spltypes.h ===
/*++

Copyright (c) 1995 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    Spltypes.h

Abstract:

    PJLMON header file


--*/

#ifndef MODULE
#define MODULE "PJLMON:"
#define MODULE_DEBUG PjlmonDebug
#endif

typedef struct _INIJOB {
    DWORD   signature;
    struct _INIJOB FAR *pNext;
    LPTSTR  pszPrinterName;
    HANDLE  hPrinter;
    DWORD   JobId;
    DWORD   status;
    DWORD   TimeoutCount;
} INIJOB, FAR *PINIJOB;

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT FAR *pNext;
    LPTSTR  pszPortName;

    DWORD   cRef;

    DWORD   status;
    PINIJOB pIniJob;

    HANDLE  hPort;
    HANDLE  WakeUp;
    HANDLE  DoneReading;
    HANDLE  DoneWriting;

    DWORD   PrinterStatus;
    DWORD   dwLastReadTime;
    DWORD   dwAvailableMemory;
    DWORD   dwInstalledMemory;

    MONITOR2 fn;

} INIPORT, FAR *PINIPORT;

#define PJ_SIGNATURE   0x4F4A  /* 'PJ' is the signature value */

//
// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_LJ4L, PP_RESETDEV
//      are set/cleared on per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
//
#define PP_INSTARTDOC       0x00000001  // Inside StartDoc, sending data to the printer
#define PP_RUN_THREAD       0x00000002  // Tell the ustatus thread to start running
#define PP_THREAD_RUNNING   0x00000004  // Tell the main thread that the ustatus thread is running

//
// If PP_RUN_THREAD is set and PP_THREAD_RUNNING is not that means UStatus
// thread is being created or it is already running but has not determined if
// printer is PJL or not yet
//
#define PP_PRINTER_OFFLINE  0x00000008  // The printer is OFFLINE
#define PP_PJL_SENT         0x00000010  // PJL Command was sent to the printer
#define PP_SEND_PJL         0x00000020  // Set at StartDoc so that we initialize PJL
                                        // commands during the first write port
#define PP_IS_PJL           0x00000040  // Port is PJL
#define PP_DONT_TRY_PJL     0x00000080  // Don't try again...
#define PP_WRITE_ERROR      0x00000100  // A write was not succesful

// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_PORT_OPEN are set/cleared on
//           per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\1394port.h ===
// 1394Port.h: interface for the C1394Port class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_)
#define AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class C1394Port : public CBasePort
{
public:
   C1394Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~C1394Port();
   virtual PORTTYPE getPortType( void );

};

#endif // !defined(AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\baseport.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    BasePort.cpp

Abstract:
    Basic Port Class
    Implementation of the CBasePort class.

Author: M. Fenelon

Revision History:

--*/

//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ntddpar.h"

TCHAR   cszMonitorName[]                = TEXT("Dynamic Print Monitor");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBasePort::CBasePort()
   : m_cRef(0), m_dwFlags(0), m_hDeviceHandle(INVALID_HANDLE_VALUE),
     m_hPrinter(INVALID_HANDLE_VALUE), m_pWriteBuffer(NULL), m_dwBufferSize(0),
     m_dwDataSize(0), m_dwDataCompleted(0), m_dwDataScheduled(0), m_dwReadTimeoutMultiplier(READ_TIMEOUT_MULTIPLIER),
     m_dwReadTimeoutConstant(READ_TIMEOUT_CONSTANT), m_dwWriteTimeoutMultiplier(WRITE_TIMEOUT_MULTIPLIER),
     m_dwWriteTimeoutConstant(WRITE_TIMEOUT_CONSTANT), m_dwMaxBufferSize(0)
{

}


CBasePort::CBasePort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath, LPTSTR pszPortDesc )
   : m_cRef(0), m_dwFlags(0), m_bActive(bActive), m_hDeviceHandle(INVALID_HANDLE_VALUE),
     m_hPrinter(INVALID_HANDLE_VALUE), m_pWriteBuffer(NULL), m_dwBufferSize(0),
     m_dwDataSize(0), m_dwDataCompleted(0), m_dwDataScheduled(0), m_dwReadTimeoutMultiplier(READ_TIMEOUT_MULTIPLIER),
     m_dwReadTimeoutConstant(READ_TIMEOUT_CONSTANT), m_dwWriteTimeoutMultiplier(WRITE_TIMEOUT_MULTIPLIER),
     m_dwWriteTimeoutConstant(WRITE_TIMEOUT_CONSTANT), m_dwMaxBufferSize(0)
{
    // Setup the Port Name
   ::SafeCopy( MAX_PORT_LEN, pszPortName, m_szPortName );
   // Setup the DevicePath
   ::SafeCopy( MAX_PATH, pszDevicePath, m_szDevicePath );
   // Setup Port Description
   ::SafeCopy( MAX_PORT_DESC_LEN, pszPortDesc, m_szPortDescription );
}


CBasePort::~CBasePort()
{
   // Cleanup any left over resources
   if ( m_hDeviceHandle != INVALID_HANDLE_VALUE )
   {
      CloseHandle( m_hDeviceHandle );
      CloseHandle( m_Ov.hEvent );
   }
}


BOOL CBasePort::open()
{
   BOOL    bRet = FALSE;

   ECS( m_CritSec );

   if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
   {
      //
      // If we have an invalid handle and refcount is non-zero we want the
      // job to fail and restart to accept writes. In other words if the
      // handle got closed prematurely, because of failing writes, then we
      // need the ref count to go down to 0 before calling CreateFile again
      //
      if ( m_cRef )
         goto Done;

      m_hDeviceHandle = CreateFile( m_szDevicePath,
                                    GENERIC_WRITE | GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_OVERLAPPED,
                                    NULL);
      //
      // If we failed to open the port - test to see if it is a Dot4 port.
      //
      if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
      {
         //
         // ERROR_FILE_NOT_FOUND -> Error code for port not there.
         //
         if ( ERROR_FILE_NOT_FOUND != GetLastError() ||
              !checkPnP() )
            goto Done;
      }

      m_Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
      if ( m_Ov.hEvent == NULL )
      {
         CloseHandle(m_hDeviceHandle);
         m_hDeviceHandle = INVALID_HANDLE_VALUE;
         goto Done;
      }

   }

   ++m_cRef;
   bRet = TRUE;

Done:

   LCS( m_CritSec );
   return bRet;

}


BOOL CBasePort::close()
{
   BOOL bRet = TRUE;

   ECS( m_CritSec );

   --m_cRef;
   if ( m_cRef != 0 )
      goto Done;

   bRet = CloseHandle( m_hDeviceHandle);
   CloseHandle( m_Ov.hEvent);
   m_hDeviceHandle = INVALID_HANDLE_VALUE;

Done:
   LCS( m_CritSec );
   return bRet;

}


BOOL CBasePort::startDoc(LPTSTR pPrinterName, DWORD dwJobId, DWORD dwLevel, LPBYTE pDocInfo)
{
   BOOL bRet;
   SPLASSERT( notInWrite() );

   if ( !openPrinter( pPrinterName ) )
      return FALSE;

   m_dwJobId = dwJobId;
   bRet = open();

   if ( !bRet )
      closePrinter();
   else
      m_dwFlags |= DYNAMON_STARTDOC;

   return bRet;
}

BOOL CBasePort::endDoc()
{
   DWORD         dwLastError = ERROR_SUCCESS;

   dwLastError = sendQueuedData();
   freeWriteBuffer();

   m_dwFlags &= ~DYNAMON_STARTDOC;

   close();
   setJobStatus( JOB_CONTROL_SENT_TO_PRINTER );

   closePrinter();

   return TRUE;
}

BOOL CBasePort::read(LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead)
{
   DWORD               dwLastError = ERROR_SUCCESS;
   DWORD               dwTimeout;
   HANDLE              hReadHandle;
   OVERLAPPED          Ov;

   //
   // Create separate read handle since we have to cancel reads which do
   // not complete within the specified timeout without cancelling writes
   //
   hReadHandle = CreateFile( m_szDevicePath,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED,
                             NULL);

   if ( hReadHandle == INVALID_HANDLE_VALUE )
      return FALSE;

   ZeroMemory( &Ov, sizeof(Ov) );

   if ( !( Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL) ) )
      goto Done;

   if ( !ReadFile( hReadHandle, pBuffer, cbBuffer, pcbRead, &Ov ) &&
        ( dwLastError = GetLastError() ) != ERROR_IO_PENDING )
      goto Done;

   dwTimeout = m_dwReadTimeoutConstant +
               m_dwReadTimeoutMultiplier * cbBuffer;

   if ( dwTimeout == 0 )
      dwTimeout=MAX_TIMEOUT;

   if ( WaitForSingleObject( Ov.hEvent, dwTimeout ) == WAIT_TIMEOUT )
   {
      CancelIo( hReadHandle );
      WaitForSingleObject( Ov.hEvent, INFINITE );
   }

   if ( !GetOverlappedResult( hReadHandle, &Ov, pcbRead, FALSE ) )
   {
      *pcbRead = 0;
      dwLastError = GetLastError();
   }
   else
      dwLastError = ERROR_SUCCESS;

Done:
   if ( Ov.hEvent )
      CloseHandle( Ov.hEvent );

   CloseHandle( hReadHandle );

   if ( dwLastError )
      SetLastError(dwLastError);

   return dwLastError == ERROR_SUCCESS;
}


BOOL CBasePort::write(LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten)
{
   DWORD         dwLastError = ERROR_SUCCESS;
   DWORD         dwBytesLeft, dwBytesSent;
   DWORD         dwStartTime, dwTimeLeft, dwTimeout;
   BYTE          bPrinterStatus;
   BOOL          bStartDoc = ( ( m_dwFlags & DYNAMON_STARTDOC ) != 0 );

   *pcbWritten = 0;
   dwStartTime = GetTickCount();
   dwTimeout   = m_dwWriteTimeoutConstant + m_dwWriteTimeoutMultiplier * cbBuffer;

   if ( dwTimeout == 0 )
      dwTimeout = MAX_TIMEOUT;

   // Usbprint currently can't handle write greater than 4K.
   // For Win2K we will make a fix here, later usbprint will be fixed
   //
   // It is ok to change the size here since spooler will resubmit the rest
   // later
   //
   cbBuffer = adjustWriteSize( cbBuffer );

   //
   // For writes outside startdoc/enddoc we do not carry them across WritePort
   // calls. These are typically from language monitors (i.e. not job data)
   //
   SPLASSERT(bStartDoc || m_pWriteBuffer == NULL);

   if ( bStartDoc && ( m_hDeviceHandle == INVALID_HANDLE_VALUE ) )
   {
      setJobStatus( JOB_CONTROL_RESTART );
      SetLastError(ERROR_CANCELLED);
      return FALSE;
   }

   if ( !open() )
      return FALSE;

   // First complete any data from previous WritePort call
   while ( m_dwDataSize > m_dwDataCompleted )
   {

      if ( m_dwDataScheduled )
      {
         dwTimeLeft  = getTimeLeft( dwStartTime, dwTimeout );
         dwLastError = getWriteStatus( dwTimeLeft );
      }
      else
         dwLastError = writeData();

      if ( dwLastError != ERROR_SUCCESS )
         goto Done;
   }

   SPLASSERT(m_dwDataSize == m_dwDataCompleted   &&
             m_dwDataScheduled == 0                       &&
             dwLastError == ERROR_SUCCESS);

   //
   // Copy the data to our own buffer
   //
   if ( m_dwBufferSize < cbBuffer )
   {
      freeWriteBuffer();
      if ( m_pWriteBuffer = (LPBYTE) AllocSplMem( cbBuffer ) )
         m_dwBufferSize = cbBuffer;
      else
      {
         dwLastError = ERROR_OUTOFMEMORY;
         goto Done;
      }
   }

   // We have to clear the counters
   m_dwDataCompleted = m_dwDataScheduled = 0;

   CopyMemory( m_pWriteBuffer, pBuffer, cbBuffer );
   m_dwDataSize = cbBuffer;

   //
   // Now do the write for the data for this WritePort call
   //
   while ( m_dwDataSize > m_dwDataCompleted )
   {

      if ( m_dwDataScheduled )
      {

         dwTimeLeft  = getTimeLeft( dwStartTime, dwTimeout );
         dwLastError = getWriteStatus( dwTimeLeft );
      }
      else
         dwLastError = writeData();

      if ( dwLastError != ERROR_SUCCESS )
         break;
   }

   //
   // For writes outside startdoc/enddoc, which are from language monitors,
   // do not carry pending writes to next WritePort.
   //
   if ( !bStartDoc && m_dwDataSize > m_dwDataCompleted )
   {
      CancelIo( m_hDeviceHandle );
      dwLastError = getWriteStatus( INFINITE );
      *pcbWritten = m_dwDataCompleted;
      freeWriteBuffer();
   }

   //
   // We will tell spooler we wrote all the data if some data got scheduled
   //  (or scheduled and completed)
   //
   if ( m_dwDataCompleted > 0 || m_dwDataScheduled != 0 )
      *pcbWritten = cbBuffer;
   else
      freeWriteBuffer();

Done:

   if ( needToResubmitJob( dwLastError ) )
      invalidatePortHandle();
   else if ( dwLastError == ERROR_TIMEOUT )
   {
      getLPTStatus( m_hDeviceHandle, &bPrinterStatus );
      if ( bPrinterStatus & LPT_PAPER_EMPTY )
         dwLastError=ERROR_OUT_OF_PAPER;
   }

   close();
   SetLastError(dwLastError);
   return dwLastError == ERROR_SUCCESS;

}


BOOL CBasePort::getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned )
{
   BOOL       bRet = FALSE;
   OVERLAPPED Ov;
   HANDLE     hDeviceHandle;
   DWORD      dwWaitResult;

   *lpcbReturned = 0;

   if ( dwControlID == 0 )
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   ZeroMemory(&Ov, sizeof(Ov));
   if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
      return FALSE;

   if ( !open() )
   {
      CloseHandle(Ov.hEvent);
      return FALSE;
   }

   if ( dwControlID == IOCTL_PAR_QUERY_DEVICE_ID )
   {
      hDeviceHandle = CreateFile( m_szDevicePath,
                                  GENERIC_WRITE | GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_FLAG_OVERLAPPED,
                                  NULL);

      if ( hDeviceHandle == INVALID_HANDLE_VALUE )
         goto Done;

      if ( !DeviceIoControl( m_hDeviceHandle, dwControlID, lpInBuffer, cbInBuffer, lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)
           && GetLastError() != ERROR_IO_PENDING )
      {
         CloseHandle( hDeviceHandle );
         goto Done;
      }

      if ( WaitForSingleObject( Ov.hEvent, PAR_QUERY_TIMEOUT ) != WAIT_OBJECT_0 )
         CancelIo( hDeviceHandle );

      bRet = GetOverlappedResult( m_hDeviceHandle, &Ov, lpcbReturned, TRUE );
      CloseHandle( hDeviceHandle );
   }
   else
   {
      if ( !DeviceIoControl( m_hDeviceHandle, dwControlID,
                             lpInBuffer, cbInBuffer,
                             lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)  &&
           GetLastError() != ERROR_IO_PENDING )
         goto Done;

      bRet = GetOverlappedResult( m_hDeviceHandle, &Ov, lpcbReturned, TRUE);
   }

Done:
   CloseHandle(Ov.hEvent);
   close();

   return bRet;
}

BOOL CBasePort::setPortTimeOuts( LPCOMMTIMEOUTS lpCTO )
{
   m_dwReadTimeoutConstant    =  lpCTO->ReadTotalTimeoutConstant;
   m_dwReadTimeoutMultiplier  =  lpCTO->ReadTotalTimeoutMultiplier;
   m_dwWriteTimeoutConstant   =  lpCTO->WriteTotalTimeoutConstant;
   m_dwWriteTimeoutMultiplier =  lpCTO->WriteTotalTimeoutMultiplier;

   return TRUE;
}


void CBasePort::InitCS()
{
   ICS( m_CritSec );
}


void CBasePort::ClearCS()
{
   DCS( m_CritSec );
}


PORTTYPE CBasePort::getPortType()
{
   return USBPORT;
}


LPTSTR CBasePort::getPortDesc()
{
   return m_szPortDescription;
}


void CBasePort::setPortDesc( LPTSTR pszPortDesc )
{
   if ( pszPortDesc )
      ::SafeCopy( MAX_PORT_DESC_LEN, pszPortDesc, m_szPortDescription );
}


BOOL CBasePort::isActive( void )
{
   return m_bActive;
}


void CBasePort::setActive( BOOL bValue )
{
   m_bActive = bValue;
}


BOOL CBasePort::compActiveState( BOOL bValue )
{
   return (m_bActive == bValue);
}


LPTSTR CBasePort::getPortName()
{
   return m_szPortName;
}


void CBasePort::setPortName(LPTSTR pszPortName)
{
   if ( pszPortName )
      ::SafeCopy( MAX_PORT_LEN, pszPortName, m_szPortName );
}


INT CBasePort::compPortName(LPTSTR pszPortName)
{
   return _tcsicmp( pszPortName, m_szPortName );
}


LPTSTR CBasePort::getDevicePath()
{
   return m_szDevicePath;
}


void CBasePort::setDevicePath(LPTSTR pszDevicePath)
{
   if ( pszDevicePath )
      ::SafeCopy( MAX_PATH, pszDevicePath, m_szDevicePath );
}


INT CBasePort::compDevicePath(LPTSTR pszDevicePath)
{
   return _tcsicmp( pszDevicePath, m_szDevicePath );
}


DWORD CBasePort::getEnumInfoSize(DWORD dwLevel )
{
   // Need to calcualted how much data will be used for this port
   DWORD dwBytesNeeded = 0;

   switch ( dwLevel )
   {
      case 1:
         // Start with size of Port Info struct
         dwBytesNeeded += sizeof( PORT_INFO_1 );
         // Add the length of the string
         dwBytesNeeded += ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR);
         break;
      case 2:
         // Start with size of Port Info struct
         dwBytesNeeded += sizeof( PORT_INFO_2 );
         // Add the length of the strings
         dwBytesNeeded += ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR);
         dwBytesNeeded += ( _tcslen( m_szPortDescription ) + 1 ) * sizeof(TCHAR);
         dwBytesNeeded += ( _tcslen( cszMonitorName ) + 1 ) * sizeof(TCHAR);
         break;
   }

   return dwBytesNeeded;
}


LPBYTE CBasePort::copyEnumInfo(DWORD dwLevel, LPBYTE pPort, LPBYTE pEnd)
{
   LPTSTR pStrStart;
   PPORT_INFO_1 pPort1 = (PPORT_INFO_1) pPort;
   PPORT_INFO_2 pPort2 = (PPORT_INFO_2) pPort;

   switch ( dwLevel )
   {
      case 2:
         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( m_szPortDescription ) + 1 ) * sizeof(TCHAR) ) );
         _tcscpy( pStrStart, m_szPortDescription );
         pPort2->pDescription = pStrStart;
         pEnd = (LPBYTE) pStrStart;

         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( cszMonitorName ) + 1 ) * sizeof(TCHAR) ) );
         _tcscpy( pStrStart, cszMonitorName );
         pPort2->pMonitorName = pStrStart;
         pEnd = (LPBYTE) pStrStart;

      case 1:
         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR) ) );
         _tcscpy( pStrStart, m_szPortName );
         pPort1->pName = pStrStart;
   }

   return (LPBYTE) pStrStart;
}


BOOL CBasePort::notInWrite()
{
   return( m_pWriteBuffer    == NULL &&
           m_dwBufferSize    == 0    &&
           m_dwDataSize      == 0    &&
           m_dwDataCompleted == 0    &&
           m_dwDataScheduled == 0       );
}


BOOL CBasePort::openPrinter(LPTSTR pPrinterName)
{
    if (INVALID_HANDLE_VALUE != m_hPrinter)
    {
        //
        // Printer is already opened
        //
        return TRUE;
    }
    //
    // Opening the printer...
    //
    BOOL bRet = 
        OpenPrinter (
            pPrinterName,
            &m_hPrinter,
            NULL
            );
    if (!bRet)
    {
        //
        // ...printer is not opened...
        //
        m_hPrinter = INVALID_HANDLE_VALUE;
    }
    return bRet;
}

void CBasePort::closePrinter()
{
   if (INVALID_HANDLE_VALUE != m_hPrinter)
   {
      ClosePrinter( m_hPrinter );
      m_hPrinter = INVALID_HANDLE_VALUE;
   }
}


void CBasePort::setJobStatus( DWORD dwJobStatus )
{
   // Make sure that we have a valid printer handle
   if ( m_hPrinter != INVALID_HANDLE_VALUE )
      SetJob( m_hPrinter, m_dwJobId, 0, NULL, dwJobStatus );
}


void CBasePort::setJobID(DWORD dwJobID)
{
   m_dwJobId = dwJobID;
}


DWORD CBasePort::getJobID()
{
   return m_dwJobId;
}


BOOL CBasePort::checkPnP()
{
   // If a class wants to do something, it needs to override
   return FALSE;
}


DWORD CBasePort::sendQueuedData()
{
   DWORD dwLastError = ERROR_SUCCESS;

   // Wait for any outstanding write to complete
   while ( m_dwDataSize > m_dwDataCompleted )
   {
      // If job needs to be aborted ask KM driver to cancel the I/O
      //
      if ( abortThisJob() )
      {
         if ( m_dwDataScheduled )
         {
            CancelIo( m_hDeviceHandle);
            dwLastError = getWriteStatus( INFINITE );
         }
         return dwLastError;
      }

      if ( m_dwDataScheduled )
         dwLastError = getWriteStatus( JOB_ABORTCHECK_TIMEOUT );
      else
      {
         // If for some reason KM is failing to complete all write do not
         // send data in a busy loop. Use 1 sec between Writes
         //
         if ( dwLastError != ERROR_SUCCESS )
            Sleep(1*1000);

         dwLastError = writeData();
      }

      //
      // Check if we can use the same handle and continue
      //
      if ( needToResubmitJob( dwLastError ) )
      {
         invalidatePortHandle();
         setJobStatus( JOB_CONTROL_RESTART );
      }
   }

   return dwLastError;
}


BOOL CBasePort::abortThisJob()
{
   BOOL            bRet = FALSE;
   DWORD           dwNeeded;
   LPJOB_INFO_1    pJobInfo = NULL;

   dwNeeded = 0;
   //
   if (INVALID_HANDLE_VALUE == m_hPrinter)
   {
       SetLastError (
           ERROR_INVALID_HANDLE
           );
       goto Done;
   }
   //
   GetJob( m_hPrinter, m_dwJobId, 1, NULL, 0, &dwNeeded);

   if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      goto Done;

   if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
        !GetJob( m_hPrinter, m_dwJobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
      )
      goto Done;

   bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
          (pJobInfo->Status & JOB_STATUS_DELETED)  ||
          (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
   FreeSplMem(pJobInfo);

   return bRet;
}


/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS   : Write got done succesfully
    ERROR_TIMEOUT   : Timeout occured
    Others          : Write completed with a failure

--*/
DWORD CBasePort::getWriteStatus(DWORD dwTimeOut)
{
   DWORD   dwLastError = ERROR_SUCCESS;
   DWORD   dwWritten = 0;

   SPLASSERT( m_dwDataScheduled > 0);

   if ( WAIT_TIMEOUT == WaitForSingleObject( m_Ov.hEvent, dwTimeOut) )
   {
      dwLastError = ERROR_TIMEOUT;
      goto Done;
   }

   if ( !GetOverlappedResult( m_hDeviceHandle, &m_Ov,
                             &dwWritten, FALSE) )
   {
      if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
         dwLastError = STG_E_UNKNOWN;
   }

   ResetEvent( m_Ov.hEvent );

   // We are here because either a write completed succesfully,
   // or failed but the error is not serious enough to resubmit job
   if ( dwWritten <= m_dwDataScheduled )
      m_dwDataCompleted += dwWritten;
   else
      SPLASSERT( dwWritten <= m_dwDataScheduled );

   m_dwDataScheduled = 0;

Done:
   // Either we timed out, or write sheduled completed (success of failure)
   SPLASSERT( dwLastError == ERROR_TIMEOUT || m_dwDataScheduled == 0 );
   return dwLastError;
}


/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS : Write got succesfully scheduled
                    (may or may not have completed on return)
                    pPortInfo->dwScheduledData is the amount that got scheduled
    Others: Write failed, return code is the Win32 error

--*/
DWORD CBasePort::writeData()
{
   DWORD   dwLastError = ERROR_SUCCESS, dwDontCare;

   // When a sheduled write is pending we should not try to send data
   // any more
   SPLASSERT( m_dwDataScheduled == 0);

   // Send all the data that is not confirmed
   SPLASSERT( m_dwDataSize >= m_dwDataCompleted);
   m_dwDataScheduled = m_dwDataSize - m_dwDataCompleted;

   // Clear Overlapped fields before sending
   m_Ov.Offset = m_Ov.OffsetHigh = 0x00;
   if ( !WriteFile( m_hDeviceHandle, m_pWriteBuffer + m_dwDataCompleted,
                    m_dwDataScheduled, &dwDontCare, &m_Ov) )
   {
      if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
         dwLastError = STG_E_UNKNOWN;
      else if ( dwLastError == ERROR_IO_PENDING )
         dwLastError = ERROR_SUCCESS;
   }

   // If scheduling of the write failed then no data is pending
   if ( dwLastError != ERROR_SUCCESS )
      m_dwDataScheduled = 0;

   return dwLastError;
}


BOOL CBasePort::needToResubmitJob(DWORD dwError)
{
   //
   // I used winerror -s ntstatus to map KM error codes to user mode errors
   //
   // 5   ERROR_ACCESS_DENIED     <-->  c0000056 STATUS_DELETE_PENDING
   // 6   ERROR_INVALID_HANDLE    <-->  c0000008 STATUS_INVALID_HANDLE
   // 23  ERROR_CRC               <-->  c000003e STATUS_DATA_ERROR
   // 23  ERROR_CRC               <-->  c000003f STATUS_CRC_ERROR
   // 23  ERROR_CRC               <-->  c000009c STATUS_DEVICE_DATA_ERROR
   // 55  ERROR_DEV_NOT_EXIST     <-->  c00000c0 STATUS_DEVICE_DOES_NOT_EXIST
   // 303 ERROR_DELETE_PENDING    <-->  c0000056 STATUS_DELETE_PENDING
   // 995 ERROR_OPERATION_ABORTED
   //
   return dwError == ERROR_ACCESS_DENIED   ||
          dwError == ERROR_INVALID_HANDLE  ||
          dwError == ERROR_CRC             ||
          dwError == ERROR_DELETE_PENDING  ||
          dwError == ERROR_DEV_NOT_EXIST   ||
          dwError == ERROR_OPERATION_ABORTED;

}


void CBasePort::invalidatePortHandle()
{
   SPLASSERT( m_hDeviceHandle != INVALID_HANDLE_VALUE );

   CloseHandle( m_hDeviceHandle );
   m_hDeviceHandle = INVALID_HANDLE_VALUE;

   CloseHandle( m_Ov.hEvent );
   m_Ov.hEvent = NULL;

   freeWriteBuffer();
}


void CBasePort::freeWriteBuffer()
{
   FreeSplMem( m_pWriteBuffer );
   m_pWriteBuffer=NULL;

   m_dwBufferSize = m_dwDataSize
                  = m_dwDataCompleted
                  = m_dwDataScheduled = 0;
}


void CBasePort::setMaxBuffer(DWORD dwMaxBufferSize)
{
   m_dwMaxBufferSize = dwMaxBufferSize;
}


DWORD CBasePort::adjustWriteSize(DWORD dwBytesToWrite)
{
   // If this port has a data size limit....
   if ( m_dwMaxBufferSize )
   {
      // Check and adjust the current write size.
      if ( dwBytesToWrite > m_dwMaxBufferSize )
         dwBytesToWrite = m_dwMaxBufferSize;
   }

   return dwBytesToWrite;
}


DWORD CBasePort::getTimeLeft(DWORD dwStartTime, DWORD dwTimeout)
{
   DWORD dwCurrentTime;
   DWORD dwTimeLeft;

   if ( dwTimeout == MAX_TIMEOUT )
      return MAX_TIMEOUT;
   dwCurrentTime = GetTickCount();
   if ( dwTimeout < ( dwCurrentTime - dwStartTime ) )
      dwTimeLeft=0;
   else
      dwTimeLeft = dwTimeout - ( dwCurrentTime - dwStartTime );
   return dwTimeLeft;
}


BOOL CBasePort::getLPTStatus(HANDLE hDeviceHandle, BYTE *Status)
{
   BYTE StatusByte;
   OVERLAPPED Ov;

   BOOL bResult;
   DWORD dwBytesReturned;
   DWORD dwLastError;
   Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
   bResult = DeviceIoControl( hDeviceHandle, IOCTL_USBPRINT_GET_LPT_STATUS, NULL,
                              0, &StatusByte, 1, &dwBytesReturned, &Ov );
   dwLastError=GetLastError();
   if ( bResult || ( dwLastError == ERROR_IO_PENDING ) )
      bResult = GetOverlappedResult( hDeviceHandle, &Ov, &dwBytesReturned, TRUE );

   if ( bResult )
      *Status=StatusByte;
   else
      *Status=LPT_BENIGN_STATUS; //benign printer status...  0 would indicate a particular error status from the printer

   CloseHandle( Ov.hEvent );
   return bResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\bidipjlmon\util.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

--*/

#include "precomp.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
MODULE_DEBUG_INIT( DBG_WARN|DBG_ERROR|DBG_INFO|DBG_TRACE, DBG_ERROR );
#endif
// @@END_DDKSPLIT

CRITICAL_SECTION pjlMonSection      = {0,0,0,0,0,0};

PINIPORT pIniFirstPort  = NULL;

DWORD dwReadThreadErrorTimeout;
DWORD dwReadThreadEOJTimeout;
DWORD dwReadThreadIdleTimeoutOther;

TCHAR cszEOJTimeout[]        = TEXT("EOJTimeout");


VOID
SplInSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread != (HANDLE) GetCurrentThreadId() ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Not in spooler semaphore !!\n"));
    }
}


VOID
SplOutSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread == (HANDLE) GetCurrentThreadId() ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Inside spooler semaphore !!\n"));
    }
}

VOID
EnterSplSem(
   VOID
    )
{
    EnterCriticalSection(&pjlMonSection);
}


VOID
LeaveSplSem(
   VOID
    )
{
    SplInSem();
    LeaveCriticalSection(&pjlMonSection);
}


VOID
UpdateRegistryValue(
    IN     HANDLE   hPrinter,
    IN     HKEY     hKey,
    IN     PMONITORREG pMonitorReg,
    IN     LPCTSTR  cszValueName,
    OUT    LPDWORD  pdwValue,
    IN     DWORD    dwDefault,
    IN OUT LPDWORD  pdwLastError
    )
/*++

Routine Description:
    Gets value assoicated with give value name from the registry. If value name
    is not found default value is written to registry.

    On error last error value is set to pdwLastError.

Arguments:
    hKey         : Registry key under which value should be searched
    pMonitorReg  : Port monitor registry function pointers
    cszValueName : Value name to search in the registry
    pdwValue     : On return will have the value
    dwDefault    : If value name not found in the registry set to this value
    pdwLastError : On error set last error to this

Return Value:
    None

--*/
{
    DWORD   dwSize = sizeof(*pdwValue);

    if ( *pdwLastError != ERROR_SUCCESS )
        return;

    if ( ERROR_SUCCESS != (* pMonitorReg->fpQueryValue) (hKey,
                                                        cszValueName,
                                                        NULL,
                                                        (LPBYTE)pdwValue,
                                                        &dwSize,
                                                        hPrinter) ) {

        *pdwValue = dwDefault;
        *pdwLastError = (* pMonitorReg->fpSetValue) (hKey,
                                                     cszValueName,
                                                     REG_DWORD,
                                                     (LPBYTE)pdwValue,
                                                     sizeof(*pdwValue),
                                                     hPrinter);
    }

}


DWORD
UpdateTimeoutsFromRegistry(      
    IN HANDLE      hPrinter,
    IN HKEY        hKey,
    IN PMONITORREG pMonitorReg
    )
/*++

Routine Description:
    Get the timeout values from the registry, or initialize registry with
    default values if entries are not found.

    Users/apps can change the registry to change the behavior.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    ERROR_SUCCESS on success, else last error value

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;

    UpdateRegistryValue(hPrinter,
                        hKey,
                        pMonitorReg,
                        cszEOJTimeout,
                        &dwReadThreadEOJTimeout,
                        READ_THREAD_EOJ_TIMEOUT,
                        &dwLastError);

    dwReadThreadErrorTimeout        = READ_THREAD_ERROR_WAITTIME;
    dwReadThreadIdleTimeoutOther    = READ_THREAD_IDLE_WAITTIME;

    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_ERROR,
               ("UpdateTimeoutsFromRegistry: Failed with %d", dwLastError));
    }

    return dwLastError;
}


PINIPORT
FindIniPort(
   IN LPTSTR pszName
    )
{
    PINIPORT    pIniPort = pIniFirstPort;

    if ( !pszName || !*pszName )
        return NULL;

    SplInSem();

    while ( pIniPort && lstrcmpi(pszName, pIniPort->pszPortName))
      pIniPort = pIniPort->pNext;

   return pIniPort;
}


PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    )
/*++

Routine Description:
    Creates a IniPort entry for a port. Needs to be called inside monitor
    critical section.

Arguments:
    pszPortName       : Name of the port

Return Value:
      On success pointer to the IniPort stucture.
      On failure NULL

--*/
{
    PINIPORT    pIniPort, pPort;
    HANDLE      DoneWriting = NULL;

    SplInSem();

    DoneWriting = CreateEvent(NULL, FALSE, TRUE, NULL);
    if ( !DoneWriting )
        return NULL;

    pIniPort = (PINIPORT) AllocSplMem(sizeof(*pIniPort));
    if ( !pIniPort ) {

        CloseHandle(DoneWriting);
        return NULL;
    }

    pIniPort->pszPortName       = AllocSplStr(pszPortName);

    if ( !pIniPort->pszPortName ) {

        CloseHandle(DoneWriting);
        FreeSplMem(pIniPort);
        return NULL;
    }

    pIniPort->pNext         = NULL;
    pIniPort->signature     = PJ_SIGNATURE;
    pIniPort->DoneWriting   = DoneWriting;

    pIniPort->pNext         = pIniFirstPort;
    pIniFirstPort           = pIniPort;

    return pIniPort;
}


VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    )
/*++

Routine Description:
    Deletes a port entry. Needs to be called inside monitor critical section

Arguments:
    pIniPort    : Pointer to the IniPort structure to be deleted

Return Value:

--*/
{
    SplInSem();

    if ( pIniPort == pIniFirstPort ) {

        pIniFirstPort = pIniPort->pNext;
    } else {

        PINIPORT    pPort;

        pPort = pIniFirstPort;
        while ( pPort && pPort->pNext != pIniPort )
            pPort = pPort->pNext;

        if (pPort) {

            pPort->pNext = pIniPort->pNext;
        } else {

            DBGMSG(DBG_ERROR, ("pjlmon: DeletePortEntry port not found\n"));
            return;
        }
    }

    CloseHandle(pIniPort->DoneWriting);
    FreeIniJobs(pIniPort);
    FreeSplStr(pIniPort->pszPortName);
    FreeSplMem(pIniPort);

    return;
}


VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    )
/*++

Routine Description:
    Deletes a job entry.

Arguments:
    pIniJob    : Pointer to the IniJob structure to be deleted

Return Value:
    None

--*/
{
    SPLASSERT(pIniJob);
    if ( pIniJob->hPrinter )
        ClosePrinter(pIniJob->hPrinter);
    FreeSplMem(pIniJob);
}


VOID
FreeIniJobs(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Free all the InJob structures assigned to this port

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed

--*/
{
    PINIJOB pIniJob, pIniNextJob;

    EnterSplSem();
    pIniJob = pIniPort->pIniJob;
    while ( pIniJob ) {

        pIniNextJob = pIniJob->pNext;
        FreeIniJob(pIniJob);
        pIniJob = pIniNextJob;
    }

    pIniPort->pIniJob = NULL;
    LeaveSplSem();
}


VOID
SendLastPageEjectedForIniJob(
    PINIPORT    pIniPort,
    PINIJOB     pIniJob
    )
{
    SplInSem();

    if ( !SetJob(pIniJob->hPrinter, pIniJob->JobId, 0,
                 NULL, JOB_CONTROL_LAST_PAGE_EJECTED) ) {

        DBGMSG(DBG_WARNING,
               ("SetJob failed with last error %d\n", GetLastError()));
    }
}


PINIJOB
FindIniJobFromJobId(
    PINIPORT    pIniPort,
    DWORD       dwJobId,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pCur, pPre, pIniJob;

    SplInSem();

    //
    // If JOB_RESTART is given there will be multiple jobs with same id
    // we need to find the last entry with given id in the list
    //
    for ( pCur = pIniPort->pIniJob, pPre = pIniJob = *ppPrevIniJob = NULL ;
          pCur ;
          pPre = pCur, pCur = pCur->pNext ) {

        if ( pCur->JobId == dwJobId ) {

            *ppPrevIniJob   = pPre;
            pIniJob         = pCur;
        }
    }

    return pIniJob;
}


PINIJOB
FindFirstIniJobTimedOut(
    PINIPORT    pIniPort,
    DWORD       dwTime,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pIniJob = pIniPort->pIniJob;

    SplInSem();
    *ppPrevIniJob = NULL;

    //
    // Look for a job not in STARTDOC and timedout
    //
    while ( pIniJob &&
            ( (pIniJob->status & PP_INSTARTDOC) ||
               pIniJob->TimeoutCount > dwTime ) ) {

        *ppPrevIniJob = pIniJob;
        pIniJob = pIniJob->pNext;
    }

    if ( !pIniJob )
        *ppPrevIniJob = NULL;

    return pIniJob;
}


VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    )
/*++

Routine Description:
    Send LastPageEjected notification for 1 or more jobs to spooler

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed
    dwValue     : if bTime is TRUE send EOJ to any jobs rcvd before dwValue
                  else dwValue is JobId -- ALL_JOBS is for all jobs
    bTime       : Tells how to interpret dwValue

--*/
{
    PINIJOB pIniJob;

    EnterSplSem();
    //
    // JobId == ALL_JOBS is a special case where we want to send LastPage
    // ejected for all jobs pending
    //
    if ( !bTime && dwValue == ALL_JOBS ) {

        pIniJob = pIniPort->pIniJob;
        pIniPort->pIniJob = NULL;

        while ( pIniJob ) {

            PINIJOB pTempJob = pIniJob;

            SendLastPageEjectedForIniJob(pIniPort, pIniJob);
            pIniJob = pIniJob->pNext;
            FreeIniJob(pTempJob);
        }

    } else {

        PINIJOB pPrevIniJob = NULL;

        pIniJob = pIniPort->pIniJob;

        //
        // If bTime we want to send LastPageEjected for all jobs timedout
        //
        if ( bTime )  {

            pIniJob = FindFirstIniJobTimedOut(pIniPort, dwValue, &pPrevIniJob);
        } else {

            pIniJob = FindIniJobFromJobId(pIniPort, dwValue, &pPrevIniJob);
        }

        if ( pIniJob ) {

            //
            // Send notifications for any previous jobs too
            //
            if ( pIniPort->pIniJob == pIniJob )
                pIniPort->pIniJob = NULL;
            else
                pPrevIniJob->pNext = NULL;

            do {

                SendLastPageEjectedForIniJob(pIniPort, pIniJob);

                pPrevIniJob = pIniJob;
                pIniJob = pIniJob->pNext;
                FreeIniJob(pPrevIniJob);
            } while ( pIniJob );
        }
    }

    LeaveSplSem();
}



// -----------------------------------------------------------------------
//
// DEBUG Stuff
//
// -----------------------------------------------------------------------
#ifdef DEBUG

DWORD SplDbgLevel = 0;

#ifndef INTERNAL

VOID cdecl DbgMsg( LPSTR MsgFormat, ... )
{
    char   MsgText[1024];

    sprintf(MsgText,MsgFormat,(LPSTR)(((LPSTR)(&MsgFormat))+sizeof(MsgFormat)) );
    strcat( MsgText, "\r");

    OutputDebugStringA(MsgText);
}
#endif

#endif


// -----------------------------------------------------------------------
//
// String helper function to remove crt dependency
//
// -----------------------------------------------------------------------
int
mystrnicmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}


LPSTR
mystrchr(
    LPSTR cs,
    char c
)
{
    while (*cs != 0)
    {
        if (IsDBCSLeadByte(*cs))
          cs++;
        else
        if (*cs == c)
            return cs;
        cs++;
    }

    // fail to find c in cs
    return NULL;
}


int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}


// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\dot4port.h ===
// Dot4Port.h: interface for the Dot4Port class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_)
#define AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CDot4Port : public CBasePort
{
public:
   CDot4Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CDot4Port();
   PORTTYPE getPortType( void );

protected:
   BOOL checkPnP();

};

#endif // !defined(AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved

Module Name:

    Debug.h

Abstract:

   Debug header for DynaMon

Environment:

    User Mode -Win32

Revision History:

--*/

//
// Debug levels
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004

extern  DWORD   DynaMonDebug;

#ifndef MODULE
#define MODULE "DynaMon:"
#define MODULE_DEBUG DynaMonDebug
#endif


#if DEBUG

#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

#else
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\baseport.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    BasePort.h

Abstract:
    Interface for the CBasePort class.

Author: M. Fenelon

Revision History:

--*/

//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_)
#define AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CBasePort
{
public:
   CBasePort();
   CBasePort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath, LPTSTR pszPortDesc );
   virtual ~CBasePort();
   BOOL startDoc( LPTSTR pPrinterName, DWORD dwJobId, DWORD dwLevel, LPBYTE pDocInfo );
   BOOL endDoc();
   BOOL write( LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten );
   BOOL read( LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead );
   virtual BOOL getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );
   virtual BOOL setPortTimeOuts( LPCOMMTIMEOUTS lpCTO );
   void ClearCS();
   void InitCS();
   virtual PORTTYPE getPortType( void );
   LPTSTR getPortDesc();
   virtual void setPortDesc( LPTSTR pszPortDesc );
   // DWORD getDeviceFlags( void );
   // void setDeviceFlags(DWORD dwFlags, DWORD dwType = SET_FLAGS);
   // BOOL compDeviceFlags( DWORD dwFlags );
   BOOL isActive( void );
   void setActive( BOOL bValue );
   BOOL compActiveState( BOOL bValue );
   LPTSTR getDevicePath( void );
   void setDevicePath( LPTSTR pszDevicePath );
   INT compDevicePath( LPTSTR pszDevicePath );
   LPTSTR getPortName( void );
   void setPortName( LPTSTR pszPortName );
   INT compPortName( LPTSTR pszPortName );
   DWORD getEnumInfoSize( DWORD Level );
   LPBYTE copyEnumInfo( DWORD dwLevel, LPBYTE pPort, LPBYTE pEnd );
   void setMaxBuffer(DWORD dwMaxBufferSize);

protected:
   DWORD       m_cRef;
   DWORD       m_dwFlags;
   BOOL        m_bActive;              // Is this port currently Active
   DWORD       m_dwJobId;
   DWORD       m_dwMaxBufferSize;
   HANDLE      m_hDeviceHandle;
   HANDLE      m_hPrinter;
   LPBYTE      m_pWriteBuffer;
   DWORD       m_dwBufferSize,         // dwBufferSize     : size of buffer
               m_dwDataSize,           // dwDataSize       : size of data in buffer
                                       //      (could be smaller than dwBufferSize)
               m_dwDataCompleted,      // dwDataCompleted  : size of data sent and acknowledged
               m_dwDataScheduled;      // dwScheduledData  : size of data we have scheduled using WriteFile
   OVERLAPPED  m_Ov;
   CRITICAL_SECTION m_CritSec;
   DWORD       m_dwReadTimeoutMultiplier;
   DWORD       m_dwReadTimeoutConstant;
   DWORD       m_dwWriteTimeoutMultiplier;
   DWORD       m_dwWriteTimeoutConstant;
   TCHAR       m_szPortName[MAX_PORT_LEN];
   TCHAR       m_szPortDescription[MAX_PORT_DESC_LEN];
   TCHAR       m_szDevicePath[MAX_PATH];

   virtual BOOL checkPnP();
   BOOL getLPTStatus(HANDLE hDeviceHandle,BYTE *Status );
   DWORD getTimeLeft( DWORD dwStartTime,DWORD dwTimeout );
   void freeWriteBuffer();
   BOOL needToResubmitJob( DWORD dwError );
   DWORD getWriteStatus( DWORD dwTimeOut );
   BOOL abortThisJob();
   virtual DWORD adjustWriteSize( DWORD dwBytesToWrite );
   void invalidatePortHandle();
   DWORD sendQueuedData();
   DWORD writeData();
   BOOL close();
   void closePrinter();
   BOOL open();
   BOOL openPrinter( LPTSTR  pPrinterName );
   void setJobStatus( DWORD dwJobStatus );
   DWORD getJobID();
   void setJobID( DWORD dwJobID );
   BOOL notInWrite( void );

private:

};

#endif // !defined(AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\dot4port.cpp ===
// Dot4Port.cpp: implementation of the Dot4Port class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "initguid.h"
#include "ntddpar.h"


const TCHAR cszCFGMGR32[]=TEXT("cfgmgr32.dll");

const CHAR cszReenumFunc[]="CM_Reenumerate_DevNode_Ex";
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDot4Port::CDot4Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszDot4PortDesc )
{
   // Basically let the default constructor do the work.
}


CDot4Port::~CDot4Port()
{

}


PORTTYPE CDot4Port::getPortType()
{
   return DOT4PORT;
}


BOOL CDot4Port::checkPnP()
{
   SETUPAPI_INFO      SetupApiInfo;
   BOOL               bRet = FALSE;
   DWORD              dwIndex, dwLastError;
   UINT               uOldErrorMode;
   HANDLE             hToken = NULL;
   HDEVINFO           hDevList = INVALID_HANDLE_VALUE;
   SP_DEVINFO_DATA    DeviceInfoData;
   HINSTANCE          hCfgMgr32 = 0;   // Library instance.
   // Pointers to the pnp function...
   pfCM_Reenumerate_DevNode_Ex pfnReenumDevNode;

   if ( !LoadSetupApiDll( &SetupApiInfo ) )
      return FALSE;

   // For a dot4 device we need to force a pnp event on the parallel port to get the
   // dot4 stack rebuilt.
   // If any of these fail, fail the call just as if the port couldn't be opened.
   //
   // Load the pnp dll.
   uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   hCfgMgr32 = LoadLibrary( cszCFGMGR32 );
   if(!hCfgMgr32)
   {
       SetErrorMode(uOldErrorMode);
       goto Done;
   }
   SetErrorMode(uOldErrorMode);

   //
   // Get the Addressed of pnp functions we want to call...
   //
   pfnReenumDevNode = (pfCM_Reenumerate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszReenumFunc );

   if( !pfnReenumDevNode )
       goto Done;

   hToken = RevertToPrinterSelf();
   if ( !hToken )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   hDevList = SetupApiInfo.GetClassDevs( (LPGUID) &GUID_PARALLEL_DEVICE,
                                         NULL, NULL, DIGCF_INTERFACEDEVICE);

   if ( hDevList == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   // Now get the DevInst handles for each DevNode
   dwLastError = ERROR_SUCCESS;
   dwIndex = 0;
   do
   {
      DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
      if ( !SetupApiInfo.EnumDeviceInfo( hDevList,
                                         dwIndex,
                                         &DeviceInfoData) )
      {
         dwLastError = GetLastError();
         if ( dwLastError == ERROR_NO_MORE_ITEMS )
            break;      // Normal exit

         DBGMSG(DBG_WARNING,
                ("DynaMon: Dot4.CheckPnP: SetupDiEnumDeviceInfo failed with %d for index %d\n",
                 dwLastError, dwIndex));
         goto Next;
      }

      // ReEnum on the current parallel port DevNode
      pfnReenumDevNode( DeviceInfoData.DevInst, CM_REENUMERATE_NORMAL, NULL );

Next:
      dwLastError = ERROR_SUCCESS;
      ++dwIndex;
   } while ( dwLastError == ERROR_SUCCESS );

   // Revert back to the user's context.
   if ( !ImpersonatePrinterClient(hToken) )
   {
      // Failure - Clear token so it won't happen again and save the error
      hToken = NULL;
      dwLastError = GetLastError();
      goto Done;
   }

   // Impersonate worked so clear token
   hToken = NULL;

   // Try and open the port again.
   // If we fail, then the device must not be there any more or still switched off - fail as usual.
   m_hDeviceHandle = CreateFile( m_szDevicePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL);

   if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
       goto Done;

   bRet = TRUE;

Done:
   if ( hDevList != INVALID_HANDLE_VALUE )
      SetupApiInfo.DestroyDeviceInfoList( hDevList );

   if (hToken)
   {
      if ( !ImpersonatePrinterClient(hToken) )
      {
         if (bRet)
         {
            dwLastError = GetLastError();
            bRet = FALSE;
         }
      }
   }

   if ( hCfgMgr32 )
      FreeLibrary( hCfgMgr32 );

   if ( SetupApiInfo.hSetupApi )
      FreeLibrary(SetupApiInfo.hSetupApi);

   SetLastError( dwLastError );
   return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\dynamon.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaMon.h

Abstract:
    Definitons & Declarations for global info

Author: M. Fenelon

Revision History:

--*/

#include "DynaDefs.h"
#include "BasePort.h"

#ifndef DYNAMON_H

#define DYNAMON_H

typedef struct DynaMon_Port_Struct
{
   DWORD       dwSignature;
   struct      DynaMon_Port_Struct *pNext;
   CBasePort*  pBasePort;
} DYNAMON_PORT, *PDYNAMON_PORT;


typedef struct Port_Update_Struct
{
   struct Port_Update_Struct* pNext;
   TCHAR                      szPortName[MAX_PORT_LEN];
   HKEY                       hKey;
   BOOL                       bActive;
} PORT_UPDATE, *PPORT_UPDATE;

typedef struct  Useless_Port_Struct
{
   struct Useless_Port_Struct* pNext;
   TCHAR                       szDevicePath[MAX_PATH];
} USELESS_PORT, *PUSELESS_PORT;


//
// Global Data needed for Monitor
//
typedef struct  DynaMon_Monitor_Info_Struct
{
   DWORD             dwLastEnumIndex;
   PDYNAMON_PORT     pPortList;
   PUSELESS_PORT     pJunkList;
   CRITICAL_SECTION  EnumPortsCS,
                     UpdateListCS;
   PPORT_UPDATE      pUpdateList;
   HANDLE            hUpdateEvent;
} DYNAMON_MONITOR_INFO, *PDYNAMON_MONITOR_INFO;


extern DYNAMON_MONITOR_INFO gDynaMonInfo;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\dynadefs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaDefs.h

Abstract:
    Definitons & Declarations for global info

Author: M. Fenelon

Revision History:

--*/

#ifndef DYNADEFS_H

#define DYNADEFS_H

//
// Default timeout values
//
#define     READ_TIMEOUT_MULTIPLIER         0
#define     READ_TIMEOUT_CONSTANT       60000
#define     WRITE_TIMEOUT_MULTIPLIER        0
#define     WRITE_TIMEOUT_CONSTANT      60000

//
// Sizes
//
#define MAX_PORT_LEN                        20
#define MAX_PORT_DESC_LEN                   60
#define MAX_DEVICE_PATH                    256
#define PAR_QUERY_TIMEOUT                 5000

static const GUID USB_PRINTER_GUID =
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2}};

extern TCHAR   cszUSB[];
extern TCHAR   cszDOT4[];
extern TCHAR   cszTS[];
extern TCHAR   csz1394[];
extern TCHAR   cszBaseName[];
extern TCHAR   cszPortNumber[];
extern TCHAR   cszRecyclable[];
extern TCHAR   cszPortDescription[];
extern TCHAR   cszMaxBufferSize[];
extern TCHAR   cszUSBPortDesc[];
extern TCHAR   cszDot4PortDesc[];
extern TCHAR   csz1394PortDesc[];
extern TCHAR   cszTSPortDesc[];

enum PORTTYPE { USBPORT, DOT4PORT, TSPORT, P1394PORT, PARPORT, UNKNOWNPORT };

#define  DYNAMON_SIGNATURE   0x89AB

//
// Shortcuts for all Critical Section routines
//
#define  ECS(arg1)   EnterCriticalSection( &arg1 )
#define  LCS(arg1)   LeaveCriticalSection( &arg1 )
#define  ICS(arg1)   InitializeCriticalSection( &arg1 )
#define  DCS(arg1)   DeleteCriticalSection( &arg1 )

#define  IF_INVALID_PORT_FAIL( pPort )  if ( !pPort || ( pPort->dwSignature != DYNAMON_SIGNATURE ) )      \
                                        {  SetLastError(ERROR_PATH_NOT_FOUND); return FALSE; }

#define  SET_FLAGS   0
#define  ADD_FLAGS   1
#define  CLEAR_FLAGS 2


//  Define for Port Flags
#define  DYNAMON_STARTDOC          0x00000001

#define  JOB_ABORTCHECK_TIMEOUT    5000

#define  LPT_NOT_ERROR             0x08
#define  LPT_SELECT                0x10
#define  LPT_PAPER_EMPTY           0x20
#define  LPT_BENIGN_STATUS         LPT_NOT_ERROR | LPT_SELECT

#define  MAX_TIMEOUT               300000 //5 minutes

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\dynamon.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaMon.cpp

Abstract:
    Multiple Transport core port monitor routines

Author: M. Fenelon

Revision History:

--*/

#include "precomp.h"
#include "ntddpar.h"

// Global Values for Monitor
TCHAR   cszUSB[]                        = TEXT("USB");
TCHAR   cszDOT4[]                       = TEXT("DOT4");
TCHAR   cszTS[]                         = TEXT("TS");
TCHAR   csz1394[]                       = TEXT("1394");
TCHAR   cszBaseName[]                   = TEXT("Base Name");
TCHAR   cszPortNumber[]                 = TEXT("Port Number");
TCHAR   cszRecyclable[]                 = TEXT("recyclable");
TCHAR   cszPortDescription[]            = TEXT("Port Description");
TCHAR   cszMaxBufferSize[]              = TEXT("MaxBufferSize");
TCHAR   cszUSBPortDesc[]                = TEXT("Virtual printer port for USB");
TCHAR   cszDot4PortDesc[]               = TEXT("Virtual printer port for Dot4");
TCHAR   csz1394PortDesc[]               = TEXT("Virtual printer port for 1394");
TCHAR   cszTSPortDesc[]                 = TEXT("Virtual printer port for TS");

DYNAMON_MONITOR_INFO gDynaMonInfo;
DWORD   DynaMonDebug;

BOOL
APIENTRY
DllMain(
       HANDLE hModule,
       DWORD dwReason,
       LPVOID lpRes
       )
{

   if ( dwReason == DLL_PROCESS_ATTACH )
      DisableThreadLibraryCalls(hModule);

   return TRUE;
}


//  Construct MonitorEx structure to provide to Spooler
MONITOREX MonitorEx = {
sizeof(MONITOR),
{
   DynaMon_EnumPorts,
   DynaMon_OpenPort,
   NULL,                           // OpenPortEx not supported
   DynaMon_StartDocPort,
   DynaMon_WritePort,
   DynaMon_ReadPort,
   DynaMon_EndDocPort,
   DynaMon_ClosePort,
   NULL,                           // AddPort not supported
   NULL,                           // AddPortEx not supported
   NULL,                           // ConfigurePort not supported
   NULL,                           // DeletePort not supported
   DynaMon_GetPrinterDataFromPort,
   DynaMon_SetPortTimeOuts,
   NULL,                           // XcvOpenPort not supported
   NULL,                           // XcvDataPort not supported
   NULL                            // XcvClosePort not supported
}
};


LPMONITOREX
WINAPI
InitializePrintMonitor(
                      LPTSTR  pszRegistryRoot
                      )

{
   // Clear the Global info
   ZeroMemory( &gDynaMonInfo, sizeof(gDynaMonInfo) );

   // Init the basic Crit Secs
   ICS( gDynaMonInfo.EnumPortsCS );

   // Get the Background Thread going
   if ( !SpinUpdateThread() )
      return NULL;

   return &MonitorEx;
}


BOOL
WINAPI
DynaMon_EnumPorts(
                LPTSTR      pszName,
                DWORD       dwLevel,
                LPBYTE      pPorts,
                DWORD       cbBuf,
                LPDWORD     pcbNeeded,
                LPDWORD     pcReturned
                )
{
   DWORD          dwLastError = ERROR_SUCCESS, dwRequestIndex;
   LPBYTE         pEnd;
   PDYNAMON_PORT  pPortList;
   PPORT_UPDATE   pPortUpdateList = NULL;

   *pcbNeeded = *pcReturned = 0;
   if ( dwLevel != 1 && dwLevel != 2 )
   {

      SetLastError(ERROR_INVALID_LEVEL);
      return FALSE;
   }

   dwRequestIndex = gDynaMonInfo.dwLastEnumIndex;
   ECS( gDynaMonInfo.EnumPortsCS );

   if ( dwRequestIndex >= gDynaMonInfo.dwLastEnumIndex )
   {
      //
      // No complete enumeration has occurred since this request was made.
      // Since the request may be an indication that something has changed,
      // the full reenumeration must be done.
      //
      // Updated the index of enumeration before actually doing the
      // work so it will show up as the most conservative
      //
      // Consequence of rollover on gdwLastEnumIndex:
      //     Any threads that recorded 0xFFFFFFFF as the dwRequestIndex
      // will show as greater than the new value 0 and therefore reenum
      // gratuitously. Not very much extra work.
      //
      ++gDynaMonInfo.dwLastEnumIndex;
      if ( dwLastError = BuildPortList( &gDynaMonInfo, &pPortUpdateList) )
         goto Done;
   }

   for ( pPortList = gDynaMonInfo.pPortList ;
         pPortList ;
         pPortList = pPortList->pNext )
   {
      *pcbNeeded += pPortList->pBasePort->getEnumInfoSize( dwLevel );
   }

   if ( cbBuf < *pcbNeeded )
   {
      dwLastError = ERROR_INSUFFICIENT_BUFFER;
      goto Done;
   }

   pEnd = pPorts + cbBuf;

   for ( pPortList = gDynaMonInfo.pPortList ;
         pPortList ;
         pPortList = pPortList->pNext )
   {

      pEnd = pPortList->pBasePort->copyEnumInfo( dwLevel, pPorts, pEnd );
      if ( dwLevel == 1 )
          pPorts += sizeof(PORT_INFO_1);
      else
          pPorts += sizeof(PORT_INFO_2);
      ++(*pcReturned);

   }

   SPLASSERT(pEnd >= pPorts);

Done:
   // If we have anything to update do it now
   if ( pPortUpdateList )
      PassPortUpdateListToUpdateThread( pPortUpdateList );

   LCS( gDynaMonInfo.EnumPortsCS );

   if ( dwLastError )
   {
      SetLastError(dwLastError);
      return FALSE;
   }
   else
      return TRUE;
}


BOOL
WINAPI
DynaMon_OpenPort(
                LPTSTR      pszPortName,
                LPHANDLE    pHandle
                )
{
   PDYNAMON_PORT   pPort, pPrev;

   pPort = FindPort( &gDynaMonInfo, pszPortName,  &pPrev);

   if ( pPort )
   {
      *pHandle = (LPHANDLE)pPort;
      pPort->pBasePort->InitCS();
      return TRUE;
   }
   else
   {
      SetLastError(ERROR_PATH_NOT_FOUND);
      return FALSE;
   }
}


BOOL
WINAPI
DynaMon_ClosePort(
                 HANDLE  hPort
                 )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   pPort->pBasePort->ClearCS();
   return TRUE;
}


BOOL
WINAPI
DynaMon_StartDocPort(
                    HANDLE  hPort,
                    LPTSTR  pPrinterName,
                    DWORD   dwJobId,
                    DWORD   dwLevel,
                    LPBYTE  pDocInfo
                    )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->startDoc( pPrinterName, dwJobId, dwLevel, pDocInfo );
}


BOOL
WINAPI
DynaMon_EndDocPort(
                  HANDLE  hPort
                  )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->endDoc();
}


BOOL
WINAPI
DynaMon_GetPrinterDataFromPort(
                              HANDLE      hPort,
                              DWORD       dwControlID,
                              LPWSTR      pValueName,
                              LPWSTR      lpInBuffer,
                              DWORD       cbInBuffer,
                              LPWSTR      lpOutBuffer,
                              DWORD       cbOutBuffer,
                              LPDWORD     lpcbReturned
                              )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->getPrinterDataFromPort( dwControlID, pValueName, lpInBuffer, cbInBuffer,
                                                    lpOutBuffer, cbOutBuffer, lpcbReturned );
}


BOOL
WINAPI
DynaMon_ReadPort(
                HANDLE      hPort,
                LPBYTE      pBuffer,
                DWORD       cbBuffer,
                LPDWORD     pcbRead
                )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->read( pBuffer, cbBuffer, pcbRead );
}


BOOL
WINAPI
DynaMon_WritePort(
                 HANDLE      hPort,
                 LPBYTE      pBuffer,
                 DWORD       cbBuffer,
                 LPDWORD     pcbWritten
                 )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->write( pBuffer, cbBuffer, pcbWritten );
}


BOOL
WINAPI
DynaMon_SetPortTimeOuts(
                       HANDLE hPort,
                       LPCOMMTIMEOUTS lpCTO,
                       DWORD reserved
                       )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->setPortTimeOuts( lpCTO );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\enumports.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    enumports.h

Abstract:

    USBMON header file


--*/

//
// Sizes
//
#define MAX_PORT_LEN                        20
#define MAX_PORT_DESC_LEN                   60
#define MAX_DEVICE_PATH                    256
#define PAR_QUERY_TIMEOUT                 5000

static const GUID USB_PRINTER_GUID =
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };

//
// Functions needed
#ifdef UNICODE
#define lstrchr     wcschr
#define lstrncmpi   _wcsnicmp
#else
#define lstrchr     strchr
#define lstrncmpi   _strnicmp
#endif

#define USB_SIGNATURE   0x89AB


typedef struct USBMON_PORT_INFO_DEF {

    DWORD       dwSignature;
    struct USBMON_PORT_INFO_DEF *pNext;
    DWORD       cRef;
    DWORD       dwFlags;
    DWORD       dwDeviceFlags;
    DWORD       dwJobId;
    HANDLE      hDeviceHandle;
    HANDLE      hPrinter;
    LPBYTE      pWriteBuffer;
    //
    // dwBufferSize     : size of buffer
    // dwDataSize       : size of data in buffer
    //                      (could be smaller than dwBufferSize)
    // dwDataCompleted  : size of data sent and acknowledged
    // dwScheduledData  : size of data we have scheduled using WriteFile
    //
    DWORD       dwBufferSize, dwDataSize, dwDataCompleted, dwDataScheduled;
    OVERLAPPED  Ov;
    CRITICAL_SECTION    CriticalSection;
    DWORD       ReadTimeoutMultiplier;
    DWORD       ReadTimeoutConstant;
    DWORD       WriteTimeoutMultiplier;
    DWORD       WriteTimeoutConstant;
    TCHAR       szPortName[MAX_PORT_LEN];
    TCHAR       szPortDescription[MAX_PORT_DESC_LEN];
    TCHAR       szDevicePath[256];
} USBMON_PORT_INFO, *PUSBMON_PORT_INFO;


#define     USBMON_STARTDOC             0x00000001


typedef struct  PORT_UPDATE_INFO_DEF {
    struct  PORT_UPDATE_INFO_DEF   *pNext;
    TCHAR                           szPortName[MAX_PORT_LEN];
    HKEY                            hKey;
    BOOL                            bActive;
} PORT_UPDATE_INFO, *PPORT_UPDATE_INFO;

typedef struct  USELESS_PORT_INFO_DEF {

    struct USELESS_PORT_INFO_DEF   *pNext;
    TCHAR                           szDevicePath[256];
} USELESS_PORT_INFO, *PUSELESS_PORT_INFO;

typedef struct  USBMON_MONITOR_INFO_DEF {

    DWORD                   dwLastEnumIndex, dwEnumPortCount,
                            dwPortCount, dwUselessPortCount;
    PUSBMON_PORT_INFO       pPortInfo;
    PUSELESS_PORT_INFO      pJunkList;
    CRITICAL_SECTION        EnumPortsCS, BackThreadCS;
} USBMON_MONITOR_INFO, *PUSBMON_MONITOR_INFO;


typedef struct BACKGROUND_THREAD_DEF {

        PUSBMON_MONITOR_INFO    pMonitorInfo;
        PPORT_UPDATE_INFO       pPortUpdateList;
        HANDLE                  hWaitToStart;
} BACKGROUND_THREAD_DATA, PBACKGROUND_THREAD_DATA;

extern  USBMON_MONITOR_INFO gUsbmonInfo;

PUSBMON_PORT_INFO
FindPort(
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    LPTSTR                  pszPortName,
    PUSBMON_PORT_INFO      *pPrev
    );

BOOL
WINAPI
USBMON_EnumPorts(
    LPTSTR      pszName,
    DWORD       dwLevel,
    LPBYTE      pPorts,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\enumutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    EnumUtil.cpp

Abstract:
    Utiltiy functions used by the EnumPorts function.

Author: M. Fenelon

Revision History:

--*/

#include "precomp.h"

TCHAR   sComma = TEXT(',');
TCHAR   sNull  = TEXT('\0');

BOOL
SpinUpdateThread( void )
{
   HANDLE  hThread = NULL, hEvent;
   DWORD   dwThreadId, dwLastError;
   BOOL    bRC = TRUE;

   ICS( gDynaMonInfo.UpdateListCS );

   if ( gDynaMonInfo.hUpdateEvent = CreateEvent(NULL, FALSE, FALSE, NULL) )
   {

      if ( hThread = CreateThread(NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)UpdateThread,
                                  &gDynaMonInfo,
                                  0,
                                  &dwThreadId) )
      {
         CloseHandle(hThread);
      }
      else
      {
         dwLastError = GetLastError();
         CloseHandle(gDynaMonInfo.hUpdateEvent);
         bRC = FALSE;
         SetLastError( dwLastError );
      }
   }

   return bRC;

}


VOID
UpdateThread(
    PDYNAMON_MONITOR_INFO   pMonInfo
    )
{
   PPORT_UPDATE        pUpdateList = NULL,
                       pNext;
   DWORD               dwPrinters;
   LPPRINTER_INFO_5    pPrinterInfo5List = NULL;
   BOOL bCheck;

   // Loop indefinitely
   while ( 1 )
   {
      // Wait for the Event to be signaled
      WaitForSingleObject( pMonInfo->hUpdateEvent, INFINITE );

      // Get access to the Update List Pointer
      ECS( pMonInfo->UpdateListCS );

      // Get the current list
      pUpdateList = pMonInfo->pUpdateList;
      pMonInfo->pUpdateList = NULL;

      // Release acces to the list pointer
      LCS( pMonInfo->UpdateListCS );

      dwPrinters = 0;
      pPrinterInfo5List = NULL;
      bCheck = GetPrinterInfo( &pPrinterInfo5List, &dwPrinters );

      // If there is anything in the list process it....
      while ( pUpdateList )
      {
         // First get a pointer to the next update
         pNext = pUpdateList->pNext;

         if ( bCheck &&
              !PortNameNeededBySpooler( pUpdateList->szPortName,
                                        pPrinterInfo5List,
                                        dwPrinters,
                                        pUpdateList->bActive )     &&
              !pUpdateList->bActive )
         {
            RegSetValueEx( pUpdateList->hKey, cszRecyclable, 0, REG_NONE, 0, 0);
         }

         // Close the Reg Key & Free the memory
         RegCloseKey( pUpdateList->hKey);
         FreeSplMem( pUpdateList );
         pUpdateList = pNext;
      }

      if ( pPrinterInfo5List )
         FreeSplMem( pPrinterInfo5List );

   }

}

BOOL
GetPrinterInfo(
              OUT LPPRINTER_INFO_5   *ppPrinterInfo5,
              OUT LPDWORD             pdwReturned
              )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_5s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPrinterInfo5  : Points to PRINTER_INFO_5s on return
    pdwReturned     : Tells how many PRINTER_INFO_5s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
   BOOL            bRet = FALSE;
   static  DWORD   dwNeeded = 0;
   LPBYTE          pBuf = NULL;

   *pdwReturned = 0;

   if ( !(pBuf = (LPBYTE) AllocSplMem( dwNeeded ) ) )
      goto Cleanup;

   if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      5,
                      pBuf,
                      dwNeeded,
                      &dwNeeded,
                      pdwReturned) )
   {
      if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
         goto Cleanup;

      FreeSplMem(pBuf);
      if ( !(pBuf = (LPBYTE) AllocSplMem( dwNeeded ) )   ||
           !EnumPrinters(PRINTER_ENUM_LOCAL,
                         NULL,
                         5,
                         pBuf,
                         dwNeeded,
                         &dwNeeded,
                         pdwReturned) )
      {
         goto Cleanup;
      }
   }

   bRet = TRUE;

Cleanup:

   if ( bRet && *pdwReturned )
   {
      *ppPrinterInfo5 = (LPPRINTER_INFO_5)pBuf;
   }
   else
   {
      FreeSplMem(pBuf);
      *ppPrinterInfo5 = NULL;
      *pdwReturned = 0;
   }

   return bRet;
}


BOOL
PortNameNeededBySpooler(
                       IN  LPTSTR           pszPortName,
                       IN  LPPRINTER_INFO_5 pPrinterInfo5,
                       IN  DWORD            dwPrinters,
                       IN  BOOL             bActive
                       )
/*++

Routine Description:
    Tells if a port is needed by spooler. Any port to which spooler currently
    has a printer going is needed.

Arguments:
    pszPortName         : Port name in question
    pPrinterInfo5       : List of PrinterInfo5s
    dwPrinters          : Count of the list of printers

Return Value:
    TRUE if spooler currently has a printer which is using the port
    FALSE otherwise

--*/
{
   BOOL    bPortUsedByAPrinter = FALSE,
           bPrinterUsesOnlyThisPort;
   DWORD   dwIndex;
   LPTSTR  pszStr1, pszStr2;

   for ( dwIndex = 0 ; dwIndex < dwPrinters ; ++dwIndex, ++pPrinterInfo5 )
   {

      bPrinterUsesOnlyThisPort = FALSE;
      //
      // Port names are returned comma separated by spooler,
      // and there are blanks
      //
      pszStr1 = pPrinterInfo5->pPortName;

      if ( _tcsicmp( (LPCTSTR) pszPortName, pszStr1 ) == 0 )
         bPortUsedByAPrinter = bPrinterUsesOnlyThisPort = TRUE;
      else
      {
         //
         // Look at each port in the list of ports printer uses
         //
         while ( pszStr2 = _tcschr( pszStr1, sComma ) )
         {
            *pszStr2 = sNull;
            if ( _tcsicmp( pszPortName, pszStr1 ) == 0 )
               bPortUsedByAPrinter = TRUE;
            *pszStr2 = sComma;  // Put the comma back

            if ( bPortUsedByAPrinter )
               break;

            pszStr1 = pszStr2 + 1;

            // Skip spaces
            while ( *pszStr1 == TEXT(' ') )
               ++pszStr1;
         }

         if ( !bPortUsedByAPrinter )
            bPortUsedByAPrinter = _tcsicmp( pszPortName, pszStr1 ) == 0;
      }

      // We will change only status of printer for non-pooled printers only
      if ( bPrinterUsesOnlyThisPort )
         SetOnlineStaus( pPrinterInfo5, bActive );
   }

   return bPortUsedByAPrinter;
}


BOOL
SetOnlineStaus(
              LPPRINTER_INFO_5    pPrinterInfo5,
              BOOL                bOnline
              )
{
   BOOL                bRet = FALSE;
   HANDLE              hPrinter;
   PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

   //
   // Don't change Online Status at all for TS ports
   //
   if ( _tcsnicmp( pPrinterInfo5->pPortName, cszTS, _tcslen(cszTS) ) == 0 )
      return TRUE;

   //
   // Force all DOT4 ports to remain online at all times.
   //
   if ( _tcsnicmp( pPrinterInfo5->pPortName, cszDOT4, _tcslen(cszDOT4) ) == 0 )
      bOnline = TRUE;

   //
   // Check if spooler already has the correct status
   //  (can happen on spooler startup)
   //
   if ( bOnline )
   {
      if ( !(pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) )
         return TRUE;
   }
   else
      if ( pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
         return TRUE;

   if ( !OpenPrinter( pPrinterInfo5->pPrinterName, &hPrinter, &PrinterDefault ) )
      return FALSE;

   if ( bOnline )
      pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
   else
      pPrinterInfo5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

   bRet = SetPrinter( hPrinter, 5, (LPBYTE)pPrinterInfo5, 0 );

   ClosePrinter( hPrinter );

   return bRet;
}


DWORD
BuildPortList(
             PDYNAMON_MONITOR_INFO pMonitorInfo,
             PPORT_UPDATE*         ppPortUpdateList
             )
{
   DWORD           dwLastError;
   SETUPAPI_INFO   SetupApiInfo;

   if ( !LoadSetupApiDll( &SetupApiInfo ) )
      return GetLastError();

   ECS( pMonitorInfo->EnumPortsCS );

   dwLastError = ProcessGUID( &SetupApiInfo, pMonitorInfo,
                              ppPortUpdateList, (LPGUID) &USB_PRINTER_GUID );

   LCS( pMonitorInfo->EnumPortsCS );

   if ( SetupApiInfo.hSetupApi )
      FreeLibrary(SetupApiInfo.hSetupApi);

   return dwLastError;
}


BOOL
LoadSetupApiDll(
               PSETUPAPI_INFO  pSetupInfo
               )
{
   UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   pSetupInfo->hSetupApi = LoadLibrary(TEXT("setupapi"));
   SetErrorMode(uOldErrMode);


   if ( !pSetupInfo->hSetupApi )
      return FALSE;

   pSetupInfo->DestroyDeviceInfoList = (pfSetupDiDestroyDeviceInfoList) GetProcAddress(pSetupInfo->hSetupApi,
                                                                "SetupDiDestroyDeviceInfoList");

   pSetupInfo->GetClassDevs = (pfSetupDiGetClassDevs) GetProcAddress(pSetupInfo->hSetupApi,
                                                       "SetupDiGetClassDevsW");

   pSetupInfo->EnumDeviceInfo = (pfSetupDiEnumDeviceInfo) GetProcAddress(pSetupInfo->hSetupApi,
                                                               "SetupDiEnumDeviceInfo");

   pSetupInfo->EnumDeviceInterfaces = (pfSetupDiEnumDeviceInterfaces) GetProcAddress(pSetupInfo->hSetupApi,
                                                               "SetupDiEnumDeviceInterfaces");

   pSetupInfo->GetDeviceInterfaceDetail = (pfSetupDiGetDeviceInterfaceDetail) GetProcAddress(pSetupInfo->hSetupApi,
                                                                   "SetupDiGetDeviceInterfaceDetailW");

   pSetupInfo->OpenDeviceInterfaceRegKey = (pfSetupDiOpenDeviceInterfaceRegKey) GetProcAddress(pSetupInfo->hSetupApi,
                                                                    "SetupDiOpenDeviceInterfaceRegKey");

   if ( !pSetupInfo->DestroyDeviceInfoList         ||
        !pSetupInfo->GetClassDevs                  ||
        !pSetupInfo->EnumDeviceInfo                ||
        !pSetupInfo->EnumDeviceInterfaces          ||
        !pSetupInfo->GetDeviceInterfaceDetail      ||
        !pSetupInfo->OpenDeviceInterfaceRegKey )
   {
      SPLASSERT(FALSE);
      FreeLibrary(pSetupInfo->hSetupApi);
      pSetupInfo->hSetupApi = NULL;
      return FALSE;
   }

   return TRUE;
}


DWORD
ProcessGUID(
           PSETUPAPI_INFO           pSetupApiInfo,
           PDYNAMON_MONITOR_INFO    pMonitorInfo,
           PPORT_UPDATE*            ppPortUpdateList,
           LPGUID                   pGUID
           )
{
   DWORD                               dwIndex, dwLastError, dwSize, dwNeeded;
   BOOL                                bIsPortActive;
   HANDLE                              hToken;
   HDEVINFO                            hDevList = INVALID_HANDLE_VALUE;
   PDYNAMON_PORT                       pPtr;
   PUSELESS_PORT                       pCur, pPrev;
   SP_DEVICE_INTERFACE_DATA            DeviceInterface;
   PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail = NULL;

   hToken = RevertToPrinterSelf();

   hDevList = pSetupApiInfo->GetClassDevs( pGUID,
                                           NULL,
                                           NULL,
                                           DIGCF_INTERFACEDEVICE);

   if ( hDevList == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   dwSize = sizeof(PSP_DEVICE_INTERFACE_DETAIL_DATA)
            + MAX_DEVICE_PATH * sizeof(TCHAR);

   pDeviceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA) AllocSplMem(dwSize);

   if ( !pDeviceDetail )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   dwLastError = ERROR_SUCCESS;
   dwIndex = 0;
   pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
   DeviceInterface.cbSize  = sizeof(DeviceInterface);
   do
   {
      if ( !pSetupApiInfo->EnumDeviceInterfaces( hDevList,
                                                 NULL,
                                                 pGUID,
                                                 dwIndex,
                                                 &DeviceInterface) )
      {
         dwLastError = GetLastError();
         if ( dwLastError == ERROR_NO_MORE_ITEMS )
            break;      // Normal exit

         DBGMSG(DBG_WARNING,
                ("DynaMon: ProcessGUID: SetupDiEnumDeviceInterfaces failed with %d for inderx %d\n",
                 dwLastError, dwIndex));
         goto Next;
      }

      if ( !pSetupApiInfo->GetDeviceInterfaceDetail( hDevList,
                                                     &DeviceInterface,
                                                     pDeviceDetail,
                                                     dwSize,
                                                     &dwNeeded,
                                                     NULL) )
      {
         dwLastError = GetLastError();
         DBGMSG(DBG_ERROR,
                ("DynaMon: ProcessGUID: SetupDiGetDeviceInterfaceDetail failed with error %d size %d\n",
                 dwLastError, dwNeeded));
         goto Next;
      }

      //
      // This is the only flag we care about
      //
      bIsPortActive = (DeviceInterface.Flags & SPINT_ACTIVE);

      //
      // For inactive port if it is already known as a useless port
      // no need to process further
      //
      if ( !bIsPortActive && FindUselessEntry( pMonitorInfo, pDeviceDetail->DevicePath, &pPrev) )
      {
         goto Next;
      }

      //
      // When port active status did not change we should have nothing
      // to update. By skipping the PortUpdateInfo we avoid registry access
      // and it is a performance improvement
      //
      if ( (pPtr = FindPortUsingDevicePath( pMonitorInfo,
                                            pDeviceDetail->DevicePath ) )    &&
            pPtr->pBasePort->compActiveState( bIsPortActive ) )
      {
         goto Next;
      }

      ProcessPortInfo( pSetupApiInfo, pMonitorInfo, hDevList, &DeviceInterface,
                       pDeviceDetail, bIsPortActive, ppPortUpdateList);

Next:
      dwLastError = ERROR_SUCCESS;
      ++dwIndex;
      pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
      DeviceInterface.cbSize  = sizeof(DeviceInterface);
   } while ( dwLastError == ERROR_SUCCESS );

   if ( dwLastError == ERROR_NO_MORE_ITEMS )
      dwLastError = ERROR_SUCCESS;

Done:
   if ( hDevList != INVALID_HANDLE_VALUE )
      pSetupApiInfo->DestroyDeviceInfoList( hDevList );

   if ( !ImpersonatePrinterClient(hToken) )
      dwLastError = GetLastError();

   FreeSplMem(pDeviceDetail);

   return dwLastError;
}


PUSELESS_PORT
FindUselessEntry(
                IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                IN  LPTSTR                pszDevicePath,
                OUT PUSELESS_PORT*        ppPrev
                )

/*++
Routine Description:
    Searches for a device path in the useless port list

Arguments:

Return Value:
    NULL if no entry found in the list
    Else a valid USELESS_PORT_INFO pointer
    Weather port is found or not *ppPrev will return the previous element

--*/
{
   INT            iCmp;
   PUSELESS_PORT  pHead;

   for ( pHead = pMonitorInfo->pJunkList, *ppPrev = NULL ;
       pHead && (iCmp = lstrcmp(pszDevicePath, pHead->szDevicePath)) < 0 ;
       *ppPrev = pHead, pHead = pHead->pNext )
      ;

   //
   // If useless port should go in the middle but not currently there
   //
   if ( pHead && iCmp != 0 )
      pHead = NULL;

   return pHead;
}


PDYNAMON_PORT
FindPortUsingDevicePath(
                       IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                       IN  LPTSTR                pszDevicePath
                       )
/*++

Routine Description:
    Finds a port by device path.

Arguments:
    pMonitorInfo    : Pointer to MONITOR_INFO structure
    pszDevicePath   : Device path name to search for

Return Value:
    If NULL port is not in list, else pointer to the PORT_INFO entry for the
    given device path

--*/
{
   INT           iCmp;
   PDYNAMON_PORT pHead;

   ECS( pMonitorInfo->EnumPortsCS );

   //
   // Port list is sorted on port name, so we have to scan the whole list
   //
   for ( pHead = pMonitorInfo->pPortList ; pHead ; pHead = pHead->pNext )
      if ( pHead->pBasePort->compDevicePath( pszDevicePath ) == 0 )
         break;

   LCS( pMonitorInfo->EnumPortsCS );

   return pHead;
}


VOID
ProcessPortInfo(
               IN      PSETUPAPI_INFO                   pSetupApiInfo,
               IN      PDYNAMON_MONITOR_INFO            pMonitorInfo,
               IN      HDEVINFO                         hDevList,
               IN      PSP_DEVICE_INTERFACE_DATA        pDeviceInterface,
               IN      PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,
               IN      BOOL                             bIsPortActive,
               IN OUT  PPORT_UPDATE*                    ppPortUpdateList
               )
{
   HKEY                hKey = INVALID_HANDLE_VALUE;
   TCHAR               szPortName[MAX_PORT_LEN];
   PDYNAMON_PORT       pCur, pPrev;
   PORTTYPE            portType = USBPORT;

   hKey = GetPortNameAndRegKey( pSetupApiInfo, hDevList, pDeviceInterface,
                                szPortName, &portType );

   if ( hKey == INVALID_HANDLE_VALUE )
   {
      //
      // If this port is inactive and is not in our known port list
      // add to useless list. Earlier we would have been opening the registry
      // every time and find that port number is missing because of KM drivers
      // not deleting the inactive device interfaces
      //
      if ( !bIsPortActive  &&
           !FindPortUsingDevicePath(pMonitorInfo, pDeviceDetail->DevicePath) )
         AddUselessPortEntry(pMonitorInfo, pDeviceDetail->DevicePath);

      return;
   }

   pCur = FindPort(pMonitorInfo, szPortName, &pPrev);

   //
   // Port info is currently in our list?
   //
   if ( pCur )
   {
      //
      // Did the device path or flags change?
      //
      if ( !pCur->pBasePort->compActiveState( bIsPortActive )     ||
           pCur->pBasePort->compDevicePath( pDeviceDetail->DevicePath ) )
      {
         UpdatePortInfo( pCur, pDeviceDetail->DevicePath,
                         bIsPortActive, &hKey, ppPortUpdateList);
      }
   }
   else
   {

      AddPortToList( portType, szPortName, pDeviceDetail->DevicePath,
                     bIsPortActive, &hKey, pMonitorInfo, pPrev,
                     ppPortUpdateList);

   }

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hKey);
}


HKEY
GetPortNameAndRegKey(
                    IN  PSETUPAPI_INFO              pSetupInfo,
                    IN  HDEVINFO                    hDevList,
                    IN  PSP_DEVICE_INTERFACE_DATA   pDeviceInterface,
                    OUT LPTSTR                      pszPortName,
                    OUT PORTTYPE*                   pPortType
                    )
/*++

Routine Description:
    Find port name for a device interface and also return reg handle

Arguments:
    hDevList            : List of USB printer devices
    pDeviceInterface    : pointer to device interface in question
    pszPortName         : Port name on return.

Return Value:
    INVALID_HANDLE_VALUE on some errors.
    Otherwize a valid registry handle with pszPortName giving port name

--*/
{
   HKEY    hKey = INVALID_HANDLE_VALUE;
   DWORD   dwPortNumber, dwNeeded, dwLastError;
   TCHAR   szPortBaseName[MAX_PORT_LEN-3];

   hKey = pSetupInfo->OpenDeviceInterfaceRegKey(hDevList,
                                                pDeviceInterface,
                                                0,
                                                KEY_ALL_ACCESS);
   if ( hKey == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      DBGMSG(DBG_ERROR,
             ("DynaMon: GetPortNameAndRegKey: SetupDiOpenDeviceInterfaceRegKey failed with error %d\n",
              dwLastError));
      return INVALID_HANDLE_VALUE;
   }

   dwNeeded = sizeof(dwPortNumber);
   if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortNumber, 0, NULL,
                                         (LPBYTE)&dwPortNumber, &dwNeeded) )
   {

      DBGMSG(DBG_WARNING,
             ("DynaMon: GetPortNameAndRegKey: RegQueryValueEx failed for port number\n"));
      goto Fail;
   }

   dwNeeded = sizeof(szPortBaseName);
   if ( ERROR_SUCCESS != (dwLastError =  RegQueryValueEx(hKey, cszBaseName, 0, NULL,
                                                        (LPBYTE)szPortBaseName, &dwNeeded) ) )
   {
      // If the error is ERROR_FILE_NOT_FOUND then it is a USB port
      //  otherwise the API failed and we shoudn't add the port...
      if ( dwLastError == ERROR_FILE_NOT_FOUND )
         _tcscpy(szPortBaseName, cszUSB);
      else
         goto Fail;
   }

   *pPortType = USBPORT;
   if ( _tcsncmp( szPortBaseName, cszDOT4, _tcslen(cszDOT4) ) == 0 )
      *pPortType = DOT4PORT;
   else if ( _tcsncmp( szPortBaseName, csz1394, _tcslen(csz1394) ) == 0 )
      *pPortType = P1394PORT;
   else if ( _tcsncmp( szPortBaseName, cszTS, _tcslen(cszTS) ) == 0 )
      *pPortType = TSPORT;

   wsprintf(pszPortName, TEXT("%s%03u"), szPortBaseName, dwPortNumber);

   return hKey;

Fail:
   RegCloseKey(hKey);
   return INVALID_HANDLE_VALUE;
}


VOID
AddUselessPortEntry(
                   IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                   IN  LPTSTR                pszDevicePath
                   )
/*++
Routine Description:
    This adds a useless port entry to our list. So next time we see an inactive
    port that is already in our known usless port list we can skip the port
    entry

Arguments:
    pMonitorInfo        : Pointer to monitor inf
    pszDevicePath       : Device path for the useless port

Return Value:
    None. Under normal circumstances will add a useless entry to our list

--*/
{
   PUSELESS_PORT  pTemp, pPrev;

   pTemp = FindUselessEntry( pMonitorInfo, pszDevicePath, &pPrev );

   //
   // Don't add an entry that is already there
   //
   SPLASSERT(pTemp == NULL);

   if ( pTemp = (PUSELESS_PORT) AllocSplMem(sizeof(*pTemp)) )
   {
      SafeCopy(MAX_PATH, pszDevicePath, pTemp->szDevicePath);

      if ( pPrev )
      {
         pTemp->pNext  = pPrev->pNext;
         pPrev->pNext = pTemp;
      }
      else
      {
         pTemp->pNext            = pMonitorInfo->pJunkList;
         pMonitorInfo->pJunkList = pTemp;
      }
   }
}


PDYNAMON_PORT
FindPort(
        IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
        IN  LPTSTR                pszPortName,
        OUT PDYNAMON_PORT*        ppPrev
        )
/*++

Routine Description:
    Finds a port by name. Ports are kept in singly linked list sorted by name.
    If found previous in the list is returned via *ppPrev.

Arguments:
    pHead       : Head pointer to port list
    pszPortName : Name of port to look
    ppPrev      : On return will have pointer to previous element

Return Value:
    If NULL port is not in list, else the found element
    Weather port is found or not *ppPrev will return the previous element

--*/
{
   INT     iCmp;
   PDYNAMON_PORT   pHead;

   ECS( pMonitorInfo->EnumPortsCS );

   pHead = pMonitorInfo->pPortList;
   for ( *ppPrev = NULL ;
       pHead && ( iCmp = pHead->pBasePort->compPortName( pszPortName) ) < 0 ;
       *ppPrev = pHead, pHead = pHead->pNext )
      ;

   //
   // If port should go in the middle but not currently there
   //
   if ( pHead && iCmp != 0 )
      pHead = NULL;

   LCS( pMonitorInfo->EnumPortsCS );

   return pHead;
}


VOID
UpdatePortInfo(
    PDYNAMON_PORT   pPort,
    LPTSTR          pszDevicePath,
    BOOL            bIsPortActive,
    HKEY*           phKey,
    PPORT_UPDATE*   ppPortUpdateList
    )
{
   DWORD   dwSize;
   CBasePort* pCurrentPort = pPort->pBasePort;

   pCurrentPort->setDevicePath( pszDevicePath );

   TCHAR   szPortDescription[MAX_PORT_DESC_LEN];
   dwSize = sizeof(szPortDescription);
   if ( ERROR_SUCCESS == RegQueryValueEx( *phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE) szPortDescription,
                                          &dwSize) )
   {
      pCurrentPort->setPortDesc( szPortDescription );
   }

   if ( !pCurrentPort->compActiveState( bIsPortActive ) )
   {
       pCurrentPort->setActive( bIsPortActive );
       AddToPortUpdateList(ppPortUpdateList, pPort, phKey);
   }
}


BOOL
AddPortToList(
             PORTTYPE              portType,
             LPTSTR                pszPortName,
             LPTSTR                pszDevicePath,
             BOOL                  bIsPortActive,
             HKEY*                 phKey,
             PDYNAMON_MONITOR_INFO pMonitorInfo,
             PDYNAMON_PORT         pPrevPort,
             PPORT_UPDATE*         ppPortUpdateList
             )
{
   DWORD          dwSize, dwLastError;
   PDYNAMON_PORT  pPort;
   PUSELESS_PORT  pCur, pPrev;
   CBasePort*     pNewPort;

   SPLASSERT(FindPortUsingDevicePath(pMonitorInfo, pszDevicePath) == NULL);

   pPort = (PDYNAMON_PORT) AllocSplMem(sizeof(DYNAMON_PORT));
   if ( !pPort )
      return FALSE;

   pPort->dwSignature      = DYNAMON_SIGNATURE;

   // Now create the port based on Port Type.
   switch ( portType )
   {
      case DOT4PORT:
         pNewPort = new CDot4Port( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case TSPORT:
         pNewPort = new CTSPort( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case P1394PORT:
         pNewPort = new C1394Port( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case USBPORT:
      default:
         pNewPort = new CUSBPort( bIsPortActive, pszPortName, pszDevicePath );
         break;
   }

   if ( !pNewPort )
   {
      dwLastError = GetLastError();
      FreeSplMem( pPort );
      SetLastError( dwLastError );
      return FALSE;
   }

   TCHAR   szPortDescription[MAX_PORT_DESC_LEN];
   dwSize = sizeof(szPortDescription);
   if ( ERROR_SUCCESS == RegQueryValueEx(*phKey,
                                         cszPortDescription,
                                         0,
                                         NULL,
                                         (LPBYTE) szPortDescription,
                                         &dwSize) )
   {
      pNewPort->setPortDesc( szPortDescription );
   }

   // See if the port has a max data size restriction
   DWORD dwMaxBufferSize;
   dwSize = sizeof(dwMaxBufferSize);
   if ( ERROR_SUCCESS == RegQueryValueEx(*phKey,
                                         cszMaxBufferSize,
                                         0,
                                         NULL,
                                         (LPBYTE) &dwMaxBufferSize,
                                         &dwSize) )
   {
      pNewPort->setMaxBuffer( dwMaxBufferSize );
   }

   // Assign Object Pointer to port list entry
   pPort->pBasePort = pNewPort;

   if ( pPrevPort )
   {
      pPort->pNext = pPrevPort->pNext;
      pPrevPort->pNext = pPort;
   }
   else
   {
      pPort->pNext = pMonitorInfo->pPortList;
      pMonitorInfo->pPortList = pPort;
   }

   //
   // If this is a port that is getting recycled remove from useless list
   //
   if ( pCur = FindUselessEntry( pMonitorInfo, pszDevicePath, &pPrev) )
   {

      if ( pPrev )
         pPrev->pNext = pCur->pNext;
      else
         pMonitorInfo->pJunkList = pCur->pNext;

      FreeSplMem(pCur);
   }

   //
   // On spooler startup we always have to check if the online/offline status
   // has to be changed. This is because spooler will remember the last state
   // before previous spooler shutdown which may be incorrect
   //
   AddToPortUpdateList(ppPortUpdateList, pPort, phKey);

   return TRUE;
}


VOID
AddToPortUpdateList(
                   IN OUT  PPORT_UPDATE* ppPortUpdateList,
                   IN      PDYNAMON_PORT pPort,
                   IN OUT  HKEY*         phKey
                   )
/*++

Routine Description:
    Adds a port to the list of ports that need to status updated.

Arguments:
    ppPortUpdateList    : Pointer to the head of port update list
    pPort           : Gives the port for which we need to update
                          port status
    phKey               : Pointer to reg handle. If port update element created
                          this will be passed to background thread for use and
                          closing

Return Value:
    None

    If the port update element is created then phKey is set to invalid hanlde
    since ownership is going to be passed to background thread.

    New port update element will be the first in the list

--*/
{
   PPORT_UPDATE pTemp;

   if ( pTemp = (PPORT_UPDATE) AllocSplMem( sizeof(PORT_UPDATE) ) )
   {
      SafeCopy( MAX_PORT_LEN, pPort->pBasePort->getPortName(), pTemp->szPortName );
      pTemp->bActive      = pPort->pBasePort->isActive();
      pTemp->hKey         = *phKey;
      pTemp->pNext        = *ppPortUpdateList;
      *ppPortUpdateList   = pTemp;

      *phKey              = INVALID_HANDLE_VALUE;
   }
}


VOID
PassPortUpdateListToUpdateThread(
    PPORT_UPDATE      pNewUpdateList
    )
{
   // Get access to the Update List Pointer
   ECS( gDynaMonInfo.UpdateListCS );

   // Add the new list to the current list
   if ( gDynaMonInfo.pUpdateList )
   {
      // THere is something in the list already so add it to the end
      PPORT_UPDATE pCurUpdateList = gDynaMonInfo.pUpdateList;
      while ( pCurUpdateList->pNext )
         pCurUpdateList = pCurUpdateList->pNext;

      pCurUpdateList->pNext = pNewUpdateList;
   }
   else
      gDynaMonInfo.pUpdateList = pNewUpdateList;

   // Release acces to the list pointer
   LCS( gDynaMonInfo.UpdateListCS );

   // Now let the Update Thread go...
   SetEvent( gDynaMonInfo.hUpdateEvent );

}

void
SafeCopy(
    IN     DWORD    MaxBufLen,
    IN     LPTSTR   pszInString,
    IN OUT LPTSTR   pszOutString
    )
{
    // Check if the input string is bigger than the output buffer
    if (_tcslen(pszInString) >= MaxBufLen)
    {
        // Only Copy as many bytes as will fix
        _tcsncpy( pszOutString, pszInString, (MaxBufLen-1) );
        pszOutString[MaxBufLen-1] = 0x00;
    }
    else
    {
        // Copy the whole string
        _tcscpy( pszOutString, pszInString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\ioctl.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef IOCTL_H

#define IOCTL_H


#define USBPRINT_IOCTL_INDEX  0x0000

#ifdef NEEDED

#define IOCTL_USBPRINT_GET_PIPE_INFO     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_GET_CONFIG_DESCRIPTOR     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+1,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_SET_PIPE_PARAMETER     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+2,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+3,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+4,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_REGISTER_NOTIFY_EVENT   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+5,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+6,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+7,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RETURN_PERF_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+8,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RESET_DEVICE   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+9,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_CLOCK_MASTER_TEST   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+10,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RESET_PIPE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+11,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)
#endif

#define IOCTL_USBPRINT_GET_LPT_STATUS  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+12,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#ifdef NEEDED

#define IOCTL_USBPRINT_GET_1284_ID     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+13,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+14,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+15,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)


#include <PSHPACK1.H>

#define BULK      0
#define INTERRUPT 1
#define CONTROL   2
#define ISO       3

typedef struct _USBPRINT_PIPE_PERF_INFO {
    ULONG               BytesPerSecond;
   ULONG             ClockCyclesPerByte;
} USBPRINT_PIPE_PERF_INFO, *PUSBPRINT_PIPE_PERF_INFO;

typedef struct _USBPRINT_PIPE_INFO {
    BOOLEAN             In;
    UCHAR               PipeType;
    UCHAR               EndpointAddress;
    UCHAR               Interval;
    ULONG               MaximumPacketSize;
    ULONG               MaximumTransferSize;
    UCHAR               Name[32];
   USBPRINT_PIPE_PERF_INFO PerfInfo;
} USBPRINT_PIPE_INFO, *PUSBPRINT_PIPE_INFO;


typedef struct _USBPRINT_INTERFACE_INFO {
    ULONG PipeCount;
    USBPRINT_PIPE_INFO Pipes[];
} USBPRINT_INTERFACE_INFO, *PUSBPRINT_INTERFACE_INFO;



#include <POPPACK.H>

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\enumports.c ===
/*++

Copyright (c) 1999  Microsoft Corporation
All Rights Reserved


Module Name:
    EnumPorts.c

Abstract:
    USBMON enumports routines

Author:

Revision History:

--*/

#include "precomp.h"


TCHAR   sComma                          = TEXT(',');
TCHAR   sZero                           = TEXT('\0');
TCHAR   cszUSB[]                        = TEXT("USB");
TCHAR   cszBaseName[]                   = TEXT("Base Name");
TCHAR   cszPortNumber[]                 = TEXT("Port Number");
TCHAR   cszRecyclable[]                 = TEXT("recyclable");
TCHAR   cszPortDescription[]            = TEXT("Port Description");
TCHAR   cszUSBDescription[]             = TEXT("Virtual printer port for USB");
TCHAR   cszMonitorName[]                = TEXT("USB Print Monitor");


DWORD                   gdwMonitorNameSize  = sizeof(cszMonitorName);
BACKGROUND_THREAD_DATA  FirstBackgroundThreadData = { NULL, NULL, NULL },
                        SecondBackgroundThreadData = { NULL, NULL, NULL };

#ifdef      MYDEBUG
#include    <stdio.h>

DWORD   dwCount[10], dwTotalTime[10];
DWORD   dwSkippedPorts, dwSkippedEnumPorts, dwPortUpdates;
#endif
//
// Default timeout values
//
#define     READ_TIMEOUT_MULTIPLIER         0
#define     READ_TIMEOUT_CONSTANT       60000
#define     WRITE_TIMEOUT_MULTIPLIER        0
#define     WRITE_TIMEOUT_CONSTANT      60000



/*++
    This section explains how we do multiple thread synchronization between
    enumport threads and background threads.

    1. Only one enumports thread can walk the port list of dynamon.
       Enumports uses EnumPortsCS critical section to ensure this.

    2. We never want to make a spooler call from the EnumPorts thread. This is
       because such a call could generate another call back to dynamon and we
       do not want a deadlock. For example OpenPrinter call to netware print
       provider will generate an EnumPorts call.

       So when we find a need to change the printer online/offline staus,
       because correponding dynamon ports are active/inactive, we will spin a
       background thread to make the spooler calls to do that.

    3. We want to make sure background thread does not block EnumPorts. The
       reason is each EnumPorts call could spin a background thread, and
       each backgound thread call a number of OpenPrinter calls, and each
       OpenPrinter call generate an EnumPorts call.

       So we pass a separate port update list to the background thread. And
       we make sure EnumPorts thread does not wait for the background thread
       to complete to return to spooler.

    4. We want to control the number and execution order of background threads.

       We will make sure at a time there can be only 2 background threads. One
       actually processing port update lists, and another just pending
       execution -- scheduled, but waiting for the active background thread
       to complete execution before processing it's port update list.

--*/


PUSELESS_PORT_INFO
FindUselessEntry(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath,
    OUT PUSELESS_PORT_INFO     *ppPrev
    )
/*++
Routine Description:
    Searches for a device path in the useless port list

Arguments:

Return Value:
    NULL if no entry found in the list
    Else a valid USELESS_PORT_INFO pointer
    Weather port is found or not *ppPrev will return the previous element

--*/
{
    INT                 iCmp;
    PUSELESS_PORT_INFO  pHead;

    for ( pHead = pMonitorInfo->pJunkList, *ppPrev = NULL ;
          pHead && (iCmp = lstrcmp(pszDevicePath, pHead->szDevicePath)) < 0 ;
          *ppPrev = pHead, pHead = pHead->pNext )
    ;

    //
    // If useless port should go in the middle but not currently there
    //
    if ( pHead && iCmp != 0 )
        pHead = NULL;

    return pHead;
}


VOID
AddUselessPortEntry(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath
    )
/*++
Routine Description:
    This adds a useless port entry to our list. So next time we see an inactive
    port that is already in our known usless port list we can skip the port
    entry

Arguments:
    pMonitorInfo        : Pointer to monitor inf
    pszDevicePath       : Device path for the useless port

Return Value:
    None. Under normal circumstances will add a useless entry to our list

--*/
{
    PUSELESS_PORT_INFO  pTemp, pPrev;

    pTemp = FindUselessEntry(pMonitorInfo, pszDevicePath, &pPrev);

    //
    // Don't add an entry that is already there
    //
    SPLASSERT(pTemp == NULL);

    if ( pTemp = (PUSELESS_PORT_INFO) AllocSplMem(sizeof(*pTemp)) ) {

        lstrcpy(pTemp->szDevicePath, pszDevicePath);
        ++pMonitorInfo->dwUselessPortCount;

        if ( pPrev ) {

            pTemp->pNext  = pPrev->pNext;
            pPrev->pNext = pTemp;
        } else {

            pTemp->pNext            = pMonitorInfo->pJunkList;
            pMonitorInfo->pJunkList = pTemp;
        }
    }
}


VOID
AddToPortUpdateList(
    IN OUT  PPORT_UPDATE_INFO  *ppPortUpdateInfo,
    IN      PUSBMON_PORT_INFO   pPortInfo,
    IN OUT  HKEY               *phKey
    )
/*++

Routine Description:
    Adds a port to the list of ports that need to status updated.

Arguments:
    ppPortUpdateInfo    : Pointer to the head of port update list
    pPortInfo           : Gives the port for which we need to update
                          port status
    phKey               : Pointer to reg handle. If port update element created
                          this will be passed to background thread for use and
                          closing

Return Value:
    None

    If the port update element is created then phKey is set to invalid hanlde
    since ownership is going to be passed to background thread.

    New port update element will be the first in the list

--*/
{
    PPORT_UPDATE_INFO pTemp;

    if ( pTemp = (PPORT_UPDATE_INFO) AllocSplMem(sizeof(*pTemp)) ) {

        lstrcpy(pTemp->szPortName, pPortInfo->szPortName);
        pTemp->bActive      = (pPortInfo->dwDeviceFlags & SPINT_ACTIVE) != 0;
        pTemp->hKey         = *phKey;
        pTemp->pNext        = *ppPortUpdateInfo;
        *ppPortUpdateInfo   = pTemp;

        *phKey              = INVALID_HANDLE_VALUE;
    }
}


PUSBMON_PORT_INFO
FindPortUsingDevicePath(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath
    )
/*++

Routine Description:
    Finds a port by device path.

Arguments:
    pMonitorInfo    : Pointer to MONITOR_INFO structure
    pszDevicePath   : Device path name to search for

Return Value:
    If NULL port is not in list, else pointer to the PORT_INFO entry for the
    given device path

--*/
{
    INT     iCmp;
    PUSBMON_PORT_INFO   pHead;

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);

    //
    // Port list is sorted on port name, so we have to scan the whole list
    //
    for ( pHead = pMonitorInfo->pPortInfo ; pHead ; pHead = pHead->pNext )
        if ( lstrcmp(pszDevicePath, pHead->szDevicePath) == 0 )
            break;

    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);

    return pHead;
}


PUSBMON_PORT_INFO
FindPort(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszPortName,
    OUT PUSBMON_PORT_INFO      *ppPrev
    )
/*++

Routine Description:
    Finds a port by name. Ports are kept in singly linked list sorted by name.
    If found previous in the list is returned via *ppPrev.

Arguments:
    pHead       : Head pointer to port list
    pszPortName : Name of port to look
    ppPrev      : On return will have pointer to previous element

Return Value:
    If NULL port is not in list, else the found element
    Weather port is found or not *ppPrev will return the previous element

--*/
{
    INT     iCmp;
    PUSBMON_PORT_INFO   pHead;

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);

    pHead = pMonitorInfo->pPortInfo;
    for ( *ppPrev = NULL ;
          pHead && (iCmp = lstrcmp(pszPortName, pHead->szPortName)) < 0 ;
          *ppPrev = pHead, pHead = pHead->pNext )
    ;

    //
    // If port should go in the middle but not currently there
    //
    if ( pHead && iCmp != 0 )
        pHead = NULL;

    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);

    return pHead;
}


BOOL
AddPortToList(
    LPTSTR                  pszPortName,
    LPTSTR                  pszDevicePath,
    DWORD                   dwDeviceFlags,
    HKEY                   *phKey,
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PUSBMON_PORT_INFO       pPrevPortInfo,
    PPORT_UPDATE_INFO      *ppPortUpdateInfo
    )
{
    DWORD               dwSize;
    PUSBMON_PORT_INFO   pPortInfo;
    PUSELESS_PORT_INFO  pCur, pPrev;

    SPLASSERT(FindPortUsingDevicePath(pMonitorInfo, pszDevicePath) == NULL);

    pPortInfo = (PUSBMON_PORT_INFO) AllocSplMem(sizeof(USBMON_PORT_INFO));
    if ( !pPortInfo )
        return FALSE;

    pPortInfo->dwSignature      = USB_SIGNATURE;
    pPortInfo->hDeviceHandle    = INVALID_HANDLE_VALUE;
    pPortInfo->dwDeviceFlags    = dwDeviceFlags;

    pPortInfo->ReadTimeoutMultiplier    = READ_TIMEOUT_MULTIPLIER;
    pPortInfo->ReadTimeoutMultiplier    = READ_TIMEOUT_MULTIPLIER;
    pPortInfo->WriteTimeoutConstant     = WRITE_TIMEOUT_CONSTANT;
    pPortInfo->WriteTimeoutConstant     = WRITE_TIMEOUT_CONSTANT;

    lstrcpy(pPortInfo->szPortName, pszPortName);
    lstrcpy(pPortInfo->szDevicePath, pszDevicePath);

    dwSize = sizeof(pPortInfo->szPortDescription);
    if ( ERROR_SUCCESS != RegQueryValueEx(*phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE)(pPortInfo->szPortDescription),
                                          &dwSize) ) {

        lstrcpy(pPortInfo->szPortDescription, cszUSBDescription);
    }

    if ( pPrevPortInfo ) {

        pPortInfo->pNext = pPrevPortInfo->pNext;
        pPrevPortInfo->pNext = pPortInfo;
    } else {

        pPortInfo->pNext = pMonitorInfo->pPortInfo;
        pMonitorInfo->pPortInfo = pPortInfo;
    }

    //
    // If this is a port that is getting recycled remove from useless list
    //
    if ( pCur = FindUselessEntry(pMonitorInfo, pszDevicePath, &pPrev) ) {
    
        if ( pPrev )
            pPrev->pNext = pCur->pNext;
        else
            pMonitorInfo->pJunkList = pCur->pNext;
    
        --pMonitorInfo->dwUselessPortCount;
        FreeSplMem(pCur);
    }
    
    //
    // On spooler startup we always have to check if the online/offline status
    // has to be changed. This is because spooler will remember the last state
    // before previous spooler shutdown which may be incorrect
    //
    AddToPortUpdateList(ppPortUpdateInfo, pPortInfo, phKey);

    ++pMonitorInfo->dwPortCount;
    
    return TRUE;
}
    
    
HKEY
GetPortNameAndRegKey(
    IN  PSETUPAPI_INFO              pSetupInfo,
    IN  HDEVINFO                    hDevList,
    IN  PSP_DEVICE_INTERFACE_DATA   pDeviceInterface,
    OUT LPTSTR                      pszPortName
    )
/*++
    
Routine Description:
    Find port name for a device interface and also return reg handle
    
Arguments:
    hDevList            : List of USB printer devices
    pDeviceInterface    : pointer to device interface in question
    pszPortName         : Port name on return.
        
Return Value:
    INVALID_HANDLE_VALUE on some errors.
    Otherwize a valid registry handle with pszPortName giving port name
    
--*/
{
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   dwPortNumber, dwNeeded, dwLastError;
    TCHAR   szPortBaseName[MAX_PORT_LEN-3];
    
#ifdef      MYDEBUG
    DWORD   dwTime;
    
    dwTime = GetTickCount();
#endif
    
    hKey = pSetupInfo->OpenDeviceInterfaceRegKey(hDevList,
                                                pDeviceInterface,
                                                0,
                                                KEY_ALL_ACCESS);
#ifdef      MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[0];
    dwTotalTime[0] += dwTime;
#endif
    
    if ( hKey == INVALID_HANDLE_VALUE ) {
    
        dwLastError = GetLastError();
        DBGMSG(DBG_ERROR,
               ("usbmon: WalkPortList: SetupDiOpenDeviceInterfaceRegKey failed with error %d\n",
               dwLastError));
        return INVALID_HANDLE_VALUE;
    }
    
    dwNeeded = sizeof(dwPortNumber);
    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortNumber, 0, NULL,
                                          (LPBYTE)&dwPortNumber, &dwNeeded) ) {

        DBGMSG(DBG_WARNING,
               ("usbmon: GetPortNameAndRegKey: RegQueryValueEx failed for port number\n"));
        goto Fail;
    }

    dwNeeded = sizeof(szPortBaseName);
    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszBaseName, 0, NULL,
                                          (LPBYTE)szPortBaseName, &dwNeeded) ) {
        lstrcpy(szPortBaseName, cszUSB);
    }

    wsprintf(pszPortName, TEXT("%s%03u"), szPortBaseName, dwPortNumber);

    return hKey;
    
Fail:
    RegCloseKey(hKey);
    return INVALID_HANDLE_VALUE;
}


BOOL
SetOnlineStaus(
    LPPRINTER_INFO_5    pPrinterInfo5,
    BOOL                bOnline
    )
{
    BOOL                bRet = FALSE;
    HANDLE              hPrinter;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

#ifdef      MYDEBUG
    DWORD               dwTime;
#endif

    //
    // Force all DOT4 ports to remain online at all times.
    //
    if( lstrncmpi( pPrinterInfo5->pPortName, TEXT("DOT4"), lstrlen(TEXT("DOT4")) ) == 0 )
        bOnline = TRUE;

    //
    // Check if spooler already has the correct status
    //  (can happen on spooler startup)
    //
    if ( bOnline ) {

        if ( !(pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) )
            return TRUE;
    } else
        if ( pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
            return TRUE;

#ifdef      MYDEBUG
    dwTime = GetTickCount();
#endif

    if ( !OpenPrinter(pPrinterInfo5->pPrinterName, &hPrinter, &PrinterDefault) )
        return FALSE;

    if ( bOnline )
        pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
    else
        pPrinterInfo5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

    bRet = SetPrinter(hPrinter, 5, (LPBYTE)pPrinterInfo5, 0);

    ClosePrinter(hPrinter);

#ifdef      MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[7];
    dwTotalTime[7] += dwTime;
#endif

    return bRet;
}


BOOL
PortNameNeededBySpooler(
    IN  LPTSTR              pszPortName,
    IN  LPPRINTER_INFO_5    pPrinterInfo5,
    IN  DWORD               dwPrinters,
    IN  BOOL                bActive
    )
/*++

Routine Description:
    Tells if a port is needed by spooler. Any port to which spooler currently
    has a printer going is needed.

Arguments:
    pszPortName         : Port name in question
    pPrinterInfo5       : List of PrinterInfo5s
    dwPrinters          : Count of the list of printers

Return Value:
    TRUE if spooler currently has a printer which is using the port
    FALSE otherwise

--*/
{
    BOOL    bPortUsedByAPrinter = FALSE, bPrinterUsesOnlyThisPort;
    DWORD   dwIndex;
    LPTSTR  pszStr1, pszStr2;

    for ( dwIndex = 0 ; dwIndex < dwPrinters ; ++dwIndex, ++pPrinterInfo5 ) {

        bPrinterUsesOnlyThisPort = FALSE;
        //
        // Port names are returned comma separated by spooler,
        // and there are blanks
        //
        pszStr1 = pPrinterInfo5->pPortName;

        if ( lstrcmpi(pszPortName, pszStr1) == 0 )
            bPortUsedByAPrinter = bPrinterUsesOnlyThisPort = TRUE;
        else {

            //
            // Look at each port in the list of ports printer uses
            //
            while ( pszStr2 = lstrchr(pszStr1, sComma) ) {

                *pszStr2 = sZero;
                if( lstrcmpi(pszPortName, pszStr1) == 0 )
                    bPortUsedByAPrinter = TRUE;
                *pszStr2 = sComma;  // Put the comma back

                if ( bPortUsedByAPrinter )
                    break;

                pszStr1 = pszStr2 + 1;

                //
                // Skip spaces
                //
                while ( *pszStr1 == TEXT(' ') )
                    ++pszStr1;
            }

            if ( !bPortUsedByAPrinter )
                bPortUsedByAPrinter = lstrcmpi(pszPortName, pszStr1) == 0;
        }

        //
        // We will change only status of printer for non-pooled printers only
        //
        if ( bPrinterUsesOnlyThisPort )
            SetOnlineStaus(pPrinterInfo5, bActive);
    }

    return bPortUsedByAPrinter;
}


VOID
UpdatePortInfo(
    PUSBMON_PORT_INFO   pPortInfo,
    LPTSTR              pszDevicePath,
    DWORD               dwDeviceFlags,
    HKEY               *phKey,
    PPORT_UPDATE_INFO  *ppPortUpdateInfo
    )
{
    DWORD   dwSize;

    lstrcpy(pPortInfo->szDevicePath, pszDevicePath);

    dwSize = sizeof(pPortInfo->szPortDescription);
    if ( ERROR_SUCCESS != RegQueryValueEx(*phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE)(pPortInfo->szPortDescription),
                                          &dwSize) ) {

        lstrcpy(pPortInfo->szPortDescription, cszUSBDescription);
    }

    if ( pPortInfo->dwDeviceFlags != dwDeviceFlags ) {

        pPortInfo->dwDeviceFlags = dwDeviceFlags;
        AddToPortUpdateList(ppPortUpdateInfo, pPortInfo, phKey);
    }

}


BOOL
PrinterInfo5s(
    OUT LPPRINTER_INFO_5   *ppPrinterInfo5,
    OUT LPDWORD             pdwReturned
    )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_5s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPrinterInfo5  : Points to PRINTER_INFO_5s on return
    pdwReturned     : Tells how many PRINTER_INFO_5s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL            bRet = FALSE;
    static  DWORD   dwNeeded = 0;
    LPBYTE          pBuf = NULL;

#ifdef      MYDEBUG
    DWORD           dwTime;

    dwTime = GetTickCount();
#endif

    *pdwReturned = 0;

    if ( !(pBuf = AllocSplMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       5,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       pdwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            goto Cleanup;

        FreeSplMem(pBuf);
        if ( !(pBuf = AllocSplMem(dwNeeded))   ||
             !EnumPrinters(PRINTER_ENUM_LOCAL,
                           NULL,
                           5,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           pdwReturned) ) {

            goto Cleanup;
        }
   }

   bRet = TRUE;

Cleanup:

    if ( bRet && *pdwReturned ) {

        *ppPrinterInfo5 = (LPPRINTER_INFO_5)pBuf;
    } else {

        FreeSplMem(pBuf);

        *ppPrinterInfo5 = NULL;
        *pdwReturned = 0;
   }

#ifdef      MYDEBUG
   dwTime = GetTickCount() - dwTime;
   ++dwCount[6];
   dwTotalTime[6] += dwTime;
#endif

   return bRet;
}


VOID
BackgroundThread(
    HANDLE    hEvent
    )
/*++
    This is the body of background thread which does the following:
        1. Update printer online/offline with spooler for printers using
           dynamon ports
        2. Mark those ports that are inactive and not needed by spooler
           as recyclable
        3. When exiting if there is a second background thread scheduled
           then trigger it to go
--*/
{
    HANDLE              hEventToSet = NULL;
    DWORD               dwPrinters;
    PPORT_UPDATE_INFO   pPortUpdateList, pCur;
    LPCRITICAL_SECTION  pBackThreadCS;
    LPPRINTER_INFO_5    pPrinterInfo5List = NULL;

#ifdef  MYDEBUG
    DWORD               dwTime;
    CHAR                szBuf[200];

    dwTime = GetTickCount();
#endif

    //
    // Background waits here to be triggered to do it's work
    //
    WaitForSingleObject(hEvent, INFINITE);

    //
    // This is the first/active background thread at this point
    //
    SPLASSERT(hEvent == FirstBackgroundThreadData.hWaitToStart);

    //
    // Until we are here (i.e. the thread is triggered to tell this is the
    // active/first background thread) we can't access any of these things
    //

    pPortUpdateList = FirstBackgroundThreadData.pPortUpdateList;
    pBackThreadCS   = &FirstBackgroundThreadData.pMonitorInfo->BackThreadCS;

    if ( PrinterInfo5s(&pPrinterInfo5List, &dwPrinters) ) {

        for ( pCur = pPortUpdateList ; pCur ; pCur = pCur->pNext ) {

            if ( !PortNameNeededBySpooler(pCur->szPortName,
                                          pPrinterInfo5List,
                                          dwPrinters,
                                          pCur->bActive)     &&
                 !pCur->bActive ) {

                RegSetValueEx(pCur->hKey, cszRecyclable, 0, REG_NONE, 0, 0);
            }

        }
    }

    //
    // Now the thread has done what it was spun off to do.
    //

    EnterCriticalSection(pBackThreadCS);

    //
    // Remove this thread from being the first/active background thread
    //
    FirstBackgroundThreadData.hWaitToStart      = NULL;
    FirstBackgroundThreadData.pPortUpdateList   = NULL;
    FirstBackgroundThreadData.pMonitorInfo      = NULL;
    CloseHandle(hEvent);

    //
    // If there is a second thread it becomes the first now
    //
    if ( SecondBackgroundThreadData.hWaitToStart ) {

        hEventToSet
                = FirstBackgroundThreadData.hWaitToStart
                = SecondBackgroundThreadData.hWaitToStart;
        FirstBackgroundThreadData.pPortUpdateList
                = SecondBackgroundThreadData.pPortUpdateList;
        FirstBackgroundThreadData.pMonitorInfo
                = SecondBackgroundThreadData.pMonitorInfo;

        SecondBackgroundThreadData.hWaitToStart     = NULL;
        SecondBackgroundThreadData.pPortUpdateList  = NULL;
        SecondBackgroundThreadData.pMonitorInfo     = NULL;
    }
    LeaveCriticalSection(pBackThreadCS);

    //
    // If there is a second thread trigger it
    //
    if ( hEventToSet )
        SetEvent(hEventToSet);

    FreeSplMem(pPrinterInfo5List);

    //
    // Free the port update list
    //
    while ( pCur = pPortUpdateList ) {

        pPortUpdateList = pPortUpdateList->pNext;
        RegCloseKey(pCur->hKey);
        FreeSplMem(pCur);
    }

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[4];
    dwTotalTime[4] += dwTime;
    sprintf(szBuf, "BackgroundThread:                   %d\n",
            dwTotalTime[4]/dwCount[4]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "PrinterInfo5s:                      %d\n",
            dwTotalTime[6]/dwCount[6]);
    OutputDebugStringA(szBuf);

    if ( dwCount[7] ) {

        sprintf(szBuf, "SetOnlineStatus:                    %d\n",
                dwTotalTime[7]/dwCount[7]);
        OutputDebugStringA(szBuf);
    }
#endif
}


HANDLE
CreateBackgroundThreadAndReturnEventToTrigger(
    VOID
    )
/*++
    Creates a background thread and passes it an event on which to wait for
    starting execution. Returns the event handle.
--*/
{
    HANDLE  hThread = NULL, hEvent;
    DWORD   dwThreadId;

    if ( hEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) {

        if (  hThread = CreateThread(NULL,
                                     0,
                                     (LPTHREAD_START_ROUTINE)BackgroundThread,
                                     hEvent,
                                     0,
                                     &dwThreadId) ) {

            CloseHandle(hThread);
        } else {

            CloseHandle(hEvent);
            hEvent = NULL;
        }
    }

    return hEvent;
}


VOID
PassPortUpdateListToBackgroundThread(
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PPORT_UPDATE_INFO       pPortUpdateList
    )
/*++
    Called from EnumPorts thread with a list of port update elements to be
    passed to the background thread.
    a. If there is no background thread then spin one and trigger it
    b. If there is only one background thread then spin the second one. First
       one will trigger the second one on completion
    c. If there are two background threads, one active and one waiting to be
       triggered, then add the port update elements to the second one's list
--*/
{
    DWORD               dwThreadCount = 0;
    PPORT_UPDATE_INFO   pCur, pNext, pLast;

    if ( pPortUpdateList == NULL )
        return;

    EnterCriticalSection(&pMonitorInfo->BackThreadCS);

    if ( FirstBackgroundThreadData.hWaitToStart ) {

        ++dwThreadCount;
        if ( SecondBackgroundThreadData.hWaitToStart )
            ++dwThreadCount;
    }

    switch (dwThreadCount) {

        case 0:
            if ( FirstBackgroundThreadData.hWaitToStart
                        = CreateBackgroundThreadAndReturnEventToTrigger() ) {

                FirstBackgroundThreadData.pMonitorInfo      = pMonitorInfo;
                FirstBackgroundThreadData.pPortUpdateList   = pPortUpdateList;
                SetEvent(FirstBackgroundThreadData.hWaitToStart);
            }
            break;
        case 1:
            if ( SecondBackgroundThreadData.hWaitToStart
                        = CreateBackgroundThreadAndReturnEventToTrigger() ) {

                SecondBackgroundThreadData.pMonitorInfo      = pMonitorInfo;
                SecondBackgroundThreadData.pPortUpdateList   = pPortUpdateList;
            }
            break;

        case 2:
            //
            // Note: We know both lists can't be empty
            //
            for ( pCur = pPortUpdateList; pCur ; pCur = pNext ) {

                pNext = pCur->pNext;

                for ( pLast = SecondBackgroundThreadData.pPortUpdateList ;
                      pLast ; pLast = pLast->pNext ) {

                    //
                    // If there is a duplicate update old entry with info
                    // from new one and free the new entry
                    //
                    if ( !lstrcmpi(pLast->szPortName, pCur->szPortName) ) {

                        RegCloseKey(pLast->hKey);
                        pLast->hKey     = pCur->hKey;
                        pLast->bActive  = pCur->bActive;
                        FreeSplMem(pCur);
                        break; // out of inner for loop
                    } else if ( pLast->pNext == NULL ) {

                        //
                        // If we hit end of list then append entry
                        //
                        pLast->pNext = pCur;
                        pCur->pNext  = NULL;
                        break; // out of inner for loop
                    }
                }
            }
            break;

        default:
            //
            // Should not happen
            //
            SPLASSERT(dwThreadCount == 0);
    }

    LeaveCriticalSection(&pMonitorInfo->BackThreadCS);
}


VOID
ProcessPortInfo(
    IN      PSETUPAPI_INFO                      pSetupApiInfo,
    IN      PUSBMON_MONITOR_INFO                pMonitorInfo,
    IN      HDEVINFO                            hDevList,
    IN      PSP_DEVICE_INTERFACE_DATA           pDeviceInterface,
    IN      PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail,
    IN OUT  PPORT_UPDATE_INFO                  *ppPortUpdateInfo
    )
{
    HKEY                hKey = INVALID_HANDLE_VALUE;
    TCHAR               szPortName[MAX_PORT_LEN];
    PUSBMON_PORT_INFO   pCur, pPrev;

#ifdef  MYDEBUG
    ++dwPortUpdates;
#endif

    hKey = GetPortNameAndRegKey(pSetupApiInfo, hDevList,
                                pDeviceInterface, szPortName);

    if ( hKey == INVALID_HANDLE_VALUE ) {

        //
        // If this port is inactive and is not in our known port list
        // add to useless list. Earlier we would have been opening the registry
        // every time and find that port number is missing because of KM drivers
        // not deleting the inactive device interfaces
        //
        if ( !(pDeviceInterface->Flags & SPINT_ACTIVE)    &&
             !FindPortUsingDevicePath(pMonitorInfo, pDeviceDetail->DevicePath) )
            AddUselessPortEntry(pMonitorInfo, pDeviceDetail->DevicePath);

        return;
    }

    pCur = FindPort(pMonitorInfo, szPortName, &pPrev);

    //
    // Port info is currently in our list?
    //
    if ( pCur ) {

        //
        // Did the device path or flags change?
        //
        if ( pCur->dwDeviceFlags != pDeviceInterface->Flags     ||
             lstrcmp(pDeviceDetail->DevicePath, pCur->szDevicePath) ) {

            UpdatePortInfo(pCur, pDeviceDetail->DevicePath,
                           pDeviceInterface->Flags, &hKey, ppPortUpdateInfo);
        }
    } else {

        AddPortToList(szPortName, pDeviceDetail->DevicePath,
                      pDeviceInterface->Flags, &hKey, pMonitorInfo, pPrev,
                      ppPortUpdateInfo);

    }

    if ( hKey != INVALID_HANDLE_VALUE )
        RegCloseKey(hKey);
}


DWORD
WalkPortList(
    PSETUPAPI_INFO          pSetupApiInfo,
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PPORT_UPDATE_INFO      *ppPortUpdateInfo
    )
{
    DWORD                               dwIndex, dwLastError, dwSize, dwNeeded;
    HANDLE                              hToken;
    HDEVINFO                            hDevList = INVALID_HANDLE_VALUE;
    PUSBMON_PORT_INFO                   pPtr;
    PUSELESS_PORT_INFO                  pCur, pPrev;
    SP_DEVICE_INTERFACE_DATA            DeviceInterface;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail = NULL;

#ifdef  MYDEBUG
    DWORD                               dwTime;
#endif

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);
    
    hToken = RevertToPrinterSelf();

    hDevList = pSetupApiInfo->GetClassDevs((GUID *)&USB_PRINTER_GUID,
                                           NULL,
                                           NULL,
                                           DIGCF_INTERFACEDEVICE);

    if ( hDevList == INVALID_HANDLE_VALUE ) {

        dwLastError = GetLastError();
        goto Done;
    }

    dwSize = sizeof(PSP_DEVICE_INTERFACE_DETAIL_DATA)
                        + MAX_DEVICE_PATH * sizeof(TCHAR);

    pDeviceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA) AllocSplMem(dwSize);

    if ( !pDeviceDetail ) {

        dwLastError = GetLastError();
        goto Done;
    }

    dwLastError = ERROR_SUCCESS;
    dwIndex = 0;
    pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
    DeviceInterface.cbSize  = sizeof(DeviceInterface);
    do {

#ifdef  MYDEBUG
        dwTime = GetTickCount();
#endif
        if ( !pSetupApiInfo->EnumDeviceInterfaces(hDevList,
                                                  NULL,
                                                  (GUID *)&USB_PRINTER_GUID,
                                                  dwIndex,
                                                  &DeviceInterface) ) {

            dwLastError = GetLastError();
            if ( dwLastError == ERROR_NO_MORE_ITEMS )
                break;      // Normal exit

            DBGMSG(DBG_WARNING,
                   ("usbmon: WalkPortList: SetupDiEnumDeviceInterfaces failed with %d for inderx %d\n",
                   dwLastError, dwIndex));
            goto Next;
        }

#ifdef  MYDEBUG
        dwTime = GetTickCount() - dwTime;
        ++dwCount[1];
        dwTotalTime[1] += dwTime;

        dwTime = GetTickCount();
#endif

        if ( !pSetupApiInfo->GetDeviceInterfaceDetail(hDevList,
                                                      &DeviceInterface,
                                                      pDeviceDetail,
                                                      dwSize,
                                                      &dwNeeded,
                                                      NULL) ) {

            dwLastError = GetLastError();
            DBGMSG(DBG_ERROR,
                   ("usbmon: WalkPortList: SetupDiGetDeviceInterfaceDetail failed with error %d size %d\n",
                   dwLastError, dwNeeded));
            goto Next;
        }

#ifdef  MYDEBUG
        dwTime = GetTickCount() - dwTime;
        ++dwCount[2];
        dwTotalTime[2] += dwTime;
#endif

        //
        // This is the only flag we care about
        //
        DeviceInterface.Flags &= SPINT_ACTIVE;

        //
        // For inactive port if it is already known as a useless port
        // no need to process further
        //
        if ( !(DeviceInterface.Flags & SPINT_ACTIVE)    &&
              FindUselessEntry(pMonitorInfo, pDeviceDetail->DevicePath, &pPrev) ) {

#ifdef  MYDEBUG
            ++dwSkippedPorts;
#endif
            goto Next;
        }

        //
        // When port active status did not change we should have nothing
        // to update. By skipping the PortUpdateInfo we avoid registry access
        // and it is a performance improvement
        //
        if ( (pPtr = FindPortUsingDevicePath(pMonitorInfo,
                                             pDeviceDetail->DevicePath))    &&
             DeviceInterface.Flags == pPtr->dwDeviceFlags ) {
    
#ifdef  MYDEBUG
            ++dwSkippedPorts;
#endif
            goto Next;
        }
    
        ProcessPortInfo(pSetupApiInfo, pMonitorInfo, hDevList, &DeviceInterface,
                        pDeviceDetail, ppPortUpdateInfo);

Next:
        dwLastError = ERROR_SUCCESS;
        ++dwIndex;
        pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
        DeviceInterface.cbSize  = sizeof(DeviceInterface);
    } while ( dwLastError == ERROR_SUCCESS);

    if ( dwLastError == ERROR_NO_MORE_ITEMS )
        dwLastError = ERROR_SUCCESS;

Done:
    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);
    if ( hDevList != INVALID_HANDLE_VALUE )
        pSetupApiInfo->DestroyDeviceInfoList(hDevList);

    ImpersonatePrinterClient(hToken);
    FreeSplMem(pDeviceDetail);

    return dwLastError;
}


LPBYTE
CopyPortToBuf(
    PUSBMON_PORT_INFO   pPortInfo,
    DWORD               dwLevel,
    LPBYTE              pPorts,
    LPBYTE              pEnd
    )
{
    DWORD   dwLen;
    LPTSTR  pszStr;
    LPPORT_INFO_1   pPortInfo1 = (LPPORT_INFO_1) pPorts;
    LPPORT_INFO_2   pPortInfo2 = (LPPORT_INFO_2) pPorts;

    switch (dwLevel) {

        case 2:
            dwLen   = gdwMonitorNameSize;
            pEnd   -= dwLen;
            pPortInfo2->pMonitorName = (LPTSTR)pEnd;
            lstrcpy(pPortInfo2->pMonitorName, cszMonitorName);

            dwLen   = lstrlen(pPortInfo->szPortDescription) + 1;
            dwLen  *= sizeof(TCHAR);
            pEnd   -= dwLen;
            pPortInfo2->pDescription = (LPTSTR)pEnd;
            lstrcpy(pPortInfo2->pDescription, pPortInfo->szPortDescription);

            //
            // Fall through
            //

        case 1:
            dwLen   = lstrlen(pPortInfo->szPortName) + 1;
            dwLen  *= sizeof(TCHAR);
            pEnd   -= dwLen;
            pPortInfo1->pName = (LPTSTR)pEnd;
            lstrcpy(pPortInfo1->pName, pPortInfo->szPortName);
    }

    return pEnd;
}


BOOL
LoadSetupApiDll(
    PSETUPAPI_INFO  pSetupInfo
    )
{
    UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

#ifdef  MYDEBUG
    DWORD   dwTime;

    dwTime = GetTickCount();
#endif

    pSetupInfo->hSetupApi = LoadLibrary(TEXT("setupapi"));
    SetErrorMode(uOldErrMode);


    if ( !pSetupInfo->hSetupApi )
        return FALSE;

    (FARPROC) pSetupInfo->DestroyDeviceInfoList
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiDestroyDeviceInfoList");

    (FARPROC) pSetupInfo->GetClassDevs
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetClassDevsW");

    (FARPROC) pSetupInfo->EnumDeviceInterfaces
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiEnumDeviceInterfaces");

    (FARPROC) pSetupInfo->GetDeviceInterfaceDetail
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetDeviceInterfaceDetailW");

    (FARPROC) pSetupInfo->OpenDeviceInterfaceRegKey
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiOpenDeviceInterfaceRegKey");

    if ( !pSetupInfo->DestroyDeviceInfoList         ||
         !pSetupInfo->GetClassDevs                  ||
         !pSetupInfo->EnumDeviceInterfaces          ||
         !pSetupInfo->GetDeviceInterfaceDetail      ||
         !pSetupInfo->OpenDeviceInterfaceRegKey ) {

        SPLASSERT(FALSE);
        FreeLibrary(pSetupInfo->hSetupApi);
        pSetupInfo->hSetupApi = NULL;
        return FALSE;
    }

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[5];
    dwTotalTime[5] += dwTime;
#endif

    return TRUE;
}


BOOL
WINAPI
USBMON_EnumPorts(
    LPTSTR      pszName,
    DWORD       dwLevel,
    LPBYTE      pPorts,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned
    )
{
    DWORD               dwLastError = ERROR_SUCCESS, dwRequestIndex;
    LPBYTE              pEnd;
    SETUPAPI_INFO       SetupApiInfo;
    PUSBMON_PORT_INFO   pPortInfo;
    PPORT_UPDATE_INFO   pPortUpdateInfo = NULL;

#ifdef  MYDEBUG
    DWORD               dwTime;
    CHAR                szBuf[200];

    dwTime = GetTickCount();
#endif

    dwRequestIndex = gUsbmonInfo.dwLastEnumIndex;

    *pcbNeeded = *pcReturned = 0;
    if ( dwLevel != 1 && dwLevel != 2 ) {

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if ( !LoadSetupApiDll(&SetupApiInfo) )
        return FALSE;

    EnterCriticalSection(&gUsbmonInfo.EnumPortsCS);

    if ( dwRequestIndex >= gUsbmonInfo.dwLastEnumIndex ) {

        //
        // No complete enumeration has occurred since this request was made.
        // Since the request may be an indication that something has changed,
        // the full reenumeration must be done.
        //
        // Updated the index of enumeration before actually doing the
        // work so it will show up as the most conservative
        //
        // Consequence of rollover on gdwLastEnumIndex:
        //     Any threads that recorded 0xFFFFFFFF as the dwRequestIndex
        // will show as greater than the new value 0 and therefore reenum
        // gratuitously. Not very much extra work.
        //
        ++gUsbmonInfo.dwLastEnumIndex;
        if ( dwLastError = WalkPortList(&SetupApiInfo, &gUsbmonInfo,
                                    &pPortUpdateInfo) )
            goto Done;
    }
#ifdef MYDEBUG
    else
        ++dwSkippedEnumPorts;
#endif

    for ( pPortInfo = gUsbmonInfo.pPortInfo ;
          pPortInfo ;
          pPortInfo = pPortInfo->pNext ) {

        if ( dwLevel == 1 )
            *pcbNeeded += sizeof(PORT_INFO_1) +
                            (lstrlen(pPortInfo->szPortName) + 1)
                                        * sizeof(TCHAR);
        else
            *pcbNeeded += sizeof(PORT_INFO_2)   +
                            gdwMonitorNameSize  +
                            (lstrlen(pPortInfo->szPortName) + 1 +
                             lstrlen(pPortInfo->szPortDescription) + 1 )
                                        * sizeof(TCHAR);

    }

    if ( cbBuf < *pcbNeeded ) {

        dwLastError = ERROR_INSUFFICIENT_BUFFER;
        goto Done;
    }

    pEnd = pPorts + cbBuf;

    for ( pPortInfo = gUsbmonInfo.pPortInfo ;
          pPortInfo ;
          pPortInfo = pPortInfo->pNext ) {

        pEnd = CopyPortToBuf(pPortInfo, dwLevel, pPorts, pEnd);

        if ( dwLevel == 1 )
            pPorts += sizeof(PORT_INFO_1);
        else
            pPorts += sizeof(PORT_INFO_2);
        ++(*pcReturned);
    }

    SPLASSERT(pEnd >= pPorts);

Done:
    PassPortUpdateListToBackgroundThread(&gUsbmonInfo, pPortUpdateInfo);

    LeaveCriticalSection(&gUsbmonInfo.EnumPortsCS);

    if ( SetupApiInfo.hSetupApi )
        FreeLibrary(SetupApiInfo.hSetupApi);

    ++gUsbmonInfo.dwEnumPortCount;

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++(dwCount[3]);
    dwTotalTime[3] += dwTime;

    sprintf(szBuf, "SetupDiOpenDeviceInterfaceRegKey:   %d\n", dwTotalTime[0]/dwCount[0]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "SetupDiSetupDiEnumDeviceInterfaces: %d\n", dwTotalTime[1]/dwCount[1]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "SetupDiGetDeviceInterfaceDetail:    %d\n", dwTotalTime[2]/dwCount[2]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "EnumPorts:                          %d\n", dwTotalTime[3]/dwCount[3]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "LoadSetupApi:                       %d\n", dwTotalTime[5]/dwCount[5]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Port updates per call               %d\n", dwPortUpdates/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Skipped port updates per call       %d\n", dwSkippedPorts/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Skipped enumport percentage         %d\n", 100 * dwSkippedEnumPorts/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Ports/Useless ports           %d/%d\n", gUsbmonInfo.dwPortCount, gUsbmonInfo.dwUselessPortCount);
    OutputDebugStringA(szBuf);
    
#endif


    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    } else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\mysetupapi.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    MySetup.h

Abstract:

    USBMON setupapi header file


--*/

#ifndef MYSETUPAPI_H

#define MYSETUPAPI_H

#include <setupapi.h>
#include <cfgmgr32.h>       // For dot4 pnp reenumeration code.


typedef
(WINAPI * pfSetupDiDestroyDeviceInfoList)(
    IN HDEVINFO DeviceInfoSet
    );

typedef
HDEVINFO
(WINAPI * pfSetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCTSTR Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

typedef
BOOL
(WINAPI * pfSetupDiEnumDeviceInfo)(
    IN  HDEVINFO          DeviceInfoSet,
    IN  DWORD             MemberIndex,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    );


typedef
BOOL
(WINAPI * pfSetupDiEnumDeviceInterfaces)(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    );

typedef
BOOL
(WINAPI * pfSetupDiGetDeviceInterfaceDetail)(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
#ifdef  UNICODE
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
#else
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
#endif
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

typedef
HKEY
(WINAPI * pfSetupDiOpenDeviceInterfaceRegKey)(
    IN     HDEVINFO                     DeviceInfoSet,
    IN     PSP_DEVICE_INTERFACE_DATA    pDeviceInterface,
    IN     DWORD                        Reserved,
    IN     REGSAM                       samDesired
    );

typedef struct  _SETUPAPI_INFO {

    HMODULE     hSetupApi;

    pfSetupDiGetClassDevs               GetClassDevs;
    pfSetupDiDestroyDeviceInfoList      DestroyDeviceInfoList;
    pfSetupDiEnumDeviceInfo             EnumDeviceInfo;
    pfSetupDiEnumDeviceInterfaces       EnumDeviceInterfaces;
    pfSetupDiGetDeviceInterfaceDetail   GetDeviceInterfaceDetail;
    pfSetupDiOpenDeviceInterfaceRegKey  OpenDeviceInterfaceRegKey;
} SETUPAPI_INFO, *PSETUPAPI_INFO;

// For dot4 pnp reenumeration code.
typedef
CONFIGRET
(WINAPI * pfCM_Locate_DevNode_Ex)(
    OUT PDEVINST    pdnDevInst,
#ifdef UNICODE
    IN  DEVINSTID_W pDeviceID,   OPTIONAL
#else
    IN  DEVINSTID_A pDeviceID,   OPTIONAL
#endif
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

typedef
CONFIGRET
(WINAPI * pfCM_Reenumerate_DevNode_Ex)(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file for usbmon

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include "tchar.h"
#include "splcom.h"
#include "debug.h"
#include "mysetupapi.h"
#include "dynamon.h"
#include "Baseport.h"
#include "usbport.h"
#include "tsport.h"
#include "dot4port.h"
#include "1394port.h"
#include "devioctl.h"
#include "ioctl.h"
#include "protos.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\tsport.h ===
// TSPort.h: interface for the CTSPort class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_)
#define AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CTSPort : public CBasePort
{
public:
   CTSPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CTSPort();
   PORTTYPE getPortType( void );
   BOOL setPortTimeOuts( LPCOMMTIMEOUTS lpCTO );
   BOOL getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );

protected:
};

#endif // !defined(AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\tsport.cpp ===
// TSPort.cpp: implementation of the CTSPort class.
//
//////////////////////////////////////////////////////////////////////

#include "TSPort.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTSPort::CTSPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszTSPortDesc )
{
   // Basically let the default constructor do the work.
}


CTSPort::~CTSPort()
{

}


PORTTYPE CTSPort::getPortType()
{
   return TSPORT;
}


BOOL CTSPort::getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                      LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned )
{
   SetLastError( ERROR_INVALID_FUNCTION );
   return FALSE;
}


BOOL CTSPort::setPortTimeOuts( LPCOMMTIMEOUTS lpCTO )
{
   SetLastError( ERROR_INVALID_FUNCTION );
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\protos.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    Protos.h

Abstract:
    Prototypes for all functions

Author: M. Fenelon

Revision History:

--*/

//
//  Functions in DynaMon.cpp
//

BOOL WINAPI DynaMon_EnumPorts( LPTSTR pszName, DWORD dwLevel, LPBYTE pPorts, DWORD cbBuf,
                               LPDWORD pcbNeeded, LPDWORD pcReturned );

BOOL WINAPI DynaMon_OpenPort( LPTSTR pszPortName, LPHANDLE pHandle );

BOOL WINAPI DynaMon_ClosePort( HANDLE hPort );

BOOL WINAPI DynaMon_StartDocPort( HANDLE hPort, LPTSTR pPrinterName, DWORD dwJobId,
                                  DWORD dwLevel, LPBYTE pDocInfo );

BOOL WINAPI DynaMon_EndDocPort( HANDLE hPort );

BOOL WINAPI DynaMon_GetPrinterDataFromPort( HANDLE hPort, DWORD dwControlID, LPWSTR pValueName, LPWSTR lpInBuffer,
                                            DWORD cbInBuffer, LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );

BOOL WINAPI DynaMon_ReadPort( HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead );

BOOL WINAPI DynaMon_WritePort( HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten );

BOOL WINAPI DynaMon_SetPortTimeOuts( HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved );

//
//  Functions in EnumUtil.cpp
//

BOOL SpinUpdateThread( void );

VOID UpdateThread( PDYNAMON_MONITOR_INFO pMonInfo );

BOOL GetPrinterInfo( LPPRINTER_INFO_5 *ppPrinterInfo5, LPDWORD pdwReturned );

BOOL PortNameNeededBySpooler( LPTSTR pszPortName, LPPRINTER_INFO_5 pPrinterInfo5,
                              DWORD dwPrinters, BOOL bActive );

BOOL SetOnlineStaus( LPPRINTER_INFO_5 pPrinterInfo5, BOOL bOnline );

DWORD BuildPortList( PDYNAMON_MONITOR_INFO pMonitorInfo, PPORT_UPDATE* ppPortUpdateList );

BOOL LoadSetupApiDll( PSETUPAPI_INFO  pSetupInfo );

DWORD ProcessGUID( PSETUPAPI_INFO pSetupApiInfo, PDYNAMON_MONITOR_INFO pMonitorInfo,
                   PPORT_UPDATE* ppPortUpdateList, LPGUID pGUID );

PUSELESS_PORT FindUselessEntry( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath, PUSELESS_PORT* ppPrev );

PDYNAMON_PORT FindPortUsingDevicePath( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath );

VOID ProcessPortInfo( PSETUPAPI_INFO pSetupApiInfo, PDYNAMON_MONITOR_INFO pMonitorInfo, HDEVINFO hDevList,
                      PSP_DEVICE_INTERFACE_DATA pDeviceInterface, PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,
                      BOOL bIsPortActive, PPORT_UPDATE* ppPortUpdateInfo );

HKEY GetPortNameAndRegKey( PSETUPAPI_INFO pSetupInfo, HDEVINFO hDevList, PSP_DEVICE_INTERFACE_DATA pDeviceInterface,
                           LPTSTR pszPortName, PORTTYPE* pPortType );

VOID AddUselessPortEntry( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath );

PDYNAMON_PORT FindPort( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszPortName, PDYNAMON_PORT* ppPrev );

VOID UpdatePortInfo( PDYNAMON_PORT pPort, LPTSTR pszDevicePath, BOOL bIsPortActive,
                     HKEY* phKey, PPORT_UPDATE* ppPortUpdateList );

BOOL
AddPortToList( PORTTYPE portType, LPTSTR pszPortName, LPTSTR pszDevicePath, BOOL bIsPortActive, HKEY* phKey,
               PDYNAMON_MONITOR_INFO pMonitorInfo, PDYNAMON_PORT pPrevPort, PPORT_UPDATE* ppPortUpdateList );

VOID AddToPortUpdateList( PPORT_UPDATE* ppPortUpdateList, PDYNAMON_PORT pPort, HKEY* phKey );

VOID PassPortUpdateListToUpdateThread( PPORT_UPDATE pNewUpdateList );

void SafeCopy(DWORD MaxBufLen, LPTSTR pszInString, LPTSTR pszOutString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\usbport.h ===
// USBPort.h: interface for the CUSBPort class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_)
#define AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CUSBPort : public CBasePort
{
public:
   CUSBPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CUSBPort();
   PORTTYPE getPortType( void );
   void setPortDesc( LPTSTR pszPortDesc );
   void setMaxBuffer(DWORD dwMaxBufferSize);

protected:

};

#endif // !defined(AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\usbport.cpp ===
// USBPort.cpp: implementation of the CUSBPort class.
//
//////////////////////////////////////////////////////////////////////

#include "USBPort.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUSBPort::CUSBPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszUSBPortDesc )
{
   // Basically let the default constructor do the work.
   m_dwMaxBufferSize = 0x1000;
}

CUSBPort::~CUSBPort()
{

}

PORTTYPE CUSBPort::getPortType()
{
   return USBPORT;
}


void CUSBPort::setPortDesc( LPTSTR pszPortDesc )
{
   // Don't change the description
}


void CUSBPort::setMaxBuffer(DWORD dwMaxBufferSize)
{
   m_dwMaxBufferSize = 0x1000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\dynamon\usbmon.c ===
/*++             

Copyright (c) 1999  Microsoft Corporation
All Rights Reserved


Module Name:
    Usbmon.c

Abstract:
    USBMON core port monitor routines

Author:

Revision History:

--*/

#include "precomp.h"
#include "ntddpar.h"

#define LPT_NOT_ERROR     0x8
#define LPT_SELECT        0x10
#define LPT_PAPER_EMPTY   0x20
#define LPT_BENIGN_STATUS LPT_NOT_ERROR | LPT_SELECT

#define MAX_TIMEOUT 300000 //5 minutes

#define JOB_ABORTCHECK_TIMEOUT 5000

const TCHAR cszCFGMGR32[]=TEXT("cfgmgr32.dll");

const CHAR cszReenumFunc[]="CM_Reenumerate_DevNode_Ex";

#ifdef UNICODE
const CHAR cszLocalFunc[]="CM_Locate_DevNode_ExW";
#else
const CHAR cszLocalFunc[]="CM_Locate_DevNode_ExA";
#endif

BOOL GetLptStatus(HANDLE hDeviceHandle,BYTE *Return);

DWORD UsbmonDebug;


BOOL
APIENTRY
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
    )
{

    if ( dwReason == DLL_PROCESS_ATTACH )
        DisableThreadLibraryCalls(hModule);

    return TRUE;
}

BOOL
AbortThisJob(PUSBMON_PORT_INFO pPortInfo)
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
         !GetJob(pPortInfo->hPrinter, pPortInfo->dwJobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
 )
        goto Done;

    bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
           (pJobInfo->Status & JOB_STATUS_DELETED)  ||
           (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
    FreeSplMem(pJobInfo);

    return bRet;
}




BOOL
WINAPI
USBMON_OpenPort(
    LPTSTR      pszPortName,
    LPHANDLE    pHandle
    )
{
    PUSBMON_PORT_INFO   pPortInfo, pPrev;

    pPortInfo = FindPort(&gUsbmonInfo, pszPortName,  &pPrev);

    if ( pPortInfo ) {

        *pHandle = (LPHANDLE)pPortInfo;
        InitializeCriticalSection(&pPortInfo->CriticalSection);
        return TRUE;
    } else {

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

}

BOOL
WINAPI
USBMON_ClosePort(
    HANDLE  hPort
    )
{
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    DeleteCriticalSection(&pPortInfo->CriticalSection);
    return TRUE;
}


//
// Dot4Pnp - test whether we need to force a dot4 pnp event if the dot4 stack doesn't exist.
//
BOOL
Dot4Pnp(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL      bRet = FALSE;
    HANDLE    hToken;
    DEVINST   hLPTDevInst;
    TCHAR     szPnpEntry[]=TEXT("Root\\ParallelClass\\0000");   // The pnp node to reenumerate.
    TCHAR     cszDot4[]=TEXT("DOT4");                           // This relates to the array size below.
    TCHAR     szPort[5];                                        // 4 chars for "DOT4" and the ending 0.
    UINT      uOldErrorMode;
    HINSTANCE hCfgMgr32 = 0;                                    // Library instance.
    // Pointers to pnp functions...
    pfCM_Locate_DevNode_Ex pfnLocateDevNode; 
    pfCM_Reenumerate_DevNode_Ex pfnReenumDevNode;

    //
    //  Make a copy of the first 4 chars of the port name - to compare against Dot4.
    //  Copy length of 4 chars + 1 for null.
    lstrcpyn( szPort, pPortInfo->szPortName, lstrlen(cszDot4)+1 );
    szPort[lstrlen(cszDot4)]=0;

    if( lstrcmpi( szPort, cszDot4) != 0)
    {
        //
        // If this is not a dot4 port and we failed to open it - fail.
        //
        goto Done;
    }

    //
    // If it is a dot4 device we need to force a pnp event on the parallel port to get the
    // dot4 stack rebuilt.  
    // If any of these fail, fail the call just as if the port couldn't be opened.
    //
    // Load the pnp dll.
    //

    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hCfgMgr32 = LoadLibrary( cszCFGMGR32 );
    if(!hCfgMgr32)
    {
        SetErrorMode(uOldErrorMode);
        goto Done;
    }
    SetErrorMode(uOldErrorMode);

    //
    // Get the Addressed of pnp functions we want to call...
    //
    pfnLocateDevNode = (pfCM_Locate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszLocalFunc );
    pfnReenumDevNode = (pfCM_Reenumerate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszReenumFunc );

    if( !pfnLocateDevNode || !pfnReenumDevNode )
        goto Done;

    //
    // We need to revert to system context here as otherwise the pnp call will fail if the user
    // is anything other than an admin as this requires admin rights.
    // If this fails, the pnp will fail anyway, so we don't need to test the return value.
    //
    hToken = RevertToPrinterSelf();

    //
    // Reenumerate from the root of the devnode tree
    //
    if( ( pfnLocateDevNode( &hLPTDevInst, szPnpEntry, CM_LOCATE_DEVNODE_NORMAL, NULL ) != CR_SUCCESS) ||
        ( pfnReenumDevNode( hLPTDevInst, CM_REENUMERATE_NORMAL, NULL ) != CR_SUCCESS) )
    {
        //
        // Revert back to the user's context in case we failed for another reason other than 
        // ACCESS DENIED (not admin)
        //
        ImpersonatePrinterClient(hToken);
        goto Done;
    }

    //
    // Revert back to the user's context.
    //
    ImpersonatePrinterClient(hToken);

    //
    // Try and open the port again.  
    // If we fail, then the device must not be there any more or still switched off - fail as usual.
    // 
    pPortInfo->hDeviceHandle = CreateFile(pPortInfo->szDevicePath,
                                          GENERIC_WRITE | GENERIC_READ,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
                                          OPEN_EXISTING,
                                          FILE_FLAG_OVERLAPPED,
                                          NULL);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE )
        goto Done;

    bRet = TRUE;
Done:
    if(hCfgMgr32)
        FreeLibrary(hCfgMgr32);

    return bRet;
}


BOOL
LocalOpenPort(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL    bRet = FALSE;

    EnterCriticalSection(&pPortInfo->CriticalSection);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE ) {

        //
        // If we have an invalid handle and refcount is non-zero we want the
        // job to fail and restart to accept writes. In other words if the
        // handle got closed prematurely, because of failing writes, then we
        // need the ref count to go down to 0 before calling CreateFile again
        //
        if ( pPortInfo->cRef )
            goto Done;

        pPortInfo->hDeviceHandle = CreateFile(pPortInfo->szDevicePath,
                                              GENERIC_WRITE | GENERIC_READ,
                                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                                              NULL,
                                              OPEN_EXISTING,
                                              FILE_FLAG_OVERLAPPED,
                                              NULL);
        //
        // If we failed to open the port - test to see if it is a Dot4 port.
        //
        if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE )
        {
            //
            // ERROR_FILE_NOT_FOUND -> Error code for port not there.
            //
            if( ERROR_FILE_NOT_FOUND != GetLastError() || 
                !Dot4Pnp(pPortInfo) )
                goto Done;
        }

        pPortInfo->Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
        if ( pPortInfo->Ov.hEvent == NULL ) {

            CloseHandle(pPortInfo->hDeviceHandle);
            pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;
            goto Done;
        }

    }

    ++(pPortInfo->cRef);
    bRet = TRUE;

Done:
    LeaveCriticalSection(&pPortInfo->CriticalSection);
    return bRet;
}


BOOL
LocalClosePort(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL    bRet = TRUE;
    BOOL bJobCanceled=FALSE;

    EnterCriticalSection(&pPortInfo->CriticalSection);

    --(pPortInfo->cRef);
    if ( pPortInfo->cRef != 0 )
        goto Done;

    bRet = CloseHandle(pPortInfo->hDeviceHandle);
    CloseHandle(pPortInfo->Ov.hEvent);
    pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;

Done:
    LeaveCriticalSection(&pPortInfo->CriticalSection);
    return bRet;
}


VOID
FreeWriteBuffer(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    FreeSplMem(pPortInfo->pWriteBuffer);
    pPortInfo->pWriteBuffer=NULL;

    pPortInfo->dwBufferSize = pPortInfo->dwDataSize
                            = pPortInfo->dwDataCompleted
                            = pPortInfo->dwDataScheduled = 0;

}


BOOL
WINAPI
USBMON_StartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   dwJobId,
    DWORD   dwLevel,
    LPBYTE  pDocInfo
    )
{
    BOOL                bRet = FALSE;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    SPLASSERT(pPortInfo->pWriteBuffer       == NULL &&
              pPortInfo->dwBufferSize       == 0    &&
              pPortInfo->dwDataSize         == 0    &&
              pPortInfo->dwDataCompleted    == 0    &&
              pPortInfo->dwDataScheduled    == 0);

    if ( !OpenPrinter(pPrinterName, &pPortInfo->hPrinter, NULL) )
        return FALSE;

    pPortInfo->dwJobId = dwJobId;
    bRet = LocalOpenPort(pPortInfo);

    if ( !bRet ) {

        if ( pPortInfo->hPrinter ) {

            ClosePrinter(pPortInfo->hPrinter);
            pPortInfo->hPrinter = NULL;
        }
    } else
        pPortInfo->dwFlags |= USBMON_STARTDOC;

    return bRet;
}


BOOL
NeedToResubmitJob(
    DWORD   dwLastError
    )
{
    //
    // I used winerror -s ntstatus to map KM error codes to user mode errors
    //
    // 5 ERROR_ACCESS_DENIED <--> c0000056 STATUS_DELETE_PENDING
    // 6 ERROR_INVALID_HANDLE <--> c0000008 STATUS_INVALID_HANDLE
    // 23 ERROR_CRC <--> 0xc000003e STATUS_DATA_ERROR
    // 23 ERROR_CRC <--> 0xc000003f STATUS_CRC_ERROR
    // 23 ERROR_CRC <--> 0xc000009c STATUS_DEVICE_DATA_ERROR
    // 55 ERROR_DEV_NOT_EXIST <--> c00000c0 STATUS_DEVICE_DOES_NOT_EXIST
    //
    return dwLastError == ERROR_ACCESS_DENIED   ||
           dwLastError == ERROR_INVALID_HANDLE  ||
           dwLastError == ERROR_CRC             ||
           dwLastError == ERROR_DEV_NOT_EXIST;
}


VOID
InvalidatePortHandle(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    SPLASSERT(pPortInfo->hDeviceHandle != INVALID_HANDLE_VALUE);

    CloseHandle(pPortInfo->hDeviceHandle);
    pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;

    CloseHandle(pPortInfo->Ov.hEvent);
    pPortInfo->Ov.hEvent = NULL;

    FreeWriteBuffer(pPortInfo);
}



DWORD
ScheduleWrite(
    PUSBMON_PORT_INFO   pPortInfo
    )
/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS : Write got succesfully scheduled
                    (may or may not have completed on return)
                    pPortInfo->dwScheduledData is the amount that got scheduled
    Others: Write failed, return code is the Win32 error 

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS, dwDontCare;

    //
    // When a sheduled write is pending we should not try to send data
    // any more
    //
    SPLASSERT(pPortInfo->dwDataScheduled == 0);

    //
    // Send all the data that is not confirmed
    //
    SPLASSERT(pPortInfo->dwDataSize >= pPortInfo->dwDataCompleted);
    pPortInfo->dwDataScheduled = pPortInfo->dwDataSize -
                                      pPortInfo->dwDataCompleted;

    if ( !WriteFile(pPortInfo->hDeviceHandle,
                    pPortInfo->pWriteBuffer + pPortInfo->dwDataCompleted,
                    pPortInfo->dwDataScheduled,
                    &dwDontCare,
                    &pPortInfo->Ov) ) {

        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
            dwLastError = STG_E_UNKNOWN;
        else  if ( dwLastError == ERROR_IO_PENDING )
            dwLastError = ERROR_SUCCESS;
    }

    //
    // If scheduling of the write failed then no data is pending
    //
    if ( dwLastError != ERROR_SUCCESS )
        pPortInfo->dwDataScheduled = 0;

    return dwLastError;
}


DWORD
ScheduledWriteStatus(
    PUSBMON_PORT_INFO   pPortInfo,
    DWORD               dwTimeout
    )
/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS   : Write got done succesfully
    ERROR_TIMEOUT   : Timeout occured
    Others          : Write completed with a failure

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   dwWritten = 0;

    SPLASSERT(pPortInfo->dwDataScheduled > 0);

    if ( WAIT_TIMEOUT == WaitForSingleObject(pPortInfo->Ov.hEvent,
                                             dwTimeout) ) {

        dwLastError = ERROR_TIMEOUT;
        goto Done;
    }

    if ( !GetOverlappedResult(pPortInfo->hDeviceHandle,
                              &pPortInfo->Ov,
                              &dwWritten,
                              FALSE) ) {

        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
            dwLastError = STG_E_UNKNOWN;
    }

    ResetEvent(pPortInfo->Ov.hEvent);

    //
    // We are here because either a write completed succesfully,
    // or failed but the error is not serious enough to resubmit job
    //
    if ( dwWritten <= pPortInfo->dwDataScheduled )
        pPortInfo->dwDataCompleted += dwWritten;
    else
        SPLASSERT(dwWritten <= pPortInfo->dwDataScheduled);

    pPortInfo->dwDataScheduled = 0;

Done:
    //
    // Either we timed out, or write sheduled completed (success of failure)
    //
    SPLASSERT(dwLastError == ERROR_TIMEOUT || pPortInfo->dwDataScheduled == 0);
    return dwLastError;
}


BOOL
WINAPI
USBMON_EndDocPort(
    HANDLE  hPort
    )
{
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    DWORD               dwLastError = ERROR_SUCCESS;

    //
    // Wait for any outstanding write to complete
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        //
        // If job needs to be aborted ask KM driver to cancel the I/O
        //
        if ( AbortThisJob(pPortInfo) ) {

            if ( pPortInfo->dwDataScheduled ) {

                CancelIo(pPortInfo->hDeviceHandle);
                dwLastError = ScheduledWriteStatus(pPortInfo, INFINITE);
            }
            goto Done;
        }

        if ( pPortInfo->dwDataScheduled )
            dwLastError = ScheduledWriteStatus(pPortInfo,
                                               JOB_ABORTCHECK_TIMEOUT);
        else {

            //
            // If for some reason KM is failing to complete all write do not
            // send data in a busy loop. Use 1 sec between Writes
            //
            if ( dwLastError != ERROR_SUCCESS )
                Sleep(1*1000);

            dwLastError = ScheduleWrite(pPortInfo);
        }

        //
        // Check if we can use the same handle and continue
        //
        if ( NeedToResubmitJob(dwLastError) ) {

            InvalidatePortHandle(pPortInfo);
            SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
                   NULL, JOB_CONTROL_RESTART);
            goto Done;
        }
    }

Done:
    FreeWriteBuffer(pPortInfo);

    pPortInfo->dwFlags  &= ~USBMON_STARTDOC;

    LocalClosePort(pPortInfo);
    SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
           NULL, JOB_CONTROL_SENT_TO_PRINTER);

    ClosePrinter(pPortInfo->hPrinter);
    pPortInfo->hPrinter = NULL;
    
    return TRUE;
    

}

    
BOOL
WINAPI
USBMON_GetPrinterDataFromPort(
    HANDLE      hPort,
    DWORD       dwControlID,
    LPWSTR      pValueName,
    LPWSTR      lpInBuffer,
    DWORD       cbInBuffer,
    LPWSTR      lpOutBuffer,
    DWORD       cbOutBuffer,
    LPDWORD     lpcbReturned
    )
{
    BOOL                bRet = FALSE;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    OVERLAPPED          Ov;
    HANDLE hDeviceHandle;
    DWORD dwWaitResult;

    *lpcbReturned = 0;

    if ( dwControlID == 0 ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ZeroMemory(&Ov, sizeof(Ov));
    if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        return FALSE;

    if ( !LocalOpenPort(pPortInfo) ) {

        CloseHandle(Ov.hEvent);
        return FALSE;
    }

    if(dwControlID==IOCTL_PAR_QUERY_DEVICE_ID)
    {
        hDeviceHandle=CreateFile(pPortInfo->szDevicePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL);
        if(hDeviceHandle==INVALID_HANDLE_VALUE)
            goto Done;
        if ( !DeviceIoControl(pPortInfo->hDeviceHandle, dwControlID,lpInBuffer, cbInBuffer,lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov) 
            && GetLastError() != ERROR_IO_PENDING )
        {
          CloseHandle(hDeviceHandle);
          goto Done;
        }

        if(WaitForSingleObject(Ov.hEvent,PAR_QUERY_TIMEOUT)!=WAIT_OBJECT_0)
          CancelIo(hDeviceHandle);
        bRet = GetOverlappedResult(pPortInfo->hDeviceHandle, &Ov,lpcbReturned,TRUE);
      CloseHandle(hDeviceHandle);
    }
    else
    {
      if ( !DeviceIoControl(pPortInfo->hDeviceHandle, dwControlID,
                          lpInBuffer, cbInBuffer,
                          lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)  &&
          GetLastError() != ERROR_IO_PENDING )
        goto Done;

      bRet = GetOverlappedResult(pPortInfo->hDeviceHandle, &Ov,
                               lpcbReturned, TRUE);
    }

Done:
    CloseHandle(Ov.hEvent);

    LocalClosePort(pPortInfo);

            
    return bRet;
}


BOOL
WINAPI
USBMON_ReadPort(
    HANDLE      hPort,
    LPBYTE      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pcbRead
    )
{
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwTimeout;
    HANDLE              hReadHandle;
    OVERLAPPED          Ov;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    //
    // Create separate read handle since we have to cancel reads which do
    // not complete within the specified timeout without cancelling writes
    //
    hReadHandle = CreateFile(pPortInfo->szDevicePath,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED,
                             NULL);

    if ( hReadHandle == INVALID_HANDLE_VALUE )
        return FALSE;

    ZeroMemory(&Ov, sizeof(Ov));

    if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        goto Done;

    if ( !ReadFile(hReadHandle, pBuffer, cbBuffer, pcbRead, &Ov) &&
         (dwLastError = GetLastError()) != ERROR_IO_PENDING )
        goto Done;

    dwTimeout = pPortInfo->ReadTimeoutConstant +
                    pPortInfo->ReadTimeoutMultiplier * cbBuffer;

    if ( dwTimeout == 0 )
        dwTimeout=MAX_TIMEOUT;

    if( WaitForSingleObject(Ov.hEvent, dwTimeout) == WAIT_TIMEOUT ) {

        CancelIo(hReadHandle);
        WaitForSingleObject(Ov.hEvent, INFINITE);
    }

    if( !GetOverlappedResult(hReadHandle, &Ov, pcbRead, FALSE) ) {

        *pcbRead = 0;
        dwLastError = GetLastError();
    } else
        dwLastError = ERROR_SUCCESS;

Done:
    if ( Ov.hEvent )
        CloseHandle(Ov.hEvent);

    CloseHandle(hReadHandle);

    if ( dwLastError )
        SetLastError(dwLastError);

    return dwLastError == ERROR_SUCCESS;
}

DWORD dwGetTimeLeft(DWORD dwStartTime,DWORD dwTimeout)
{
    DWORD dwCurrentTime;
    DWORD dwTimeLeft;

    if(dwTimeout==MAX_TIMEOUT)
        return MAX_TIMEOUT;
    dwCurrentTime=GetTickCount();
    if(dwTimeout<(dwCurrentTime-dwStartTime))
        dwTimeLeft=0;
    else
      dwTimeLeft=dwTimeout-(dwCurrentTime-dwStartTime);
    return dwTimeLeft;
}

BOOL
WINAPI
USBMON_WritePort(
    HANDLE      hPort,
    LPBYTE      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pcbWritten
    )
{
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwBytesLeft, dwBytesSent;
    DWORD               dwStartTime, dwTimeLeft, dwTimeout;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    BOOL                bStartDoc = (pPortInfo->dwFlags & USBMON_STARTDOC) != 0;
    BYTE                bPrinterStatus;

    *pcbWritten = 0;
    dwStartTime = GetTickCount();
    dwTimeout   = pPortInfo->WriteTimeoutConstant + pPortInfo->WriteTimeoutMultiplier * cbBuffer;

    if ( dwTimeout == 0 )
        dwTimeout = MAX_TIMEOUT;

    //
    // Usbprint currently can't handle write greater than 4K.
    // For Win2K we will make a fix here, later usbprint will be fixed
    //
    // It is ok to change the size here since spooler will resubmit the rest
    // later
    //
    if ( cbBuffer > 0x1000  &&
         !lstrncmpi(pPortInfo->szPortName, TEXT("USB"), lstrlen(TEXT("USB"))) )
        cbBuffer = 0x1000;

    //
    // For writes outside startdoc/enddoc we do not carry them across WritePort
    // calls. These are typically from language monitors (i.e. not job data)
    //
    SPLASSERT(bStartDoc || pPortInfo->pWriteBuffer == NULL);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE ) {

        SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
               NULL, JOB_CONTROL_RESTART);
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    if ( !LocalOpenPort(pPortInfo) )
        return FALSE;

    //
    // First complete any data from previous WritePort call
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        if ( pPortInfo->dwDataScheduled ) {

            dwTimeLeft  = dwGetTimeLeft(dwStartTime, dwTimeout);
            dwLastError = ScheduledWriteStatus(pPortInfo, dwTimeLeft);
        } else
            dwLastError = ScheduleWrite(pPortInfo);

        if ( dwLastError != ERROR_SUCCESS )
            goto Done;
    }

    SPLASSERT(pPortInfo->dwDataSize == pPortInfo->dwDataCompleted   &&
              pPortInfo->dwDataScheduled == 0                       &&
              dwLastError == ERROR_SUCCESS);

    //
    // Copy the data to our own buffer
    //
    if ( pPortInfo->dwBufferSize < cbBuffer ) {

        FreeWriteBuffer(pPortInfo);
        if ( pPortInfo->pWriteBuffer = AllocSplMem(cbBuffer) )
            pPortInfo->dwBufferSize = cbBuffer;
        else {

            dwLastError = ERROR_OUTOFMEMORY;
            goto Done;
        }
    } else {

        pPortInfo->dwDataCompleted = pPortInfo->dwDataScheduled = 0;
    }

    CopyMemory(pPortInfo->pWriteBuffer, pBuffer, cbBuffer);
    pPortInfo->dwDataSize = cbBuffer;

    //
    // Now do the write for the data for this WritePort call
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        if ( pPortInfo->dwDataScheduled ) {

            dwTimeLeft  = dwGetTimeLeft(dwStartTime, dwTimeout);
            dwLastError = ScheduledWriteStatus(pPortInfo, dwTimeLeft);
        } else
            dwLastError = ScheduleWrite(pPortInfo);

        if ( dwLastError != ERROR_SUCCESS )
            break;
    }

    //
    // For writes outside startdoc/enddoc, which are from language monitors,
    // do not carry pending writes to next WritePort.
    //
    if ( !bStartDoc && pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        CancelIo(pPortInfo->hDeviceHandle);
        dwLastError = ScheduledWriteStatus(pPortInfo, INFINITE);
        *pcbWritten = pPortInfo->dwDataCompleted;
        FreeWriteBuffer(pPortInfo);
    }

    //
    // We will tell spooler we wrote all the data if some data got scheduled
    //  (or scheduled and completed)
    //
    if ( pPortInfo->dwDataCompleted > 0 || pPortInfo->dwDataScheduled != 0 )
        *pcbWritten = cbBuffer;
    else
        FreeWriteBuffer(pPortInfo);

Done:
    if ( NeedToResubmitJob(dwLastError) )
        InvalidatePortHandle(pPortInfo);
    else if ( dwLastError == ERROR_TIMEOUT ) {

        GetLptStatus(pPortInfo->hDeviceHandle, &bPrinterStatus);
        if ( bPrinterStatus & LPT_PAPER_EMPTY )
            dwLastError=ERROR_OUT_OF_PAPER;
    }
  
    LocalClosePort(pPortInfo);
    SetLastError(dwLastError);
    return dwLastError == ERROR_SUCCESS;
}


BOOL
WINAPI
USBMON_SetPortTimeOuts(
    HANDLE hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD reserved
    )
{
    
    PUSBMON_PORT_INFO pPortInfo = (PUSBMON_PORT_INFO)hPort;
    pPortInfo->ReadTimeoutMultiplier    = lpCTO->ReadTotalTimeoutMultiplier;
    pPortInfo->ReadTimeoutConstant      = lpCTO->ReadTotalTimeoutConstant;
    pPortInfo->WriteTimeoutMultiplier   = lpCTO->WriteTotalTimeoutMultiplier;
    pPortInfo->WriteTimeoutConstant     = lpCTO->WriteTotalTimeoutConstant;

    return TRUE;
}



BOOL GetLptStatus(HANDLE hDeviceHandle,BYTE *Status)
{
    BYTE StatusByte;
    OVERLAPPED Ov;

    BOOL bResult;
    DWORD dwBytesReturned;
    DWORD dwLastError;
    Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
    bResult=DeviceIoControl(hDeviceHandle,IOCTL_USBPRINT_GET_LPT_STATUS,NULL,0,&StatusByte,1,&dwBytesReturned,&Ov);
    dwLastError=GetLastError();      
    if((bResult)||(dwLastError==ERROR_IO_PENDING))
        bResult=GetOverlappedResult(hDeviceHandle,&Ov,&dwBytesReturned,TRUE);
    if(bResult)
    {
        *Status=StatusByte;
    }
    else
    {
        *Status=LPT_BENIGN_STATUS; //benign printer status...  0 would indicate a particular error status from the printer
    }
    CloseHandle(Ov.hEvent);
    return bResult;
}














MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        USBMON_EnumPorts,
        USBMON_OpenPort,
        NULL,                           // OpenPortEx not supported
        USBMON_StartDocPort,
        USBMON_WritePort,
        USBMON_ReadPort,
        USBMON_EndDocPort,
        USBMON_ClosePort,
        NULL,                           // AddPort not supported
        NULL,                           // AddPortEx not supported
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        USBMON_GetPrinterDataFromPort,
        USBMON_SetPortTimeOuts,
        NULL,                           // XcvOpenPort not supported
        NULL,                           // XcvDataPort not supported
        NULL                            // XcvClosePort not supported
    }
};

USBMON_MONITOR_INFO gUsbmonInfo;

LPMONITOREX
WINAPI
InitializePrintMonitor(
    LPTSTR  pszRegistryRoot
    )

{
    ZeroMemory(&gUsbmonInfo, sizeof(gUsbmonInfo));
    InitializeCriticalSection(&gUsbmonInfo.EnumPortsCS);
    InitializeCriticalSection(&gUsbmonInfo.BackThreadCS);

    return &MonitorEx;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\config.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    config.c

Abstract:

    Handles spooler entry points for adding, deleting, and configuring
    localmon ports.

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


PINIPORT
LcmCreatePortEntry(
    PINILOCALMON pIniLocalMon,
    PWSTR pPortName
    )
{
    DWORD       cb;
    PINIPORT    pIniPort, pPort;

    if (!pPortName || wcslen(pPortName) > 247)
    {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }

    cb = sizeof(INIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

    pIniPort=AllocSplMem(cb);

    if( pIniPort )
    {
        pIniPort->pName = wcscpy((LPWSTR)(pIniPort+1), pPortName);
        pIniPort->cb = cb;
        pIniPort->pNext = 0;
        pIniPort->pIniLocalMon = pIniLocalMon;
        pIniPort->signature = IPO_SIGNATURE;

        // @@BEGIN_DDKSPLIT
        //
        // KrishnaG --  initialized the hFile value; it will be set to
        // a legal value in the StartDocPort call
        //
        // @@END_DDKSPLIT

        pIniPort->hFile = INVALID_HANDLE_VALUE;


        if (pPort = pIniLocalMon->pIniPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniPort;

        } else
            pIniLocalMon->pIniPort = pIniPort;
    }

    return pIniPort;
}


PINIXCVPORT
CreateXcvPortEntry(
    PINILOCALMON pIniLocalMon,
    LPCWSTR pszName,
    ACCESS_MASK GrantedAccess
)
{
    DWORD       cb;
    PINIXCVPORT pIniXcvPort, pPort;

    cb = sizeof(INIXCVPORT) + (wcslen(pszName) + 1)*sizeof(WCHAR);

    pIniXcvPort = AllocSplMem(cb);

    if( pIniXcvPort )
    {
        pIniXcvPort->pszName = wcscpy((LPWSTR)(pIniXcvPort+1), pszName);
        pIniXcvPort->dwMethod = 0;
        pIniXcvPort->cb = cb;
        pIniXcvPort->pNext = 0;
        pIniXcvPort->signature = XCV_SIGNATURE;
        pIniXcvPort->GrantedAccess = GrantedAccess;
        pIniXcvPort->pIniLocalMon = pIniLocalMon;


        if (pPort = pIniLocalMon->pIniXcvPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniXcvPort;

        } else
            pIniLocalMon->pIniXcvPort = pIniXcvPort;
    }

    return pIniXcvPort;
}

BOOL
DeleteXcvPortEntry(
    PINIXCVPORT  pIniXcvPort
)
{
    PINILOCALMON pIniLocalMon = pIniXcvPort->pIniLocalMon;
    PINIXCVPORT  pPort, pPrevPort;

    for (pPort = pIniLocalMon->pIniXcvPort;
         pPort && pPort != pIniXcvPort;
         pPort = pPort->pNext){

        pPrevPort = pPort;
    }

    if (pPort) {    // found the port
        if (pPort == pIniLocalMon->pIniXcvPort) {
            pIniLocalMon->pIniXcvPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }

        FreeSplMem(pPort);

        return TRUE;
    }
    else            // port not found
        return FALSE;
}



BOOL
LcmDeletePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
)
{
    DWORD       cb;
    PINIPORT    pPort, pPrevPort;

    cb = sizeof(INIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

    pPort = pIniLocalMon->pIniPort;


    while (pPort) {

        if (!lstrcmpi(pPort->pName, pPortName)) {
            if (pPort->Status & PP_FILEPORT) {
                pPrevPort = pPort;
                pPort = pPort->pNext;
                continue;
            }
            break;
        }

        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort) {
        if (pPort == pIniLocalMon->pIniPort) {
            pIniLocalMon->pIniPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplMem(pPort);

        return TRUE;
    }
    else
        return FALSE;
}



DWORD
GetPortSize(
    PINIPORT pIniPort,
    DWORD   Level
)
{
    DWORD   cb;
    WCHAR   szLocalMonitor[MAX_PATH+1], szPortDesc[MAX_PATH+1];

    switch (Level) {

    case 1:

        cb=sizeof(PORT_INFO_1) +
           wcslen(pIniPort->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    case 2:
        LoadString(LcmhInst, IDS_LOCALMONITORNAME, szLocalMonitor, MAX_PATH);
        LoadString(LcmhInst, IDS_LOCALMONITOR, szPortDesc, MAX_PATH);
        cb = wcslen(pIniPort->pName) + 1 +
             wcslen(szLocalMonitor) + 1 +
             wcslen(szPortDesc) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(PORT_INFO_2);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniPortToPort(
    PINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
)
{
    LPWSTR         *SourceStrings,  *pSourceStrings;
    PPORT_INFO_2    pPort2 = (PPORT_INFO_2)pPortInfo;
    WCHAR           szLocalMonitor[MAX_PATH+1], szPortDesc[MAX_PATH+1];
    DWORD          *pOffsets;
    DWORD           Count;

    switch (Level) {

    case 1:
        pOffsets = LcmPortInfo1Strings;
        break;

    case 2:
        pOffsets = LcmPortInfo2Strings;
        break;

    default:
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
        return NULL;
    }

    for ( Count = 0 ; pOffsets[Count] != -1 ; ++Count ) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(Count * sizeof(LPWSTR));

    if ( !SourceStrings ) {

        DBGMSG( DBG_WARNING, ("Failed to alloc port source strings.\n"));
        return NULL;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniPort->pName;

        break;

    case 2:
        *pSourceStrings++=pIniPort->pName;

        LoadString(LcmhInst, IDS_LOCALMONITORNAME, szLocalMonitor, MAX_PATH);
        LoadString(LcmhInst, IDS_LOCALMONITOR, szPortDesc, MAX_PATH);
        *pSourceStrings++ = szLocalMonitor;
        *pSourceStrings++ = szPortDesc;

        // @@BEGIN_DDKSPLIT
        // How do i findout other types ???
        // @@END_DDKSPLIT
        pPort2->fPortType = PORT_TYPE_WRITE;

        // Reserved
        pPort2->Reserved = 0;

        break;

    default:
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
        return NULL;
    }

    pEnd = PackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);

    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\dialogs.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.h

Abstract:

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#ifndef _DIALOGS_H_
#define _DIALOGS_H_

BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    PHANDLE phFile
);

BOOL
PrintToFileCommandOK(
    HWND hwnd
);

BOOL
PrintToFileCommandCancel(
    HWND hwnd
);

BOOL
LocalHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    );

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\dialogs.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.c

Abstract:

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "dialogs.h"

WCHAR szLcmHelpFile[] = L"WINDOWS.HLP";

const DWORD g_aHelpIDs[]=
{
    IDD_PF_EF_OUTPUTFILENAME, 8810218, // Print to File: "" (Edit)
    0, 0
};

/* PortIsValid
 *
 * Validate the port by attempting to create/open it.
 */
BOOL
PortIsValid(
    LPWSTR pPortName
)
{
    HANDLE hFile;
    BOOL   Valid;

    //
    // For COM and LPT ports, no verification
    //
    if ( IS_COM_PORT( pPortName ) ||
        IS_LPT_PORT( pPortName ) ||
        IS_FILE_PORT( pPortName ) )
    {
        return TRUE;
    }

    hFile = CreateFile(pPortName,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = CreateFile(pPortName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                           NULL);
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        Valid = TRUE;
    } else {
        Valid = FALSE;
    }

    return Valid;
}

/*
 *
 */
INT_PTR APIENTRY
PrintToFileDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return PrintToFileInitDialog(hwnd, (PHANDLE)lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return PrintToFileCommandOK(hwnd);

        case IDCANCEL:
            return PrintToFileCommandCancel(hwnd);
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return LocalHelp(hwnd, msg, wparam, lparam);

    }

    return FALSE;
}


/*
 *
 */
BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    PHANDLE phFile
)
{
    BringWindowToTop( hwnd );

    SetFocus(hwnd);

    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)phFile );

    SendDlgItemMessage( hwnd, IDD_PF_EF_OUTPUTFILENAME, EM_LIMITTEXT, MAX_PATH, 0);

    return TRUE;
}


/*
 *
 */
BOOL
PrintToFileCommandOK(
    HWND hwnd
)
{
    WCHAR           pFileName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    PHANDLE         phFile;
    HANDLE          hFile;
    HANDLE          hFind;

    phFile = (PHANDLE)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    GetDlgItemText( hwnd, IDD_PF_EF_OUTPUTFILENAME,
                    pFileName, MAX_PATH );

    hFind = FindFirstFile( pFileName, &FindData );

    /* If the file already exists, get the user to verify
     * before we overwrite it:
     */
    if( hFind != INVALID_HANDLE_VALUE )
    {
        FindClose( hFind );

        if( LcmMessage( hwnd, MSG_CONFIRMATION, IDS_LOCALMONITOR,
                     IDS_OVERWRITE_EXISTING_FILE )
            != IDOK )
        {
            return TRUE;
        }
    }


    hFile = CreateFile( pFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        ReportError( hwnd, IDS_LOCALMONITOR, IDS_COULD_NOT_OPEN_FILE );
    }

    else
    {
        *phFile = hFile;
        EndDialog( hwnd, TRUE );
    }

    return TRUE;
}

/*
 *
 */
BOOL
PrintToFileCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, FALSE);
    return TRUE;
}

/*++

Routine Name:

    LocalHelp

Routine Description:

    Handles context sensitive help for the configure LPTX:
    port and the dialog for adding a local port.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if LcmMessage handled, otherwise FALSE.

--*/
BOOL
LocalHelp(
    IN HWND        hDlg,
    IN UINT        uMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                           szLcmHelpFile,
                           HELP_WM_HELP,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp((HWND)wParam,
                           szLcmHelpFile,
                           HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\irda.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation
All rights reserved

Module Name:

    irda.c

Abstract:

    IRDA printing support in localmon

// @@BEGIN_DDKSPLIT
Author:
    Muhunthan Sivapragasam (MuhuntS)    27-Oct-97

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include    "precomp.h"
#pragma hdrstop

#include    <af_irda.h>
#include    "irda.h"

#define     PRINTER_HINT_BIT     0x08
#define     DEVICE_LIST_LEN         5
#define     WRITE_TIMEOUT       60000   // 60 seconds
#define     BUF_SIZE            sizeof(DEVICELIST) + (DEVICE_LIST_LEN - 1) * sizeof(IRDA_DEVICE_INFO)


typedef struct _IRDA_INFO  {
    DWORD           dwBeginTime;
    DWORD           dwSendPduLen;
    WSAOVERLAPPED   WsaOverlapped;
    WSABUF          WsaBuf;
    LPBYTE          pBuf;
} IRDA_INFO, *PIRDA_INFO;


BOOL
IsIRDAInstalled(
    )
{
    BOOL        bRet = FALSE;
    WORD        WSAVerReq = MAKEWORD(1,1);
    SOCKET      hSock;
    WSADATA     WSAData;


    if ( WSAStartup(WSAVerReq, &WSAData) == ERROR_SUCCESS       &&
         (hSock = socket(AF_IRDA, SOCK_STREAM, 0)) != INVALID_SOCKET ) {

        closesocket(hSock);
        bRet = TRUE;
    }

    WSACleanup();
    return bRet;
}


VOID
CheckAndAddIrdaPort(
    PINILOCALMON    pIniLocalMon
    )
{
    PINIPORT    pIniPort;

    LcmEnterSplSem();

    for ( pIniPort = pIniLocalMon->pIniPort ;
          pIniPort && !IS_IRDA_PORT(pIniPort->pName) ;
          pIniPort = pIniPort->pNext )
    ;

    LcmLeaveSplSem();

    if ( pIniPort || !IsIRDAInstalled() )
        return;

    //
    // Add the port to the list and write to registry
    //
    LcmCreatePortEntry(pIniLocalMon, szIRDA);

// @@BEGIN_DDKSPLIT
/*
    if ( (pIniPort = LcmCreatePortEntry(pIniLocalMon, szIRDA))  &&
         !WriteProfileString(szPorts, szIRDA, L"") ) {

        DeletePortNode(pIniLocalMon, pIniPort);
    }
*/
// @@END_DDKSPLIT
}


VOID
CloseIrdaConnection(
    PINIPORT    pIniPort
    )
{
    PIRDA_INFO  pIrda = (PIRDA_INFO) pIniPort->pExtra;

    if ( pIrda ) {

        if ( pIrda->WsaOverlapped.hEvent )
            WSACloseEvent(pIrda->WsaOverlapped.hEvent);

        FreeSplMem(pIrda);
        pIniPort->pExtra = NULL;
    }

    if ( (SOCKET)pIniPort->hFile != INVALID_SOCKET ) {

        closesocket((SOCKET)pIniPort->hFile);
        pIniPort->hFile = (HANDLE)INVALID_SOCKET;
    }
}


DWORD
IrdaConnect(
    PINIPORT    pIniPort
    )
{
    BOOL            bRet = FALSE;
    WORD            WSAVerReq = MAKEWORD(1,1);
    DWORD           dwIndex, dwNeeded = BUF_SIZE, dwEnableIrLPT = TRUE,
                    dwLastError = ERROR_SUCCESS, dwSendPduLen;
    LPSTR           pBuf = NULL;
    WSADATA         WSAData;
    SOCKET          Socket = INVALID_SOCKET;
    IAS_QUERY       IasQuery;
    PIRDA_INFO      pIrda;
    PDEVICELIST     pDevList;
    SOCKADDR_IRDA   PrinterAddr  = { AF_IRDA, 0, 0, 0, 0, "IrLPT" };

    SPLASSERT(pIniPort->hFile == (HANDLE)INVALID_SOCKET && pIniPort->pExtra == NULL);

    if ( dwLastError = WSAStartup(WSAVerReq, &WSAData) )
        goto Done;

    if ( !(pBuf = AllocSplMem(dwNeeded)) ) {

        dwLastError = GetLastError();
        goto Done;
    }

    if ( (Socket = WSASocket(AF_IRDA, SOCK_STREAM, 0, NULL, 0,
                             WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET    ||
         getsockopt(Socket, SOL_IRLMP, IRLMP_ENUMDEVICES,
                    (LPSTR)pBuf, &dwNeeded) == SOCKET_ERROR ) {

        dwLastError = WSAGetLastError();
        goto Done;
    }

    if ( dwNeeded > BUF_SIZE ) {

        FreeSplMem(pBuf);
        if ( !(pBuf = AllocSplMem(dwNeeded)) ) {

            dwLastError = GetLastError();
            goto Done;
        }

        if ( getsockopt(Socket, SOL_IRLMP, IRLMP_ENUMDEVICES,
                        (LPSTR)pBuf, &dwNeeded) == SOCKET_ERROR ) {

            dwLastError = WSAGetLastError();
            goto Done;
        }
    }

    pDevList = (PDEVICELIST) pBuf;

    //
    // Any of the devices a printer?
    //
    for ( dwIndex = 0 ; dwIndex < pDevList->numDevice ; ++dwIndex ) {

        if ( (pDevList->Device[dwIndex].irdaDeviceHints1 & PRINTER_HINT_BIT)  ||
             (pDevList->Device[dwIndex].irdaDeviceHints2 & PRINTER_HINT_BIT) )
            break;
    }

    //
    // Any printers found?
    //
    if ( dwIndex == pDevList->numDevice ) {

        dwLastError = ERROR_PRINTER_NOT_FOUND;
        goto Done;
    }

    //
    // Move printer's address into the socket address
    //
    memcpy(PrinterAddr.irdaDeviceID,
           pDevList->Device[dwIndex].irdaDeviceID,
           sizeof(PrinterAddr.irdaDeviceID));

    dwIndex = 0;
    dwNeeded = sizeof(dwSendPduLen);
    bRet = SOCKET_ERROR != setsockopt(Socket,
                                      SOL_IRLMP,
                                      IRLMP_IRLPT_MODE,
                                      (LPCSTR)&dwEnableIrLPT,
                                      sizeof(dwEnableIrLPT))    &&
           SOCKET_ERROR != connect(Socket,
                                   (const struct sockaddr *)&PrinterAddr,
                                   sizeof(PrinterAddr))         &&
           // @@BEGIN_DDKSPLIT
           //
           // What size should we use for sends?
           //
           // @@END_DDKSPLIT
           SOCKET_ERROR != getsockopt(Socket,
                                      SOL_IRLMP,
                                      IRLMP_SEND_PDU_LEN,
                                      (char *)&dwSendPduLen,
                                      &dwNeeded) &&
           // @@BEGIN_DDKSPLIT
           //
           // No buffering (i.e. buffer size of 0)
           //
           // @@END_DDKSPLIT
           SOCKET_ERROR != setsockopt(Socket,
                                      SOL_SOCKET,
                                      SO_SNDBUF,
                                      (LPCSTR)&dwIndex,
                                      sizeof(dwIndex));


    if ( bRet ) {

        SPLASSERT(pIniPort->pExtra == NULL);

        dwNeeded = sizeof(IRDA_INFO) + dwSendPduLen;

        if ( !(pIrda = (PIRDA_INFO) AllocSplMem(dwNeeded)) ) {

            bRet = FALSE;
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        pIniPort->hFile     = (HANDLE)Socket;
        pIniPort->pExtra    = (LPBYTE)pIrda;

        pIrda->dwSendPduLen = dwSendPduLen;
        pIrda->pBuf         = ((LPBYTE) pIrda) + sizeof(IRDA_INFO);

    } else
        dwLastError = WSAGetLastError();

Done:
    FreeSplMem(pBuf);

    if ( !bRet ) {

        if ( Socket != INVALID_SOCKET )
            closesocket(Socket);

        FreeSplMem(pIniPort->pExtra);
        pIniPort->pExtra = NULL;
    }

    return bRet ? ERROR_SUCCESS : dwLastError;
}


BOOL
AbortThisJob(
    PINIPORT    pIniPort
    )
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(pIniPort->hPrinter, pIniPort->JobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
         !GetJob(pIniPort->hPrinter, pIniPort->JobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
 )
        goto Done;

    bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
           (pJobInfo->Status & JOB_STATUS_DELETED)  ||
           (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
    if ( pJobInfo )
        FreeSplMem(pJobInfo);

    return bRet;
}


VOID
IrdaDisconnect(
    PINIPORT    pIniPort
    )
{
    BOOL        bRet;
    DWORD       dwRet, dwSent, dwFlags;
    SOCKET      Socket = (SOCKET) pIniPort->hFile;
    PIRDA_INFO  pIrda = (PIRDA_INFO) pIniPort->pExtra;

    //
    // If the job has already been cancelled close socket and quit
    //
    if ( Socket == INVALID_SOCKET )
        goto Done;

    //
    // If a send is pending wait for all the data to go through indefinitly
    //
    if ( pIrda->WsaOverlapped.hEvent ) {

        do {

            dwRet = WaitForSingleObject(pIrda->WsaOverlapped.hEvent,
                                        WRITE_TIMEOUT);

            if ( dwRet == WAIT_TIMEOUT ) {

                //
                // If user has cancelled the job close connection
                //
                if ( AbortThisJob(pIniPort) )
                    goto Done;
            } else if ( dwRet != WAIT_OBJECT_0 )
                goto Done;
        } while ( dwRet == WAIT_TIMEOUT );

        //
        // IRDA can only send the whole packet so we do not check dwSent
        //
    }

    //
    // No more sends
    //
    shutdown(Socket, SD_SEND);

Done:
    CloseIrdaConnection(pIniPort);
}


BOOL
IrdaStartDocPort(
    IN OUT  PINIPORT    pIniPort
    )
{
    HANDLE hToken;
    DWORD  dwLastError;
     
    //
    // If remote guest is the first user to print, then the connect fails.
    // Thus we need to revert to system context before calling IrdaConnect
    //

    hToken = RevertToPrinterSelf();

    if (!hToken) {
        return FALSE;
    }
    
    dwLastError = IrdaConnect(pIniPort);

    ImpersonatePrinterClient(hToken);

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    } else
        return TRUE;
}


BOOL
IrdaWritePort(
    IN  HANDLE      hPort,
    IN  LPBYTE      pBuf,
    IN  DWORD       cbBuf,
    IN  LPDWORD     pcbWritten
    )
{
    INT             iRet = ERROR_SUCCESS;
    DWORD           dwSent, dwFlags, dwTimeout, dwBuffered;
    PINIPORT        pIniPort = (PINIPORT)hPort;
    SOCKET          Socket = (SOCKET) pIniPort->hFile;
    PIRDA_INFO      pIrda = (PIRDA_INFO)pIniPort->pExtra;

    *pcbWritten = 0;

    //
    // When we have to close socket we fail the write.
    // If anothe write comes through it is because user wanted to retry
    //
    if ( Socket == INVALID_SOCKET ) {

        SPLASSERT(pIrda == NULL);

        SetJob(pIniPort->hPrinter, pIniPort->JobId, 0, NULL, JOB_CONTROL_RESTART);
        iRet = WSAENOTSOCK;
        goto Done;
    }

    SPLASSERT(pIrda != NULL);

    //
    // This is the time spooler issued the write to us
    //
    pIrda->dwBeginTime = GetTickCount();

    do {

        //
        // If event is non-NULL at the beginning we have a pending write from
        // last WritePort call
        //
        if ( pIrda->WsaOverlapped.hEvent ) {

            dwTimeout = GetTickCount() - pIrda->dwBeginTime;

            //
            // We want to wait for WRITE_TIMEOUT time from the time spooler
            // issued the WritePort.
            // If it is already more than that still check what happened to the
            // write before returning
            //
            if ( dwTimeout > WRITE_TIMEOUT )
                dwTimeout = 0;
            else
                dwTimeout = WRITE_TIMEOUT - dwTimeout;

            //
            // Let's wait for the timeout period for the last send to complete
            //
            if ( WAIT_OBJECT_0 != WaitForSingleObject(pIrda->WsaOverlapped.hEvent,
                                                      dwTimeout) ) {

                iRet = ERROR_TIMEOUT;
                goto Done;
            }

            //
            // What happened to the last send?
            //
            if ( WSAGetOverlappedResult(Socket, &pIrda->WsaOverlapped,
                                        &dwSent, FALSE, &dwFlags) == FALSE ) {

                iRet = WSAGetLastError();
                CloseIrdaConnection(pIniPort);
                goto Done;
            }

            //
            // IRDA can only send the whole packet so we do not check dwSent
            //

            //
            // Reset the manual reset event and do the next send
            //
            WSAResetEvent(pIrda->WsaOverlapped.hEvent);

            //
            // Have we already sent all the data?
            //
            if ( cbBuf == 0 ) {

                WSACloseEvent(pIrda->WsaOverlapped.hEvent);
                pIrda->WsaOverlapped.hEvent = NULL;
                goto Done;
            }
        } else {

            pIrda->WsaOverlapped.hEvent = WSACreateEvent();

            if ( !pIrda->WsaOverlapped.hEvent ) {

                iRet = GetLastError();
                CloseIrdaConnection(pIniPort);
                goto Done;
            }
        }

        do {

            //
            // Have we already sent all the data?
            //
            if ( cbBuf == 0 ) {

                WSACloseEvent(pIrda->WsaOverlapped.hEvent);
                pIrda->WsaOverlapped.hEvent = NULL;
                goto Done;
            }

            //
            // Send no more than pIrda->dwSendPduLen
            //
            if ( cbBuf < pIrda->dwSendPduLen )
                dwBuffered = cbBuf;
            else
                dwBuffered = pIrda->dwSendPduLen;

            pIrda->WsaBuf.len   = dwBuffered;
            pIrda->WsaBuf.buf   = pIrda->pBuf;

            CopyMemory(pIrda->pBuf, pBuf, dwBuffered);

            //
            // We are asking a non-blocking send. Typically this will
            // return with I/O pending
            //
            if ( WSASend(Socket, &pIrda->WsaBuf, 1, &dwSent,
                         MSG_PARTIAL, &pIrda->WsaOverlapped, NULL) != NO_ERROR ) {

                iRet = WSAGetLastError();
                break;
            }

            pBuf        += dwSent;
            cbBuf       -= dwSent;
            *pcbWritten += dwSent;
        } while ( iRet == NO_ERROR );

        if ( iRet == WSA_IO_PENDING ) {

            //
            // Lie to spooler we sent the whole data. Next time we will find out
            //
            pBuf        += dwBuffered;
            cbBuf       -= dwBuffered;
            *pcbWritten += dwBuffered;
            iRet = NO_ERROR;
        } else {

            DBGMSG(DBG_ERROR, ("IrdaWritePort: WSASend failed %d\n", iRet));
            CloseIrdaConnection(pIniPort);
        }
    } while ( cbBuf && iRet == NO_ERROR );


Done:
    if ( iRet != ERROR_SUCCESS )
        SetLastError(iRet);

    return iRet == ERROR_SUCCESS;
}


VOID
IrdaEndDocPort(
    PINIPORT    pIniPort
    )
{
    IrdaDisconnect(pIniPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\localmon.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    localmon.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:


    Adina Trufinescu (adinatru) 07-December 1998
    Commented LocalMonInitializePrintMonitor2 that used to be called by InitializePrintMonitor2;
    Changed back to the old interface - InitializePrintMonitor which initialize LcmhMonitor to a MONITOREX structure.
    MONITOREX structure are filled with old style functions(LcmxNAME) that (don't takes hMonitor as parameter).This functions calls
    LcmNAME functions passing LcmhMonitor as hMonitor parameter.

// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "lmon.h"
#include "irda.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
//MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN, DBG_ERROR);
#endif
// @@END_DDKSPLIT

HANDLE LcmhMonitor;
HANDLE LcmhInst;
CRITICAL_SECTION LcmSpoolerSection;
DWORD LocalmonDebug;

DWORD LcmPortInfo1Strings[]={FIELD_OFFSET(PORT_INFO_1, pName),
                          (DWORD)-1};

DWORD LcmPortInfo2Strings[]={FIELD_OFFSET(PORT_INFO_2, pPortName),
                          FIELD_OFFSET(PORT_INFO_2, pMonitorName),
                          FIELD_OFFSET(PORT_INFO_2, pDescription),
                          (DWORD)-1};

WCHAR szPorts[]   = L"ports";
WCHAR gszPorts[]  = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Ports";
WCHAR szPortsEx[] = L"portsex"; /* Extra ports values */
WCHAR szFILE[]    = L"FILE:";
WCHAR szLcmCOM[]     = L"COM";
WCHAR szLcmLPT[]     = L"LPT";
WCHAR szIRDA[]    = L"IR";

extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];

BOOL
LocalMonInit(HANDLE hModule)
{
    LcmhInst = hModule;

    InitializeCriticalSection(&LcmSpoolerSection);

    return TRUE;
}



BOOL
LcmEnumPorts(
    HANDLE hMonitor,
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    PINIPORT pIniPort;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   LastError=0;

    LcmEnterSplSem();

    cb=0;

    pIniPort = pIniLocalMon->pIniPort;

    CheckAndAddIrdaPort(pIniLocalMon);

    while (pIniPort) {

        if ( !(pIniPort->Status & PP_FILEPORT) ) {

            cb+=GetPortSize(pIniPort, Level);
        }
        pIniPort=pIniPort->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pIniLocalMon->pIniPort;
        while (pIniPort) {

            if (!(pIniPort->Status & PP_FILEPORT)) {

                pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);

                if( !pEnd ){
                    LastError = GetLastError();
                    break;
                }

                switch (Level) {
                case 1:
                    pPorts+=sizeof(PORT_INFO_1);
                    break;
                case 2:
                    pPorts+=sizeof(PORT_INFO_2);
                    break;
                default:
                    DBGMSG(DBG_ERROR,
                           ("EnumPorts: invalid level %d", Level));
                    LastError = ERROR_INVALID_LEVEL;
                    goto Cleanup;
                }
                (*pcReturned)++;
            }
            pIniPort=pIniPort->pNext;
        }

    } else

        LastError = ERROR_INSUFFICIENT_BUFFER;

Cleanup:
   LcmLeaveSplSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;

    } else

        return TRUE;
}


BOOL
LcmxEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    return LcmEnumPorts(LcmhMonitor, pName, Level, pPorts, cbBuf, pcbNeeded, pcReturned);
}

BOOL
LcmOpenPort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    PINILOCALMON    pIniLocalMon = (PINILOCALMON)hMonitor;
    PINIPORT        pIniPort;
    BOOL            bRet = FALSE;

    LcmEnterSplSem();

    if ( IS_FILE_PORT(pName) ) {

        //
        // We will always create multiple file port
        // entries, so that the spooler can print
        // to multiple files.
        //
        DBGMSG(DBG_TRACE, ("Creating a new pIniPort for %ws\n", pName));
        pIniPort = LcmCreatePortEntry( pIniLocalMon, pName );
        if ( !pIniPort )
            goto Done;

        pIniPort->Status |= PP_FILEPORT;
        *pHandle = pIniPort;
        bRet = TRUE;
        goto Done;
    }

    pIniPort = FindPort(pIniLocalMon, pName);

    if ( !pIniPort )
        goto Done;

    //
    // For LPT ports language monitors could do reads outside Start/End doc
    // port to do bidi even when there are no jobs printing. So we do a
    // CreateFile and keep the handle open all the time.
    //
    // But for COM ports you could have multiple devices attached to a COM
    // port (ex. a printer and some other device with a switch)
    // To be able to use the other device they write a utility which will
    // do a net stop serial and then use the other device. To be able to
    // stop the serial service spooler should not have a handle to the port.
    // So we need to keep handle to COM port open only when there is a job
    // printing
    //
    //
    if ( IS_COM_PORT(pName) ) {

        bRet = TRUE;
        goto Done;
    }

    //
    // If it is not a port redirected we are done (succeed the call)
    //
    if ( ValidateDosDevicePort(pIniPort) ) {

        bRet = TRUE;

        //
        // If it isn't a true dosdevice port (ex. net use lpt1 \\<server>\printer)
        // then we need to do CreateFile and CloseHandle per job so that
        // StartDoc/EndDoc is issued properly for the remote printer
        //
        if ( (pIniPort->Status & PP_DOSDEVPORT) &&
            !(pIniPort->Status & PP_COMM_PORT) ) {

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;

            (VOID)RemoveDosDeviceDefinition(pIniPort);
        }
    }

Done:
    if ( !bRet && pIniPort && (pIniPort->Status & PP_FILEPORT) )
        DeletePortNode(pIniLocalMon, pIniPort);

    if ( bRet )
        *pHandle = pIniPort;

    LcmLeaveSplSem();
    return bRet;
}

BOOL
LcmxOpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    return LcmOpenPort(LcmhMonitor, pName, pHandle);
}

BOOL
LcmStartDocPort(
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    DWORD Error = 0;

    DBGMSG(DBG_TRACE, ("StartDocPort(%08x, %ws, %d, %d, %08x)\n",
                       hPort, pPrinterName, JobId, Level, pDocInfo));

    if (pIniPort->Status & PP_STARTDOC) {
        return TRUE;
    }

    LcmEnterSplSem();
    pIniPort->Status |= PP_STARTDOC;
    LcmLeaveSplSem();

    pIniPort->hPrinter = NULL;
    pIniPort->pPrinterName = AllocSplStr(pPrinterName);

    if (pIniPort->pPrinterName) {

        if (OpenPrinter(pPrinterName, &pIniPort->hPrinter, NULL)) {

            pIniPort->JobId = JobId;

            //
            // For COMx port we need to validates dos device now since
            // we do not do it during OpenPort
            //
            if ( IS_COM_PORT(pIniPort->pName) &&
                 !ValidateDosDevicePort(pIniPort) ) {

                goto Fail;
            }

            if ( IS_FILE_PORT(pIniPort->pName) ) {

                HANDLE hFile = INVALID_HANDLE_VALUE;

                if (pDocInfo1                 &&
                    pDocInfo1->pOutputFile    &&
                    pDocInfo1->pOutputFile[0] ){

                    hFile = CreateFile( pDocInfo1->pOutputFile,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         NULL );

                    DBGMSG(DBG_TRACE,
                           ("Print to file and the handle is %x\n", hFile));

                } else {
                    INT_PTR rc;

                    rc = DialogBoxParam( LcmhInst,
                                        MAKEINTRESOURCE( DLG_PRINTTOFILE ),
                                        NULL, PrintToFileDlg,
                                        (LPARAM)&hFile );

                    if( rc == -1 ) {

                        goto Fail;

                    } else if( rc == 0 ) {

                        Error = ERROR_PRINT_CANCELLED;
                        goto Fail;
                    }
                }

                if (hFile != INVALID_HANDLE_VALUE)
                    SetEndOfFile(hFile);

                pIniPort->hFile = hFile;
            } else if ( IS_IRDA_PORT(pIniPort->pName) ) {

                if ( !IrdaStartDocPort(pIniPort) )
                    goto Fail;
            } else if ( !(pIniPort->Status & PP_DOSDEVPORT) ) {

                //
                // For non dosdevices CreateFile on the name of the port
                //
                pIniPort->hFile = CreateFile(pIniPort->pName,
                                             GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL  |
                                             FILE_FLAG_SEQUENTIAL_SCAN,
                                             NULL);

                if ( pIniPort->hFile != INVALID_HANDLE_VALUE )
                    SetEndOfFile(pIniPort->hFile);

            } else if ( !IS_COM_PORT(pIniPort->pName) ) {

                if ( !FixupDosDeviceDefinition(pIniPort) )
                    goto Fail;
            }
        }
    } // end of if (pIniPort->pPrinterName)

    if (pIniPort->hFile == INVALID_HANDLE_VALUE)
        goto Fail;

    return TRUE;


Fail:
    SPLASSERT(pIniPort->hFile == INVALID_HANDLE_VALUE);

    LcmEnterSplSem();
    pIniPort->Status &= ~PP_STARTDOC;
    LcmLeaveSplSem();

    if (pIniPort->hPrinter) {
        ClosePrinter(pIniPort->hPrinter);
    }

    if (pIniPort->pPrinterName) {
        FreeSplStr(pIniPort->pPrinterName);
    }

    if (Error)
        SetLastError(Error);

    return FALSE;
}


BOOL
LcmWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE, ("WritePort(%08x, %08x, %d)\n", hPort, pBuffer, cbBuf));

    if ( IS_IRDA_PORT(pIniPort->pName) )
        rc = IrdaWritePort(pIniPort, pBuffer, cbBuf, pcbWritten);
    else if ( !pIniPort->hFile || pIniPort->hFile == INVALID_HANDLE_VALUE ) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    } else {

        rc = WriteFile(pIniPort->hFile, pBuffer, cbBuf, pcbWritten, NULL);
        if ( rc && *pcbWritten == 0 ) {

            SetLastError(ERROR_TIMEOUT);
            rc = FALSE;
        }
    }

    DBGMSG(DBG_TRACE, ("WritePort returns %d; %d bytes written\n", rc, *pcbWritten));

    return rc;
}


BOOL
LcmReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuf,
    LPDWORD pcbRead)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE, ("ReadPort(%08x, %08x, %d)\n", hPort, pBuffer, cbBuf));

    if ( !pIniPort->hFile                           ||
         pIniPort->hFile == INVALID_HANDLE_VALUE    ||
         !(pIniPort->Status & PP_COMM_PORT) ) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    rc = ReadFile(pIniPort->hFile, pBuffer, cbBuf, pcbRead, NULL);

    DBGMSG(DBG_TRACE, ("ReadPort returns %d; %d bytes read\n", rc, *pcbRead));

    return rc;
}

BOOL
LcmEndDocPort(
    HANDLE   hPort
    )
{
    PINIPORT    pIniPort = (PINIPORT)hPort;

    DBGMSG(DBG_TRACE, ("EndDocPort(%08x)\n", hPort));

    if (!(pIniPort->Status & PP_STARTDOC)) {
        return TRUE;
    }

    // The flush here is done to make sure any cached IO's get written
    // before the handle is closed.   This is particularly a problem
    // for Intelligent buffered serial devices

    FlushFileBuffers(pIniPort->hFile);

    //
    // For any ports other than real LPT ports we open during StartDocPort
    // and close it during EndDocPort
    //
    if ( !(pIniPort->Status & PP_COMM_PORT) || IS_COM_PORT(pIniPort->pName) ) {

        if ( IS_IRDA_PORT(pIniPort->pName) ) {

            IrdaEndDocPort(pIniPort);
        } else {

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;

            if ( pIniPort->Status & PP_DOSDEVPORT ) {

                (VOID)RemoveDosDeviceDefinition(pIniPort);
            }

            if ( IS_COM_PORT(pIniPort->pName) ) {

                pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);
                FreeSplStr(pIniPort->pDeviceName);
                pIniPort->pDeviceName = NULL;
            }
        }
    }

    SetJob(pIniPort->hPrinter, pIniPort->JobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);

    ClosePrinter(pIniPort->hPrinter);

    FreeSplStr(pIniPort->pPrinterName);

    //
    // Startdoc no longer active.
    //
    pIniPort->Status &= ~PP_STARTDOC;

    return TRUE;
}

BOOL
LcmClosePort(
    HANDLE  hPort
    )
{
    PINIPORT pIniPort = (PINIPORT)hPort;

    FreeSplStr(pIniPort->pDeviceName);
    pIniPort->pDeviceName = NULL;

    if (pIniPort->Status & PP_FILEPORT) {

        LcmEnterSplSem();
        DeletePortNode(pIniPort->pIniLocalMon, pIniPort);
        LcmLeaveSplSem();
    } else if ( pIniPort->Status & PP_COMM_PORT ) {

        (VOID) RemoveDosDeviceDefinition(pIniPort);
        if ( pIniPort->hFile != INVALID_HANDLE_VALUE ) {

            // @@BEGIN_DDKSPLIT
            if ( pIniPort->hNotify ) {

                SplUnregisterForDeviceEvents(pIniPort->hNotify);
                pIniPort->hNotify = NULL;
            }
            // @@END_DDKSPLIT

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;
        }
        pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);
    }

    return TRUE;
}


BOOL
LcmAddPortEx(
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    LPWSTR pPortName;
    DWORD  Error;
    LPPORT_INFO_1 pPortInfo1;
    LPPORT_INFO_FF pPortInfoFF;

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (LPPORT_INFO_FF)pBuffer;
        pPortName = pPortInfoFF->pName;
        break;

    case 1:
        pPortInfo1 =  (LPPORT_INFO_1)pBuffer;
        pPortName = pPortInfo1->pName;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return(FALSE);
    }
    if (!pPortName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (PortExists(pName, pPortName, &Error)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (Error != NO_ERROR) {
        SetLastError(Error);
        return(FALSE);
    }
    if (!LcmCreatePortEntry(pIniLocalMon, pPortName)) {
        return(FALSE);
    }
    if (!WriteProfileString(szPorts, pPortName, L"")) {
        LcmDeletePortEntry( pIniLocalMon, pPortName );
        return(FALSE);
    }
    return TRUE;
}

BOOL
LcmxAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    return LcmAddPortEx(LcmhMonitor, pName, Level, pBuffer, pMonitorName);
}

BOOL
LcmGetPrinterDataFromPort(
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE,
           ("GetPrinterDataFromPort(%08x, %d, %ws, %ws, %d, ",
           hPort, ControlID, pValueName, lpInBuffer, cbInBuffer));

    if ( !ControlID                                 ||
         !pIniPort->hFile                           ||
         pIniPort->hFile == INVALID_HANDLE_VALUE    ||
         !(pIniPort->Status & PP_DOSDEVPORT) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    rc = DeviceIoControl(pIniPort->hFile,
                         ControlID,
                         lpInBuffer,
                         cbInBuffer,
                         lpOutBuffer,
                         cbOutBuffer,
                         lpcbReturned,
                         NULL);

    DBGMSG(DBG_TRACE,
           ("%ws, %d, %d)\n", lpOutBuffer, cbOutBuffer, lpcbReturned));

    return rc;
}

BOOL
LcmSetPortTimeOuts(
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved)    // must be set to 0
{
    PINIPORT        pIniPort = (PINIPORT)hPort;
    COMMTIMEOUTS    cto;

    if (reserved != 0)
        return FALSE;

    if ( !(pIniPort->Status & PP_DOSDEVPORT) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( GetCommTimeouts(pIniPort->hFile, &cto) )
    {
        cto.ReadTotalTimeoutConstant = lpCTO->ReadTotalTimeoutConstant;
        cto.ReadIntervalTimeout = lpCTO->ReadIntervalTimeout;
        return SetCommTimeouts(pIniPort->hFile, &cto);
    }

    return FALSE;
}

VOID
LcmShutdown(
    HANDLE hMonitor
    )
{
    PINIPORT pIniPort;
    PINIPORT pIniPortNext;
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;

    //
    // Delete the ports, then delete the LOCALMONITOR.
    //
    for( pIniPort = pIniLocalMon->pIniPort; pIniPort; pIniPort = pIniPortNext ){
        pIniPortNext = pIniPort->pNext;
        FreeSplMem( pIniPort );
    }

    FreeSplMem( pIniLocalMon );
}


BOOL
LcmxXcvOpenPort(
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    return LcmXcvOpenPort(LcmhMonitor, pszObject, GrantedAccess, phXcv);
}

// @@BEGIN_DDKSPLIT
#ifdef _SPL_CLUST
// @@END_DDKSPLIT

MONITOR2 Monitor2 = {
    sizeof(MONITOR2),
    LcmEnumPorts,
    LcmOpenPort,
    NULL,           // OpenPortEx is not supported
    LcmStartDocPort,
    LcmWritePort,
    LcmReadPort,
    LcmEndDocPort,
    LcmClosePort,
    NULL,           // AddPort is not supported
    LcmAddPortEx,
    NULL,           // ConfigurePort is not supported
    NULL,           // DeletePort is not supported
    LcmGetPrinterDataFromPort,
    LcmSetPortTimeOuts,
    LcmXcvOpenPort,
    LcmXcvDataPort,
    LcmXcvClosePort,
    LcmShutdown
};


LPMONITOR2
LocalMonInitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
    )
{
    LPWSTR   pPortTmp;
    DWORD    dwCharCount=1024, rc, i, j;
    PINILOCALMON pIniLocalMon = NULL;
    LPWSTR   pPorts = NULL;

    // @@BEGIN_DDKSPLIT
    //
    // If we are clustered (e.g., bLocal is FALSE), then we don't want to
    // initialize, since local ports can't be used with clustering.
    //
    // @@END_DDKSPLIT
    if( !pMonitorInit->bLocal ){
        return NULL;
    }

    do {
        FreeSplMem((LPVOID)pPorts);

        dwCharCount *= 2;
        pPorts = (LPWSTR) AllocSplMem(dwCharCount*sizeof(WCHAR));
        if ( !pPorts ) {

            DBGMSG(DBG_ERROR,
                   ("Failed to alloc %d characters for ports\n", dwCharCount));
            goto Fail;
        }

        rc = GetProfileString(szPorts, NULL, szNULL, pPorts, dwCharCount);
        if ( !rc || dwCharCount >= 1024*1024 ) { // Work around in GetProfileString bug

            DBGMSG(DBG_ERROR,
                   ("GetProfilesString failed with %d\n", GetLastError()));
            goto Fail;
        }

    } while ( rc >= dwCharCount - 2 );

    pIniLocalMon = (PINILOCALMON)AllocSplMem( sizeof( INILOCALMON ));

    if( !pIniLocalMon ){
        goto Fail;
    }

    pIniLocalMon->signature = ILM_SIGNATURE;
    pIniLocalMon->pMonitorInit = pMonitorInit;

    //
    // dwCharCount is now the count of return buffer, not including
    // the NULL terminator.  When we are past pPorts[rc], then
    // we have parsed the entire string.
    //
    dwCharCount = rc;

   LcmEnterSplSem();

    //
    // We now have all the ports
    //
    for( j = 0; j <= dwCharCount; j += rc + 1 ){

        pPortTmp = pPorts + j;

        rc = wcslen(pPortTmp);

        if( !rc ){
            continue;
        }

        if (!_wcsnicmp(pPortTmp, L"Ne", 2)) {

            i = 2;
            //
            // For Ne-ports
            //
            if ( rc > 2 && pPortTmp[2] == L'-' )
                ++i;
            for ( ; i < rc - 1 && iswdigit(pPortTmp[i]) ; ++i )
            ;

            if ( i == rc - 1 && pPortTmp[rc-1] == L':' ) {
                continue;
            }
        }

        LcmCreatePortEntry(pIniLocalMon, pPortTmp);
    }

    FreeSplMem(pPorts);

    LcmLeaveSplSem();

    CheckAndAddIrdaPort(pIniLocalMon);

    *phMonitor = (HANDLE)pIniLocalMon;

    return &Monitor2;

Fail:

    FreeSplMem( pPorts );
    FreeSplMem( pIniLocalMon );

    return NULL;
}

// @@BEGIN_DDKSPLIT
#endif

MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        LcmxEnumPorts,
        LcmxOpenPort,
        NULL,
        LcmStartDocPort,
        LcmWritePort,
        LcmReadPort,
        LcmEndDocPort,
        LcmClosePort,
        NULL,                           // AddPort not supported
        LcmxAddPortEx,
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        LcmGetPrinterDataFromPort,
        LcmSetPortTimeOuts,              // SetPortTimeOuts not supported
        LcmxXcvOpenPort,
        LcmXcvDataPort,
        LcmXcvClosePort
    }
};

DWORD
GetPortStrings(
    PWSTR   *ppPorts,
    PDWORD  pdwUsed
    )
{
    DWORD   sRetval  = ERROR_INVALID_PARAMETER;
    HKEY    hPortKey = NULL;

    if (ppPorts && pdwUsed)
    {
        sRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, gszPorts, 0, KEY_READ, &hPortKey);

        if (sRetval == ERROR_SUCCESS)
        {
            DWORD dwcValues = 0;
            DWORD dwMaxValueName = 0;

            sRetval = RegQueryInfoKey(hPortKey, NULL, NULL, NULL, NULL, NULL, NULL, &dwcValues, &dwMaxValueName, NULL, NULL, NULL);

            if (sRetval == ERROR_SUCCESS)
            {
                PWSTR pPorts = NULL;
                DWORD cbMaxMemNeeded = ((dwcValues * (dwMaxValueName + 1) + 1) * sizeof(WCHAR));

                pPorts = (LPWSTR)AllocSplMem(cbMaxMemNeeded);

                if (pPorts)
                {
                    DWORD sTempRetval = ERROR_SUCCESS;
                    INT   CharsAvail = cbMaxMemNeeded/sizeof(WCHAR);
                    INT   cIndex = 0;
                    PWSTR pPort = NULL;
                    DWORD dwCurLen = 0;


                    for (pPort = pPorts; (sTempRetval == ERROR_SUCCESS) && (CharsAvail > 0); cIndex++)
                    {
                        if (dwCurLen)
                        {
                            dwCurLen++;
                            CharsAvail -= dwCurLen;
                            pPort += dwCurLen;
                        }

                        dwCurLen = CharsAvail;
                        sTempRetval = RegEnumValue(hPortKey, cIndex, pPort, &dwCurLen, NULL, NULL, NULL, NULL);
                    }

                    if ((sTempRetval == ERROR_NO_MORE_ITEMS) && (CharsAvail > 0))
                    {
                        *pPort = L'\0';
                        *ppPorts = pPorts;
                        CharsAvail--;
                        *pdwUsed = (cbMaxMemNeeded / sizeof(WCHAR)) - CharsAvail;
                    }
                    else
                    {
                        sRetval = sTempRetval;

                        if (sRetval == ERROR_SUCCESS)
                        {
                            sRetval = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }
                else
                {
                    sRetval = GetLastError();
                }
            }

            RegCloseKey(hPortKey);
        }
    }

    return sRetval;
}


LPMONITOREX
WINAPI
InitializePrintMonitor(
    IN     LPTSTR      pszRegistryRoot
)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    Pointer to monitor function table

--*/
{
    LPWSTR   pPortTmp;
    DWORD    dwCharCount=0, rc, i;
    DWORD    sRetval = ERROR_SUCCESS;
    PINILOCALMON pIniLocalMon = NULL;
    LPWSTR   pPorts = NULL;

    if ( !pszRegistryRoot || !*pszRegistryRoot ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (sRetval = GetPortStrings(&pPorts, &dwCharCount) != ERROR_SUCCESS)
    {
        SetLastError(sRetval);
        goto Fail;
    }

    pIniLocalMon = (PINILOCALMON)AllocSplMem( sizeof( INILOCALMON ));

    if( !pIniLocalMon ){
        goto Fail;
    }

    pIniLocalMon->signature = ILM_SIGNATURE;


   LcmEnterSplSem();

    //
    // We now have all the ports
    //
    for(pPortTmp = pPorts; pPortTmp && *pPortTmp; pPortTmp += rc + 1){

        rc = wcslen(pPortTmp);

        if (!_wcsnicmp(pPortTmp, L"Ne", 2)) {

            i = 2;

            //
            // For Ne- ports
            //
            if ( rc > 2 && pPortTmp[2] == L'-' )
                ++i;
            for ( ; i < rc - 1 && iswdigit(pPortTmp[i]) ; ++i )
            ;

            if ( i == rc - 1 && pPortTmp[rc-1] == L':' ) {
                continue;
            }
        }

        LcmCreatePortEntry(pIniLocalMon, pPortTmp);
    }

    FreeSplMem(pPorts);

    LcmLeaveSplSem();

    CheckAndAddIrdaPort(pIniLocalMon);

    LcmhMonitor = (HANDLE)pIniLocalMon;

    return &MonitorEx;

Fail:

    FreeSplMem( pPorts );
    FreeSplMem( pIniLocalMon );

    return NULL;

}

#if 0

//
// Since the DDK is a standalone DLL, we need a DLL init routine.
// However, the NT version is a library and we call LocamonInit
// directly, so this isn't needed.
//

// @@END_DDKSPLIT

VOID
LocalMonCleanUp(
    VOID
    )
{
    DeleteCriticalSection(&LcmSpoolerSection);
}

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        LocalMonInit(hModule);
        DisableThreadLibraryCalls(hModule);
        return TRUE;

    case DLL_PROCESS_DETACH:

        LocalMonCleanUp();
        return TRUE;
    }

    UNREFERENCED_PARAMETER(lpRes);

    return TRUE;
}

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localmon.rc
//
#define IDS_LOCALMONITOR               500
#define IDS_COULD_NOT_OPEN_FILE        504
#define IDS_UNKNOWN_ERROR              505
#define IDS_OVERWRITE_EXISTING_FILE    506
#define IDS_LOCALMONITORNAME           507
#define DLG_PRINTTOFILE                600
#define IDD_PF_EF_OUTPUTFILENAME       601
#define IDD_PF_PB_HELP                 602

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        603
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           603
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\precomp.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

// @@BEGIN_DDKSPLIT
Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

// @@BEGIN_DDKSPLIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// @@END_DDKSPLIT

                      
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock2.h>
#include <wchar.h>
#include <stddef.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "resource.h"
#include "spltypes.h"
#include "localmon.h"

// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT

#undef DBGMSG
#define DBGMSG(x,y)
#undef SPLASSERT
#define SPLASSERT(x) 

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\irda.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation
All rights reserved.

Module Name:

    irda.h

Abstract:

    Definitions used for IRDA printing

// @@BEGIN_DDKSPLIT
Author:

    Muhunthan Sivapragasam (MuhuntS)  27-Oct-97

Revision History:
// @@END_DDKSPLIT
--*/

VOID
CheckAndAddIrdaPort(
    PINILOCALMON    pIniLocalMon
    );

VOID
CheckAndDeleteIrdaPort(
    PINILOCALMON    pIniLocalMon
    );

BOOL
IrdaStartDocPort(
    IN OUT  PINIPORT    pIniPort
    );

BOOL
IrdaWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuf,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
    );

VOID
IrdaEndDocPort(
    PINIPORT    pIniPort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\localmon.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    localmon.h

// @@BEGIN_DDKSPLIT
Abstract:

Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT


LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)
#define COUNTOF(x)                (sizeof(x)/sizeof *(x))


/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the LcmDBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with LcmDBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     LcmDBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define LcmDBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define LcmDBGMSG
#endif
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

VOID
CompleteRead(
    DWORD Error,
    DWORD ByteCount,
    LPOVERLAPPED pOverlapped
);

BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
);

BOOL
PortIsValid(
    LPWSTR pPortName
);

extern HANDLE   LcmhInst;
extern CRITICAL_SECTION    LcmSpoolerSection;
extern DWORD    LcmPortInfo1Strings[];
extern DWORD    LcmPortInfo2Strings[];
extern PINIPORT pIniFirstPort;
extern PINIXCVPORT pIniFirstXcvPort;

extern WCHAR szNULL[];
extern WCHAR szPorts[];
extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];
extern WCHAR szLcmDeviceNameHeader[];
extern WCHAR szFILE[];
extern WCHAR szLcmCOM[];
extern WCHAR szLcmLPT[];
extern WCHAR szIRDA[];

#define MSG_ERROR           MB_OK | MB_ICONSTOP
#define MSG_WARNING         MB_OK | MB_ICONEXCLAMATION
#define MSG_YESNO           MB_YESNO | MB_ICONQUESTION
#define MSG_INFORMATION     MB_OK | MB_ICONINFORMATION
#define MSG_CONFIRMATION    MB_OKCANCEL | MB_ICONEXCLAMATION

#define TIMEOUT_MIN         1
#define TIMEOUT_MAX         999999
#define TIMEOUT_STRING_MAX  6

#define WITHINRANGE( val, lo, hi ) \
    ( ( val <= hi ) && ( val >= lo ) )


#define IS_FILE_PORT(pName) \
    !_wcsicmp( pName, szFILE )

#define IS_IRDA_PORT(pName) \
    !_wcsicmp( pName, szIRDA )

#define IS_COM_PORT(pName) \
    IsCOMPort( pName )

#define IS_LPT_PORT(pName) \
    IsLPTPort( pName )

BOOL
IsCOMPort(
    LPWSTR pPort
);

BOOL
IsLPTPort(
    LPWSTR pPort
);


INT_PTR APIENTRY
PrintToFileDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
);

VOID
LcmEnterSplSem(
   VOID
);

VOID
LcmLeaveSplSem(
   VOID
);

VOID
LcmSplOutSem(
   VOID
);

PINIENTRY
LcmFindName(
   PINIENTRY pIniKey,
   LPWSTR pName
);

PINIENTRY
LcmFindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR lpName
);

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
);

INT
LcmMessage(
    HWND hwnd,
    DWORD Type,
    INT CaptionID,
    INT TextID,
    ...
);

DWORD
ReportError(
    HWND  hwndParent,
    DWORD idTitle,
    DWORD idDefaultError
);

VOID
LcmRemoveColon(
    LPWSTR  pName
);


PINIPORT
LcmCreatePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
);

BOOL
LcmDeletePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
);


PINIXCVPORT
CreateXcvPortEntry(
    PINILOCALMON pIniLocalMon,
    LPCWSTR pszName,
    ACCESS_MASK GrantedAccess
);

BOOL
DeleteXcvPortEntry(
    PINIXCVPORT  pIniXcvPort
);


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
);

BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    );

BOOL
MakeLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR *ppOldNtDeviceName,
    LPWSTR  pNewNtDeviceName,
    SECURITY_DESCRIPTOR *pSecurityDescriptor
);

BOOL
RemoveLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR  *ppOldNtDeviceName
);


DWORD
ConfigureLPTPortCommandOK(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);



DWORD
GetPortSize(
    PINIPORT pIniPort,
    DWORD   Level
);

LPBYTE
CopyIniPortToPort(
    PINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
);

BOOL
ValidateDosDevicePort(
    PINIPORT    pIniPort
    );

BOOL
RemoveDosDeviceDefinition(
    PINIPORT    pIniPort
    );

BOOL
DeletePortNode(
    PINILOCALMON pIniLocalMon,
    PINIPORT  pIniPort
    );

BOOL
FixupDosDeviceDefinition(
    PINIPORT    pIniPort
    );

DWORD
LcmXcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

BOOL
LcmXcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

BOOL
LcmXcvClosePort(
    HANDLE  hXcv
    );

DWORD
WINAPIV
StrNCatBuffW(
    IN      PWSTR       pszBuffer,
    IN      UINT        cchBuffer,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:



Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT


LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)


/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define LcmDBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define LcmDBGMSG
#endif

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\setlink.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    setlink.c

Abstract:

    Utility to display or change the value of a symbolic link.

// @@BEGIN_DDKSPLIT
Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


BOOL
MakeLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR *ppOldNtDeviceName,
    LPWSTR  pNewNtDeviceName,
    SECURITY_DESCRIPTOR *pSecurityDescriptor
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING OldDosDeviceName;
    UNICODE_STRING NewDosDeviceName;
    UNICODE_STRING PreviousNtDeviceName;
    UNICODE_STRING NewNtDeviceName;
    HANDLE  Handle, Handle1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR   Buffer[MAX_PATH];

    RtlInitUnicodeString( &OldDosDeviceName, pOldDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &OldDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );
    
    // Try to open \DosDevices\LPT1
 
    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_WARNING, ("Symbolic link %ws does not exist\n", pOldDosDeviceName ));
        return FALSE;

    }

    memset(Buffer, 0, sizeof(Buffer));

    PreviousNtDeviceName.Length = 0;
    PreviousNtDeviceName.MaximumLength = sizeof( Buffer );
    PreviousNtDeviceName.Buffer = Buffer;

    // Get \Device\Parallel0 into Buffer

    Status = NtQuerySymbolicLinkObject( Handle,
                                        &PreviousNtDeviceName,
                                        NULL );

    if (!NT_SUCCESS( Status )) {
        SetLastError(Status);
        NtClose(Handle);
        return FALSE;
    }

    *ppOldNtDeviceName = AllocSplStr(Buffer);

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    ObjectAttributes.Attributes |= OBJ_PERMANENT;
    RtlInitUnicodeString( &NewNtDeviceName, pNewNtDeviceName );

    // Make \DosDevices\LPT1 point to \Device\NamedPipe\Spooler\LPT1

    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &NewNtDeviceName );

    if (!NT_SUCCESS( Status )) {
        DBGMSG( DBG_WARNING, ("Error creating symbolic link %ws => %ws\n",
                 pOldDosDeviceName,
                 pNewNtDeviceName ));
        DBGMSG( DBG_WARNING, ("Error status was:  %X\n", Status ));
        return FALSE;
    } else {
        NtClose( Handle );
    }

    RtlInitUnicodeString( &NewDosDeviceName, pNewDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &NewDosDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                (HANDLE) NULL,
                                pSecurityDescriptor );

    // Finally make \DosDevices\NONSPOOLED_LPT1 => \Device\Parallel0

    Status = NtCreateSymbolicLinkObject(&Handle,
                                        SYMBOLIC_LINK_ALL_ACCESS,
                                        &ObjectAttributes,
                                        &PreviousNtDeviceName);

    if (NT_SUCCESS(Status))
        NtClose(Handle);

    return TRUE;
}

BOOL
RemoveLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR  *ppOldNtDeviceName
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING OldDosDeviceName;
    UNICODE_STRING NewDosDeviceName;
    UNICODE_STRING PreviousNtDeviceName;
    UNICODE_STRING OldNtDeviceName;
    HANDLE  Handle, Handle1;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString( &NewDosDeviceName, pNewDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &NewDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    // Try to open \DosDevices\NONSPOOLED_LPT1

    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_ERROR, ("Symbolic link %ws does not exist\n", pNewDosDeviceName ));
        return FALSE;

    }

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    RtlInitUnicodeString( &OldDosDeviceName, pOldDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &OldDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    // Try to open \DosDevices\LPT1

    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_ERROR, ("Symbolic link %ws does not exist\n", pOldDosDeviceName ));
        return FALSE;
    }

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    ObjectAttributes.Attributes |= OBJ_PERMANENT;

    RtlInitUnicodeString( &OldNtDeviceName, *ppOldNtDeviceName );

    // Make \DosDevices\LPT1 point to \Device\Parallel0

    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &OldNtDeviceName );

    if (!NT_SUCCESS( Status )) {
        DBGMSG( DBG_WARNING, ("Error creating symbolic link %ws => %ws\n",
                 pOldDosDeviceName,
                 *ppOldNtDeviceName ));
        DBGMSG( DBG_WARNING, ("Error status was:  %X\n", Status ));
    } else {
        NtClose( Handle );
    }

    FreeSplStr(*ppOldNtDeviceName);

    *ppOldNtDeviceName = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\dialogs.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.h

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

//
// Use the window word of the entry field to store last valid entry
//
#define SET_LAST_VALID_ENTRY( hwnd, id, val ) \
    SetWindowLongPtr( GetDlgItem( hwnd, id ), GWLP_USERDATA, (LONG_PTR)val )
#define GET_LAST_VALID_ENTRY( hwnd, id ) \
    GetWindowLongPtr( GetDlgItem( hwnd, id ), GWLP_USERDATA )

BOOL
PortNameInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
    );

BOOL
PortNameCommandOK(
    HWND    hwnd
    );

BOOL
PortNameCommandCancel(
    HWND hwnd
    );

BOOL
ConfigureLPTPortInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
    );

BOOL
ConfigureLPTPortCommandOK(
    HWND    hwnd
    );

BOOL
ConfigureLPTPortCommandCancel(
    HWND hwnd
    );

BOOL
ConfigureLPTPortCommandTransmissionRetryUpdate(
    HWND hwnd,
    WORD CtlId
    );

BOOL
LocalUIHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    );

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\dialogs.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"
#include "dialogs.h"

WCHAR szINIKey_TransmissionRetryTimeout[] = L"TransmissionRetryTimeout";
WCHAR szHelpFile[] = L"WINDOWS.HLP";

#define MAX_LOCAL_PORTNAME  246

const DWORD g_aHelpIDs[]=
{
    IDD_PN_EF_PORTNAME,             8805136, // Port Name: "" (Edit)
    IDD_CL_EF_TRANSMISSIONRETRY,    8807704, // Configure LPT Port: "" (Edit)
    0, 0
};


INT_PTR APIENTRY
ConfigureLPTPortDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return ConfigureLPTPortInitDialog(hwnd, (PPORTDIALOG) lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return ConfigureLPTPortCommandOK(hwnd);

        case IDCANCEL:
            return ConfigureLPTPortCommandCancel(hwnd);

        case IDD_CL_EF_TRANSMISSIONRETRY:
            if( HIWORD(wparam) == EN_UPDATE )
                ConfigureLPTPortCommandTransmissionRetryUpdate(hwnd, LOWORD(wparam));
            break;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return LocalUIHelp(hwnd, msg, wparam, lparam);
        break;
    }

    return FALSE;
}


/*
 *
 */
BOOL
ConfigureLPTPortInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
)
{
    DWORD dwTransmissionRetryTimeout;
    DWORD cbNeeded;
    DWORD dwDummy;
    BOOL  rc;
    DWORD dwStatus;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pPort);

    SetForegroundWindow(hwnd);

    SendDlgItemMessage( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                        EM_LIMITTEXT, TIMEOUT_STRING_MAX, 0 );


    // Get the Transmission Retry Timeout from the host
    rc = XcvData(   pPort->hXcv,
                    L"GetTransmissionRetryTimeout",
                    (PBYTE) &dwDummy,
                    0,
                    (PBYTE) &dwTransmissionRetryTimeout,
                    sizeof dwTransmissionRetryTimeout,
                    &cbNeeded,
                    &dwStatus);
    if(!rc) {
        DBGMSG(DBG_WARNING, ("Error %d checking TransmissionRetryTimeout\n", GetLastError()));

    } else if(dwStatus != ERROR_SUCCESS) {
        DBGMSG(DBG_WARNING, ("Error %d checking TransmissionRetryTimeout\n", dwStatus));
        SetLastError(dwStatus);
        rc = FALSE;

    } else {

        SetDlgItemInt( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                       dwTransmissionRetryTimeout, FALSE );

        SET_LAST_VALID_ENTRY( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                              dwTransmissionRetryTimeout );

    }

    return rc;
}


/*
 *
 */
BOOL
ConfigureLPTPortCommandOK(
    HWND hwnd
)
{
    WCHAR String[TIMEOUT_STRING_MAX+1];
    UINT  TransmissionRetryTimeout;
    BOOL  b;
    DWORD cbNeeded;
    PPORTDIALOG pPort;
    DWORD dwStatus;

    if ((pPort = (PPORTDIALOG) GetWindowLongPtr(hwnd, GWLP_USERDATA)) == NULL)
    {
        dwStatus = ERROR_INVALID_DATA;
        ErrorMessage (hwnd, dwStatus);
        SetLastError (dwStatus);
        return FALSE;
    }

    TransmissionRetryTimeout = GetDlgItemInt( hwnd,
                                              IDD_CL_EF_TRANSMISSIONRETRY,
                                              &b,
                                              FALSE );

    wsprintf(String, L"%d", TransmissionRetryTimeout);

    b = XcvData(pPort->hXcv,
                L"ConfigureLPTPortCommandOK",
                (PBYTE) String,
                (wcslen(String) + 1)*sizeof(WCHAR),
                (PBYTE) &cbNeeded,
                0,
                &cbNeeded,
                &dwStatus);

    EndDialog(hwnd, b ? dwStatus : GetLastError());

    return TRUE;
}



/*
 *
 */
BOOL
ConfigureLPTPortCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, ERROR_CANCELLED);
    return TRUE;
}


/*
 *
 */
BOOL
ConfigureLPTPortCommandTransmissionRetryUpdate(
    HWND hwnd,
    WORD CtlId
)
{
    int  Value;
    BOOL OK;

    Value = GetDlgItemInt( hwnd, CtlId, &OK, FALSE );

    if( WITHINRANGE( Value, TIMEOUT_MIN, TIMEOUT_MAX ) )
    {
        SET_LAST_VALID_ENTRY( hwnd, CtlId, Value );
    }

    else
    {
        SetDlgItemInt( hwnd, CtlId, (UINT) GET_LAST_VALID_ENTRY( hwnd, CtlId ), FALSE );
        SendDlgItemMessage( hwnd, CtlId, EM_SETSEL, 0, (LPARAM)-1 );
    }

    return TRUE;
}


/*
 *
 */
BOOL APIENTRY
PortNameDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return PortNameInitDialog(hwnd, (PPORTDIALOG)lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return PortNameCommandOK(hwnd);

        case IDCANCEL:
            return PortNameCommandCancel(hwnd);
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return LocalUIHelp(hwnd, msg, wparam, lparam);
    }

    return FALSE;
}


/*
 *
 */
BOOL
PortNameInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
)
{
    SetForegroundWindow(hwnd);

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pPort);
    // Number used to check port length in LocalMon (247)
    SendDlgItemMessage (hwnd, IDD_PN_EF_PORTNAME, EM_LIMITTEXT, MAX_LOCAL_PORTNAME, 0);

    return TRUE;
}


/*
 *
 */
BOOL
PortNameCommandOK(
    HWND    hwnd
)
{
    PPORTDIALOG pPort;
    WCHAR   string[MAX_PATH + 1];
    BOOL    rc;
    DWORD   cbNeeded;
    DWORD   dwStatus;

    if ((pPort = (PPORTDIALOG) GetWindowLongPtr( hwnd, GWLP_USERDATA )) == NULL)
    {
        dwStatus = ERROR_INVALID_DATA;
        ErrorMessage (hwnd, dwStatus);
        SetLastError (dwStatus);
        return FALSE;
    }

    GetDlgItemText( hwnd, IDD_PN_EF_PORTNAME, string, (MAX_LOCAL_PORTNAME+1) );

    rc = XcvData(   pPort->hXcv,
                    L"PortIsValid",
                    (PBYTE) string,
                    (wcslen(string) + 1)*sizeof *string,
                    (PBYTE) NULL,
                    0,
                    &cbNeeded,
                    &dwStatus);

    if (!rc) {
        return FALSE;

    } else if (dwStatus != ERROR_SUCCESS) {
        SetLastError(dwStatus);

        if (dwStatus == ERROR_INVALID_NAME)
            Message( hwnd, MSG_ERROR, IDS_LOCALMONITOR, IDS_INVALIDPORTNAME_S, string );
        else
            ErrorMessage(hwnd, dwStatus);

        return FALSE;

    } else {
        pPort->pszPortName = AllocSplStr( string );
        EndDialog( hwnd, ERROR_SUCCESS );
        return TRUE;
    }

}



/*
 *
 */
BOOL
PortNameCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, ERROR_CANCELLED);
    return TRUE;
}


/*++

Routine Name:

    LocalUIHelp

Routine Description:

    Handles context sensitive help for the configure LPTX:
    port and the dialog for adding a local port.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if message handled, otherwise FALSE.

--*/

BOOL
LocalUIHelp(
    IN HWND        hDlg,
    IN UINT        uMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                           szHelpFile,
                           HELP_WM_HELP,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp((HWND)wParam,
                           szHelpFile,
                           HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\local.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation
All rights reserved

Module Name:

    local.h
    
// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#ifndef _LOCAL_H_
#define _LOCAL_H_


LPWSTR AllocSplStr(LPCWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        ((pMem) ? (GlobalFree(pMem) ? FALSE:TRUE):TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

#define COUNTOF(x) (sizeof(x)/sizeof *(x))

//
// DEBUGGING:
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */

#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */

#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( L"Failed: %s\nLine %d, %ws\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define SPLASSERT(expr)
#endif


#endif // _LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\winspool.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    winspool.c

Abstract:

    Implements the spooler supported apis for printing.

// @@BEGIN_DDKSPLIT
Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

WCHAR   szNULL[] = L"";
WCHAR   szLcmDeviceNameHeader[] = L"\\Device\\NamedPipe\\Spooler\\";
WCHAR   szWindows[] = L"windows";
WCHAR   szINIKey_TransmissionRetryTimeout[] = L"TransmissionRetryTimeout";


//
// Timeouts for serial printing
//
#define WRITE_TOTAL_TIMEOUT     3000    // 3 seconds
#define READ_TOTAL_TIMEOUT      5000    // 5 seconds
#define READ_INTERVAL_TIMEOUT   200     // 0.2 second


BOOL
DeletePortNode(
    PINILOCALMON pIniLocalMon,
    PINIPORT  pIniPort
    )
{
    PINIPORT    pPort, pPrevPort;

    for( pPort = pIniLocalMon->pIniPort;
         pPort && pPort != pIniPort;
         pPort = pPort->pNext){

        pPrevPort = pPort;
    }

    if (pPort) {    // found the port
        if (pPort == pIniLocalMon->pIniPort) {
            pIniLocalMon->pIniPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplMem(pPort);

        return TRUE;
    }
    else            // port not found
        return FALSE;
}


BOOL
RemoveDosDeviceDefinition(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Removes the NONSPOOLED.. dos device definition created by localmon

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on success, FALSE on error

--*/
{
    WCHAR   TempDosDeviceName[MAX_PATH];

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"NONSPOOLED_", pIniPort->pName, NULL ))
        return FALSE;

    LcmRemoveColon(TempDosDeviceName);

    return DefineDosDevice(DDD_REMOVE_DEFINITION, TempDosDeviceName, NULL);
}

// @@BEGIN_DDKSPLIT
DWORD
HandleLptQueryRemove(
    LPVOID  pData
    )
{
    DWORD       dwRet = NO_ERROR;
    PINIPORT    pIniPort = (PINIPORT)pData;

    SPLASSERT(pIniPort && pIniPort->signature == IPO_SIGNATURE
                       && pIniPort->hNotify != NULL );

    LcmEnterSplSem();
    //
    // Fix is not multi-thread safe now
    //
    if ( pIniPort->Status & PP_STARTDOC ) {

        dwRet = ERROR_BUSY;
        goto Done;
    }

    // InitializeCriticalSection(pIniPort->&CritSection);
    CloseHandle(pIniPort->hFile);
    SplUnregisterForDeviceEvents(pIniPort->hNotify);
    pIniPort->hNotify   = NULL;
    pIniPort->hFile     = INVALID_HANDLE_VALUE;

Done:
    LcmLeaveSplSem();
    return dwRet;
}
// @@END_DDKSPLIT

BOOL
ValidateDosDevicePort(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Checks if the given port corresponds to a dos device.
    For a dos device port the following is done:
        -- Dos device definition for the NONSPOOLED.. is created
        -- CreateFile is done on the NONSPOOLED.. port

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on all validations passing, FALSE otherwise

    Side effect:
        For dos devices :
        a. CreateFile is called on the NONSPOOLED.. name
        b. PP_DOSDEVPORT flag is set
        c. pIniPort->pDeviceName is set to the first string found on
           QueryDosDefition this could be used to see if the definition changed
           (ex. when user did a net use lpt1 \\server\printer the connection
                is effective only when the user is logged in)
        d. PP_COMM_PORT is set for real LPT/COM port
           (ie. GetCommTimeouts worked, not a net use lpt1 case)

--*/
{
    DCB             dcb;
    COMMTIMEOUTS    cto;
    WCHAR           TempDosDeviceName[MAX_PATH];
    HANDLE          hToken = NULL;
    WCHAR           DeviceNames[MAX_PATH];
    WCHAR           DosDeviceName[MAX_PATH];
    WCHAR           NewNtDeviceName[MAX_PATH];
    WCHAR          *pDeviceNames=DeviceNames;
    BOOL            bRet = FALSE;
    LPWSTR          pDeviceName = NULL;

    hToken = RevertToPrinterSelf();
    if (!hToken)
       goto Done;

    if( ERROR_SUCCESS != StrNCatBuffW( DosDeviceName, COUNTOF(DosDeviceName),
                                       pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(DosDeviceName);

    //
    // If the port is not a dos device port nothing to do -- return success
    //
    if ( !QueryDosDevice(DosDeviceName, DeviceNames, sizeof(DeviceNames)) ) {

        bRet = TRUE;
        goto Done;
    }

    pDeviceName = AllocSplStr(pDeviceNames);
    if ( !pDeviceName )
        goto Done;

    if( ERROR_SUCCESS != StrNCatBuffW( NewNtDeviceName, COUNTOF(NewNtDeviceName),
                                       szLcmDeviceNameHeader, pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(NewNtDeviceName);


    //
    // The if clause has been replaced by a while clause in order to prevent an
    // infinite loop while printing.
    // Additional bound checks should be implemented. Ram 1\16
    //

    while ( lstrcmpi(pDeviceNames, NewNtDeviceName) == 0 ) {

        pDeviceNames+=wcslen(pDeviceNames)+1;
    }

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"NONSPOOLED_", pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(TempDosDeviceName);

    //
    // Delete any existing definition for TempDosDeviceName. This ensures that
    // there exists only one definition for the nonspooled_port device name.
    // @@BEGIN_DDKSPLIT
    // Ram 1\16
    //
    // @@END_DDKSPLIT

    DefineDosDevice(DDD_REMOVE_DEFINITION, TempDosDeviceName, NULL);
    DefineDosDevice(DDD_RAW_TARGET_PATH, TempDosDeviceName, pDeviceNames);

    ImpersonatePrinterClient(hToken);
    hToken = NULL;

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"\\\\.\\NONSPOOLED_", pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(TempDosDeviceName);

    pIniPort->hFile = CreateFile(TempDosDeviceName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL |
                                 FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);

    //
    // If CreateFile fails remove redirection and fail the call
    //
    if ( pIniPort->hFile == INVALID_HANDLE_VALUE ) {

        (VOID)RemoveDosDeviceDefinition(pIniPort);
        goto Done;
    }

    pIniPort->Status |= PP_DOSDEVPORT;

    SetEndOfFile(pIniPort->hFile);

    if ( IS_COM_PORT (pIniPort->pName) ) {

        if ( GetCommState(pIniPort->hFile, &dcb) ) {

            GetCommTimeouts(pIniPort->hFile, &cto);
            GetIniCommValues (pIniPort->pName, &dcb, &cto);
            SetCommState (pIniPort->hFile, &dcb);
            cto.WriteTotalTimeoutConstant   = WRITE_TOTAL_TIMEOUT;
            cto.WriteTotalTimeoutMultiplier = 0;
            cto.ReadTotalTimeoutConstant    = READ_TOTAL_TIMEOUT;
            cto.ReadIntervalTimeout         = READ_INTERVAL_TIMEOUT;
            SetCommTimeouts(pIniPort->hFile, &cto);

            pIniPort->Status |= PP_COMM_PORT;
        } else {

            DBGMSG(DBG_WARNING,
                   ("ERROR: Failed GetCommState pIniPort->hFile %x\n",pIniPort->hFile) );
        }
    } else if ( IS_LPT_PORT (pIniPort->pName) ) {

        if ( GetCommTimeouts(pIniPort->hFile, &cto) ) {

            cto.WriteTotalTimeoutConstant =
                            GetProfileInt(szWindows,
                                          szINIKey_TransmissionRetryTimeout,
                                          45 );
            cto.WriteTotalTimeoutConstant*=1000;
            SetCommTimeouts(pIniPort->hFile, &cto);

            // @@BEGIN_DDKSPLIT
            hToken = RevertToPrinterSelf();
            pIniPort->hNotify = SplRegisterForDeviceEvents(
                                    pIniPort->hFile,
                                    (LPVOID)pIniPort,
                                    HandleLptQueryRemove);
            ImpersonatePrinterClient(hToken);
            hToken = NULL;
            // @@END_DDKSPLIT

            pIniPort->Status |= PP_COMM_PORT;
        } else {

            DBGMSG(DBG_WARNING,
                   ("ERROR: Failed GetCommTimeouts pIniPort->hFile %x\n",pIniPort->hFile) );
        }
    }

    FreeSplStr( pIniPort->pDeviceName );

    pIniPort->pDeviceName = pDeviceName;
    bRet = TRUE;

Done:
    if (hToken)
        ImpersonatePrinterClient(hToken);

    if ( !bRet && pDeviceName )
        FreeSplStr(pDeviceName);

    return bRet;
}


BOOL
FixupDosDeviceDefinition(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Called before every StartDocPort for a DOSDEVPORT. The routine will check if
    the dos device defintion has changed (if a user logged and his connection
    is remembered). Also for a connection case the CreateFile is called since
    that needs to be done per job

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on all validations passing, FALSE otherwise

--*/
{
    WCHAR       DeviceNames[MAX_PATH];
    WCHAR       DosDeviceName[MAX_PATH];
    HANDLE      hToken; 

    //
    // If the port is not a real LPT port we open it per job
    // @@BEGIN_DDKSPLIT
    // Also parallel ports could be closed on QUERYREMOVE if user undocks
    // then it will be opened on next job's StartDocPort
    // @@END_DDKSPLIT
    //

    if ( !(pIniPort->Status & PP_COMM_PORT) ||
         pIniPort->hFile == INVALID_HANDLE_VALUE )
        return ValidateDosDevicePort(pIniPort);

    if( ERROR_SUCCESS != StrNCatBuffW( DosDeviceName, COUNTOF(DosDeviceName),
                                       pIniPort->pName, NULL ))
        return FALSE;

    LcmRemoveColon(DosDeviceName);

    hToken = RevertToPrinterSelf();

    if (!hToken) {
        return FALSE;
    }
    
    if ( !QueryDosDevice(DosDeviceName, DeviceNames, sizeof(DeviceNames)) ) {

        ImpersonatePrinterClient(hToken);
        return FALSE;
    }

    //
    // If strings are same then definition has not changed
    //
    if ( !lstrcmpi(DeviceNames, pIniPort->pDeviceName) )
    {
        ImpersonatePrinterClient(hToken);
        return TRUE;
    }

    (VOID)RemoveDosDeviceDefinition(pIniPort);

    CloseHandle(pIniPort->hFile);
    pIniPort->hFile = INVALID_HANDLE_VALUE;

    // @@BEGIN_DDKSPLIT
    if ( pIniPort->hNotify ) {

        SplUnregisterForDeviceEvents(pIniPort->hNotify);
        pIniPort->hNotify   = NULL;
    }
    // @@END_DDKSPLIT

    pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);

    FreeSplStr(pIniPort->pDeviceName);
    pIniPort->pDeviceName = NULL;

    ImpersonatePrinterClient(hToken);

    return ValidateDosDevicePort(pIniPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\spltypes.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h

// @@BEGIN_DDKSPLIT
Abstract:


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef MODULE
#define MODULE "LMON:"
#define MODULE_DEBUG LocalmonDebug
#endif

#define ILM_SIGNATURE   0x4d4c49  /* 'ILM' is the signature value */

typedef struct _INIPORT  *PINIPORT;
typedef struct _INIXCVPORT  *PINIXCVPORT;

typedef struct _INILOCALMON {
    DWORD signature;
// @@BEGIN_DDKSPLIT
#ifdef _SPL_CLUST
// @@END_DDKSPLIT
    PMONITORINIT pMonitorInit;
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
    PINIPORT pIniPort;
    PINIXCVPORT pIniXcvPort;
} INILOCALMON, *PINILOCALMON;

typedef struct _INIENTRY {
    DWORD       signature;
    DWORD       cb;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;

// IMPORTANT: the offset to pNext in INIPORT must be the same as in INIXCVPORT (DeletePortNode)
typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hFile;               // File handle
    DWORD   cbWritten;
    DWORD   Status;              // see PORT_ manifests
    LPWSTR  pPrinterName;
    LPWSTR  pDeviceName;
    HANDLE  hPrinter;
    DWORD   JobId;
    PINILOCALMON        pIniLocalMon;
    LPBYTE              pExtra;
    // @@BEGIN_DDKSPLIT
    HANDLE              hNotify;
    // @@END_DDKSPLIT
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x5450  /* 'PT' is the signature value */

// IMPORTANT: the offset to pNext in INIXCVPORT must be the same as in INIPORT (DeletePortNode)
typedef struct _INIXCVPORT {
    DWORD       signature;
    DWORD       cb;
    struct      _INIXCVPORT *pNext;
    DWORD       cRef;
    DWORD       dwMethod;
    LPWSTR      pszName;
    DWORD       dwState;
    ACCESS_MASK GrantedAccess;
    PINILOCALMON pIniLocalMon;
} INIXCVPORT, *PINIXCVPORT;

#define XCV_SIGNATURE   0x5843  /* 'XC' is the signature value */


#define PP_DOSDEVPORT     0x0001  // A port for which we did DefineDosDevice
#define PP_COMM_PORT      0x0002  // A port for which GetCommTimeouts was successful
#define PP_FILEPORT       0x0004  // The port is a file port
#define PP_STARTDOC       0x0008  // Port is in use (startdoc called)

#define FindPort(pIniLocalMon, psz)                          \
    (PINIPORT)LcmFindIniKey( (PINIENTRY)pIniLocalMon->pIniPort, \
                          (LPWSTR)(psz))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\xcv.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    xcv.c

Abstract:

    Implements xcv functions.

// @@BEGIN_DDKSPLIT
Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

//
// The ddk montior samples will be build with the name ddklocalmon and ddklocalui
// so they can be installed without clashing with existing files
//                 
// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT
//
// change this to the name of the dll that provides the ui for the monitor
//
#define SZLOCALUI  L"DDKLocalUI.dll"
// @@BEGIN_DDKSPLIT
#endif

#define SZLOCALUI  L"LocalUI.dll"
// @@END_DDKSPLIT

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoPortExists(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoPortIsValid(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoSetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoGetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);


DWORD
GetTransmissionRetryTimeout(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);


typedef struct {
    PWSTR   pszMethod;
    DWORD   (*pfn)( PBYTE  pInputData,
                    DWORD  cbInputData,
                    PBYTE  pOutputData,
                    DWORD  cbOutputData,
                    PDWORD pcbOutputNeeded,
                    PINIXCVPORT pIniXcv
                    );
} XCV_METHOD, *PXCV_METHOD;


XCV_METHOD  gpLcmXcvMethod[] = {
                            {L"MonitorUI", GetMonitorUI},
                            {L"ConfigureLPTPortCommandOK", ConfigureLPTPortCommandOK},
                            {L"AddPort", DoAddPort},
                            {L"DeletePort", DoDeletePort},
                            {L"PortExists", DoPortExists},
                            {L"PortIsValid", DoPortIsValid},
                            {L"GetTransmissionRetryTimeout", GetTransmissionRetryTimeout},
                            {L"SetDefaultCommConfig", DoSetDefaultCommConfig},
                            {L"GetDefaultCommConfig", DoGetDefaultCommConfig},
                            {NULL, NULL}
                            };

DWORD
LcmXcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    )
{
    DWORD dwRet;
    DWORD i;

    for(i = 0 ; gpLcmXcvMethod[i].pszMethod &&
                wcscmp(gpLcmXcvMethod[i].pszMethod, pszDataName) ; ++i)
        ;

    if (gpLcmXcvMethod[i].pszMethod) {
        dwRet = (*gpLcmXcvMethod[i].pfn)(  pInputData,
                                        cbInputData,
                                        pOutputData,
                                        cbOutputData,
                                        pcbOutputNeeded,
                                        (PINIXCVPORT) hXcv);

    } else {
        dwRet = ERROR_INVALID_PARAMETER;
    }

    return dwRet;
}

BOOL
LcmXcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    *phXcv = CreateXcvPortEntry(pIniLocalMon, pszObject, GrantedAccess);

    return !!*phXcv;
}


BOOL
LcmXcvClosePort(
    HANDLE  hXcv
    )
{
    LcmEnterSplSem();
    DeleteXcvPortEntry((PINIXCVPORT) hXcv);
    LcmLeaveSplSem();

    return TRUE;
}

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet = ERROR_SUCCESS;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    LcmEnterSplSem();

    if (LcmDeletePortEntry( pIniXcv->pIniLocalMon, (PWSTR)pInputData))
        WriteProfileString(szPorts, (PWSTR) pInputData, NULL);
    else
        dwRet = ERROR_FILE_NOT_FOUND;

    LcmLeaveSplSem();

    return dwRet;
}


DWORD
DoPortExists(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet;
    BOOL  bPortExists;

    *pcbOutputNeeded = sizeof(DWORD);

    if (cbOutputData < sizeof(DWORD)) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    bPortExists = PortExists(NULL, (PWSTR) pInputData, &dwRet);

    if (dwRet == ERROR_SUCCESS)
        *(DWORD *) pOutputData = bPortExists;

    return dwRet;
}


DWORD
DoPortIsValid(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    BOOL bRet;

    bRet = PortIsValid((PWSTR) pInputData);

    return bRet ? ERROR_SUCCESS : GetLastError();
}



DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD       dwRet, bPortExists;
    PINIPORT    pIniPort = NULL;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    if ( cbInputData == 0   ||
         pInputData == NULL ||
         ( wcslen((LPWSTR)pInputData) + 1 ) * sizeof(WCHAR) != cbInputData )
        return ERROR_INVALID_PARAMETER;

    bPortExists = PortExists(NULL, (PWSTR) pInputData, &dwRet);

    if (dwRet == ERROR_SUCCESS) {
        if (bPortExists) {
            SetLastError(ERROR_ALREADY_EXISTS);
        } else {
            pIniPort = LcmCreatePortEntry( pIniXcv->pIniLocalMon, (PWSTR)pInputData );

            if (pIniPort) {
                if (!WriteProfileString(szPorts, (PWSTR) pInputData, L""))
                {
                    LcmDeletePortEntry(pIniXcv->pIniLocalMon, (PWSTR) pInputData);
                    pIniPort = NULL;
                }
            }
        }
    }

    return pIniPort ? ERROR_SUCCESS : GetLastError();
}


DWORD
DoSetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    BOOL        bRet = FALSE;
    DWORD       dwLength;
    PWSTR       pszPortName = NULL;
    COMMCONFIG  *pCommConfig = (COMMCONFIG *) pInputData;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    dwLength = wcslen(pIniXcv->pszName);
    if (pIniXcv->pszName[dwLength - 1] == L':') {
        if (!(pszPortName = AllocSplStr(pIniXcv->pszName)))
            goto Done;
        pszPortName[dwLength - 1] = L'\0';
    }

    bRet = SetDefaultCommConfig(pszPortName,
                                pCommConfig,
                                pCommConfig->dwSize);

Done:

    FreeSplStr(pszPortName);

    return bRet ? ERROR_SUCCESS : GetLastError();
}


DWORD
DoGetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    PWSTR       pszPortName = (PWSTR) pInputData;
    COMMCONFIG  *pCommConfig = (COMMCONFIG *) pOutputData;
    BOOL        bRet;


    if (cbOutputData < sizeof(COMMCONFIG))
        return ERROR_INSUFFICIENT_BUFFER;

    pCommConfig->dwProviderSubType = PST_RS232;
    *pcbOutputNeeded = cbOutputData;

    bRet = GetDefaultCommConfig(pszPortName, pCommConfig, pcbOutputNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
GetTransmissionRetryTimeout(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    *pcbOutputNeeded = sizeof(DWORD);

    if (cbOutputData < sizeof(DWORD))
        return ERROR_INSUFFICIENT_BUFFER;

    *(PDWORD) pOutputData = GetProfileInt(szWindows,
                                          szINIKey_TransmissionRetryTimeout,
                                          45 );
    return ERROR_SUCCESS;
}

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet;

    *pcbOutputNeeded = sizeof( SZLOCALUI );

    if (cbOutputData < *pcbOutputNeeded) {

        dwRet =  ERROR_INSUFFICIENT_BUFFER;

    } else {

        wcscpy((PWSTR) pOutputData, SZLOCALUI);
        dwRet = ERROR_SUCCESS;
    }

    return dwRet;
}


DWORD
ConfigureLPTPortCommandOK(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    if (!WriteProfileString(  szWindows, szINIKey_TransmissionRetryTimeout, (PWSTR) pInputData ))
        return GetLastError();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\local\util.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

// @@BEGIN_DDKSPLIT
Abstract:

    This module provides all the utility functions for localmon.

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


//
// These globals are needed so that AddPort can call
// SPOOLSS!EnumPorts to see whether the port to be added
// already exists.
// @@BEGIN_DDKSPLIT
// They will be initialized the first time AddPort is called.
//
// !! LATER !!
//
// This is common code. move PortExists into the router.
//
// @@END_DDKSPLIT

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

VOID
LcmRemoveColon(
    LPWSTR  pName)
{
    DWORD   Length;

    Length = wcslen(pName);

    if (pName[Length-1] == L':')
        pName[Length-1] = 0;
}


BOOL
IsCOMPort(
    LPWSTR pPort
)
{
    //
    // Must begin with szLcmCOM
    //
    if ( _wcsnicmp( pPort, szLcmCOM, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

BOOL
IsLPTPort(
    LPWSTR pPort
)
{
    //
    // Must begin with szLcmLPT
    //
    if ( _wcsnicmp( pPort, szLcmLPT, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}




#define NEXTVAL(pch)                    \
    while( *pch && ( *pch != L',' ) )    \
        pch++;                          \
    if( *pch )                          \
        pch++


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
)
{
    BOOL    bRet = FALSE;
    DWORD   rc, dwCharCount = 10;
    LPVOID  pszEntry = NULL;
    HANDLE  hToken = RevertToPrinterSelf();

    do {

        FreeSplMem(pszEntry);

        dwCharCount *= 2;
        pszEntry = AllocSplMem(dwCharCount*sizeof(WCHAR));

        if ( !pszEntry  ||
             !(rc = GetProfileString(szPorts, pName, szNULL,
                                     pszEntry, dwCharCount)) )
            goto Done;

    } while ( rc >= dwCharCount - 2 );

    bRet =  BuildCommDCB((LPWSTR)pszEntry, pdcb);

    pcto->WriteTotalTimeoutConstant = GetProfileInt(szWindows,
                                            szINIKey_TransmissionRetryTimeout,
                                            45 );
    pcto->WriteTotalTimeoutConstant*=1000;

Done:
    if (hToken)
    {
        ImpersonatePrinterClient (hToken);
    }
    FreeSplMem(pszEntry);
    return bRet;
}


/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
)
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1 pPorts;
    DWORD i;
    BOOL  Found = TRUE;

    *pError = NO_ERROR;

    if (!hSpoolssDll) {

        hSpoolssDll = LoadLibrary(L"SPOOLSS.DLL");

        if (hSpoolssDll) {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll,
                                                 "EnumPortsW");
            if (!pfnSpoolssEnumPorts) {

                *pError = GetLastError();
                FreeLibrary(hSpoolssDll);
                hSpoolssDll = NULL;
            }

        } else {

            *pError = GetLastError();
        }
    }

    if (!pfnSpoolssEnumPorts)
        return FALSE;


    if (!(*pfnSpoolssEnumPorts)(pName, 1, NULL, 0, &cbNeeded, &cReturned))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            cbPorts = cbNeeded;

            pPorts = AllocSplMem(cbPorts);

            if (pPorts)
            {
                if ((*pfnSpoolssEnumPorts)(pName, 1, (LPBYTE)pPorts, cbPorts,
                                           &cbNeeded, &cReturned))
                {
                    Found = FALSE;

                    for (i = 0; i < cReturned; i++)
                    {
                        if (!lstrcmpi(pPorts[i].pName, pPortName))
                            Found = TRUE;
                    }
                }
            }

            FreeSplMem(pPorts);
        }
    }

    else
        Found = FALSE;


    return Found;
}


VOID
LcmSplInSem(
   VOID
)
{
    if (LcmSpoolerSection.OwningThread != (HANDLE) UIntToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Not in spooler semaphore\n"));
    }
}

VOID
LcmSplOutSem(
   VOID
)
{
    if (LcmSpoolerSection.OwningThread == (HANDLE) UIntToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Inside spooler semaphore !!\n"));
    }
}

VOID
LcmEnterSplSem(
   VOID
)
{
    EnterCriticalSection(&LcmSpoolerSection);
}

VOID
LcmLeaveSplSem(
   VOID
)
{
#if DBG
    LcmSplInSem();
#endif
    LeaveCriticalSection(&LcmSpoolerSection);
}

PINIENTRY
LcmFindName(
   PINIENTRY pIniKey,
   LPWSTR pName
)
{
    if (pName) {
        while (pIniKey) {

            if (!lstrcmpi(pIniKey->pName, pName)) {
                return pIniKey;
            }

            pIniKey=pIniKey->pNext;
        }
    }

    return FALSE;
}

PINIENTRY
LcmFindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR pName
)
{
   if (!pName)
      return NULL;

   LcmSplInSem();

   while (pIniEntry && lstrcmpi(pName, pIniEntry->pName))
      pIniEntry = pIniEntry->pNext;

   return pIniEntry;
}

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
)
{
   while (*DestOffsets != -1) {
      if (*pSource) {
         pEnd-=wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
         *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)=wcscpy((LPWSTR)pEnd, *pSource);
      } else
         *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)=0;
      pSource++;
      DestOffsets++;
   }

   return pEnd;
}


/* LcmMessage
 *
 * Displays a LcmMessage by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
int LcmMessage(HWND hwnd, DWORD Type, int CaptionID, int TextID, ...)
{
    WCHAR   MsgText[256];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( LcmhInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( LcmhInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        wvsprintf( MsgText, MsgFormat, vargs );
        va_end( vargs );

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}


/*
 *
 */
LPTSTR
LcmGetErrorString(
    DWORD   Error
)
{
    TCHAR   Buffer[1024];
    LPTSTR  pErrorString = NULL;

    if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL, Error, 0, Buffer,
                       COUNTOF(Buffer), NULL )
      == 0 )

        LoadString( LcmhInst, IDS_UNKNOWN_ERROR,
                    Buffer, COUNTOF(Buffer) );

    pErrorString = AllocSplStr(Buffer);

    return pErrorString;
}




DWORD ReportError( HWND  hwndParent,
                   DWORD idTitle,
                   DWORD idDefaultError )
{
    DWORD  ErrorID;
    DWORD  MsgType;
    LPTSTR pErrorString;

    ErrorID = GetLastError( );

    if( ErrorID == ERROR_ACCESS_DENIED )
        MsgType = MSG_INFORMATION;
    else
        MsgType = MSG_ERROR;


    pErrorString = LcmGetErrorString( ErrorID );

    LcmMessage( hwndParent, MsgType, idTitle,
             idDefaultError, pErrorString );

    FreeSplStr( pErrorString );


    return ErrorID;
}


// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

DWORD
WINAPIV
StrNCatBuffW(
    IN      PWSTR       pszBuffer,
    IN      UINT        cchBuffer,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    into the provided buffer.  The last argument must be a NULL
    to signify the end of the argument list.  This only called
        from LocalMon by functions that use WCHARS.

Arguments:

    pszBuffer  - pointer buffer where to place the concatenated
                 string.
    cchBuffer  - character count of the provided buffer including
                 the null terminator.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

--*/
{
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    PCWSTR  pszTemp     = NULL;
    PWSTR   pszDest     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (pszBuffer && cchBuffer)
    {
        //
        // Assume success.
        //
        dwRetval = ERROR_SUCCESS;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, cchBuffer);

        //
        // Get temp destination pointer.
        //
        pszDest = pszBuffer;

        //
        // Insure we have space for the null terminator.
        //
        cchBuffer--;

        //
        // Collect all the arguments.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, PCWSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Copy the data into the destination buffer.
            //
            for ( ; cchBuffer; cchBuffer-- )
            {
                if (!(*pszDest = *pszTemp))
                {
                    break;
                }

                pszDest++, pszTemp++;
            }

            //
            // If were unable to write all the strings to the buffer,
            // set the error code and nuke the incomplete copied strings.
            //
            if (!cchBuffer && pszTemp && *pszTemp)
            {
                dwRetval = ERROR_BUFFER_OVERFLOW;
                *pszBuffer = L'\0';
                break;
            }
        }

        //
        // Terminate the buffer always.
        //
        *pszDest = L'\0';

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\config.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    config.c

Abstract:

    Handles spooler entry points for adding, deleting, and configuring
    localui ports.

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"
#include "lmon.h"

/* From Control Panel's control.h:
 */
#define CHILD_PORTS 0

/* From cpl.h:
 */
#define CPL_INIT        1
#define CPL_DBLCLK      5
#define CPL_EXIT        7

// @@BEGIN_DDKSPLIT
/* Hack:
 */
// @@END_DDKSPLIT
#define CHILD_PORTS_HELPID  0

/* ConfigCOMPort
 *
 * Calls the Control Panel Ports applet
 * to permit user to set Baud rate etc.
 */
typedef void (WINAPI *CFGPROC)(HWND, ULONG, ULONG, ULONG);


BOOL
ConfigLPTPort(
    HWND    hWnd,
    HANDLE  hXcv
);

BOOL
ConfigCOMPort(
    HWND    hWnd,
    HANDLE  hXcv,
    PCWSTR  pszServer,
    PCWSTR  pszPortName
);

LPWSTR
GetPortName(
    HWND    hWnd,
    HANDLE  hXcv
);


BOOL
AddPortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
)
{
    PWSTR  pszPortName = NULL;
    BOOL   rc = TRUE;
    WCHAR  szLocalMonitor[MAX_PATH+1];
    DWORD  dwReturn, dwStatus;
    DWORD  cbNeeded;
    PRINTER_DEFAULTS Default;
    PWSTR  pszServerName = NULL;
    HANDLE  hXcv = NULL;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        //
        // Invalid parent window handle causes problems in function with DialogBoxParam call.
        // That function when the handle is bad returns ZERO, the same value as ERROR_SUCCEED.
        // PortNameDlg function calls EndDialog (ERROR_SUCCEES) if everything is alright.
        // => Bug 33356487
        // 
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        if (ppszPortNameOut)
        {
            *ppszPortNameOut = NULL;
        }
        return FALSE;
    }
    //
    //
    //
    /* Get the user to enter a port name:
     */

    if (!(pszServerName = ConstructXcvName(pszServer, pszMonitorNameIn, L"XcvMonitor"))) {
        rc = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(rc = OpenPrinter((PWSTR) pszServerName, &hXcv, &Default))) {
        rc = FALSE;
        goto Done;
    }

    if (!(pszPortName = GetPortName(hWnd, hXcv))) {
        rc = FALSE;
        goto Done;
    }

    // We can't Add, Configure, or Delete Remote COM ports
    if (IS_COM_PORT(pszPortName) || IS_LPT_PORT(pszPortName)) {
        SetLastError(ERROR_NOT_SUPPORTED);
        rc = FALSE;
        goto Done;
    }

    if(IS_COM_PORT(pszPortName))
        CharUpperBuff(pszPortName, 3);
    else if(IS_LPT_PORT(pszPortName))
        CharUpperBuff(pszPortName, 3);

    rc = XcvData(   hXcv,
                    L"AddPort",
                    (PBYTE) pszPortName,
                    (wcslen(pszPortName) + 1)*sizeof(WCHAR),
                    (PBYTE) &dwReturn,
                    0,
                    &cbNeeded,
                    &dwStatus);

    if (rc) {
        if(dwStatus == ERROR_SUCCESS) {
            if(ppszPortNameOut)
                *ppszPortNameOut = AllocSplStr(pszPortName);

            if(IS_LPT_PORT(pszPortName))
                rc = ConfigLPTPort(hWnd, hXcv);
            else if(IS_COM_PORT(pszPortName))
                rc = ConfigCOMPort(hWnd, hXcv, pszServer, pszPortName);

        } else if (dwStatus == ERROR_ALREADY_EXISTS) {
            Message( hWnd, MSG_ERROR, IDS_LOCALMONITOR, IDS_PORTALREADYEXISTS_S, pszPortName );

        } else {
            SetLastError(dwStatus);
            rc = FALSE;
        }
    }


Done:

    FreeSplStr(pszPortName);
    FreeSplMem(pszServerName);

    if (hXcv)
        ClosePrinter(hXcv);

    return rc;
}


BOOL
DeletePortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
)
{
    PRINTER_DEFAULTS Default;
    PWSTR   pszServerName = NULL;
    DWORD   dwOutput;
    DWORD   cbNeeded;
    BOOL    bRet;
    HANDLE  hXcv = NULL;
    DWORD   dwStatus;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        return FALSE;
    }
    //
    //
    //
    if (!(pszServerName = ConstructXcvName(pszServer, pszPortName, L"XcvPort"))) {
        bRet = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(bRet = OpenPrinter((PWSTR) pszServerName, &hXcv, &Default)))
        goto Done;

    // Since we can't Add or Configure Remote COM ports, let's not allow deletion either
  
    if (IS_COM_PORT(pszPortName) || IS_LPT_PORT(pszPortName)) {
        SetLastError(ERROR_NOT_SUPPORTED);
        bRet = FALSE;

    } else {

        bRet = XcvData( hXcv,
                        L"DeletePort",
                        (PBYTE) pszPortName,
                        (wcslen(pszPortName) + 1)*sizeof(WCHAR),
                        (PBYTE) &dwOutput,
                        0,
                        &cbNeeded,
                        &dwStatus);

        if (!bRet && (ERROR_BUSY == dwStatus))
        {
            //
            // Port cannot be deleted cause it is in use.
            //
            ErrorMessage (
                hWnd,
                dwStatus
                );
            //
            // Error is handled here and caller does not need to do anything
            //
            SetLastError (ERROR_CANCELLED);
        }
        else if (bRet && (ERROR_SUCCESS != dwStatus)) 
        {
            SetLastError(dwStatus);
            bRet = FALSE;
        }
    }

Done:

    if (hXcv)
        ClosePrinter(hXcv);

    FreeSplMem(pszServerName);

    return bRet;
}




/* ConfigurePortUI
 *
 */
BOOL
ConfigurePortUI(
    PCWSTR pName,
    HWND   hWnd,
    PCWSTR pPortName
)
{
    BOOL   bRet;
    PRINTER_DEFAULTS Default;
    PWSTR  pServerName = NULL;
    HANDLE hXcv = NULL;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        return FALSE;
    }
    //
    //
    //
    if (!(pServerName = ConstructXcvName(pName, pPortName, L"XcvPort"))) {
        bRet = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(bRet = OpenPrinter((PWSTR) pServerName, &hXcv, &Default)))
        goto Done;


    if( IS_LPT_PORT( (PWSTR) pPortName ) )
        bRet = ConfigLPTPort(hWnd, hXcv);
    else if( IS_COM_PORT( (PWSTR) pPortName ) )
        bRet = ConfigCOMPort(hWnd, hXcv, pName, pPortName);
    else {
        Message( hWnd, MSG_INFORMATION, IDS_LOCALMONITOR,
                 IDS_NOTHING_TO_CONFIGURE );

        SetLastError(ERROR_CANCELLED);
        bRet = FALSE;
    }

Done:

    FreeSplMem(pServerName);

    if (hXcv) {
        ClosePrinter(hXcv);
        hXcv = NULL;
    }

    return bRet;
}



/* ConfigLPTPort
 *
 * Calls a dialog box which prompts the user to enter timeout and retry
 * values for the port concerned.
 * The dialog writes the information to the registry (win.ini for now).
 */
BOOL
ConfigLPTPort(
    HWND    hWnd,
    HANDLE  hXcv
)
{
    PORTDIALOG  Port;
    INT         iRet;
    //
    //
    ZeroMemory (&Port, sizeof (Port));
    iRet = -1;
    //
    //
    Port.hXcv = hXcv;

    iRet = (INT)DialogBoxParam(hInst, MAKEINTRESOURCE( DLG_CONFIGURE_LPT ),
                               hWnd, ConfigureLPTPortDlg, (LPARAM) &Port);

    if (iRet == ERROR_SUCCESS)
    {
        //
        // DialogBoxParam returns zero if hWnd is invalid.
        // ERROR_SUCCESS is equal to zero.
        // => We need to check LastError too.
        //
        return ERROR_SUCCESS == GetLastError ();
    }

    if (iRet == -1)
        return FALSE;

    SetLastError(iRet);
    return FALSE;
}


/* ConfigCOMPort
 *
 */
BOOL
ConfigCOMPort(
    HWND    hWnd,
    HANDLE  hXcv,
    PCWSTR  pszServer,
    PCWSTR  pszPortName
)
{
    DWORD       dwStatus;
    BOOL        bRet = FALSE;
    COMMCONFIG  CommConfig;
    COMMCONFIG  *pCommConfig = &CommConfig;
    COMMCONFIG  *pCC = NULL;
    PWSTR       pszPort = NULL;
    DWORD       cbNeeded;


    // GetDefaultCommConfig can't handle trailing :, so remove it!
    if (!(pszPort = (PWSTR) AllocSplStr(pszPortName)))
        goto Done;
    pszPort[wcslen(pszPort) - 1] = L'\0';

    cbNeeded = sizeof CommConfig;

    if (!XcvData(   hXcv,
                    L"GetDefaultCommConfig",
                    (PBYTE) pszPort,
                    (wcslen(pszPort) + 1)*sizeof *pszPort,
                    (PBYTE) pCommConfig,
                    cbNeeded,
                    &cbNeeded,
                    &dwStatus))
        goto Done;

    if (dwStatus != ERROR_SUCCESS) {
        if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
            SetLastError(dwStatus);
            goto Done;
        }

        if (!(pCommConfig = pCC = AllocSplMem(cbNeeded)))
            goto Done;

        if (!XcvData(   hXcv,
                        L"GetDefaultCommConfig",
                        (PBYTE) pszPort,
                        (wcslen(pszPort) + 1)*sizeof *pszPort,
                        (PBYTE) pCommConfig,
                        cbNeeded,
                        &cbNeeded,
                        &dwStatus))
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            SetLastError(dwStatus);
            goto Done;
        }
    }

    if (CommConfigDialog(pszPort, hWnd, pCommConfig)) {
        if (!XcvData(   hXcv,
                        L"SetDefaultCommConfig",
                        (PBYTE) pCommConfig,
                        pCommConfig->dwSize,
                        (PBYTE) NULL,
                        0,
                        &cbNeeded,
                        &dwStatus))
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            SetLastError(dwStatus);
            goto Done;
        }
        bRet = TRUE;
    }


Done:

    FreeSplMem(pCC);
    FreeSplStr(pszPort);

    return bRet;
}



//
// Support routines
//


/* GetPortName
 *
 * Puts up a dialog containing a free entry field.
 * The dialog allocates a string for the name, if a selection is made.
 */

LPWSTR
GetPortName(
    HWND    hWnd,
    HANDLE  hXcv
)
{
    PORTDIALOG Port;
    INT        Result;
    LPWSTR     pszPort = NULL;
    //
    //
    ZeroMemory (&Port, sizeof (Port));
    Result = -1;
    //
    //
    Port.hXcv = hXcv;

    Result = (INT)DialogBoxParam(hInst, 
                                 MAKEINTRESOURCE(DLG_PORTNAME), 
                                 hWnd, 
                                 (DLGPROC)PortNameDlg, 
                                 (LPARAM)&Port);
        
    if (Result == ERROR_SUCCESS) 
    {
        //
        // DialogBoxParam returns zero if hWnd is invalid.
        // ERROR_SUCCESS is equal to zero.
        // => We need to check LastError too.
        //
        if (ERROR_SUCCESS == GetLastError ())
        {
            //
            // DialogBoxParam executed successfully and a port name was retrieved
            //
            pszPort = Port.pszPortName;
        }
    }
    else if (Result != -1) 
    {
        //
        // DialogBoxParam executed successfully, but the user canceled the dialog
        //
        SetLastError(Result);
    }
    
    return pszPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localui.rc
//
#define DLG_PORTNAME                200
#define IDD_PN_PB_HELP              201
#define IDD_PN_EF_PORTNAME          202

#define DLG_CONFIGURE_LPT           300
#define IDD_CL_EF_TRANSMISSIONRETRY 303
#define IDD_CF_PB_HELP              304

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        305
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           305
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\spltypes.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h
    
// @@BEGIN_DDKSPLIT
Abstract:


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#ifndef _SPLTYPES_H_
#define _SPLTYPES_H_

#ifndef MODULE
#define MODULE "LMON:"
#define MODULE_DEBUG LocalmonDebug
#endif

typedef struct _PORTDIALOG {
    HANDLE  hXcv;
    PWSTR   pszServer;
    PWSTR   pszPortName;
} PORTDIALOG, *PPORTDIALOG;

typedef struct _INIENTRY {
    DWORD       signature;
    DWORD       cb;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;

//
// IMPORTANT: the offset to pNext in INIPORT must be the same as in INIXCVPORT (DeletePortNode)
//
typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hFile;               
    DWORD   cbWritten;
    DWORD   Status;          // see PORT_ manifests    
    LPWSTR  pPrinterName;
    LPWSTR  pDeviceName;
    HANDLE  hPrinter;
    DWORD   JobId;
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x5450  /* 'PT' is the signature value */

//
// IMPORTANT: the offset to pNext in INIXCVPORT must be the same as in INIPORT (DeletePortNode)
//
typedef struct _INIXCVPORT {
    DWORD       signature;
    DWORD       cb;
    struct      _INIXCVPORT *pNext;
    DWORD       cRef;
    DWORD       dwMethod;
    LPWSTR      pszName;
    DWORD       dwState;
} INIXCVPORT, *PINIXCVPORT;

#define XCV_SIGNATURE   0x5843  /* 'XC' is the signature value */


#define PP_DOSDEVPORT     0x0001  // A port for which we did DefineDosDevice
#define PP_COMM_PORT      0x0002  // A port for which GetCommTimeouts was successful
#define PP_FILEPORT       0x0004  // The port is a file port
#define PP_STARTDOC       0x0008  // Port is in use (startdoc called)


#endif // _SPLTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\precomp.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>
#include <stddef.h>
#include <commctrl.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\localui.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    localui.h

// @@BEGIN_DDKSPLIT
Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _LOCALUI_H_
#define _LOCALUI_H_

VOID
CompleteRead(
    DWORD Error,
    DWORD ByteCount,
    LPOVERLAPPED pOverlapped
);

extern  HANDLE   hInst;
extern  DWORD    PortInfo1Strings[];
extern  DWORD    PortInfo2Strings[];
extern  PINIPORT pIniFirstPort;
extern  PINIXCVPORT pIniFirstXcvPort;

extern WCHAR szPorts[];
extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];
extern WCHAR szDeviceNameHeader[];
extern WCHAR szFILE[];
extern WCHAR szCOM[];
extern WCHAR szLPT[];


#define IDS_LOCALMONITOR               300
#define IDS_INVALIDPORTNAME_S          301
#define IDS_PORTALREADYEXISTS_S        302
#define IDS_NOTHING_TO_CONFIGURE       303

#define MSG_ERROR           MB_OK | MB_ICONSTOP
#define MSG_WARNING         MB_OK | MB_ICONEXCLAMATION
#define MSG_YESNO           MB_YESNO | MB_ICONQUESTION
#define MSG_INFORMATION     MB_OK | MB_ICONINFORMATION
#define MSG_CONFIRMATION    MB_OKCANCEL | MB_ICONEXCLAMATION

#define TIMEOUT_MIN         1
#define TIMEOUT_MAX         999999
#define TIMEOUT_STRING_MAX  6

#define WITHINRANGE( val, lo, hi ) \
    ( ( val <= hi ) && ( val >= lo ) )


#define IS_FILE_PORT(pName) \
    !_wcsicmp( pName, szFILE )

#define IS_COM_PORT(pName) \
    IsCOMPort( pName )

#define IS_LPT_PORT(pName) \
    IsLPTPort( pName )

BOOL
IsCOMPort(
    PCWSTR pPort
);

BOOL
IsLPTPort(
    PCWSTR pPort
);

INT_PTR APIENTRY
ConfigureLPTPortDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
);


int
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
);



PINIXCVPORT
CreateXcvPortEntry(
    DWORD   dwMethod,
    LPCWSTR pszName
);


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
);

BOOL
ConfigurePortUI(
    LPCWSTR  pName,
    HWND    hWnd,
    LPCWSTR  pPortName
    );


BOOL
DeletePortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);

BOOL APIENTRY
PortNameDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
);


PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
);


INT
ErrorMessage(
    HWND hwnd,
    DWORD dwStatus
);

VOID cdecl DbgMsg( LPWSTR MsgFormat, ... );

#endif // _LOCALUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\parsepjl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved

Module Name:

    parsepjl.h

Abstract:

    Header file for PJL parser

--*/

#define MAX_POSSIBLE_LISTS_IN_BRANCH 2

/* Note: new actions must be added at end, and new functions at the
end of the function pointer array defined later in this file */
enum ParseActionsEnumTag 
   {
   ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF,
   ACTION_SET_NEW_LIST,
   ACTION_GET_TOTAL_AND_LARGEST_FF,
   ACTION_GET_CODE_AND_ONLINE_FF,
   ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST,
   ACTION_SET_VALUE_FROM_PARAM_FF,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM,   
   ACTION_SET_VALUE_FROM_PARAM,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL
   };



/* Note: new actions must be added at end, and new functions at the
   end of the function pointer array defined later in this file 
*/
enum ParseNotFoundActionsEnumTag 
   {
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES
   };



/* Note: The order of some of the Token values is related to 
   indexes in the keyword lists.  Always add new token values
   to the end of BASE group.
*/
enum pjl_token_variables_tag
   {

   PJL_TOKEN_INQUIRE_BASE = 0x10000,
   TOKEN_INQUIRE_TRAY1SIZE = 0x10000,
   TOKEN_INQUIRE_TRAY2SIZE,
   TOKEN_INQUIRE_TRAY3SIZE,
   TOKEN_INQUIRE_TRAY4SIZE,

   PJL_TOKEN_ECHO_BASE = 0x20000,
   TOKEN_ECHO_MSSYNC_NUMBER = 0x20000,

   PJL_TOKEN_INFO_MEMORY_BASE = 0x30000,
   TOKEN_INFO_MEMORY_TOTAL   = 0x30000,
   TOKEN_INFO_MEMORY_LARGEST,

   PJL_TOKEN_INFO_STATUS_BASE = 0x40000,
   TOKEN_INFO_STATUS_CODE = 0x40000,
   TOKEN_INFO_STATUS_ONLINE,

   PJL_TOKEN_INFO_CONFIG_BASE = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY_SPACE,

   PJL_TOKEN_USTATUS_JOB_BASE = 0x60000,
   TOKEN_USTATUS_JOB_END = 0x60000,
   TOKEN_USTATUS_JOB_NAME_MSJOB,

   PJL_TOKEN_USTATUS_DEVICE_BASE = 0x70000,
   TOKEN_USTATUS_DEVICE_CODE = 0x70000,
   TOKEN_USTATUS_DEVICE_DISPLAY,
   TOKEN_USTATUS_DEVICE_ONLINE,
   };

/* The first 5 values are the possible return values for GetPJLTokens() */
/* The last 2 values are used internally */
enum status_tag
   {
   STATUS_REACHED_END_OF_COMMAND_OK,
   STATUS_END_OF_STRING,
   STATUS_SYNTAX_ERROR,
   STATUS_ATPJL_NOT_FOUND,
   STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS,

   STATUS_REACHED_FF,
   STATUS_CONTINUE
   };

typedef struct
   {
   DWORD    token;
   UINT_PTR value;
   } TOKENPAIR, * PTOKENPAIR, TokenPairType;

typedef struct ParamTypeTag
   {
   union 
      {
      struct ListTypeTag *pList;
      DWORD token;
      DWORD value;
      struct KeywordTypeTag *pListOfKeywords; 
      LPSTR lpstr;
      };  
   } ParamType;

typedef struct KeywordTypeTag 
   {
   LPSTR lpsz;
   DWORD dwAction;
   ParamType param;
   } KeywordType;

typedef struct ListTypeTag
   {
   BOOL  bFormFeedOK;
   DWORD dwNotFoundAction;
   DWORD tokenBaseValue;
   KeywordType *pListOfKeywords; 
   } ListType;

typedef struct parseVarsTag
   {
   LPSTR        pInPJL_Local;
   DWORD        nTokenLeft;
   DWORD        nTokenInBuffer_Local;
   TokenPairType *pToken_Local;
   DWORD        dwNextToken;
   DWORD        dwFoundIndex;
   DWORD        status; 
   ListType     *pCurrentList;
   KeywordType  *pCurrentKeywords;
   ListType     *arrayOfLists[MAX_POSSIBLE_LISTS_IN_BRANCH+1]; 
   } ParseVarsType;



extern DWORD GetPJLTokens(LPSTR lpInPJL, DWORD nTokenInBuffer, 
   TokenPairType *pToken, DWORD *pnTokenParsed, LPSTR *plpInPJL);

typedef struct
    {
    DWORD   pjl;
    DWORD   status;
    } PJLTOPRINTERSTATUS;

extern PJLTOPRINTERSTATUS PJLToStatus[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\precomp.h ===
/*++

Copyright (c) 1994 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include "spltypes.h"
#include "local.h"
#include "parsepjl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\localui.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    localui.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"


//
// Common string definitions
//


HANDLE hInst;
PINIPORT pIniFirstPort;
PINIXCVPORT pIniFirstXcvPort;
DWORD LocalMonDebug;

DWORD PortInfo1Strings[]={FIELD_OFFSET(PORT_INFO_1, pName),
                          (DWORD)-1};

DWORD PortInfo2Strings[]={FIELD_OFFSET(PORT_INFO_2, pPortName),
                          FIELD_OFFSET(PORT_INFO_2, pMonitorName),
                          FIELD_OFFSET(PORT_INFO_2, pDescription),
                          (DWORD)-1};

WCHAR szPorts[]   = L"ports";
WCHAR szPortsEx[] = L"portsex"; /* Extra ports values */
WCHAR szFILE[]    = L"FILE:";
WCHAR szCOM[]     = L"COM";
WCHAR szLPT[]     = L"LPT";


MONITORUI MonitorUI =
{
    sizeof(MONITORUI),
    AddPortUI,
    ConfigurePortUI,
    DeletePortUI
};


extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    INITCOMMONCONTROLSEX icc;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        hInst = hModule;

        DisableThreadLibraryCalls(hModule);

        //
        // Initialize the common controls, needed for fusion applications
        // because standard controls were moved to comctl32.dll
        //
        InitCommonControls();

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icc);
       
        return TRUE;

    case DLL_PROCESS_DETACH:
        return TRUE;
    }

    UNREFERENCED_PARAMETER( lpRes );
    return TRUE;
}

PMONITORUI
InitializePrintMonitorUI(
    VOID
)
{
    return &MonitorUI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:

    DDK version of local.h

Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#endif
// @@END_DDKSPLIT


#define READTHREADTIMEOUT                5000
#define READ_THREAD_EOJ_TIMEOUT         60000   // 1 min
#define READ_THREAD_ERROR_WAITTIME       5000   // 5 sec
#define READ_THREAD_IDLE_WAITTIME       30000   // 30 sec

#define ALL_JOBS                    0xFFFFFFFF


// ---------------------------------------------------------------------
// EXTERN VARIABLES
// ---------------------------------------------------------------------
extern  HANDLE              hInst;
extern  DWORD               dwReadThreadErrorTimeout;
extern  DWORD               dwReadThreadEOJTimeout;
extern  DWORD               dwReadThreadIdleTimeoutOther;

extern  CRITICAL_SECTION    pjlMonSection;
extern  DWORD SplDbgLevel;


// ---------------------------------------------------------------------
// FUNCTION PROTOTYPE
// ---------------------------------------------------------------------
VOID
EnterSplSem(
   VOID
    );

VOID
LeaveSplSem(
   VOID
    );

VOID
SplInSem(
   VOID
    );

VOID
SplOutSem(
    VOID
    );

DWORD
UpdateTimeoutsFromRegistry(
    IN LPTSTR      pszRegistryRoot
    );

PINIPORT
FindIniPort(
   IN LPTSTR pszName
    );

PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    );

VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    );

VOID
FreeIniJobs(
    PINIPORT pIniPort
    );

VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    );
VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    );

// @@BEGIN_DDKSPLIT
// ---------------------------------------------------------------------
// UNICODE TO ANSI MACRO
// ??? !!! we should get rid of these sooner or later
// ---------------------------------------------------------------------
// @@END_DDKSPLIT
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

LPSTR
mystrstr(
    LPSTR cs,
    LPSTR ct
);

LPSTR
mystrrchr(
    LPSTR cs,
    char c
);

LPSTR
mystrchr(
    LPSTR cs,
    char c
);

int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
);

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

extern  CRITICAL_SECTION    pjlMonSection;

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

//
// Needed by DDK
//
// @@BEGIN_DDKSPLIT
/*
// @@END_DDKSPLIT
#define DBGMSG(x,y)
#define SPLASSERT(exp)
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\spltypes.h ===
/*++

Copyright (c) 1995 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    Spltypes.h

Abstract:

    PJLMON header file


--*/

#ifndef MODULE
#define MODULE "PJLMON:"
#define MODULE_DEBUG PjlmonDebug
#endif

typedef struct _INIJOB {
    DWORD   signature;
    struct _INIJOB FAR *pNext;
    LPTSTR  pszPrinterName;
    HANDLE  hPrinter;
    DWORD   JobId;
    DWORD   status;
    DWORD   TimeoutCount;
} INIJOB, FAR *PINIJOB;

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT FAR *pNext;
    LPTSTR  pszPortName;

    DWORD   cRef;

    DWORD   status;
    PINIJOB pIniJob;

    HANDLE  hPort;
    HANDLE  WakeUp;
    HANDLE  DoneReading;
    HANDLE  DoneWriting;

    DWORD   PrinterStatus;
    DWORD   dwLastReadTime;
    DWORD   dwAvailableMemory;
    DWORD   dwInstalledMemory;

    MONITOR fn;

} INIPORT, FAR *PINIPORT;

#define PJ_SIGNATURE   0x4F4A  /* 'PJ' is the signature value */

//
// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_LJ4L, PP_RESETDEV
//      are set/cleared on per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
//
#define PP_INSTARTDOC       0x00000001  // Inside StartDoc, sending data to the printer
#define PP_RUN_THREAD       0x00000002  // Tell the ustatus thread to start running
#define PP_THREAD_RUNNING   0x00000004  // Tell the main thread that the ustatus thread is running

//
// If PP_RUN_THREAD is set and PP_THREAD_RUNNING is not that means UStatus
// thread is being created or it is already running but has not determined if
// printer is PJL or not yet
//
#define PP_PRINTER_OFFLINE  0x00000008  // The printer is OFFLINE
#define PP_PJL_SENT         0x00000010  // PJL Command was sent to the printer
#define PP_SEND_PJL         0x00000020  // Set at StartDoc so that we initialize PJL
                                        // commands during the first write port
#define PP_IS_PJL           0x00000040  // Port is PJL
#define PP_DONT_TRY_PJL     0x00000080  // Don't try again...
#define PP_WRITE_ERROR      0x00000100  // A write was not succesful

// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_PORT_OPEN are set/cleared on
//           per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\localui\util.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for localui.

// @@BEGIN_DDKSPLIT

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "local.h"
#include "localui.h"

PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    DWORD   cbOutput;
    PWSTR   pOut;

    cbOutput = pServerName ? (wcslen(pServerName) + 2)*sizeof(WCHAR) : sizeof(WCHAR);   /* "\\Server\," */
    cbOutput += (wcslen(pObjectType) + 2)*sizeof(WCHAR);                        /* "\\Server\,XcvPort _" */
    cbOutput += pObjectName ? (wcslen(pObjectName))*sizeof(WCHAR) : 0;      /* "\\Server\,XcvPort Object_" */

    if (pOut = AllocSplMem(cbOutput)) {

        if (pServerName) {
            wcscpy(pOut,pServerName);
            wcscat(pOut, L"\\");
        }

        wcscat(pOut,L",");
        wcscat(pOut,pObjectType);
        wcscat(pOut,L" ");

        if (pObjectName)
            wcscat(pOut,pObjectName);
    }

    return pOut;
}


BOOL
IsCOMPort(
    PCWSTR pPort
)
{
    //
    // Must begin with szCom
    //
    if ( _wcsnicmp( pPort, szCOM, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

BOOL
IsLPTPort(
    PCWSTR pPort
)
{
    //
    // Must begin with szLPT
    //
    if ( _wcsnicmp( pPort, szLPT, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}




/* Message
 *
 * Displays a message by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
int Message(HWND hwnd, DWORD Type, int CaptionID, int TextID, ...)
{
    WCHAR   MsgText[2*MAX_PATH + 1];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        _vsnwprintf( MsgText, COUNTOF(MsgText), MsgFormat, vargs );
        va_end( vargs );

        MsgText[COUNTOF(MsgText) - 1] = L'\0';

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}


INT
ErrorMessage(
    HWND hwnd,
    DWORD dwStatus
)
{
    WCHAR   MsgCaption[MAX_PATH];
    PWSTR   pBuffer = NULL;
    INT     iRet = 0;

    FormatMessage(  FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    NULL,
                    dwStatus,
                    0,
                    (PWSTR) &pBuffer,
                    0,
                    NULL);

    if (pBuffer) {
        if (LoadString( hInst, IDS_LOCALMONITOR, MsgCaption,
                  sizeof MsgCaption / sizeof *MsgCaption) > 0) {

             iRet = MessageBox(hwnd, pBuffer, MsgCaption, MSG_ERROR);
        }

        LocalFree(pBuffer);
    }

    return iRet;
}


LPWSTR
AllocSplStr(
    LPCWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    return GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cbAlloc);
}


// -----------------------------------------------------------------------
//
// DEBUG Stuff
//
// -----------------------------------------------------------------------

DWORD SplDbgLevel = 0;

VOID cdecl DbgMsg( LPWSTR MsgFormat, ... )
{
    WCHAR   MsgText[1024];
    va_list pArgs;
    va_start( pArgs, MsgFormat);	

    wvsprintf(MsgText,MsgFormat, pArgs );
    wcscat( MsgText, L"\r");

    va_end( pArgs);
		
    OutputDebugString(MsgText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\debug.cpp ===
/*****************************************************************************
 *
 * $Workfile: debug.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/
#include "precomp.h"

#include "debug.h"

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations
HANDLE	g_hDebugFile;

///////////////////////////////////////////////////////////////////////////////
//  InitDebug

void
InitDebug( LPTSTR pszDebugFile )
{
	g_hDebugFile = CreateFile(	pszDebugFile,	// file name
								GENERIC_WRITE,			// access mode
								FILE_SHARE_WRITE | FILE_SHARE_READ,		// share mode
								NULL,					// security attributes
								OPEN_ALWAYS,			// creation
								FILE_ATTRIBUTE_NORMAL,	// file attributes
								NULL );				// template file
	if (g_hDebugFile == INVALID_HANDLE_VALUE)
	{
		DWORD dwError = GetLastError();
		//_RPT1(_CRT_WARN, "\t>ERROR!! CreateFile dwError = %d\n", dwError);
	}
 	_CrtSetReportMode(_CRT_WARN,  _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
	_CrtSetReportFile(_CRT_WARN, (_HFILE)g_hDebugFile);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);		

}	// InitDebug()


///////////////////////////////////////////////////////////////////////////////
//  DeInitDebug

void
DeInitDebug(void)
{
	if (g_hDebugFile)
	{
		CloseHandle(g_hDebugFile);
	}

}	// DeInitDebug()


///////////////////////////////////////////////////////////////////////////////
//  debugRPT -- used w/ the macros

void
debugRPT(char *p, int i)
{
	//_RPT2(_CRT_WARN, "%s %d\n", p, i);

}

///////////////////////////////////////////////////////////////////////////////
//  debugCSect -- used w/ the macros

void
debugCSect(char *p, int i, char *fileName, int lineNum, long csrc)
{
	//_RPT4(_CRT_WARN, "%s (%d) @%s %d", p, i, fileName, lineNum);
	//_RPT1(_CRT_WARN, " [recursioncount=(%ld)]\n", csrc);

}


///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug

DWORD	CMemoryDebug::m_dwMemUsed = 0;

///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug::CMemoryDebug

CMemoryDebug::CMemoryDebug()
{

}	// ::CMemoryDebug()
							

///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug::~CMemoryDebug

CMemoryDebug::~CMemoryDebug()
{

}	// ::~CMemoryDebug()


///////////////////////////////////////////////////////////////////////////////
//	operator new

void *
CMemoryDebug::operator new(size_t in s)
{
	m_dwMemUsed += s;
	//_RPT2(_CRT_WARN, "DEBUG -- operator new() ----- Bytes allocated = %d, Total Memory used upto date = %d\n", s, m_dwMemUsed);

	return (void *) new char[s];

}	// ::operator new()


///////////////////////////////////////////////////////////////////////////////
//	operator delete

void
CMemoryDebug::operator delete(void		in *p,
							  size_t	in s)
{
	m_dwMemUsed -= s;
	//_RPT2(_CRT_WARN, "DEBUG -- operator delete() ----- Bytes deleted = %d,Total Memory used upto date = %d\n", s, m_dwMemUsed);
	delete [] p;

}	// ::operator delete()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\pjlmon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved


Module Name:

Abstract:

Author:

Revision History:

--*/

#define USECOMM

#include "precomp.h"
#include <winioctl.h>
#include <ntddpar.h>


// ---------------------------------------------------------------------
// PROTO, CONSTANT, and GLOBAL
//
// ---------------------------------------------------------------------

DWORD   ProcessPJLString(PINIPORT, CHAR *, DWORD *);
VOID    ProcessParserError(DWORD);
VOID    InterpreteTokens(PINIPORT, PTOKENPAIR, DWORD);
BOOL    IsPJL(PINIPORT);
BOOL    WriteCommand(HANDLE, LPSTR);
BOOL    ReadCommand(HANDLE);

#define WAIT_FOR_WRITE                  100 // 0.1 sec
#define WAIT_FOR_DATA_TIMEOUT           100 // 0.1 sec
#define WAIT_FOR_USTATUS_THREAD_TIMEOUT 500 // 0.5 sec
#define GETDEVICEID                     IOCTL_PAR_QUERY_DEVICE_ID
#define MAX_DEVID                       1024

TCHAR   cszInstalledMemory[]    = TEXT("Installed Memory");
TCHAR   cszAvailableMemory[]    = TEXT("Available Memory");

BOOL
DllMain(
    IN HANDLE   hModule,
    IN DWORD    dwReason,
    IN LPVOID   lpRes
    )
/*++

Routine Description:
    Dll entry point

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&pjlMonSection);
            DisableThreadLibraryCalls(hModule);
            break;

        default:
            // do nothing
            ;
    }

    return TRUE;
}


VOID
ClearPrinterStatusAndIniJobs(
    PINIPORT    pIniPort
    )
{
    PORT_INFO_3 PortInfo3;

    if ( pIniPort->PrinterStatus ||
         (pIniPort->status & PP_PRINTER_OFFLINE) ) {

        pIniPort->PrinterStatus = 0;
        pIniPort->status &= ~PP_PRINTER_OFFLINE;

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        SetPort(NULL, pIniPort->pszPortName, 3, (LPBYTE)&PortInfo3);
    }

    SendJobLastPageEjected(pIniPort, ALL_JOBS, FALSE);
}


VOID
RefreshPrinterInfo(
    PINIPORT    pIniPort
    )
{
    //
    // Only one thread should write to the printer at a time
    //
    if ( WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->DoneWriting,
                                              WAIT_FOR_WRITE) ) {

        return;
    }

    //
    // If printer is power cycled and it does not talk back (but answers
    // PnP id) we got to clear the error on spooler to send jobs
    //
    ClearPrinterStatusAndIniJobs(pIniPort);
    if ( !IsPJL(pIniPort) ) {

        pIniPort->status &= ~PP_IS_PJL;
    }

    SetEvent(pIniPort->DoneWriting);
}


VOID
UstatusThread(
    HANDLE hPort
)
/*++

Routine Description:
    Unsolicited status information thread. This thread will continue to
    read unsolicited until it's asked to terminate, which will happen
    under one of these conditions:
        1) Receive EOJ confirmation from the printer.
        2) Timeout waiting for EOJ confirmation.
        3) The port is been closed.

Arguments:
    hPort   : IniPort structure for the port

Return Value:

--*/
{
    PINIPORT        pIniPort = (PINIPORT)((INIPORT *)hPort);
    HANDLE          hToken;

    SPLASSERT(pIniPort                              &&
              pIniPort->signature == PJ_SIGNATURE   &&
              (pIniPort->status & PP_THREAD_RUNNING) == 0);

    if ( IsPJL(pIniPort) )
        pIniPort->status |= PP_IS_PJL;


    SetEvent(pIniPort->DoneWriting);

    if ( !(pIniPort->status & PP_IS_PJL) )
        goto StopThread;

    pIniPort->status |= PP_THREAD_RUNNING;

    pIniPort->PrinterStatus     = 0;
    pIniPort->status           &= ~PP_PRINTER_OFFLINE;
    pIniPort->dwLastReadTime    = GetTickCount ();

    for ( ; ; ) {

        //
        // check if PP_RUN_THREAD has been cleared to terminate
        //
        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            if ( pIniPort->status & PP_INSTARTDOC ) {

                //
                // there's an active job, can't end the thread
                //
                pIniPort->status |= PP_RUN_THREAD;
            } else {

                DBGMSG(DBG_INFO,
                       ("PJLMon Read Thread for Port %ws Closing Down.\n",
                       pIniPort->pszPortName));

                pIniPort->status &= ~PP_THREAD_RUNNING;

                ClearPrinterStatusAndIniJobs(pIniPort);
                goto StopThread;
            }
        }

        //
        // check if the printer is bi-di
        //
        if (pIniPort->status & PP_IS_PJL) {

            (VOID)ReadCommand(hPort);

            //
            // If we are under error condition or if we have jobs pending
            // read status back from printer more frequently
            //
            if ( pIniPort->pIniJob                          ||
                 (pIniPort->status & PP_PRINTER_OFFLINE)    ||
                 (pIniPort->status & PP_WRITE_ERROR) ) {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadErrorTimeout);
            } else {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadIdleTimeoutOther);
            }

            if ( pIniPort->pIniJob &&
                 !(pIniPort->status & PP_PRINTER_OFFLINE) &&
                 !(pIniPort->status & PP_WRITE_ERROR) ) {

                //
                // Some printers are PJL bi-di, but do not send
                // EOJ. We want jobs to disappear from printman
                //
                SendJobLastPageEjected(pIniPort,
                                       GetTickCount() - dwReadThreadEOJTimeout,
                                       TRUE);
            }

            //
            // If we did not read from printer for more than a minute
            // and no more jobs talk to printer again
            //
            if ( !(pIniPort->status & PP_INSTARTDOC) &&
                 (GetTickCount() - pIniPort->dwLastReadTime) > 240000
)
                RefreshPrinterInfo(pIniPort);

        } else {

            //
            // exit the thread if printer is not PJL bi-di capable
            //
            Sleep(2000);
            pIniPort->status &= ~PP_RUN_THREAD;

            DBGMSG(DBG_TRACE, ("Set ~PP_RUN_THREAD because printer is not bi-di\n"));
        }
    }

StopThread:
    pIniPort->status &= ~PP_RUN_THREAD;
    pIniPort->status &= ~PP_THREAD_RUNNING;
    CloseHandle(pIniPort->DoneReading);
    pIniPort-> DoneReading = NULL;

    //
    // By closing the handle and then setting it to NULL we know the main
    // thread will not end up setting a wrong event
    //
    CloseHandle(pIniPort->WakeUp);
    pIniPort->WakeUp = NULL;
}


BOOL
CreateUstatusThread(
    PINIPORT pIniPort
)
/*++

Routine Description:
    Creates the Ustatus thread

Arguments:
    pIniPort    : IniPort structure for the port

Return Value:
    TRUE on succesfully creating the thread, else FALSE
--*/
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    DBGMSG(DBG_INFO, ("PJLMon Read Thread for Port %ws Starting.\n",
                      pIniPort->pszPortName));

    pIniPort->status |= PP_RUN_THREAD;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    pIniPort->WakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);

    if ( !pIniPort->WakeUp )
        goto Fail;
    //
    // manual-reset event, initially signal state
    //
    pIniPort->DoneReading = CreateEvent(NULL, TRUE, TRUE, NULL);
    if ( !pIniPort->DoneReading )
        goto Fail;

    ThreadHandle = CreateThread(NULL, 16*1024,
                                (LPTHREAD_START_ROUTINE)UstatusThread,
                                pIniPort,
                                0, &ThreadId);

    if ( ThreadHandle ) {

        SetThreadPriority(ThreadHandle, THREAD_PRIORITY_LOWEST);
        CloseHandle(ThreadHandle);
        return TRUE;
    }

Fail:

    if ( pIniPort->WakeUp ) {

        CloseHandle(pIniPort->WakeUp);
        pIniPort->WakeUp = NULL;
    }
    //
    //
    if (pIniPort-> DoneReading) 
    {
        CloseHandle (pIniPort-> DoneReading);
        pIniPort-> DoneReading = NULL;
    }

    pIniPort->status &= ~PP_RUN_THREAD;
    SetEvent(pIniPort->DoneWriting);

    return FALSE;
}


BOOL
WINAPI
PJLMonOpenPortEx(
    IN     LPTSTR       pszPortName,
    IN     LPTSTR       pszPrinterName,
    IN OUT LPHANDLE     pHandle,
    IN OUT LPMONITOR    pMonitor
)
/*++

Routine Description:
    Opens the port

Arguments:
    pszPortName     : Port name
    pszPrinterName  : Printer name
    pHandle         : Pointer to the handle to return
    pMonitor        : Port monitor function table

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort;
    BOOL        bRet = FALSE;
    BOOL        bInSem = FALSE;

    //
    // Validate port monitor
    //
    if ( !pMonitor                  ||
         !pMonitor->pfnOpenPort     ||
         !pMonitor->pfnStartDocPort ||
         !pMonitor->pfnWritePort    ||
         !pMonitor->pfnReadPort     ||
         !pMonitor->pfnClosePort ) {


        DBGMSG(DBG_WARNING,
               ("PjlMon: Invalid port monitors passed to OpenPortEx\n"));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Cleanup;
    }

    EnterSplSem();
    bInSem = TRUE;

    //
    // Is the port open already?
    //
    if ( pIniPort = FindIniPort(pszPortName) ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    pIniPort = CreatePortEntry(pszPortName);
    LeaveSplSem();
    bInSem = FALSE;

    if ( pIniPort &&
         (*pMonitor->pfnOpenPort)(pszPortName, &pIniPort->hPort) ) {

        *pHandle = pIniPort;
        CopyMemory((LPBYTE)&pIniPort->fn, (LPBYTE)pMonitor, sizeof(*pMonitor));

        //
        // Create the ustatus thread always
        // If printer is not PJL it will die by itself
        // We do not want to write to the printer in this thread to determine
        //      printer is PJL since that may take several seconds to fail
        //
        CreateUstatusThread(pIniPort);
        bRet = TRUE;
    } else {

        DBGMSG(DBG_WARNING, ("PjlMon: OpenPort "TSTR" : Failed\n", pszPortName));
    }

Cleanup:
    if ( bInSem ) {

        LeaveSplSem();
    }
    SplOutSem();

    return bRet;
}


BOOL
WINAPI
PJLMonStartDocPort(
    IN HANDLE  hPort,
    IN LPTSTR  pszPrinterName,
    IN DWORD   dwJobId,
    IN DWORD   dwLevel,
    IN LPBYTE  pDocInfo
)
/*++

Routine Description:
    Language monitor StartDocPort

Arguments:
    hPort           : Port handle
    pszPrinterName  : Printer name
    dwJobId         : Job identifier
    dwLevel         : Level of Doc info strucuture
    pDocInfo        : Pointer to doc info structure

Return Value:
    TRUE on success, FALSE on error

--*/
{

    PINIPORT            pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB             pIniJob = NULL;
    DWORD               cbJob;
    BOOL                bRet = FALSE;

    //
    // Validate parameters
    //
    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ||
         !pDocInfo ||
         !pszPrinterName ||
         !*pszPrinterName ) {

        SPLASSERT(pIniPort &&
                  pIniPort->signature == PJ_SIGNATURE &&
                  pDocInfo);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwLevel != 1 ) {

        SPLASSERT(dwLevel == 1);
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Serialize access to the port
    //
    if ( pIniPort->status & PP_INSTARTDOC ) {

        SetLastError(ERROR_BUSY);
        return FALSE;
    }

    cbJob   = sizeof(*pIniJob) + lstrlen(pszPrinterName) * sizeof(TCHAR)
                               + sizeof(TCHAR);
    pIniJob = (PINIJOB) AllocSplMem(cbJob);
    if ( !pIniJob ) {

        goto Cleanup;
    }

    pIniJob->pszPrinterName = wcscpy((LPTSTR)(pIniJob+1), pszPrinterName);

    if ( !OpenPrinter(pIniJob->pszPrinterName, &pIniJob->hPrinter, NULL) ) {

        DBGMSG(DBG_WARNING,
               ("pjlmon: OpenPrinter failed for "TSTR", last error %d\n",
                pIniJob->pszPrinterName, GetLastError()));

        goto Cleanup;
    }

    pIniPort->status |= PP_INSTARTDOC;

    bRet = (*pIniPort->fn.pfnStartDocPort)(pIniPort->hPort,
                                           pszPrinterName,
                                           dwJobId,
                                           dwLevel,
                                           pDocInfo);

    if ( !bRet ) {

        pIniPort->status &= ~PP_INSTARTDOC;
        goto Cleanup;
    }

    //
    // If Ustatus thread is not running then check if printer understands
    // PJL, unless we determined that printer does not understand PJL earlier
    //
    if ( !(pIniPort->status & PP_RUN_THREAD) &&
         !(pIniPort->status & PP_DONT_TRY_PJL) ) {

        CreateUstatusThread(pIniPort);
    }

    //
    // set PP_SEND_PJL flag here so the first write of the job
    // will try to send PJL command to initiate the job control
    //

    pIniJob->JobId = dwJobId;
    pIniJob->status |= PP_INSTARTDOC;

    EnterSplSem();
    if ( !pIniPort->pIniJob ) {

        pIniPort->pIniJob = pIniJob;
    } else {

        pIniJob->pNext = pIniPort->pIniJob;
        pIniPort->pIniJob = pIniJob;
    }
    LeaveSplSem();

    if ( pIniPort->status & PP_IS_PJL )
        pIniJob->status |= PP_SEND_PJL;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

Cleanup:

    if ( !bRet ) {

        if ( pIniJob )
            FreeIniJob(pIniJob);
    }

    return bRet;
}


BOOL
WINAPI
PJLMonReadPort(
    IN  HANDLE  hPort,
    OUT LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD pcbRead
)
/*++

Routine Description:
    Language monitor ReadPort

Arguments:
    hPort           : Port handle
    pBuffer         : Buffer to read data to
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return read count

Return Value:
    TRUE on success, FALSE on error
--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return (*pIniPort->fn.pfnReadPort)(pIniPort->hPort, pBuffer, cbBuf, pcbRead);
}


BOOL
WINAPI
PJLMonWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
)
/*++

Routine Description:
    Language monitor WritePort

Arguments:
    hPort           : Port handle
    pBuffer         : Data Buffer
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return written count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        ret;

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's the fist write of the job
    //
    if ( pIniPort->pIniJob &&
         (pIniPort->pIniJob->status & PP_SEND_PJL) ) {

        // PP_SEND_PJL is set if it's the first write of the job
        char string[256];

        if ( !WriteCommand(hPort, "\033%-12345X@PJL \015\012") ) {

            return FALSE;
        }

        //
        // clear PP_SEND_PJL here if we have successfully send a PJL command.
        //
        pIniPort->pIniJob->status &= ~PP_SEND_PJL;

        //
        // set PP_PJL_SENT meaning that we have successfully sent a
        // PJL command to the printer, though it doesn't mean that
        // we will get a successfully read. PP_PJL_SENT gets cleared in
        // StartDocPort.
        //
        pIniPort->pIniJob->status |= PP_PJL_SENT;

        sprintf(string, "@PJL JOB NAME = \"MSJOB %d\"\015\012",
                    pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        WriteCommand(hPort, "@PJL USTATUS JOB = ON \015\012@PJL USTATUS PAGE = OFF \015\012@PJL USTATUS DEVICE = ON \015\012@PJL USTATUS TIMED = 30 \015\012\033%-12345X");
    }

    //
    // writing to port monitor
    //
    ret = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, pBuffer,
                                       cbBuf, pcbWritten);

    if ( ret ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
    }

    if ( (!ret || pIniPort->PrinterStatus) &&
         (pIniPort->status & PP_THREAD_RUNNING) ) {

        //
        // By waiting for the UStatus thread to finish reading if there
        // is an error and printer sends unsolicited status
        // and user gets status on queue view before the win32 popup
        //
        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, INFINITE);
    }

    return ret;
}


BOOL
WINAPI
PJLMonEndDocPort(
   HANDLE   hPort
)
/*++

Routine Description:
    Language monitor EndDocPort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB     pIniJob;

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Find the job (which is the last)
    //
    pIniJob = pIniPort->pIniJob;

    if ( !pIniJob )
        DBGMSG(DBG_ERROR, ("No jobs?\n"));

    //
    // check if we had sent PJL command, i.e. if the printer is bi-di
    //
    if ( pIniJob && (pIniJob->status & PP_PJL_SENT) ) {

        //
        // if the printer is bi-di, tell printer to let us know when the job
        // is don't in the printer and we'll really EndDoc then. this is so
        // that we can continue to monitor the job status until the job is
        // really done in case there's an error occurs.
        // but some cheap printers like 4L, doesn't handle this EOJ command
        // reliably, so we time out if printer doesn't tell us EOJ after a
        // while so that we don't end up having the port open forever in this
        // case.
        //

        char    string[256];

        sprintf(string,
                "\033%%-12345X@PJL EOJ NAME = \"MSJOB %d\"\015\012\033%%-12345X",
                pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        pIniJob->TimeoutCount = GetTickCount();
        pIniJob->status &= ~PP_INSTARTDOC;
    }

    (*pIniPort->fn.pfnEndDocPort)(pIniPort->hPort);

    if ( pIniJob && !(pIniJob->status & PP_PJL_SENT) ) {

        //
        // This is not bi-di printer send EOJ so that spooler deletes it
        //
        SendJobLastPageEjected(pIniPort, pIniJob->JobId, FALSE);
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    // wake up the UStatus read thread if printer is bi-di

    if ( pIniPort->status & PP_THREAD_RUNNING )
        SetEvent(pIniPort->WakeUp);

    SetEvent(pIniPort->DoneWriting);

    return TRUE;
}


BOOL
WINAPI
PJLMonClosePort(
    HANDLE  hPort
)
/*++

Routine Description:
    Language monitor ClosePort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    //
    // Kill Ustatus thread if it is running
    //
    if (pIniPort->status & PP_RUN_THREAD) {

        pIniPort->status &= ~PP_RUN_THREAD;

        DBGMSG(DBG_TRACE, ("Set ~PP_RUN_THREAD from close port\n"));

        SetEvent(pIniPort->WakeUp);

        //
        // if UStatusThread is still running at this point,
        // wait utill it terminates, because we can't DeletePortEntry
        // until it terminates.
        //
        while (pIniPort->WakeUp)
            Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
    }

    if ( pIniPort->fn.pfnClosePort )
        (*pIniPort->fn.pfnClosePort)(pIniPort->hPort);

    EnterSplSem();
    DeletePortEntry(pIniPort);
    LeaveSplSem();

    return TRUE;
}


BOOL
WriteCommand(
    HANDLE hPort,
    LPSTR cmd
)
/*++

Routine Description:
    Write a command to the port

Arguments:
    hPort           : Port handle
    cmd             : Command buffer

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD cbWrite, cbWritten, dwRet;
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    cbWrite = strlen(cmd);

    dwRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, cmd, cbWrite, &cbWritten);

    if ( dwRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
        DBGMSG(DBG_INFO, ("PJLMON!No data Written\n"));
        if ( pIniPort->status & PP_THREAD_RUNNING )
            SetEvent(pIniPort->WakeUp);
    }

    return dwRet;
}


#define CBSTRING 1024

BOOL
ReadCommand(
    HANDLE hPort
)
/*++

Routine Description:
    Read a command from the port

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on successfully reading one or more commands, FALSE on error
--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    DWORD       cbRead, cbToRead, cbProcessed, cbPrevious;
    char        string[CBSTRING];
    DWORD       status = STATUS_SYNTAX_ERROR; //Value should not matter
    BOOL        bRet=FALSE;

    cbPrevious = 0;

    ResetEvent(pIniPort->DoneReading);

    cbToRead = CBSTRING - 1;

    for ( ; ; ) {

        if ( !PJLMonReadPort(hPort, &string[cbPrevious], cbToRead, &cbRead) )
            break;
        if ( cbRead ) {
            if (cbPrevious + cbRead > CBSTRING - 1)
            {
                bRet = FALSE;
                break;
            }
            string[cbPrevious + cbRead] = '\0';
            status = ProcessPJLString(pIniPort, string, &cbProcessed);
            if ( cbProcessed )
                bRet = TRUE;

            if (status == STATUS_END_OF_STRING ) {

                if ( cbProcessed )
                    strcpy(string, string+cbProcessed);
                cbPrevious = cbRead + cbPrevious - cbProcessed;
            }
        } else {

            SPLASSERT(!cbPrevious);
        }

        if ( status != STATUS_END_OF_STRING && cbRead != cbToRead )
            break;

        cbToRead = CBSTRING - cbPrevious - 1;
        if ( cbToRead == 0 )
        {
            DBGMSG(DBG_ERROR, 
                   ("ReadCommand cbToRead is 0 (buffer too small)\n"));
            bRet = FALSE;
            break;
        }
        Sleep(WAIT_FOR_DATA_TIMEOUT);
    }

    SetEvent(pIniPort->DoneReading);

    //
    // Update the time we last read from printer
    //
    if ( bRet )
        pIniPort->dwLastReadTime = GetTickCount();

    return bRet;
}


BOOL
WINAPI
PJLMonGetPrinterDataFromPort(
    HANDLE   hPort,
    DWORD   ControlID,
    LPTSTR  pValueName,
    LPTSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPTSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
)
/*++

Routine Description:
    GetPrinter data from port. Supports predefined commands/valuenames.

    When we support Value name commands (not supported by DeviceIoControl)
    we should check for startdoc -- MuhuntS

    This monitor function supports the following two functionalities,

         1. Allow spooler or language monitor to call DeviceIoControl to get
            information from the port driver vxd, i.e. ControlID != 0.
            And only port monitor support this functionality, language monitor
            doesn't, so language monitor just pass this kind of calls down to
            port monitor.

         2. Allow app or printer driver query language monitor for some device
            information by specifying some key names that both parties understand,
            i.e. ControlID == 0 && pValueName != 0. So when printer driver call
            DrvGetPrinterData DDI, gdi will call spooler -> language monitor
            to get specific device information, for example, UNIDRV does this
            to get installed printer memory from PJL printers thru PJLMON.
            Only language monitor support this functionality,
            port monitor doesn't.

Arguments:
    hPort           : Port handle
    ControId        : Control id
    pValueName      : Value name
    lpInBuffer      : Input buffer for the command
    cbinBuffer      : Input buffer size
    lpOutBuffer     : Output buffer
    cbOutBuffer     : Output buffer size
    lpcbReturned    : Set to the amount of data in output buffer on success

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
    if ( ControlID ) {

        if ( !pIniPort->fn.pfnGetPrinterDataFromPort ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return (*pIniPort->fn.pfnGetPrinterDataFromPort)(
                        pIniPort->hPort,
                        ControlID,
                        pValueName,
                        lpInBuffer,
                        cbInBuffer,
                        lpOutBuffer,
                        cbOutBuffer,
                        lpcbReturned);
    }

    //
    // Only 2 keys supported
    //
    if ( lstrcmpi(pValueName, cszInstalledMemory)   &&
         lstrcmpi(pValueName, cszAvailableMemory) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Wait for crrent job to print since we can't send a PJL command
    // in the middle of job
    //
    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    // make sure the first write succeeds
    // @@BEGIN_DDKSPLIT
    // WIN95C BUG 14299, ccteng, 5/18/95
    // @@END_DDKSPLIT
    // The multi-language printers (4M, 4ML, 4MP, 4V, 4SI), if you print a
    // PS print job, the memory resources claimed by the PS processor are not
    // release until you enter PCL or reset the printer with "EscE".
    //
    // So if we had just printed a PS job, the available memory will be
    // incorrect if we don't have the "EscE" here.

    if ( (pIniPort->status & PP_IS_PJL) &&
         WriteCommand(hPort, "\033E\033%-12345X@PJL INFO CONFIG\015\012") ) {

        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            bStopUstatusThread = TRUE;
            CreateUstatusThread(pIniPort);
        }

        // PJLMON currently only supports the following pValueName
        //  1. installed printer memory
        //  2. available printer memory

        if ( !lstrcmpi(pValueName, cszInstalledMemory) )
            pIniPort->dwInstalledMemory = 0;
        else if (!lstrcmpi(pValueName, cszAvailableMemory))
            pIniPort->dwAvailableMemory = 0;

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        WriteCommand(hPort,
                     "@PJL INFO MEMORY\015\012@PJL INFO STATUS\015\012");

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        if ( bStopUstatusThread ) {

            pIniPort->status &= ~PP_RUN_THREAD;
            SetEvent(pIniPort->WakeUp);
        }

        if ( !lstrcmpi(pValueName, cszInstalledMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                pIniPort->dwInstalledMemory ) {

                *((LPDWORD)lpOutBuffer) = pIniPort->dwInstalledMemory;

                bRet = TRUE;
            }
        } else if ( !lstrcmpi(pValueName, cszAvailableMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                 pIniPort->dwAvailableMemory)
            {
                *((LPDWORD)lpOutBuffer) = pIniPort->dwAvailableMemory;

                bRet = TRUE;
            }
        }

        if ( bStopUstatusThread ) {

            while (pIniPort->WakeUp)
                Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
        }

    }

    if ( !bRet )
        SetLastError(ERROR_INVALID_PARAMETER);

    SetEvent(pIniPort->DoneWriting);

    return bRet;
}


MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        NULL,                           // EnumPrinters not supported
        NULL,                           // OpenPort  not supported
        PJLMonOpenPortEx,
        PJLMonStartDocPort,
        PJLMonWritePort,
        PJLMonReadPort,
        PJLMonEndDocPort,
        PJLMonClosePort,
        NULL,                           // AddPort not supported
        NULL,                           // AddPortEx not supported
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        PJLMonGetPrinterDataFromPort,
        NULL                            // SetPortTimeOuts not supported
    }
};


LPMONITOREX
WINAPI
InitializePrintMonitor(
    IN     LPTSTR      pszRegistryRoot
)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll
    lpMonitor       : Pointer to monitor fucntion table to be filled

Return Value:
    TRUE on successfully initializing the monitor, false on error.

--*/
{

    if ( !pszRegistryRoot || !*pszRegistryRoot ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if ( UpdateTimeoutsFromRegistry(pszRegistryRoot) != ERROR_SUCCESS ) {

        return NULL;
    }


    return &MonitorEx;
}


#define NTOKEN  20

DWORD
ProcessPJLString(
    PINIPORT    pIniPort,
    LPSTR       pInString,
    DWORD      *lpcbProcessed
)
/*++

Routine Description:
    Process a PJL string read from the printer

Arguments:
    pIniPort        : Ini port
    pInString       : Input string to process
    lpcbProcessed   : On return set to the amount of data processed

Return Value:
    Status value of the processing

--*/
{
    TOKENPAIR tokenPairs[NTOKEN];
    DWORD nTokenParsedRet;
    LPSTR lpRet;
    DWORD status = 0;

    lpRet = pInString;

    DBGMSG(DBG_TRACE, ("String to process: <"TSTR">\n", pInString));

    for (*lpcbProcessed = 0; *pInString != 0; pInString = lpRet) {

        //
        // hack to determine if printer is bi-di.  LJ 4 does not have p1284
        // device ID so we do PCL memory query and see if it returns anything
        //
        if (!(pIniPort->status & PP_IS_PJL) &&
            !mystrncmp(pInString, "PCL\015\012INFO MEMORY", 16) )
            pIniPort->status |= PP_IS_PJL;

        status = GetPJLTokens(pInString, NTOKEN, tokenPairs,
                              &nTokenParsedRet, &lpRet);

        if (status == STATUS_REACHED_END_OF_COMMAND_OK) {

            pIniPort->status |= PP_IS_PJL;
            InterpreteTokens(pIniPort, tokenPairs, nTokenParsedRet);
        } else {

            ProcessParserError(status);
        }

        //
        // if a PJL command straddles between buffers
        //
        if (status == STATUS_END_OF_STRING)
            break;

        *lpcbProcessed += (DWORD)(lpRet - pInString);
    }

    return status;
}


DWORD
SeverityFromPjlStatus(
    DWORD   dwPjlStatus
    )
{
    if ( dwPjlStatus >= 10000 && dwPjlStatus < 12000 ) {

        //
        // 10xyz
        // 11xyz : load paper (paper available on another tray)
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus >= 30000 && dwPjlStatus < 31000 ) {

        //
        // 30xyz : Auto continuable errors
        //
        return PORT_STATUS_TYPE_WARNING;

    } else if ( dwPjlStatus >= 35000 && dwPjlStatus < 36000 ) {

        //
        // 35xyz : Potential operator intervention conditions
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus > 40000 && dwPjlStatus < 42000 ) {

        //
        // 40xyz : Operator intervention required
        // 41xyz : Load paper errors
        //
        return PORT_STATUS_TYPE_ERROR;
    }

    DBGMSG(DBG_ERROR,
           ("SeverityFromPjlStatus: Unknown status %d\n", dwPjlStatus));
    return PORT_STATUS_TYPE_INFO;
}


VOID
InterpreteTokens(
    PINIPORT pIniPort,
    PTOKENPAIR tokenPairs,
    DWORD nTokenParsed
)
/*++

Routine Description:
    Interpret succesfully read PJL tokens

Arguments:
    pIniPort        : Ini port
    tokenPairs      : List of token pairs
    nTokenParsed    : Number of token pairs

Return Value:
    None

--*/
{
    DWORD                   i, OldStatus;
    PJLTOPRINTERSTATUS     *pMap;
    PORT_INFO_3             PortInfo3;
    DWORD                   dwSeverity = 0;
    HANDLE                  hToken;

    OldStatus = pIniPort->PrinterStatus;
    pIniPort->PrinterStatus = 0;

    for (i = 0; i < nTokenParsed; i++) {

        // DBGMSG(DBG_INFO, ("pjlmon!Token=0x%x, Value=%d\n",
        //                   tokenPairs[i].token, tokenPairs[i].value));

        switch(tokenPairs[i].token) {

        case TOKEN_INFO_STATUS_CODE:
        case TOKEN_USTATUS_DEVICE_CODE:

            for (pMap = PJLToStatus; pMap->pjl; pMap++) {

                if (pMap->pjl == tokenPairs[i].value) {

                    pIniPort->PrinterStatus = pMap->status;
                    dwSeverity = SeverityFromPjlStatus(pMap->pjl);
                    if ( dwSeverity == PORT_STATUS_TYPE_ERROR )
                        pIniPort->status |= PP_PRINTER_OFFLINE;
                    else
                        pIniPort->status &= ~PP_PRINTER_OFFLINE;
                    break;
                }
            }

            if ( pMap->pjl && pMap->pjl == tokenPairs[i].value )
                break;

            //
            // some printers use this to signal online/ready
            //
            if ( tokenPairs[i].value == 10001  ||
                 tokenPairs[i].value == 10002  ||
                 tokenPairs[i].value == 11002 ) {

                pIniPort->status       &= ~PP_PRINTER_OFFLINE;
                pIniPort->PrinterStatus = 0;
                dwSeverity              = 0;
            }


            //
            // background or foreground paper out
            //
            if ( tokenPairs[i].value > 11101 && tokenPairs[i].value < 12000  ||
                 tokenPairs[i].value > 41101 && tokenPairs[i].value < 42000 ) {

                pIniPort->PrinterStatus  = PORT_STATUS_PAPER_OUT;

                if ( tokenPairs[i].value > 4000 ) {

                    dwSeverity           = PORT_STATUS_TYPE_ERROR;
                    pIniPort->status    |= PP_PRINTER_OFFLINE;
                } else {

                    dwSeverity = PORT_STATUS_TYPE_WARNING;
                }
            } else if (tokenPairs[i].value > 40000) {

                pIniPort->PrinterStatus = PORT_STATUS_USER_INTERVENTION;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }

            break;

        case TOKEN_INFO_STATUS_ONLINE:
        case TOKEN_USTATUS_DEVICE_ONLINE:

            // DBGMSG(DBG_INFO, ("PJLMON:ONLINE = %d\n", tokenPairs[i].value));

            if (tokenPairs[i].value) {

                pIniPort->status        &= ~PP_PRINTER_OFFLINE;
                dwSeverity = pIniPort->PrinterStatus ? PORT_STATUS_TYPE_WARNING :
                                                       0;
            } else {

                if ( !pIniPort->PrinterStatus )
                    pIniPort->PrinterStatus = PORT_STATUS_OFFLINE;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }
            break;

        case TOKEN_USTATUS_JOB_NAME_MSJOB:

            DBGMSG(DBG_TRACE, ("EOJ for %d\n", tokenPairs[i].value));

            SendJobLastPageEjected(pIniPort, (DWORD)tokenPairs[i].value, FALSE);
            break;

        case TOKEN_INFO_CONFIG_MEMORY:
        case TOKEN_INFO_CONFIG_MEMORY_SPACE:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

            DBGMSG(DBG_TRACE, ("PJLMON installed memory %d\n", tokenPairs[i].value));

            pIniPort->dwInstalledMemory = (DWORD)tokenPairs[i].value;
            break;

        case TOKEN_INFO_MEMORY_TOTAL:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

            DBGMSG(DBG_TRACE, ("PJLMON available memory %d\n", tokenPairs[i].value));

            pIniPort->dwAvailableMemory = (DWORD)tokenPairs[i].value;
            break;

        default:
            break;
        }
    }

    if ( OldStatus != pIniPort->PrinterStatus ) {

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        PortInfo3.dwStatus      = pIniPort->PrinterStatus;
        PortInfo3.dwSeverity    = dwSeverity;

        if ( !SetPort(NULL,
                      pIniPort->pszPortName,
                      3,
                      (LPBYTE)&PortInfo3) ) {

            DBGMSG(DBG_WARNING,
                   ("pjlmon: SetPort failed %d (LE: %d)\n",
                    pIniPort->PrinterStatus, GetLastError()));

            pIniPort->PrinterStatus = OldStatus;
        }
    }
}


VOID
ProcessParserError(
    DWORD status
)
/*++

Routine Description:
    Print error messages on parsing error

Arguments:
    status  : status

Return Value:
    None

--*/
{
#ifdef DEBUG
    LPSTR pString;

    switch (status)
    {
    case STATUS_REACHED_END_OF_COMMAND_OK:
        pString = "STATUS_REACHED_END_OF_COMMAND_OK\n";
        break;

    case STATUS_CONTINUE:
        pString = "STATUS_CONTINUE\n";
        break;

    case STATUS_REACHED_FF:
        pString = "STATUS_REACHED_FF\n";
        break;

    case STATUS_END_OF_STRING:
        pString = "STATUS_END_OF_STRING\n";
        break;

    case STATUS_SYNTAX_ERROR:
        pString = "STATUS_SYNTAX_ERROR\n";
        break;

    case STATUS_ATPJL_NOT_FOUND:
        pString = "STATUS_ATPJL_NOT_FOUND\n";
        break;

    case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
        pString = "STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n";
        break;

    default:
        pString = "INVALID STATUS RETURNED!!!!!!\n";
        break;
    };

    OutputDebugStringA(pString);
#endif
}


#define MODEL                       "MODEL:"
#define MDL                         "MDL:"
#define COMMAND                     "COMMAND SET:"
#define CMD                         "CMD:"
#define COLON                       ':'
#define SEMICOLON                   ';'


LPSTR
FindP1284Key(
    PINIPORT    pIniPort,
    LPSTR   lpKey
    )
/*++

Routine Description:
    Find the 1284 key identifying the device id

Arguments:
    status  : status

Return Value:
    Pointer to the command string, NULL if not found.

--*/
{
    LPSTR   lpValue;                // Pointer to the Key's value
    WORD    wKeyLength;             // Length for the Key (for stringcmps)
    LPSTR   ret = NULL;

    // While there are still keys to look at.

    DBGMSG(DBG_TRACE, ("PJLMon!DeviceId : <"TSTR">\n", lpKey));

    while (lpKey && *lpKey) {

        //
        // Is there a terminating COLON character for the current key?
        //
        if (!(lpValue = mystrchr(lpKey, COLON)) ) {

            //
            // N: OOPS, somthing wrong with the Device ID
            //
            return ret;
        }

        //
        // The actual start of the Key value is one past the COLON
        //
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (WORD)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        if ( *lpKey == 'C' ) {

            //
            // Look for COMMAND SET or CMD
            //
            if ( !mystrncmp(lpKey, COMMAND, wKeyLength) ||
                 !mystrncmp(lpKey, CMD, wKeyLength) ) {

                ret = lpValue;
            }
        }

        // Go to the next Key

        if ( lpKey = mystrchr(lpValue, SEMICOLON) ) {

            *lpKey = '\0';
            ++lpKey;
        }
    }

    return ret;
}


BOOL
IsPJL(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Finds out if the printer is a PJL bi-di printer

Arguments:
    pIniPort  : Points to an INIPORT

Return Value:
    TRUE if printer is PJL bi-di, else FALSE

    On failure PP_DONT_TRY_PJL is set

--*/
{
    char        szID[MAX_DEVID];
    DWORD       cbRet;
    LPSTR       lpCMD;
    HANDLE      hPort = (HANDLE)pIniPort;
    BOOL        bRet = FALSE;

    //
    // for printers that supports P1284 plug and play like LJ 4L, DJ540.
    // we parse the COMMAND string and see if PJL is supported
    //
    if (pIniPort->fn.pfnGetPrinterDataFromPort) {

        //
        // Only try P1284 if port monitor supports DeviceIOCtl
        //
        memset((LPBYTE)szID, 0, sizeof(szID));
        cbRet = 0;
        if ((*pIniPort->fn.pfnGetPrinterDataFromPort)
                (pIniPort->hPort, GETDEVICEID, NULL, NULL,
                    0, (LPWSTR)szID, sizeof(szID), &cbRet)
            && cbRet) {

            //
            // succeeded the P1284 plug and play protocol
            //
            szID[cbRet] = '\0';

            if ( lpCMD = FindP1284Key(pIniPort, szID) ) {

                // found the COMMAND string

                while (*lpCMD) {

                    //
                    // look for "PJL"
                    //
                    if ( lpCMD[0] == 'P' && lpCMD[1] == 'J' && lpCMD[2] == 'L' ){

                        pIniPort->status &= ~PP_DONT_TRY_PJL;
                        bRet = TRUE;
                        goto Cleanup;
                    }

                    lpCMD++;
                }

                pIniPort->status |= PP_DONT_TRY_PJL;
                goto Cleanup;
            }
        }

        //
        // fall thru to try PJL bi-di if we failed the P1284 communication
        // or P1284 didn't return a COMMAND string
        //
    }

    //
    // for printers that don't support P1284 plug and play, but support PJL
    // language command, like LJ 4 and 4M. we try to write/read PJL
    // command and see if it succeeds.
    // if we can't set the time outs we don't want to try to read, just fail.
    //
    if ( pIniPort->fn.pfnSetPortTimeOuts &&
         !(pIniPort->status & PP_DONT_TRY_PJL)) {

        COMMTIMEOUTS CTO;

        memset((LPSTR)&CTO, 0, sizeof(CTO));
        CTO.ReadTotalTimeoutConstant = 5000;
        CTO.ReadIntervalTimeout = 200;
        if ( !(*pIniPort->fn.pfnSetPortTimeOuts)(pIniPort->hPort, &CTO, 0) ) {

            goto Cleanup;
        }

        // This <ESC>*s1M is a PCL5 command to determine the amount of memory
        // in a PCL5 printer, and if the printer is PCL5 and bi-di capable,
        // it will return "PCL\015\012INFO MEMORY".
        // See PJL Tech Ref Manual page 7-21.

        pIniPort->status &= ~PP_IS_PJL;

        if ( !WriteCommand(hPort, "\033*s1M") )
            goto Cleanup;

        // ReadCommand->ProcessPJLString will set PP_IS_PJL
        // if we read any valid PJL command back from the printer

        if ( !ReadCommand(hPort) ) {

            //
            // We have jumped through the hoop to determin if this printer can
            // understand PJL.  It DOES NOT.  We are not going to try again.
            // until there is a printer change.
            //
            pIniPort->status |= PP_DONT_TRY_PJL;
        }

        if (pIniPort->status & PP_IS_PJL) {

            bRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( bRet ) {

        WriteCommand(hPort, "\033%-12345X@PJL \015\012@PJL USTATUS TIMED 30 \015\012\033%-12345X");
        pIniPort->dwLastReadTime = GetTickCount();
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\coreui.h ===
/*****************************************************************************
 *
 * $Workfile: CoreUI.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/Common/CoreUI.h $
 * 
 * 14    9/17/97 2:45p Dsnelson
 * For XcvData need the port name to be the first element of the data
 * structure pass in.
 * 
 * 13    9/09/97 2:52p Dsnelson
 * Changed the port info struct. ( resolved multiple memory issues )
 * 
 * 12    9/03/97 4:24p Dsnelson
 * Updated SNMP Member structures
 * 
 * 11    8/14/97 4:54p Becky
 * Added DELETE_PORT_DATA_1 for deleting a port using XcvData().
 * 
 * 10    7/25/97 10:12a Becky
 * Changed COREUI_DATA_1 to use extension bytes for config port UI.
 * 
 * 9     7/23/97 12:12p Becky
 * Modified the struct CORE_UIDATA_1 to include info needed for
 * configuration.
 * 
 * 8     7/17/97 5:14p Becky
 * Added Struct CORE_UIDATA_1
 * 
 * 7     7/15/97 12:26p Becky
 * 
 * 6     7/15/97 11:18a Becky
 * 
 * 5     7/15/97 12:20p Binnur
 * core ui changes -- again!
 * 
 * 3     7/15/97 11:06a Becky
 * Updated the Core Add Port UI structure
 * 
 * 2     7/11/97 4:45p Becky
 * Just getting started.
 * 
 * 1     7/11/97 3:14p Binnur
 * Initial file
 * 
 *****************************************************************************/

#ifndef INC_COREUI_H
#define INC_COREUI_H

/***************************************************************************** 
 *
 * Important Note: This file defines the interface between the UI pieces of the
 *	standard TCP/IP port monitor. Changes to this interface will impact the 
 *	existing UI pieces.
 * 
 *****************************************************************************/

#ifndef	DllExport
#define	DllExport	__declspec(dllexport)
#endif

#include "tcpmon.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
// LocalCoreAddPortUI -- 
//	Return Codes:
//		NO_ERROR if successful
//		ERROR_INSUFFICIENT_BUFFER if buffer size is small
//		ERROR_INVALID_LEVEL	if version is not supported
DWORD DllExport CoreAddPortUI(	HWND hWnd,				// parent window handle
								PPORT_DATA_1 pData,	// Input and Output data, see above structure for which items are input and which are output.
								DWORD dwDeviceType,		// determined by the core UI -- the type of device returned by GetDeviceType (ERROR_DEVICE_NOT_FOUND, SUCCESS_DEVICE_SINGLE_PORT, SUCCESS_DEVICE_MULTI_PORT, or SUCCESS_DEVICE_UNKNOWN)
								PDWORD pcbExtensionDataSizeNeeded,	// needed buffer size, refers to pData->pExtensionData, (input and output).
								DWORD  *pdwUserPressed);// output, if set to IDOK then the port is created otherwise it is treated as IDCANCEL, the main dialog is left open for further user input/changes.

BOOL DllExport CoreConfigPortUI(HWND hWndParent);
BOOL DllExport CoreDeletePortUI(HWND hWndParent);

#ifdef __cplusplus
}
#endif


#endif	// INC_COREUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\util.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

--*/

#include "precomp.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
MODULE_DEBUG_INIT( DBG_WARN|DBG_ERROR, DBG_ERROR );
#endif
// @@END_DDKSPLIT

CRITICAL_SECTION pjlMonSection      = {0,0,0,0,0,0};

PINIPORT pIniFirstPort  = NULL;

DWORD dwReadThreadErrorTimeout;
DWORD dwReadThreadEOJTimeout;
DWORD dwReadThreadIdleTimeoutOther;

TCHAR cszEOJTimeout[]        = TEXT("EOJTimeout");


VOID
SplInSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread != (HANDLE) UIntToPtr(GetCurrentThreadId()) ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Not in spooler semaphore !!\n"));
    }
}


VOID
SplOutSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread == (HANDLE) UIntToPtr(GetCurrentThreadId()) ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Inside spooler semaphore !!\n"));
    }
}

VOID
EnterSplSem(
   VOID
    )
{
    EnterCriticalSection(&pjlMonSection);
}


VOID
LeaveSplSem(
   VOID
    )
{
    SplInSem();
    LeaveCriticalSection(&pjlMonSection);
}


VOID
UpdateRegistryValue(
    IN     HKEY     hKey,
    IN     LPCTSTR  cszValueName,
    OUT    LPDWORD  pdwValue,
    IN     DWORD    dwDefault,
    IN OUT LPDWORD  pdwLastError
    )
/*++

Routine Description:
    Gets value assoicated with give value name from the registry. If value name
    is not found default value is written to registry.

    On error last error value is set to pdwLastError.

Arguments:
    hKey         : Registry key under which value should be searched
    cszValueName : Value name to search in the registry
    pdwValue     : On return will have the value
    dwDefault    : If value name not found in the registry set to this value
    pdwLastError : On error set last error to this

Return Value:
    None

--*/
{
    DWORD   dwSize = sizeof(*pdwValue);

    if ( *pdwLastError != ERROR_SUCCESS )
        return;

    if ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                          cszValueName,
                                          NULL,
                                          NULL,
                                          (LPBYTE)pdwValue,
                                          &dwSize) ) {

        *pdwValue = dwDefault;
        *pdwLastError = RegSetValueEx(hKey,
                                      cszValueName,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)pdwValue,
                                      sizeof(*pdwValue));
    }

}


DWORD
UpdateTimeoutsFromRegistry(
    IN LPTSTR      pszRegistryRoot
    )
/*++

Routine Description:
    Get the timeout values from the registry, or initialize registry with
    default values if entries are not found.

    Users/apps can change the registry to change the behavior.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    ERROR_SUCCESS on success, else last error value

--*/
{
    HKEY    hKey;
    DWORD   dwLastError = ERROR_SUCCESS;

    dwLastError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegistryRoot,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &hKey,
                                 NULL);

    if ( dwLastError != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    UpdateRegistryValue(hKey,
                        cszEOJTimeout,
                        &dwReadThreadEOJTimeout,
                        READ_THREAD_EOJ_TIMEOUT,
                        &dwLastError);

    dwReadThreadErrorTimeout        = READ_THREAD_ERROR_WAITTIME;
    dwReadThreadIdleTimeoutOther    = READ_THREAD_IDLE_WAITTIME;

    RegCloseKey(hKey);

Cleanup:

    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_ERROR,
               ("UpdateTimeoutsFromRegistry: Failed with %d", dwLastError));
    }

    return dwLastError;
}


PINIPORT
FindIniPort(
   IN LPTSTR pszName
    )
{
    PINIPORT    pIniPort = pIniFirstPort;

    if ( !pszName || !*pszName )
        return NULL;

    SplInSem();

    while ( pIniPort && lstrcmpi(pszName, pIniPort->pszPortName))
      pIniPort = pIniPort->pNext;

   return pIniPort;
}


PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    )
/*++

Routine Description:
    Creates a IniPort entry for a port. Needs to be called inside monitor
    critical section.

Arguments:
    pszPortName       : Name of the port

Return Value:
      On success pointer to the IniPort stucture.
      On failure NULL

--*/
{
    PINIPORT    pIniPort, pPort;
    HANDLE      DoneWriting = NULL;

    SplInSem();

    DoneWriting = CreateEvent(NULL, FALSE, TRUE, NULL);
    if ( !DoneWriting )
        return NULL;

    pIniPort = (PINIPORT) AllocSplMem(sizeof(*pIniPort));
    if ( !pIniPort ) {

        CloseHandle(DoneWriting);
        return NULL;
    }

    pIniPort->pszPortName       = AllocSplStr(pszPortName);

    if ( !pIniPort->pszPortName ) {

        CloseHandle(DoneWriting);
        FreeSplMem(pIniPort);
        return NULL;
    }

    pIniPort->pNext         = NULL;
    pIniPort->signature     = PJ_SIGNATURE;
    pIniPort->DoneWriting   = DoneWriting;

    pIniPort->pNext         = pIniFirstPort;
    pIniFirstPort           = pIniPort;

    return pIniPort;
}


VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    )
/*++

Routine Description:
    Deletes a port entry. Needs to be called inside monitor critical section

Arguments:
    pIniPort    : Pointer to the IniPort structure to be deleted

Return Value:

--*/
{
    SplInSem();

    if ( pIniPort == pIniFirstPort ) {

        pIniFirstPort = pIniPort->pNext;
    } else {

        PINIPORT    pPort;

        pPort = pIniFirstPort;
        while ( pPort && pPort->pNext != pIniPort )
            pPort = pPort->pNext;

        if (pPort) {

            pPort->pNext = pIniPort->pNext;
        } else {

            DBGMSG(DBG_ERROR, ("pjlmon: DeletePortEntry port not found\n"));
            return;
        }
    }

    CloseHandle(pIniPort->DoneWriting);
    FreeIniJobs(pIniPort);
    FreeSplStr(pIniPort->pszPortName);
    FreeSplMem(pIniPort);

    return;
}


VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    )
/*++

Routine Description:
    Deletes a job entry.

Arguments:
    pIniJob    : Pointer to the IniJob structure to be deleted

Return Value:
    None

--*/
{
    SPLASSERT(pIniJob);
    if ( pIniJob->hPrinter )
        ClosePrinter(pIniJob->hPrinter);
    FreeSplMem(pIniJob);
}


VOID
FreeIniJobs(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Free all the InJob structures assigned to this port

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed

--*/
{
    PINIJOB pIniJob, pIniNextJob;

    EnterSplSem();
    pIniJob = pIniPort->pIniJob;
    while ( pIniJob ) {

        pIniNextJob = pIniJob->pNext;
        FreeIniJob(pIniJob);
        pIniJob = pIniNextJob;
    }

    pIniPort->pIniJob = NULL;
    LeaveSplSem();
}


VOID
SendLastPageEjectedForIniJob(
    PINIPORT    pIniPort,
    PINIJOB     pIniJob
    )
{
    SplInSem();

    if ( !SetJob(pIniJob->hPrinter, pIniJob->JobId, 0,
                 NULL, JOB_CONTROL_LAST_PAGE_EJECTED) ) {

        DBGMSG(DBG_WARNING,
               ("SetJob failed with last error %d\n", GetLastError()));
    }
}


PINIJOB
FindIniJobFromJobId(
    PINIPORT    pIniPort,
    DWORD       dwJobId,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pCur, pPre, pIniJob;

    SplInSem();

    //
    // If JOB_RESTART is given there will be multiple jobs with same id
    // we need to find the last entry with given id in the list
    //
    for ( pCur = pIniPort->pIniJob, pPre = pIniJob = *ppPrevIniJob = NULL ;
          pCur ;
          pPre = pCur, pCur = pCur->pNext ) {

        if ( pCur->JobId == dwJobId ) {

            *ppPrevIniJob   = pPre;
            pIniJob         = pCur;
        }
    }

    return pIniJob;
}


PINIJOB
FindFirstIniJobTimedOut(
    PINIPORT    pIniPort,
    DWORD       dwTime,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pIniJob = pIniPort->pIniJob;

    SplInSem();
    *ppPrevIniJob = NULL;

    //
    // Look for a job not in STARTDOC and timedout
    //
    while ( pIniJob &&
            ( (pIniJob->status & PP_INSTARTDOC) ||
               pIniJob->TimeoutCount > dwTime ) ) {

        *ppPrevIniJob = pIniJob;
        pIniJob = pIniJob->pNext;
    }

    if ( !pIniJob )
        *ppPrevIniJob = NULL;

    return pIniJob;
}


VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    )
/*++

Routine Description:
    Send LastPageEjected notification for 1 or more jobs to spooler

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed
    dwValue     : if bTime is TRUE send EOJ to any jobs rcvd before dwValue
                  else dwValue is JobId -- ALL_JOBS is for all jobs
    bTime       : Tells how to interpret dwValue

--*/
{
    PINIJOB pIniJob;

    EnterSplSem();
    //
    // JobId == ALL_JOBS is a special case where we want to send LastPage
    // ejected for all jobs pending
    //
    if ( !bTime && dwValue == ALL_JOBS ) {

        pIniJob = pIniPort->pIniJob;
        pIniPort->pIniJob = NULL;

        while ( pIniJob ) {

            PINIJOB pTempJob = pIniJob;

            SendLastPageEjectedForIniJob(pIniPort, pIniJob);
            pIniJob = pIniJob->pNext;
            FreeIniJob(pTempJob);
        }

    } else {

        PINIJOB pPrevIniJob = NULL;

        pIniJob = pIniPort->pIniJob;

        //
        // If bTime we want to send LastPageEjected for all jobs timedout
        //
        if ( bTime )  {

            pIniJob = FindFirstIniJobTimedOut(pIniPort, dwValue, &pPrevIniJob);
        } else {

            pIniJob = FindIniJobFromJobId(pIniPort, dwValue, &pPrevIniJob);
        }

        if ( pIniJob ) {

            //
            // Send notifications for any previous jobs too
            //
            if ( pIniPort->pIniJob == pIniJob )
                pIniPort->pIniJob = NULL;
            else
                pPrevIniJob->pNext = NULL;

            do {

                SendLastPageEjectedForIniJob(pIniPort, pIniJob);

                pPrevIniJob = pIniJob;
                pIniJob = pIniJob->pNext;
                FreeIniJob(pPrevIniJob);
            } while ( pIniJob );
        }
    }

    LeaveSplSem();
}

// -----------------------------------------------------------------------
//
// String helper function to remove crt dependency
//
// -----------------------------------------------------------------------
int
mystrnicmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}


LPSTR
mystrchr(
    LPSTR cs,
    char c
)
{
    while (*cs != 0)
    {
        if (IsDBCSLeadByte(*cs))
          cs++;
        else
        if (*cs == c)
            return cs;
        cs++;
    }

    // fail to find c in cs
    return NULL;
}


int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}


// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\pjlmon\parsepjl.c ===
/*++

Copyright (c) 1994 - 2000  Microsoft Corporation

Module Name:
    
    PARSEPJL.C
    
Abstract:
    
    Handles parsing of PJL printer response streams into token\value pairs.

--*/


/*
Currently returns tokens for (see enum in parsepjl.h for token values):
@PJL ECHO MSSYNC # ->#

@PJL INFO MEMORY
TOTAL=#   ->#
LARGEST=# ->#

@PJL INFO STATUS
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

@PJL INQUIRE INTRAY?SIZE   (? is 1,2,3 or 4)
LEGAL(or other PJL paper size) ->constant from DM... list in PRINT.H 

@PJL INFO CONFIG
MEMORY=# ->#
  
@PJL USTATUS JOB
END -> returns token with zero for value
  
@PJL USTATUS JOB
NAME="MSJOB #" ->#

added

@PJL USTATUS DEVICE
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

*/

#include "precomp.h"

#define FF 12
#define CR 13
#define LF 10
#define TAB 9
#define SPACE 32

#define OK_IF_FF_FOUND    TRUE
#define ERROR_IF_FF_FOUND FALSE
#define TOKEN_BASE_NOT_USED 0
#define ACTION_NOT_USED 0
#define PARAM_NOT_USED 0
/* returned as value for TOKEN_USTATUS_JOB_END */
#define VALUE_RETURED_FOR_VALUELESS_TOKENS  0  

extern KeywordType readBackCommandKeywords[]; 
extern KeywordType infoCatagoryKeywords[]; 
extern KeywordType inquireVariableKeywords[];
extern KeywordType traySizeKeywords[];
extern KeywordType echoKeywords[];
extern KeywordType infoConfigKeywords[];
extern KeywordType ustatusKeywords[];
extern KeywordType ustatusJobKeywords[];
extern KeywordType ustatusDeviceKeywords[];

/* Fuctions called when a string in keyword is found */
void TokenFromParamValueFromNumberFF
   (ParseVarsType *pParseVars, ParamType);
void SetNewList(ParseVarsType *pParseVars,
   ParamType);
void GetTotalAndLargestFF(ParseVarsType *pParseVars,ParamType param);
void GetCodeAndOnlineFF(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParamFF(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromNumberEOLFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromBooleanEOL(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromStringEOL(ParseVarsType *pParseVars,ParamType param);


/* Fuctions called when no string in a keywords list is found */
void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars);
void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars);


/* Helper Functions */
void StoreToken(ParseVarsType *pParseVars, DWORD dwToken);
BOOL StoreTokenValueAndAdvancePointer
   (ParseVarsType *pParseVars, UINT_PTR dwValue);
void  ExpectFinalCRLFFF(ParseVarsType *pParseVars);
BOOL  SkipPastNextCRLF(ParseVarsType *pParseVars);
int GetPositiveInteger(ParseVarsType *pParseVars);
BOOL AdvancePointerPastString
   (ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipOverSpaces(ParseVarsType *pParseVars);
int LookForKeyword(ParseVarsType *pParseVars);
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipPastFF(ParseVarsType *pParseVars);
void ExpectFinalFF(ParseVarsType *pParseVars);

/* Helper Strings */
char lpCRLF[] = "\r\n";
char lpQuoteCRLF[] = "\"\r\n";

/*
Below are the Lists that drive the parsing.  The main loop of this 
parser looks through the keywords in the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If a FF is found in the input stream rather than a keyword, then the 
parser returns.  The return value is determined using the bFormFeedOk 
element of the ListType structure.

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

The tokenBaseValue element is a number to which the index in the
keyword's list of strings will added to calculate the token number 
corresponding to the indexed string.
*/

ListType readBackCommandList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   readBackCommandKeywords /* INFO, ECHO, INQUIRE ... */
   };

ListType infoCatagoryList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   infoCatagoryKeywords  /* MEMORY STATUS CONFIG ... */
   };


ListType infoConfigList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES, 
   PJL_TOKEN_INFO_CONFIG_BASE, 
   infoConfigKeywords  /* MEMORY= ... */
   };

ListType inquireVariableList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_INQUIRE_BASE, 
   inquireVariableKeywords /* INTRAY1SIZE ...*/
   };


ListType echoList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   echoKeywords /* MSSYNC ...*/
   };


ListType traySizeList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   traySizeKeywords /* LEGAL, C5 ...*/
   };

ListType ustatusList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusKeywords  /* JOB ... */
   };


ListType ustatusJobList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusJobKeywords  /* END ... */
   };

ListType ustatusDeviceList =
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_DEVICE_BASE,
   ustatusDeviceKeywords  /* END ... */
   };


/* Command strings that can follow @PJL USTATUS */
KeywordType ustatusKeywords[] = 
   {
      {"JOB\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusJobList},
      {"DEVICE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
//    {"DEVICE\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"TIMED\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
      NULL
   };                


/* Command strings that can follow @PJL USTATUS JOB */
KeywordType ustatusJobKeywords[] = 
   {
      {"END\r\n", ACTION_SET_VALUE_FROM_PARAM, VALUE_RETURED_FOR_VALUELESS_TOKENS},
      {"NAME=\"MSJOB ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpQuoteCRLF},
      NULL
   };                


/* command strings that can follow @PJL USTATUS DEVICE */
KeywordType ustatusDeviceKeywords[] =
   {
      {"CODE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DISPLAY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL, (struct ListTypeTag *)lpCRLF},
      {"ONLINE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL, (struct ListTypeTag *)lpCRLF},
      NULL
   };


/* Command strings that can follow @PJL */
KeywordType readBackCommandKeywords[] = 
   {
      {"INFO", ACTION_SET_NEW_LIST, &infoCatagoryList},
      {"ECHO", ACTION_SET_NEW_LIST, &echoList},
      {"INQUIRE", ACTION_SET_NEW_LIST, &inquireVariableList},
      {"USTATUS", ACTION_SET_NEW_LIST, &ustatusList},
      NULL
   };                


/* Command strings that can follow @PJL ECHO (Microsoft specific-NOT PJL!) */
KeywordType echoKeywords[] = 
   {
      {"MSSYNC", ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF, 
         (struct ListTypeTag *)(INT_PTR)TOKEN_ECHO_MSSYNC_NUMBER},
      NULL
   };                

/* Catagory strings that can follow @PJL INFO */
KeywordType infoCatagoryKeywords[] = 
   {
      {"MEMORY\r\n", ACTION_GET_TOTAL_AND_LARGEST_FF, PARAM_NOT_USED},
      {"STATUS\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"CONFIG\r\n", ACTION_SET_NEW_LIST, &infoConfigList},
      NULL
   };

/* Catagory strings that can follow @PJL INFO */
KeywordType infoConfigKeywords[] = 
   {
      {"MEMORY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"MEMORY = ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      NULL
   };

/* TRUE or FALSE strings */
KeywordType FALSEandTRUEKeywords[] = 
   {
      {"FALSE", ACTION_NOT_USED, PARAM_NOT_USED},
      {"TRUE",  ACTION_NOT_USED, PARAM_NOT_USED},
      NULL
   };

/* strings that can follow @PJL INQUIRE */
KeywordType inquireVariableKeywords[] = 
   {
      {"INTRAY1SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY2SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY3SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY4SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      NULL
   };

/* strings that can follow @PJL INQUIRE INTRAY?SIZE */
/* the parameters are the Microsoft defined token values for paper size */
KeywordType traySizeKeywords[] =
   {
      {"LETTER",    ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LETTER},
      {"LEGAL",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LEGAL},
      {"A4",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_A4},
      {"EXECUTIVE", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_EXECUTIVE},
      {"COM10",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_10},
      {"MONARCH",   ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_MONARCH},
      {"C5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_C5},
      {"DL",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_DL},
      {"B5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_B5},
      NULL
   };

void (*pfnNotFoundActions[])(ParseVarsType *pParseVars) = 
   {
   ActionNotFoundSkipPastFF,
   ActionNotFoundSkipCFLFandIndentedLines
   };


void (*pfnFoundActions[])(ParseVarsType *pParseVars, ParamType param) = 
   {
   TokenFromParamValueFromNumberFF,
   SetNewList,
   GetTotalAndLargestFF,
   GetCodeAndOnlineFF,
   GetTokenFromIndexSetNewList,
   SetValueFromParamFF,
   GetTokenFromIndexValueFromNumberEOLFromParam,
   SetValueFromParam,
   GetTokenFromIndexValueFromBooleanEOL,
   GetTokenFromIndexValueFromStringEOL
   };

PJLTOPRINTERSTATUS PJLToStatus[] =
{
    { 10001,0x0 },  // clear status - printer is ready
    { 10002,0x0 },  // clear status - check ONLINE=TRUE or FALSE
    { 11002,0x0 },  // LJ4 sends this code for 00 READY
    { 40022,PORT_STATUS_PAPER_JAM    },
    { 40034,PORT_STATUS_PAPER_PROBLEM},
    { 40079,PORT_STATUS_OFFLINE      },
    { 40019,PORT_STATUS_OUTPUT_BIN_FULL},

    { 10003,PORT_STATUS_WARMING_UP   },
    { 10006,PORT_STATUS_TONER_LOW    },
    { 40038,PORT_STATUS_TONER_LOW    },

    { 30016,PORT_STATUS_OUT_OF_MEMORY},
    { 40021,PORT_STATUS_DOOR_OPEN    },
    { 30078,PORT_STATUS_POWER_SAVE   },

    //
    // Entries added by MuhuntS
    //
    { 41002, PORT_STATUS_PAPER_PROBLEM}, // Load plain
    { 35078, PORT_STATUS_POWER_SAVE},
    {0, 0}

};


// @@BEGIN_DDKSPLIT
#if 0
/*
test not enough room for tokens
test no FF
test zero before end
*/
main ()
{
char pInString[] = "@PJL USTATUS DEVICE\r\nCODE=25008\r\n\f\
@PJL USTATUS DEVICE\r\n\CODE=20020\r\n\f\
@PJL ECHO MSSYNC 1234567\r\n\f\
@PJL INFO CONFIG\r\n\
IN TRAYS [1 ENUMERATED]\r\n\
\tINTRAY1 PC\r\n\
OUT TRAYS [1 ENUMERATED]\r\n\
\tNORMAL FACEDOWN\r\n\
PAPERS [10 ENUMERATED]\r\n\
\tLETTER\r\n\
\tLEGAL\r\n\
\tA4\r\n\
LANGUAGES [1 ENUMERATED]\r\n\
\tPCL\r\n\
MEMORY=2097152\r\n\
DISPLAY LINES=1\r\n\
DISPLAY CHARACTER SIZE=16\r\n\f\
@PJL INQ";


//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"MSJOB 3\"\r\nPAGES=3\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"JOB 14993\"\r\nPAGES=3\r\n\f$"; //good command 1 token
/*
char pInString[] = "@PJL INFO CONFIG\r\nINTRAYS [3 ENUMERATED]\r\n\tINTRAY1\
 MP\r\n\tINTRAY2 PC\r\n\tINTRAY3 LC\r\nENVELOPE TRAY\r\nMEMORY=2087152\r\n\
DISPLAY LINES=1\r\n\f$"; //good command 1 token
*/
//char pInString[] = "@PJL INQUIRE INTRAY3SIZE\r\nC5\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL INFO STATUS\r\nCODE=10001\r\n\DISPLAY=\"00 READY\"\r\nONLINE=TRUE\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJL INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJG INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\f$"; //bad command Fail
//char pInString[] = "@PJG ECHO MSSYNC 12T4567\r\n\f$";     //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\000\f$"; //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\f$";     //bad MS command Fail
//char pInString[] = "@PJL ECHO MSSYNC 1234567\r\n\f$";     //good command Success 1 token
//char pInString[] = "@PJL ECHO 124567\r\n\f$";             //good command Success 0 token
TokenPairType tokenPairs[20];
DWORD nTokenParsedRet;
LPSTR lpRet;
DWORD i;
DWORD status;


status = GetPJLTokens(pInString, 20, tokenPairs, &nTokenParsedRet, &lpRet);

switch (status)
   {
   case STATUS_REACHED_END_OF_COMMAND_OK:
      {
      printf("STATUS_REACHED_END_OF_COMMAND_OK\n");
      break;
      }
   case STATUS_CONTINUE:
      {
      printf("STATUS_CONTINUE\n");
      break;
      }
   case STATUS_REACHED_FF:
      {
      printf("STATUS_REACHED_FF\n");
      break;
      }
   case STATUS_END_OF_STRING;
      {
      printf("STATUS_END_OF_STRING\n");
      break;
      }
   case STATUS_SYNTAX_ERROR:
      {
      printf("STATUS_SYNTAX_ERROR\n");
      break;
      }
   case STATUS_ATPJL_NOT_FOUND:
      {
      printf("STATUS_ATPJL_NOT_FOUND\n");
      break;
      }
   case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
      {
      printf("STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n");
      break;
      }
   default:
      {
      printf("INVALID STATUS RETURNED!!!!!!\n");
      break;
      }
   };

printf(" length of command=%d, numberOfTokens=%d\n", lpRet-pInString, nTokenParsedRet);
for (i=0; i<nTokenParsedRet; i++)
   {
   printf("  Token=0x%x, Value=%d\n", tokenPairs[i].token, tokenPairs[i].value);
   }

if (*lpRet==0)
   {
   printf(" Next char is terminator\n");
   }
else
   {
   printf(" Next char=%c\n", *lpRet);
   }

exit(0);
}
#endif
// @@END_DDKSPLIT

/* GetPJLTokens 
This function parses a single ASCII PJL command and returns token/value pairs.
Complete PJL commands must begin with '@PJL' and end with a <FF>.

The function result returns one of the following values:
   0 = STATUS_REACHED_END_OF_COMMAND_OK
   1 = STATUS_END_OF_STRING
   2 = STATUS_SYNTAX_ERROR
   3 = STATUS_ATPJL_NOT_FOUND,
   4 = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS

Also returned through the parameters are:
 1] *plpInPJL:
    If STATUS_REACHED_END_OF_COMMAND_OK
      will point to the character past the first <FF> (FF = form feed).
    If STATUS_END_OF_STRING
      will point to the terminator that was found before any <FF>.
    Else
      undefined 
  
 2] *pnTokenParsed will contain the number of pairs returned in *pToken.

 3] pToken will contain *pnTokenParsed  token pairs  

If there are characters belonging to another command trailing the first
then the caller should call again for the new command.  If only part of
the new command may be present, then the caller may want to copy the 
characters of the new command to the beginning of the buffer, and then read 
the necessary additional characters onto the end before resubmitting the
complete command to this function for parsing.  Note that the *plpInPJL
tells the caller where the next command would begin.


If the end of the string is encountered before the trailing <FF> is found then
the function returns with *plpInPJL pointing to the terminator.
If the caller wants the command parsed into
token\value pairs it should resubmit the string once the characters 
which complete the command have been appended.


Operation:
----------
Lists drive the parsing.  The main loop of this 
parser looks through the keywords of the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

*/

DWORD GetPJLTokens(
    LPSTR lpInPJL,
    DWORD nTokenInBuffer,
    TokenPairType *pToken, 
    DWORD *pnTokenParsed,
    LPSTR *plpInPJL
)
{
   /* The parseVars variables are put into a structure so that they can be
      passed efficiently to all the helper functions.
    */
   ParseVarsType parseVars;
   BOOL bFoundKeyword;
   DWORD i, keywordIndex;
   KeywordType *pKeyword;
   DWORD dwNotFoundAction;

   /* The first list to look for is the commands that can follow
      @PJL
    */
   parseVars.arrayOfLists[0] = &readBackCommandList;
   parseVars.arrayOfLists[1] = NULL;      

   parseVars.pInPJL_Local = lpInPJL;
   parseVars.nTokenInBuffer_Local = 0;
   parseVars.nTokenLeft = nTokenInBuffer;
   parseVars.pToken_Local = pToken;
   parseVars.status = STATUS_CONTINUE;

   if (!AdvancePointerPastString(&parseVars, "@PJL"))
      {
      parseVars.status = STATUS_ATPJL_NOT_FOUND;
      }
                     
   while (parseVars.status == STATUS_CONTINUE)
      {
      /* Look for next input keyword in currently valid lists.
         Sometimes may need to look for the next input keyword in more
         then one list.
       */
      bFoundKeyword = FALSE;
      for (i=0; (parseVars.pCurrentList = parseVars.arrayOfLists[i])!=NULL; i++)
         {
         dwNotFoundAction = parseVars.pCurrentList->dwNotFoundAction;
         /* Skip over spaces to start of next keyword string */
         if ( !SkipOverSpaces(&parseVars) )
            {
            /* Either the input stream has ended or FF was found */
            if (parseVars.status == STATUS_REACHED_FF)
               {
               /* Finding a FF here may or may not be an error,
                  the field in the current list tells us which
                */  

               if ( parseVars.pCurrentList->bFormFeedOK )
                  {
                  parseVars.status = STATUS_REACHED_END_OF_COMMAND_OK;
                  }
               else
                  {
                  parseVars.status = STATUS_SYNTAX_ERROR;
                  }
               }
            break;
            }
         /* Look for keyword in current keywords */
         parseVars.pCurrentKeywords = parseVars.pCurrentList->pListOfKeywords;
         keywordIndex = LookForKeyword(&parseVars);
         if ( keywordIndex!=-1 )
            {
            bFoundKeyword = TRUE;
            break;
            }
         }

      if ( parseVars.status!=STATUS_CONTINUE )
         {
         /* We are finished processing commands */
         break;
         }

      if ( bFoundKeyword )
         /* do action from keyword */
         {
         pKeyword = &parseVars.pCurrentKeywords[keywordIndex];
         (*pfnFoundActions[pKeyword->dwAction])(&parseVars, pKeyword->param);
         }
      else
         /* do not found action from list */
         {
         (*pfnNotFoundActions[dwNotFoundAction])(&parseVars);
         }
      } 

   /* We are done parsing the input command, now we return the information */

   DBGMSG(DBG_TRACE, ("ParseVars.status = %d\n", parseVars.status));

   /* Fill in returned values and return with success */
   *pnTokenParsed = parseVars.nTokenInBuffer_Local;
   *plpInPJL = parseVars.pInPJL_Local;

   return(parseVars.status);
}


/* 
int LookForKeyword(ParseVarsType *pParseVars)

This function looks through the current keyword list in search of a 
keyword that matches the characters in the input stream pointed to 
by pParseVars->pInPJL_Local.

If a match is found:
        The index of the match in the pKeyword is returned.
        pParseVars->pInPJL_Local is advanced past the last matching character.
        pParseVars->dwKeywordIndex is set to item number in list

If no match is found:
        The return value is -1.
        pParseVars->pInPJL_Local is unchanged.
*/
int LookForKeyword(ParseVarsType *pParseVars)
{
LPSTR   pInStart = pParseVars->pInPJL_Local;
LPSTR   pIn;
DWORD   dwKeywordIndex = 0;
BOOL    bFoundMatch = FALSE;
BYTE    c;
KeywordType *pKeywords = pParseVars->pCurrentKeywords;
LPSTR   pKeywordString;

while ( (pKeywordString=pKeywords[dwKeywordIndex++].lpsz)!=NULL )
{
   DBGMSG(DBG_TRACE, ("LookForIn=%hs\n", pInStart));
   DBGMSG(DBG_TRACE, ("Keyword=%hs\n", pKeywordString));

   pIn = pInStart;
   while ( (c=*pKeywordString++)!=0 )
      {
      if ( c!=*pIn++ )
         {
         break;
         }
      }

   if ( c==0 )
      {
      bFoundMatch = TRUE;
      pParseVars->pInPJL_Local = pIn;
      pParseVars->dwFoundIndex = dwKeywordIndex-1;
      break;
      }
   }

   DBGMSG(DBG_TRACE, ("LookForOut=%hs\n", pParseVars->pInPJL_Local));

   return( (bFoundMatch)?dwKeywordIndex-1:-1 );
}


/*
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)

This function looks through the input stream for a match with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
*/
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) )
      {
      if ( s==in )
         {
         pS++; /* point to next char in string to look for match */
         }
      else
         {
         pS = pString; /* start over looking for start of string */
         }
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }

   if ( in==FF )
      {
      pParseVars->status = STATUS_REACHED_FF;
      pParseVars->pInPJL_Local = pIn+1;
      }
   else
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      } 

   return(FALSE);
}



/*
BOOL SkipOverSpaces(ParseVarsType &parseVars) 
This function skips over spaces in the input stream until a non-space
character (FF and NULL are special cases) is found.

If a non-space character is found then 
   pParseVars->pInPJL_Local is set to point to the first non-space char.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before a non-space char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered before a non-space character is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipOverSpaces(ParseVarsType *pParseVars) 
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)==SPACE)&&(in!=0)&&(in!=FF) )
      {
      pIn++;
      }
   
   switch (in)
      {
      case FF:
         {
         pParseVars->status = STATUS_REACHED_FF;
         pParseVars->pInPJL_Local = pIn+1;
         return(FALSE);
         }
      case 0:
         {
         pParseVars->status = STATUS_END_OF_STRING;
         pParseVars->pInPJL_Local = pIn;
         return(FALSE);
         }
      default:
         {
         /* point to character after string in input */
         pParseVars->pInPJL_Local = pIn;
         return(TRUE);
         }
      }
}


void TokenFromParamValueFromNumberFF(
   ParseVarsType *pParseVars,ParamType param)
{
   int value;

   StoreToken(pParseVars, param.token);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars)
{
   if ( SkipPastFF(pParseVars) )
      {
      pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK;
      }
   return;
}

/*
BOOL SkipPastFF(ParseVarsType *pParseVars)
This function skips over all characters until either a zero is found or
FF is found.

If the end of input is encountered before an FF char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered 
   the return value is TRUE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipPastFF(ParseVarsType *pParseVars)
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)!=FF)&&(in!=0) )
      {
      pIn++;
      }
   
   if ( in==0 )
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      return(FALSE);
      }
   pParseVars->pInPJL_Local = pIn+1;
   pParseVars->status = STATUS_REACHED_FF;
   return(TRUE);
}

void ExpectFinalCRLFFF(ParseVarsType *pParseVars)
{
   char c;

   if ( pParseVars->status==STATUS_CONTINUE )
      {
      c=*pParseVars->pInPJL_Local;
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         return;
         }
   
      if ( !AdvancePointerPastString(pParseVars, lpCRLF) )
         {
         if ( pParseVars->status==STATUS_REACHED_FF )
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         return;
         }
      ExpectFinalFF(pParseVars);
      }
   return;
}



void ExpectFinalFF(ParseVarsType *pParseVars)
{
   if ( pParseVars->status==STATUS_CONTINUE )
      {
      if ( *pParseVars->pInPJL_Local==FF )
         {
         pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK; 
         pParseVars->pInPJL_Local++;
         }
      else
         {
         if ( *pParseVars->pInPJL_Local==0 )
            {
            pParseVars->status = STATUS_END_OF_STRING;
            }
         else
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         }
      }
   return;
}


/*
int GetPositiveInteger(ParseVarsType *pParseVars)
This function skips spaces and then interprets all the digits in input stream
as a positive integer.

If digits follow any spaces and they are not terminated by a zero then
   the return value is the positive integer.

If the first character following spaces in not a digit or the end of 
string is encountered then 
   -1 is returned as the value 
   pParseVars->status is set to STATUS_SYNTAX_ERROR
   
Note: does not check for overflow
*/
int GetPositiveInteger(ParseVarsType *pParseVars)
{
   int   value;
   LPSTR pIn; 
   BYTE  c;

   if ( !SkipOverSpaces(pParseVars) )
      {
      if ( pParseVars->status == STATUS_REACHED_FF )
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(-1);
      }
   
   pIn = pParseVars->pInPJL_Local;
   for ( value=0; ((c=*pIn++)>='0')&&(c<='9'); value=value*10+(c-'0') );
   if ( (c==0)||(pIn==pParseVars->pInPJL_Local+1) )
      {
      /* either end of string encountered or no digits found */
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         }
      else
         {   
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      pParseVars->pInPJL_Local = pIn-1;
      return(-1);
      }
   pParseVars->pInPJL_Local = pIn-1;
   return(value);
}



void SetNewList(ParseVarsType *pParseVars, ParamType param)
{
   pParseVars->arrayOfLists[0] = param.pList;
   pParseVars->arrayOfLists[1] = NULL;
   return;
}  

void StoreToken(ParseVarsType *pParseVars, DWORD dwToken)
{
   pParseVars->dwNextToken = dwToken;
   return;
}

BOOL StoreTokenValueAndAdvancePointer(ParseVarsType *pParseVars, UINT_PTR dwValue)
{
   if ( pParseVars->nTokenLeft==0 )
      {
      pParseVars->status = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS;
      return(FALSE);
      }
   pParseVars->pToken_Local->token = pParseVars->dwNextToken;
   pParseVars->pToken_Local->value = dwValue;
   pParseVars->pToken_Local++;
   pParseVars->nTokenInBuffer_Local++;
   pParseVars->nTokenLeft--;
   return(TRUE);
}


void GetTotalAndLargestFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars, "TOTAL=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_TOTAL);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nLARGEST=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_LARGEST);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void GetCodeAndOnlineFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars,"CODE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_CODE);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nDISPLAY=") )
      {
      return;
      }
   if ( !SkipPastNextCRLF(pParseVars) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "ONLINE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_ONLINE);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;
   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


/*
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)

This function looks for a match of the current stream 
position with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) && (s==in) )
      {
      pS++; 
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }
   
   pParseVars->status = ( in!=0 )?
      STATUS_SYNTAX_ERROR:STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
   return(FALSE);
}




/*
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)

This function positions the stream pointer past the next
CRLF.

If a CRLF is found:
   pParseVars->pInPJL_Local is set to point just past the CRLF.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the CRLF is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the CRLF is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)
{
   if ( !AdvancePointerPastString(pParseVars, "\r\n") )
      {
      if ( pParseVars->status == STATUS_REACHED_FF)
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(FALSE);
      }
   return(TRUE);
}


void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars, ParamType param)
{
   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   SetNewList(pParseVars, param);
   return;
}


void SetValueFromParamFF(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


void SetValueFromParam(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   return;
}

void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars)
{
   DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF In=%hs\n", pParseVars->pInPJL_Local));

   do
      {
      if ( !SkipPastNextCRLF(pParseVars) )
         {

         DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF error skipping\n"));

         return;
         }
      } while (*pParseVars->pInPJL_Local==TAB);

   DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF Out=%hs\n", pParseVars->pInPJL_Local));

   return;      
}

void GetTokenFromIndexValueFromNumberEOLFromParam
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromNumberIn=%hs\n", pParseVars->pInPJL_Local));

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */

      DBGMSG(DBG_TRACE, ("error getting number\n"));

      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {

      DBGMSG(DBG_TRACE, ("error storing value\n"));

      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromNumberOut=%hs\n", pParseVars->pInPJL_Local));

   return;
}

void GetTokenFromIndexValueFromBooleanEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromBooleanEOLin=%hs\n", pParseVars->pInPJL_Local));

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;

   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromBooleanEOLout=%hs\n", pParseVars->pInPJL_Local));

   return;
}

void GetTokenFromIndexValueFromStringEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromStringEOLin=%hs\n", pParseVars->pInPJL_Local));


   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);

   if ( !StoreTokenValueAndAdvancePointer(pParseVars, (UINT_PTR)pParseVars->pInPJL_Local))
      {
      return;
      }
   SkipPastNextCRLF(pParseVars);

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromStringEOLout=%hs\n", pParseVars->pInPJL_Local));

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\debug.h ===
/*****************************************************************************
 *
 * $Workfile: debug.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_DEBUG_H
#define INC_DEBUG_H

#include <crtdbg.h>		// debug functions

#define in
#define out
#define inout

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations
extern HANDLE	g_hDebugFile;


///////////////////////////////////////////////////////////////////////////////
//  function prototypes
#ifdef __cplusplus
extern "C" {
#endif
	void InitDebug( LPTSTR pszDebugFile );
	void DeInitDebug(void);
	void debugRPT(char *p, int i);
	void debugCSect(char *p, int i, char *fileName, int lineNum, LONG csrc);
#ifdef __cplusplus
}
#endif


///////////////////////////////////////////////////////////////////////////////
//  debug macros
#define	MON_DEBUG_FILE	__TEXT("c:\\tmp\\DebugMon.out")
#define	MONUI_DEBUG_FILE	__TEXT("c:\\tmp\\UIDbgMon.out")

#ifdef IS_INTEL
#define BREAK	{ if ( CreateFile((LPCTSTR)__TEXT("c:\\tmp\\breakmon.on"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING,	\
							FILE_ATTRIBUTE_NORMAL, 0) == INVALID_HANDLE_VALUE)					\
					{	}													\
				  else { { _asm { int 3h } } }																\
				}
#else
#define BREAK	{}
#endif

#if defined NDEBUG
	#ifdef BREAK
	#undef BREAK
	#define BREAK
	#endif
#endif


///////////////////////////////////////////////////////////////////////////////
//  memory watch routines

class CMemoryDebug 
{
public:
	CMemoryDebug();
	~CMemoryDebug();

	// override new & delete to keep track of memory usage
	void*	operator	new(size_t s);
	void	operator	delete( void   *p, 
								size_t s );		// 2nd parameter optional

private:
	static DWORD	m_dwMemUsed;

};

#endif		// INC_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\precomp.h ===
/*****************************************************************************
 *
 * $Workfile: pch_mon.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/Common/pch_mon.h $
 *
 * 4     9/25/97 9:08a Dsnelson
 * removed target.h
 *
 * 3     7/14/97 2:35p Binnur
 * copyright statement
 *
 * 2     7/11/97 1:52p Dsnelson
 * added blank last line
 *
 * 1     7/02/97 2:25p Binnur
 * Initial File
 *
 *****************************************************************************/


#ifndef _PRECOMP_H
#define _PRECOMP_H

#include <tchar.h>
#include <windows.h>
#include <windowsx.h>

//  Include the correct spooler definitions, etc
#include <winspool.h>

#endif	// INC_PCH_MON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\lprdata.h ===
/*****************************************************************************
 *
 * $Workfile: LPRData.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_LPRDATA_H
#define INC_LPRDATA_H

// globals shared by the UI & transport dlls
#if (!defined(LPR))
    #define	LPR						2
    #define	PROTOCOL_LPR_TYPE		LPR
#endif    
#define	PROTOCOL_LPR_VERSION1	1		// supports ADDPORT_DATA_1; REGPORT_DATA_1; CONFIGPORT_DATA_1

#define LPR_DEFAULT_PORT_NUMBER 515


typedef struct _LPR_PORT_DATA_1						// used by the registry
{
	TCHAR	sztPortName[MAX_PORTNAME_LEN];
	TCHAR	sztHostName[MAX_NETWORKNAME_LEN];
	TCHAR	sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR	sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR	sztQueue[MAX_QUEUENAME_LEN];
	TCHAR	sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
    DWORD   dwDoubleSpool;
	DWORD	dwSNMPEnabled;
	DWORD	dwSNMPDevIndex;
	DWORD	dwPortNumber;
}	LPR_PORT_DATA_1, *PLPR_PORT_DATA_1;

#endif	// INC_LPRDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\mibabc.h ===
/*****************************************************************************
 *
 * $Workfile: MibABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_TCPMIBABC_H
#define INC_TCPMIBABC_H

#include <snmp.h>
#include <mgmtapi.h>
#include <winspool.h>



// error codes -- device type operation
#define  ERROR_DEVICE_NOT_FOUND                 10000
#define  SUCCESS_DEVICE_SINGLE_PORT             10001
#define  SUCCESS_DEVICE_MULTI_PORT              10002
#define  SUCCESS_DEVICE_UNKNOWN                 10003


class   CTcpMibABC;

typedef CTcpMibABC* (CALLBACK *RPARAM_1) ( void );

#ifndef DllExport
#define DllExport       __declspec(dllexport)
#endif


#ifdef __cplusplus
extern "C" {
#endif
	//      return the pointer to the interface
	CTcpMibABC* GetTcpMibPtr( void );

#ifdef __cplusplus
}
#endif


/***************************************************************************** 
 *
 * Important Note: This abstract base class defines the interface for the CTcpMib 
 *      class. Changing this interface will cause problems for the existing DLLs that 
 *      uses the TcpMib.dll & CTcpMib class.
 * 
 *****************************************************************************/

class DllExport CTcpMibABC      
#if defined _DEBUG || defined DEBUG
//      , public CMemoryDebug
#endif
{
public:
	CTcpMibABC() { };
	virtual ~CTcpMibABC() { };

	virtual BOOL   SupportsPrinterMib( LPCSTR        pHost,
							           LPCSTR        pCommunity,
                                       DWORD         dwDevIndex,
                                       PBOOL         pbSupported) = 0;
	virtual DWORD   GetDeviceDescription(LPCSTR        pHost,
									     LPCSTR        pCommunity,
									     DWORD         dwDevIndex,
                                         LPTSTR        pszPortDescription,
										 DWORD		   dwDescLen) = 0;
	virtual DWORD   GetDeviceStatus ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex) = 0;
	virtual DWORD   GetJobStatus    ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex) = 0;
	virtual DWORD   GetDeviceHWAddress( LPCSTR      pHost,
									    LPCSTR      pCommunity,
										DWORD   dwDevIndex,
										DWORD   dwSize, // Size in characters of the dest hardware address
									    LPTSTR      psztHWAddress) = 0;
	virtual DWORD   GetDeviceName   ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex,
									  DWORD         dwSize, // Size in characters of the dest psztDescription
									  LPTSTR        psztDescription) = 0;
	virtual DWORD   SnmpGet( LPCSTR                      pHost,
							 LPCSTR pCommunity,
							 DWORD          dwDevIndex,
							 AsnObjectIdentifier *pMibObjId,
							 RFC1157VarBindList  *pVarBindList) = 0;
	virtual DWORD   SnmpWalk( LPCSTR                          pHost,
							  LPCSTR                          pCommunity,
							  DWORD                           dwDevIndex,
							  AsnObjectIdentifier *pMibObjId,
							  RFC1157VarBindList  *pVarBindList) = 0;
	virtual DWORD   SnmpGetNext( LPCSTR                          pHost,
							     LPCSTR                              pCommunity,
							     DWORD                               dwDevIndex,
								 AsnObjectIdentifier *pMibObjId,
								 RFC1157VarBindList  *pVarBindList) = 0;
	virtual BOOL SNMPToPortStatus( const DWORD in dwStatus, 
								 PPORT_INFO_3 pPortInfo ) = 0;

	virtual DWORD SNMPToPrinterStatus( const DWORD in dwStatus) = 0;


private:


};      // class CTcpMibABC



#endif  // INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\rtcpdata.h ===
/*****************************************************************************
 *
 * $Workfile: RTcpData.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_RAWTCPDATA_H
#define INC_RAWTCPDATA_H
 
// globals shared by the UI & transport dlls

#if (!defined(RAWTCP))
    #define	RAWTCP						1
    #define	PROTOCOL_RAWTCP_TYPE		RAWTCP
#endif    
#define	PROTOCOL_RAWTCP_VERSION		1		// supports ADDPORT_DATA_1; REGPORT_DATA_1; CONFIGPORT_DATA_1

// UI structures
typedef struct _RAWTCP_PORT_DATA_1						// used by the registry
{
	TCHAR	sztPortName[MAX_PORTNAME_LEN];
	TCHAR	sztHostName[MAX_NETWORKNAME_LEN];
	TCHAR	sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR	sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR	sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD	dwSNMPEnabled;
	DWORD	dwSNMPDevIndex;
	DWORD	dwPortNumber;
}	RAWTCP_PORT_DATA_1, *PRAWTCP_PORT_DATA_1;

typedef struct _RAWTCP_CONFIG_DATA_1					// used by the UI -- configPort
{
	TCHAR   sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR   sztHardwareAddress[MAX_ADDRESS_STR_LEN];
	TCHAR   sztDeviceType[MAX_DEVICEDESCRIPTION_STR_LEN];
}	RAWTCP_CONFIG_DATA_1, *PRAWTCP_CONFIG_DATA_1;

#endif	// INC_RAWTCPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\pingicmp.cpp ===
/*****************************************************************************
 *
 * $Workfile: PingICMP.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "pingicmp.h"


///////////////////////////////////////////////////////////////////////////////
//  CPingICMP::CPingICMP()

CPingICMP::CPingICMP(const char   *pHost) :
                        hIcmp(INVALID_HANDLE_VALUE), m_iLastError(NO_ERROR)
{
    strncpyn(m_szHost, pHost, sizeof( m_szHost));
}   // ::CPingICMP()


///////////////////////////////////////////////////////////////////////////////
//  CPingICMP::~CPingICMP()

CPingICMP::~CPingICMP()
{
    _ASSERTE(hIcmp == INVALID_HANDLE_VALUE);
}   // ::~CPingICMP()


///////////////////////////////////////////////////////////////////////////////
//  Open -- AF_INET, SOCK_RAW, IPPROTO_ICMP

BOOL
CPingICMP::Open()
{
    _ASSERTE(hIcmp == INVALID_HANDLE_VALUE);

    if ( (hIcmp = IcmpCreateFile()) == INVALID_HANDLE_VALUE )
    {
        m_iLastError = GetLastError();
        return FALSE;
    }

    return TRUE;
}   // ::Open()


///////////////////////////////////////////////////////////////////////////////
//  Close

BOOL
CPingICMP::Close()
{
    BOOL    bRet = (hIcmp == INVALID_HANDLE_VALUE || IcmpCloseHandle(hIcmp));

    if ( !bRet )
        m_iLastError = GetLastError();
    else
        hIcmp = INVALID_HANDLE_VALUE;

    return bRet;

}   // ::Close()


///////////////////////////////////////////////////////////////////////////////
//  Ping -- sends an ICMP Echo Request & reads the ICMP Echo Reply back. It
//      records the round trip time.
//      Note: SOCK_RAW support is optional in WinSock V1.1, so this will not
//      work over all WinSock implementations.
//      Error Codes:
//          NO_ERROR if successfull
//          WinSock error otherwise

BOOL
CPingICMP::Ping()
{
    BOOL                    bRet = FALSE;
    DWORD                   timeOut = 5 * 1000; // 5 seconds, 5000 milliseconds
    int                     i, nReplies, nRetries   = 2;    // It is not necessary to retry 3 times.
                                                            // Printers need retry means they are
                                                            // too far away to print

    char                    cSendBuf[4], cRcvBuf[1024];
    IP_OPTION_INFORMATION   IpOptions;
    PICMP_ECHO_REPLY        pReply;
    IPAddr                  IpAddr;


    if ( (IpAddr = ResolveAddress()) == INADDR_NONE || !Open() )
        return FALSE;

    ZeroMemory(&IpOptions, sizeof(IpOptions));
    IpOptions.Ttl   = 128;      // From ping utility (net\sockets\tcpcmd\ping)

    //
    // *** Since 0 initialized the following is not needed
    //
    // IpOptions.Tos   = 0;
    // IpOptions.OptionsSize    = 0;
    // IpOptions.OptionsData    = NULL;
    // IpOptions.Flags          = 0;

    for ( i = 0 ; i < sizeof(cSendBuf) ; ++i )
        cSendBuf[i] = 'a' + i;


    // send ICMP echo request
    for (i = 0; !bRet && i < nRetries; i++)
    {

        nReplies = IcmpSendEcho(hIcmp,
                                IpAddr,
                                cSendBuf,
                                sizeof(cSendBuf),
                                &IpOptions,
                                cRcvBuf,
                                sizeof(cRcvBuf),
                                timeOut);



        pReply = (PICMP_ECHO_REPLY)cRcvBuf;
        while (!bRet && nReplies--)
        {
            bRet = sizeof(cSendBuf) == pReply->DataSize  &&
                   memcmp(cSendBuf, pReply->Data, sizeof(cSendBuf)) == 0;
            pReply++;
        }
    }

    Close();

    return bRet;    // device is found

}   // ::Ping()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

IPAddr
CPingICMP::ResolveAddress()
{
    IPAddr  ipAddr = INADDR_NONE;
    struct hostent  *h_info;        /* host information */

    /*
     * m_szHost is not necessarily a host name. It could be an IP address as well
     */

    if ( (ipAddr = inet_addr(m_szHost)) == INADDR_NONE )
    {
        if ((h_info = gethostbyname(m_szHost)) != NULL)
        {
            /*
            * Copy the IP address to the address structure.
            */
            memcpy(&ipAddr, h_info->h_addr, sizeof(ipAddr));
        }
    }

    return ipAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\common\tcpmon.h ===
/*****************************************************************************
 *
 * $Workfile: TcpMon.h $
 *
 * Copyright (C) 1997 - 1999 Hewlett-Packard Company.
 * Copyright (C) 1997 - 1999 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_HPSPPMON_H
#define INC_HPSPPMON_H

#include <wininet.h>
#include <splcom.h>
#include "debug.h"
#include "tcpxcv.h"

typedef BOOL (* SETPORTPARAM)(LPTSTR, LPTSTR, DWORD, LPBYTE);
typedef BOOL (* ENUMPORTPARAM)(LPTSTR, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD);

// externs
extern int           g_cntGlobalAlloc;
extern int           g_csGlobalCount;
extern HINSTANCE     g_hInstance;
extern HINSTANCE     g_hTcpMib;
extern HINSTANCE     g_hSpoolLib;
extern SETPORTPARAM  g_pfnSetPort;
extern ENUMPORTPARAM g_pfnEnumPorts;

// Additional Dll's

#define TCPMIB_DLL_NAME         TEXT("tcpmib.dll")


// macros
#define ENTER_CRITICAL_SECTION(cs, fn, ln, csrc)                        ( debugCSect("DEBUG -- EnterCriticalSection count = ", ++g_csGlobalCount, fn, ln, csrc), EnterCriticalSection(cs) )
#define EXIT_CRITICAL_SECTION(cs, fn, ln, csrc)                 ( debugCSect("DEBUG -- ExitCriticalSection count = ", --g_csGlobalCount, fn, ln, csrc), LeaveCriticalSection(cs) )


#if defined (UNICODE) || defined (_UNICODE)
#define MBCS_TO_UNICODE(dest, destsize, src)                                   \
      {                                                         \
      _ASSERTE(strlen(src)<(size_t)destsize); /* make sure dest is big enough -- should a bigger buffer be allocated? */ \
      MultiByteToWideChar(CP_ACP, 0L, src, -1, dest, destsize); \
	  (dest)[destsize - 1 ] = '\0'; \
      }

#define UNICODE_TO_MBCS(dest, destsize, src, srcsize)                  \
      {                                                         \
      _ASSERTE((int)srcsize == -1 || _tcslen(src)<=(size_t)srcsize);  /* make sure the source string did not go past the provided buffer size */ \
      WideCharToMultiByte(CP_ACP, 0L, src, -1, dest, destsize, NULL, NULL); \
	  (dest)[destsize - 1 ] = '\0'; \
      }

#define SIZEOF_IN_CHAR(buf)             (sizeof(buf)/sizeof(buf[0]))
#define STRLEN_IN_BYTES(buf)    (_tcslen(buf)*sizeof(TCHAR))                            // String length in bytes
#define STRLENN_IN_BYTES(buf)   (_tcslen(buf)*sizeof(TCHAR)+sizeof(TCHAR))      // string length including NULL terminator
#endif

// Required Winsock version info
#define WS_VERSION_REQUIRED             (0x0101)                        // WinSock V1.1 is required
#define WS_VERSION_MAJOR                HIBYTE(WS_VERSION_REQUIRED)
#define WS_VERSION_MINOR                LOBYTE(WS_VERSION_REQUIRED)
 
// strings

#define NULLSTR					 TEXT("");
#ifdef HP_BUILD
#define PORTMONITOR_CLASS_NAME   TEXT("STDTCPMON")
#define PORTMONITOR_HELP_FILE    TEXT("HPTCPMUI.HLP")
#define PORTMONITOR_NAME         TEXT("HPTCPMON.DLL")
#define PORTMONITOR_UI_NAME      TEXT("HPTcpMUI.dll")
#define PORTMONITOR_DESC         TEXT("HP Standard TCP/IP Port")
#define SZEVENTLOG_NAME          TEXT("HPTcpMon")
#define PORTMONITOR_INI_FILE     TEXT("\\HPTcpMon.ini")
#else
#define PORTMONITOR_CLASS_NAME   TEXT("HPJETADMIN")
#define PORTMONITOR_HELP_FILE    TEXT("TCPMON.HLP")
#define PORTMONITOR_NAME         TEXT("TCPMON.DLL")
#define PORTMONITOR_UI_NAME      TEXT("TCPMonUI.dll")
#define PORTMONITOR_DESC         TEXT("Standard TCP/IP Port")
#define SZEVENTLOG_NAME          TEXT("TCPMon")
#define PORTMONITOR_INI_FILE     TEXT("\\TcpMon.ini")
#endif

#define DEFAULT_SNMP_COMMUNITYA  "public"
#define DEFAULT_SNMP_COMUNITY    TEXT( DEFAULT_SNMP_COMMUNITYA )
#define DEFAULT_QUEUE			 TEXT( "LPR" )
#define TCP_PROTOCOL             TEXT( "TCP_IP" )

// Defaults
#define DEFAULT_PORT_NUMBER  9100
#define DEFAULT_PROTOCOL		1
#define DEFAULT_VERSION			1

// SNMP Constants
#define DEFAULT_SNMP_DEVICE_INDEX 1

// lengths 
#define MAX_SECTION_NAME                 64
#define MAX_PRINTERNAME_LEN              MAX_UNC_PRINTER_NAME  // printer name 
#define MAX_FULLY_QUALIFIED_HOSTNAME_LEN 128                   // fully qualified hostname length
#define MAX_PORT_DESCRIPTION_LEN		 256
#define MAX_NUM_OF_DEVICEPORTS           1024

//Status Constants
#define PORT_STATUS_IDLE                 0
#define PORT_STATUS_ERROR                1
#define PORT_STATUS_PRINTING             2
#define STATUS_ERROR_FACTOR              20
#define STATUS_PRINTINT_FACTOR           10
#define STATUS_ERROR_MIN                 10                    // Seconds

class CPortMgr;
#define     MONITOR_SIGNATURE        (0xE9324C33)
typedef struct _MONITOR_HANDLE {
	DWORD           cb;
	DWORD           dSignature;
	CPortMgr        *pPortMgr;
} MONITOR_HANDLE, *PMONITOR_HANDLE;

typedef struct _SNMP_INFO
{
	TCHAR   sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	TCHAR   sztAddress[MAX_NETWORKNAME_LEN];
	DWORD   dwSNMPEnabled;
	DWORD   dwSNMPDeviceIndex;
}   SNMP_INFO, *PSNMP_INFO;


// This must be included after the length definitions because
// the structures in it depend on these definitions.

#define SPOOLER_SUPPORTED_LEVEL 2                   // spooler supported level

#ifdef __cplusplus
extern "C" {
#endif

	DWORD EncodeMonitorHandle( PHANDLE phMonitor, CPortMgr *pPortMgr );

	DWORD ValidateMonitorHandle( HANDLE hMonitor );

	DWORD FreeMonitorHandle( HANDLE hMonitor );

	BOOL WINAPI EndDocPort  (HANDLE hPort);
	BOOL WINAPI StartDocPort(HANDLE hPort,
							 LPTSTR pPrinterName,
							 DWORD  jobId,
							 DWORD  level,
							 LPBYTE pDocInfo);
	BOOL AddPortExW(LPTSTR psztName,
					DWORD  Level,   
					LPBYTE lpBuffer,
					LPTSTR psztMonitorName);

	BOOL WINAPI     AddPortUIEx(LPBYTE pData);
	BOOL WINAPI ConfigPortUIEx(const LPBYTE pData);

	BOOL ClusterOpenPort(HANDLE             hcKey,
						 LPTSTR         pName,
						 PHANDLE                pHandle);

	BOOL ClusterXcvOpenPort( HANDLE hcKey,
							  LPCTSTR               pszObject,
							  ACCESS_MASK   GrantedAccess,
						  PHANDLE               phXcv);

	BOOL ClusterAddPort(HANDLE      hcKey,
						LPTSTR  psztName,
						HWND    hWnd,
						LPTSTR  psztMonitorName);

	BOOL ClusterAddPortExW( HANDLE hcKey,
							LPTSTR psztName,
							DWORD  Level,   
							LPBYTE lpBuffer,
							LPTSTR psztMonitorName);

	BOOL ClusterConfigurePort(      HANDLE  hcKey,
								LPTSTR  psztName,
								HWND    hWnd,
								LPTSTR  psztPortName);

	BOOL ClusterDeletePort( HANDLE hcKey,
							LPTSTR psztName,
							HWND   hWnd,
							LPTSTR psztPortName);

	BOOL ClusterEnumPorts(  HANDLE          hcKey,
							LPTSTR          psztName,
							DWORD           Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
							LPBYTE          pPorts, // port data is written to
							DWORD           cbBuf,  // buffer size of pPorts points to
							LPDWORD         pcbNeeded,      // needed buffer size
							LPDWORD         pcReturned) ;   // number of structs written to pPorts

	VOID ClusterShutdown( HANDLE hTcpMon );

    _inline char *strncpyn(char *pszdest, const char *pszsrc, size_t n) {
        (strncpy( pszdest, pszsrc, n))[n - 1] = NULL;
        return pszdest;
    }



#ifdef __cplusplus
}
#endif

#endif // INC_HPSPPMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\precomp.h ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Weihai Chen (weihaic)  2/20/2001

Revision History:

--*/

#ifndef _TCPMIB_PRECOMP_H_
#define _TCPMIB_PRECOMP_H_

#include <windows.h>
//#include <windowsx.h>
#include <winsock2.h>
#include <ipexport.h>

#include <tchar.h>
#include <snmp.h>
#include <mgmtapi.h>

#include <stdio.h>
#include <winspool.h>
#include <stdlib.h>
#include <icmpapi.h>


//
//  Files at ..\Common
//
#include "tcpmon.h"
#include "rtcpdata.h"
#include "CoreUI.h"
#include "mibabc.h"
#include "debug.h"		// debug functions


#endif	// INC_PCH_SPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\pingicmp.h ===
/*****************************************************************************
 *
 * $Workfile: PingICMP.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/Common/PingICMP.h $
 *
 * 2     7/14/97 2:35p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:25p Binnur
 * Initial File
 *
 *****************************************************************************/

#ifndef INC_PINGICMP_H
#define INC_PINGICMP_H

class CMemoryDebug;

class CPingICMP
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CPingICMP( const char *pHost );
	~CPingICMP();

	BOOL	Ping();

private:
	HANDLE  hIcmp;
	int		m_iLastError;		// Last error from Winsock call

	char	m_szHost[MAX_NETWORKNAME_LEN];	
	BOOL	Open();
	BOOL	Close();
	IPAddr	ResolveAddress();

};

#endif	// INC_PINGICMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcpmib.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\snmpmgr.h ===
/*****************************************************************************
 *
 * $Workfile: SnmpMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_SNMPMGR_H
#define INC_SNMPMGR_H

#define	DEFAULT_IP_GET_COMMUNITY_ALT	"internal"	// HP devices only


#define	MAX_JDPORTS				3						// # of JetDirect Ex ports
#define	MAX_COMMUNITY_LEN		32						// maximum community length
#define	DEFAULT_SNMP_REQUEST	ASN_RFC1157_GETREQUEST	// get request is the default
#define	DEFAULT_TIMEOUT			6000					// milliseconds
#define	DEFAULT_RETRIES			3

typedef enum {
	DEV_UNKNOWN	= 0,
	DEV_OTHER	= 1,
	DEV_HP_JETDIRECT= 2,
	DEV_TEK_PRINTER	= 3,
	DEV_LEX_PRINTER	= 4,
	DEV_IBM_PRINTER	= 5,
	DEV_KYO_PRINTER	= 6,
	DEV_XER_PRINTER	= 7
}	DeviceType;

class CMemoryDebug;


class CSnmpMgr
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CSnmpMgr();
	CSnmpMgr( const char *pHost,
			  const char *pCommunity,
			  DWORD		 dwDevIndex);
	CSnmpMgr( const char			*pHost,
			  const char			*pCommunity,
			  DWORD					dwDevIndex,
			  AsnObjectIdentifier	*pMibObjId,
			  RFC1157VarBindList	*pVarBindList);
	~CSnmpMgr();

	INT		GetLastError(void)	 { return m_iLastError; };
	INT		Get( RFC1157VarBindList	*pVariableBindings);
	INT		Walk(RFC1157VarBindList *pVariableBindings);
	INT		WalkNext(RFC1157VarBindList  *pVariableBindings);
	INT		GetNext(RFC1157VarBindList  *pVariableBindings);
	DWORD	BldVarBindList( AsnObjectIdentifier   *pMibObjId,		// builds the varBindList
						    RFC1157VarBindList    *pVarBindList);

private:	// methods
	BOOL	Open();		// establish a session
	void	Close();	// close the previously established session

private:	// attributes
	LPSTR				m_pCommunity;
	LPSTR				m_pAgent;			
	LPSNMP_MGR_SESSION	m_pSession;

	INT					m_iLastError;
	INT					m_iTimeout;
	INT					m_iRetries;
	BYTE				m_bRequestType;
};


#endif	// INC_SNMPMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\status.h ===
/*****************************************************************************
 *
 * $Workfile: Status.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

//status.h

#ifndef STATUS_H
#define STATUS_H


/*  Asynch status codes, Peripheral Status Values */
#define MAX_ASYNCH_STATUS           76          /* MAX for generic printer applet */

#define ASYNCH_STATUS_UNKNOWN       0xFFFFFFFF
#define ASYNCH_PRINTER_ERROR        0
#define ASYNCH_DOOR_OPEN            1
#define ASYNCH_WARMUP               2
#define ASYNCH_RESET                3
#define ASYNCH_OUTPUT_BIN_FULL      4           /* yellow condition */
#define ASYNCH_PAPER_JAM            5
#define ASYNCH_TONER_GONE           6
#define ASYNCH_MANUAL_FEED          7
#define ASYNCH_PAPER_OUT            8
#define ASYNCH_PAGE_PUNT            9
#define ASYNCH_MEMORY_OUT           10
#define ASYNCH_OFFLINE              11
#define ASYNCH_INTERVENTION         12
#define ASYNCH_INITIALIZING         13
#define ASYNCH_TONER_LOW            14
#define ASYNCH_PRINTING_TEST_PAGE   15
#define ASYNCH_PRINTING             16
#define ASYNCH_ONLINE               17
#define ASYNCH_BUSY                 18
#define ASYNCH_NOT_CONNECTED        19
#define ASYNCH_STATUS_UNAVAILABLE   20
#define ASYNCH_NETWORK_ERROR        21
#define ASYNCH_COMM_ERROR           22
#define ASYNCH_BLACK_AGENT_EMPTY    23
#define ASYNCH_MAGENTA_AGENT_EMPTY  24
#define ASYNCH_CYAN_AGENT_EMPTY     25
#define ASYNCH_YELLOW_AGENT_EMPTY   26
#define ASYNCH_BLACK_AGENT_MISSING  27
#define ASYNCH_MAGENTA_AGENT_MISSING 28
#define ASYNCH_CYAN_AGENT_MISSING   29
#define ASYNCH_YELLOW_AGENT_MISSING 30
#define ASYNCH_TRAY1_EMPTY          31          /* yellow condition */
#define ASYNCH_TRAY2_EMPTY          32          /* yellow condition */
#define ASYNCH_TRAY3_EMPTY          33          /* yellow condition */
#define ASYNCH_TRAY1_JAM            34
#define ASYNCH_TRAY2_JAM            35
#define ASYNCH_TRAY3_JAM            36
#define ASYNCH_POWERSAVE_MODE       37          /* MAX for generic printer & Arrakis */
#define ASYNCH_ENVL_ERROR           38
#define ASYNCH_HCI_ERROR            39
#define ASYNCH_HCO_ERROR            40
#define ASYNCH_HCI_EMPTY            41          /* yellow condition */
#define ASYNCH_HCI_JAM              42
#define ASYNCH_TRAY1_ADD            43          /* red condition */
#define ASYNCH_TRAY2_ADD            44          /* red condition */
#define ASYNCH_TRAY3_ADD            45          /* red condition */
#define ASYNCH_HCI_ADD              46          /* red condition */
#define ASYNCH_TRAY1_UNKNOWN_MEDIA  47          /* yellow condition */
#define ASYNCH_CLEAR_OUTPUT_BIN     48          /* red condition */
#define ASYNCH_CARRIAGE_STALL             49
#define ASYNCH_COLOR_AGENT_EMPTY          50
#define ASYNCH_COLOR_AGENT_MISSING           51
#define ASYNCH_BLACK_AGENT_INCORRECT         52
#define ASYNCH_MAGENTA_AGENT_INCORRECT       53
#define ASYNCH_CYAN_AGENT_INCORRECT          54
#define ASYNCH_YELLOW_AGENT_INCORRECT        55
#define ASYNCH_COLOR_AGENT_INCORRECT         56
#define ASYNCH_BLACK_AGENT_INCORRECT_INSTALL 57
#define ASYNCH_MAGENTA_AGENT_INCORRECT_INSTALL  58
#define ASYNCH_CYAN_AGENT_INCORRECT_INSTALL     59
#define ASYNCH_YELLOW_AGENT_INCORRECT_INSTALL   60
#define ASYNCH_COLOR_AGENT_INCORRECT_INSTALL 61
#define ASYNCH_BLACK_AGENT_FAILURE           62
#define ASYNCH_MAGENTA_AGENT_FAILURE         63
#define ASYNCH_CYAN_AGENT_FAILURE            64
#define ASYNCH_YELLOW_AGENT_FAILURE          65
#define ASYNCH_COLOR_AGENT_FAILURE           66
#define ASYNCH_TRAY1_MISSING              67
#define ASYNCH_TRAY2_MISSING              68
#define ASYNCH_TRAY3_MISSING              69

//imports==================================================

#ifdef __cplusplus
extern "C" {
#endif

//prototypes===============================================
DWORD StdMibGetPeripheralStatus( const char *pHost, const char *pCommunity, DWORD dwDevIndex );
DWORD ProcessCriticalAlerts( DWORD errorState);
DWORD ProcessWarningAlerts( DWORD errorState);
DWORD ProcessOtherAlerts( DWORD deviceStatus);
void GetBitsFromString( LPSTR getVal, DWORD getSiz, LPDWORD bits);

#ifdef __cplusplus
}
#endif

#endif		//STATUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\snmpmgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: SnmpMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "stdoids.h"
#include "snmpmgr.h"


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr()

CSnmpMgr::CSnmpMgr() :
					m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
					m_iLastError(NO_ERROR),	m_iRetries(DEFAULT_RETRIES),
					m_iTimeout(DEFAULT_TIMEOUT),
					m_bRequestType(DEFAULT_SNMP_REQUEST)
{
}	// ::CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr() -- establishes a session w/ a given agent
//			uses the default request type (get) & community	name (public)

CSnmpMgr::CSnmpMgr( const char	in	*pHost,
				    const char  in  *pCommunity,
					DWORD			dwDevIndex ) :
						m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
						m_iLastError(NO_ERROR),	m_iRetries(DEFAULT_RETRIES),
						m_iTimeout(DEFAULT_TIMEOUT),
						m_bRequestType(DEFAULT_SNMP_REQUEST)
{
	m_pAgent = (LPSTR)SNMP_malloc(strlen(pHost) + 1);		// copy the agent
	if( m_pAgent != NULL )
	{
		strcpy(m_pAgent, pHost);
	}

	m_pCommunity = (LPSTR)SNMP_malloc(strlen(pCommunity) + 1);	// copy the community name
	if( m_pCommunity != NULL )
	{
		strcpy(m_pCommunity, pCommunity);
	}

	m_bRequestType = DEFAULT_SNMP_REQUEST;		// set the default request type == GET request

	m_pSession = NULL;
	if ( !Open() )				// establish a session w/ the agent
	{
		m_iLastError = GetLastError();
	}

}	// ::CSnmpMgr()

														
														///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr() -- establishes a session w/ a given agent
//			uses the default request type (get) & community	name (public)

CSnmpMgr::CSnmpMgr( const char			in	*pHost,
				    const char			in  *pCommunity,
					DWORD				in  dwDevIndex,
					AsnObjectIdentifier	in	*pMibObjId,
				    RFC1157VarBindList	out	*pVarBindList) :
						m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
						m_iLastError(NO_ERROR),	m_iRetries(DEFAULT_RETRIES),
						m_iTimeout(DEFAULT_TIMEOUT),
						m_bRequestType(DEFAULT_SNMP_REQUEST)
{
	DWORD	dwRetCode = SNMPAPI_NOERROR;

	m_pAgent = (LPSTR)SNMP_malloc(strlen(pHost) + 1);		// copy the agent
	if( m_pAgent != NULL )
	{
		strcpy(m_pAgent, pHost);
	}

	m_pCommunity = (LPSTR)SNMP_malloc(strlen(pCommunity) + 1);	// copy the community name
	if( m_pCommunity != NULL )
	{
		strcpy(m_pCommunity, pCommunity);
	}

	m_bRequestType = DEFAULT_SNMP_REQUEST;		// set the default request type == GET request

	dwRetCode = BldVarBindList(pMibObjId, pVarBindList);
	if (dwRetCode == SNMPAPI_NOERROR)
	{
		m_pSession = NULL;
		if ( !Open() )				// establish a session w/ the agent
		{
			m_iLastError = GetLastError();
		}
	}

}	// ::CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::~CSnmpMgr()

CSnmpMgr::~CSnmpMgr()
{
	if (m_pSession)		Close();	// close the session

	// delete the allocated memory from community & agent names
	if (m_pAgent)		SNMP_free(m_pAgent);
	if (m_pCommunity)	SNMP_free(m_pCommunity);

}	// ::~CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  Open() -- establishes a session
//		Error Codes:
//			SNMPAPI_NOERROR if successful
//			SNMPAPI_ERROR if fails

BOOL
CSnmpMgr::Open()
{
	m_iLastError = SNMPAPI_NOERROR;

	m_pSession = SnmpMgrOpen(m_pAgent, m_pCommunity, m_iTimeout, m_iRetries);
	if ( m_pSession == NULL )
	{
		m_iLastError = SNMPAPI_ERROR;
		m_pSession = NULL;
		return FALSE;
	}
	
	return TRUE;

}	// ::Open()


///////////////////////////////////////////////////////////////////////////////
//  Close() -- closes the previously established session

void
CSnmpMgr::Close()
{
	_ASSERTE( m_pSession != NULL);

	if ( !SnmpMgrClose(m_pSession) )
	{
		m_iLastError = GetLastError();
	}
	m_pSession = NULL;

}	// ::Close()


///////////////////////////////////////////////////////////////////////////////
//  Get() -- does an SNMP command (m_bRequestType) given a set of OIDs
//		Error Codes:
//				SNMP_ERRORSTATUS_NOERROR	if no error
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()

int
CSnmpMgr::Get( RFC1157VarBindList	in	*pVariableBindings)		
{
	int iRetCode = SNMP_ERRORSTATUS_NOERROR;

	AsnInteger	errorStatus;
	AsnInteger	errorIndex;

	if ( !SnmpMgrRequest( m_pSession, m_bRequestType, pVariableBindings, &errorStatus, &errorIndex) )
	{
		iRetCode = m_iLastError = GetLastError();
	}
	else
	{
		if (errorStatus > 0)
		{
			iRetCode = errorStatus;
		}
		else	// return the result of the variable bindings?
		{
			// variableBindings->list[x]->value contains the return value
		}
	}

	return iRetCode;

}	// ::Get()


///////////////////////////////////////////////////////////////////////////////
//	Walk -- given an object, it walks until the tree is done
//		Error Codes:
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()

int
CSnmpMgr::Walk(	RFC1157VarBindList  inout  *pVariableBindings)
{
	int iRetCode = SNMP_ERRORSTATUS_NOERROR;
	RFC1157VarBindList	variableBindings;
	UINT	numElements=0;
	LPVOID  pTemp;

	variableBindings.len = 0;
	variableBindings.list = NULL;

	variableBindings.len++;
	if ( (variableBindings.list = (RFC1157VarBind *)SNMP_realloc(variableBindings.list,		
			sizeof(RFC1157VarBind) * variableBindings.len)) == NULL)
	{
		iRetCode = ERROR_NOT_ENOUGH_MEMORY;
		return iRetCode;
	}

	if ( !SnmpUtilVarBindCpy(&(variableBindings.list[variableBindings.len -1]), &(pVariableBindings->list[0])) )
	{
		iRetCode = ERROR_NOT_ENOUGH_MEMORY;
		return iRetCode;
	}

	AsnObjectIdentifier root;
	AsnObjectIdentifier tempOid;
	AsnInteger	errorStatus;
	AsnInteger	errorIndex;

    if (!SnmpUtilOidCpy(&root, &variableBindings.list[0].name))
	{
		iRetCode = ERROR_NOT_ENOUGH_MEMORY;
		goto CleanUp;
	}

    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;
	while(1)		// walk the MIB tree (or sub-tree)
    {
		if (!SnmpMgrRequest(m_pSession, m_bRequestType, &variableBindings,
                        &errorStatus, &errorIndex))
        {
	        // The API is indicating an error.
			iRetCode = m_iLastError = GetLastError();
	        break;
        }
		else
        {
			// The API succeeded, errors may be indicated from the remote agent.
	        // Test for end of subtree or end of MIB.
			if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
						SnmpUtilOidNCmp(&variableBindings.list[0].name, &root, root.idLength))
            {
				iRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
	            break;
            }

	        // Test for general error conditions or sucesss.
	        if (errorStatus > 0)
            {
	           	iRetCode = errorStatus;
				break;
            }
			numElements++;
        } // end if()

		// append the variableBindings to the pVariableBindings
		_ASSERTE(pVariableBindings->len != 0);
		pVariableBindings->len++;
		if ( ( pTemp = (RFC1157VarBind *)SNMP_realloc(pVariableBindings->list,
				sizeof(RFC1157VarBind) * pVariableBindings->len)) == NULL)
		{
			iRetCode = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}
		else
		{
		    pVariableBindings->list = (SnmpVarBind *)pTemp;
		}
		
		if ( !SnmpUtilVarBindCpy(&(pVariableBindings->list[pVariableBindings->len -1]), &(variableBindings.list[0])) )
		{
			iRetCode = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}

	    // Prepare for the next iteration.  Make sure returned oid is
		// preserved and the returned value is freed
	    if( SnmpUtilOidCpy(&tempOid, &variableBindings.list[0].name) )
		{	
			SnmpUtilVarBindFree(&variableBindings.list[0]);

			if ( SnmpUtilOidCpy(&variableBindings.list[0].name, &tempOid))
			{
				variableBindings.list[0].value.asnType = ASN_NULL;
		
				SnmpUtilOidFree(&tempOid);
			}
			else
			{
				iRetCode = SNMP_ERRORSTATUS_GENERR;
				goto CleanUp;
			}
		}
		else
		{
			iRetCode = SNMP_ERRORSTATUS_GENERR;
			goto CleanUp;
		}


    } // end while()

CleanUp:
    // Free the variable bindings that have been allocated.
	SnmpUtilVarBindListFree(&variableBindings);
	SnmpUtilOidFree(&root);

	if (iRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
		if (numElements != 0)	// list is full; iRetCode indicates the end of the MIB
			iRetCode = SNMP_ERRORSTATUS_NOERROR;

	return (iRetCode);

}	// Walk()


///////////////////////////////////////////////////////////////////////////////
//	WalkNext -- given object(s), it walks until the table has no more object
//		entries. The end of the table is determined by the first item in the list.
//		Error Codes:
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()

int
CSnmpMgr::WalkNext(	RFC1157VarBindList  inout  *pVariableBindings)
{
	int iRetCode = SNMP_ERRORSTATUS_NOERROR;
	RFC1157VarBindList	variableBindings;
	UINT	numElements=0;
	UINT	len=0, i=0;
    LPVOID  pTemp;

	variableBindings.len = 0;
	variableBindings.list = NULL;

	variableBindings.len = pVariableBindings->len;
	if ( (variableBindings.list = (RFC1157VarBind *)SNMP_realloc(variableBindings.list,		
			sizeof(RFC1157VarBind) * variableBindings.len)) == NULL)
	{
		iRetCode = ERROR_NOT_ENOUGH_MEMORY;
		return iRetCode;
	}
	
	for (i=0; i<variableBindings.len; i++)
	{
		if ( !SnmpUtilVarBindCpy(&(variableBindings.list[i]), &(pVariableBindings->list[i])) )
		{
			iRetCode = ERROR_NOT_ENOUGH_MEMORY;
			return iRetCode;
		}
	}

	AsnObjectIdentifier root;
	AsnObjectIdentifier tempOid;
	AsnInteger	errorStatus;
	AsnInteger	errorIndex;

    if (!SnmpUtilOidCpy(&root, &variableBindings.list[0].name))
	{
		iRetCode = ERROR_NOT_ENOUGH_MEMORY;
		goto CleanUp;
	}


    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;
	while(1)		// get the object(s) in the MIB table
    {
		if (!SnmpMgrRequest(m_pSession, m_bRequestType, &variableBindings,
                        &errorStatus, &errorIndex))
        {
	        // The API is indicating an error.
			iRetCode = m_iLastError = GetLastError();
	        break;
        }
		else
        {
			// The API succeeded, errors may be indicated from the remote agent.
	        // Test for end of subtree or end of MIB.
			if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
						SnmpUtilOidNCmp(&variableBindings.list[0].name, &root, root.idLength))
            {
				iRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
	            break;
            }

	        // Test for general error conditions or sucesss.
	        if (errorStatus > 0)
            {
	           	iRetCode = errorStatus;
				break;
            }
			numElements++;
        } // end if()

		// append the variableBindings to the pVariableBindings
		_ASSERTE(pVariableBindings->len != 0);
		len = pVariableBindings->len;
		pVariableBindings->len += variableBindings.len;
		if ( (pTemp = (RFC1157VarBind *)SNMP_realloc(pVariableBindings->list,
				sizeof(RFC1157VarBind) * pVariableBindings->len)) == NULL)
		{
			iRetCode = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}
        else
        {
		    pVariableBindings->list = (SnmpVarBind *)pTemp;
        }

		int j=0;
		for ( i=len; i < pVariableBindings->len; i++, j++)
		{
			if ( !SnmpUtilVarBindCpy(&(pVariableBindings->list[i]), &(variableBindings.list[j])) )
			{
				iRetCode = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}
		}

	    // Prepare for the next iteration.  Make sure returned oid is
		// preserved and the returned value is freed
		for (i=0; i<variableBindings.len; i++)
		{
		    if ( SnmpUtilOidCpy(&tempOid, &variableBindings.list[i].name) )
			{
				SnmpUtilVarBindFree(&variableBindings.list[i]);
				if( SnmpUtilOidCpy(&variableBindings.list[i].name, &tempOid))
				{
					variableBindings.list[i].value.asnType = ASN_NULL;
					SnmpUtilOidFree(&tempOid);
				}
				else
				{
					iRetCode = SNMP_ERRORSTATUS_GENERR;
					goto CleanUp;
				}
			}
			else
			{
				iRetCode = SNMP_ERRORSTATUS_GENERR;
				goto CleanUp;
			}

		}

    } // end while()

CleanUp:
    // Free the variable bindings that have been allocated.
	SnmpUtilVarBindListFree(&variableBindings);
	SnmpUtilOidFree(&root);

	if (iRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
		if (numElements != 0)	// list is full; iRetCode indicates the end of the MIB
			iRetCode = SNMP_ERRORSTATUS_NOERROR;

	return (iRetCode);

}	// WalkNext()


///////////////////////////////////////////////////////////////////////////////
//	GetNext -- does an SNMP GetNext command on the set of OID(s)
//		Error Codes:
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()

int
CSnmpMgr::GetNext(	RFC1157VarBindList  inout  *pVariableBindings)
{
	int iRetCode = SNMP_ERRORSTATUS_NOERROR;
	AsnInteger	errorStatus;
	AsnInteger	errorIndex;

    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;

	if ( !SnmpMgrRequest( m_pSession, m_bRequestType, pVariableBindings, &errorStatus, &errorIndex) )
	{
		iRetCode = m_iLastError = GetLastError();
	}
	else
	{
		if (errorStatus > 0)
		{
			iRetCode = errorStatus;
		}
		else	// return the result of the variable bindings?
		{
			// variableBindings->list[x]->value contains the return value
		}
	}

	return (iRetCode);

}	// GetNext()


///////////////////////////////////////////////////////////////////////////////
//	BldVarBindList -- given a category, it retuns the RFC1157VarBindList
//		Error Codes:
//			NO_ERROR if successful
//			ERROR_NOT_ENOUGH_MEMORY		if memory allocation failes
//			ERROR_INVALID_HANDLE		if can't build the variable bindings

DWORD
CSnmpMgr::BldVarBindList( AsnObjectIdentifier in     *pMibObjId,		// group identifier
						  RFC1157VarBindList  inout  *pVarBindList)
{
	DWORD	dwRetCode = SNMPAPI_NOERROR;
    LPVOID  pTemp;

	m_iLastError = SNMPAPI_NOERROR;
	while (pMibObjId->idLength != 0)
	{
		// setup the variable bindings
        CONST UINT uNewLen = pVarBindList->len + 1;
		if ( (pTemp = (RFC1157VarBind *)SNMP_realloc(pVarBindList->list,		
				sizeof(RFC1157VarBind) * uNewLen)) == NULL)
		{
            m_iLastError = ERROR_NOT_ENOUGH_MEMORY;
            return ERROR_NOT_ENOUGH_MEMORY;
		}
        else
        {
		    pVarBindList->list = (SnmpVarBind *)pTemp;
            pVarBindList-> len = uNewLen;
        }

		AsnObjectIdentifier	reqObject;
		if ( !SnmpUtilOidCpy(&reqObject, pMibObjId) )
		{
			m_iLastError = ERROR_INVALID_HANDLE;
			return ERROR_INVALID_HANDLE;
		}

		pVarBindList->list[pVarBindList->len -1].name = reqObject;
		pVarBindList->list[pVarBindList->len -1].value.asnType = ASN_NULL;

		pMibObjId++;
	}
	
	return dwRetCode;

}	// BldVarBindList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\status.cpp ===
/*****************************************************************************
 *
 * $Workfile: Status.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdoids.h"
#include "status.h"


/********************************************************
    status notes:

    1. ASYNCH_NETWORK_ERROR handled by calling function,
        GetObjectSNMP() located in snmp.c

*********************************************************/



//constants==============================================
#define NA 0
#define OTHER_ALERTS        MAX_ASYNCH_STATUS+1
#define WARNING_ALERTS      MAX_ASYNCH_STATUS+2
#define CRITICAL_ALERTS     MAX_ASYNCH_STATUS+3

//hrPrinterDetectedErrorState Masks
#define LOW_PAPER               0x00000080
#define NO_PAPER                0x00000040
#define LOW_TONER               0x00000020
#define NO_TONER                0x00000010
#define DOOR_OPEN               0x00000008
#define PAPER_JAM               0x00000004
#define OFF_LINE                0x00000002
#define SERVICE_REQUESTED       0x00000001


//subunit status
#define AVAIL_IDLE              0L          //available and idle
#define AVAIL_STDBY             2L          //available and in standby
#define AVAIL_ACTIVE            4L          //available and active
#define AVAIL_BUSY              6L


#define UNAVAIL_ONREQ           1L          //unavailable and on-request
#define UNAVAIL_BROKEN          3L          //unavailable because broken
#define AVAIL_UNKNOWN           5L

#define NON_CRITICAL_ALERT      8L
#define CRITICAL_ALERT          16L

#define OFF_LINEx               32L

#define TRANS                   64L         //transitioning to intended state


#define NUM_TRAYS 2

/*************
   Printer     hrDeviceStatus  hrPrinterStatus  hrPrinterDetectedErrorState
   Status

   Normal         running(2)     idle(3)        none set

   Busy/          running(2)     printing(4)
   Temporarily
   Unavailable

   Non Critical   warning(3)     idle(3) or     could be: lowPaper,
   Alert Active                  printing(4)    lowToner, or
                                                serviceRequested

   Critical       down(5)        other(1)       could be: jammed,
   Alert Active                                 noPaper, noToner,
                                                coverOpen, or
                                                serviceRequested

   Unavailable    down(5)        other(1)

   Moving off-    warning(3)     idle(3) or     offline
   line                          printing(4)




   Smith, Wright, Hastings, Zilles & Gyllenskog                   [Page 14]

   RFC 1759                      Printer MIB                     March 1995


   Off-line       down(5)        other(1)       offline

   Moving         down(5)        warmup(5)
   on-line

   Standby        running(2)     other(1)
*************/

//lookup table for basic status
// [device status][printer status]
#define LOOKUP_TABLE_ROWS  5
#define LOOKUP_TABLE_COLS  5
BYTE basicStatusTable[LOOKUP_TABLE_COLS][LOOKUP_TABLE_ROWS] =
{
                    /*other                 unknown idle              printing                      warmup*/
/*unknown*/ { NA,                       NA,         NA,                     NA,                                 NA },
/*running*/ { ASYNCH_POWERSAVE_MODE,    NA,         ASYNCH_ONLINE,          ASYNCH_PRINTING,                    ASYNCH_WARMUP },
/*warning*/ { NA,                       NA,         WARNING_ALERTS,         WARNING_ALERTS,                     WARNING_ALERTS },
/*testing*/ { OTHER_ALERTS,             NA,         NA,                     ASYNCH_PRINTING_TEST_PAGE,          NA },
/*down*/    { CRITICAL_ALERTS,          NA,         NA,                     NA,                                 ASYNCH_WARMUP }
};


///////////////////////////////////////////////////////////////////////////////
//  StdMibGetPeripheralStatus
//      Returns Printer status ( Async Code )
//          or ASYNCH_STATUS_UNKNOWN     if Printer MIB is not supported on the device

DWORD
StdMibGetPeripheralStatus( const char in *pHost,
                           const char in *pCommunity,
                           DWORD      in dwDevIndex)
{
    DWORD       dwRetCode   = NO_ERROR;
    DWORD       errorState;
    WORD        wLookup     = NA;
    RFC1157VarBindList  variableBindings;

    UINT  OID_HRMIB_hrDeviceStatus[]                = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5, dwDevIndex};
    UINT  OID_HRMIB_hrPrinterStatus[]               = { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1, dwDevIndex};
    UINT  OID_HRMIB_hrPrinterDetectedErrorState[]   = { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2, dwDevIndex};

    AsnObjectIdentifier OT_DEVICE_STATUS[] = {  { OID_SIZEOF(OID_HRMIB_hrDeviceStatus), OID_HRMIB_hrDeviceStatus },
                                                { OID_SIZEOF(OID_HRMIB_hrPrinterStatus), OID_HRMIB_hrPrinterStatus },
                                                { OID_SIZEOF(OID_HRMIB_hrPrinterDetectedErrorState), OID_HRMIB_hrPrinterDetectedErrorState },
                                                { 0, 0 } };
    // build the variable bindings list
    variableBindings.list = NULL;
    variableBindings.len = 0;

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);

    if ( !pSnmpMgr )
    {
        return ERROR_OUTOFMEMORY;
    }

    if (pSnmpMgr->GetLastError() != SNMPAPI_NOERROR )
    {
        delete pSnmpMgr;
        return ASYNCH_STATUS_UNKNOWN;
    }

    dwRetCode = pSnmpMgr->BldVarBindList(OT_DEVICE_STATUS, &variableBindings);
    if (dwRetCode != SNMPAPI_NOERROR)
    {
        SnmpUtilVarBindListFree(&variableBindings);
        delete pSnmpMgr;
        return ASYNCH_STATUS_UNKNOWN;
    }

    // get the status objects
    dwRetCode = pSnmpMgr->Get(&variableBindings);
    if (dwRetCode != NO_ERROR)
    {
        SnmpUtilVarBindListFree(&variableBindings);
        delete pSnmpMgr;
        if (dwRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
            dwRetCode = ASYNCH_ONLINE;
        else
            dwRetCode = ASYNCH_STATUS_UNKNOWN;
        return dwRetCode;
    }


    if(dwRetCode == NO_ERROR)
    {
        if( (variableBindings.list[0].value.asnValue.number-1 < 0) ||
            (variableBindings.list[0].value.asnValue.number-1>=LOOKUP_TABLE_COLS) )
        {
            wLookup = OTHER_ALERTS;
        }
        else if( (variableBindings.list[1].value.asnValue.number-1 < 0) ||
                 (variableBindings.list[1].value.asnValue.number-1 >=LOOKUP_TABLE_ROWS) )
        {
            wLookup = OTHER_ALERTS;
        }
        else
        {
            wLookup = basicStatusTable[variableBindings.list[0].value.asnValue.number-1]
                                      [variableBindings.list[1].value.asnValue.number-1];
        }
        switch(wLookup)
        {
            case NA:
                dwRetCode = ASYNCH_STATUS_UNKNOWN;
                break;

            case CRITICAL_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessCriticalAlerts(errorState);
                break;

            case WARNING_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessWarningAlerts(errorState);
                break;

            case OTHER_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessOtherAlerts( errorState);
                break;

            default:
                dwRetCode = wLookup;
                break;
        }
    }
    else
    {
        dwRetCode = ASYNCH_STATUS_UNKNOWN;
    }


    SnmpUtilVarBindListFree(&variableBindings);
    delete pSnmpMgr;

    return dwRetCode;

}   // StdMibGetPeripheralStatus()


///////////////////////////////////////////////////////////////////////////////
//  ProcessCriticalAlerts  - determine active critical error
//
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )

DWORD
ProcessCriticalAlerts( DWORD    errorState )
{
    DWORD status = ASYNCH_ONLINE;

    if ( errorState & DOOR_OPEN) {
        status = ASYNCH_DOOR_OPEN;
    }
    else if( errorState & NO_TONER) {
        status = ASYNCH_TONER_GONE;
    }
    else if( errorState & NO_PAPER) {
        status = ASYNCH_PAPER_OUT;
    }
    else if( errorState & PAPER_JAM ) {
        status = ASYNCH_PAPER_JAM;
    }
    else if(errorState & SERVICE_REQUESTED) {
        status = ASYNCH_PRINTER_ERROR;
    }
    else if( errorState & OFF_LINE) {
        status = ASYNCH_OFFLINE;
    }
    else
        status = ASYNCH_PRINTER_ERROR;

    return status;

}   // ProcessCriticalAlerts()

///////////////////////////////////////////////////////////////////////////////
//  ProcessWarningAlerts  - determine active warning
//
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )

DWORD
ProcessWarningAlerts( DWORD errorState )
{
    DWORD status = ASYNCH_ONLINE;

    if( errorState & LOW_PAPER) {
        status = ASYNCH_ONLINE;
    }
    else if(errorState & LOW_TONER) {
        status = ASYNCH_TONER_LOW;
    }
    else if( errorState & SERVICE_REQUESTED) {

        // Changed it from ASYNCH_INTERVENTION; since if hrDeviceStatus = warning,
        // the printer can still print even though hrPrinterDetectedErrorState = serviceRequested
        //

        status = ASYNCH_ONLINE;
    }
    else if( errorState == 0) {
        status = ASYNCH_ONLINE;
    }
    else {
        status = ASYNCH_STATUS_UNKNOWN;
    }

    return status;
}   // ProcessWarningAlerts()

///////////////////////////////////////////////////////////////////////////////
//  ProcessWarningAlerts  - determine status for other Alerts
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )
DWORD ProcessOtherAlerts( DWORD errorState )
{
    DWORD status = ASYNCH_ONLINE;

    //
    // This is a place holder for future functionality
    //

    status = ASYNCH_STATUS_UNKNOWN;

    return status;
}   // ProcessOtherAlerts

///////////////////////////////////////////////////////////////////////////////
//  GetBitsFromString  -
//      extracts the bin numbers from collection string returned by the get
//
void GetBitsFromString( LPSTR    getVal,
                        DWORD    getSiz,
                        LPDWORD  bits)
{
   char* ptr = (char*)bits;
   *bits = 0;

#if defined(_INTEL) || defined(WINNT)

   switch(getSiz)
   {
      case 1:
         ptr[0] = getVal[0];
         break;

      case 2:
         ptr[1] = getVal[0];
         ptr[0] = getVal[1];
         break;

      case 3:
         ptr[2] = getVal[0];
         ptr[1] = getVal[1];
         ptr[0] = getVal[2];
         break;

      case 4:
         ptr[3] = getVal[0];
         ptr[2] = getVal[1];
         ptr[1] = getVal[2];
         ptr[0] = getVal[3];
         break;
   }

#elif defined(_MOTOROLLA)

   switch(getSiz)
   {
      case 1:
         ptr[3] = getVal[0];
         break;

      case 2:
         ptr[2] = getVal[0];
         ptr[3] = getVal[1];
         break;

      case 3:
         ptr[1] = getVal[0];
         ptr[2] = getVal[1];
         ptr[3] = getVal[2];
         break;

      case 4:
         ptr[0] = getVal[0];
         ptr[1] = getVal[1];
         ptr[2] = getVal[2];
         ptr[3] = getVal[3];
         break;
   }

#else

   #error #define a swap method ( _INTEL, _MOTOROLLA )

#endif /* _INTEL, _MOTOROLLA */

}   // GetBitsFromString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdmib.h ===
/*****************************************************************************
 *
 * $Workfile: StdMib.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_STDMIB_H
#define INC_STDMIB_H

#define	IFTYPE_OTHER		1
#define	IFTYPE_ETHERNET		6

enum SNMPCMD	{ SNMP_GET,			// SNMP commands
				  SNMP_WALK,
				  SNMP_GETNEXT,
				  SNMP_SET };

class CMemoryDebug;
class CTcpMib;

class CStdMib
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CStdMib( CTcpMib *pParent );

	CStdMib(const char	*pHost,
		    const char  *pszCommunity,
			DWORD		dwDevIndex,
			CTcpMib		*pParent );

	~CStdMib();

	BOOL	GetDeviceDescription(LPTSTR       pszPortDescription, DWORD dwDescLen);
	DWORD	GetDeviceStatus( );
	DWORD	GetJobStatus( );
	DWORD	GetDeviceHWAddress( LPTSTR psztHWAddress, DWORD dwSize);
	DWORD	GetDeviceName( LPTSTR psztDescription, DWORD dwSize );
	BOOL	TestPrinterMIB( );
	DWORD	MapJobErrorToSpooler( const DWORD dwStatus);

private:	// method
	DWORD	OIDQuery( AsnObjectIdentifier *pMibObjId,
					  SNMPCMD			  eSnmpCmd);	
	DWORD	OIDQuery( RFC1157VarBindList *pVarBindList,
					  SNMPCMD			 eSnmpCmd );
	BOOL	OIDVarBindCpy( RFC1157VarBindList	*pVarBindList );
    static  BOOL GetAsnOctetString(  char               *pszStr,
                                     DWORD              dwCount,
                                     RFC1157VarBindList *pVarBindList,
                                     UINT               i);



private:	// attributes
	char	m_szAgent[MAX_NETWORKNAME_LEN];
	char	m_szCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD	m_dwDevIndex;
	CTcpMib	*m_pParent;

	RFC1157VarBindList	m_VarBindList;

};


#endif	// INC_STDMIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdmib.cpp ===
/*****************************************************************************
 *
 * $Workfile: StdMib.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdoids.h"
#include "status.h"
#include "stdmib.h"
#include "tcpmib.h"


///////////////////////////////////////////////////////////////////////////////
//  CStdMib::CStdMib()

CStdMib::CStdMib( CTcpMib	in	*pParent ) :
					m_dwDevIndex( 1 ),m_pParent(pParent)
{
	m_VarBindList.len = 0;
	m_VarBindList.list = NULL;

	*m_szAgent = '\0';
	strncpyn(m_szCommunity, DEFAULT_SNMP_COMMUNITYA, sizeof( m_szCommunity));
}	// ::CStdMib()

///////////////////////////////////////////////////////////////////////////////
//  CStdMib::CStdMib()

CStdMib::CStdMib(const char in *pHost,
				 const char in *pCommunity,
				 DWORD		   dwDevIndex,
				 CTcpMib	in *pParent ) :
					m_dwDevIndex( dwDevIndex ),m_pParent(pParent)
{
	m_VarBindList.len = 0;
	m_VarBindList.list = NULL;

	strncpyn(m_szAgent, pHost, sizeof( m_szAgent ));
	strncpyn(m_szCommunity, pCommunity, sizeof( m_szCommunity ));
}	// ::CStdMib()


///////////////////////////////////////////////////////////////////////////////
//  CStdMib::~CStdMib()

CStdMib::~CStdMib()
{
	m_pParent = NULL;
}	// ::~CStdMib()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceDescription
//

BOOL
CStdMib::GetDeviceDescription(
    OUT LPTSTR       pszPortDescription,
	IN  DWORD	     dwDescLen
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLen;
    LPSTR   psz;

    m_VarBindList.list = NULL;
    m_VarBindList.len = 0;

    if ( NO_ERROR != OIDQuery(OT_DEVICE_SYSDESCR, SNMP_GET) )
        goto cleanup;

    //
    // If we got the device description successfully, allocate memory and
    // return this back in a UNICODE string. Caller is responsible for
    // freeing it using free()
    //
    psz = (LPSTR)m_VarBindList.list[0].value.asnValue.string.stream;
    dwLen = (DWORD)m_VarBindList.list[0].value.asnValue.string.length;

    if ( bRet = MultiByteToWideChar(CP_ACP,
                                    MB_PRECOMPOSED,
                                    psz,
                                    dwLen,
                                    pszPortDescription,
                                    dwDescLen) )
        pszPortDescription[dwDescLen-1] = TEXT('\0');

cleanup:
    SnmpUtilVarBindListFree(&m_VarBindList);

    return bRet;

}	// ::GetDeviceDescription()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceStatus -- gets the device status

DWORD
CStdMib::GetDeviceStatus( )
{
	DWORD	dwRetCode = NO_ERROR;

	dwRetCode = StdMibGetPeripheralStatus( m_szAgent, m_szCommunity, m_dwDevIndex);

	return dwRetCode;

}	// ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus -- gets the device status, and maps it to the spooler
//		error codes -- see JOB_INFO_2
//			Error Codes:
//				Spooler error codes

DWORD
CStdMib::GetJobStatus( )
{
	DWORD	dwRetCode = NO_ERROR;
	DWORD	dwStatus = NO_ERROR;

	dwRetCode = StdMibGetPeripheralStatus( m_szAgent, m_szCommunity, m_dwDevIndex );
	if (dwRetCode != NO_ERROR)
	{
		dwStatus = MapJobErrorToSpooler( dwRetCode );
	}

	return dwStatus;

}	// ::GetJobStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceAddress -- gets the device hardware address
//		Error Codes:
//			NO_ERROR if successful
//			ERROR_NOT_ENOUGH_MEMORY		if memory allocation failes
//			ERROR_INVALID_HANDLE		if can't build the variable bindings
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()
//			SNMPAPI_ERROR if open fails -- set by GetLastError()

DWORD
CStdMib::GetDeviceHWAddress( LPTSTR out	psztHWAddress,
							 DWORD dwSize ) // Size of in characters in of HW address
{
	DWORD	dwRetCode = NO_ERROR;
	UINT i = 0;
	char szTmpHWAddr[256];

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	// get the hardware address
	dwRetCode = OIDQuery(OT_DEVICE_ADDRESS, SNMP_GETNEXT);		// query the first entry in the table
	if (dwRetCode != NO_ERROR)
	{
		goto cleanup;
	}

	while (1)	// instead of walking the tree, do a get next, until we filled up the HW address -- saves on the network communications
	{
		i = 0;
		// process the variableBinding
		if ( IS_ASN_INTEGER(m_VarBindList, i) )	// check the ifType
		{
			if ( GET_ASN_NUMBER(m_VarBindList, i) == IFTYPE_ETHERNET)
			{
				sprintf(szTmpHWAddr, "%02X%02X%02X%02X%02X%02X", GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 0),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 1),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 2),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 3),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 4),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 5) );
				MBCS_TO_UNICODE(psztHWAddress, dwSize, szTmpHWAddr);
				dwRetCode = NO_ERROR;
				break;
			}
			else if ( GET_ASN_NUMBER(m_VarBindList, i) == IFTYPE_OTHER)	// apperently, XEROX encodes their HW address w/ ifType = other
			{
				// check if the HWAddress is NULL
				if ( GET_ASN_STRING_LEN(m_VarBindList, i+1) != 0)
				{
					sprintf(szTmpHWAddr, "%02X%02X%02X%02X%02X%02X", GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 0),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 1),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 2),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 3),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 4),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 5) );
					MBCS_TO_UNICODE(psztHWAddress, dwSize, szTmpHWAddr);
					dwRetCode = NO_ERROR;
					break;
				}
			}
		}

		// didn't get what we were looking for, so copy the address over & do a another GetNext()
		if( !OIDVarBindCpy(&m_VarBindList) )
		{
			dwRetCode = GetLastError();
			goto cleanup;
		}

		if ( !SnmpUtilOidNCmp( &m_VarBindList.list[0].name, &OID_Mib2_ifTypeTree, OID_Mib2_ifTypeTree.idLength) )
		{
			break;		// end of the tree
		}

		dwRetCode = OIDQuery(&m_VarBindList, SNMP_GETNEXT);		// query the next entry in the table
		if (dwRetCode != NO_ERROR)		
		{
			goto cleanup;
		}
	}	// end while()

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);

	return dwRetCode;

}	// ::GetDeviceHWAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- gets the device description, such as the manufacturer string
//		Error Codes:
//			NO_ERROR if successful
//			ERROR_NOT_ENOUGH_MEMORY		if memory allocation failes
//			ERROR_INVALID_HANDLE		if can't build the variable bindings
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()
//			SNMPAPI_ERROR	if Open() for session fails

DWORD
CStdMib::GetDeviceName( LPTSTR out psztDescription,
					    DWORD  in  dwSize ) //Size in characters of the psztDescription
{
	DWORD	dwRetCode = NO_ERROR;

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	// 1st test for the support of Printer MIB -- note if Printer MIB supported, so is HR MIB
	BOOL bTestPrtMIB = TestPrinterMIB();

	char		szTmpDescr[MAX_DEVICEDESCRIPTION_STR_LEN];
	UINT i=0;
	// process the bindings
	if (bTestPrtMIB)	// parse the data from the HR MIB device entry
	{
		while (1)	// instead of walking the tree, do a get next, until we filled up the HW address -- saves on the network communications
		{
			i = 0;
			dwRetCode = OIDQuery(OT_DEVICE_DESCRIPTION, SNMP_GETNEXT);
			if (dwRetCode != NO_ERROR)
			{
				goto cleanup;
			}

			// process the variableBinding
			if ( IS_ASN_OBJECTIDENTIFIER(m_VarBindList, i) )	// check the hrDeviceType
			{
				// compare it to hrDevicePrinter
				if (SnmpUtilOidCmp(GET_ASN_OBJECT(&m_VarBindList, i), &HRMIB_hrDevicePrinter) == 0)
				{
					// found the printer description, get the hrDeviceDescr
					if ( IS_ASN_OCTETSTRING(m_VarBindList, i) )
					{
						if (GET_ASN_OCTETSTRING(szTmpDescr, sizeof(szTmpDescr), m_VarBindList, i))
                        {
                            MBCS_TO_UNICODE(psztDescription, dwSize, szTmpDescr);
                            dwRetCode = NO_ERROR;
                            break;
                        } else
                        {
                            dwRetCode =  SNMP_ERRORSTATUS_TOOBIG;
                            break;
                        }
					}
					else
					{
						dwRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
						break;
					}
				}
			}
			
			// didn't get what we were looking for, so copy the address over & do a another GetNext()
			if( !OIDVarBindCpy(&m_VarBindList) )
			{
				dwRetCode = GetLastError();
				goto cleanup;
			}
		}	// end while()

	}	// if TestPrinterMIB() TRUE
	else
	{
		dwRetCode = OIDQuery(OT_DEVICE_SYSDESCR, SNMP_GET);
		if (dwRetCode != NO_ERROR)
		{
			goto cleanup;
		}
		// process the variables
		if (GET_ASN_OCTETSTRING(szTmpDescr, sizeof(szTmpDescr), m_VarBindList, i))
        {
            MBCS_TO_UNICODE(psztDescription, dwSize, szTmpDescr);
            dwRetCode = NO_ERROR;
        }
	}	// if TestPrinterMIB() FALSE

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);

	return dwRetCode;

}	// ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  TestPrinterMIB -- tests if the device supports Printer MIB

BOOL
CStdMib::TestPrinterMIB( )
{
	DWORD	dwRetCode = NO_ERROR;
	BOOL	bRetCode = FALSE;

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	dwRetCode = OIDQuery(OT_TEST_PRINTER_MIB, SNMP_GETNEXT);
	if (dwRetCode != NO_ERROR)
	{
		bRetCode = FALSE;
		goto cleanup;
	}

	// compare the resulting value w/ the Printer MIB tree value
	if (SnmpUtilOidNCmp(GET_ASN_OID_NAME(&m_VarBindList, 0), &PrtMIB_OidPrefix, PrtMIB_OidPrefix.idLength) == 0)
	{
		bRetCode = TRUE;
		goto cleanup;
	}

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);
	
	return (bRetCode);

}	// ::TestPrinterMIB()


///////////////////////////////////////////////////////////////////////////////
//  OIDQuery -- calls into the CTcpMib class to query the OIDs passed in

DWORD	
CStdMib::OIDQuery( AsnObjectIdentifier in *pMibObjId,
				   SNMPCMD			   in eSnmpCmd )
{
	DWORD	dwRetCode = NO_ERROR;

	if( m_pParent == NULL ) {
		dwRetCode = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	switch (eSnmpCmd)
	{
		case SNMP_GET:
			dwRetCode = m_pParent->SnmpGet(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_WALK:
			dwRetCode = m_pParent->SnmpWalk(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_GETNEXT:
			dwRetCode = m_pParent->SnmpGetNext(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_SET:
		default:
			dwRetCode = ERROR_NOT_SUPPORTED;
			goto cleanup;
	}

cleanup:
	if (dwRetCode != NO_ERROR)
	{
		SnmpUtilVarBindListFree(&m_VarBindList);
	}

	return (dwRetCode);

}	// ::OIDQuery()


///////////////////////////////////////////////////////////////////////////////
//  OIDQuery -- calls into the CTcpMib class to query the OIDs passed in

DWORD	
CStdMib::OIDQuery( RFC1157VarBindList inout *pVarBindList,
				   SNMPCMD			  in	eSnmpCmd )
{
	DWORD	dwRetCode = NO_ERROR;

	if( m_pParent == NULL ) {
		dwRetCode = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	switch (eSnmpCmd)
	{
		case SNMP_GET:
			dwRetCode = m_pParent->SnmpGet(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_WALK:
			dwRetCode = m_pParent->SnmpWalk(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_GETNEXT:
			dwRetCode = m_pParent->SnmpGetNext(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_SET:
		default:
			dwRetCode = ERROR_NOT_SUPPORTED;
			goto cleanup;
	}

cleanup:
	if (dwRetCode != NO_ERROR)
	{
		SnmpUtilVarBindListFree(pVarBindList);
	}

	return (dwRetCode);

}	// ::OIDQuery()


///////////////////////////////////////////////////////////////////////////////
//  OIDVarBindCpy --

BOOL	
CStdMib::OIDVarBindCpy( RFC1157VarBindList	inout	*pVarBindList )
{		
	UINT	i=0;
	AsnObjectIdentifier tempOid;

	for (i=0; i< PRFC1157_VARBINDLIST_LEN(pVarBindList); i++)
	{
		if( SnmpUtilOidCpy( &tempOid, &(PGET_ASN_OID_NAME(pVarBindList, i))))
		{
			SnmpUtilVarBindFree(&(pVarBindList->list[i]));
			if ( SnmpUtilOidCpy(&(PGET_ASN_OID_NAME(pVarBindList, i)), &tempOid))
			{
				PGET_ASN_TYPE(pVarBindList, i) = ASN_NULL;
				SnmpUtilOidFree(&tempOid);
			}
			else
			{
				return(FALSE);
			}
		}
		else
		{
			return(FALSE);
		}
	}
	
	return( TRUE );
}	// ::OIDVarBindCpy()


///////////////////////////////////////////////////////////////////////////////
//  MapJobErrorToSpooler -- Maps the received device error to the spooler
//		error codes.
//		Return Values:
//			Spooler device error codes

DWORD
CStdMib::MapJobErrorToSpooler( const DWORD in dwStatus)
{
	DWORD	dwRetCode = NO_ERROR;

	switch (dwStatus)
	{
		case ASYNCH_WARMUP:
		case ASYNCH_INITIALIZING:
			dwRetCode = JOB_STATUS_OFFLINE;
			break;
		case ASYNCH_DOOR_OPEN:
		case ASYNCH_PRINTER_ERROR:
		case ASYNCH_TONER_LOW:
		case ASYNCH_OUTPUT_BIN_FULL:
		case ASYNCH_STATUS_UNKNOWN:
		case ASYNCH_RESET:
		case ASYNCH_MANUAL_FEED:
		case ASYNCH_BUSY:
		case ASYNCH_PAPER_JAM:
		case ASYNCH_TONER_GONE:
			dwRetCode = JOB_STATUS_ERROR;
			break;
		case ASYNCH_PAPER_OUT:
			dwRetCode = JOB_STATUS_PAPEROUT;
			break;
		case ASYNCH_OFFLINE:
			dwRetCode = JOB_STATUS_OFFLINE;
			break;
		case ASYNCH_INTERVENTION:
			dwRetCode = JOB_STATUS_USER_INTERVENTION;
			break;
		case ASYNCH_PRINTING:
			dwRetCode = JOB_STATUS_PRINTING;
			break;
		case ASYNCH_ONLINE:
			dwRetCode = NO_ERROR;		
			break;
		default:
			dwRetCode = JOB_STATUS_PRINTING;
	}
	
	return dwRetCode;

}	// ::MapJobErrorToSpooler()

BOOL CStdMib::GetAsnOctetString(  char               *pszStr,
                                  DWORD              dwCount,
                                  RFC1157VarBindList *pVarBindList,
                                  UINT               i) {

    _ASSERTE( pszStr && pVarBindList );

    DWORD dwSize = GET_ASN_STRING_LEN( *pVarBindList, i);

    return dwCount >= dwSize ?
           memcpy(pszStr, pVarBindList->list[i].value.asnValue.string.stream, dwSize) != NULL :
           FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdoids.h ===
/*****************************************************************************
 *
 * $Workfile: StdOids.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/TcpMib/StdOids.h $
 * 
 * 4     9/22/97 2:15p Dsnelson
 * Updates the device status based on the device index
 * 
 * 3     7/18/97 1:16p Binnur
 * Fixed the Hardware address code
 * 
 * 2     7/14/97 2:34p Binnur
 * copyright statement
 * 
 * 1     7/08/97 5:18p Binnur
 * Initial File
 * 
 * 1     7/02/97 2:25p Binnur
 * Initial File
 * 
 *****************************************************************************/

#ifndef INC_OIDLIST_H
#define INC_OIDLIST_H

// Macro to determine number of sub-oid's in array.
#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )
#define	MAX_OIDSTR_SIZE		256

#define MIB_NUMITEMS(mib)		( sizeof(mib)/sizeof(AsnObjectIdentifier) )

// System Groups
extern AsnObjectIdentifier OT_DEVICE_TYPE[];		// identifies the type of device, such as multi-port device
extern AsnObjectIdentifier OT_DEVICE_TCPPORTS[];	// identifies the TCP ports on the device
extern AsnObjectIdentifier OT_DEVICE_ADDRESS[];		// identifies the hardware address of the device
extern AsnObjectIdentifier OT_DEVICE_SYSDESCR[];		// identifies the device manufacturer (description) -- mib2 table
extern AsnObjectIdentifier OT_DEVICE_DESCRIPTION[];		// identifies the device manufacturer -- host resources table
extern AsnObjectIdentifier OT_TEST_PRINTER_MIB[];		// tests the existance of Printer MIB

extern AsnObjectIdentifier PrtMIB_OidPrefix;			// identifies the Printer MIB tree
extern AsnObjectIdentifier HRMIB_hrDevicePrinter;		// identifies the printer entry in the HR device table
extern AsnObjectIdentifier OID_Mib2_ifTypeTree;


#endif	// INC_OIDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdoids.cpp ===
/*****************************************************************************
 *
 * $Workfile: StdOids.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "stdoids.h"


// MIB2 group
UINT OID_Mib2_Prefix[] = { 1, 3, 6, 1, 2, 1 };
AsnObjectIdentifier MIB2_OidPrefix = { OID_SIZEOF(OID_Mib2_Prefix), OID_Mib2_Prefix };

// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
// all others are used for GetNext purposes, and they are located in a table

// MIB2 - system group
UINT OID_Mib2_sysDescr[] = { 1, 3, 6, 1, 2, 1, 1, 1, 0 };
UINT OID_Mib2_sysContact[] = { 1, 3, 6, 1, 2, 1, 1, 4, 0};

// MIB2 - interfaces group
UINT OID_Mib2_ifType[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 3 };
AsnObjectIdentifier OID_Mib2_ifTypeTree = { OID_SIZEOF(OID_Mib2_ifType), OID_Mib2_ifType };
UINT OID_Mib2_ifPhysAddress[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 6 };


// MIB2 - tcp group
UINT OID_Mib2_tcpConnTable[] = { 1, 3, 6, 1, 2, 1, 6, 13, 1 };
UINT OID_Mib2_tcpConnLocalPort[] = { 1, 3, 6, 1, 2, 1, 6, 13, 1, 3 };

// Printer MIB group
UINT OID_PrtMIB_Prefix[] = { 1, 3, 6, 1, 2, 1, 43 };
AsnObjectIdentifier PrtMIB_OidPrefix = { OID_SIZEOF(OID_PrtMIB_Prefix), OID_PrtMIB_Prefix };

UINT OID_PrtMIB_testPrinterMIB[] = { 1, 3, 6, 1, 2, 1, 43 };

// HR MIB - host resources
UINT OID_HRMIB_hrDeviceType[] = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 2};
UINT OID_HRMIB_hrDeviceDescr[] = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 3};
UINT OID_HRMIB_hrDevicePrinter[] = { 1, 3, 6, 1, 2, 1, 25, 3, 1, 5};
AsnObjectIdentifier HRMIB_hrDevicePrinter = { OID_SIZEOF(OID_HRMIB_hrDevicePrinter), OID_HRMIB_hrDevicePrinter };

// status objects are defined in status .cpp
//  OID_HRMIB_hrDeviceStatus[] 				= { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5, 1};
//  OID_HRMIB_hrPrinterStatus[] 				= { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1, 1};
//  OID_HRMIB_hrPrinterDetectedErrorState[] 	= { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2, 1};


// OT_groups
// tests the existance of Printer MIB in the device
AsnObjectIdentifier OT_TEST_PRINTER_MIB[] =   {	{ OID_SIZEOF(OID_PrtMIB_testPrinterMIB), OID_PrtMIB_testPrinterMIB },
												{ 0, 0}
											};

// identifies the type of device
AsnObjectIdentifier OT_DEVICE_TYPE[] =  {	{ OID_SIZEOF(OID_Mib2_sysDescr), OID_Mib2_sysDescr },
											{ OID_SIZEOF(OID_Mib2_tcpConnLocalPort), OID_Mib2_tcpConnLocalPort },
											{ 0, 0}
										};

// identifies the ports on the device
AsnObjectIdentifier OT_DEVICE_TCPPORTS[] =  {	{ OID_SIZEOF(OID_Mib2_tcpConnLocalPort), OID_Mib2_tcpConnLocalPort },
												{ 0, 0}
											};

// identifies the hardware address of the device
AsnObjectIdentifier OT_DEVICE_ADDRESS[] =   {	{ OID_SIZEOF(OID_Mib2_ifType), OID_Mib2_ifType },
												{ OID_SIZEOF(OID_Mib2_ifPhysAddress), OID_Mib2_ifPhysAddress },
												{ 0, 0}
											};

// identifies the MIB 2 device description
AsnObjectIdentifier OT_DEVICE_SYSDESCR[] =   {	{ OID_SIZEOF(OID_Mib2_sysDescr), OID_Mib2_sysDescr },
												{ 0, 0}
											};

// identifies the HR device description (manufacturer id)
AsnObjectIdentifier OT_DEVICE_DESCRIPTION[] =   {	{ OID_SIZEOF(OID_HRMIB_hrDeviceType), OID_HRMIB_hrDeviceType },
													{ OID_SIZEOF(OID_HRMIB_hrDeviceDescr), OID_HRMIB_hrDeviceDescr },
													{ 0, 0}
												};

// identifies the status of the device defined in status .cpp
// AsnObjectIdentifier OT_DEVICE_STATUS[]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\tcpmib.cpp ===
/*****************************************************************************
 *
 * $Workfile: TcpMib.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdmib.h"
#include "pingicmp.h"
#include "tcpmib.h"
#include "status.h"


///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

CTcpMib     *g_pTcpMib = 0;
int g_cntGlobalAlloc=0;     // used for debugging purposes
int g_csGlobalCount=0;

// to ensure that the CTCPMib is not being deleted improperly, perform usage count on the DLL
int g_cntUsage = 0;


///////////////////////////////////////////////////////////////////////////////
//  GetDLLInterfacePtr -- returns the pointer to the DLL interface

extern "C" CTcpMibABC*
GetTcpMibPtr( void )
{
    return (g_pTcpMib);

}   // GetDLLInterfacePtr()


///////////////////////////////////////////////////////////////////////////////
//  Ping -- pings the given device
//  Return Codes:
//      NO_ERROR            if ping is successfull
//      DEVICE_NOT_FOUND    if device is not found

extern "C" DWORD
Ping( LPCSTR    in  pHost )
{
    DWORD   dwRetCode = NO_ERROR;

    // do icmpPing
    CPingICMP *pPingICMP = new CPingICMP(pHost);

    if ( !pPingICMP )
        return (dwRetCode = GetLastError()) ? dwRetCode : ERROR_OUTOFMEMORY;

    if (  !pPingICMP->Ping() )
    {
        dwRetCode = ERROR_DEVICE_NOT_FOUND;
    }

    delete pPingICMP;

    return (dwRetCode);

}   // Ping()


///////////////////////////////////////////////////////////////////////////////
//  DllMain
//

BOOL APIENTRY
DllMain (   HANDLE in hInst,
            DWORD  in dwReason,
            LPVOID in lpReserved )
{

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInst );

            g_cntUsage++;       // DLL usage count
            if ( !g_pTcpMib)
            {
                g_pTcpMib = new CTcpMib();  // create the port manager object
                if (!g_pTcpMib)
                {
                    return FALSE;
                }
            }
            return TRUE;

        case DLL_PROCESS_DETACH:
            g_cntUsage--;       // DLL usage count
            if (g_cntUsage == 0)
            {
                if (g_pTcpMib)
                {
                    delete g_pTcpMib;   // FIX! do we need to worry about usage count here??
                    g_pTcpMib = NULL;
                }
            }
            return TRUE;

    }

    return FALSE;

}   // DllMain()


/*****************************************************************************
*
* CTcpMib implementation
*
*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization


///////////////////////////////////////////////////////////////////////////////
//  CTcpMib::CTcpMib()

CTcpMib::CTcpMib( )
{
    InitializeCriticalSection(&m_critSect);

}   // ::CTcpMib()


///////////////////////////////////////////////////////////////////////////////
//  CTcpMib::~CTcpMib()

CTcpMib::~CTcpMib( )
{
    DeleteCriticalSection(&m_critSect);

}   // ::~CTcpMib()


///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

void
CTcpMib::EnterCSection( )
{
    EnterCriticalSection(&m_critSect);      // enter critical section

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

void
CTcpMib::ExitCSection( )
{
    LeaveCriticalSection(&m_critSect);      // exit critical section

}   //  ::ExitCSection()

///////////////////////////////////////////////////////////////////////////////
//  SupportsPrinterMib --
//
BOOL
CTcpMib::
SupportsPrinterMib(
    IN  LPCSTR      pHost,
    IN  LPCSTR      pCommunity,
    IN  DWORD       dwDevIndex,
    OUT PBOOL       pbSupported
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLastError = ERROR_SUCCESS;

    EnterCSection();

    if ( (dwLastError = Ping(pHost)) == NO_ERROR ) {
        CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);

        if ( pStdMib ) {

            *pbSupported = pStdMib->TestPrinterMIB();
            bRet = TRUE;
            delete pStdMib;
        }
    }

    ExitCSection();

    if (!bRet)
        SetLastError (dwLastError);

    return bRet;
}   // ::SupportsPrinterMib()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceDescription --
//
//  Returns:
//     NO_ERROR -
//     ERROR_DEVICE_NOT_FOUND -
//     SUCCESS_DEVICE_UNKNOWN
DWORD
CTcpMib::
GetDeviceDescription(
    IN  LPCSTR      pHost,
    IN  LPCSTR      pCommunity,
    IN  DWORD       dwDevIndex,
    OUT LPTSTR      pszPortDesc,
    IN  DWORD       dwDescLen
    )
{
    DWORD    dwRet = NO_ERROR;

    EnterCSection();

    if ( Ping(pHost) == NO_ERROR ) {
        CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);

        if ( pStdMib ) {

            if ( !pStdMib->GetDeviceDescription(pszPortDesc, dwDescLen)){
                dwRet = SUCCESS_DEVICE_UNKNOWN;
            }
            delete pStdMib;

        }
    } else {
        dwRet = ERROR_DEVICE_NOT_FOUND;
    }

    ExitCSection();

    return dwRet;
}   // ::GetDeviceDescription()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceStatus --
//      Error Codes:
//          Returns the mapped printer error code to the spooler error code

DWORD
CTcpMib::GetDeviceStatus( LPCSTR in  pHost,
                          LPCSTR    pCommunity,
                          DWORD     dwDevIndex )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceType()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceStatus();
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus --
//      Error Codes:
//          Returns the mapped printer error code to the spooler error code

DWORD
CTcpMib::GetJobStatus( LPCSTR  in   pHost,
                       LPCSTR  in   pCommunity,
                       DWORD   in   dwDevIndex)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetJobStatus();
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetJobType()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceAddress -- gets the hardware address of the device
//      ERROR CODES:
//          NO_ERROR if successful
//          ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//          ERROR_INVALID_HANDLE        if can't build the variable bindings
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

DWORD
CTcpMib::GetDeviceHWAddress( LPCSTR  in  pHost,
                             LPCSTR  in  pCommunity,
                             DWORD   in  dwDevIndex,
                             DWORD   in  dwSize, // Size in characters of the HWAddress returned
                             LPTSTR  out psztHWAddress
                             )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceAddress()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceHWAddress(psztHWAddress, dwSize);
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetDeviceAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- gets the device description
//      ERROR CODES
//          NO_ERROR if successful
//          ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//          ERROR_INVALID_HANDLE        if can't build the variable bindings
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

DWORD
CTcpMib::GetDeviceName( LPCSTR in   pHost,
                        LPCSTR in   pCommunity,
                        DWORD  in   dwDevIndex,
                        DWORD  in   dwSize,  // Size in characters of the description returned
                        LPTSTR out  psztDescription)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceInfo()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceName(psztDescription, dwSize);
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);
}   // ::GetDeviceAddress()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGet -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGet.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGet( LPCSTR                in  pHost,
                  LPCSTR                in  pCommunity,
                  DWORD                 in  dwDevIndex,
                  AsnObjectIdentifier   in  *pMibObjId,
                  RFC1157VarBindList    out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex, pMibObjId, pVarBindList);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Get(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);
}   // ::SnmpGet()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGet -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGet.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGet( LPCSTR                in      pHost,
                  LPCSTR                in      pCommunity,
                  DWORD                 in      dwDevIndex,
                  RFC1157VarBindList    inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Get(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpGet()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGetNext -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGetNext.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGetNext( LPCSTR                in  pHost,
                      LPCSTR                in  pCommunity,
                      DWORD                 in  dwDevIndex,
                      AsnObjectIdentifier   in  *pMibObjId,
                      RFC1157VarBindList    out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex,
                                         pMibObjId, pVarBindList);
    if( pSnmpMgr )   {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->GetNext(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpGetNext()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGetNext -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGetNext.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGetNext( LPCSTR                in      pHost,
                      LPCSTR                in      pCommunity,
                      DWORD                 in      dwDevIndex,
                      RFC1157VarBindList    inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->GetNext(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);
}   // ::SnmpGetNext()


///////////////////////////////////////////////////////////////////////////////
//  SnmpWalk -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpWalk.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpWalk( LPCSTR               in  pHost,
                   LPCSTR               in  pCommunity,
                   DWORD                in  dwDevIndex,
                   AsnObjectIdentifier  in  *pMibObjId,
                   RFC1157VarBindList   out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex,
                                         pMibObjId, pVarBindList);
    if( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Walk(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpWalk()


///////////////////////////////////////////////////////////////////////////////
//  SnmpWalk -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpWalk.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpWalk( LPCSTR               in      pHost,
                   LPCSTR               in      pCommunity,
                   DWORD                in      dwDevIndex,
                   RFC1157VarBindList   inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Walk(pVarBindList))  != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpWalk()



///////////////////////////////////////////////////////////////////////////////
//  SNMPToPrinterStatus -- Maps the received device error to the printer
//      error codes.
//      Return Values:
//          Spooler device error codes

DWORD
CTcpMib::SNMPToPrinterStatus( const DWORD in dwStatus)
{
    DWORD   dwRetCode = NO_ERROR;

    switch (dwStatus)
    {
        case ASYNCH_STATUS_UNKNOWN:
            dwRetCode = PRINTER_STATUS_NOT_AVAILABLE;
            break;
        case ASYNCH_PRINTER_ERROR:
            dwRetCode = PRINTER_STATUS_ERROR;
            break;
        case ASYNCH_DOOR_OPEN:
            dwRetCode = PRINTER_STATUS_DOOR_OPEN;
            break;
        case ASYNCH_WARMUP:
            dwRetCode = PRINTER_STATUS_WARMING_UP;
            break;
        case ASYNCH_RESET:
        case ASYNCH_INITIALIZING:
            dwRetCode = PRINTER_STATUS_INITIALIZING;
            break;
        case ASYNCH_OUTPUT_BIN_FULL:
            dwRetCode = PRINTER_STATUS_OUTPUT_BIN_FULL;
            break;
        case ASYNCH_PAPER_JAM:
            dwRetCode = PRINTER_STATUS_PAPER_JAM;
            break;
        case ASYNCH_TONER_GONE:
            dwRetCode = PRINTER_STATUS_NO_TONER;
            break;
        case ASYNCH_MANUAL_FEED:
            dwRetCode = PRINTER_STATUS_MANUAL_FEED;
            break;
        case ASYNCH_PAPER_OUT:
            dwRetCode = PRINTER_STATUS_PAPER_OUT;
            break;
        case ASYNCH_OFFLINE:
            dwRetCode = PRINTER_STATUS_OFFLINE;
            break;
        case ASYNCH_INTERVENTION:
            dwRetCode = PRINTER_STATUS_USER_INTERVENTION;
            break;
        case ASYNCH_TONER_LOW:
            dwRetCode = PRINTER_STATUS_TONER_LOW;
            break;
        case ASYNCH_PRINTING:
            dwRetCode = PRINTER_STATUS_PRINTING;
            break;
        case ASYNCH_BUSY:
            dwRetCode = PRINTER_STATUS_BUSY;
            break;
        case ASYNCH_ONLINE:
            dwRetCode = NO_ERROR;
            break;
        default:
            dwRetCode = PRINTER_STATUS_NOT_AVAILABLE;
    }

    return dwRetCode;

}   // SNMPToPrinterStatus()

///////////////////////////////////////////////////////////////////////////////
//  SNMPToPortStatus -- Maps the received device error to the printer
//      error codes.
//      Return Values:
//          Spooler device error codes

BOOL
CTcpMib::SNMPToPortStatus( const DWORD in dwStatus, PPORT_INFO_3 pPortInfo )
{
    DWORD   dwRetCode = NO_ERROR;

    pPortInfo->dwStatus = 0;
    pPortInfo->pszStatus = NULL;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;

    switch (dwStatus)
    {
        case ASYNCH_DOOR_OPEN:
            pPortInfo->dwStatus = PORT_STATUS_DOOR_OPEN;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_WARMUP:
            pPortInfo->dwStatus = PORT_STATUS_WARMING_UP;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_INFO;
            break;
        case ASYNCH_OUTPUT_BIN_FULL:
            pPortInfo->dwStatus = PORT_STATUS_OUTPUT_BIN_FULL;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_PAPER_JAM:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_JAM;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_TONER_GONE:
            pPortInfo->dwStatus = PORT_STATUS_NO_TONER;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_MANUAL_FEED:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_PROBLEM;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_PAPER_OUT:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_OUT;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_PRINTER_ERROR:
        case ASYNCH_INTERVENTION:
        case ASYNCH_OFFLINE:
            pPortInfo->dwStatus = PORT_STATUS_OFFLINE;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_TONER_LOW:
            pPortInfo->dwStatus = PORT_STATUS_TONER_LOW;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_STATUS_UNKNOWN:
        case ASYNCH_POWERSAVE_MODE:
        case ASYNCH_RESET:
        case ASYNCH_INITIALIZING:
        case ASYNCH_PRINTING:
        case ASYNCH_BUSY:
        case ASYNCH_ONLINE:
        default:
            pPortInfo->dwStatus = 0;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_INFO;
            break;
    }

    return dwRetCode;

}   // ::SNMPStatusToPortStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\tcpmib.h ===
/*****************************************************************************
 *
 * $Workfile: TcpMib.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_TCPMIB_H
#define INC_TCPMIB_H

#include "mibABC.h"
#include "winspool.h"
#define ERROR_SNMPAPI_ERROR                             15000           

#ifndef DllExport
#define DllExport       __declspec(dllexport)
#endif

class   CTcpMibABC;

#ifdef __cplusplus
extern "C" {
#endif
    //      return the pointer to the interface
    CTcpMibABC*     GetTcpMibPtr( void );

    ///////////////////////////////////////////////////////////////////////////////
    //  Ping return codes:
    //              NO_ERROR                        if ping is successfull
    //              DEVICE_NOT_FOUND        if device is not found
    DllExport       DWORD           Ping( LPCSTR    pHost );        

#ifdef __cplusplus
}
#endif


///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations/macros
// externs
extern int                      g_cntGlobalAlloc;
extern int                      g_csGlobalCount;

// macros to manupulate the RFC1157 variable bindings
#define RFC1157_VARBINDLIST_LEN(varBindList)    ( varBindList.len )             // returns the length of the varBind list
#define PRFC1157_VARBINDLIST_LEN(pVarBindList)  ( pVarBindList->len )           // returns the length of the varBind list

#define IS_ASN_INTEGER(varBindList, i)  ( ( varBindList.list[i].value.asnType == ASN_INTEGER ) ? TRUE : FALSE )
#define IS_ASN_OBJECTIDENTIFIER(varBindList, i) ( ( varBindList.list[i].value.asnType == ASN_OBJECTIDENTIFIER ) ? TRUE : FALSE )
#define IS_ASN_OCTETSTRING(varBindList, i)      ( ( varBindList.list[i].value.asnType == ASN_OCTETSTRING ) ? TRUE : FALSE )

#define GET_ASN_NUMBER(varBindList, i)  ( varBindList.list[i].value.asnValue.number )
#define GET_ASN_STRING_LEN(varBindList, i)      ( (varBindList).list[i].value.asnValue.string.length )
#define GET_ASN_OBJECT(varBindList, i)  ( varBindList.list[i].value.asnValue.object )
#define GET_ASN_OCTETSTRING(pDest, count, varBindList, i) ( GetAsnOctetString(pDest, count, &varBindList, i) )
#define GET_ASN_OCTETSTRING_CHAR( varBindList, i, x)    ( varBindList.list[i].value.asnValue.string.stream[x] )
#define GET_ASN_OID_NAME(varBindList, i)        ( varBindList.list[i].name )

#define PGET_ASN_OID_NAME(pVarBindList, i)      ( pVarBindList->list[i].name )
#define PGET_ASN_TYPE(pVarBindList, i)  ( pVarBindList->list[i].value.asnType )

// export the interface for CRawTcpInterface class
class DllExport CTcpMib : public CTcpMibABC             
#if defined _DEBUG || defined DEBUG
//      , public CMemoryDebug
#endif
{
public:
    CTcpMib();
    ~CTcpMib();

    BOOL   SupportsPrinterMib(LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              PBOOL         pbSupported);

    DWORD   GetDeviceDescription(LPCSTR        pHost,
                                 LPCSTR        pCommunity,
                                 DWORD         dwDevIndex,
                                 LPTSTR        pszPortDescription,
                                 DWORD         dwDescLen);
    DWORD   GetDeviceStatus ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex);
    DWORD   GetJobStatus    ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex);
    DWORD   GetDeviceHWAddress( LPCSTR      pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              DWORD         dwSize, // Size in characters of the dest HWAddress buffer
                              LPTSTR        psztHWAddress);
    DWORD   GetDeviceName   ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              DWORD         dwSize, // Size in characters of the dest Description buffer
                              LPTSTR        psztDescription);
    DWORD   SnmpGet( LPCSTR                      pHost,
                     LPCSTR                          pCommunity,
                     DWORD                           dwDevIndex,
                     AsnObjectIdentifier *pMibObjId,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGet( LPCSTR                      pHost,
                     LPCSTR                          pCommunity,
                     DWORD                           dwDevIndex,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpWalk( LPCSTR                          pHost,
                      LPCSTR                          pCommunity,
                      DWORD                           dwDevIndex,
                      AsnObjectIdentifier *pMibObjId,
                      RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpWalk( LPCSTR                          pHost,
                      LPCSTR                          pCommunity,
                      DWORD                           dwDevIndex,
                      RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGetNext( LPCSTR                          pHost,
                         LPCSTR                          pCommunity,
                         DWORD                           dwDevIndex,
                     AsnObjectIdentifier *pMibObjId,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGetNext( LPCSTR                          pHost,
                         LPCSTR                          pCommunity,
                         DWORD                   dwDevIndex,
                     RFC1157VarBindList  *pVarBindList);

    BOOL SNMPToPortStatus( const DWORD in dwStatus, 
                                 PPORT_INFO_3 pPortInfo );

    DWORD SNMPToPrinterStatus( const DWORD in dwStatus);

private:        // methods
    void    EnterCSection();
    void    ExitCSection();

private:        // attributes
    CRITICAL_SECTION        m_critSect;

};      // class CTcpMib



#endif  // INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cluster.h ===
/*****************************************************************************
 *
 * $Workfile: cluster.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_CLUSTER_H
#define INC_CLUSTER_H

#include "regabc.h"
#include "portmgr.h"

class CMemoryDebug;

class CCluster : public CRegABC
#if defined _DEBUG || defined DEBUG
	, public CMemoryDebug
#endif
{
public:
	CCluster( HANDLE		hcKey,
			  HANDLE		hSpooler,
			  PMONITORREG	pMonitorReg);

	~CCluster();

	DWORD EnumeratePorts( CPortMgr *pPortMgr );

	DWORD SetPortMgrSettings(const DWORD  dStatusUpdateInterval,
							 const BOOL	  bStatusUpdateEnabled );

	DWORD GetPortMgrSettings(DWORD  *dStatusUpdateInterval,
							 BOOL   *bStatusUpdateEnabled );

	DWORD SetWorkingKey( LPCTSTR	lpKey);

	DWORD SetValue( LPCTSTR lpValueName,
					DWORD dwType, 
					CONST BYTE *lpData, 
					DWORD cbData ); 

	DWORD QueryValue(LPTSTR lpValueName, 
					 LPBYTE lpData, 
					 LPDWORD lpcbData ); 

	DWORD FreeWorkingKey();

	BOOL DeletePortEntry( LPTSTR in psztPortName);


private:
	// attributes

	PMONITORREG m_pMonitorReg;

	TCHAR	m_sztMonitorPorts[MAX_PATH];

	HANDLE		m_hcKey;
	HANDLE		m_hSpooler;
	HANDLE		m_hcWorkingKey;

    CRITICAL_SECTION	m_critSect;
};

#endif // INC_CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cssocket.h ===
/*****************************************************************************
 *
 * $Workfile: CSSocket.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_CSSOCKET_H
#define INC_CSSOCKET_H

#define     SEND_TIMEOUT       15000   // 15 seconds


class CMemoryDebug;

class CStreamSocket
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
    CStreamSocket();
    ~CStreamSocket();

    INT         GetLastError(void)	 { return m_iLastError; };

    BOOL        Open();
    VOID        Close();
    DWORD       GetAckBeforeClose(DWORD dwSeconds);
    DWORD       PendingDataStatus(DWORD dwTimeout, LPDWORD pcbPending);
    BOOL        Connect(struct sockaddr_in * pRemoteAddr);
    BOOL        Bind();
    DWORD       Send(char far      *lpBuffer,
                     INT			iLength,
                     LPDWORD		pcbWritten);

    DWORD       ReceiveDataAvailable(IN      INT         iTimeout = 0);

    DWORD       Receive(char far   *lpBuffer,
                        INT			iBufSize,
                        INT			iFlags,
						INT			iTimeout,
                        LPDWORD		pcbRead);


	DWORD       Receive( );

	VOID        GetLocalAddress();
	VOID        GetRemoteAddress();
	
    BOOL        ResolveAddress(LPSTR    netperiph);
    BOOL        SetOptions();

private:
    DWORD       InternalSend(VOID);
    enum SOCKETSTATE {IDLE, CONNECTING, CONNECTED, LISTENING, WAITING_TO_CLOSE};

    //
    // cbBuf        : size of the buffer pointed by pBuf
    // cbData       : size of data in the buffer (could be less than cbBuf)
    // cbPending    : size of data in buffer sent with no confirmation yet
    //                (i.e. WSASend succesful but i/o is still pending)
    //
    DWORD           cbBuf, cbData, cbPending;
    WSAOVERLAPPED   WsaOverlapped;
    LPBYTE          pBuf;

    INT                     m_iLastError;		// Last error from Winsock call
    SOCKET                  m_socket;
    SOCKETSTATE	            m_iState;
    struct sockaddr_in      m_Paddr;
    struct sockaddr_in      m_localAddr;
#ifdef DEBUG
    DWORD                   m_dwTimeStart, m_dwTimeEnd;
    double                  m_TotalBytes;
#endif
};


#endif	// INC_CSSOCKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cssocket.cpp ===
/*****************************************************************************
 *
 * $Workfile: CSSocket.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "cssocket.h"



///////////////////////////////////////////////////////////////////////////////
//  global variables



///////////////////////////////////////////////////////////////////////////////
//  CStreamSocket::CStreamSocket()

CStreamSocket::
CStreamSocket(
    VOID
    ) : m_socket(INVALID_SOCKET), m_iState(IDLE), m_iLastError(NO_ERROR),
        cbBuf(0), cbData(0), cbPending(0), pBuf(NULL)
{
    ZeroMemory(&m_Paddr, sizeof(m_Paddr));
    ZeroMemory(&m_localAddr, sizeof(m_localAddr));
    ZeroMemory(&WsaOverlapped, sizeof(WsaOverlapped));
}   // CStreamSocket()


///////////////////////////////////////////////////////////////////////////////
//  CStreamSocket::~CStreamSocket()

CStreamSocket::
~CStreamSocket(
    VOID
    )
{

#ifdef DEBUG
    DWORD dwDiff;
    CHAR szBuf[512];

    m_dwTimeEnd = GetTickCount ();

    if (m_dwTimeEnd < m_dwTimeStart) {
        dwDiff = (m_dwTimeEnd - m_dwTimeStart + 0xffffffff) ;
    }
    else
        dwDiff = m_dwTimeEnd - m_dwTimeStart;

    // DBGMSG does not allow floating value, so we need to use sprintf instead

    sprintf (szBuf, "Job Data (before Close): %3.1f bytes,  %3.1f sec, %3.1f (KB /sec).\n",
             m_TotalBytes, dwDiff / 1000., (m_TotalBytes / dwDiff ));

    DBGMSG (DBG_PORT, ("%s", szBuf));

#endif

    Close();
}   // ~CStreamSocket()


///////////////////////////////////////////////////////////////////////////////
// Open
//  Error Codes:
//      TRUE if socket created, FALSE otherwise.

BOOL
CStreamSocket::
Open(
    VOID
    )
{
    int     iBufSize = 0;

    if ( m_socket != INVALID_SOCKET ) {

        _ASSERTE(m_socket == INVALID_SOCKET);
        return FALSE;
    }

    if ( (m_socket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL,
                               0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET ) {

        m_iLastError = WSAGetLastError();
        _RPT1(_CRT_WARN,
              "CSSOCKET -- Open(%d) error: can't create socket\n",
              m_iLastError);
        return FALSE;
    }

    //
    // Tell WinSock not to buffer data (i.e. buffer size of 0)
    //
    if ( setsockopt(m_socket, SOL_SOCKET, SO_SNDBUF,
                    (LPCSTR)&iBufSize, sizeof(iBufSize)) == SOCKET_ERROR ) {

        m_iLastError = WSAGetLastError();
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return FALSE;
    }

    return TRUE;
}   // Open()


DWORD
CStreamSocket::
GetAckBeforeClose(
    DWORD   dwSeconds
    )
/*++

Description:
    Called to get the FIN from the remote host to make sure job has
    gone through ok.

Parameters:
    dwSeconds: how long the routine should wait for FIN from the remote host

Return values:
    NO_ERROR        : Received a FIN from the remote host
    WSAWOULBLOCK    : Timed out. Connection is ok, but did not get the FIN
                      in the specified time. Caller could reissue the
                      GetAckBeforeClose call again.
    Anything else   : An unexpected winsock error

--*/
{
    DWORD   dwRet = ERROR_SUCCESS, cbRead;
    time_t  dwStartTime, dwWaitTime;
    char    buf[100];

#ifdef DEBUG
    DWORD dwDiff;
    CHAR szBuf[512];

    m_dwTimeEnd = GetTickCount ();

    if (m_dwTimeEnd < m_dwTimeStart) {
        dwDiff = (m_dwTimeEnd - m_dwTimeStart + 0xffffffff) ;
    }
    else
        dwDiff = m_dwTimeEnd - m_dwTimeStart;

    // DBGMSG does not allow floating value, so we need to use sprintf instead

    sprintf (szBuf, "Job Data (before Ack): %3.1f bytes,  %3.1f sec, %3.1f (KB /sec).\n",
             m_TotalBytes, dwDiff / 1000., (m_TotalBytes / dwDiff ));

    DBGMSG (DBG_PORT, ("%s", szBuf));

#endif

    dwStartTime = time(NULL);

    //
    // We need to issue shutdown SD_SEND only once, the first time
    //
    if ( m_iState != WAITING_TO_CLOSE ) {

        if ( shutdown(m_socket, 1) != ERROR_SUCCESS ) {

            if ( (dwRet = m_iLastError = WSAGetLastError()) == NO_ERROR )
                dwRet = m_iLastError = STG_E_UNKNOWN;
            goto Done;
        }
        m_iState = WAITING_TO_CLOSE;
    }

    do {

        dwWaitTime = time(NULL) - dwStartTime;
        if ( static_cast<DWORD> (dwWaitTime) > dwSeconds )
            dwWaitTime = 0;
        else
            dwWaitTime = dwSeconds - dwWaitTime;

        dwRet = Receive(buf, sizeof(buf), 0,  static_cast<DWORD>(dwWaitTime), &cbRead);

    } while ( dwRet == NO_ERROR && cbRead > 0 );

Done:
    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  Close

VOID
CStreamSocket::
Close(
    VOID
    )
{
    if ( m_socket != INVALID_SOCKET ) {

        if ( closesocket(m_socket) == 0 ) {

            //
            // If we have pending data (i.e. in case of aborting job)
            // then event will be set
            //
            if ( cbPending )
                WaitForSingleObject(WsaOverlapped.hEvent, INFINITE);
        } else {

            //
            // Why would close fail ?
            //
            _ASSERTE(WSAGetLastError());
        }

        m_socket = INVALID_SOCKET;
    }

    if ( pBuf ) {

        LocalFree(pBuf);
        pBuf = NULL;
    }

    if ( WsaOverlapped.hEvent ) {

        WSACloseEvent(WsaOverlapped.hEvent);
        WsaOverlapped.hEvent = NULL;
    }
}   // Close()


///////////////////////////////////////////////////////////////////////////////
//  SetOptions -- sets the socket options (is not currently being used )
BOOL
CStreamSocket::
SetOptions(
    VOID
    )
{
#if 0
    LINGER ling;

    if( m_socket != INVALID_SOCKET )
    {
        ling.l_onoff = 1;
        ling.l_linger = 90;

        setsockopt( m_socket,
                    SOL_SOCKET, SO_LINGER, (LPSTR)&ling, sizeof( ling ) );
    }
#endif
    return TRUE;
}   // SetOptions()


///////////////////////////////////////////////////////////////////////////////
//  Connect
//      Error codes:
//          TRUE if connect succeeds, FALSE if fails
//      FIX: how to call the destructor

BOOL
CStreamSocket::
Connect(
    struct sockaddr_in * pRemoteAddr
    )
{

    //
    // open a socket (Makes sense to call when open fails? -- Muhunts )
    //


    if ( m_socket == INVALID_SOCKET && !Open() )
    {
            return FALSE;
    }

    if( m_socket == INVALID_SOCKET && !Bind() )
    {
        return FALSE;
    }

    if ( SOCKET_ERROR == connect(m_socket, (LPSOCKADDR)pRemoteAddr,
                                 sizeof(*pRemoteAddr)) ) {

        m_iLastError = WSAGetLastError();
        return FALSE;
    }
    m_iState = CONNECTED;


    return TRUE;
}   // Connect()


///////////////////////////////////////////////////////////////////////////////
//  Bind

BOOL
CStreamSocket::
Bind(
    VOID
    )
{
    memset (&m_localAddr, 0x00, sizeof(m_localAddr));

    m_localAddr.sin_family = AF_INET;
    m_localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    m_localAddr.sin_port = 0;

    if ( SOCKET_ERROR == bind(m_socket, (struct sockaddr *)&m_localAddr,
                              sizeof(m_localAddr)) ) {

        m_iLastError = WSAGetLastError();
        return FALSE;
    }

    return TRUE;

}   // Bind()


////////////////////////////////////////////////////////////////////////////////
//
// InternalSend
//      Send whatever is left in buffer
//
////////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
InternalSend(
    VOID
    )
{
    INT         iSendRet;
    DWORD       dwRet = NO_ERROR, dwSent;
    WSABUF      WsaBuf;

    //
    // Send as much data without blocking
    //
    while ( cbPending ) {

        WsaBuf.len   = cbPending;
        WsaBuf.buf   = (char far *)(pBuf + cbData - cbPending);

        iSendRet = WSASend(m_socket, &WsaBuf, 1, &dwSent, MSG_PARTIAL,
                           &WsaOverlapped, NULL);

        //
        // If return value is 0 data is already sent
        //
        if ( iSendRet == 0 ) {

            WSAResetEvent(WsaOverlapped.hEvent);
            cbPending -= dwSent;
        } else {

            if ( (dwRet = WSAGetLastError()) != WSA_IO_PENDING )
                m_iLastError = dwRet;

            break;
        }
    }

    if ( dwRet == WSA_IO_PENDING )
        dwRet = NO_ERROR;

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  Send -- sends the specified buffer to the host that was set previously
//      ERROR CODES:
//          NO_ERROR        ( No Error )    if send was successfull
//          WSAEWOULDBLOCK  if write socket is blocked
//          WSAECONNRESET   if connection was reset
//
//  MuhuntS: 5/26/99
//      I am changing tcpmon to use overlapped i/o with no winsock buffering
//      So caller should call PendingDataStatus to see if Send completed yet
//      Send call is just to schedule an I/O operation
///////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
Send(
    IN      char far   *lpBuffer,
    IN      INT         iLength,
    IN OUT  LPDWORD     pcbWritten)
{
    DWORD   dwRet = NO_ERROR, dwSent;
    INT     iSendRet;


    *pcbWritten = 0;

    _ASSERTE(cbPending == 0);

    cbData = cbPending = 0;

#ifdef DEBUG

    if (!pBuf) {
        // First send comes in

        DBGMSG (DBG_PORT, ("Get Connected \n"));

        m_TotalBytes = 0;
        m_dwTimeStart = GetTickCount ();
    }

#endif


    //
    // Once we allocate a buffer we do not free it till the end of job, or if
    // spooler gives us a bigger buffer
    //
    if ( pBuf && (INT)cbBuf < iLength ) {

        LocalFree(pBuf);
        pBuf = NULL;
        cbBuf = 0;
    }

    if ( !pBuf ) {

        if ( !(pBuf = (LPBYTE)LocalAlloc(LPTR, iLength)) ) {

            dwRet = ERROR_OUTOFMEMORY;
            goto Done;
        }

        cbBuf = iLength;
    }

    //
    // If we did not create event yet do so
    //
    if ( !WsaOverlapped.hEvent && !(WsaOverlapped.hEvent =WSACreateEvent()) ) {

        dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    cbData = cbPending = iLength;
    CopyMemory(pBuf, lpBuffer, iLength);

    if ( (dwRet = InternalSend()) == NO_ERROR )
        *pcbWritten = cbData;
    else {

        *pcbWritten = cbData - cbPending;
        cbData = cbPending = 0;
    }

#ifdef DEBUG
    m_TotalBytes += *pcbWritten;
#endif


Done:
    return dwRet;
}   // Send()


///////////////////////////////////////////////////////////////////////////////
//
// This routine will tell how much pending data is there in blocked I/O
// operations, waiting upto dwTimeout milliseconds
//
// Return value:
//      NO_ERROR:
//          If *pcbPending is 0 then either no pending I/O or all the issued
//          Sends are completed
//          If *pcbPending is not 0 then after the specified time we still have
//          so much data pending.
//      Others
//          There was an error with the last send.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
PendingDataStatus(
    DWORD       dwTimeout,
    LPDWORD     pcbPending
    )
{
    DWORD   dwRet = NO_ERROR, dwSent, dwFlags = 0;

    if ( cbPending ) {

        if ( WAIT_OBJECT_0 == WaitForSingleObject(WsaOverlapped.hEvent,
                                                  dwTimeout) ) {

            WSAResetEvent(WsaOverlapped.hEvent);
            if ( WSAGetOverlappedResult(m_socket, &WsaOverlapped, &dwSent,
                                        FALSE, &dwFlags) ) {

                if ( cbPending >= dwSent ) {

                    cbPending -= dwSent;
                    if ( cbPending )
                        dwRet = InternalSend();
                } else {

                    //
                    // This should not happen. How could more data be sent
                    // then scheduled?
                    //
                    _ASSERTE(cbPending >= dwSent);
                    cbPending = 0;
                    dwRet = STG_E_UNKNOWN;
                }

            } else {

                if ( (dwRet = m_iLastError = WSAGetLastError()) == NO_ERROR )
                    dwRet = m_iLastError = STG_E_UNKNOWN;
            }

        } else
            *pcbPending = cbPending;
    }

    *pcbPending = cbPending;

    //
    // If we get error then clear all data pending info
    //
    if ( dwRet != NO_ERROR )
        cbData = cbPending = 0;

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  ReceiveDataAvailable -- checks if there is any data to receive
//      ERROR CODES:
//          NO_ERROR  ( No Error ) There are a least one byte to receive
//          WSAEWOULDBLOCK if no data is available
//          WSAECONNRESET   if connection was reset

DWORD
CStreamSocket::
ReceiveDataAvailable(
    IN      INT         iTimeout)
{
    DWORD   dwRetCode = NO_ERROR;
    fd_set  fdReadSet;
    struct  timeval timeOut;
    INT     selret;

    //
    // immediately return from select()
    //
    timeOut.tv_sec  = iTimeout;
    timeOut.tv_usec = 0;
    m_iLastError    = NO_ERROR;

    //
    // Check to see if any thing is available
    //

    FD_ZERO( (fd_set FAR *)&fdReadSet );
    FD_SET( m_socket, (fd_set FAR *)&fdReadSet );

    selret = select(0, &fdReadSet, NULL, NULL, &timeOut);

    if ( selret == SOCKET_ERROR )   {

        dwRetCode = m_iLastError = WSAGetLastError();
    }  else if ( !FD_ISSET( m_socket, &fdReadSet ) ) {

        dwRetCode = WSAEWOULDBLOCK;
    }

    return dwRetCode;

}   // ReceiveDataAvailable()


///////////////////////////////////////////////////////////////////////////////
//  Receive -- receives the specified buffer from the host that was set previously
//      ERROR CODES:
//          NO_ERROR  ( No Error ) if send was successfull
//          WSAEWOULDBLOCK if write socket is blocked
//          WSAECONNRESET   if connection was reset

DWORD
CStreamSocket::
Receive(
    IN      char far   *lpBuffer,
    IN      INT         iSize,
    IN      INT         iFlags,
    IN      INT         iTimeout,
    IN OUT  LPDWORD     pcbRead)
{
    INT     iRecvLength = 0;
    DWORD   dwRetCode = ReceiveDataAvailable (iTimeout);
    fd_set  fdReadSet;

    *pcbRead = 0;

    if (dwRetCode == NO_ERROR)
    {
        iRecvLength = recv(m_socket, lpBuffer, iSize, iFlags);

        if ( iRecvLength == SOCKET_ERROR )
            dwRetCode = m_iLastError = WSAGetLastError();
        else
            *pcbRead = iRecvLength;
    }

    return dwRetCode;

}   // Recv()

///////////////////////////////////////////////////////////////////////////////
//  Receive -- detects whether the connection closed or not. Used by select()
//      if the server closed the connection, recv() indicates either a gracefull
//      shutdown, or WSAECONNRESET
//      Error Codes:
//          NO_ERROR        if connection has shutdown gracefully
//          WSAECONNRESET   if connection is reset


DWORD
CStreamSocket::
Receive(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CHAR    tempBuf[1024];

    if ( recv(m_socket, tempBuf, 1024, 0) != 0 ) {

        dwRetCode = m_iLastError = WSAGetLastError();
    }

    return dwRetCode;
}   // Receive()


///////////////////////////////////////////////////////////////////////////////
//  GetLocalAddress

VOID
CStreamSocket::
GetLocalAddress(
    VOID
    )
{

}   // GetLocalAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetRemoteAddress

VOID
CStreamSocket::
GetRemoteAddress(
    VOID
    )
{

}   // GetRemoteAddress()


BOOL
CStreamSocket::
ResolveAddress(
    IN  LPSTR   netperiph
    )
/* host name or IP address of network periph */
{
    struct hostent  *h_info;        /* host information */

    //
    // Check for dotted decimal or hostname.
    //
    m_Paddr.sin_addr.s_addr = inet_addr(netperiph);
    if (( m_Paddr.sin_addr.s_addr ) ==  INADDR_NONE ) {

        //
        // The IP address is not in dotted decimal notation. Try to get the
        // network peripheral IP address by host name.
        //
        if ( (h_info = gethostbyname(netperiph)) != NULL ) {

            //
            // Copy the IP address to the address structure.
            //
            (void) memcpy(&(m_Paddr.sin_addr.s_addr), h_info->h_addr,
                          h_info->h_length);
        } else {

            return FALSE;
        }
    }

    m_Paddr.sin_family = AF_INET;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cluster.cpp ===
/*****************************************************************************
 *
 * $Workfile: cluster.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#include "precomp.h"
#include "portmgr.h"
#include "cluster.h"

//////////////////////////////////////////////////////////////////////////////
// CCluster::CCluster()
//

CCluster::CCluster( HANDLE      IN hcKey,
                    HANDLE      IN hSpooler,
                    PMONITORREG IN pMonitorReg ) : 
                                            m_hcKey(hcKey),
                                            m_hSpooler(hSpooler),
                                            m_pMonitorReg(pMonitorReg),
                                            m_hcWorkingKey(NULL)
{
    lstrcpyn(m_sztMonitorPorts, PORTMONITOR_PORTS, SIZEOF_IN_CHAR( m_sztMonitorPorts));

    InitializeCriticalSection( &m_critSect );
}   // ::CCluster()


//////////////////////////////////////////////////////////////////////////////
// CCluster::~CCluster()
//      FIX: should the configuration be saved here?

CCluster::~CCluster()
{
    DeleteCriticalSection( &m_critSect );

    if( m_hcWorkingKey !=NULL ) {
        m_pMonitorReg->fpCloseKey(m_hcWorkingKey, m_hSpooler);
        m_hcWorkingKey = NULL;
    }
    m_pMonitorReg = NULL;
    m_hSpooler = NULL;
    m_hcKey = NULL;
}   // ::~CCluster


//////////////////////////////////////////////////////////////////////////////
// EnumeratePorts -- Enumerates the ports in the registry & adds it to the portList
//      Registry entries per port: IPAddress, MACAddress, HostName, PortNumber, ExPortNumber
//

DWORD 
CCluster::EnumeratePorts(CPortMgr *pPortMgr )
{
    DWORD   dwRetCode;
    HANDLE  hcKey = NULL;
    HANDLE  hcKeyPort = NULL;
    DWORD   dwSubkey = 0;
    TCHAR   szTemp[MAX_PATH];
    DWORD   dwSize = 0;
    DWORD   dwDisp = 0;
    DWORD   dwProtocol;
    DWORD   dwVersion;

    if ( m_pMonitorReg == NULL)
        return ERROR_INVALID_HANDLE;

    dwRetCode = m_pMonitorReg->fpCreateKey(m_hcKey, 
                                           m_sztMonitorPorts, 
                                           REG_OPTION_NON_VOLATILE, 
                                           KEY_ALL_ACCESS, 
                                           NULL, 
                                           &hcKey, 
                                           &dwDisp,
                                           m_hSpooler);

    if ( dwRetCode != ERROR_SUCCESS )
        return dwRetCode;

    do {

        dwSize = SIZEOF_IN_CHAR(szTemp);
        dwRetCode = m_pMonitorReg->fpEnumKey(hcKey, 
                                             dwSubkey, 
                                             szTemp, 
                                             &dwSize, 
                                             NULL,
                                             m_hSpooler);

        if ( dwRetCode == ERROR_NO_MORE_ITEMS ) {

            dwRetCode = ERROR_SUCCESS;
            break; // This is our exit out of the loop with no more ports
        }

        hcKeyPort = NULL;

        dwRetCode = m_pMonitorReg->fpOpenKey(hcKey, 
                                             szTemp, 
                                             KEY_ALL_ACCESS, 
                                             &hcKeyPort, 
                                             m_hSpooler);

        //
        // If we have one bad port entry in registry we should not stop there
        // and continue to enumerate other ports
        //
        if ( dwRetCode != ERROR_SUCCESS ) 
            goto NextPort;

        dwSize = sizeof(dwProtocol);        // get the protocol type
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKeyPort,
                                                PORTMONITOR_PORT_PROTOCOL, 
                                                NULL, 
                                                (LPBYTE)&dwProtocol,
                                                &dwSize,
                                                m_hSpooler);

        if ( dwRetCode != ERROR_SUCCESS )
            goto NextPort;

        dwSize = sizeof(dwVersion);     // get the version
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKeyPort, 
                                                PORTMONITOR_PORT_VERSION, 
                                                NULL, 
                                                (LPBYTE)&dwVersion, 
                                                &dwSize, 
                                                m_hSpooler);

        if ( dwRetCode != ERROR_SUCCESS )
            goto NextPort;

        //
        // create a new port
        //
        dwRetCode =  pPortMgr->CreatePortObj((LPTSTR)szTemp,    // port name
                                             dwProtocol,            // protocol type
                                             dwVersion);            // version number

        if ( dwRetCode != NO_ERROR ) {

            //
            // FIX EVENT message indicating bad port in registry.
            //
            EVENT_LOG1(EVENTLOG_WARNING_TYPE, dwRetCode, szTemp);
        }

NextPort:
        if ( hcKeyPort ) {

            m_pMonitorReg->fpCloseKey(hcKeyPort, m_hSpooler);
            hcKeyPort = NULL;
        }

        ++dwSubkey;
        dwRetCode = NO_ERROR;
    } while ( dwRetCode == NO_ERROR ); // Exit via break above
        
    m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);

    return dwRetCode;
}





//////////////////////////////////////////////////////////////////////////////
// DeletePortEntry -- deletes the given port entry from the registry

BOOL
CCluster::DeletePortEntry(LPTSTR in psztPortName)
{
    BOOL    bReturn = TRUE;
    HANDLE  hcKey = NULL;
    DWORD   dwDisp = 0;

    if( m_pMonitorReg == NULL)
    {
        return FALSE;
    }

    LONG lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if ( lRetCode == ERROR_SUCCESS) 
    {
        lRetCode = m_pMonitorReg->fpDeleteKey(hcKey, 
                                              psztPortName, 
                                              m_hSpooler);
        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
        if (lRetCode != ERROR_SUCCESS) 
        {
            bReturn = FALSE;
        }
    }
    else 
    {
        bReturn = FALSE;
    }

    return bReturn;

}   // ::DeletePortEntry()


//////////////////////////////////////////////////////////////////////////////
// GetPortMgrSettings -- Gets the port manager registry settings.
//      

DWORD 
CCluster::GetPortMgrSettings(DWORD inout *pdwStatusUpdateInterval,
                             BOOL  inout *pbStatusUpdateEnabled )
{
    LONG    lRetCode = ERROR_SUCCESS;
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwDisp = 0;
    DWORD   dwSize = 0;
    HANDLE  hcKey;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    // get current configuration settings from the registry
    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if (lRetCode == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKey, PORTMONITOR_STATUS_INT, NULL,
            (LPBYTE)pdwStatusUpdateInterval, &dwSize, m_hSpooler);
        if ( (dwRetCode != ERROR_SUCCESS) || (*pdwStatusUpdateInterval <= 0) )
        {
            *pdwStatusUpdateInterval = DEFAULT_STATUSUPDATE_INTERVAL;
            m_pMonitorReg->fpSetValue(hcKey, PORTMONITOR_STATUS_INT, REG_DWORD,
                (const LPBYTE)pdwStatusUpdateInterval, sizeof(DWORD), m_hSpooler);
        }
        dwSize = sizeof(BOOL);
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKey, PORTMONITOR_STATUS_ENABLED, NULL,
            (LPBYTE)pbStatusUpdateEnabled, &dwSize, m_hSpooler);
        if ( (dwRetCode != ERROR_SUCCESS) || ((*pbStatusUpdateEnabled != FALSE) && (*pbStatusUpdateEnabled != TRUE )))
        {
            *pbStatusUpdateEnabled = DEFAULT_STATUSUPDATE_ENABLED;
            m_pMonitorReg->fpSetValue(hcKey, PORTMONITOR_STATUS_ENABLED, REG_DWORD,
                (const LPBYTE)pbStatusUpdateEnabled, sizeof(BOOL), m_hSpooler);
        }

        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
        dwRetCode = NO_ERROR;
    }

    return (dwRetCode);

}   // GetPortMgrSettings()


//////////////////////////////////////////////////////////////////////////////
//  SetPortMgrSettings -- Sets the port manager registry settings.
//  Error Codes:
//      NO_ERROR if successful
//      ERROR_ACCESS_DENIED if can't access the registry

DWORD
CCluster::SetPortMgrSettings( const DWORD in dwStatusUpdateInterval,
                              const BOOL  in bStatusUpdateEnabled )
{
    HKEY    hcKey = NULL;
    LONG    lRetCode = ERROR_SUCCESS;
    DWORD   dwDisp = 0;
    DWORD   dwRetCode = NO_ERROR;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    // update the internal values
    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if (lRetCode == ERROR_SUCCESS)
    {

        // Update registry values for port manager
        // Note: RegSetValueEx expects size in BYTES!
        lRetCode = m_pMonitorReg->fpSetValue(hcKey,
                                             PORTMONITOR_STATUS_INT, 
                                             REG_DWORD, 
                                             (const LPBYTE)&dwStatusUpdateInterval, 
                                             sizeof(dwStatusUpdateInterval), 
                                             m_hSpooler);
        lRetCode = m_pMonitorReg->fpSetValue(hcKey, 
                                             PORTMONITOR_STATUS_ENABLED, 
                                             REG_DWORD, 
                                             (const LPBYTE)&bStatusUpdateEnabled, 
                                             sizeof(bStatusUpdateEnabled), m_hSpooler);


        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
    }
    else
    {
        dwRetCode = ERROR_ACCESS_DENIED;
    }

    return (dwRetCode);

}   // ::SetPortMgrSettings()


//////////////////////////////////////////////////////////////////////////////
//  SetWorkingKey -- Opens the given entry @ the registry
//  Error codes:
//      NO_ERROR if no error
//      ERROR_ACCESS_DENIED if can't access the registry

DWORD 
CCluster::SetWorkingKey(LPCTSTR lpKey)
{
    DWORD   dwRetCode = NO_ERROR;
    LONG    lRetCode = ERROR_SUCCESS;
    HANDLE  hcKey = NULL;
    DWORD   dwDisp = 0;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    EnterCriticalSection( &m_critSect );

    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey,  
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);
    if (lRetCode == ERROR_SUCCESS) {
        lRetCode = m_pMonitorReg->fpCreateKey(hcKey,            // Create new key for port
                                    lpKey,
                                    REG_OPTION_NON_VOLATILE, 
                                    KEY_ALL_ACCESS, 
                                    NULL, 
                                    &m_hcWorkingKey, 
                                    &dwDisp,
                                    m_hSpooler);
        
        if (lRetCode != ERROR_SUCCESS) {
            m_hcWorkingKey = NULL;
            dwRetCode = ERROR_ACCESS_DENIED;
        }
    } else {
        dwRetCode = ERROR_ACCESS_DENIED;
    }

    if( hcKey ) {
        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
    }

    if( m_hcWorkingKey == NULL ) {
        LeaveCriticalSection(&m_critSect);
    }


    return(dwRetCode);

}   // ::RegOpenPortEntry()

//////////////////////////////////////////////////////////////////////////////
//  QueryValue -- Queries the current working key for the requested value
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry
DWORD
CCluster::QueryValue(LPTSTR lpValueName, 
                     LPBYTE lpData, 
                     LPDWORD lpcbData )
{
    if( m_pMonitorReg == NULL)
    {
        return ERROR_INVALID_HANDLE;
    }

    if( m_hcWorkingKey != NULL ) {
        return( m_pMonitorReg->fpQueryValue(m_hcWorkingKey, 
                                            lpValueName, 
                                            NULL,
                                            (LPBYTE)lpData, 
                                            lpcbData,
                                            m_hSpooler));
    }
    return ERROR_BADKEY;
}

//////////////////////////////////////////////////////////////////////////////
//  SetValue -- Sets the value for the current 
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry

DWORD
CCluster::SetValue( LPCTSTR lpValueName,
                     DWORD dwType, 
                     CONST BYTE *lpData, 
                     DWORD cbData ) 
{
    if( m_pMonitorReg == NULL)
    {
        return ERROR_INVALID_HANDLE;
    }

    if( m_hcWorkingKey != NULL ) {
        return( m_pMonitorReg->fpSetValue(m_hcWorkingKey,
                                          lpValueName,
                                          dwType, 
                                          lpData, 
                                          cbData,
                                          m_hSpooler));
    } 
    return ERROR_BADKEY;
}

//////////////////////////////////////////////////////////////////////////////
//  FreeWorkingKey -- Frees the current working key
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry

DWORD 
CCluster::FreeWorkingKey()
{
    DWORD dwRetCode = NO_ERROR;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }
    
    if( m_hcWorkingKey !=NULL ) {
        dwRetCode = m_pMonitorReg->fpCloseKey(m_hcWorkingKey, m_hSpooler);
        m_hcWorkingKey = NULL;
        LeaveCriticalSection(&m_critSect);
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\csutils.h ===
/*****************************************************************************
 *
 * $Workfile: CSUtils.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/CSUtils.h $
 *
 * 2     7/23/97 3:49p Binnur
 * changed the address resolution mechanism to update the IP address when
 * given a host name.
 *
 * 1     7/17/97 1:08p Dsnelson
 * New
 *
 * 2     7/14/97 2:25p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:34p Binnur
 * Initial File
 *
 * 4     5/30/97 5:16p Binnur
 * inheriting from CMemoryDebug
 *
 * 3     5/13/97 5:02p Binnur
 * UI addport integration
 *
 * 2     4/21/97 11:50a Binnur
 * Prints successfully.. SetJob functionality is not implemented. It can
 * print to the same device over two different ports. Needs to change the
 * GlobalAlloc from fixed to moveable.
 *
 * 1     4/14/97 2:50p Binnur
 * Port Monitor include files.
 *
 *****************************************************************************/

#ifndef INC_CSUTILS_H
#define INC_CSUTILS_H

class CMemoryDebug;

class CSocketUtils
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CSocketUtils();
	~CSocketUtils();

	BOOL	ResolveAddress( const char		*pHost,
							const USHORT	port,
							struct sockaddr_in *pAddr);
	BOOL	ResolveAddress( char   *pHost,
                            DWORD   dwHostNameBufferLength,
                            char   *pHostName,
                            DWORD   dwIpAddressBufferLength,
                            char   *pIPAddress);
	BOOL	ResolveAddress( LPSTR	pHostName,
							LPSTR   pIPAddress );

private:

};


#endif	// INC_CSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devstat.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved

Module Name:

    DevStat.h

Abstract:

    Status thread for TCP/IP Port Monitor

Author:
    Muhunthan Sivapragasam (MuhuntS)    25-Aug-98

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef INC_DEVSTAT_H
#define INC_DEVSTAT_H

#include        "portmgr.h"

class       CPortMgr;

//
// After telling status thread to terminate check every 0.1 seconds
//
#define     WAIT_FOR_THREAD_TIMEOUT 100


class
CDeviceStatus
#if defined _DEBUG || defined DEBUG
    : public CMemoryDebug
#endif
{
public:
    ~CDeviceStatus();

    static  CDeviceStatus      &gDeviceStatus();
    BOOL                        RunThread();
    VOID                        TerminateThread();
    BOOL                        RegisterPortMgr(CPortMgr *pPortMgr);
    VOID                        UnregisterPortMgr(CPortMgr *pPortMgr);

    BOOL                        SetStatusEvent();
    VOID                        SetStatusUpdateInterval(DWORD   dwVal);
    LONG                        GetStatusUpdateInterval(VOID)
                                    { return lUpdateInterval; }


private:
    CDeviceStatus();

    struct _PortMgrList {
        CPortMgr               *pPortMgr;
        struct  _PortMgrList   *pNext;
    }   *pPortMgrList;


    BOOL                bTerminate;
    LONG                lUpdateInterval;
    HANDLE              hStatusEvent;
    CRITICAL_SECTION    CS;
    CRITICAL_SECTION    PortListCS;

    static  VOID        StatusThread(CDeviceStatus *);
    VOID                EnterCS(VOID);
    VOID                LeaveCS(VOID);

    VOID                EnterPortListCS(VOID);
    VOID                LeavePortListCS(VOID);

    time_t              CheckAndUpdateAllPrinters(VOID);
    HANDLE              m_hThread;

};

#endif  // INC_DEVSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\csutils.cpp ===
/*****************************************************************************
 *
 * $Workfile: CSUtils.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "csutils.h"


///////////////////////////////////////////////////////////////////////////////
//  CSocketUtils::CSocketUtils

CSocketUtils::
CSocketUtils(
    VOID
    )
{

}       // ::CSocketUtils()


///////////////////////////////////////////////////////////////////////////////
//  CSocketUtils::~CSocketUtils

CSocketUtils::
~CSocketUtils(
    VOID
    )
{

}       // ::~CSocketUtils()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- resolves the host name or the ip address of the peripheral
//              and fills the in_addr structure.
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN      const char         *pHost,
    IN      const USHORT        port,
    IN OUT  struct sockaddr_in *pAddr)
{
    struct hostent      *h_info;            /* host information */

    //
    // Check for dotted decimal or hostname.
    //
    if ( (pAddr->sin_addr.s_addr = inet_addr(pHost)) ==  INADDR_NONE ) {

    //
    // The IP address is not in dotted decimal notation. Try to get the
    // network peripheral IP address by host name.
    //
    if ( (h_info = gethostbyname(pHost)) != NULL ) {

        //
        // Copy the IP address to the address structure.
        ///
        (void) memcpy(&(pAddr->sin_addr.s_addr), h_info->h_addr,
              h_info->h_length);
    } else {

        return FALSE;
    }
    }

    pAddr->sin_family = AF_INET;
    pAddr->sin_port = htons(port);

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- resolves the host name or the ip address of the peripheral
//              and fills the the apporperiate host name or ipaddress field,  Note
//              if the address is in dotted notation it will be left in dotted notation
//              and only one strusture is filled.
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN      char   *pHost,
    IN      DWORD   dwHostNameBufferLength,
    IN OUT  char   *pHostName,
    IN      DWORD   dwIpAddressBufferLength,
    IN OUT  char   *pIPAddress
    )
{
    //
    // Check for dotted decimal or hostname.
    //
    //  This is not a very accurate check since
    //  and IP address can be 00000000001 which is
    //  also a valid hostname.
    //
    if ( strlen(pHost) >= dwIpAddressBufferLength || inet_addr(pHost) ==  INADDR_NONE ) {

        strncpy(pHostName, pHost, dwHostNameBufferLength);
        pHostName [dwHostNameBufferLength - 1] = 0;

        *pIPAddress = '\0';
    } else  { // it is a dotted notation

        strncpy(pIPAddress, pHost, dwIpAddressBufferLength);
        pIPAddress [dwIpAddressBufferLength - 1] = 0;
        *pHostName = '\0';
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- given the host name, resolves the IP address
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN  LPSTR   pHostName,
    OUT LPSTR   pIPAddress
    )
{
    BOOL bRet = FALSE;
    struct hostent              *h_info;            /* host information */
    struct sockaddr_in  h_Addr;

    if ( (h_info = gethostbyname(pHostName)) != NULL ) {

        //
        // Copy the IP address to the address structure.
        //
        memcpy(&(h_Addr.sin_addr.s_addr), h_info->h_addr, h_info->h_length);

        if (inet_ntoa(h_Addr.sin_addr)) {
            strncpyn(pIPAddress, inet_ntoa(h_Addr.sin_addr), (strlen(inet_ntoa(h_Addr.sin_addr))+1) );
            bRet = TRUE;
        }

    } else {

        *pIPAddress = '\0';
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devabc.h ===
/*****************************************************************************
 *
 * $Workfile: devABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_DEVICEABC_H
#define INC_DEVICEABC_H


class CDeviceABC			
{
public:
	virtual	~CDeviceABC() { };

	virtual DWORD Read( LPBYTE	pBuffer,
				 		DWORD	cbBufSize,
                        INT     iTimeout,
					    LPDWORD pcbRead) = 0;

	virtual	DWORD Write( LPBYTE	pBuffer,
						 DWORD	cbBuf,
						 LPDWORD pcbWritten) = 0;
	virtual	DWORD	Connect() = 0;
	virtual	DWORD	Close() = 0;
    virtual DWORD   GetAckBeforeClose(DWORD dwTimeInSeconds) = 0;
    virtual DWORD   PendingDataStatus(DWORD dwTimeoutInMilliseconds,
                                      LPDWORD pcbPending) = 0;
    virtual DWORD   ReadDataAvailable () = 0;

	virtual DWORD	SetStatus( LPTSTR psztPortName ) = 0;

	virtual DWORD	GetJobStatus() = 0;




private:

};


#endif	// INC_DEVICEABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devstat.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved

Module Name:

    DevStat.cpp

Abstract:

    Status thread for TCP/IP Port Monitor

Author:
    Muhunthan Sivapragasam (MuhuntS)    25-Aug-98

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "devstat.h"


CDeviceStatus::
CDeviceStatus(
    VOID
    ) :
    pPortMgrList(NULL),
    hStatusEvent(NULL),
    bTerminate(FALSE)
{
    lUpdateInterval    = DEFAULT_STATUSUPDATE_INTERVAL * 60;
    InitializeCriticalSection(&CS);
    InitializeCriticalSection(&PortListCS);
}

CDeviceStatus::
~CDeviceStatus(
    VOID
    )
{
    //
    // This happens only on shutdown. Keep it simple
    //
    DeleteCriticalSection(&CS);
    DeleteCriticalSection(&PortListCS);
}


VOID
CDeviceStatus::
SetStatusUpdateInterval(
    DWORD   dwVal
    )
{
    EnterCS();

    lUpdateInterval = dwVal * 60;
    LeaveCS();
}



CDeviceStatus&
CDeviceStatus::
gDeviceStatus(
    VOID
    )
{
    static  CDeviceStatus   gDevStat;

    return gDevStat;
}


BOOL
CDeviceStatus::
RegisterPortMgr(
    CPortMgr *pPortMgr
    )
{
    BOOL    bRet = FALSE;
    struct _PortMgrList *pNew;

    if ( pNew = (struct _PortMgrList *) LocalAlloc(LPTR, sizeof(*pNew)) ) {

        EnterPortListCS();

        pNew->pNext     = pPortMgrList;
        pNew->pPortMgr  = pPortMgr;
        pPortMgrList    = pNew;

        LeavePortListCS();

        bRet            = TRUE;
    }

    return bRet;
}


VOID
CDeviceStatus::
UnregisterPortMgr(
    CPortMgr   *pPortMgr
    )
{
    BOOL    bRestartStatusThread = hStatusEvent != NULL;
    struct _PortMgrList *ptr, *prev = NULL;

    EnterCS();

    //
    // By terminating and restarting the status thread we make sure
    // there is no CPort object blocked on SNMP call which has reference
    // CPortMgr object which we are deleting now
    //
    if ( bRestartStatusThread )
        TerminateThread();

    EnterPortListCS ();

    for ( ptr = pPortMgrList ; ptr->pPortMgr != pPortMgr ; ptr = ptr->pNext )
        prev = ptr;

    _ASSERTE(ptr != NULL);

    if ( prev )
        prev->pNext = ptr->pNext;
    else
        pPortMgrList = ptr->pNext;

    LeavePortListCS ();

    LocalFree(ptr);

    if ( bRestartStatusThread )
        RunThread();

    LeaveCS();

}


BOOL
CDeviceStatus::
SetStatusEvent(
    VOID
    )
{
    BOOL    bRet = TRUE;

    if ( hStatusEvent ) {

        EnterCS();

        if ( hStatusEvent )
            bRet = SetEvent(hStatusEvent);

        LeaveCS();
    }

    return bRet;
}

time_t
CDeviceStatus::
CheckAndUpdateAllPrinters(
    VOID
    )
{
    struct _PortMgrList         *pList;
    time_t                      lUpdateTime, lSmallestUpdateTime = 60*60;
    CPort                       *pPort = NULL;

    EnterPortListCS();
    pList = pPortMgrList;
    LeavePortListCS();

    while (pList) {

        pList->pPortMgr->m_pPortList->IncRef ();

        TEnumManagedListImp *pEnum;
        if (pList->pPortMgr->m_pPortList->NewEnum (&pEnum)) {

            BOOL bRet = TRUE;

            while (bRet) {

                bRet = pEnum->Next (&pPort);
                if (bRet) {

                    pPort->SetDeviceStatus();

                    lUpdateTime = pPort->NextUpdateTime();
                    if ( lSmallestUpdateTime > lUpdateTime )
                        lSmallestUpdateTime = lUpdateTime;

                    pPort->DecRef ();
                    pPort = NULL;

                    if (WaitForSingleObject( hStatusEvent, 0 ) == WAIT_OBJECT_0) {
                        if ( bTerminate )
                            break;  // We have been asked to terminate, abandon the main loop.
                    }

                }
            }

            pEnum->DecRef ();
        }

        pList->pPortMgr->m_pPortList->DecRef ();

        if (bTerminate) {
            break;
        }

        EnterPortListCS ();
        pList = pList->pNext;
        LeavePortListCS ();

    }

    return lSmallestUpdateTime;
}


VOID
CDeviceStatus::
StatusThread(
    CDeviceStatus   *pDeviceStatus
    )
{
    time_t  lUpdateTime;
    DWORD   rc;

    while ( !pDeviceStatus->bTerminate ) {

        lUpdateTime = pDeviceStatus->CheckAndUpdateAllPrinters();

        if ( pDeviceStatus->bTerminate )
            break;

        WaitForSingleObject(pDeviceStatus->hStatusEvent, static_cast<DWORD> (lUpdateTime*1000));
    }

    CloseHandle(pDeviceStatus->hStatusEvent);
    pDeviceStatus->bTerminate = FALSE;
    pDeviceStatus->hStatusEvent = NULL;
}


BOOL
CDeviceStatus::
RunThread(
    VOID
    )
{
    HANDLE      hThread;
    DWORD       dwThreadId;

    EnterCS();

    //
    // If the thread is already running wake it up. So for clustering
    // we do SNMP for new ports too
    //
    //
    if ( hStatusEvent ) {

        SetEvent(hStatusEvent);
        goto Done;
    }

    if ( hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ) {
        hThread = CreateThread(NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)StatusThread,
                               (LPVOID)&gDeviceStatus(),
                               0,
                               &dwThreadId);

        if ( hThread ) {
            SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST);
            CloseHandle(hThread);
        } else {

            CloseHandle(hStatusEvent);
            hStatusEvent = NULL;
        }
    }

Done:
    LeaveCS();

    return hStatusEvent != NULL;
}


VOID
CDeviceStatus::
TerminateThread(
    VOID
    )
{

    EnterCS();

    bTerminate = TRUE;

    //
    // Wake up the status thread, and wait for it die.
    //
    SetEvent(hStatusEvent);

    while ( hStatusEvent )     // The background thread sets this to NULL when it is done
        Sleep(WAIT_FOR_THREAD_TIMEOUT);

    LeaveCS();
}


VOID
CDeviceStatus::
EnterCS(
    VOID
    )
{
    EnterCriticalSection(&CS);
}

VOID
CDeviceStatus::
LeaveCS(
    VOID
    )
{
    LeaveCriticalSection(&CS);
}

VOID
CDeviceStatus::EnterPortListCS(
    VOID)
{
    EnterCriticalSection(&PortListCS);
}

VOID
CDeviceStatus::LeavePortListCS(
    VOID)
{
    LeaveCriticalSection(&PortListCS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\ipdata.h ===
/*****************************************************************************
 *
 * $Workfile: ipdata.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/Common/ipdata.h $
 * 
 * 3     8/07/97 1:46p Dsnelson
 * Added LPR Printing
 * 
 * 2     8/04/97 12:16p Dsnelson
 * Added defines for types common to lpr and raw transport.
 * 
 * 
 *****************************************************************************/

#ifndef INC_IPDATA_H
#define INC_IPDATA_H
 
//	registry entries
#define	PORTMONITOR_HOSTNAME    TEXT("HostName")
#define	PORTMONITOR_IPADDR      TEXT("IPAddress")
#define	PORTMONITOR_HWADDR      TEXT("HWAddress")
#define PORTMONITOR_PORTNUM		TEXT("PortNumber")
#define PORTMONITOR_QUEUE		TEXT("Queue")
#define DOUBLESPOOL_ENABLED     TEXT("Double Spool")
#define SNMP_COMMUNITY			TEXT("SNMP Community")
#define SNMP_DEVICE_INDEX		TEXT("SNMP Index")
#define SNMP_ENABLED			TEXT("SNMP Enabled")

#endif //INC_IPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\event.cpp ===
/*****************************************************************************
 *
 * $Workfile: event.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 * 
 ***************************************************************************/

#include "precomp.h"

HANDLE  hEventSource = NULL;
WORD        wLevel = EVENTLOG_ERROR_TYPE;

/***************************************************************************
 *
 * Function: EventLogAddMessage
 *
 * Author: Craig White
 *
 * Description:
 *     Adds the specified message to the event log.  The event log source
 *    must have already been specified in a previous call to EventLogOpen.
 *
 * Parameters:
 *    wType -
 *       The error level of the message to add.  The must be one of
 *       the following:
 *          EVENTLOG_ERROR_TYPE - Error message 
 *          EVENTLOG_WARNING_TYPE - Warning message
 *          EVENTLOG_INFORMATION_TYPE - Informational message
 *       A previous call to EventLogSetLevel will cause the messages
 *       to be filtered based on what level was set.  The default is
 *       to add all messages to the event log.
 *
 *    dwID -  
 *       The ID of the message that exists in the message file.  
 *       These values are defined in the message file.
 *
 *    wStringCount - 
 *       The number of strings passed in the lpString parameters.
 *       This must be 0 or greater.   
 *
 *    lpStrings - 
 *       An array of string pointers specifying the strings to include in
 *       the message.  This can be NULL if wStringCount is 0.
 *
 * Return Value:
 *    TRUE: The message was successfully added to the log.
 *    FALSE: The message could not be added.
 *
 ***************************************************************************/

BOOL
EventLogAddMessage(
    WORD        wType, 
    DWORD       dwID, 
    WORD        wStringCount, 
    LPCTSTR *lpStrings
    )

{

    BOOL        bLogEvent = FALSE;

    //
    //  A previous call to EventLogOpen was not done if this is NULL
    //
    if ( hEventSource == NULL ) {

        _ASSERTE(hEventSource != NULL);
        return FALSE;
    }

    //
    //  Check to see if message should be logged based on 
    //  set level
    //
    switch (wLevel) {

        case EVENTLOG_ERROR_TYPE:
            bLogEvent = TRUE;
            break;

        case EVENTLOG_WARNING_TYPE:
            bLogEvent = wType == EVENTLOG_ERROR_TYPE ||
                        wType == EVENTLOG_WARNING_TYPE;
            break;

        case EVENTLOG_INFORMATION_TYPE:
            bLogEvent = wType == EVENTLOG_ERROR_TYPE    ||
                        wType == EVENTLOG_WARNING_TYPE  ||
                        wType == EVENTLOG_INFORMATION_TYPE;
            break;

        default:
            _ASSERTE(FALSE);
            return FALSE;
    }
                     
    return bLogEvent ? ReportEvent(hEventSource, wType, 0, dwID, NULL,
                                   wStringCount,  0, (LPCTSTR *)lpStrings,
                                   NULL)
                     : TRUE;
}


/***************************************************************************
 *
 * Function: EventLogOpen
 *
 * Author: Craig White
 *
 * Description:
 *     Initializes the event log prior to adding messages.  All events go to
 *    specified event log type until a subsequent EventLogClose and 
 *    EventLogOpen are called.
 *
 * Parameters:
 *    lpAppName -
 *       The name of the service providing the event logging.
 *        
 *    lpLogType -
 *       The type of the event log to open.  Must be one of the following:
 *         LOG_APPLICATION - The application log 
 *         LOG_SYSTEM - The system log 
 *         LOG_SECURITY - The security log 
 *        
 *    lpFileName -  
 *       The complete path of the file that contains the messages.
 *
 * Return Value:
 *    TRUE: The event log was successfully opened.
 *    FALSE: The event log could not be opened.
 *
 ***************************************************************************/

BOOL
EventLogOpen(
    LPTSTR lpAppName, 
    LPTSTR lpLogType,
    LPTSTR lpFileName
    )

{
    TCHAR       szPathName[256];
    HKEY        hKey;
    DWORD       dwLen, dwKeyDisposition = 0;
    DWORD       dwMsgTypes = EVENTLOG_INFORMATION_TYPE | 
                             EVENTLOG_WARNING_TYPE | 
                             EVENTLOG_ERROR_TYPE;
    
    if ( !lpAppName || !lpFileName ||
         ( _tcsicmp(lpLogType, LOG_APPLICATION)     &&
           _tcsicmp(lpLogType, LOG_SECURITY)        &&
           _tcsicmp(lpLogType, LOG_SYSTEM) ) ) {

        _ASSERTE(FALSE);
        return FALSE;
    }

    //
    //  Event log was not closed from a previous open call
    //
    if ( hEventSource ) {

        _ASSERTE(hEventSource == NULL);
        return FALSE;
    }

    dwLen =  _tcslen(lpLogType) + _tcslen(lpAppName) + 3;

    if ( dwLen > SIZEOF_IN_CHAR(szPathName) ) {

        _ASSERTE(dwLen <= SIZEOF_IN_CHAR(szPathName));
        return FALSE;
    }

    _stprintf(szPathName, TEXT("%s\\%s\\%s"), EVENT_LOG_APP_ROOT,
              lpLogType, lpAppName);

    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPathName, 0, lpAppName, 
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, &dwKeyDisposition) != ERROR_SUCCESS )
        return FALSE;

    if ( RegSetValueEx(hKey, EVENT_TYPES_SUPPORTED, 0L,
                       REG_DWORD,  (LPBYTE)&dwMsgTypes,
                       sizeof(dwMsgTypes)) == ERROR_SUCCESS    &&
         RegSetValueEx(hKey, EVENT_MSG_FILE, 0L,
                       REG_SZ, (LPBYTE)lpFileName,
                       STRLENN_IN_BYTES(lpFileName)) == ERROR_SUCCESS ) {


        hEventSource = RegisterEventSource(NULL, lpAppName);
    }

    RegCloseKey(hKey);

    return hEventSource != NULL;

}


/***************************************************************************
 *
 * Function: EventLogClose
 *
 * Author: Craig White
 *
 * Description:
 *     Closes the event log after a prior call to EventLogOpen.
 *
 * Parameters: None
 *
 * Return Value: None
 *
 ***************************************************************************/

VOID
EventLogClose(
    VOID
    )
{
    //
    //  Cause an assert if the log was not previously opened
    //
    if ( !hEventSource ) {

        _ASSERTE(hEventSource != NULL );
    } else {

        DeregisterEventSource(hEventSource);
        hEventSource = NULL;
    }
}

/***************************************************************************
 *
 * Function: EventLogSetLevel
 *
 * Author: Craig White
 *
 * Description:
 *     Sets the level of messages to allow to go to the event log.
 *
 * Parameters:
 *    wType -
 *       The type of the level to limit messages to.  The results will be:
 *          EVENTLOG_ERROR_TYPE - Log only errors
 *          EVENTLOG_WARNING_TYPE - Log errors and warnings
 *          EVENTLOG_INFORMATION_TYPE - Log errors, warnings and information 
 *
 * Return Value:
 *    TRUE: The event log level was successfully set.
 *    FALSE: The event log level could not be set.
 *
 ***************************************************************************/

BOOL
EventLogSetLevel(
    WORD wType
    )

{
    if ( wType != EVENTLOG_ERROR_TYPE       && 
         wType != EVENTLOG_WARNING_TYPE     &&
         wType != EVENTLOG_INFORMATION_TYPE ) {

        _ASSERTE(wType == EVENTLOG_ERROR_TYPE       ||
                 wType == EVENTLOG_WARNING_TYPE     ||
                 wType == EVENTLOG_INFORMATION_TYPE);
        return FALSE;
    }

    wLevel = wType;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\jobabc.h ===
/*****************************************************************************
 *
 * $Workfile: jobABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_JOBABC_H
#define INC_JOBABC_H

class CJobABC			
{
public:
	virtual	~CJobABC() { };

	virtual	DWORD	Write(	 LPBYTE  pBuffer, 
							 DWORD	  cbBuf,
							 LPDWORD pcbWritten) = 0;
	virtual	DWORD	StartDoc() = 0;
	virtual	DWORD	EndDoc() = 0;


private:

};


#endif	// INC_JOBABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\event.h ===
/***************************************************************************
 * $Workfile: event.h $
 *
 * Copyright (C) 1993-1996 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho  83714
 *
 ***************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/event.h $
 * 
 * 2     7/14/97 2:27p Binnur
 * copyright statement
 * 
 * 1     7/02/97 2:19p Binnur
 * Initial File
 * 
 ***************************************************************************/

#ifndef _EVENT_H
#define _EVENT_H


#define	EVENT_TYPES_SUPPORTED		TEXT("TypesSupported")
#define	EVENT_MSG_FILE					TEXT("EventMessageFile")
#define	EVENT_LOG_APP_ROOT			TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog")

#define  LOG_APPLICATION				TEXT("Application")
#define  LOG_SYSTEM						TEXT("System")
#define  LOG_SECURITY					TEXT("Security")

#define EVENT_LOG0(err,id)                                  \
            if( 1 ) {                                       \
                EventLogAddMessage(err, (id), 0, NULL);		\
            } else

#define EVENT_LOG1(err,id,s0)										            \
            if( 1 ) {															   \
                LPTSTR apsz[1];													\
																							\
                apsz[0] = (s0);													\
                EventLogAddMessage(err, (id), 1, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG2(err,id,s0,s1)												   \
            if( 1 ) {																\
                LPTSTR apsz[2];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                EventLogAddMessage(err, (id), 2, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG3(err,id,s0,s1,s2)												\
            if( 1 ) {																\
                LPTSTR apsz[3];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                apsz[2] = (s2);													\
                EventLogAddMessage(err, (id), 3, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG4(err,id,s0,s1,s2,s3)											\
            if( 1 ) {																\
                LPTSTR apsz[4];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                apsz[2] = (s2);													\
                apsz[3] = (s3);													\
                EventLogAddMessage(err, (id), 4, (LPCTSTR *)apsz);	\
            } else

#ifdef __cplusplus
extern "C" {
#endif

BOOL EventLogAddMessage
		(
		WORD		wType, 
		DWORD		dwID, 
		WORD		wStringCount, 
		LPCTSTR	*lpStrings
		);

BOOL EventLogOpen
		(
		LPTSTR lpAppName, 
		LPTSTR lpLogType,
		LPTSTR lpFileName
		);

void EventLogClose
		(
		void
		);

BOOL EventLogSetLevel
		(
		WORD wType
		);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprifc.h ===
/*****************************************************************************
 *
 * $Workfile: LPRifc.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_LPRIFC_H
#define INC_LPRIFC_H

#include "ipdata.h"
#include "lprdata.h"
#include "rawtcp.h"
#include "devstat.h"

#define	MAX_LPR_PORTS				1
#define LPR_PORT_1					515

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

class	CPortRefABC;


// the interface for CLPRInterface class
class CLPRInterface : public CRawTcpInterface		
{
public:
	CLPRInterface(CPortMgr *pPortMgr);
	~CLPRInterface();

	DWORD	CreatePort( DWORD		IN		dwProtocolType,					// port related functions
						DWORD		IN		dwVersion,
						PPORT_DATA_1 IN		pData,
						CRegABC		IN		*pRegistry,
						CPortRefABC	IN OUT	**pPort );					
	DWORD	CreatePort( LPTSTR		IN		psztPortName,
						DWORD		IN		dwProtocolType,				
						DWORD		IN		dwVersion,
						CRegABC		IN		*pRegistry,
						CPortRefABC	IN OUT	**pPort );	
private:
    BOOL    GetRegistryEntry(LPTSTR		psztPortName,
							 DWORD	in	dwVersion,
                             CRegABC *pRegistry,
							 LPR_PORT_DATA_1	in	*pRegData1
							 );



};	// class CLPRInterface


#endif	// INC_LPRIFC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprifc.cpp ===
/*****************************************************************************
 *
 * $Workfile: LPRifc.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "lprport.h"
#include "lprifc.h"

/*****************************************************************************
*
* CLPRInterface implementation
*
*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

//DWORD CLPRInterface::m_dwProtocol = PROTOCOL_LPR_TYPE;
//DWORD CLPRInterface::m_dwVersion = PROTOCOL_LPR_VERSION;
static DWORD dwLPRPorts[] = { LPR_PORT_1 };

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::CRawTcpInterface()

CLPRInterface::
CLPRInterface(
    CPortMgr *pPortMgr
    ) : CRawTcpInterface(pPortMgr)
{

    m_dwProtocol    = PROTOCOL_LPR_TYPE;
    m_dwVersion     = PROTOCOL_LPR_VERSION1;
    m_dwPort        = dwLPRPorts;

}   // ::CRawTcpInterface()

///////////////////////////////////////////////////////////////////////////////
//  CLPRInterface::~CLPRInterface()

CLPRInterface::
~CLPRInterface(
    VOID
    )
{
}   // ::~CLPRInterface()

///////////////////////////////////////////////////////////////////////////////
//  GetRegistryEntry

BOOL
CLPRInterface::
GetRegistryEntry(
    IN      LPTSTR              psztPortName,
    IN      DWORD               dwVersion,
    IN      CRegABC             *pRegistry,
    OUT     LPR_PORT_DATA_1     *pRegData1
    )
{
    BOOL    bRet = FALSE;
    BOOL    bKeySet = FALSE;
    DWORD   dwSize, dwRet;

    memset( pRegData1, 0, sizeof(RAWTCP_PORT_DATA_1) );

    if ( dwRet = pRegistry->SetWorkingKey(psztPortName) )
        goto Done;

    bKeySet = TRUE;
    //
    // Get host name
    //
    dwSize = sizeof(pRegData1->sztHostName);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HOSTNAME,
                                      (LPBYTE)pRegData1->sztHostName,
                                      &dwSize) )
        goto Done;

    //
    // Get IP Address
    //
    dwSize = sizeof(pRegData1->sztIPAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_IPADDR,
                                       (LPBYTE)pRegData1->sztIPAddress,
                                       &dwSize) )
        goto Done;

    //
    // Get Hardware address
    //
    dwSize = sizeof(pRegData1->sztHWAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HWADDR,
                                       (LPBYTE)pRegData1->sztHWAddress,
                                       &dwSize) )
        goto Done;

    //
    // Get the port number (ex: 9100, 9101)
    //
    dwSize = sizeof(pRegData1->dwPortNumber);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_PORTNUM,
                                       (LPBYTE)&(pRegData1->dwPortNumber),
                                       &dwSize) )
        goto Done;

    //
    // Get the lpr queue name
    //
    dwSize = sizeof(pRegData1->sztQueue);
    if (dwRet = pRegistry->QueryValue(PORTMONITOR_QUEUE,
                                       (LPBYTE)pRegData1->sztQueue,
                                       &dwSize)  )
        goto Done;


    //
    // Get Double spool enabled flag
    //
    dwSize = sizeof(pRegData1->dwDoubleSpool);
    if ( pRegistry->QueryValue(DOUBLESPOOL_ENABLED,
                               (LPBYTE)&(pRegData1->dwDoubleSpool),
                               &dwSize) ) {

        pRegData1->dwDoubleSpool = 0;
    }

    //
    // Get SNMP status enabled flag
    //
    dwSize = sizeof(pRegData1->dwSNMPEnabled);
    if ( dwRet = pRegistry->QueryValue(SNMP_ENABLED,
                                       (LPBYTE)&(pRegData1->dwSNMPEnabled),
                                       &dwSize) )
        goto Done;

    //
    // Get SNMP device index
    //
    dwSize = sizeof(pRegData1->dwSNMPDevIndex);
    if ( dwRet = pRegistry->QueryValue(SNMP_DEVICE_INDEX,
                                      (LPBYTE)&(pRegData1->dwSNMPDevIndex),
                                      &dwSize) )
        goto Done;

    //
    // Get SNMP community
    //
    dwSize = sizeof(pRegData1->sztSNMPCommunity);
    if ( dwRet = pRegistry->QueryValue(SNMP_COMMUNITY,
                                       (LPBYTE)&(pRegData1->sztSNMPCommunity),
                                       &dwSize) )
        goto Done;

    bRet = TRUE;

    Done:
       if ( bKeySet )
           pRegistry->FreeWorkingKey();

       if ( !bRet )
           SetLastError(dwRet);


    return bRet;

}   // GetRegistryEntry()



///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CLPRInterface::
CreatePort(
    IN      DWORD           dwProtocol,
    IN      DWORD           dwVersion,
    IN      PPORT_DATA_1    pData,
    IN      CRegABC         *pRegistry,
    IN OUT  CPortRefABC    **pPort )
{
    DWORD   dwRetCode = NO_ERROR;

    //
    //  Is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocol) )
        return  ERROR_NOT_SUPPORTED;

    //
    // Is the version supported
    //
    if ( !IsVersionSupported(dwVersion) )
        return  ERROR_INVALID_LEVEL;

    EnterCSection();

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:  {   // PORT_DATA_1
            CLPRPort *pLPRPort = new CLPRPort(pData->sztPortName,
                                  pData->sztHostAddress,
                                  pData->sztQueue,
                                  pData->dwPortNumber,
                                  pData->dwDoubleSpool,
                                  pData->dwSNMPEnabled,
                                  pData->sztSNMPCommunity,
                                  pData->dwSNMPDevIndex,
                                  pRegistry,
                                  m_pPortMgr);
            if (pLPRPort) {
                pLPRPort->SetRegistryEntry(pData->sztPortName,
                                              dwProtocol,
                                              dwVersion,
                                              (LPBYTE)pData );
                *pPort = pLPRPort;
            } else {
                *pPort = NULL;
            }

            if ( !*pPort && (dwRetCode = GetLastError() == ERROR_SUCCESS) )
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        default:
            dwRetCode = ERROR_NOT_SUPPORTED;

    }   // end::switch

    ExitCSection();

    return dwRetCode;

}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CLPRInterface::
CreatePort(
    IN      LPTSTR          psztPortName,
    IN      DWORD           dwProtocolType,
    IN      DWORD           dwVersion,
    IN      CRegABC         *pRegistry,
    IN OUT  CPortRefABC     **pPort )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    //
    // Is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocolType) )
        return  ERROR_NOT_SUPPORTED;

    //
    // Is the version supported?
    //
    if ( !IsVersionSupported(dwVersion) )
        return  ERROR_INVALID_LEVEL;

    EnterCSection();

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:      // LPR_PORT_DATA_1

            LPR_PORT_DATA_1 regData1;

            //
            // read the registry entry & parse the data then call the CLPRPort
            //
            if ( !GetRegistryEntry(psztPortName,
                                  dwVersion,
                                  pRegistry,
                                  &regData1)){
                if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                    dwRetCode = STG_E_UNKNOWN;
                    goto Done;
            }

            //
            // fill in the port name
            //
            lstrcpyn(regData1.sztPortName, psztPortName, MAX_PORTNAME_LEN); // fill in the port name
            if ( *pPort = new CLPRPort(regData1.sztPortName,
                                       regData1.sztHostName,
                                       regData1.sztIPAddress,
                                       regData1.sztHWAddress,
                                       regData1.sztQueue,
                                       regData1.dwPortNumber,
                                       regData1.dwDoubleSpool,
                                       regData1.dwSNMPEnabled,
                                       regData1.sztSNMPCommunity,
                                       regData1.dwSNMPDevIndex,
                                       pRegistry,
                                       m_pPortMgr ) )
                bRet = TRUE;
            break;
    }   // end::switch

Done:
    ExitCSection();

    if ( !bRet && (dwRetCode = GetLastError()) != ERROR_SUCCESS )
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

    return dwRetCode;
}   // ::CreatePort()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprjob.cpp ===
/*****************************************************************************
 *
 * $Workfile: lprjob.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "message.h"
#include "resource.h"
#include "lprport.h"
#include "rawdev.h"
#include "lprjob.h"

WCHAR       szDef[] = L"Default";

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpJob::CRawTcpJob()
//      Called by CPort when StartDocPort is called

CLPRJob::
CLPRJob(
    IN  LPTSTR      psztPrinterName,
    IN  DWORD       jobId,
    IN  DWORD       level,
    IN  LPBYTE      pDocInfo,
    IN  BOOL        bSpoolFirst,
    IN  CTcpPort   *pParent
    ) : CTcpJob(psztPrinterName, jobId, level, pDocInfo, pParent, kLPRJob),
        m_hFile(INVALID_HANDLE_VALUE), m_dwFlags(0), m_dwJobSize(0),
        m_dwSizePrinted(0)
{
    if ( bSpoolFirst )
        m_dwFlags |= LPRJOB_SPOOL_FIRST;
}   // ::CLPRJob()


LPSTR
CLPRJob::
AllocateAnsiString(
    LPWSTR  pszUni
    )
/*++
        Allocate an ANSI string for the given unicode string. Memory is
        allocated, and caller is responsible for freeing it.
--*/
{
    DWORD   dwSize;
    LPSTR   pszRet = NULL;

    dwSize = (wcslen(pszUni) + 1) * sizeof(CHAR);

    if ( pszRet = (LPSTR) LocalAlloc(LPTR, dwSize) ) {

        UNICODE_TO_MBCS(pszRet, dwSize, pszUni, -1);
    }

    return pszRet;
}


BOOL
CLPRJob::
UpdateJobStatus(
    DWORD   dwStatusId
    )
/*++
        Update job status with the spooler
--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwSize;
    TCHAR           szStatus[100];
    LPJOB_INFO_1    pJobInfo1 = NULL;

    if ( dwStatusId     &&
         !LoadString(g_hInstance, dwStatusId,
                     szStatus, SIZEOF_IN_CHAR(szStatus)) )
        return FALSE;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwSize);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo1 = (LPJOB_INFO_1) LocalAlloc(LPTR, dwSize)) )
        goto Done;

    if ( !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo1, dwSize, &dwSize) )
        goto Done;

    pJobInfo1->Position = JOB_POSITION_UNSPECIFIED;
    pJobInfo1->pStatus  = dwStatusId ? szStatus : NULL;

    if ( bRet = SetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo1, 0) )
        m_dwFlags |= LPRJOB_STATUS_SET;

Done:
    if ( pJobInfo1 )
        LocalFree(pJobInfo1);

    return bRet;
}


DWORD
CLPRJob::
ReadLpdReply(
    DWORD dwTimeOut
    )
/*++
        Gets the acknowldgement from the LPD serve.
        Return value is the win32 error
--*/
{
    CHAR    szBuf[256];
    DWORD   dwRead, dwRet;

    if ( dwRet = (m_pParent->GetDevice())->Read((unsigned char *)szBuf,
                                                sizeof(szBuf),
                                                dwTimeOut,
                                                &dwRead) )
        goto Done;

    //
    // A 0 from the LPD server is an ACK, anything else is a NACK
    //
    if ( dwRead == 0 || szBuf[0] != '\0' )
        dwRet = CS_E_NETWORK_ERROR;

/*
    if ( dwRet )
        OutputDebugStringA("NACK\n");
    else
        OutputDebugStringA("ACK\n");
*/

Done:
    return dwRet;
}


HANDLE
CLPRJob::
CreateSpoolFile(
    )
/*++
        Generates a name for the spool file in the spool directory and
        creates the file.
--*/
{
    HANDLE      hFile = INVALID_HANDLE_VALUE, hToken = NULL;
    DWORD       dwType, dwNeeded;

    hToken = RevertToPrinterSelf();

    if ( GetPrinterData(m_hPrinter,
                        SPLREG_DEFAULT_SPOOL_DIRECTORY,
                        &dwType,
                        (LPBYTE)m_szFileName,
                        sizeof(m_szFileName),
                        &dwNeeded) != ERROR_SUCCESS                 ||
         !GetTempFileName(m_szFileName, TEXT("TcpSpl"), 0, m_szFileName) ) {

        goto Done;
    }

    hFile = CreateFile(m_szFileName,
                       GENERIC_READ|GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY
                                             | FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);
Done:

    //
    // The thread is not impersonating client if hToken == NULL
    //
    if (hToken && !ImpersonatePrinterClient(hToken)) {

        DBGMSG (DBG_PORT, ("ImpersionteFailed - %d\n", GetLastError ()));

        if (hFile != INVALID_HANDLE_VALUE) {
            // Close the file
            CloseHandle (hFile);
            hFile = INVALID_HANDLE_VALUE;
            DeleteFile (m_szFileName);
        }
    }

    return hFile;
}


DWORD
CLPRJob::
GetCFileAndName(
    LPSTR      *ppszCFileName,
    LPDWORD     pdwCFileNameLen,
    LPSTR      *ppszCFile,
    LPDWORD     pdwCFileLen
    )
/*++
        Generates the control file and its name.
        Memory is allocated, caller is responsible for freeing it.
--*/
{
    DWORD           dwRet, dwJobId, dwNeeded, dwLen;
    LPJOB_INFO_1    pJobInfo = NULL;
    LPSTR           pHostName = NULL, pUserName = NULL, pJobName = NULL;
    LPWSTR          psz;

    dwNeeded =  *pdwCFileNameLen = *pdwCFileLen = 0;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwNeeded);

    if ( (dwRet = GetLastError()) != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) LocalAlloc(LPTR, dwNeeded))       ||
         !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    dwJobId = pJobInfo->JobId % 1000; // LPR used seq nos. why?

    //
    // Convert machine name to ANSI
    //
    if ( pJobInfo->pMachineName && *pJobInfo->pMachineName ) {

        psz = pJobInfo->pMachineName;
        while ( *psz == L'\\' )
            ++psz;

    } else {

        psz = szDef;
    }

    if ( !(pHostName = AllocateAnsiString(psz)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    //
    // Convert user name to ANSI
    //
    if ( pJobInfo->pUserName && *pJobInfo->pUserName )
        psz = pJobInfo->pUserName;
    else
        psz = szDef;

    if ( !(pUserName = AllocateAnsiString(psz)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    //
    // Convert job name to ANSI if not NULL
    //
    if ( pJobInfo->pDocument && *pJobInfo->pDocument ) {

        if ( !(pJobName = AllocateAnsiString(pJobInfo->pDocument)) ) {

            if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
                dwRet = ERROR_OUTOFMEMORY;

            goto Done;
        }
    }

    //
    // Compute the length of the 2 fields
    //
    *pdwCFileNameLen    = 6 + strlen(pHostName);
    *pdwCFileLen        = 2 + strlen(pHostName) + 2 + strlen(pUserName)
                                                + 2 * (2 + *pdwCFileNameLen);

    if ( pJobName )
        *pdwCFileLen += 2 * (2 + strlen(pJobName));

    if ( !(*ppszCFile = (LPSTR) LocalAlloc(LPTR,
                                           (*pdwCFileLen + 1) * sizeof(CHAR)))  ||
         !(*ppszCFileName = (LPSTR) LocalAlloc(LPTR,
                                               (*pdwCFileNameLen + 1 ) * sizeof(CHAR))) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    //
    // CFile name
    //
    dwLen = sprintf(*ppszCFileName, "dfA%03d%s", dwJobId, pHostName);

    //
    // Cmd line which varies depending on pJobName being non-NULL
    //
    if ( pJobName )
        dwLen = sprintf(*ppszCFile,
                "H%s\nP%s\nJ%s\nl%s\nU%s\nN%s\n",
                pHostName,
                pUserName,
                pJobName,
                *ppszCFileName,
                *ppszCFileName,
                pJobName);
    else
        dwLen = sprintf(*ppszCFile,
                "H%s\nP%s\nl%s\nU%s\n",
                pHostName,
                pUserName,
                *ppszCFileName,
                *ppszCFileName);

    (*ppszCFileName)[0] = 'c';

    dwRet = ERROR_SUCCESS;

Done:
    if ( pJobInfo )
        LocalFree(pJobInfo);

    if ( pHostName )
        LocalFree(pHostName);

    if ( pUserName )
        LocalFree(pUserName);

    if ( pJobName )
        LocalFree(pJobName);

    if ( dwRet != ERROR_SUCCESS ) {

        if ( *ppszCFile ) {

            LocalFree(*ppszCFile);
            *ppszCFile = NULL;
        }

        if ( *ppszCFileName ) {

            LocalFree(*ppszCFileName);
            *ppszCFileName = NULL;
        }
    }

    return dwRet;
}


DWORD
CLPRJob::
EstablishConnection(
    VOID
    )
{
    return CTcpJob::StartDoc();
}

DWORD
CLPRJob::
StartJob(
    VOID
    )
/*++
        Initiate the job by sending the control file header, control file,
        and the data file header.
--*/
{
    DWORD           dwRet, dwLen, dwDaemonCmdLen;
    DWORD           dwCFileNameLen, dwCFileLen, dwRead, dwWritten;
    LPSTR           pszCFile = NULL, pszCFileName = NULL,
                    pszHdr = NULL, pszQueue = NULL;

    if ( dwRet = GetCFileAndName(&pszCFileName, &dwCFileNameLen,
                                 &pszCFile, &dwCFileLen) )
        goto Done;

    if ( !(pszQueue = AllocateAnsiString(((CLPRPort *)m_pParent)->GetQueue())) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    //
    // Need to send Daemon cmd and Control file header. We will allocate
    // buffer big enough for the bigger of the two
    //
    dwLen           = 1 + 15 + 1 + dwCFileNameLen + 1;
    dwDaemonCmdLen  = 1 + strlen(pszQueue) + 1;
    if ( dwLen < dwDaemonCmdLen + 1 )
        dwLen = dwDaemonCmdLen + 1;

    if ( !(pszHdr = (LPSTR) LocalAlloc(LPTR, (dwLen + 1) * sizeof(CHAR))) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    //
    // Send the daemon command first
    //
    sprintf(pszHdr, "%c%s\n", LPR_RECV_JOB, pszQueue);

    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwDaemonCmdLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // Form the Control File Header
    //
    dwLen = sprintf(pszHdr,
                    "%c%d %s\n",
                    LPR_CONTROL_HDR,
                    dwCFileLen * sizeof(CHAR),
                    pszCFileName);

    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // Include \0 as part of the package here like lprmon
    //
    if ( (dwRet = CTcpJob::Write((unsigned char *)pszCFile,
                                  (dwCFileLen + 1) * sizeof(CHAR),
                                  &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // For the Data File header
    //
    pszCFileName[0] = 'd';
    if ( m_dwFlags & LPRJOB_SPOOL_FIRST ) {

        dwLen = sprintf(pszHdr,
                        "%c%d %s\n",
                        LPR_DATA_HDR,
                        m_dwJobSize,
                        pszCFileName);

    } else {

        dwLen = sprintf(pszHdr,
                        "%c125899906843000 %s\n",
                        '\3',           // Tells this is the Data File Header
                        pszCFileName);
    }

    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    m_dwFlags  |= LPRJOB_DATASIZESENT;

Done:
    if ( pszCFileName )
        LocalFree(pszCFileName);

    if ( pszCFile )
        LocalFree(pszCFile);

    if ( pszHdr )
        LocalFree(pszHdr);

    if ( pszQueue )
        LocalFree(pszQueue);

    return dwRet;
}


/*++
        StartDoc for the job object
--*/
DWORD
CLPRJob::
StartDoc(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;

    if ( !m_hPrinter && !OpenPrinter(m_sztPrinterName, &m_hPrinter, NULL) )
        return GetLastError();

    if ( m_dwFlags & LPRJOB_SPOOL_FIRST ) {

        UpdateJobStatus(IDS_STRING_SPOOLING);

        if ( (m_hFile = CreateSpoolFile()) == INVALID_HANDLE_VALUE ) {

            if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                dwRetCode = STG_E_UNKNOWN;

            goto Done;
        } else {

            m_dwFlags |= LPRJOB_SPOOLING;
        }
    } else {

        m_bFirstWrite = TRUE;

        dwRetCode = EstablishConnection ();
    }

Done:
    return dwRetCode;
}   //  :: StartDoc()


DWORD
CLPRJob::
Write(
    IN      LPBYTE      pBuf,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
/*++
        Write function for the job object.
        Will write to disk in case of double spooling in the first pass.
        Otherwise send the bits to the LPD server.
--*/
{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwWritten;

    if ( (m_dwFlags & LPRJOB_SPOOL_FIRST) && (m_dwFlags & LPRJOB_SPOOLING) ) {

        dwRet =  WriteFile(m_hFile, pBuf, cbBuf, &dwWritten, NULL)
                        ? ERROR_SUCCESS : GetLastError();

        if ( dwRet == ERROR_SUCCESS ) {

            *pcbWritten += dwWritten;
            m_dwJobSize += dwWritten;
        }
        else {
            if (dwRet == ERROR_DISK_FULL) {
                TCHAR szMsg[256];

                if (LoadString(g_hInstance, IDS_DISK_FULL, szMsg, sizeof (szMsg) / sizeof (TCHAR))) {

                    EVENT_LOG1 (EVENTLOG_ERROR_TYPE, HARD_DISK_FULL, szMsg);

                }

                //
                // We should release the diskspace asap when the disk is full
                //
                DeleteSpoolFile ();
            }
        }
    } else {

        if (m_bFirstWrite)
        {
            m_bFirstWrite = FALSE;

            dwRet = StartJob();
        }

        if (dwRet == ERROR_SUCCESS)
        {
            dwRet = CTcpJob::Write(pBuf, cbBuf, pcbWritten);
        }
    }

    return dwRet;
}


DWORD
CLPRJob::
DeSpoolJob(
    )
{
#define  CONNECT_RETRIES  3
    BOOL        bFirst = TRUE;
    CHAR        szBuf[1];
    DWORD       dwConnectAttempts = 0;
    DWORD       dwRet, dwTime, dwBufSize, dwJobSize, dwRead, dwWritten;
    LPBYTE      pBuf = NULL, pCur;

    m_dwFlags   &= ~LPRJOB_SPOOLING;
    m_dwFlags   |= LPRJOB_DESPOOLING;

    if ( dwRet = SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) )
        goto Done;

    dwJobSize = m_dwJobSize;
    dwBufSize = dwJobSize > READ_BUFFER_SIZE ? READ_BUFFER_SIZE : dwJobSize;

    if ( !(pBuf = (LPBYTE) LocalAlloc(LPTR, dwBufSize)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    while (TRUE) {

        dwRet = EstablishConnection();

        if (dwRet == NOERROR)
        {
            dwRet = StartJob ();
        }
        else if (dwRet == ERROR_NOT_CONNECTED)
        {
            dwConnectAttempts++;
            if (dwConnectAttempts >= CONNECT_RETRIES)
                goto Done;
        }

        if (dwRet == NOERROR)
        {
            //
            //  We have succeeded in calling startjob
            //
            break;
        }

        //
        // Every LPR_ABORTCHK_TIMEOUT we will check if user deleted the job
        // and every LPR_RETRY_TIMEOUT we will retry talking to the device
        //
        for ( dwTime = 0 ;
              dwTime < LPR_RETRY_TIMEOUT ;
              dwTime += LPR_ABORTCHK_TIMEOUT ) {

            if ( IsJobAborted() ) {

                dwRet = ERROR_PRINT_CANCELLED;
                goto Done;
            }

            if ( bFirst ) {

                UpdateJobStatus(IDS_STRING_ERROR_OR_BUSY);
                bFirst = FALSE;
            }
            Sleep(LPR_ABORTCHK_TIMEOUT);
        }
    }

    UpdateJobStatus(IDS_STRING_PRINTING);

    while ( dwJobSize ) {

        //
        // Read from spool file
        //
        if ( !ReadFile(m_hFile, pBuf, dwBufSize, &dwRead, NULL) ) {

            dwRet = GetLastError();
            goto Done;
        }

        dwJobSize -= dwRead;

        //
        // Check if job has been cancelled
        //
        if ( IsJobAborted() ) {

            dwRet = ERROR_PRINT_CANCELLED;
            goto Done;
        }

        //
        // Write data in the buffer to the port
        //
        for ( pCur = pBuf ; dwRead ; dwRead -= dwWritten, pCur += dwWritten ) {

            //
            //  Sun Workstation may send a NACK in the middle of the job submission,
            //  so we need to poll the back channel to see if there is anything to
            //  read.
            //
            dwRet = ReadLpdReply(0);

            if (dwRet == CS_E_NETWORK_ERROR)
            {

                goto Done;
            }

            dwWritten = 0;
            dwRet = CTcpJob::Write(pCur, dwRead, &dwWritten);

            if ( dwRet == ERROR_SUCCESS )
                m_dwSizePrinted += dwWritten;
            else if ( dwRet == WSAEWOULDBLOCK ) {

                if ( IsJobAborted() ) {

                    dwRet = ERROR_PRINT_CANCELLED;
                    goto Done; // else continue
                }

            } else
                goto Done;
        }
    }

Done:
    if ( pBuf )
        LocalFree(pBuf);

    //
    // Send the confirmation zero octet for succesful completion
    //
    if ( dwRet == ERROR_SUCCESS ) {

        szBuf[0] = '\0';
        if ( (dwRet = CTcpJob::Write((unsigned char *)szBuf,
                            1, &dwWritten)) == ERROR_SUCCESS )
            dwRet = ReadLpdReply();
    }

    if ( dwRet != ERROR_SUCCESS && dwRet != ERROR_PRINT_CANCELLED )
        Restart();

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  EndDoc -- closes the previous connection w/ device
//  Error Codes:
//      NO_ERROR if successful

DWORD
CLPRJob::EndDoc(
    VOID
    )
{
    DWORD   dwRet = NO_ERROR;
    HANDLE  hToken;

    //
    // If we are double spooling then DeSpool if job size is not 0
    //
    if ( (m_dwFlags & LPRJOB_SPOOL_FIRST) && m_dwJobSize ) {

        dwRet = DeSpoolJob();
    }

    if ( m_dwFlags & LPRJOB_STATUS_SET )
        UpdateJobStatus(NULL);

    dwRet = CTcpJob::EndDoc();

    if ( m_hFile != INVALID_HANDLE_VALUE ) {

        dwRet = DeleteSpoolFile ();

    }

    return dwRet;

}   //  ::EndDoc()


CLPRJob::
~CLPRJob(
    VOID
    )
{
    if ( m_hPrinter ) {

        ClosePrinter(m_hPrinter);
        m_hPrinter = NULL;
    }
}

DWORD
CLPRJob::DeleteSpoolFile(
    VOID
    )
{
    DWORD   dwRet = NO_ERROR;
    HANDLE  hToken;

    hToken = RevertToPrinterSelf();

    CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;
    DeleteFile(m_szFileName);

    if (hToken && !ImpersonatePrinterClient(hToken)) {
        dwRet = GetLastError ();
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprjob.h ===
/*****************************************************************************
 *
 * $Workfile: lprjob.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_LPRJOB_H
#define INC_LPRJOB_H

#include "tcpjob.h"


#define     LPR_RECV_JOB                2
#define     LPR_CONTROL_HDR             '\2'
#define     LPR_DATA_HDR                '\3'

#define     LPR_READ_TIMEOUT            90
#define     LPR_ABORTCHK_TIMEOUT      1000
#define     LPR_RETRY_TIMEOUT         4000  // 4 seconds

#define             LPRJOB_SPOOL_FIRST          0x00000001
#define             LPRJOB_SPOOLING             0x00000002
#define             LPRJOB_DESPOOLING           0x00000004
#define             LPRJOB_DATASIZESENT         0x00000008
#define             LPRJOB_STATUS_SET           0x00000010

#define             READ_BUFFER_SIZE            4096

class CLPRPort;		

class CLPRJob : public CTcpJob
{
public:
	CLPRJob( LPTSTR	psztPrinterName,
	   		    DWORD	jobId,
				DWORD	level,
				LPBYTE	pDocInfo,
                BOOL    bSpoolFirst,
				CTcpPort	*pParent);

    ~CLPRJob(VOID);

	virtual DWORD	
    StartDoc();

    virtual DWORD
    Write(
        LPBYTE    pBuf,
        DWORD     cbBuf,
        LPDWORD   pcbWritten);

	virtual DWORD	
    EndDoc();

private:
    LPSTR       AllocateAnsiString(LPWSTR  pszUni);
    BOOL        UpdateJobStatus(DWORD   dwStatusId);
    DWORD       ReadLpdReply(DWORD dwTimeout = LPR_READ_TIMEOUT);
    HANDLE      CreateSpoolFile();
    DWORD       GetCFileAndName(LPSTR      *ppszCFileName,
                                LPDWORD     pdwFileNameLen,
                                LPSTR      *ppszCFile,
                                LPDWORD     pdwCFileLen
                                );
    DWORD       StartJob(VOID);
    DWORD       EstablishConnection(VOID);
    DWORD       DeSpoolJob();
    DWORD       DeleteSpoolFile(VOID);


    HANDLE      m_hFile;
    DWORD       m_dwFlags, m_dwJobSize, m_dwSizePrinted;
    TCHAR       m_szFileName[MAX_PATH];
    BOOL        m_bFirstWrite;

};


#endif // INC_LPRJOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprport.cpp ===
/*****************************************************************************
 *
 * $Workfile: lprport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "lprdata.h"
#include "lprjob.h"
#include "lprifc.h"
#include "lprport.h"

///////////////////////////////////////////////////////////////////////////////
//  CLPRPort::CLPRPort()    -- called when creating a new port through the UI

CLPRPort::
CLPRPort(
    IN  LPTSTR      psztPortName,
    IN  LPTSTR      psztHostAddress,
    IN  LPTSTR      psztQueue,
    IN  DWORD       dPortNum,
    IN  DWORD       dDoubleSpool,
    IN  DWORD       dSNMPEnabled,
    IN  LPTSTR      sztSNMPCommunity,
    IN  DWORD       dSNMPDevIndex,
    IN  CRegABC     *pRegistry,
    IN  CPortMgr    *pPortMgr
    ) : m_dwDoubleSpool(dDoubleSpool),
        CTcpPort(psztPortName, psztHostAddress, dPortNum, dSNMPEnabled,
                 sztSNMPCommunity, dSNMPDevIndex, pRegistry, pPortMgr)
{
    lstrcpyn(m_szQueue, psztQueue, SIZEOF_IN_CHAR(m_szQueue));
}   // ::CLPRPort()


///////////////////////////////////////////////////////////////////////////////
//  CLPRPort::CLPRPort() -- called when creating a new port through the
//      registry entries.

CLPRPort::
CLPRPort(
    IN  LPTSTR      psztPortName,
    IN  LPTSTR      psztHostName,
    IN  LPTSTR      psztIPAddr,
    IN  LPTSTR      psztHWAddr,
    IN  LPTSTR      psztQueue,
    IN  DWORD       dPortNum,
    IN  DWORD       dDoubleSpool,
    IN  DWORD       dSNMPEnabled,
    IN  LPTSTR      sztSNMPCommunity,
    IN  DWORD       dSNMPDevIndex,
    IN  CRegABC     *pRegistry,
    IN  CPortMgr    *pPortMgr
    ) : m_dwDoubleSpool( dDoubleSpool ),
        CTcpPort(psztPortName, psztHostName, psztIPAddr, psztHWAddr, dPortNum,
                 dSNMPEnabled, sztSNMPCommunity, dSNMPDevIndex, pRegistry, pPortMgr)
{
    lstrcpyn(m_szQueue, psztQueue, SIZEOF_IN_CHAR(m_szQueue));
}   // ::CLPRPort()


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CLPRPort::
StartDoc(
    IN  LPTSTR  psztPrinterName,
    IN  DWORD   jobId,
    IN  DWORD   level,
    IN  LPBYTE  pDocInfo
    )
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT3(_CRT_WARN,
          "PORT -- (CLPRPort) StartDoc called for (%S,%S) w/ jobID %d\n",
          psztPrinterName, m_szName, jobId);

    if ( m_pJob == NULL ) {
        m_pJob = new CLPRJob(psztPrinterName, jobId, level, pDocInfo,
                             m_dwDoubleSpool, this);

        if ( m_pJob ) {

            if ( dwRetCode = m_pJob->StartDoc() ) {

                delete m_pJob;
                m_pJob = NULL;
            }
        } else if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS ) {

            dwRetCode = STG_E_UNKNOWN;
        }
    }
    else {
        _RPT0( _CRT_WARN, TEXT("PORT - (LPRPORT)Start Doc called withour EndDoc\n") );
    }

    return dwRetCode;

}   // ::StartDoc()


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry

DWORD
CLPRPort::
SetRegistryEntry(
    IN  LPCTSTR     psztPortName,
    IN  DWORD       dwProtocol,
    IN  DWORD       dwVersion,
    IN  LPBYTE      pData
    )
{
    DWORD           dwRetCode = NO_ERROR;
    PPORT_DATA_1    pPortData = (PPORT_DATA_1)pData;

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:      // ADDPORT_DATA_1

            _ASSERTE( _tcscmp(psztPortName, pPortData->sztPortName) == 0 );

            dwRetCode = UpdateRegistryEntry( psztPortName,
                                             dwProtocol,
                                             dwVersion );


            break;

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;
    }   // end::switch

    return dwRetCode;

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  UpdateRegistryEntry

DWORD
CLPRPort::
UpdateRegistryEntry( LPCTSTR    psztPortName,
                     DWORD      dwProtocol,
                     DWORD      dwVersion
    )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = CTcpPort::UpdateRegistryEntry( psztPortName,
                                               dwProtocol,
                                               dwVersion );

    if  ( dwRetCode == NO_ERROR ) {
        if( m_pRegistry->SetWorkingKey( psztPortName ) == NO_ERROR ) {
            dwRetCode = m_pRegistry->SetValue( PORTMONITOR_QUEUE,
                                                    REG_SZ,
                                                    (LPBYTE)m_szQueue,
                                                    (_tcslen(m_szQueue) +1) * sizeof(TCHAR));

            if( dwRetCode == NOERROR )
            {
                dwRetCode = m_pRegistry->SetValue( DOUBLESPOOL_ENABLED,
                                                REG_DWORD,
                                                (CONST BYTE *)&m_dwDoubleSpool,
                                                sizeof(DWORD));

            }
            m_pRegistry->FreeWorkingKey();
        }
    }

    return dwRetCode;

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CLPRPort::
InitConfigPortUI(
    const DWORD dwProtocolType,
    const DWORD dwVersion,
    LPBYTE      pData
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_DATA_1    pConfigPortData = (PPORT_DATA_1) pData;

    if ( NO_ERROR != (dwRetCode = CTcpPort::InitConfigPortUI(dwProtocolType, dwVersion, pData)))
        goto Done;

    lstrcpyn(pConfigPortData->sztQueue, m_szQueue, MAX_QUEUENAME_LEN);
    pConfigPortData->dwDoubleSpool = m_dwDoubleSpool;
    pConfigPortData->dwVersion = PROTOCOL_LPR_VERSION1;
    pConfigPortData->dwProtocol = PROTOCOL_LPR_TYPE;

Done:
    return dwRetCode;

}   // ::InitConfigPortUI()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\makefile.inc ===
message.h message.rc msg00001.bin: message.mc
    mc -v message.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\mglist.h ===
#ifndef _MANAGED_LIST
#define _MANAGED_LIST

/***************************************************************************************

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mglist.h

Abstract:

    Managed List Class

Author:

    Weihai Chen  (WeihaiC) 04/10/00

Revision History:


The purpose of several classes in this file is to convert traditional a list 
data-structure without reference count into a robust multithread data structure.
There are many port monitors / providers uses link list as a data structure. 
However, since there are not reference count for the individual node, it is very
hard to controll the life time of the node. 


TRefCount:

    TRefCount is a class used to keep track of the ref count of a class. 
    When the refcount becomes zero, it deletes itself.

TRefNodeABC - TRefCount

    TRefNodeABC is an abstract class to keep track of the lifetime of a node in 
    a double linked list. 

    It uses TRefCount to keep track of the referece count. It uses a pending-deletion 
    state to tell if the node is being deleted. The opereation "Delete" marks the node
    as pending-deletion node after it calls "PartialDelete" function to delete all 
    the persistent storage of the node. This is to make sure that no conflict occurs
    when you create a new node with the same name while the old node is not deleted.
    
    This class has a tight relationship to TManagedList. When users add a new node 
    to TManagedList, TMangedClass calls  SetContextPtr () to set the critical section 
    pointer and double link list. The double link list is used to delete the Node when 
    the refcount becomes 0

TMangedList - TRefCount

    TManagedList is use to manage a double link list in a multi-threading environemnt. 
    The code is designed so that clients do not have to enter critical section for
    any operations. This class has an internal critical section to serialize operations.


TEnumManagedList - TRefCount

    TEnumManagedList is an iterator for TMangedList. The iterator will go through 
    all the non-pending deletion node in the list without holding the critical section.

***************************************************************************************/

class TRefCount 
{
public:
    TRefCount ():m_cRef(1) {};
    virtual ~TRefCount () {
        DBGMSG (DBG_TRACE, ("TRefCount deleted\n"));
    };
    
    virtual DWORD 
    IncRef () {
        DBGMSG (DBG_TRACE, ("+Ref (%d)\n", m_cRef));
        return InterlockedIncrement(&m_cRef) ;
    };

    virtual DWORD 
    DecRef () {    
        DBGMSG (DBG_TRACE, ("-Ref (%d)\n", m_cRef));
        if (InterlockedDecrement(&m_cRef) == 0) {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }
private:
    LONG m_cRef;
};

template <class T, class KEYTYPE> class TRefNodeABC:
    public TRefCount
{
public:
    TRefNodeABC ():
        m_pCritSec  (NULL),
        m_bPendingDeletion (FALSE) {};

    virtual ~TRefNodeABC () {
        DBGMSG (DBG_TRACE, ("TRefNodeABC deleted\n"));
    };

    virtual DWORD 
    DecRef () {    
        DWORD dwRef;

        if (m_pCritSec) {
            TAutoCriticalSection CritSec (*m_pCritSec);
            if (CritSec.bValid ()) {

                dwRef = TRefCount::DecRef();
    
                if (m_bPendingDeletion && dwRef == 1) {
                    // Delete
    
                    DBGMSG (DBG_TRACE, ("Deleting this node\n"));
                    m_pList->DeleteNode(m_pThisNode);
                    
                    //
                    // Delete this pointer
                    //
                    TRefCount::DecRef();
                }
            }
        }
        else 
            dwRef = TRefCount::DecRef();

        return dwRef;
    };
    
    VOID SetContextPtr (
        TCriticalSection *pCritSec,
        TSrchDoubleList<T, KEYTYPE> * pList,
        TDoubleNode <T, KEYTYPE> *pThisNode) {
            m_pCritSec = pCritSec;
            m_pList = pList;
            m_pThisNode = pThisNode;
    };
    
    BOOL Delete () {
        BOOL bRet = FALSE;

        if (m_pCritSec) {
            TAutoCriticalSection CritSec (*m_pCritSec);

            if (CritSec.bValid ()) {
                
                if (PartialDelete ()) {
                    m_bPendingDeletion = TRUE;
                    bRet = TRUE;
                }
            }
        }
        return bRet;
    };

    // This function is to delete all the persistent storage related to the node, such as 
    // registry settings etc.
    //

    virtual BOOL 
    PartialDelete (VOID) = 0;   
    
    // Return whether the node is in the pending deletion state
    //
    
    inline BOOL 
    IsPendingDeletion (BOOL &refPending)  CONST {
        BOOL bRet; 
    
        TAutoCriticalSection CritSec (*m_pCritSec);

        if (CritSec.bValid ()) {
        
            refPending = m_bPendingDeletion;
            bRet = TRUE;
        };
        return bRet;
    };

private:
    BOOL m_bPendingDeletion;
    TCriticalSection *m_pCritSec;
    TSrchDoubleList<T, KEYTYPE> * m_pList;
    TDoubleNode <T, KEYTYPE> *m_pThisNode;
};

template <class T, class KEYTYPE> class TManagedList;

                                
template <class T, class KEYTYPE> class TEnumManagedList:
    public TRefCount
{
public:

#ifdef DBG
    virtual DWORD 
    IncRef () {
        DBGMSG (DBG_TRACE, ("TEnumManagedList"));
        return TRefCount::IncRef();
    };
    
    virtual DWORD 
    DecRef () {    
        DBGMSG (DBG_TRACE, ("TEnumManagedList"));
        return TRefCount::DecRef();
    }
#endif
    
    BOOL bValid (VOID) CONST { return TRUE;};
    TEnumManagedList (
        TManagedList<T, KEYTYPE> *pList,
        TSrchDoubleList<T, KEYTYPE> *pSrchList);
    ~TEnumManagedList ();
    BOOL Next (T *ppItem);
    VOID Reset ();
private:
    TDoubleNode <T, KEYTYPE> *m_pCurrent;
    TManagedList<T, KEYTYPE> *m_pList;
    TSrchDoubleList<T, KEYTYPE> * m_pSrchList;
};


template <class T, class KEYTYPE> class TManagedList:
    public TRefCount
{
public:

#ifdef DBG
    virtual DWORD 
    IncRef () {
        DBGMSG (DBG_TRACE, ("TManagedList"));
        return TRefCount::IncRef();
    };
    
    virtual DWORD 
    DecRef () {    
        DBGMSG (DBG_TRACE, ("TManagedList"));
        return TRefCount::DecRef();
    }
#endif
    
    TManagedList ();
    virtual ~TManagedList ();

    BOOL 
    AppendItem (
        T &item);

    BOOL 
    FindItem (
        CONST KEYTYPE t,
        T &refItem);

    BOOL 
    FindItem (
        CONST T &t,
        T &refItem);

    BOOL 
    NewEnum (
        TEnumManagedList<T, KEYTYPE> **ppIterator);
    
    BOOL 
    Lock () {
        return m_CritSec.Lock ();
    } ;

    BOOL 
    Unlock () {
        return m_CritSec.Unlock ();
    };

    TCriticalSection* 
    GetCS(
        VOID) CONST {
        return (TCriticalSection*) &m_CritSec;
    };

    inline BOOL 
    bValid () CONST {
        return m_bValid;
    }

private:
    BOOL m_bValid;

    TSrchDoubleList<T, KEYTYPE> * m_pList;
    TCriticalSection m_CritSec;

};

#include "mglist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprport.h ===
/*****************************************************************************
 *
 * $Workfile: lprport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_LPRPORT_H
#define INC_LPRPORT_H

#include "rawport.h"
#include "LPRData.h"
#include "regabc.h"

class CLPRJob;
class CLPRInterface;


class CLPRPort : public CTcpPort
{
	// methods
public:
    CLPRPort();

    CLPRPort(LPTSTR		psztPortName,		// called through the UI port creation
             LPTSTR		psztHostAddress, 
			 LPTSTR		psztQueue,
			 DWORD		dPortNum,
             DWORD      dDoubleSpool,
			 DWORD		dSNMPEnabled,
			 LPTSTR		sztSNMPCommunity,
			 DWORD		dSNMPDevIndex,
			 CRegABC	*pRegistry,
             CPortMgr   *pPortMgr);
	
    CLPRPort(LPTSTR		psztPortName,		// called through the registry port creation
  			 LPTSTR 	psztHostName, 
	  		 LPTSTR 	psztIPAddr, 
		  	 LPTSTR 	psztHWAddr, 
			 LPTSTR     psztQueue,
		  	 DWORD  	dPortNum,
             DWORD      dDoubleSpool,
			 DWORD		dSNMPEnabled,
  			 LPTSTR		sztSNMPCommunity,
	  		 DWORD		dSNMPDevIndex,
			 CRegABC	*pRegistry,
             CPortMgr   *pPortMgr);

    DWORD   StartDoc(const LPTSTR psztPrinterName,
                     const DWORD  jobId,
                     const DWORD  level,
                     const LPBYTE pDocInfo);

	DWORD	SetRegistryEntry(LPCTSTR		psztPortName, 
							 const DWORD	dwProtocol, 
                             const DWORD	dwVersion, 
							 const LPBYTE   pData);

	LPTSTR  GetQueue()	{ return m_szQueue;  }

	DWORD	InitConfigPortUI( const DWORD	dwProtocolType, 
							const DWORD	dwVersion, 
							LPBYTE		pData);

private:	// methods
    DWORD   UpdateRegistryEntry(LPCTSTR psztPortName,
								DWORD	 dwProtocol, 
								DWORD	 dwVersion);	
	

private:	// attributes					
	TCHAR		m_szQueue[MAX_QUEUENAME_LEN];
    DWORD       m_dwDoubleSpool;
};


#endif // INC_LPRPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\port.h ===
/*****************************************************************************
 *
 * $Workfile: Port.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 ****************************************************************************
 *
 *	To ensure that we don't have threads crashing on configuration and deletion
 *	we keep track of the current refrences to the threads.
 *	
 *	Caution: be careful when making changes to refrences to m_pRealPort
 *
 *****************************************************************************/

#ifndef INC_PORT_H
#define INC_PORT_H

#include "portABC.h"
#include "portrefABC.h"
#include "mglist.h"
#include "devabc.h"

class CPortMgr;

enum PORTSTATE	{ CLEARED, INSTARTDOC };

#define MAX_SYNC_COUNT		10
#define SYNC_TIMEOUT		10000		// 10 s
#define MAX_SYNC_RETRIES    3

typedef class CPort* PCPORT;

class CPort : public CPortABC, public TRefNodeABC <PCPORT, LPTSTR>
{
	// methods
public:
	CPort( DWORD	dwProtocolType,
		   DWORD	dwVersion,
		   LPBYTE	pData,
		   CPortMgr *pParent,
		   CRegABC	*pRegistry);
    CPort( LPTSTR	psztPortName,
		   DWORD	dwProtocolType,
		   DWORD	dwVersion,
		   CPortMgr *pParent,
		   CRegABC	*pRegistry);

    DWORD Configure( DWORD	dwProtocolType,
					 DWORD	dwVersion,
					 LPTSTR	psztPortName,
					 LPBYTE	pData );


    BOOL operator==( CPort &newPort);
    BOOL operator==( const LPTSTR psztPortName);

    //
    // required for the list implementation
    //
    BOOL operator!=(const CPort &lhs) const;
    BOOL operator<(const CPort &lhs);
    BOOL operator>(const CPort &lhs) const;

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("%ws", m_szName));
        return TRefNodeABC <PCPORT, LPTSTR>::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("%ws", m_szName));
        return TRefNodeABC <PCPORT, LPTSTR>::DecRef();
    };
#endif

    INT Compare (PCPORT &k) {
        BOOL bDel;

        if (!IsPendingDeletion (bDel) || bDel) {
            return 1;
        }
        else
            return lstrcmpi (m_szName, k->m_szName);
    };

    INT Compare (LPTSTR &pszName) {
        BOOL bDel;

        if (!IsPendingDeletion (bDel) || bDel) {
            return 1;
        }
        else {
            return lstrcmpi (m_szName, pszName);
        }
    };

    BOOL PartialDelete (VOID) {
        BOOL bRet = TRUE;
        DWORD dwRet = DeleteRegistryEntry (m_szName);

        if (dwRet != ERROR_SUCCESS) {
            SetLastError (dwRet);
            bRet = FALSE;
        }

        return bRet;
    }


    DWORD	StartDoc    (const  LPTSTR psztPrinterName,
                         const  DWORD  jobId,
                         const  DWORD  level,
                         const  LPBYTE pDocInfo );
    DWORD	Write       (LPBYTE	 pBuffer,
                         DWORD	 cbBuf,
                         LPDWORD pcbWritten);
    DWORD   EndDoc();
    DWORD   GetInfo(DWORD   level,	
                    LPBYTE  &pPortBuf,
                    LPTCH  &pEnd);	
    DWORD   GetInfoSize	(DWORD level);
    DWORD   SetRegistryEntry(LPCTSTR psztPortName,
							 const  DWORD   dwProtocol,
                             const  DWORD   dwVersion,
                             const  LPBYTE pData );

	DWORD	DeleteRegistryEntry( LPTSTR psztPortName );

    DWORD   InitConfigPortUI(const  DWORD	dwProtocolType,
                             const  DWORD	dwVersion,
                                    LPBYTE  pConfigPortData);

    DWORD   SetDeviceStatus( );
    DWORD   ClearDeviceStatus();

    DWORD GetSNMPInfo(PSNMP_INFO pSnmpInfo);

    LPCTSTR	GetName();

    BOOL	ValidateRealPort();
    BOOL    Valid() { return m_bValid; }

    time_t  NextUpdateTime();

    BOOL    m_bDeleted;

    BOOL    m_bUsed;

    ~CPort();
private:	// methods
	DWORD	InitPortSem();
	BOOL	EndPortSem();
	DWORD	SetRealPortSem();
	DWORD	UnSetRealPortSem();
	DWORD	LockRealPort();
	DWORD	UnlockRealPort();
	

private:	// attributes
	TCHAR		m_szName[MAX_PORTNAME_LEN+1];			// port name
    BOOL        m_bValid;
    DWORD		m_dwProtocolType;		// indicates what type of printing protocol
    DWORD		m_dwVersion;			// version of the data being passed in to create the port

    CPortMgr	*m_pParent;			// points to the PortMgr object
    CPortRefABC	*m_pRealPort;		// points to the actual port object
	CRegABC		*m_pRegistry;		// points to the registry object

    PORTSTATE	m_iState;			// port state
    DWORD		m_dwLastError;		

	HANDLE		m_hPortSync;
};

#endif // INC_PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portabc.h ===
/*****************************************************************************
 *
 * $Workfile: portabc.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_PORTABC_H
#define INC_PORTABC_H

#ifndef	DllExport
#define	DllExport	__declspec(dllexport)
#endif

#include "devabc.h"
#include "regabc.h"

class DllExport CPortABC			
{
public:
	CPortABC() { };
	virtual	~CPortABC() { };

	virtual	DWORD	StartDoc	( const LPTSTR psztPrinterName,
								  const DWORD  jobId,
								  const DWORD  level,
								  const LPBYTE pDocInfo ) = 0;

	virtual DWORD	Read		( const HANDLE  handle,
								  LPBYTE  pBuffer,
							      const DWORD   cbBuffer,
								  LPDWORD pcbRead) {  return ( ERROR_INVALID_PARAMETER ); }

	virtual	DWORD	Write		( LPBYTE	 pBuffer,
								  DWORD	 cbBuf,
								  LPDWORD pcbWritten) = 0;
	virtual	DWORD	EndDoc() = 0;
	virtual LPCTSTR	GetName() = 0;
	virtual	DWORD	SetRegistryEntry( LPCTSTR		psztPortName,
									  const DWORD	dwProtocol,
									  const DWORD	dwVersion,
									  const LPBYTE  pData) = 0;
	virtual DWORD	InitConfigPortUI( const DWORD	dwProtocolType,
									  const DWORD	dwVersion,
									  LPBYTE		pConfigPortData) = 0;

	virtual DWORD	GetSNMPInfo( PSNMP_INFO pSnmpInfo) = 0;

	virtual DWORD	SetDeviceStatus( ) = 0;

    virtual DWORD   ClearDeviceStatus() = 0;

    virtual time_t  NextUpdateTime() = 0;
private:

};


#endif	// INC_PORTABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\port.cpp ===
/*****************************************************************************
 *
 * $Workfile: Port.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 ****************************************************************************
 *
 *  To ensure that we don't have threads crashing on configuration and deletion
 *  we keep track of the current refrences to the threads.
 *
 *  Caution: be careful when making changes to refrences to m_pRealPort
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "portmgr.h"
#include "port.h"
#include "rawtcp.h"
#include "lprifc.h"


///////////////////////////////////////////////////////////////////////////////
//  CPort::CPort()
//      Called by CPortMgr when creating a new port through the registry entry

CPort::
CPort(
    IN  LPTSTR      psztPortName,
    IN  DWORD       dwProtocolType,
    IN  DWORD       dwVersion,
    IN  CPortMgr    *pParent,
    IN  CRegABC     *pRegistry
    ) : m_dwProtocolType(dwProtocolType), m_dwVersion(dwVersion),
        m_pParent(pParent), m_pRealPort(NULL),
        m_iState(CLEARED), m_bValid(FALSE),
        m_hPortSync(NULL), m_pRegistry( pRegistry ),m_bUsed(FALSE),
        m_dwLastError(NO_ERROR)
{
    InitPortSem();

    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);

    switch ( m_dwProtocolType ) {

        case PROTOCOL_RAWTCP_TYPE: {
            CRawTcpInterface    *pPort = new CRawTcpInterface(m_pParent);

            if ( !pPort )
                return;

            m_bValid = ERROR_SUCCESS == pPort->CreatePort(psztPortName,
                                                          m_dwProtocolType,
                                                          m_dwVersion,
                                                          m_pRegistry,
                                                          &m_pRealPort);
            _ASSERTE(m_pRealPort != NULL);
            delete pPort;
            break;
        }

        case PROTOCOL_LPR_TYPE: {
            CLPRInterface   *pPort = new CLPRInterface(m_pParent);

            if ( !pPort )
                return;

            m_bValid = ERROR_SUCCESS == pPort->CreatePort(psztPortName,
                                                          m_dwProtocolType,
                                                          m_dwVersion,
                                                          m_pRegistry,
                                                          &m_pRealPort);
            _ASSERTE(m_pRealPort != NULL);
            delete pPort;
            break;
        }

        default:
            // Nothig to do, m_bValid is FALSE
            break;
    }
}   // ::CPort()


///////////////////////////////////////////////////////////////////////////////
//  CPort::CPort()
//      Called by CPortMgr when creating a new port through the UI

CPort::
CPort(
    IN  DWORD       dwProtocolType,
    IN  DWORD       dwVersion,
    IN  LPBYTE      pData,
    IN  CPortMgr    *pParent,
    IN  CRegABC     *pRegistry
    ) : m_dwProtocolType(dwProtocolType), m_dwVersion(dwVersion),
        m_pParent(pParent), m_pRealPort(NULL), m_iState(CLEARED),
        m_bValid(FALSE), m_hPortSync( NULL ),
        m_pRegistry( pRegistry ),m_bUsed(FALSE),
        m_dwLastError(NO_ERROR)
{
    InitPortSem();

    lstrcpyn(m_szName, ((PPORT_DATA_1)pData)->sztPortName, MAX_PORTNAME_LEN );

    switch (m_dwProtocolType) {

        case PROTOCOL_RAWTCP_TYPE: {

            CRawTcpInterface *pRawInterface = new CRawTcpInterface(m_pParent);
            if ( !pRawInterface ) {

                m_dwLastError = ERROR_OUTOFMEMORY;
            } else {

                pRawInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                          (PPORT_DATA_1)pData,
                                          pRegistry,
                                          &m_pRealPort);
                _ASSERTE(m_pRealPort != NULL);

                delete pRawInterface;
            }
            break;
        }

        case PROTOCOL_LPR_TYPE: {

            CLPRInterface *pLPRInterface = new CLPRInterface(m_pParent);

            if( !pLPRInterface ) {

                m_dwLastError = ERROR_OUTOFMEMORY;
            } else {

                pLPRInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                          (PPORT_DATA_1)pData,
                                          pRegistry,
                                          &m_pRealPort);
                _ASSERTE(m_pRealPort != NULL);

                delete pLPRInterface;
            }
            break;
        }
        default:
            break; // Nothing to do

    }
}   // ::CPort()


///////////////////////////////////////////////////////////////////////////////
//  CPort::~CPort()
//      Called by CPortMgr when deleting a port

CPort::
~CPort(
    VOID
    )
{

    _ASSERTE(m_dwRefCount == 0);

    if( m_hPortSync)
        CloseHandle( m_hPortSync );

    if ( m_pRealPort ) {
        m_pRealPort->DecRef();
        m_pRealPort = NULL;

    }
}   // ::~CPort

DWORD
CPort::Configure(
    DWORD   dwProtocolType,
    DWORD   dwVersion,
    LPTSTR  psztPortName,
    LPBYTE  pData
    )
{
    DWORD dwRetCode = NO_ERROR;

    m_bValid = FALSE;
    m_iState = CLEARED;


    m_dwProtocolType = dwProtocolType;
    m_dwVersion = dwVersion;

    dwRetCode = LockRealPort();
    if ( dwRetCode == NO_ERROR ) {

        if (m_pRealPort)
        {
            m_pRealPort->DecRef();
            m_pRealPort = NULL;
        }

        // For testing only
        //

        //MessageBox (NULL, _T("The real port has been deleted"), _T("Click OK to continue"), MB_OK);

        switch (dwProtocolType) {
            case PROTOCOL_RAWTCP_TYPE: {

                CRawTcpInterface *pRawInterface = new CRawTcpInterface(m_pParent);
                if ( !pRawInterface ) {

                    dwRetCode = ERROR_OUTOFMEMORY;
                } else {

                    pRawInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                              (PPORT_DATA_1)pData,
                                              m_pRegistry,
                                              &m_pRealPort);
                    _ASSERTE(m_pRealPort != NULL);

                    delete pRawInterface;
                }
                break;
            }

            case PROTOCOL_LPR_TYPE: {

                CLPRInterface *pLPRInterface = new CLPRInterface(m_pParent);
                if ( !pLPRInterface ) {

                    dwRetCode = ERROR_OUTOFMEMORY;
                } else {

                    pLPRInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                              (PPORT_DATA_1)pData,
                                              m_pRegistry,
                                              &m_pRealPort);
                    _ASSERTE(m_pRealPort != NULL);

                    delete pLPRInterface;
                }
                break;
            }

            default:
                break; // Nothing to do
        }

        if ( m_pRealPort != NULL ) {

            m_pParent->EnterCSection();

            dwRetCode = m_pRealPort->SetRegistryEntry(psztPortName,
                                                      m_dwProtocolType,
                                                      m_dwVersion, pData);

            m_pParent->ExitCSection();

            ClearDeviceStatus();
        }

        UnlockRealPort();

    }

    return ( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CPort::StartDoc( const LPTSTR in psztPrinterName,
                 const DWORD  in jobId,
                 const DWORD  in level,
                 const LPBYTE in pDocInfo)
{
    DWORD   dwRetCode = NO_ERROR;

    // serialize access to the port
    m_pParent->EnterCSection();
    if (m_iState == INSTARTDOC)
    {
        m_pParent->ExitCSection();
        return ERROR_BUSY;
    }
    m_iState = INSTARTDOC;
    m_pParent->ExitCSection();

    dwRetCode = SetRealPortSem();

    if (dwRetCode == NO_ERROR ) {

        dwRetCode = m_pRealPort->StartDoc(psztPrinterName,
                                          jobId,
                                          level,
                                          pDocInfo);

        if (dwRetCode != NO_ERROR)
        {
            m_pParent->EnterCSection();
            m_iState = CLEARED;         // start doc failed
            m_pParent->ExitCSection();

            UnSetRealPortSem();
        }
    }
    return (dwRetCode);

}   // ::StartDoc()


///////////////////////////////////////////////////////////////////////////////
//  Write
//      Error codes:
//          NO_ERROR if succesfull
//  FIX: complete Write processing & define how it relates to a job

DWORD
CPort::Write(   LPBYTE  in      pBuffer,
                DWORD   in      cbBuf,
                LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pRealPort->Write(pBuffer, cbBuf, pcbWritten);

    return(dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  EndDoc
//      Error codes:
//          NO_ERROR if succesfull

DWORD
CPort::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pRealPort->EndDoc();

    // serialize access to the port
    m_pParent->EnterCSection();
    m_iState = CLEARED;
    m_pParent->ExitCSection();

    UnSetRealPortSem();

    return(dwRetCode);

}   // ::EndDoc()


///////////////////////////////////////////////////////////////////////////////
//  GetInfo -- returns port info w/ the PORT_INFO_x information. It is assumed
//      that pPort points to a buffer large enough for port info. Each time it is
//      called, it adds the PORT_INFO structures at the beginning of the buffer, and
//      strings at the end.
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_INVALID_LEVEL if level is invalid
//          ERROR_INSUFFICIENT_BUFFER if pPortBuf is not big enough

DWORD
CPort::GetInfo( const DWORD   in    level,    // PORT_INFO_1/2
                      LPBYTE inout  &pPortBuf, // buffer to place the PORT_INFO_x struct
                      LPTCH  inout  &pEnd)    // pointer to end of the buffer where the
                                              // any strings should be placed
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_INFO_1    pInfo1 = (PPORT_INFO_1)pPortBuf;
    PPORT_INFO_2    pInfo2 = (PPORT_INFO_2)pPortBuf;
    TCHAR           szPortName[MAX_PORTNAME_LEN+1];

    lstrcpyn(szPortName, GetName(), MAX_PORTNAME_LEN);
    switch (level)
    {
        case 1:
            {
                pEnd -= _tcslen(szPortName) + 1;
                _tcscpy( (LPTSTR)pEnd, szPortName );
                pInfo1->pName = (LPTSTR)pEnd;

                ++pInfo1;
                pPortBuf = (LPBYTE) pInfo1;
            }
            break;

        case 2:
            pEnd -= ( _tcslen(PORTMONITOR_DESC) + 1 );
            _tcscpy( (LPTSTR)pEnd, PORTMONITOR_DESC );
            pInfo2->pDescription = (LPTSTR)pEnd;

            pEnd -= _tcslen(PORTMONITOR_NAME) + 1;
            _tcscpy((LPTSTR)pEnd, PORTMONITOR_NAME);
            pInfo2->pMonitorName = (LPTSTR)pEnd;

            pInfo2->fPortType = PORT_TYPE_READ | PORT_TYPE_WRITE;
    #ifdef WINNT
            // Don't mark ports as net attached for Windows 95, since this
            // will prevent them from being shared!!!!
            pInfo2->fPortType |= /*PORT_TYPE_REDIRECTED |*/ PORT_TYPE_NET_ATTACHED;
    #endif
            pEnd -= _tcslen(szPortName) + 1;
            _tcscpy((LPTSTR)pEnd, szPortName);
            pInfo2->pPortName = (LPTSTR)pEnd;

            ++pInfo2;
            pPortBuf = (LPBYTE) pInfo2;
            break;

        default:
            dwRetCode = ERROR_INVALID_LEVEL;
            break;
    }

    return (dwRetCode);

}   // ::GetInfo()


///////////////////////////////////////////////////////////////////////////////
//  GetInfoSize -- calculates the size of buffer needed for PORT_INFO_x struct.
//      Called by CPortMgr::EnumPorts()
//
//      Return:
//          # bytes needed for PORT_INFO_x struct
//  FIX: complete GetInfoSize processing

DWORD
CPort::GetInfoSize( const DWORD in level )
{
    DWORD   dwPortInfoSize = 0;
    TCHAR   sztPortName[MAX_PORTNAME_LEN+1];

    lstrcpyn( sztPortName, GetName(), MAX_PORTNAME_LEN );
    switch (level)
    {
        case 1:
            dwPortInfoSize = sizeof(PORT_INFO_1) + STRLENN_IN_BYTES(sztPortName);
            break;

        case 2:
            dwPortInfoSize = ( sizeof(PORT_INFO_2)  +
                    STRLENN_IN_BYTES(sztPortName) +
                    STRLENN_IN_BYTES(PORTMONITOR_NAME) +
                    STRLENN_IN_BYTES(PORTMONITOR_DESC) );
            break;
    }

    return (dwPortInfoSize);

}   // ::GetInfoSize()


///////////////////////////////////////////////////////////////////////////////
//  GetName

LPCTSTR
CPort::GetName()
{
    return (LPCTSTR) m_szName;
}   // ::GetName()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CPort::InitConfigPortUI( const DWORD    in  dwProtocolType,
                         const DWORD    in  dwVersion,
                         LPBYTE         out pConfigPortData)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->InitConfigPortUI(dwProtocolType, dwVersion, pConfigPortData);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::InitConfigPortUI()


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry -- writes the information to the register

DWORD
CPort::SetRegistryEntry( LPCTSTR      in    psztPortName,
                         const DWORD  in    dwProtocol,
                         const DWORD  in    dwVersion,
                         const LPBYTE in    pData )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->SetRegistryEntry(psztPortName, dwProtocol, dwVersion, pData);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::Register()

///////////////////////////////////////////////////////////////////////////////
//  DelRegistryEntry -- deletes the information to the register

DWORD
CPort::DeleteRegistryEntry( LPTSTR    in    psztPortName )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = LockRealPort();

    if( dwRetCode == NO_ERROR ) {
        if (! m_pRegistry->DeletePortEntry(psztPortName))
            dwRetCode = GetLastError ();
        UnlockRealPort();
    }

    return (dwRetCode);

}   // ::Register()

///////////////////////////////////////////////////////////////////////////////
//  operator== -- determines whether two ports are equal, or not.
//      Comparasions on the port name, and device mac address are done.
//      For the same type of printing protocol, there cannot be created more than
//      one port to the same device -- i.e. check MAC address, and ensure it prints
//      to a different port if it is an JetDirect Ex box.
//      Return:
//          TRUE if two ports are equal
//          FALSE if two ports are not equal
//      FIX: operator== function


BOOL
CPort::operator==(CPort &newPort )
{
    // compare the port name
    if (_tcscmp(this->GetName(), newPort.GetName()) == 0)
        return TRUE;        // port name matches

    return FALSE;

}   // ::operator==()


///////////////////////////////////////////////////////////////////////////////
//  operator== -- determines whether two port names are equal, or not.
//      Return:
//          TRUE if two port names are equal
//          FALSE if two port names are not equal
//      FIX: operator== function


BOOL
CPort::operator==( const LPTSTR psztPortName )
{
    if (_tcscmp(this->GetName(), psztPortName) == 0)
        return TRUE;        // port name matches

    return FALSE;

}   // ::operator==()

BOOL
CPort::ValidateRealPort()
{
    return (m_pRealPort != NULL);

}   //  ::ValidateRealPort()

///////////////////////////////////////////////////////////////////////////////
//  GetSNMPInfo --

DWORD
CPort::GetSNMPInfo( PSNMP_INFO pSnmpInfo)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->GetSNMPInfo(pSnmpInfo);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::InitConfigPortUI()

DWORD
CPort::SetDeviceStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    CPortRefABC *pRealPort;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        pRealPort = m_pRealPort;
        pRealPort->IncRef();
        UnSetRealPortSem();

        // For Testing only
        //
        // MessageBox (NULL, _T("I'm settting device status"), _T("Click OK to continue"), MB_OK);

        dwRetCode =  pRealPort->SetDeviceStatus();

        pRealPort->DecRef();
    }

    return (dwRetCode);
}

//
// Private Sync Fuctions
//

DWORD
CPort::InitPortSem()
{

    m_hPortSync = CreateSemaphore( NULL, MAX_SYNC_COUNT,
                                   MAX_SYNC_COUNT, NULL );
    if( m_hPortSync ==  NULL ) {
        return( GetLastError() );
    }

    return( NO_ERROR );
}

BOOL
CPort::EndPortSem()
{
    if( m_hPortSync != NULL ) {
        return( CloseHandle( m_hPortSync ));
    }
    return(FALSE);
}

DWORD
CPort::SetRealPortSem()
{
    LONG cRetry = 0;
    DWORD dwRetCode = NO_ERROR;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    do {
        dwRetCode = WaitForSingleObject( m_hPortSync, SYNC_TIMEOUT );

        if (dwRetCode == WAIT_FAILED ) {
            return( GetLastError());
        } else if (dwRetCode == WAIT_TIMEOUT ) {
            dwRetCode = ERROR_BUSY;
        } else {
            dwRetCode = NOERROR;
        }
        cRetry ++;
    } while( dwRetCode != NO_ERROR && cRetry < MAX_SYNC_RETRIES );

    return( NO_ERROR );
}

DWORD
CPort::UnSetRealPortSem()
{

    BOOL  bSemSet = FALSE;
    LONG cCur;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    bSemSet = ReleaseSemaphore( m_hPortSync, 1, &cCur );
    if( !bSemSet )
        return( GetLastError() );

    return( NO_ERROR );
}

DWORD
CPort::LockRealPort()
{
    DWORD dwRetCode = 0;
    LONG cLock = 0;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    while ( cLock < MAX_SYNC_COUNT ) {
        dwRetCode = WaitForSingleObject( m_hPortSync, SYNC_TIMEOUT );

        if (dwRetCode == WAIT_FAILED ) {
            ReleaseSemaphore( m_hPortSync, cLock, NULL );
            return( GetLastError());
        } else if (dwRetCode == WAIT_TIMEOUT ) {
            ReleaseSemaphore( m_hPortSync, cLock, NULL );
            return( ERROR_BUSY );
        }
        cLock++;
    }

    return( NO_ERROR );
}

DWORD
CPort::UnlockRealPort()
{

    BOOL  bSemSet = FALSE;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    bSemSet = ReleaseSemaphore( m_hPortSync, MAX_SYNC_COUNT, NULL );

    if( !bSemSet )
        return( GetLastError() );

    return( NO_ERROR );
}


DWORD
CPort::
ClearDeviceStatus(
    )
{
    return m_pRealPort->ClearDeviceStatus();
}


time_t
CPort::
NextUpdateTime(
    )
{
    time_t   dwRetCode = NO_ERROR;
    CPortRefABC *pRealPort;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        pRealPort = m_pRealPort;
        pRealPort->IncRef();
        UnSetRealPortSem();

        // For Testing only
        //
        // MessageBox (NULL, _T("I'm updating the status"), _T("Click OK to continue"), MB_OK);

        dwRetCode =  pRealPort->NextUpdateTime();

        pRealPort->DecRef();
    }

    return (dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portmgr.cpp ===
/****************************************************************************
 *
 * $Workfile: PortMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "port.h"
#include "devstat.h"
#include "portmgr.h"
#include "cluster.h"

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

CONST DWORD CPortMgr::cdwMaxXcvDataNameLen = 64;


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::CPortMgr()
//      Performs any needed initialization for the Port Manager

CPortMgr::
CPortMgr(
    VOID) :
    m_bValid (FALSE),
    m_bStatusUpdateEnabled( DEFAULT_STATUSUPDATE_ENABLED ),
    m_dStatusUpdateInterval( DEFAULT_STATUSUPDATE_INTERVAL ),
    m_pPortList(NULL)

{
    //
    // initialize member variables
    //
    *m_szServerName = TEXT('\0');
    memset(&m_monitorEx, 0, sizeof(m_monitorEx));

    CDeviceStatus::gDeviceStatus().RegisterPortMgr(this);

    if (m_pPortList = new TManagedListImp ()) {
        m_bValid = TRUE;
    }

}   // ::CPortMgr()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::~CPortMgr()
//      Performs the necessary clean up for the Port Manager

CPortMgr::
~CPortMgr(
    VOID
    )
{
    CDeviceStatus::gDeviceStatus().UnregisterPortMgr(this);

    if (m_pPortList) {
        m_pPortList->DecRef ();
    }

}   // ::~CPortMgr()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::InitializeMonitor()
//      Initializes the Port Manager:
//              1. Check for TCP/IP support
//              2. Initialize CRegistry and fill in LPMONITOREX structure
//              4. Enumerate installed ports
//              5. Start up a thread for the printer status object
//      Error codes:
//          ERROR_INVALID_PARAMETER if pMonitorEx is NULL
//          ERROR_NOT_SUPPORTED if TCP/IP not installed in the system -- FIX!

DWORD
CPortMgr::
InitializeMonitor(
//    IN      LPTSTR          psztRegisterRoot,
//    IN OUT  LPMONITOREX    *ppMonitorEx
    )
{
    DWORD   dwRetCode = NO_ERROR;
    OSVERSIONINFO   osVersionInfo;

//    if ( !ppMonitorEx   || !psztRegisterRoot )
//        return ERROR_INVALID_PARAMETER;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetVersionEx(&osVersionInfo) )
        return GetLastError();

    //
    // Check for TCP/IP support
    //
    if ( dwRetCode = EnumSystemProtocols() )
        return dwRetCode;

    //
    // Enumerate the installed ports
    //
    if ( dwRetCode = EnumSystemPorts() )
        return dwRetCode;

    return ERROR_SUCCESS;

}   // ::Initialize()


DWORD
CPortMgr::
InitializeRegistry(
    IN HANDLE hcKey,
    IN HANDLE hSpooler,
    IN PMONITORREG  pMonitorReg,
    IN LPCTSTR  pszServerName
    )
{
    DWORD dwRetCode = NO_ERROR;

    m_pRegistry = new CCluster(hcKey, hSpooler, pMonitorReg);
    if ( !m_pRegistry ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }

    //
    // get the registry settings
    //
    if ( m_pRegistry->GetPortMgrSettings(&m_dStatusUpdateInterval,
                                         &m_bStatusUpdateEnabled) != NO_ERROR )
    {
        m_dStatusUpdateInterval = DEFAULT_STATUSUPDATE_INTERVAL;
        m_bStatusUpdateEnabled = DEFAULT_STATUSUPDATE_ENABLED;
    }
    if( pszServerName != NULL )
    {
        lstrcpyn( m_szServerName, pszServerName, SIZEOF_IN_CHAR( m_szServerName));
    }

    return ERROR_SUCCESS;

}   // ::InitializeRegistry()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::InitMonitor()
//      Initializes the MONITOREX strucutre

void
CPortMgr::
InitMonitor2(
        IN OUT LPMONITOR2   *ppMonitor2
    )
{
    memset( &m_monitor2, '\0', sizeof( MONITOR2 ) );

    m_monitor2.cbSize = sizeof(MONITOR2);

    m_monitor2.pfnEnumPorts     = ::ClusterEnumPorts;   // functions are in the global space
    m_monitor2.pfnOpenPort      = ::ClusterOpenPort;
    m_monitor2.pfnOpenPortEx    = NULL;
    m_monitor2.pfnStartDocPort  = ::StartDocPort;
    m_monitor2.pfnWritePort     = ::WritePort;
    m_monitor2.pfnReadPort      = ::ReadPort;
    m_monitor2.pfnEndDocPort    = ::EndDocPort;
    m_monitor2.pfnClosePort     = ::ClosePort;
    m_monitor2.pfnAddPort       = NULL;
    m_monitor2.pfnAddPortEx     = NULL;
    m_monitor2.pfnConfigurePort = NULL;
    m_monitor2.pfnDeletePort    = NULL;
    m_monitor2.pfnGetPrinterDataFromPort = NULL;
    m_monitor2.pfnSetPortTimeOuts = NULL;
    m_monitor2.pfnXcvOpenPort   = ::ClusterXcvOpenPort;
    m_monitor2.pfnXcvDataPort   = ::XcvDataPort;
    m_monitor2.pfnXcvClosePort  = ::XcvClosePort;
    m_monitor2.pfnShutdown      = ::ClusterShutdown;

    *ppMonitor2 = &m_monitor2;

}   // ::InitMonitor2()


///////////////////////////////////////////////////////////////////////////////
//  OpenPort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_PARAMETER if port object doesn't exist
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//          ERROR_INVALID_HANDLE if pPort is null

DWORD
CPortMgr::
OpenPort(
    IN      LPCTSTR     psztPName,
    IN OUT  PHANDLE     pHandle
    )
{
    DWORD   dwRet = ERROR_INVALID_PARAMETER;

    //
    // Get a handle to the port object and get the port handle
    //
    CPort   *pPort = FindPort(psztPName);

    if ( pPort ) {

        dwRet = EncodeHandle(pPort, pHandle);

        //
        // Start the device status update thread if it is not already started:
        //
        if ( dwRet == ERROR_SUCCESS && m_bStatusUpdateEnabled == TRUE )
            CDeviceStatus::gDeviceStatus().RunThread();
    }

    return dwRet;
}   // ::OpenPort()


///////////////////////////////////////////////////////////////////////////////
//  OpenPort -- used for the remote OpenPort calls
//  Error codes:
//      NO_ERROR if success
//      ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
CPortMgr::
OpenPort(
    OUT PHANDLE phXcv
    )
{
    //
    // Create Dummy Handle for add port
    //
    return EncodeHandle(NULL, phXcv);

}   // ::OpenPort()


///////////////////////////////////////////////////////////////////////////////
//  ClosePort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid

DWORD
CPortMgr::
ClosePort(
    IN  HANDLE handle
    )
{
    DWORD dwRetCode = NO_ERROR;
    CPort *pPort = NULL;

    //
    // Validate the handle before freeing it
    //
    if ( (dwRetCode = ValidateHandle(handle, &pPort)) == ERROR_SUCCESS ) {
        if (pPort)
            pPort->DecRef ();

        dwRetCode = FreeHandle(handle);
    }

    return dwRetCode;

}   // ::ClosePort()


///////////////////////////////////////////////////////////////////////////////
//  StartDocPort --
//  Error codes:
//      NO_ERROR if success
//      ERROR_INVALID_HANDLE if handle is invalid
//      ERROR_INVALID_PARAMETER if a passed parameter is invalid
//      ERROR_BUSY if the requested port is already busy
//      ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//      ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CPortMgr::
StartDocPort(
    IN  HANDLE      handle,
    IN  LPTSTR      psztPrinterName,
    IN  DWORD       jobId,
    IN  DWORD       level,
    IN  LPBYTE      pDocInfo
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    //
    // Validate the handle
    //
    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;


    if ( !pPort || !psztPrinterName || !pDocInfo )
        return ERROR_INVALID_PARAMETER;

    return pPort->StartDoc(psztPrinterName, jobId, level,
                           pDocInfo);
}   // ::StartDocPort()


///////////////////////////////////////////////////////////////////////////////
//  WritePort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid
//          ERROR_INVALID_PARAMETER if a passed parameter is invalid

DWORD
CPortMgr::
WritePort(
    IN      HANDLE      handle,
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;

    if ( !pPort || !pBuffer || !pcbWritten )
        return ERROR_INVALID_PARAMETER;;

    return pPort->Write(pBuffer, cbBuf, pcbWritten);
}   // ::WritePort()


///////////////////////////////////////////////////////////////////////////////
//  ReadPort -- Not supported
//      Return code:
//          NO_ERROR if success
//      FIX: should this return ERROR_NOT_SUPPORTED??

DWORD
CPortMgr::
ReadPort(
    IN      HANDLE  handle,
    IN OUT  LPBYTE  pBuffer,
    IN      DWORD   cbBuffer,
    IN OUT  LPDWORD pcbRead
    )
{
    return ERROR_NOT_SUPPORTED;
}   // ::ReadPort()


///////////////////////////////////////////////////////////////////////////////
//  EndDocPort
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid
//          ERROR_INVALID_PARAMETER if port object is invalid

DWORD
CPortMgr::
EndDocPort(
    IN  HANDLE  handle
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;

    return pPort ? pPort->EndDoc() : ERROR_INVALID_PARAMETER;
}   // ::EndDocPort()


///////////////////////////////////////////////////////////////////////////////
//  EnumPorts
//      Enumerates the ports using the port list structure kept in the memory
//      If the buffer size needed is not enough, it will return the buffer
//      size needed.
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_LEVEL if level is not supported
//          ERROR_INSUFFICIENT_BUFFER if buffer size is small
//          ERROR_INVALID_HANDLE if the passed in pointers are invalid

DWORD
CPortMgr::
EnumPorts(
    IN      LPTSTR  psztName,
    IN      DWORD   level,          // 1/2(PORT_INFO_1/2)
    IN OUT  LPBYTE  pPorts,         // port data is written to
    IN OUT  DWORD   cbBuf,          // buffer size of pPorts points to
    IN OUT  LPDWORD pcbNeeded,      // needed buffer size
    IN OUT  LPDWORD pcReturned      // number of structs written to pPorts
    )
{
    DWORD   dwRetCode = NO_ERROR;
    LPBYTE  pPortsBuf = pPorts;
    LPTCH   pEnd = (LPTCH) (pPorts + cbBuf);    // points to the end of the buffer

    if ( pcbNeeded == NULL || pcReturned == NULL )
        return ERROR_INVALID_PARAMETER;

    *pcbNeeded  = 0;
    *pcReturned = 0;

    if ( level > SPOOLER_SUPPORTED_LEVEL )
        return ERROR_INVALID_LEVEL;

    CPort *pPort;

    if (m_pPortList->Lock ()) {
        // We don't need to enter critical section to enumerate port since the portlist itself
        // is protected by the same critical section, but it is easier.

        TEnumManagedListImp *pEnum;
        if (m_pPortList->NewEnum (&pEnum)) {

            BOOL bRet = TRUE;

            while (bRet) {

                bRet = pEnum->Next (&pPort);
                if (bRet) {
                    *pcbNeeded += pPort->GetInfoSize(level);
                    pPort->DecRef ();
                }
            }


            if ( cbBuf >= *pcbNeeded ) {

                pEnum->Reset ();

                //
                // fill in the actual buffer
                //
                bRet = TRUE;
                while (bRet) {
                    bRet = pEnum->Next (&pPort);
                    if (bRet) {
                        *pcbNeeded += pPort->GetInfo(level, pPortsBuf, pEnd);
                        (*pcReturned)++;
                        pPort->DecRef ();
                    }
                }

            }
            else {
                dwRetCode = ERROR_INSUFFICIENT_BUFFER;
            }

            pEnum->DecRef ();
        }
        else
            dwRetCode = GetLastError ();
    }
    m_pPortList->Unlock ();


    return dwRetCode;
}   // ::EnumPorts()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortStruct
//
//  Purpose: To initialize a structure to hand to the User Interface so
//      the user can configure the port information.
//
//  Arguments: A pointer to the structure to be filled.
//
DWORD
CPortMgr::
InitConfigPortStruct(
    OUT PPORT_DATA_1    pConfigPortData,
    IN  CPort          *pPort
    )
{
    DWORD   dwProtocolType = PROTOCOL_RAWTCP_TYPE;
    DWORD   dwVersion   = PROTOCOL_RAWTCP_VERSION, dwRet;

    //
    // initialize the structure needed to communicate w/ the UI
    //
    memset(pConfigPortData, 0, sizeof(PORT_DATA_1));

    pConfigPortData->cbSize = sizeof(PORT_DATA_1);

    //pConfigPortData->dwCoreUIVersion = 0;

    dwRet = pPort->InitConfigPortUI(
                          dwProtocolType,
                          dwVersion,
                          (LPBYTE)pConfigPortData);


    return dwRet;

} // InitConfigPortStruct

///////////////////////////////////////////////////////////////////////////////
//  ConfigPortUIEx
//      Return code:
//          NO_ERROR if success
//      FIX: error codes
//      This function is called by the ui when information has been changed
//      on the device configuration page, or in an extension dll config page.

DWORD
CPortMgr::
ConfigPortUIEx(
    LPBYTE pData
    )
{
    DWORD dwRetCode = NO_ERROR;
    PPORT_DATA_1 pPortData = (PPORT_DATA_1)pData;
    CPort *pPort;

    EndPortData1Strings(pPortData);

    if( _tcscmp( pPortData->sztPortName, TEXT("") )) {
        pPort = FindPort(pPortData->sztPortName);
        if ( pPort ==  NULL )
            return ERROR_INVALID_PARAMETER;

        dwRetCode = pPort->Configure(pPortData->dwProtocol,
                                pPortData->dwVersion,
                                pPortData->sztPortName,
                                (LPBYTE)pData);
    }

    return dwRetCode;
} // ConfigPortUIEx

///////////////////////////////////////////////////////////////////////////////
//  DeletePort
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_PARAMETER if a passed parameter is invalid
//          ERROR_KEY_DELETED   if error deleting the registry entry

DWORD
CPortMgr::
DeletePort(
    IN  LPTSTR  psztPortName
    )
{
    DWORD       dwRetCode = NO_ERROR;
    BOOL        bFound = FALSE;

    CPort *pPort;

    if (m_pPortList->FindItem (psztPortName, pPort)) {

        bFound = TRUE;

        if (!pPort->Delete()) {
            if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                dwRetCode = ERROR_KEY_DELETED;
        }
        pPort-> DecRef ();
    }

    return bFound ? dwRetCode : ERROR_UNKNOWN_PORT;
}   // ::DeletePort()


DWORD
CPortMgr::
AddPortToList(
    CPort *pPort
    )
{

    if (m_pPortList->AppendItem (pPort)) {
        return ERROR_SUCCESS;
    }
    else {
        pPort->Delete();
        return ERROR_OUTOFMEMORY;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  CreatePortObj -- creates the port obj & adds it to the end of the port list
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePortObj(
    IN  LPCTSTR     psztPortName,       // port name
    IN  DWORD       dwPortType,         // port to be add; (rawTCP, lpr, etc.)
    IN  DWORD       dwVersion,          // level/version number of the data
    IN  LPBYTE      pData               // data being passed in
    )               // data being passed in
{
    CPort      *pPort = NULL;
    DWORD       dwRetCode = NO_ERROR;

    //
    // Is there port with this name already present?
    //
    if ( pPort =  FindPort(psztPortName) ) {
        pPort->DecRef ();
        return ERROR_INVALID_PARAMETER;
    }


    if ( !(pPort = new CPort(dwPortType, dwVersion, pData,
                             this, m_pRegistry)) ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }

    if ( !pPort->ValidateRealPort() ) {

        pPort->Delete();

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;

        return dwRetCode;
    }

    if ( dwRetCode = AddPortToList(pPort) )
        return dwRetCode;

    return ERROR_SUCCESS;
}   // ::CreatePortObj()


///////////////////////////////////////////////////////////////////////////////
//  CreatePortObj -- creates the port obj & adds it to the end of the port list
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePortObj(
    IN  LPTSTR      psztPortName,   // port name
    IN  DWORD       dwProtocolType, // port to be add; (rawTCP, lpr, etc.)
    IN  DWORD       dwVersion       // level/version number of the data
    )
{
    CPort   *pPort = NULL;
    DWORD   dwRetCode = NO_ERROR;

    if ( !(pPort = new CPort(psztPortName, dwProtocolType, dwVersion,
                             this, m_pRegistry)) ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }


    if ( !pPort->ValidateRealPort() ) {

        pPort->Delete ();

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }

    if ( FindPort(pPort) ) {

        _ASSERTE(pPort == NULL); // How could we hit this? -- MuhuntS

        pPort->Delete();
        pPort->DecRef ();

        return ERROR_INVALID_PARAMETER;
    }


    //
    // Now we have a unique port, add it to the list
    //
    if ( dwRetCode = AddPortToList(pPort) )
        return dwRetCode;

    return ERROR_SUCCESS;

}   // ::CreatePortObj()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort -- creates a port & adds it to the end of the port list & sets
//      the registry entry for that port
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePort(
    IN  DWORD       dwPortType,         // port type to be created; i.e. protocol type
    IN  DWORD       dwVersion,          // version/level number of the data passed in
    IN  LPCTSTR     psztPortName,       // port name
    IN  LPBYTE      pData
    )
{
    DWORD   dwRetCode = NO_ERROR;

    // This is the place where new ports are create via the UI.


    dwRetCode = PortExists(psztPortName );

    if( dwRetCode == NO_ERROR )
    {
        EnterCSection();

        dwRetCode = CreatePortObj( psztPortName, dwPortType, dwVersion, pData);

        ExitCSection();
    }
    return dwRetCode;

}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  ValidateHandle -- Checks to see if the handle is for an HP Port
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
CPortMgr::
ValidateHandle(
    IN      HANDLE      handle,
    IN OUT  CPort     **ppPort
    )
{
    PHPPORT pHPPort = (PHPPORT) handle;
    DWORD   dwRetCode = NO_ERROR;

    if ( ppPort )  {

        *ppPort = NULL;
        //
        // verify the port handle & the signature
        //
        if ( pHPPort                                    &&
             pHPPort->dSignature == HPPORT_SIGNATURE ) {

            //
            // Note if pHPPort->pPort being NULL is
            // XcvOpenPort for generic Add case (and is still success)
            //
            if ( pHPPort->pPort )
                *ppPort = pHPPort->pPort;
        } else {

            dwRetCode = ERROR_INVALID_HANDLE;
        }
    } else  {

        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return dwRetCode;
}   // ::ValidateHandle()



///////////////////////////////////////////////////////////////////////////////
//  FindPort -- finds a port given a port name (FIX)
//      Return:
//          pointer to CPort object or HANDLE to CPort object if success
//          NULL if port is not found
//      FIX: how to handle this

CPort *
CPortMgr::
FindPort(
    IN  LPCTSTR psztPortName
    )
{
    CPort      *pPort = NULL;

    if (m_pPortList->FindItem ((LPTSTR) psztPortName, pPort)) {
        return pPort;
    }
    else
        return NULL;

}   // ::FindPort()


///////////////////////////////////////////////////////////////////////////////
//  FindPort -- finds a port given a port object or port HANDLE? (FIX)
//      Return:
//          TRUE if port exists
//          FALSE if port !exists


BOOL
CPortMgr::
FindPort(
    IN  CPort   *pNewPort
    )
{
    CPort      *pPort = NULL;

    if (m_pPortList->FindItem (pNewPort, pPort)) {
        pPort->DecRef ();
        return TRUE;
    }
    else
        return FALSE;

}   // ::FindPort()



///////////////////////////////////////////////////////////////////////////////
//  EnumSystemProtocols
//      Enumerates the system protocols using WSAEnumProtocols or EnumProtocols
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_SUPPORTED if TCP/IP networking is not supported
//      FIX: how to handle this

DWORD
CPortMgr::
EnumSystemProtocols(
    VOID
    )
{
    DWORD dwRetCode = NO_ERROR;

    // call WSAEnumProtocols or EnumProtocols
    // if TCP protocol ! available, return ERROR_NOT_SUPPORTED

    return dwRetCode;
}   // ::EnumSystemProtocols()


///////////////////////////////////////////////////////////////////////////////
//  EnumSystemPorts
//      Enumerates the installed ports in the system using the registry
//      Error codes:
//          NO_ERROR if success
//          FIX: Error codes

DWORD
CPortMgr::
EnumSystemPorts(
    VOID
    )
{
    DWORD dwRetCode = NO_ERROR;

    EnterCSection();
    dwRetCode = m_pRegistry->EnumeratePorts( this );
    ExitCSection();

    return dwRetCode;

}   // ::EnumSystemPorts()

///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

VOID
CPortMgr::
EnterCSection()
{
    m_pPortList->Lock ();
    //EnterCriticalSection(&m_critSect);

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

VOID
CPortMgr::
ExitCSection()
{
    m_pPortList->Unlock ();

    //_ASSERTE(m_critSect.OwningThread == (LPVOID)GetCurrentThreadId());

    //LeaveCriticalSection(&m_critSect);

}   //  ::ExitCSection()

///////////////////////////////////////////////////////////////////////////////
//  XcvOpenPort -- used for remote port administration
//  Error Codes:
//          NO_ERROR if success
//          ERROR_NOT_SUPPORTED if port object doesn't exist
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//          ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

DWORD
CPortMgr::
XcvOpenPort(
    IN  LPCTSTR         pszObject,
    IN  ACCESS_MASK     GrantedAccess,
    OUT PHANDLE         phXcv)
{
    DWORD   dwRetCode = NO_ERROR;

    if ( !pszObject || !*pszObject ) {

        //
        // A generic session to the monitor is being opened for AddPort.
        // create a new handle and return it.
        //
        dwRetCode = OpenPort(phXcv);
    } else if( _tcscmp(pszObject, PORTMONITOR_DESC ) == 0) {

        //
        // A generic session to the monitor is being opened for AddPort.
        // create a new handle and return it.
        //
        dwRetCode = OpenPort(phXcv);
    } else if ( pszObject != NULL ) {

        //
        // A specific port is being requested for configure or delete
        // and the port was found by the call to OpenPort.
        //
        dwRetCode = OpenPort( pszObject, phXcv);
    }

    if ( dwRetCode == NOERROR )
    {
        ((PHPPORT)(*phXcv))->grantedAccess = GrantedAccess;
        ((PHPPORT)(*phXcv))->pPortMgr = this;
    }


    return dwRetCode;
} // ::XcvOpenPort()


///////////////////////////////////////////////////////////////////////////////
//  XcvClosePort --
//  Error codes:
//      NO_ERROR if success
//      ERROR_INVALID_HANDLE if handle is invalid

DWORD
CPortMgr::
XcvClosePort(
    IN  HANDLE  hXcv
    )
{
    return ClosePort(hXcv);
} // ::XcvClosePort()


///////////////////////////////////////////////////////////////////////////////
//  XcvDataPort -- remote port management function
//  Error Codes:
//      NO_ERROR if success
//      ERROR_INVALID_DATA if the Input data is missing
//      ERROR_BAD_COMMAND if the pszDataName is not supported
//      ERROR_INSUFFICIENT_BUFFER if buffer size is invalid
//      ACCESS_DENIED if doesn't have sufficient rights
//      ERROR_INVALID_HANDLE if the handle is invalid

DWORD
CPortMgr::
XcvDataPort(
    IN  HANDLE      hXcv,
    IN  PCWSTR      pszDataName,
    IN  PBYTE       pInputData,
    IN  DWORD       cbInputData,
    IN  PBYTE       pOutputData,
    IN  DWORD       cbOutputData,
    OUT PDWORD      pcbOutputNeeded
    )
{
    DWORD   dwSize;
    DWORD   dwRetCode = NO_ERROR;
    CPort  *pPort;

    if ( (dwRetCode = ValidateHandle(hXcv, &pPort)) != ERROR_SUCCESS )
        return dwRetCode;

    // Valid input parameters

    if ((pszDataName && IsBadStringPtr (pszDataName, sizeof (TCHAR) * cdwMaxXcvDataNameLen)) ||

        (pInputData && cbInputData && IsBadReadPtr (pInputData, cbInputData)) ||

        (pOutputData && cbOutputData && IsBadWritePtr (pOutputData, cbOutputData)) ||

        (pcbOutputNeeded && IsBadWritePtr (pcbOutputNeeded, sizeof (DWORD)))) {

        return  ERROR_INVALID_PARAMETER;
    }


    PHPPORT pHpPort = (PHPPORT)hXcv;

    // We have a valid handle, check the validity of the passed parameters

    if ( pszDataName == NULL ) {
        dwRetCode = ERROR_INVALID_PARAMETER;
    } else

    if ( _tcscmp(pszDataName, TEXT("AddPort")) == 0 ) {

        if ( !HasAdminAccess(hXcv) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData < sizeof(PORT_DATA_1)) {

            dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((PPORT_DATA_1)pInputData)->dwVersion != 1 ) {
          dwRetCode = ERROR_INVALID_LEVEL;

        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                EndPortData1Strings((PPORT_DATA_1)pInputData);

                dwRetCode = CreatePort(((PPORT_DATA_1)pInputData)->dwProtocol,
                                   ((PPORT_DATA_1)pInputData)->dwVersion,
                                   ((PPORT_DATA_1)pInputData)->sztPortName,
                                   pInputData);

                ImpersonatePrinterClient( hPrintAccess );

            } else {

                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if ( _tcscmp(pszDataName, TEXT("DeletePort")) == 0 )  {

        if ( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData != sizeof (DELETE_PORT_DATA_1)) {
                    dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((DELETE_PORT_DATA_1 *)pInputData)->dwVersion != 1 ) {

            dwRetCode = ERROR_INVALID_LEVEL;
        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                EndDeletePortData1Strings((DELETE_PORT_DATA_1 *)pInputData);

                dwRetCode = DeletePort(((DELETE_PORT_DATA_1 *)pInputData)
                                                        ->psztPortName);
                ImpersonatePrinterClient( hPrintAccess );
            } else {
                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("MonitorUI")) == 0 ) {

        if( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else {
            dwSize = sizeof(PORTMONITOR_UI_NAME);

            //
            // This returns the name of the UI DLL "tcpmonui.dll"
            //
            if ( cbOutputData < dwSize ) {
                if (pcbOutputNeeded == NULL) {

                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    _tcscpy((TCHAR *)pOutputData, PORTMONITOR_UI_NAME);
                    dwRetCode = NO_ERROR;
                }
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("ConfigPort")) == 0 ) {

        if( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData < sizeof(PORT_DATA_1) ) {

            dwRetCode = ERROR_INVALID_DATA;

        } else if ( ((PPORT_DATA_1)pInputData)->dwVersion != 1 ) {

            dwRetCode = ERROR_INVALID_LEVEL;
        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                dwRetCode = ConfigPortUIEx( pInputData );  // This terminates strings internally

                ImpersonatePrinterClient( hPrintAccess );

            } else {
                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("GetConfigInfo")) == 0 ) {

        dwSize = sizeof( PORT_DATA_1 );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }
        } else if ( pInputData == NULL || cbInputData < sizeof(CONFIG_INFO_DATA_1) ) {
            dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((CONFIG_INFO_DATA_1 *)pInputData)->dwVersion != 1 ) {
            dwRetCode = ERROR_INVALID_LEVEL;
        } else if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                InitConfigPortStruct((PPORT_DATA_1) pOutputData, pHpPort->pPort);
                dwRetCode = NO_ERROR;
            }
        }
    } else if(_tcsicmp(pszDataName, TEXT("SNMPEnabled")) == 0)  {

        SNMP_INFO snmpInfo;

        dwSize = sizeof( DWORD );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }

        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else if (!pHpPort->pPort) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                pHpPort->pPort->GetSNMPInfo( &snmpInfo);
                memcpy( (TCHAR *)pOutputData, &snmpInfo.dwSNMPEnabled, dwSize );
                dwRetCode = NO_ERROR;
            }
        }
    } else if ( _tcsicmp(pszDataName, TEXT("IPAddress")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {

            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztAddress ) + 1) * sizeof( TCHAR )) ;
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztAddress, dwSize );
                    dwRetCode = NO_ERROR;
                }
            }
        }

    } else if ( _tcsicmp(pszDataName, TEXT("HostAddress")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {
            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztAddress ) + 1) * sizeof( TCHAR )) ;
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztAddress, dwSize );
                    dwRetCode = NO_ERROR;
                }
            }
        }

    } else if ( _tcsicmp(pszDataName, TEXT("SNMPCommunity")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {
            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztSNMPCommunity ) + 1 ) * sizeof( TCHAR ));
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {

                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztSNMPCommunity, dwSize );
                    dwRetCode = NO_ERROR;
                }
           }
        }
    } else if( _tcsicmp(pszDataName, TEXT("SNMPDeviceIndex")) == 0 )  {

        SNMP_INFO snmpInfo;

        dwSize= sizeof( DWORD );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            }
            else if (!pHpPort->pPort) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                pHpPort->pPort->GetSNMPInfo( &snmpInfo);
                memcpy( (TCHAR *)pOutputData, &snmpInfo.dwSNMPDeviceIndex, dwSize );
                dwRetCode = NO_ERROR;
            }
        }
    } else {

        dwRetCode = ERROR_INVALID_PARAMETER;
    }

    return dwRetCode;

} // ::XcvDataPort()

 ///////////////////////////////////////////////////////////////////////////////
//  EndPortData1Strings -- Ensures that all of the PPORT_DATA_1 strings passed
//                      -- in are NULL Terminated

void CPortMgr::EndPortData1Strings(PPORT_DATA_1 pPortData) {
    pPortData->sztPortName[MAX_PORTNAME_LEN - 1]                = NULL;
    pPortData->sztHostAddress[MAX_NETWORKNAME_LEN - 1]          = NULL;
    pPortData->sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN - 1] = NULL;
    pPortData->sztQueue[MAX_QUEUENAME_LEN - 1]                  = NULL;
    pPortData->sztIPAddress[MAX_IPADDR_STR_LEN - 1]             = NULL;
    pPortData->sztDeviceType[MAX_DEVICEDESCRIPTION_STR_LEN - 1] = NULL;
}

 ///////////////////////////////////////////////////////////////////////////////
//  EndDeletePortData1Strings -- Ensures that all of the PPORT_DATA_1 strings passed
//                            -- in are NULL Terminated
void CPortMgr::EndDeletePortData1Strings(PDELETE_PORT_DATA_1 pDeleteData) {
    pDeleteData->psztName[SIZEOF_IN_CHAR(pDeleteData->psztPortName) - 1]        = NULL;
    pDeleteData->psztPortName[SIZEOF_IN_CHAR(pDeleteData->psztPortName) - 1] = NULL;
}

///////////////////////////////////////////////////////////////////////////////
//  EncodeHandle -- Encodes the HPPORT handle
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
CPortMgr::
EncodeHandle(
    CPort *pPort,
    PHANDLE phXcv
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PHPPORT pHPPort = NULL;

    size_t size = sizeof(HPPORT);
    if ( pHPPort = (PHPPORT) LocalAlloc( LPTR, sizeof(HPPORT) ) ) {

        pHPPort->cb = sizeof(HPPORT);
        pHPPort->dSignature = HPPORT_SIGNATURE;
        pHPPort->grantedAccess = SERVER_ACCESS_ADMINISTER;
        pHPPort->pPort = pPort;
        pHPPort->pPortMgr = this;

        *phXcv = pHPPort;
    }  else {

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRetCode;
}   // ::EncodeHandle()

///////////////////////////////////////////////////////////////////////////////
//  FreeHandle -- Frees the HPPORT handle
//      Error codes:
//          NO_ERROR if success

DWORD
CPortMgr::
FreeHandle(
    HANDLE hXcv
    )
{
    DWORD   dwRetCode = NO_ERROR;

    LocalFree( hXcv );

    return( dwRetCode );
}   // ::FreeHandle()


BOOL
CPortMgr::
HasAdminAccess(
    HANDLE hXcv
    )
{
    return ((((PHPPORT)hXcv)->grantedAccess & SERVER_ACCESS_ADMINISTER) != 0);
}

//
// Function - PortExists()
//
// returns - true when the port exists false otherwise
//
//
DWORD
CPortMgr::
PortExists(
    IN  LPCTSTR psztPortName
    )
{
    DWORD dwRetCode = NO_ERROR;

    PORT_INFO_1 *pi1 = NULL;
    DWORD pcbNeeded = 0;
    DWORD pcReturned = 0;
    BOOL res;

    // Should never happen but well be safe
    if( g_pfnEnumPorts == NULL )
    {
        return( TRUE );
    }

    // Get the required buffer size
    res = g_pfnEnumPorts((m_szServerName[0] == TEXT('\0')) ? NULL : m_szServerName,
        1,
        (LPBYTE)pi1,
        0,
        &pcbNeeded,
        &pcReturned
        );
    // Alloc the space for the port list and check to make sure that
    // this port does not already exist.

    while(dwRetCode == NO_ERROR &&
          res == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {

        if(pi1 != NULL)
        {
            free( pi1 );
            pi1 = NULL;
        }

        pi1 = (PORT_INFO_1 *) malloc(pcbNeeded);
        if(pi1 == NULL)
        {
            pcbNeeded = 0;
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            res = g_pfnEnumPorts(
                (m_szServerName[0] == '\0') ? NULL : m_szServerName,
                1,
                (LPBYTE)pi1,
                pcbNeeded,
                &pcbNeeded,
                &pcReturned);

            if( res )
            {
                for(DWORD i=0;i<pcReturned; i++)
                {
                    if(0 == _tcsicmp(pi1[i].pName, psztPortName))
                    {
                        dwRetCode = ERROR_DUP_NAME;
                        break;
                    }
                }
            }
        }
    }

    if(pi1 != NULL)
    {
        free(pi1);
        pi1 = NULL;
    }

    return(dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portrefabc.h ===
/*****************************************************************************
 *
 * $Workfile: portrefabc.h $
 *
 * Copyright (C) 2000 Microsoft Corporation.
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef INC_PORTREFABC_H
#define INC_PORTREFABC_H

#include "mglist.h"

class TRefCount;
class CPortABC;

class CPortRefABC: public CPortABC, public TRefCount
{
public:
	CPortRefABC() { };
	virtual	~CPortRefABC() { };

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("PortRefABC %p ", this));
        return TRefCount::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("PortRefABC %p ", this));
        return TRefCount::DecRef();
    };
#endif

};


#endif	// INC_PORTREFABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\precomp.h ===
/*****************************************************************************
 *
 * $Workfile: pch_spp.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/pch_spp.h $
 *
 * 2     7/14/97 2:27p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:19p Binnur
 * Initial File
 *
 *****************************************************************************/

#ifndef INC_PCH_SPP_H
#define INC_PCH_SPP_H

#include <windows.h>

//  Include the correct spooler definitions, etc
#include <winspool.h>

#include <tchar.h>

#include <windows.h>
#include <winsock2.h>
#include <time.h>
#include <winerror.h>

#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <winsplp.h>

// event messages
#include "message.h"	
#include "event.h"	
#include "spllib.hxx"

//
//  Files at ..\Common
//
#include "tcpmon.h"
#include "rtcpdata.h"
#include "CoreUI.h"
#include "regabc.h"
#include "mibabc.h"

#endif	// INC_PCH_SPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\mglist.inl ===
template <class T, class KEYTYPE>
TManagedList<T, KEYTYPE>::TManagedList<T, KEYTYPE>(void):
    m_bValid (FALSE)
{
    if (m_CritSec.bValid ()) {
        m_pList = new TSrchDoubleList<T, KEYTYPE>;
    
        if (m_pList) {
            if (m_pList->bValid ()) {
                m_bValid = TRUE;
            }
            else  {
                delete m_pList;
                m_pList = NULL;
            }
        }
    }
}

template <class T, class KEYTYPE>
TManagedList<T, KEYTYPE>::~TManagedList<T, KEYTYPE>(void)
{
    DBGMSG (DBG_TRACE, ("TManagedList deleted\n"));
    if (m_pList) {
        delete m_pList;
    }
}


template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::AppendItem (T &item)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {
    
        TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);
    
        if (pNewNode) {
            if (m_pList->AppendNode (pNewNode)) {
                item->SetContextPtr (&m_CritSec, m_pList, pNewNode);
                bRet = TRUE;
            }
        }
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::FindItem (
    CONST KEYTYPE t, T&refItem)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {
        if (refItem = m_pList->FindItemFromKey (t)) {

            refItem->IncRef ();
    
            bRet = TRUE;
        }
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::FindItem (
    CONST T &t, 
    T &refItem)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {
        if (refItem = m_pList->FindItemFromItem (t)) {

            refItem->IncRef ();
    
            bRet = TRUE;
        }
    }
    return bRet;
}



template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::NewEnum (TEnumManagedList<T, KEYTYPE> **ppIterator)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {

        TEnumManagedList<T, KEYTYPE> *pItem 
            = new TEnumManagedList<T, KEYTYPE> (this, m_pList);
    
        if (pItem) {
            if (pItem->bValid ()) {
                *ppIterator = pItem;
                bRet = TRUE;
            }
            else 
                delete pItem;
        }
    }
    return bRet;
}


template <class T, class KEYTYPE>
TEnumManagedList<T, KEYTYPE>::TEnumManagedList<T, KEYTYPE> (
    TManagedList<T, KEYTYPE> *pList,
    TSrchDoubleList<T, KEYTYPE> *pSrchList):
    m_pList (pList),
    m_pCurrent (NULL),
    m_pSrchList (pSrchList)
{
    m_pList->IncRef ();
}

template <class T, class KEYTYPE>
TEnumManagedList<T, KEYTYPE>::~TEnumManagedList<T, KEYTYPE> ()
{
    T pItem;
    
    if (m_pList->Lock ()) {
        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->DecRef ();
        }
        m_pList->Unlock ();
    }
    m_pList->DecRef ();

    DBGMSG (DBG_TRACE, ("TEnumManagedList deleted\n"));
}

template <class T, class KEYTYPE>
BOOL
TEnumManagedList<T, KEYTYPE>::Next (T *ppItem)
{

    T pItem;
    BOOL bRet = FALSE;
    BOOL bDel;
    TDoubleNode <T, KEYTYPE> * pTmp;
    TDoubleNode <T, KEYTYPE> * pOld;

    TAutoCriticalSection CritSec (*m_pList->GetCS());

    if (CritSec.bValid ()) {

        if (!m_pCurrent) {
            // First call
            if (m_pCurrent = m_pSrchList->GetHead ()) {
                pItem = m_pCurrent->GetData ();
                pItem->IncRef ();

    
                if (pItem->IsPendingDeletion (bDel) && !bDel) {
                    pItem ->IncRef ();
                    *ppItem = pItem;
        
                    return TRUE;
                }
            }
            else {
                // There is no element
                return FALSE;
            }
        }
    
        pOld = m_pCurrent;
        pTmp = m_pCurrent;
    
        while (pTmp = pTmp->GetNext ()) {
    
            pItem = pTmp->GetData ();
    
            if (pItem->IsPendingDeletion (bDel) && !bDel) {
                pItem->IncRef ();
                *ppItem = pItem;
                bRet = TRUE;
                break;
            }
        }
    
        m_pCurrent = pTmp;
        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->IncRef ();
        }
    
        if (pOld) {
            pItem = pOld->GetData ();
            pItem->DecRef ();
        }
    
    }
    return bRet;
}


template <class T, class KEYTYPE>
VOID
TEnumManagedList<T, KEYTYPE>:: Reset ()
{
    TAutoCriticalSection CritSec (*m_pList->GetCS());
    T pItem;

    if (CritSec.bValid ()) {

        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->DecRef ();
        }
        m_pCurrent = NULL;
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawdev.h ===
/*****************************************************************************
 *
 * $Workfile: rawdev.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPDEVICE_H
#define INC_TCPDEVICE_H

#include "devABC.h"
#include "tcpport.h"

class CMemoryDebug;
class CTCPTransport;
class CTcpMibABC;


typedef DWORD	 (CALLBACK *PFN_PING) ( LPCSTR );


class CRawTcpDevice : public CDeviceABC
#if defined _DEBUG || defined DEBUG
	 , public CMemoryDebug
#endif
{
	// methods
public:
	CRawTcpDevice();

	CRawTcpDevice(	
        LPTSTR		    psztHostAddress,
        DWORD		    dPortNum,
        DWORD		    dSNMPEnabled,
        LPTSTR		    psztSNMPCommunity,
        DWORD		    dSNMPDevIndex,
        CTcpPort        *pParent);

	CRawTcpDevice(
        LPTSTR		    psztHostName,
        LPTSTR		    psztIPAddr,
        LPTSTR		    psztHWAddr,
        DWORD		    dPortNum,
        DWORD		    dSNMPEnabled,
        LPTSTR		    psztSNMPCommunity,
        DWORD		    dSNMPDevIndex,
        CTcpPort        *pParent);
	
	~CRawTcpDevice();

    DWORD   ReadDataAvailable();

	DWORD   Read(LPBYTE	        pBuffer,
                 DWORD	        cbBufSize,
                 INT            iTimeout,
                 LPDWORD        pcbRead);

	DWORD   Write(LPBYTE        pBuffer,
                  DWORD	        cbBuf,
                  LPDWORD       pcbWritten);

	DWORD   Connect();

    DWORD   GetAckBeforeClose(DWORD     dwTimeInSeconds);

    DWORD   PendingDataStatus(DWORD     dwTimeInMilliSeconds,
                              LPDWORD   pcbNeeded);
	DWORD	Close();
	DWORD	Ping();
	DWORD	ResolveAddress();
	DWORD	CheckAddress( );
	LPTSTR	GetHostAddress()	{ return (*m_sztHostName == '\0' ?
								(LPTSTR)m_sztIPAddress : (LPTSTR)m_sztHostName);  }
	LPTSTR	GetHostName()	{ return (LPTSTR)m_sztHostName;  }
	LPTSTR	GetIPAddress()	{ return (LPTSTR)m_sztIPAddress; }
	LPTSTR	GetHWAddress()	{ return (LPTSTR)m_sztHWAddress; }
	LPTSTR  GetSNMPCommunity()	{ return (LPTSTR)m_sztSNMPCommunity; }
	DWORD	GetSNMPEnabled()	{ return m_dSNMPEnabled; }
	DWORD	GetSNMPDevIndex()	{ return m_dSNMPDevIndex; }
	LPTSTR	GetDescription();
	DWORD	GetPortNumber() { return m_dPortNumber; }
	DWORD	GetStatus();
	DWORD	GetJobStatus();
	DWORD	SetStatus( LPTSTR psztPortName );
    DWORD   SetStatusNT3( LPTSTR psztPortName );
	DWORD	GetDeviceInfo();
	DWORD	ResolveTransportPath( LPSTR	 pszHostAddress,
								  DWORD  dwSize );

protected:		// members
	void	InitializeTcpMib();
	void	DeInitialize( );
	DWORD	SetHWAddress();
	
private:		// attributes
	CTcpPort     *m_pParent;
	CTcpMibABC		*m_pTcpMib;
	RPARAM_1		m_pfnGetTcpMibPtr;	// points to RecognizeFrame()

	DWORD			m_dwLastError;

protected:
	CTCPTransport	*m_pTransport;			// the actual transport path

	// device address
	TCHAR		m_sztAddress[MAX_NETWORKNAME_LEN];			// host address (name or IP)
	TCHAR		m_sztHostName[MAX_NETWORKNAME_LEN];			// host name
	TCHAR		m_sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR		m_sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR		m_sztDescription[MAX_DEVICEDESCRIPTION_STR_LEN];
	TCHAR		m_sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD		m_dPortNumber;
	DWORD		m_dSNMPEnabled;
	DWORD		m_dSNMPDevIndex;
    BOOL        m_bFirstWrite;


/*	CMACAddress	*m_pHWAddress;
	CIPAddress	*m_pIPAddress;
*/
};


#endif // INC_TCPDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawdev.cpp ===
/*****************************************************************************
 *
 * $Workfile: rawdev.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "tcptrans.h"
#include "rawdev.h"


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpDevice::CRawTcpDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice() :
                                m_pTransport(NULL), m_pParent(NULL),
                                m_pfnGetTcpMibPtr(NULL), m_pTcpMib(NULL),
                                m_dwLastError(NO_ERROR), m_dPortNumber(0),
                                m_dSNMPEnabled(FALSE),
                                m_bFirstWrite (TRUE)
{
    *m_sztAddress   = '\0';
    *m_sztIPAddress = '\0';
    *m_sztHWAddress = '\0';
    *m_sztHostName  = '\0';
    *m_sztDescription = '\0';
    *m_sztSNMPCommunity = '\0';

    InitializeTcpMib();

}   // ::CRawTcpDevice()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpDevice::CRawTcpDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice( LPTSTR    in psztHostAddress,
                              DWORD     in dPortNum,
                              DWORD     in dSNMPEnabled,
                              LPTSTR    in psztSNMPCommunity,
                              DWORD     in dSNMPDevIndex,
                              CTcpPort  in *pParent) :
                                                     m_pTransport( NULL ),
                                                     m_bFirstWrite (TRUE)


{
    lstrcpyn(m_sztAddress, psztHostAddress, SIZEOF_IN_CHAR( m_sztAddress));
    lstrcpyn(m_sztSNMPCommunity, psztSNMPCommunity, SIZEOF_IN_CHAR( m_sztSNMPCommunity) );

    *m_sztIPAddress = '\0';
    *m_sztHWAddress = '\0';
    *m_sztHostName  = '\0';
    *m_sztDescription = '\0';

    m_dSNMPEnabled = dSNMPEnabled;
    m_dSNMPDevIndex = dSNMPDevIndex;
    m_dPortNumber = dPortNum;
    m_pParent = pParent;

    InitializeTcpMib();

    ResolveAddress( );      // gets the hostName & IP Address
//  SetHWAddress();         // gets the hardware address
//  GetDescription();


}   // ::CRawTcpDevice()


///////////////////////////////////////////////////////////////////////////////
//  CDevice::CDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice( LPTSTR in psztHostName,
                              LPTSTR in psztIPAddr,
                              LPTSTR in psztHWAddr,
                              DWORD  in dPortNum,
                              DWORD  in dSNMPEnabled,
                              LPTSTR in psztSNMPCommunity,
                              DWORD  in dSNMPDevIndex,
                              CTcpPort  in *pParent) :
                                                     m_pTransport(NULL),
                                                     m_bFirstWrite (TRUE)
{
    lstrcpyn(m_sztHostName, psztHostName, SIZEOF_IN_CHAR( m_sztHostName));
    lstrcpyn(m_sztIPAddress, psztIPAddr, SIZEOF_IN_CHAR( m_sztIPAddress));
    lstrcpyn(m_sztHWAddress, psztHWAddr, SIZEOF_IN_CHAR( m_sztHWAddress));
    lstrcpyn(m_sztSNMPCommunity, psztSNMPCommunity, SIZEOF_IN_CHAR( m_sztSNMPCommunity ) );

    if ( *m_sztHostName == '\0' )
    {
        if ( *m_sztIPAddress != '\0' )
        {
            lstrcpyn(m_sztAddress, m_sztIPAddress, SIZEOF_IN_CHAR( m_sztAddress) );
        }
        else
        {
            _tcscpy(m_sztAddress, TEXT("") );
        }
    }
    else
    {
        lstrcpyn(m_sztAddress, m_sztHostName, SIZEOF_IN_CHAR(m_sztAddress));
    }

    m_dPortNumber = dPortNum;
    m_pParent = pParent;


    *m_sztDescription = '\0';

    m_dSNMPEnabled = dSNMPEnabled;
    m_dSNMPDevIndex = dSNMPDevIndex;

    InitializeTcpMib();

//  Type();     // FIX:     for debug only.
//  Ping();
//  SetHWAddress();
//  GetDeviceInfo();


}   // ::CDevice()


///////////////////////////////////////////////////////////////////////////////
//  CDevice::~CDevice()
//

CRawTcpDevice::~CRawTcpDevice()
{
    if (m_pTransport)   delete m_pTransport;
}   // ::~CDevice()


///////////////////////////////////////////////////////////////////////////////
//  InitializeTcpMib -- loads the TcpMib.dll & gets a handle to the CTcpMibABC
//      class

void
CRawTcpDevice::InitializeTcpMib( )
{
    // load & assign the m_pTcpMib pointer
    m_pTcpMib = NULL;

    if( g_hTcpMib == NULL )
    {
        g_hTcpMib = ::LoadLibrary(TCPMIB_DLL_NAME);
        if (g_hTcpMib == NULL)
        {
            _RPT0(_CRT_WARN, "TCPMIB.DLL Not Found\n");
            m_dwLastError = ERROR_DLL_NOT_FOUND;
        }
    }

    if( g_hTcpMib != NULL )
    {
        // initialize the proc address
        m_pfnGetTcpMibPtr=(RPARAM_1)::GetProcAddress(g_hTcpMib, "GetTcpMibPtr");

        m_pTcpMib = (CTcpMibABC *)(*m_pfnGetTcpMibPtr)();
        if ( m_pTcpMib == NULL)
        {
            m_dwLastError = GetLastError();
        }
    }
}   // ::InitializeTcpMib()

///////////////////////////////////////////////////////////////////////////////
//  ReadDataAvailable -- check if there are data available to read
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::ReadDataAvailable()
{
    DWORD dwRetCode = NO_ERROR;

    if ( m_pTransport )
    {
        dwRetCode = m_pTransport->ReadDataAvailable();
    }
    else
    {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return (dwRetCode);

}   // ::ReadDataAvailable()


///////////////////////////////////////////////////////////////////////////////
//  Read -- recv the print data from the device
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::Read( LPBYTE in      pBuffer,
                      DWORD     in      cbBufSize,
                      INT       in      iTimeout,
                      LPDWORD   inout   pcbRead)
{
    DWORD dwRetCode = NO_ERROR;

    if ( m_pTransport )
    {
        dwRetCode = m_pTransport->Read(pBuffer, cbBufSize, iTimeout, pcbRead);
    }
    else
    {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return (dwRetCode);

}   // ::Read()

///////////////////////////////////////////////////////////////////////////////
//  Write -- sends the print data to the device
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::Write( LPBYTE    in      pBuffer,
                      DWORD     in      cbBuf,
                      LPDWORD   inout   pcbWritten)
{
    DWORD dwRetCode = NO_ERROR;

    if (dwRetCode == NO_ERROR)
    {
        if ( m_pTransport )
        {
            dwRetCode = m_pTransport->Write(pBuffer, cbBuf, pcbWritten);
        }
        else
        {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    }

    if (m_bFirstWrite && dwRetCode == ERROR_CONNECTION_ABORTED)
    {
        if ( m_pTransport ) {
            delete m_pTransport;
            m_pTransport = NULL;
        }

        //
        // When users print large images, there will be a long delay between StartDocPrinter
        // and the frist WritePrinter call. TCPMon used to open the TCP/IP connection
        // to the printer at the StartDocPrinter time, but since there is no data
        // coming, the printer closeed the connection when TCPMon tried to write the data.
        //
        // So we have to re-establish connection open to the first WritePrinter call.
        //

        char    szHostAddress[MAX_NETWORKNAME_LEN];

        //
        // resolve the address to use
        //
        dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );

        if (dwRetCode == NO_ERROR && strcmp(szHostAddress, "") == 0 )
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }

        if (dwRetCode == NO_ERROR) {

            m_pTransport = new CTCPTransport(szHostAddress, static_cast<USHORT>(m_dPortNumber));

            if (!m_pTransport)
            {
                dwRetCode = ERROR_OUTOFMEMORY;
            }
        }

        if (dwRetCode == NO_ERROR)
        {
            dwRetCode = m_pTransport->Connect();
        }

        if (dwRetCode != NO_ERROR)
        {
            //
            //  Operation failed, we need to free the m_Transport
            //
            delete m_pTransport;
            m_pTransport = NULL;
        }

        if ( m_pTransport )
        {
            dwRetCode = m_pTransport->Write(pBuffer, cbBuf, pcbWritten);
        }
        else
        {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    }

    m_bFirstWrite = FALSE;

    return (dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  Connect -- creates a new transport connection
//  Error Codes
//      NO_ERROR if everything is OK
//      PRINTER_STATUS_BUSY if connection refused
//      ERROR_INVALID_PARAMETER if the address is not valid

DWORD
CRawTcpDevice::Connect()
{
    DWORD   dwRetCode = NO_ERROR;

    if ( m_pTransport ) {
        delete m_pTransport;
        m_pTransport = NULL;
    }

    m_bFirstWrite = TRUE;

    //
    // We must verify if the HostName is available, if not we should return error
    // right away.
    //
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    //
    // resolve the address to use
    //
    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );

    if (dwRetCode == NO_ERROR && strcmp(szHostAddress, "") == 0 )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
    }

    if (dwRetCode == NO_ERROR) {

        m_pTransport = new CTCPTransport(szHostAddress, static_cast<USHORT>(m_dPortNumber));

        if (!m_pTransport)
        {
            dwRetCode = ERROR_OUTOFMEMORY;
        }
    }

    if (dwRetCode == NO_ERROR)
    {
        dwRetCode = m_pTransport->Connect();
    }

    if (dwRetCode != NO_ERROR)
    {
        //
        //  Operation failed, we need to free the m_Transport
        //
        delete m_pTransport;
        m_pTransport = NULL;
    }

    return dwRetCode;

}   // ::Connect()


DWORD
CRawTcpDevice::
GetAckBeforeClose(
    DWORD   dwTimeInSeconds
    )
{
    return m_pTransport ? m_pTransport->GetAckBeforeClose(dwTimeInSeconds)
                        : ERROR_INVALID_PARAMETER;

}


DWORD
CRawTcpDevice::
PendingDataStatus(
    DWORD       dwTimeout,
    LPDWORD     pcbNeeded
    )
{
   return m_pTransport ? m_pTransport->PendingDataStatus(dwTimeout, pcbNeeded)
                       :  NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
//  Close

DWORD
CRawTcpDevice::Close()
{
    DWORD   dwRetCode = NO_ERROR;

    if ( m_pTransport ) delete m_pTransport;
    m_pTransport = NULL;

    return (dwRetCode);

}   // ::Close()


///////////////////////////////////////////////////////////////////////////////
//  ResolveTransportPath -- m_sztAddress contains the host address to be used
//      to talk to the device

DWORD
CRawTcpDevice::ResolveTransportPath( LPSTR      out     pszHostAddress,
                                     DWORD      in      dwSize ) // Size in characters of the host address
{
    DWORD   dwRetCode = NO_ERROR;

    if ( *m_sztHostName == '\0' )                   // host name is NULL -- no DNS entry
    {
        if ( *m_sztIPAddress != '\0' )              // ip address is entered
        {
            lstrcpyn(m_sztAddress, m_sztIPAddress, SIZEOF_IN_CHAR( m_sztAddress) );
        }
        else
        {
            _tcscpy(m_sztAddress, TEXT("") );
        }
    }
    else
    {
        lstrcpyn(m_sztAddress, m_sztHostName, SIZEOF_IN_CHAR(m_sztAddress));    // use the host name
    }

    UNICODE_TO_MBCS( pszHostAddress, dwSize, m_sztAddress, -1);

    return (dwRetCode);

}   // ::CreateTransport()


///////////////////////////////////////////////////////////////////////////////
//  Ping
//      Error codes:
//          NO_ERROR            if ping is successfull
//          DEVICE_NOT_FOUND    if device is not found
//          ERROR_INVALID_PARAMETER if address is not valid

DWORD
CRawTcpDevice::Ping()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];
    PFN_PING    pfnPing;

    if( g_hTcpMib == NULL )
    {
        g_hTcpMib = ::LoadLibrary(TCPMIB_DLL_NAME);
        if (g_hTcpMib == NULL)
        {
            _RPT0(_CRT_WARN, "TCPMIB.DLL Not Found\n");
            m_dwLastError = ERROR_DLL_NOT_FOUND;
        }
    }

    if( g_hTcpMib != NULL )
    {
        // resolve the address to use
        dwRetCode = ResolveTransportPath( szHostAddress,
                                          SIZEOF_IN_CHAR(szHostAddress) );
        if ( strcmp(szHostAddress, "") == 0 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        // initialize the proc address
        pfnPing = (PFN_PING)::GetProcAddress(g_hTcpMib, "Ping");
        _ASSERTE(pfnPing != NULL);
        if ( pfnPing )
        {
            dwRetCode = (*pfnPing)(szHostAddress);      // ping the device
        }
    }

    return (dwRetCode);

}   // ::Ping()

///////////////////////////////////////////////////////////////////////////////
//  SetHWAddress -- get's device hardware address, and sets the m_sztHWAddress
//  Error Codes:
//      NO_ERROR if successful
//      ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//      ERROR_INVALID_HANDLE        if can't build the variable bindings
//          SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//          SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//          SNMP_ERRORSTATUS_BADVALUE
//          SNMP_ERRORSTATUS_READONLY
//          SNMP_ERRORSTATUS_GENERR
//          SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//          SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()
//          ERROR_INVALID_PARAMETER if address is not valid

DWORD
CRawTcpDevice::SetHWAddress()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
    if ( strcmp(szHostAddress, "") == 0 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( m_pTcpMib )
    {
        char buf[MAX_SNMP_COMMUNITY_STR_LEN];

        UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR(buf), m_sztSNMPCommunity, -1);
        dwRetCode = m_pTcpMib->GetDeviceHWAddress(szHostAddress, buf, m_dSNMPDevIndex, SIZEOF_IN_CHAR(m_sztHWAddress), m_sztHWAddress);     // get the OT_DEVICE_INFO
    }

    return (dwRetCode);

}   // ::SetHWAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDescription -- returns the device description -- this is either the
//      sysDescr field, or the hrDeviceDescr if Printer MIB is implemented
//  ERROR CODES
//      Returns the manufacturer information or NULL if error

LPTSTR
CRawTcpDevice::GetDescription()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
    if ( strcmp(szHostAddress, "") == 0 )
    {
        *m_sztDescription = '\0';
        return (m_sztDescription);
    }

    if ( m_pTcpMib )
    {
        char buf[MAX_SNMP_COMMUNITY_STR_LEN];

        UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
        dwRetCode = m_pTcpMib->GetDeviceName(szHostAddress, buf, m_dSNMPDevIndex,SIZEOF_IN_CHAR(m_sztDescription), m_sztDescription);           // get the OT_DEVICE_INFO
    }

    if ( dwRetCode != NO_ERROR )
    {
        *m_sztDescription = '\0';
    }

    return (m_sztDescription);

}   // ::GetDescription()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- given an Address, resolves the host name, and IP address
//          Add MacAddress, here
//      Error Codes:    FIX!!

DWORD
CRawTcpDevice::ResolveAddress( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    hostAddress[MAX_NETWORKNAME_LEN];
    char    szHostName[MAX_NETWORKNAME_LEN];
    char    szIPAddress[MAX_IPADDR_STR_LEN];

    CTCPTransport *pTransport;
    memset(szHostName, '\0', sizeof( szHostName ));
    memset(szIPAddress, '\0', sizeof( szIPAddress ));

    UNICODE_TO_MBCS(hostAddress, SIZEOF_IN_CHAR(hostAddress), m_sztAddress, -1);        // convert from UNICODE

    pTransport = new CTCPTransport();
    if( pTransport )
    {
        dwRetCode = pTransport->ResolveAddress(hostAddress, MAX_NETWORKNAME_LEN, szHostName, MAX_IPADDR_STR_LEN, szIPAddress );

        // convert to unicode
        MBCS_TO_UNICODE(m_sztHostName, SIZEOF_IN_CHAR(m_sztHostName), szHostName);
        MBCS_TO_UNICODE(m_sztIPAddress, SIZEOF_IN_CHAR(m_sztIPAddress), szIPAddress);

        delete pTransport;
    }
    return (dwRetCode);

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  CheckAddress -- double check the valadity of the addresses
//      Error Codes:    FIX!! -- solve for the DNS problem w/ hostname is invalid ( host name doens't work, ip address does)
//          (, and w/ no DNS

DWORD
CRawTcpDevice::CheckAddress( )
{
    DWORD   dwRetCode = NO_ERROR;
    return (dwRetCode);

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetStatus -- gets the printer status
//      Return Code: the spooler status codes, see PRINTER_INFO_2

DWORD
CRawTcpDevice::GetStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    hostName[MAX_NETWORKNAME_LEN];
    char buf[MAX_SNMP_COMMUNITY_STR_LEN];

    if (m_dSNMPEnabled)
    {
        CheckAddress();
        if ( *m_sztHostName != '\0' )
        {
            UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName ), m_sztHostName, -1);
        }
        else if ( *m_sztIPAddress != '\0' )
        {
            UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName ), m_sztIPAddress, -1);
        }

        if ( m_pTcpMib )
        {
            // get the OT_DEVICE_STATUS
            UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
            dwRetCode = m_pTcpMib->GetDeviceStatus(hostName, buf, m_dSNMPDevIndex);
        }
        return dwRetCode;
    }
    else
        return ERROR_NOT_SUPPORTED;

}   // ::GetStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus -- gets the job status
//      Return Code: the spooler status codes, see JOB_INFO_2

DWORD
CRawTcpDevice::GetJobStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    if (m_dSNMPEnabled)
    {
        dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
        if ( strcmp(szHostAddress, "") == 0 )
        {
            return JOB_STATUS_ERROR;        // can't communicate w/ the device
        }

        if ( m_pTcpMib )
        {
            char buf[MAX_SNMP_COMMUNITY_STR_LEN];

            UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
            dwRetCode = m_pTcpMib->GetJobStatus(szHostAddress,  buf, m_dSNMPDevIndex);      // get the OT_DEVICE_STATUS
        }

        return dwRetCode;
    }
    else
        return ERROR_NOT_SUPPORTED;

}   // ::GetStatus()

///////////////////////////////////////////////////////////////////////////////
//  SetStatus -- sets the printer status
//              Returns the last printer status 0 for no - error
DWORD
CRawTcpDevice::SetStatus( LPTSTR psztPortName )
{
    DWORD          dwStatus   = NO_ERROR;
    DWORD          dwRetCode  = NO_ERROR;
    PORT_INFO_3    PortStatus = {0, NULL, 0};
    const CPortMgr *pPortMgr  = NULL;


    if( g_pfnSetPort && (pPortMgr = m_pParent->GetPortMgr()) != NULL )
    {
        if (m_dSNMPEnabled)
        {
            // GetStatus() here
            LPCTSTR lpszServer = pPortMgr->GetServerName();

            dwStatus = GetStatus();


            if ( m_pTcpMib )
            {
                m_pTcpMib->SNMPToPortStatus(dwStatus, &PortStatus );

                //
                // This calls happens in a newly created thread, which already has admin access,
                // so we do not need to impersonate client when calling SetPort ()
                //

                if (!SetPort((LPTSTR)lpszServer, psztPortName, 3, (LPBYTE)&PortStatus ))
                    return GetLastError ();

            }
            return PortStatus.dwStatus;
        }
        else
            return ERROR_NOT_SUPPORTED;

    } else
    {
        return( ERROR_INVALID_FUNCTION );
    }
}       // ::SetStatus()

///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- given an address, gets the device information: IP address,
//      host name, HW address, device type
//      Error Codes:    FIX!!

DWORD
CRawTcpDevice::GetDeviceInfo()
{
    DWORD   dwRetCode = NO_ERROR;
/*  char    hostName[MAX_NETWORKNAME_LEN];

    _tcscpy(m_sztAddress, m_sztHostName);
    ResolveAddress();       // update the IP address based on the hostname
    HWAddress();            // update the HW address based on the hostname

    if ( *m_sztHostName != '\0' )
    {
        UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName), m_sztHostName, -1);
    }
    else if ( *m_sztAddress != '\0' )
    {
        UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName), m_sztAddress, -1);
    }

    // get the OT_DEVICE_INFO
    dwRetCode = (CPortMgr::GetTransportMgr())->GetDeviceInfo(hostName, m_sztDescription);
*/
    return (dwRetCode);

}   // ::GetDeviceInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portmgr.h ===
/*****************************************************************************
 *
 * $Workfile: PortMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_PORTMGR_H
#define INC_PORTMGR_H

typedef int (CALLBACK *ADDPARAM)(HWND);
typedef int (CALLBACK *CONFIGPARAM)(HWND, PPORT_DATA_1);

#include "port.h"

typedef TManagedList<PCPORT, LPTSTR> TManagedListImp;
typedef TEnumManagedList<PCPORT, LPTSTR> TEnumManagedListImp;

class CMemoryDebug;
class CPort;
class CPortMgr;
class CDeviceStatus;

#define MAX_SUPPORTED_LEVEL     2   // maximum supported level


// A pointer to this structure is passed back as a port handle to
// the spooler during an OpenPort.  Subsequent WritePort, ...
// calls from the spooler pass back this handle/pointer.
// The dSignature is used to ensure the handle is a valid one
// that this monitor created.  The pPort points to a CPort
// object in our list of ports.
//
//  marks port structures as an HP port structure
//
#define     HPPORT_SIGNATURE        (0x504F5254)
typedef struct _HPPORT {
    DWORD       cb;
    DWORD       dSignature;
    ACCESS_MASK grantedAccess;
    CPort       *pPort;
    CPortMgr    *pPortMgr;
} HPPORT, *PHPPORT;

class CPortMgr
#if defined _DEBUG || defined DEBUG
    : public CMemoryDebug
#endif
{
    // methods
public:
    CPortMgr();
    ~CPortMgr();

    DWORD   InitializeMonitor ();

    DWORD   InitializeRegistry(HANDLE hcKey,
                               HANDLE hSpooler,
                               PMONITORREG  pMonitorReg,
                               LPCTSTR psztServerName );

    DWORD   OpenPort        (LPCTSTR    psztPName,
                             PHANDLE    pHandle);
    DWORD   OpenPort        (PHANDLE    phXcv );
    DWORD   ClosePort       (const HANDLE   handle);
    DWORD   StartDocPort    (const HANDLE   handle,
                             const LPTSTR   psztPrinterName,
                             const DWORD    jobId,
                             const DWORD    level,
                             const LPBYTE   pDocInfo);
    DWORD   WritePort       (const HANDLE  handle,
                              LPBYTE  pBuffer,
                              DWORD   cbBuf,
                              LPDWORD pcbWritten);
    DWORD   ReadPort        ( const HANDLE  handle,
                                    LPBYTE  pBuffer,
                              const DWORD   cbBuffer,
                                    LPDWORD pcbRead);
    DWORD   EndDocPort      ( const HANDLE  handle);
    DWORD   DeletePort      ( const LPTSTR  psztPortName);
    DWORD   EnumPorts       ( const LPTSTR  psztName,
                              const DWORD   level,
                              const LPBYTE  pPorts,
                                    DWORD   cbBuf,
                                    LPDWORD pcbNeeded,
                                    LPDWORD pcReturned);
    DWORD ConfigPortUIEx( LPBYTE pData );

    DWORD XcvOpenPort( LPCTSTR      pszObject,
                       ACCESS_MASK  GrantedAccess,
                       PHANDLE      phXcv);
    DWORD XcvClosePort( HANDLE  hXcv );
    DWORD XcvDataPort(HANDLE        hXcv,
                      PCWSTR        pszDataName,
                      PBYTE     pInputData,
                      DWORD     cbInputData,
                      PBYTE     pOutputData,
                      DWORD     cbOutputData,
                      PDWORD        pcbOutputNeeded);

    VOID    EnterCSection();
    VOID    ExitCSection();

    DWORD   GetStatusUpdateInterval() { return m_dStatusUpdateInterval; }
    BOOL    IsStatusUpdateEnabled() { return m_bStatusUpdateEnabled; }

    DWORD   CreatePortObj( const LPTSTR psztPortName,       // port name
                           const DWORD  dwProtocolType,     // protocol type
                           const DWORD  dwVersion);         // version number

    DWORD   UpdatePortEntry( LPCTSTR    psztPortName);

    VOID    InitMonitor2( LPMONITOR2    *ppMonitor);

    inline LPCTSTR GetServerName(void) const;       // Some of our port calls need the server
                                                    // name and hence have to be passed the
                                                    // port manager object

    inline BOOL bValid(VOID) CONST { return m_bValid;};

    // instance methods
private:

    DWORD CreatePortObj( LPCTSTR psztPortName,      // port name
                           const DWORD   dwPortType,        // port number
                           const DWORD   dwVersion,         // version number
                           const LPBYTE  pData);            // data

    DWORD   CreatePort( const DWORD     dwProtocolType,
                        const DWORD     dwVersion,
                        LPCTSTR         psztPortName,
                        const LPBYTE    pData);

    DWORD   ValidateHandle( const HANDLE handle,
                                  CPort  **ppPort);
    DWORD   EncodeHandle( PHANDLE   pHandle );
    CPort*  FindPort ( LPCTSTR psztPortName);
    BOOL    FindPort ( CPort  *pNewPort);
    DWORD   PortExists( LPCTSTR psztPortName);
    DWORD   GetEnumPortsBuffer( const DWORD   level,
                                      LPBYTE  pPorts,
                                const DWORD   bBuf,
                                      LPDWORD pcbNeeded,
                                      LPDWORD pcReturned);
    DWORD   EnumSystemProtocols( void );
    DWORD   EnumSystemPorts    ( void );
    DWORD   InitConfigPortStruct(PPORT_DATA_1 pConfigPortData,
                                 CPort              *pPort);
    DWORD   AddPortToList(CPort *pPort);

    DWORD   EncodeHandle( CPort *pPort,
                         PHANDLE phXcv);

    DWORD   FreeHandle( HANDLE hXcv );

    BOOL    HasAdminAccess( HANDLE hXcv );
    // attributes
    static void EndPortData1Strings(PPORT_DATA_1 pPortData);
    static void EndDeletePortData1Strings(PDELETE_PORT_DATA_1 pDeleteData);
    static inline void EndConfigInfoData1Strings(PCONFIG_INFO_DATA_1 pConfigData);

 protected:
    friend CDeviceStatus;

    TManagedListImp *m_pPortList;

private:
    static  CONST   DWORD   cdwMaxXcvDataNameLen;

    BOOL                m_bValid;

    MONITOREX           m_monitorEx;        // monitor ex structure
    MONITOR2            m_monitor2;
    CRITICAL_SECTION    m_critSect;

    DWORD               m_dStatusUpdateInterval;
    BOOL                m_bStatusUpdateEnabled;
    CRegABC            *m_pRegistry;       // pointers to the needed objects
    TCHAR               m_szServerName[MAX_PATH];

};

/////////////////////////////////////////////////////////////////////////////////////////////
// INLINE METHODS
/////////////////////////////////////////////////////////////////////////////////////////////
inline LPCTSTR CPortMgr::GetServerName(void) const {
    return m_szServerName;
}

inline void CPortMgr::EndConfigInfoData1Strings(PCONFIG_INFO_DATA_1 pConfigData) {
    pConfigData->sztPortName[MAX_PORTNAME_LEN-1] = NULL;
}

#endif // INC_PORTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawport.h ===
/*****************************************************************************
 *
 * $Workfile: rawport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_RAWTCPPORT_H
#define INC_RAWTCPPORT_H

#include "tcpport.h"
#include "RTcpData.h"

class CRawTcpJob;
class CRawTcpDevice;
class CRawTcpInterface;

class CRawTcpPort : public CTcpPort
#if defined _DEBUG || defined DEBUG
//	, public CMemoryDebug
#endif
{
	// methods
public:

	CRawTcpPort( );
	CRawTcpPort( LPTSTR	  IN	psztPortName,		// called through the UI port creation
				 LPTSTR	  IN	psztHostAddress, 
				 DWORD	  IN	dPortNum,
				 DWORD	  IN    dSNMPEnabled,
				 LPTSTR   IN    sztSNMPCommunity,
                 DWORD    IN    dSNMPDevIndex,
				 CRegABC  IN    *pRegistry,
                 CPortMgr IN    *pPortMgr);

	CRawTcpPort( LPTSTR	  IN	psztPortName,		// called through the registry port creation
				 LPTSTR   IN	psztHostName, 
				 LPTSTR   IN	psztIPAddr, 
				 LPTSTR   IN	psztHWAddr, 
				 DWORD    IN	dPortNum,
				 DWORD	  IN    dSNMPEnabled,
				 LPTSTR   IN    sztSNMPCommunity,
                 DWORD    IN    dSNMPDevIndex,
				 CRegABC  IN	*pRegistry,
                 CPortMgr IN    *pPortMgr);
	~CRawTcpPort();

	DWORD	StartDoc	( const LPTSTR psztPrinterName,
						  const DWORD  jobId,
						  const DWORD  level,
						  const LPBYTE pDocInfo );


private:	// attributes					
};


#endif // INC_RAWTCPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawtcp.cpp ===
/*****************************************************************************
 *
 * $Workfile: RawTCP.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "rawport.h"
#include "rawtcp.h"


///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

//DWORD CRawTcpInterface::m_dwProtocol = PROTOCOL_RAWTCP_TYPE;
//DWORD CRawTcpInterface::m_dwVersion = PROTOCOL_RAWTCP_VERSION;
static DWORD    dwRawPorts[] = { SUPPORTED_PORT_1,
                                         SUPPORTED_PORT_2,
                                         SUPPORTED_PORT_3,
                                         SUPPORTED_PORT_4 };


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::CRawTcpInterface()

CRawTcpInterface::
CRawTcpInterface(
    CPortMgr *pPortMgr
    ) : m_dwProtocol(PROTOCOL_RAWTCP_TYPE), m_dwPort(dwRawPorts),
        m_dwVersion(PROTOCOL_RAWTCP_VERSION), m_pPortMgr(pPortMgr)
{

    InitializeCriticalSection(&m_critSect);

}   // ::CRawTcpInterface()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::~CRawTcpInterface()

CRawTcpInterface::
~CRawTcpInterface(
    VOID
    )
{
    DeleteCriticalSection(&m_critSect);

}   // ::~CRawTcpInterface()


///////////////////////////////////////////////////////////////////////////////
//  Type --

DWORD
CRawTcpInterface::
Type(
    )
{
    return m_dwProtocol;

}   // ::Type()

///////////////////////////////////////////////////////////////////////////////
//  IsProtocolSupported --

BOOL
CRawTcpInterface::
IsProtocolSupported(
    const   DWORD   dwProtocol
    )
{
    return ( (m_dwProtocol == dwProtocol) ? TRUE : FALSE );

}   // ::IsProtocolSupported()


///////////////////////////////////////////////////////////////////////////////
//  IsVersionSupported --

BOOL
CRawTcpInterface::IsVersionSupported(
    const   DWORD dwVersion
    )
{
    return ( (m_dwVersion >= dwVersion) ? TRUE : FALSE );

}   // ::IsVersionSupported()

///////////////////////////////////////////////////////////////////////////////
//  GetRegistryEntry

BOOL
CRawTcpInterface::
GetRegistryEntry(
    IN      LPTSTR              psztPortName,
    IN      DWORD               dwVersion,
    IN      CRegABC             *pRegistry,
    OUT     RAWTCP_PORT_DATA_1  *pRegData1
    )
{
    BOOL    bRet = FALSE;
    BOOL    bKeySet = FALSE;
    DWORD   dSize, dwRet;

    memset( pRegData1, 0, sizeof(RAWTCP_PORT_DATA_1) );

    if ( dwRet = pRegistry->SetWorkingKey(psztPortName) )
        goto Done;

    bKeySet = TRUE;
    //
    // Get host name
    //
    dSize = sizeof(pRegData1->sztHostName);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HOSTNAME,
                                      (LPBYTE)pRegData1->sztHostName,
                                      &dSize) )
        goto Done;

    //
    // Get IP Address
    //
    dSize = sizeof(pRegData1->sztIPAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_IPADDR,
                                       (LPBYTE)pRegData1->sztIPAddress,
                                       &dSize) )
        goto Done;

    //
    // Get Hardware address
    //
    dSize = sizeof(pRegData1->sztHWAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HWADDR,
                                       (LPBYTE)pRegData1->sztHWAddress,
                                       &dSize) )
        goto Done;

    //
    // Get the port number (ex: 9100, 9101)
    //
    dSize = sizeof(pRegData1->dwPortNumber);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_PORTNUM,
                                       (LPBYTE)&(pRegData1->dwPortNumber),
                                       &dSize) )
        goto Done;

    //
    // Get SNMP status enabled flag
    //
    dSize = sizeof(pRegData1->dwSNMPEnabled);
    if ( dwRet = pRegistry->QueryValue(SNMP_ENABLED,
                                       (LPBYTE)&(pRegData1->dwSNMPEnabled),
                                       &dSize) )
        goto Done;

    //
    // Get SNMP device index
    //
    dSize = sizeof(pRegData1->dwSNMPDevIndex);
    if ( dwRet = pRegistry->QueryValue(SNMP_DEVICE_INDEX,
                                      (LPBYTE)&(pRegData1->dwSNMPDevIndex),
                                      &dSize) )
        goto Done;

    //
    // Get SNMP community
    //
    dSize = sizeof(pRegData1->sztSNMPCommunity);
    if ( dwRet = pRegistry->QueryValue(SNMP_COMMUNITY,
                                       (LPBYTE)&(pRegData1->sztSNMPCommunity),
                                       &dSize) )
        goto Done;

    bRet = TRUE;

    Done:
       if ( bKeySet )
           pRegistry->FreeWorkingKey();

       if ( !bRet )
           SetLastError(dwRet);


    return bRet;

}   // GetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CRawTcpInterface::CreatePort(
    IN      DWORD           dwProtocol,
    IN      DWORD           dwVersion,
    IN      PPORT_DATA_1    pData,
    IN      CRegABC         *pRegistry,
    OUT     CPortRefABC     **pPort )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    //
    // is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocol) ) {

        dwRetCode = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    //
    // Is the version supported??
    //
    if ( !IsVersionSupported(dwVersion) ) {

        dwRetCode = ERROR_INVALID_LEVEL;
        goto Done;
    }

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_RAWTCP_VERSION: {

            CRawTcpPort *pRawTcpPort = new CRawTcpPort( pData->sztPortName,
                                                        pData->sztHostAddress,
                                                        pData->dwPortNumber,
                                                        pData->dwSNMPEnabled,
                                                        pData->sztSNMPCommunity,
                                                        pData->dwSNMPDevIndex,
                                                        pRegistry,
                                                        m_pPortMgr);
            if (pRawTcpPort) {
                pRawTcpPort->SetRegistryEntry(pData->sztPortName,
                                              dwProtocol,
                                              dwVersion,
                                              (LPBYTE)pData );
                *pPort = pRawTcpPort;
            } else {
                pPort = NULL;
            }
            break;
        }

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;

    }   // end::switch

Done:
    ExitCSection();

    return dwRetCode;
}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CRawTcpInterface::
CreatePort(
    IN      LPTSTR      psztPortName,
    IN      DWORD       dwProtocolType,
    IN      DWORD       dwVersion,
    IN      CRegABC     *pRegistry,
    OUT     CPortRefABC **pPort
    )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    EnterCSection();

    if ( !IsProtocolSupported(dwProtocolType) ) {
        dwRetCode = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    if ( !IsVersionSupported(dwVersion) ) {

        dwRetCode = ERROR_INVALID_LEVEL;
        goto Done;
    }

    switch (dwVersion) {

        case    PROTOCOL_RAWTCP_VERSION: {

            RAWTCP_PORT_DATA_1  regData1;

            //
            // read the registry entry & parse the data
            // then call the CRawTcpPort
            //
            if ( !GetRegistryEntry(psztPortName,
                                   dwVersion,
                                   pRegistry,
                                   &regData1) ) {

                if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                    dwRetCode = STG_E_UNKNOWN;
                    goto Done;
            }

            //
            // fill in the port name
            //
            _tcscpy(regData1.sztPortName, psztPortName);
            *pPort = new CRawTcpPort(
                                               regData1.sztPortName,
                                               regData1.sztHostName,
                                               regData1.sztIPAddress,
                                               regData1.sztHWAddress,
                                               regData1.dwPortNumber,
                                               regData1.dwSNMPEnabled,
                                               regData1.sztSNMPCommunity,
                                               regData1.dwSNMPDevIndex,
                                               pRegistry,
                                               m_pPortMgr);

                bRet = TRUE;
            break;
        }

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;

    }   // end::switch

Done:
    ExitCSection();

    if ( !bRet && (dwRetCode = GetLastError()) != ERROR_SUCCESS )
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;


    return dwRetCode;
}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

void
CRawTcpInterface::
EnterCSection()
{
    EnterCriticalSection(&m_critSect);

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

void
CRawTcpInterface::
ExitCSection()
{
    LeaveCriticalSection(&m_critSect);
}   //  ::ExitCSection()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawport.cpp ===
/*****************************************************************************
 *
 * $Workfile: rawport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "rawdev.h"
#include "tcpjob.h"
#include "rawtcp.h"
#include "rawport.h"

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::CRawTcpPort()  -- called when creating a new port through the UI

CRawTcpPort::CRawTcpPort( LPTSTR    IN      psztPortName,
                          LPTSTR    IN      psztHostAddress,
                          DWORD     IN      dPortNum,
                          DWORD     IN      dSNMPEnabled,
                          LPTSTR    IN      sztSNMPCommunity,
                          DWORD     IN      dSNMPDevIndex,
                          CRegABC   IN      *pRegistry,
                          CPortMgr  IN      *pPortMgr) :
                                CTcpPort(psztPortName, psztHostAddress,
                                dPortNum, dSNMPEnabled, sztSNMPCommunity,
                                dSNMPDevIndex, pRegistry, pPortMgr)
{
// Let the base class do the work;
}   // ::CRawTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::CRawTcpPort() -- called when creating a new port through the
//      registry entries.

CRawTcpPort::CRawTcpPort( LPTSTR    IN      psztPortName,
                          LPTSTR    IN      psztHostName,
                          LPTSTR    IN      psztIPAddr,
                          LPTSTR    IN      psztHWAddr,
                          DWORD     IN      dPortNum,
                          DWORD     IN      dSNMPEnabled,
                          LPTSTR    IN      sztSNMPCommunity,
                          DWORD     IN      dSNMPDevIndex,
                          CRegABC   IN      *pRegistry,
                          CPortMgr  IN      *pPortMgr ) :
                                CTcpPort( psztPortName, psztHostName,
                                psztIPAddr, psztHWAddr, dPortNum, dSNMPEnabled,
                                sztSNMPCommunity, dSNMPDevIndex,  pRegistry, pPortMgr)
{
// Let The base class do the work;
}   // ::CRawTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::~CRawTcpPort()
//      Called by CPortMgr when deleting a port

CRawTcpPort::~CRawTcpPort()
{
    //
    // Delete the job class first because it access the device class.
    //
    if (m_pJob)
    {
        delete m_pJob;
        m_pJob = NULL;
    }
    if (m_pDevice)
    {
        delete m_pDevice;
        m_pDevice = NULL;
    }

}   // ::~CPort


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CRawTcpPort::StartDoc( const LPTSTR in psztPrinterName,
                       const DWORD  in jobId,
                       const DWORD  in level,
                       const LPBYTE in pDocInfo )
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT3(_CRT_WARN,
          "PORT -- (CRawPort)StartDoc called for (%S,%S) w/ jobID %d\n",
          psztPrinterName, m_szName, jobId);

    if( m_pJob == NULL ) {

        //
        // Create a new job
        //
        m_pJob = new CTcpJob(psztPrinterName, jobId, level, pDocInfo, this, CTcpJob::kRawJob);
        if ( m_pJob ) {

            if ( (dwRetCode = m_pJob->StartDoc()) != NO_ERROR ) {

                //
                // startdoc failed
                //
                delete m_pJob;
                m_pJob = NULL;
            }
        } else {

            dwRetCode = ERROR_OUTOFMEMORY;
        }
    } else {

        _ASSERTE(m_pJob == NULL);
        dwRetCode = STG_E_UNKNOWN;
    }

    return (dwRetCode);

}   // ::StartDoc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\regabc.h ===
/*****************************************************************************
 *
 * $Workfile: RegABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_REGABC_H
#define INC_REGABC_H

//////////////////////////////////////////////////////////////////////////////
// registry settings

#define	DEFAULT_STATUSUPDATE_INTERVAL		10L			// 10 minutes
#define DEFAULT_STATUSUPDATE_ENABLED		TRUE		

// port manager entries
#define	PORTMONITOR_STATUS_INT		TEXT("StatusUpdateInterval")
#define	PORTMONITOR_STATUS_ENABLED  TEXT("StatusUpdateEnabled")

// per port entries
#define	PORTMONITOR_PORT_PROTOCOL    TEXT("Protocol")
#define	PORTMONITOR_PORT_VERSION     TEXT("Version")

// Port Key
#define	PORTMONITOR_PORTS			TEXT("Ports")
#define REG_CLASS					TEXT("STDTCPMON")

class CPortMgr;

class CRegABC
{
public:
//	CRegistry();
//	CRegistry(	CPortMgr  *pParent);
//	CRegistry(	const LPTSTR	pRegisterRoot, 
//				      CPortMgr  *pParent);
//	~CRegistry();

	virtual DWORD EnumeratePorts(CPortMgr *pPortMgr) = 0;

	virtual DWORD SetPortMgrSettings(const DWORD  dStatusUpdateInterval,
							         const BOOL	  bStatusUpdateEnabled ) = 0;

	virtual DWORD GetPortMgrSettings(DWORD  *dStatusUpdateInterval,
									 BOOL   *bStatusUpdateEnabled ) = 0;

	virtual DWORD SetWorkingKey( LPCTSTR	lpKey) = 0;

	virtual DWORD SetValue( LPCTSTR lpValueName,
								DWORD dwType, 
								CONST BYTE *lpData, 
								DWORD cbData ) = 0; 

	virtual DWORD QueryValue(LPTSTR lpValueName, 
							 LPBYTE  lpData, 
								 LPDWORD lpcbData ) = 0; 

	virtual DWORD FreeWorkingKey() = 0;

	virtual BOOL DeletePortEntry( LPTSTR in psztPortName) = 0;

};

#endif // INC_REGABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpjob.h ===
/*****************************************************************************
 *
 * $Workfile: tcpjob.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPJOB_H
#define INC_TCPJOB_H

#include "jobABC.h"

#define	DEFAULT_TIMEOUT_DELAY		10000L		// 10 sec
#define DEFAULT_CONNECT_DELAY		5000L		// 5 Sec
#define CONNECT_TIMEOUT				60L			// 60 Sec

#define WAIT_FOR_ACK_TIMEOUT        5*60        // 5 minutes
#define WAIT_FOR_ACK_INTERVAL       5           // 5 seconds

#define WRITE_TIMEOUT               90 * 1000   // 90 seconds
#define WRITE_CHECK_INTERVAL        5  * 1000   // 5 seconds

#define STATUS_CONNECTED            0x01
#define STATUS_ABORTJOB             0x02

class CTcpPort;		
class CMemoryDebug;

class CTcpJob : public CJobABC
#if defined _DEBUG || defined DEBUG
	, public CMemoryDebug
#endif
{
public:
    enum EJobType
    {
        kRawJob,
        kLPRJob
    };

    CTcpJob();
    CTcpJob(LPTSTR      psztPrinterName,
            DWORD       jobId,
            DWORD       level,
            LPBYTE      pDocInfo,
            CTcpPort   *pParent,
            EJobType    kJobType);
    ~CTcpJob();

    virtual DWORD
    Write(
        LPBYTE  pBuffer,
        DWORD	  cbBuf,
          LPDWORD pcbWritten);

    virtual DWORD	
    StartDoc();

    virtual DWORD	
    EndDoc();

protected:
    VOID	Restart();
    DWORD	SetStatus(DWORD	dwStatus);
    BOOL    IsJobAborted(VOID);

    //
    // Member variables
    //
    CTcpPort	*m_pParent;
    DWORD   m_dwFlags;
    DWORD   m_dJobId;
    DWORD   m_cbSent;        // count of bytes sent

    TCHAR	m_sztPrinterName[MAX_PRINTERNAME_LEN];		
    HANDLE	m_hPrinter;		// printer handle

    LPBYTE	m_pDocInfo;
    DWORD	m_dwCurrJobStatus;

private:
    DWORD   WaitForAllPendingDataToBeSent(DWORD       dwEndTime,
                                          LPDWORD     pcbPending);

    EJobType    m_kJobType;
};


#endif // INC_TCPJOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HPSPPMon.rc
//
#define     IDS_STRING_SPOOLING                             1001
#define     IDS_STRING_PRINTING                             1002
#define     IDS_STRING_ERROR_OR_BUSY                        1003
#define     IDS_DISK_FULL                   2044

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpjob.cpp ===
/*****************************************************************************
 *
 * $Workfile: tcpjob.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "tcpport.h"
#include "tcpjob.h"
#include "rawdev.h"

///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::CTcpJob()

CTcpJob::CTcpJob()
{
    m_pParent = NULL;

}   // ::CTcpJob()


///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::CTcpJob()
//      Called by CPort when StartDocPort is called
//  FIX: necessary constructors for creating new jobs

CTcpJob::CTcpJob(LPTSTR in psztPrinterName,
                 DWORD  in jobId,
                 DWORD  in level,
                 LPBYTE  in pDocInfo,
                 CTcpPort   in *pParent,
                 EJobType in kJobType) :
    m_pParent(pParent), m_dJobId(jobId), m_dwFlags(0),
    m_hPrinter(NULL), m_dwCurrJobStatus(0), m_cbSent(0), m_pDocInfo(pDocInfo),
    m_kJobType (kJobType)
{
    lstrcpyn(m_sztPrinterName, psztPrinterName, MAX_PRINTERNAME_LEN);
}   // ::CTcpJob()


///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::~CTcpJob()
//      Called by CPort when EndDocPort is called
//  FIX: clean up CTcpJob

CTcpJob::~CTcpJob()
{
    if ( m_dwFlags & STATUS_CONNECTED ) {
        (m_pParent->GetDevice())->Close();      // close device connection
    }

    if ( m_hPrinter ) {
        //
        // Quit before the job was done.
        //
        ClosePrinter( m_hPrinter );
        m_hPrinter = NULL;
    }

}   // ::~CTcpJob()


BOOL
CTcpJob::
IsJobAborted(
    VOID
    )
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) LocalAlloc(LPTR, dwNeeded))       ||
         !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
 )
        goto Done;

    bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
           (pJobInfo->Status & JOB_STATUS_DELETED);

    //
    //  The previous code treated restart as cancel, which caused big restarted job
    //  being aborted, so let's remove the following
    //
    //  (pJobInfo->Status & JOB_STATUS_RESTART);
    //

Done:
    if ( pJobInfo )
        LocalFree(pJobInfo);

    return bRet;
}


DWORD
CTcpJob::WaitForAllPendingDataToBeSent(
    DWORD       dwEndTime,
    LPDWORD     pcbPending
    )
{
    DWORD   dwRet = NO_ERROR;

    *pcbPending = 0;

    do {

        //
        // From WritePort or EndDocPort?
        //
        if ( dwEndTime != INFINITE ) {

            //
            // If we hit the timeout need to return to spooler
            //
            if ( GetTickCount() >= dwEndTime ) {

                dwRet = WSAEWOULDBLOCK;
                //
                // This means our write is timing out. To guarantee users can
                // delete jobs within the WRITE_TIMEOUT period, and more
                // importantly we can shutdown the cluster we should not
                // wait any longer to close the connection if spooler has
                // marked the job for aborting
                //
                if ( IsJobAborted() )
                    m_dwFlags |= STATUS_ABORTJOB;
                goto Done;
            }
        } else {

            //
            // During EndDoc if job is deleted no need to wait. Last WritePort
            // would have already waited for timeout period
            //
            if ( IsJobAborted() ) {

                dwRet = ERROR_PRINT_CANCELLED;
                goto Done;
            }
        }


        dwRet = m_pParent->GetDevice()->PendingDataStatus(
                                    WRITE_CHECK_INTERVAL, pcbPending);


        //
        //  If it is a LPR job, we need to check if there is anything
        //  coming back in the middle of writing.
        //
        if (m_kJobType == kLPRJob && dwRet == ERROR_SUCCESS && *pcbPending != 0)
        {
            //
            // This is the loop condition, we need to check if there is anything to
            // receive, if so, we need to set the correct return code and break the
            // loop
            //

            //
            // Check if there is any data to receive
            //
            if (NO_ERROR == m_pParent->GetDevice()->ReadDataAvailable ()) {

                //
                //  This is the case where there are more pending data
                //  to wait, so we must set the return code to WSAEWOULDBLOCK
                //
                dwRet = WSAEWOULDBLOCK;
            }
        }

    } while ( dwRet == ERROR_SUCCESS && *pcbPending != 0 );

Done:
    return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
//  Write -- Called by CPort->Write()
//      Error codes:
//          NO_ERROR if no error
//          TIMEOUT if timed out
//  FIX: setup Write operation & error codes

DWORD
CTcpJob::Write( LPBYTE  in      pBuffer,
                DWORD   in      cbBuf,
                LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR, dwPending, dwEndTime;

    *pcbWritten = 0;

    if ( m_dwFlags & STATUS_ABORTJOB )
        return ERROR_PRINT_CANCELLED;

    if ( !(m_dwFlags & STATUS_CONNECTED) ) {

        Restart();
        dwRetCode = ERROR_PRINT_CANCELLED;
        goto Done;
    }

    dwEndTime = GetTickCount() + WRITE_TIMEOUT;

    //
    // First check for any pending I/O from last call to Write
    //
    dwRetCode = WaitForAllPendingDataToBeSent(dwEndTime, &dwPending);

    if ( dwRetCode != ERROR_SUCCESS )
        goto Done;

    _ASSERTE(dwPending == 0);

    dwRetCode = (m_pParent->GetDevice())->Write(pBuffer, cbBuf, pcbWritten);

    m_cbSent += *pcbWritten;

    if ( dwRetCode == NO_ERROR ) {

        SetStatus(JOB_STATUS_PRINTING);
        dwRetCode = WaitForAllPendingDataToBeSent(dwEndTime, &dwPending);
    }


Done:
    if ( dwRetCode != ERROR_SUCCESS ) {

        SetStatus(JOB_STATUS_ERROR);

        //
        // This would cause job to be restarted
        //
        if ( dwRetCode != WSAEWOULDBLOCK )
            m_dwFlags &= ~STATUS_CONNECTED;
    }

    return dwRetCode;
}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  StartDoc -- connects to the device. If the connect failes, it retries
//
//      Error Codes -- FIX
//          NO_ERROR if no error
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CTcpJob::StartDoc()
{
    DWORD   dwRetCode = NO_ERROR;
    time_t  lStartConnect = time( NULL );

    if ( !m_hPrinter && !OpenPrinter(m_sztPrinterName, &m_hPrinter, NULL) )
        return GetLastError();

    if ( m_dwFlags & STATUS_CONNECTED ) {

        m_dwFlags &= ~STATUS_CONNECTED;
        m_pParent->GetDevice()->Close();
    }

    do {

        if ( (dwRetCode = (m_pParent->GetDevice())->Connect()) == NO_ERROR ) {

            m_dwFlags  |= STATUS_CONNECTED;
            goto Done;
        }

        //
        // Map known errors to meaningful messages
        //
        if ( dwRetCode == ERROR_INVALID_PARAMETER )
            dwRetCode = ERROR_BAD_NET_NAME;     // bad network name

        //
        // We will try a job for upto CONNECT_TIMEOUT time without retry/cancel
        // but checking for the case user decided to restart the job
        //
        if ( time(NULL) > lStartConnect + CONNECT_TIMEOUT )
            goto Done;

        if ( IsJobAborted() ) {

            dwRetCode = ERROR_PRINT_CANCELLED;
            break;
        }
        Sleep(DEFAULT_CONNECT_DELAY);
    } while ( TRUE );

Done:
    if ( dwRetCode != NO_ERROR )
        SetStatus(JOB_STATUS_ERROR);

    m_cbSent = 0;

    return dwRetCode;

}   //  :: StartDoc()

///////////////////////////////////////////////////////////////////////////////
//  EndDoc -- closes the previous connection w/ device
//  Error Codes:
//      NO_ERROR if successful

DWORD
CTcpJob::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR, dwWaitTime, dwPending;

    if ( !(m_dwFlags & STATUS_ABORTJOB) )
        dwRetCode = WaitForAllPendingDataToBeSent(INFINITE, &dwPending);
    else
        dwRetCode = ERROR_PRINT_CANCELLED;

    //
    // Unless the job got cancelled we need to wait for ACK from printer
    // to complete the job ok
    //
    if ( m_cbSent != 0  && dwRetCode == ERROR_SUCCESS ) {

        for ( dwWaitTime = 0 ;
              !IsJobAborted() && dwWaitTime < WAIT_FOR_ACK_TIMEOUT ;
              dwWaitTime += WAIT_FOR_ACK_INTERVAL ) {

            dwRetCode = m_pParent->GetDevice()->GetAckBeforeClose(WAIT_FOR_ACK_INTERVAL);

            //
            // Normal case is ERROR_SUCCESS
            // WSAEWOULDBLOCK means printer is taking longer to process the job
            // other cases mean we need to resubmit the job. If the other side simply
            // resets the connection, however, since we have made sure we have sent all of
            // the data (if we are not aborting the job), then we shouldn't restart it.
            //
            if ( dwRetCode == ERROR_SUCCESS || dwRetCode == WSAECONNRESET)
                break;
            else if ( dwRetCode != WSAEWOULDBLOCK ) {

                Restart();
                break;
            }
        }
    }

    dwRetCode = (m_pParent->GetDevice())->Close();      // close device connection
    m_dwFlags &= ~STATUS_CONNECTED;

    // delete the job from the spooler
    if (m_hPrinter)
    {

        //
        // Clear any job bits we set before
        //
        SetStatus(0);

        SetJob( m_hPrinter, m_dJobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER );
        ClosePrinter(m_hPrinter);
        m_hPrinter = NULL;
    }

    return dwRetCode;
}   //  ::EndDoc()


///////////////////////////////////////////////////////////////////////////////
//  SetStatus -- gets & sets the printer job status
//
DWORD
CTcpJob::SetStatus( DWORD   in  dwStatus )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD               cbNeeded = 0;
    JOB_INFO_1  *pJobInfo;

    if( m_dwCurrJobStatus != dwStatus ) {

        //
        // We need to kick off SNMP status
        // Also this gets called at the first write of the job so the status
        // thread knows it needs to wake up earlier than 10 minutes
        //
        CDeviceStatus::gDeviceStatus().SetStatusEvent();

        m_dwCurrJobStatus = dwStatus;

        // Get the current job info.  Use this info to set the new job status.
        GetJob( m_hPrinter, m_dJobId, 1, NULL, 0, &cbNeeded );

        if( pJobInfo = (JOB_INFO_1 *)malloc( cbNeeded ) )
        {
            if (GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, cbNeeded, &cbNeeded))
            {
                pJobInfo->Position = JOB_POSITION_UNSPECIFIED;
                pJobInfo->Status = dwStatus;

                SetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, 0);
            }
            free( pJobInfo );
        }
    }

    return dwRetCode;

}   // ::SetStatus()

///////////////////////////////////////////////////////////////////////////////
//  Restart -- restarts the job
//
void
CTcpJob::Restart()
{
    if ( m_hPrinter && (m_dJobId != 0) )
    {// FIX check the return code of the set job
        SetJob(m_hPrinter, m_dJobId, 0, NULL, JOB_CONTROL_RESTART);

        _RPT1(_CRT_WARN, "TcpJob -- Restarting the Job (ID %d)\n", m_dJobId );

    }

}   // ::Restart()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawtcp.h ===
/*****************************************************************************
 *
 * $Workfile: RawTCP.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_RAWTCP_H
#define INC_RAWTCP_H

#include "ipdata.h"
#include "rtcpdata.h"
#include "regabc.h"

#define	MAX_SUPPORTED_PORTS			4
#define SUPPORTED_PORT_1			9100
#define SUPPORTED_PORT_2			9101
#define SUPPORTED_PORT_3			9102
#define SUPPORTED_PORT_4			2501

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations


class	CPortRefABC;


// the interface for CRawTcpInterface class
class CRawTcpInterface
#if defined _DEBUG || defined DEBUG
//	, public CMemoryDebug
#endif
{
public:
    CRawTcpInterface(CPortMgr *pPortMgr);
    ~CRawTcpInterface();

    DWORD	Type();									// supported protocol information
    BOOL	IsProtocolSupported( DWORD	dwProtocol );
    BOOL	IsVersionSupported( DWORD dwVersion);

    DWORD	CreatePort( DWORD			dwProtocolType,					// port related functions
						DWORD			dwVersion,
						PPORT_DATA_1	pData,
						CRegABC			*pRegistry,
						CPortRefABC	    **pPort );					
    DWORD	CreatePort( LPTSTR		psztPortName,
						DWORD		dwProtocolType,				
						DWORD		dwVersion,
						CRegABC		*pRegistry,
						CPortRefABC	**pPort );					

    VOID	EnterCSection();
    VOID	ExitCSection();


protected:

    BOOL    GetRegistryEntry(LPTSTR		psztPortName,
							 DWORD	in	dwVersion,
                             CRegABC *pRegistry,
							 RAWTCP_PORT_DATA_1	in	*pRegData1
							 );


    DWORD	            *m_dwPort;
    DWORD	            m_dwProtocol;			// protocol type
    DWORD	            m_dwVersion;			// supported version
    CPortMgr            *m_pPortMgr;            // Port Manager that created this
private:
    CRITICAL_SECTION	m_critSect;

};	// class CRawTcpInterface


#endif	// INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpmon.cpp ===
/*****************************************************************************
 *
 * $Workfile: TcpMon.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company & Microsoft.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/
#include "precomp.h"    // pre-compiled header
#include "event.h"
#include "portmgr.h"
#include "message.h"



///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

#ifndef MODULE

#define MODULE "TCPMON: "

#endif


#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_PORT, DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif

HINSTANCE                       g_hInstance = NULL;
CPortMgr                        *g_pPortMgr = NULL;

int g_cntGlobalAlloc=0;         // used for debugging purposes
int g_csGlobalCount=0;

// TcpMib Library Instance
HINSTANCE       g_hTcpMib = NULL;
HINSTANCE   g_hSpoolLib = NULL;
SETPORTPARAM g_pfnSetPort = NULL;
ENUMPORTPARAM g_pfnEnumPorts = NULL;

///////////////////////////////////////////////////////////////////////////////
//  DllMain
//

BOOL APIENTRY 
DllMain (       HANDLE in hInst,                                
            DWORD  in dwReason,                     
            LPVOID in lpReserved )
{
    WSADATA wsaData;

    switch (dwReason) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInst );

//          InitDebug(MON_DEBUG_FILE);            // initialize debug file

            g_hInstance = (HINSTANCE) hInst;

            // Start up Winsock.
            if ( WSAStartup(WS_VERSION_REQUIRED, (LPWSADATA)&wsaData) != NO_ERROR)
            {
                _RPT1(_CRT_WARN, "CSSOCKET -- CStreamSocket() WSAStartup failed! Error( %d )\n", WSAGetLastError());
                return FALSE;
            }

            // See if the DLL and the app each support a common version.
            // Check to make sure that the version the DLL returns in wVersion
            // is at least enough to satisfy the applications needs.
            if ( HIBYTE(wsaData.wVersion) < WS_VERSION_MINOR ||
                (HIBYTE(wsaData.wVersion) == WS_VERSION_MAJOR &&
                 LOBYTE(wsaData.wVersion) < WS_VERSION_MINOR) )
            {
                _RPT0(_CRT_WARN, "CSSOCKET -- CStreamSocket()  -- DLL version not supported\n");
                return FALSE;
            }

            g_hSpoolLib = ::LoadLibrary(TEXT("spoolss.dll"));
            if(g_hSpoolLib == NULL)
            {               
                _RPT0(_CRT_WARN, "spoolss.dll Not Found\n");
                return FALSE;
            }       

            // Note that these can be NULL we accept this here and check later
            // When they are used.  
            g_pfnSetPort = (SETPORTPARAM)::GetProcAddress(g_hSpoolLib, "SetPortW");
            g_pfnEnumPorts = (ENUMPORTPARAM)::GetProcAddress(g_hSpoolLib, "EnumPortsW");

            // startup the event log
            EventLogOpen( SZEVENTLOG_NAME, LOG_SYSTEM, TEXT("%SystemRoot%\\System32\\tcpmon.dll") );        
        
            return TRUE;

        case DLL_PROCESS_DETACH:
            if (WSACleanup() == SOCKET_ERROR)
            {
                EVENT_LOG0(EVENTLOG_INFORMATION_TYPE, SOCKETS_CLEANUP_FAILED);
            }

            if( g_hTcpMib != NULL )
            {
                FreeLibrary(g_hTcpMib);
            }

            if( g_hSpoolLib != NULL )
            {
                FreeLibrary(g_hSpoolLib);
            }
            DeInitDebug();          // close the debug file

            EventLogClose();        // close the event log

            return TRUE;

    }

    return FALSE;

}       // DllMain()


///////////////////////////////////////////////////////////////////////////////
//  ValidateHandle -- Checks to see if the handle is for an HP Port
//      Error codes:    
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
ValidateHandle(
    IN      HANDLE      handle)
{
    PHPPORT pHPPort = (PHPPORT) handle;
    DWORD   dwRetCode = NO_ERROR;

    //
    // verify the port handle & the signature
    //

    if (!pHPPort || 
        IsBadReadPtr (pHPPort, sizeof (PHPPORT)) ||
        pHPPort->dSignature != HPPORT_SIGNATURE) {
        
        dwRetCode = ERROR_INVALID_HANDLE;

    } 

    return dwRetCode;
}   // ::ValidateHandle()


///////////////////////////////////////////////////////////////////////////////
//  InitializePrintMonitor2
//              Returns a MONITOR2 structure or NULL if failure
//      Error Codes:
//              

LPMONITOR2 
InitializePrintMonitor2( PMONITORINIT pMonitorInit,
                         PHANDLE      phMonitor )
{
    DWORD           dwRetCode=NO_ERROR;
    LPMONITOR2      pMonitor2 = NULL;
    CPortMgr        *pPortMgr = NULL;
    //
    // Create the port manager if necessary
    //
    pPortMgr = new CPortMgr();    // create the port manager object
    if (!pPortMgr) 
    {
        goto Done;
    }

    dwRetCode = pPortMgr->InitializeRegistry( 
                            pMonitorInit->hckRegistryRoot,
                            pMonitorInit->hSpooler,
                            pMonitorInit->pMonitorReg, 
                            pMonitorInit->pszServerName);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
    } else {
        dwRetCode = pPortMgr->InitializeMonitor();
        if (dwRetCode != NO_ERROR) {
            SetLastError(dwRetCode);
        } else {
            dwRetCode = EncodeMonitorHandle( phMonitor, pPortMgr );
            if( dwRetCode != NO_ERROR ) {
                SetLastError(dwRetCode);
            } else {
                pPortMgr->InitMonitor2( &pMonitor2 );
            }
        }
    }
Done:
    return (pMonitor2);

}       // InitializePrintMonitor()

///////////////////////////////////////////////////////////////////////////////
//  EncodeMoniorHandle -- Encodes the monitor handle
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
EncodeMonitorHandle(
    PHANDLE phHandle,
    CPortMgr *pPortMgr
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PMONITOR_HANDLE phMonitor = NULL;

    size_t size = sizeof(MONITOR_HANDLE);
    if ( phMonitor = (PMONITOR_HANDLE) LocalAlloc( LPTR, sizeof(MONITOR_HANDLE) ) ) {

        phMonitor->cb = sizeof(MONITOR_HANDLE);
        phMonitor->dSignature = MONITOR_SIGNATURE;
        phMonitor->pPortMgr = pPortMgr;

        *phHandle = phMonitor;
    }  else {

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRetCode;
}   // ::EncodeMonitorHandle()

///////////////////////////////////////////////////////////////////////////////
//  ValidateMonitorHandle -- Checks to see if the handle is valid
//      Error codes:    
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
ValidateMonitorHandle(
    IN      HANDLE      hMonitor
    )
{
    PMONITOR_HANDLE pMonitor = (PMONITOR_HANDLE) hMonitor;
    DWORD   dwRetCode = NO_ERROR;

    if ( pMonitor )  {

        if ( pMonitor->dSignature != MONITOR_SIGNATURE ) {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    } else  {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return dwRetCode;
}   // ::ValidateMonitorHandle()


///////////////////////////////////////////////////////////////////////////////
//  FreeHandle -- Frees the monitor handle
//      Error codes:
//          NO_ERROR if success

DWORD
FreeMonitorHandle(
    HANDLE hMonitor
    )
{
    DWORD   dwRetCode = NO_ERROR;

    LocalFree( hMonitor );

    return( dwRetCode );
}   // ::FreeHandle()

///////////////////////////////////////////////////////////////////////////////
//  ClosePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid

BOOL
ClosePort( HANDLE in hPort )
{
    DWORD           dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)      
        dwRetCode = g_pPortMgr->ClosePort(hPort);

    if (dwRetCode != NO_ERROR) 
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // ClosePort()


///////////////////////////////////////////////////////////////////////////////
//  StartDocPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid
//              ERROR_BUSY if the requested port is already busy
//              ERROR_WRITE_FAULT       if Winsock returns WSAECONNREFUSED
//              ERROR_BAD_NET_NAME   if cant' find the printer on the network

BOOL WINAPI
StartDocPort(   HANDLE in hPort,                        // handle of the port the job sent to
                LPTSTR in psztPrinterName,      // name of the printer the job sent to
                DWORD  in JobId,                        // ids the job
                DWORD  in Level,        // level of the struct pointed by pDocInfo
                LPBYTE in pDocInfo)     // points to DOC_INFO_1 or DOC_INFO_2 structure
 {
    DWORD   dwRetCode = NO_ERROR;
    
    if ( Level != 1 ) {

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)      
        
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->StartDocPort(hPort, 
                                                    psztPrinterName, 
                                                    JobId, 
                                                    Level, 
                                                    pDocInfo);
    if (dwRetCode != NO_ERROR)      
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // StartDocPort()


///////////////////////////////////////////////////////////////////////////////
//  WritePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid

BOOL
WritePort(      HANDLE  in              hPort,
            LPBYTE  in              pBuffer,
            DWORD   in              cbBuf,
            LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);
    
    if (dwRetCode == NO_ERROR)      
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->WritePort(hPort, 
                                                          pBuffer, 
                                                          cbBuf, 
                                                          pcbWritten);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    
    return TRUE;

}       // WritePort()


///////////////////////////////////////////////////////////////////////////////
//  ReadPort
//              Returns TRUE if success, FALSE otherwise
//      Note: ReadPort() function is not supported

BOOL 
ReadPort(       HANDLE  in              hPort,
            LPBYTE  inout   pBuffer,
            DWORD   in              cbBuffer,
            LPDWORD inout   pcbRead)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)      
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->ReadPort(hPort, 
                                                pBuffer, 
                                                cbBuffer, 
                                                pcbRead);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // ReadPort()


///////////////////////////////////////////////////////////////////////////////
//  EndDocPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid

BOOL WINAPI
EndDocPort( HANDLE in hPort)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);
    
    if (dwRetCode == NO_ERROR)      
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->EndDocPort(hPort);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    
    return TRUE;

}       // EndDocPort()

///////////////////////////////////////////////////////////////////////////////
//  EnumPorts
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_LEVEL             if level is not supported
//              ERROR_INVALID_HANDLE            if the passed in pointers are invalid
//              ERROR_INSUFFICIENT_BUFFER       if buffer size is small

BOOL WINAPI
EnumPorts(      LPTSTR  in              psztName,
            DWORD   in              Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
            LPBYTE  inout   pPorts, // port data is written to
            DWORD   inout   cbBuf,  // buffer size of pPorts points to
            LPDWORD inout   pcbNeeded,      // needed buffer size
            LPDWORD inout   pcReturned)     // number of structs written to pPorts
{
    DWORD   dwRetCode = NO_ERROR;
    
    dwRetCode = g_pPortMgr->EnumPorts(psztName, Level, pPorts, cbBuf, pcbNeeded, 
                                      pcReturned);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // EnumPorts()


///////////////////////////////////////////////////////////////////////////////
//  XcvOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_NOT_SUPPORTED if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

BOOL
XcvOpenPort( LPCTSTR     in             pszObject,
             ACCESS_MASK in         GrantedAccess,
             PHANDLE         out    phXcv)
{
    DWORD dwRetCode = NO_ERROR;

    dwRetCode = g_pPortMgr->XcvOpenPort(pszObject, GrantedAccess, phXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvOpenPort()


///////////////////////////////////////////////////////////////////////////////
//  XcvClosePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE if handle is invalid

BOOL
XcvClosePort( HANDLE in hXcv )
{
    DWORD dwRetCode = NO_ERROR;

    dwRetCode = g_pPortMgr->XcvClosePort(hXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvClosePort()


///////////////////////////////////////////////////////////////////////////////
//  XcvDataPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_BAD_COMMAND if the pszDataName is not supported
//              ERROR_INSUFFICIENT_BUFFER if buffer size is invalid
//              ACCESS_DENIED if doesn't have sufficient rights
//              ERROR_INVALID_HANDLE if the handle is invalid

DWORD
XcvDataPort(HANDLE in       hXcv,
            PCWSTR in       pszDataName,
            PBYTE  in       pInputData,
            DWORD  in       cbInputData,
            PBYTE  out      pOutputData,
            DWORD  out      cbOutputData,
            PDWORD out      pcbOutputNeeded)
{
    DWORD dwRetCode = NO_ERROR;
    
    
    _ASSERTE(hXcv != NULL && hXcv != INVALID_HANDLE_VALUE); 
    
    if (hXcv == NULL || hXcv == INVALID_HANDLE_VALUE) {
        dwRetCode = ERROR_INVALID_HANDLE;
    } else {
        // These should be never be possible except from a bad spooler or another bad port monitor

        dwRetCode = ((PHPPORT)hXcv)->pPortMgr->XcvDataPort(hXcv, 
                                    pszDataName, 
                                    pInputData, 
                                    cbInputData, 
                                    pOutputData, 
                                    cbOutputData, 
                                    pcbOutputNeeded);
    }

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
    }

    return( dwRetCode );


} // XcvDataPort()


//
//
// Clustering EntryPoints
//
//

///////////////////////////////////////////////////////////////////////////////
//  ClusterOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_PARAMETER if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null

BOOL
ClusterOpenPort( HANDLE hMonitor,
                LPTSTR  in    psztPName, 
          PHANDLE inout pHandle)
{
    DWORD   dwRetCode = NO_ERROR;

    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->OpenPort(psztPName, 
                                                               pHandle);
    if (dwRetCode != NO_ERROR) 
    {       
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // ClusterOpenPort()

///////////////////////////////////////////////////////////////////////////////
//  ClusterEnumPorts
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_LEVEL             if level is not supported
//              ERROR_INVALID_HANDLE            if the passed in pointers are invalid
//              ERROR_INSUFFICIENT_BUFFER       if buffer size is small

BOOL
ClusterEnumPorts( HANDLE     in     hMonitor,
                     LPTSTR  in     psztName,
                     DWORD   in     Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
                     LPBYTE  inout  pPorts, // port data is written to
                     DWORD   inout  cbBuf,  // buffer size of pPorts points to
                     LPDWORD inout  pcbNeeded,      // needed buffer size
                     LPDWORD inout  pcReturned)     // number of structs written to pPorts
{
    DWORD   dwRetCode = NO_ERROR;
    
    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->EnumPorts(psztName, 
                                                            Level, 
                                                            pPorts, 
                                                            cbBuf, 
                                                            pcbNeeded,
                                                            pcReturned);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // EnumPorts()

///////////////////////////////////////////////////////////////////////////////
//  ClusteringXcvOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_NOT_SUPPORTED if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

BOOL
ClusterXcvOpenPort( HANDLE      in  hMonitor,
                       LPCTSTR      in  pszObject,
                       ACCESS_MASK  in  GrantedAccess,
                       PHANDLE      out phXcv)
{
    DWORD dwRetCode = NO_ERROR;

    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->XcvOpenPort(pszObject, 
                                                       GrantedAccess, 
                                                       phXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvOpenPort()

VOID 
ClusterShutdown( HANDLE hMonitor )
{
    if ( ((PMONITOR_HANDLE)hMonitor)->pPortMgr != NULL )
        delete ((PMONITOR_HANDLE)hMonitor)->pPortMgr;

    FreeMonitorHandle(hMonitor);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpport.cpp ===
/*****************************************************************************
 *
 * $Workfile: tcpport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "rawdev.h"
#include "rawtcp.h"
#include "tcpport.h"

///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::CTcpPort()    -- called when creating a new port through the UI

CTcpPort::CTcpPort( LPTSTR in   psztPortName,
                          LPTSTR in psztHostAddress,
                          DWORD  in dPortNum,
                          DWORD  in dSNMPEnabled,
                          LPTSTR in sztSNMPCommunity,
                          DWORD  in dSNMPDevIndex,
                          CRegABC in *pRegistry,
                          CPortMgr in *pPortMgr ) :
                                        m_dwStatus( NO_ERROR ),
                                        m_pJob( NULL ),
                                        m_pDevice( NULL ),
                                        m_lLastUpdateTime(0),
                                        m_pRegistry( pRegistry ),
                                        m_pPortMgr(pPortMgr)
{
    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);
    m_pDevice = new CRawTcpDevice(psztHostAddress,
                                  dPortNum,
                                  dSNMPEnabled,
                                  sztSNMPCommunity,
                                  dSNMPDevIndex,
                                  this);
}   // ::CTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::CTcpPort() -- called when creating a new port through the
//      registry entries.

CTcpPort::CTcpPort( LPTSTR in   psztPortName,
                    LPTSTR in   psztHostName,
                    LPTSTR in   psztIPAddr,
                    LPTSTR in   psztHWAddr,
                    DWORD  in   dPortNum,
                    DWORD    in dSNMPEnabled,
                    LPTSTR in sztSNMPCommunity,
                    DWORD  in dSNMPDevIndex,
                    CRegABC in *pRegistry,
                    CPortMgr in *pPortMgr) :
                                        m_dwStatus( NO_ERROR ),
                                        m_pJob( NULL ),
                                        m_pDevice( NULL ),
                                        m_lLastUpdateTime( 0 ),
                                        m_pRegistry( pRegistry ),
                                        m_pPortMgr(pPortMgr)
{
    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);
    m_pDevice = new CRawTcpDevice(psztHostName,
                                  psztIPAddr,
                                  psztHWAddr,
                                  dPortNum,
                                  dSNMPEnabled,
                                  sztSNMPCommunity,
                                  dSNMPDevIndex,
                                  this);
}   // ::CTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::~CTcpPort()
//      Called by CPortMgr when deleting a port

CTcpPort::~CTcpPort()
{
    if (m_pJob)
    {
        delete m_pJob;
        m_pJob = NULL;
    }
    if (m_pDevice)
    {
        delete m_pDevice;
        m_pDevice = NULL;
    }
}   // ::~CPort

///////////////////////////////////////////////////////////////////////////////
//  Write
//      Error codes:
//          NO_ERROR if succesfull
//  FIX: complete Write processing & define how it relates to a job

DWORD
CTcpPort::Write( LPBYTE in      pBuffer,
                    DWORD   in      cbBuf,
                    LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pJob->Write(pBuffer, cbBuf, pcbWritten);

    return(dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  EndDoc
//      Error codes:
//          NO_ERROR if succesfull

DWORD
CTcpPort::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT1(_CRT_WARN, "PORT -- (CTcpPort) EndDoc called for (%S)\n",m_szName );

    if ( m_pJob ) {

        dwRetCode = m_pJob->EndDoc();       // finish processing the print job
        delete m_pJob;
        m_pJob = NULL;
    }

    return(dwRetCode);

}   // ::EndDoc


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry

DWORD
CTcpPort::SetRegistryEntry( LPCTSTR     in  psztPortName,
                            const DWORD in  dwProtocol,
                            const DWORD in  dwVersion,
                            const LPBYTE in pData)
{
    DWORD   dwRetCode = NO_ERROR;

    // create the port
    switch (dwVersion)
    {
        case    PROTOCOL_RAWTCP_VERSION:        // ADDPORT_DATA_1
        {
            PPORT_DATA_1 pPortData = (PPORT_DATA_1)pData;

            _ASSERTE( _tcscmp(psztPortName, pPortData->sztPortName) == 0 );

            UpdateRegistryEntry( psztPortName,
                                 dwProtocol,
                                 dwVersion );


            break;
        }

    }   // end::switch

    return (dwRetCode);

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  UpdateRegistryEntry

DWORD
CTcpPort::UpdateRegistryEntry( LPCTSTR psztPortName,
                               DWORD dwProtocol,
                               DWORD dwVersion )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwSize = 0;
    BOOL    bKeySet = FALSE;
    TCHAR   *psztTemp = NULL;
    DWORD   dwSNMPDevIndex = 0;
    DWORD   dwSNMPEnabled = 0;
    DWORD   dwPortNum = 0;

    if( dwRetCode = m_pRegistry->SetWorkingKey(psztPortName))
        goto Done;

    bKeySet = TRUE;

    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORT_PROTOCOL,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwProtocol,
                                          sizeof(DWORD)))
        goto Done;

    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORT_VERSION,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwVersion,
                                          sizeof(DWORD)))
        goto Done;


    psztTemp = m_pDevice->GetHostName();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_HOSTNAME,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                           dwSize))
        goto Done;

    psztTemp = m_pDevice->GetIPAddress();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_IPADDR,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    psztTemp = m_pDevice->GetHWAddress();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_HWADDR,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    dwPortNum = m_pDevice->GetPortNumber();
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORTNUM,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwPortNum,
                                          sizeof(DWORD)))
        goto Done;

    // Snmp Status keys
    psztTemp = m_pDevice->GetSNMPCommunity();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(SNMP_COMMUNITY,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    if( dwRetCode = m_pRegistry->SetValue(SNMP_ENABLED,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwSNMPEnabled,
                                          sizeof(DWORD) ))
        goto Done;

    dwSNMPDevIndex = m_pDevice->GetSNMPDevIndex();
    if( dwRetCode = m_pRegistry->SetValue(SNMP_DEVICE_INDEX,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwSNMPDevIndex,
                                          sizeof(DWORD)))
        goto Done;

Done:
   if ( bKeySet )
       m_pRegistry->FreeWorkingKey();

   if ( dwRetCode )
       SetLastError(dwRetCode);

    return (dwRetCode);

}   // ::UpdateRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CTcpPort::InitConfigPortUI( const DWORD in  dwProtocolType,
                               const DWORD  in  dwVersion,
                               LPBYTE       out pData)
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_DATA_1    pPortData = (PPORT_DATA_1) pData;

    lstrcpyn(pPortData->sztIPAddress, m_pDevice->GetIPAddress(), MAX_IPADDR_STR_LEN);
//  _tcscpy(pPortData->sztHardwareAddress, m_pDevice->GetHWAddress());
//  _tcscpy(pPortData->sztDeviceType, m_pDevice->GetDescription());

    lstrcpyn(pPortData->sztSNMPCommunity, m_pDevice->GetSNMPCommunity(), MAX_SNMP_COMMUNITY_STR_LEN);
    lstrcpyn(pPortData->sztPortName, GetName(), MAX_PORTNAME_LEN);
    lstrcpyn(pPortData->sztHostAddress, m_pDevice->GetHostAddress(), MAX_NETWORKNAME_LEN);
    pPortData->dwVersion = dwVersion;
    pPortData->dwProtocol = dwProtocolType;
    pPortData->dwPortNumber = m_pDevice->GetPortNumber();
    pPortData->dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    pPortData->dwSNMPDevIndex = m_pDevice->GetSNMPDevIndex();

    return (dwRetCode);

}   // ::InitConfigPortUI()

///////////////////////////////////////////////////////////////////////////////
//  SetDeviceStatus --

DWORD
CTcpPort::SetDeviceStatus( )
{
    m_dwStatus = m_pDevice->SetStatus( m_szName );

    m_lLastUpdateTime = time(NULL);

    return( m_dwStatus );
}

///////////////////////////////////////////////////////////////////////////////
// NextStatusUpdate --

time_t
CTcpPort::NextUpdateTime()
{
    LONG lUpdateInterval = CDeviceStatus::gDeviceStatus().GetStatusUpdateInterval();
    time_t lNextUpdateTime;
    CHAR    buf[250];

    //
    // If snmp is not enabled then return 1 hour (something very big)
    //
    if ( !m_pDevice->GetSNMPEnabled() )
        return  60 * 60; // One hour


    if( m_lLastUpdateTime == 0 )
        return 0;
    //
    // Calculate the next time a status is needed
    //

    if ( m_dwStatus )
        lUpdateInterval /= STATUS_ERROR_TIMEOUT_FACTOR;
    else if ( m_pJob )
        lUpdateInterval /= STATUS_PRINTING_TIMEOUT_FACTOR;

    lNextUpdateTime = lUpdateInterval + m_lLastUpdateTime - time(NULL);

    //
    // if the next update time has passed then pass a zero indicating that
    // an update should occur now.
    //
    if( lNextUpdateTime < 0 )
        lNextUpdateTime = 0;

    return lNextUpdateTime;
}

///////////////////////////////////////////////////////////////////////////////
//  SNMP Port Info --

DWORD
CTcpPort::GetSNMPInfo( PSNMP_INFO pData )
{
    DWORD   dwRetCode = NO_ERROR;

    lstrcpyn(pData->sztAddress, m_pDevice->GetHostAddress(), MAX_NETWORKNAME_LEN);
    lstrcpyn(pData->sztSNMPCommunity, m_pDevice->GetSNMPCommunity(), MAX_SNMP_COMMUNITY_STR_LEN);
    pData->dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    pData->dwSNMPDeviceIndex = m_pDevice->GetSNMPDevIndex();

    return (dwRetCode);

}   // ::InitConfigPortUI()


DWORD
CTcpPort::
ClearDeviceStatus(
    )
{
    DWORD   dwRet = NO_ERROR;
    PORT_INFO_3             PortStatus = {0, NULL, 0};

    if( !m_pDevice->GetSNMPEnabled() && m_pPortMgr)
    {
        BOOL bRet = FALSE;
        HANDLE hToken = RevertToPrinterSelf();

        if (hToken) {
            if (SetPort((LPTSTR)m_pPortMgr->GetServerName(), m_szName, 3, (LPBYTE)&PortStatus ))
                bRet = TRUE;

            if (!ImpersonatePrinterClient(hToken))
                bRet = FALSE;
        }

        if (!bRet)
            dwRet = GetLastError ();
    }

    return( dwRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcptrans.cpp ===
/*****************************************************************************
 *
 * $Workfile: TCPTrans.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "cssocket.h"
#include "csutils.h"
#include "tcptrans.h"


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::CTCPTransport()

CTCPTransport::
CTCPTransport(
    const char   *pHost,
    const USHORT port
    ) :  m_iPort(port), m_pSSocket(NULL)
{
    strncpyn(m_szHost, pHost, MAX_NETWORKNAME_LEN);

}   // ::CTCPTransport()


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::CTCPTransport()

CTCPTransport::
CTCPTransport(
    VOID
    ) : m_pSSocket(NULL)
{

    m_szHost[0] = NULL;

}   // ::CTCPTransport()


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::~CTCPTransport()

CTCPTransport::
~CTCPTransport(
    VOID
    )
{
    if ( m_pSSocket )
        delete m_pSSocket;

}   // ::~CTCPTransport()


DWORD
CTCPTransport::
GetAckBeforeClose(
    DWORD   dwTimeInSeconds
    )
{
   return m_pSSocket ? m_pSSocket->GetAckBeforeClose(dwTimeInSeconds)
                     :  ERROR_INVALID_PARAMETER;
}


DWORD
CTCPTransport::
PendingDataStatus(
    DWORD       dwTimeInMilliSeconds,
    LPDWORD     pcbPending
    )
{
   return m_pSSocket ? m_pSSocket->PendingDataStatus(dwTimeInMilliSeconds,
                                                     pcbPending)
                     :  ERROR_INVALID_PARAMETER;
}

///////////////////////////////////////////////////////////////////////////////
//  Connect
//      Error Codes:
//          NO_ERROR if connection established
//          WinSock error if connect() failed
//          ERROR_INVALID_HANDLE if ResolveAddress failed       // FIX: error code

DWORD
CTCPTransport::
Connect(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    if ( !ResolveAddress() )
        return ERROR_INCORRECT_ADDRESS;

    if ( m_pSSocket )
        delete m_pSSocket;

    if ( m_pSSocket = new CStreamSocket() ) {

        //
        // Success case is if we connected
        if ( m_pSSocket->Connect(&m_remoteHost) )
            m_pSSocket->SetOptions();
        else {

            dwRetCode = ERROR_NOT_CONNECTED;
            delete m_pSSocket;
            m_pSSocket = NULL;
        }
    } else
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;


    return dwRetCode;

}   // ::Connect()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

BOOL
CTCPTransport::
ResolveAddress(
    VOID
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet =  pUSocket->ResolveAddress(m_szHost, m_iPort, &m_remoteHost);
        delete pUSocket;
    }

    return bRet;

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

BOOL
CTCPTransport::
ResolveAddress(
    IN  LPSTR   pHostName,
    OUT LPSTR   pIPAddress
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet = pUSocket->ResolveAddress(pHostName, pIPAddress);
        delete pUSocket;
    }

    return bRet;

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress
//      Error Codes: FIX!!

BOOL
CTCPTransport::
ResolveAddress(
    IN      char   *pHost,
    IN      DWORD   dwHostNameBufferLength,
    IN OUT  char   *szHostName,
    IN      DWORD   dwIpAddressBufferLength,
    IN OUT  char   *szIPAddress
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet =  pUSocket->ResolveAddress(pHost, dwHostNameBufferLength, szHostName,  dwIpAddressBufferLength, szIPAddress);
        delete pUSocket;
    }

    return bRet;
}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  Write --
//      Error codes
//          NO_ERROR if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
Write(
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->Send((char FAR *)pBuffer, cbBuf,
                                             pcbWritten))
                      : ERROR_INVALID_HANDLE;

}   // ::Print()

///////////////////////////////////////////////////////////////////////////////
//  Read --
//      Error codes
//          RC_SUCCESS if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
ReadDataAvailable()
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->ReceiveDataAvailable())
                      : ERROR_INVALID_HANDLE;
}   // ::Read()

///////////////////////////////////////////////////////////////////////////////
//  Read --
//      Error codes
//          RC_SUCCESS if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
Read(
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN      INT         iTimeout,
    IN OUT  LPDWORD     pcbRead
    )
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->Receive((char FAR *)pBuffer, cbBuf,
                                             0, iTimeout, pcbRead))
                      : ERROR_INVALID_HANDLE;
}   // ::Read()



///////////////////////////////////////////////////////////////////////////////
//  MapWinsockToAppError -- maps a given WinSock error to the application error
//          codes.
//      Error codes:
//              RC_SUCCESS no error
//              RC_CONNECTION_RESET if WSAECONNRESET

DWORD
CTCPTransport::
MapWinsockToAppError(
    IN  DWORD   dwErrorCode
    )
{
    DWORD   dwRetCode= NO_ERROR;

    switch (dwErrorCode) {

        case    NO_ERROR:
            dwRetCode = NO_ERROR;
            break;

        case    WSAECONNRESET:
        case    WSAECONNABORTED:
        case    WSAENOTSOCK:
        case    WSANOTINITIALISED:
        case    WSAESHUTDOWN:
            dwRetCode = ERROR_CONNECTION_ABORTED;
            _RPT1(_CRT_WARN,
                  "TCPTRANS -- Connection is reset for (%s)\n", m_szHost);
            break;

        case    WSAENOBUFS:
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;

        default:
            _RPT2(_CRT_WARN,
                  "TCPTRANS -- Unhandled Error (%d) for (%s)\n",
                  dwErrorCode, m_szHost);
            dwRetCode = dwErrorCode;
    }

    return dwRetCode;

}   //  ::MapWinsockToMapError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\adddone.h ===
/*****************************************************************************
 *
 * $Workfile: AddDone.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_ADDDONE_H
#define INC_ADDDONE_H

// Global Variables
extern HINSTANCE g_hInstance;

#define MAX_YESNO_SIZE 10
#define MAX_PROTOCOL_AND_PORTNUM_SIZE 20

class CSummaryDlg
{
public:
	CSummaryDlg();
	~CSummaryDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	BOOL OnFinish();
	DWORD RemoteTellPortMonToCreateThePort();
	DWORD LocalTellPortMonToCreateThePort();
	void FillTextFields(HWND hDlg);

private:
	ADD_PARAM_PACKAGE *m_pParams;

}; // CSummaryDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
BOOL APIENTRY SummaryDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDDONE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpport.h ===
/*****************************************************************************
 *
 * $Workfile: tcpport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPPORT_H
#define INC_TCPPORT_H

#include "portABC.h"
#include "portrefABC.h"
#include "jobabc.h"
#include "devstat.h"

#define STATUS_ERROR_TIMEOUT_FACTOR     20   // 1/20 status update interval
#define STATUS_PRINTING_TIMEOUT_FACTOR  10   // 1/10 status update interval

class CRawTcpDevice;

class CTcpPort : public CPortRefABC
#if defined _DEBUG || defined DEBUG
//  , public CMemoryDebug
#endif
{
    // methods
public:
    CTcpPort(LPTSTR     psztPortName,       // called through the UI port creation
             LPTSTR     psztHostAddress,
             DWORD      dPortNum,
             DWORD      dSNMPEnabled,
             LPTSTR     sztSNMPCommunity,
             DWORD      dSNMPDevIndex,
             CRegABC    *pRegistry,
             CPortMgr   *pPortMgr);

    CTcpPort(LPTSTR     psztPortName,       // called through the registry port creation
             LPTSTR     psztHostName,
             LPTSTR     psztIPAddr,
             LPTSTR     psztHWAddr,
             DWORD      dPortNum,
             DWORD      dSNMPEnabled,
             LPTSTR     sztSNMPCommunity,
             DWORD      dSNMPDevIndex,
             CRegABC    *pRegistry,
             CPortMgr   *pPortMgr);

    ~CTcpPort();

    DWORD   Write(LPBYTE     pBuffer,
                  DWORD  cbBuf,
                  LPDWORD pcbWritten);
    DWORD   EndDoc();


    LPCTSTR GetName ( ) { return (LPCTSTR) m_szName; }
    CDeviceABC *GetDevice() { return (CDeviceABC *)m_pDevice; }

    BOOL    IsSamePort(LPTSTR pszName) { return _tcscmp(m_szName, pszName); }
    DWORD   SetRegistryEntry(LPCTSTR        psztPortName,
                             const DWORD    dwProtocol,
                             const DWORD    dwVersion,
                             const LPBYTE   pData);
    DWORD   SetDeviceStatus( );

    DWORD   ClearDeviceStatus();

    DWORD   InitConfigPortUI( const DWORD   dwProtocolType,
                            const DWORD dwVersion,
                            LPBYTE      pData);
    DWORD   GetSNMPInfo( PSNMP_INFO pSnmpInfo);

    time_t  NextUpdateTime();

    BOOL    m_bUsed;

    inline const CPortMgr *GetPortMgr(void) const;

protected:  // methods
    DWORD   UpdateRegistryEntry( LPCTSTR        psztPortName,
                                 const DWORD    dwProtocol,
                                 const DWORD    dwVersion );

    DWORD   m_dwStatus;
protected:
    CRawTcpDevice   *m_pDevice;         // device that is attached to
    CJobABC         *m_pJob;
    CRegABC         *m_pRegistry;
    CPortMgr        *m_pPortMgr;        //  The Port Manager that this port belongs to

    TCHAR       m_szName[MAX_PORTNAME_LEN+1];           // port name

private:    // attributes

    time_t  m_lLastUpdateTime;

};

//////////////////////////////////////////////////////////////////////////
// INLINE METHODS
//////////////////////////////////////////////////////////////////////////
inline const CPortMgr *CTcpPort::GetPortMgr(void) const {
    return m_pPortMgr;
}



#endif // INC_TCPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addgetad.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddGetAd.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "AddGetAd.h"
#include "Resource.h"
#include "TCPMonUI.h"
#include "RTcpData.h"
#include "LprData.h"
#include "inisection.h"

//
//  FUNCTION: CGetAddrDlg constructor
//
//  PURPOSE:  initialize a CGetAddrDlg class
//
CGetAddrDlg::CGetAddrDlg()
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // constructor


//
//  FUNCTION: CGetAddrDlg destructor
//
//  PURPOSE:  deinitialize a CGetAddrDlg class
//
CGetAddrDlg::~CGetAddrDlg()
{
} // destructor


//
//  FUNCTION: GetAddressDialog(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the main dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY GetAddressDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL bRc = FALSE;
    CGetAddrDlg *wndDlg = NULL;
    wndDlg = (CGetAddrDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CGetAddrDlg;
            if( wndDlg != NULL )
            {
                SetLastError(ERROR_SUCCESS);
                if ( (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) ) &&
                     GetLastError() != ERROR_SUCCESS )
                {
                    delete wndDlg;
                    bRc = TRUE;
                }
                else
                    bRc = wndDlg->OnInitDialog(hDlg, wParam, lParam);
            }
            break;

       case WM_COMMAND:
            if (wndDlg)
                bRc = wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            if (wndDlg)
                bRc = wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            bRc = TRUE;
            break;

        default:
            return FALSE;
    }
    return bRc;

} // AddPortDialog

//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CGetAddrDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    TCHAR sztAddPortInfo[ADD_PORT_INFO_LEN] = NULLSTR;

    LoadString(g_hInstance, IDS_STRING_ADD_PORT, sztAddPortInfo, ADD_PORT_INFO_LEN);

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_ADD_PORT), sztAddPortInfo);
    // initialize data members
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;
    m_pParams->pData->sztHostAddress[0] = '\0';
    m_pParams->pData->sztPortName[0] = '\0';

    // Set limits on the address and port name lengths
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), MAX_ADDRESS_LENGTH);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), MAX_PORTNAME_LEN - 1);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CGetAddrDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case EN_UPDATE:
            // one of the text controls had text changed in it.
            return OnEnUpdate(hDlg, wParam, lParam);
            break;
        default:
            return FALSE;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CGetAddrDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return 1;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            TCHAR szTemp[MAX_PATH];
            lstrcpyn( szTemp, m_pParams->pData->sztHostAddress,
                 SIZEOF_IN_CHAR(szTemp) );
            m_InputChkr.MakePortName( szTemp );
            if((_tcscmp(m_pParams->pData->sztHostAddress,
                m_pParams->pData->sztPortName) == 0) ||
                (_tcscmp( m_pParams->pData->sztPortName, szTemp ) == 0 ))
            {
                m_InputChkr.LinkPortNameAndAddressInput();
            } else {
                m_InputChkr.UnlinkPortNameAndAddressInput();
            }
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), m_pParams->pData->sztHostAddress);
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), m_pParams->pData->sztPortName);
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK /* | PSWIZB_FINISH */);
            break;

        case PSN_WIZNEXT:
            // the Next button was pressed
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            OnNext(hDlg);

            // To jump to a page other than the previous or next one,
            // an application should set DWL_MSGRESULT to the identifier
            // of the dialog box to be displayed.

            switch ( m_pParams->dwDeviceType ) {
            case  SUCCESS_DEVICE_SINGLE_PORT:
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                break;

            case SUCCESS_DEVICE_MULTI_PORT:
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MULTIPORT);
                break;

            default:
                //
                // No action necessary
                //
                break;
            }

            break;

        case PSN_WIZBACK:
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:
//
//
BOOL CGetAddrDlg::OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int idEditCtrl = (int) LOWORD(wParam);
    HWND hwndEditCtrl = NULL;

    hwndEditCtrl = (HWND)lParam;

    switch(idEditCtrl) {
        case IDC_EDIT_PORT_NAME:

            m_InputChkr.OnUpdatePortName(idEditCtrl, hwndEditCtrl);
            break;

        case IDC_EDIT_DEVICE_ADDRESS:

            if (SendMessage(hwndEditCtrl, EM_GETMODIFY, 0, 0)) {
                // The port address has changed
                // so we need to probe the network again
                //
                m_pParams->bBypassNetProbe = FALSE;

            }

            m_InputChkr.OnUpdateAddress(hDlg, idEditCtrl, hwndEditCtrl, m_pParams->pszServer);
            break;

        default:
            //
            // Should never get here
            //
            break;
    }
    return TRUE;

} // OnEnUpdate


//
//  FUNCTION: OnNext(HWND hDlg)
//
//  PURPOSE:  When the user clicks Next this function does all the necessary
//              things to create a port.  Verify the address, check to see if there
//              is already a port existing with the given name/address, get the
//              device type, and set the values in the m_PortData structure.
//
void CGetAddrDlg::OnNext(HWND hDlg)
{
    HCURSOR         hNewCursor = NULL;
    HCURSOR         hOldCursor = NULL;
    IniSection      *pIniSection = NULL;
    TCHAR           ptcsAddress[MAX_ADDRESS_LENGTH] = NULLSTR;
    TCHAR           ptcsPortName[MAX_PORTNAME_LEN] = NULLSTR;
    TCHAR           sztSystemDesc[MAX_PORT_DESCRIPTION_LEN] = NULLSTR;
    DWORD           dwDeviceType = SUCCESS_DEVICE_UNKNOWN;
    DWORD           dwPortNum = DEFAULT_PORT_NUMBER;
    DWORD           dwNumMultiPorts = 0;
    DWORD           dwRet = ERROR_DEVICE_NOT_FOUND;


    if ( hNewCursor = LoadCursor(NULL, IDC_WAIT) )
        hOldCursor = SetCursor(hNewCursor);

    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), ptcsAddress, MAX_ADDRESS_LENGTH);
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), ptcsPortName, MAX_PORTNAME_LEN);

    if(! m_InputChkr.AddressIsLegal(ptcsAddress)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ADDRESS_NOT_VALID);
        return;
    }

    if(! m_InputChkr.PortNameIsLegal(ptcsPortName)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_PORTNAME_NOT_VALID);
        return;
    }

    if(! m_InputChkr.PortNameIsUnique(ptcsPortName, m_pParams->pszServer)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_PORTNAME_NOT_UNIQUE);
        return;
    }

    memset( m_pParams->sztPortDesc, '\0', sizeof( m_pParams->sztPortDesc ));
    memset( m_pParams->sztSectionName, '\0', sizeof( m_pParams->sztSectionName ) );
    m_pParams->bMultiPort = FALSE;
    dwRet = GetDeviceDescription(ptcsAddress, sztSystemDesc, SIZEOF_IN_CHAR(sztSystemDesc));

    switch( dwRet ) {
        case NO_ERROR:

            if ( pIniSection = new IniSection() ) {
                if ( pIniSection->GetIniSection( sztSystemDesc )) {

                    if ( pIniSection->GetDWord(PORTS_KEY, &dwNumMultiPorts)   &&
                         dwNumMultiPorts > 1 ) {

                        dwDeviceType = SUCCESS_DEVICE_MULTI_PORT;
                        m_pParams->bMultiPort = TRUE;
                        lstrcpyn(m_pParams->sztSectionName,
                                 pIniSection->GetSectionName(),
                                 MAX_SECTION_NAME);
                    } else {

                        dwDeviceType = SUCCESS_DEVICE_SINGLE_PORT;
                        if (! pIniSection->GetPortInfo( ptcsAddress, m_pParams->pData, 1 , m_pParams->bBypassNetProbe)) {
                            if (GetLastError () == ERROR_DEVICE_NOT_FOUND) {

                                // The IP address is incorrect, we should by pass network probe from now on
                                //

                                m_pParams->bBypassNetProbe = TRUE;

                            }
                        }
                    }

                    pIniSection->GetString( PORT_NAME_KEY, m_pParams->sztPortDesc, SIZEOF_IN_CHAR(m_pParams->sztPortDesc));

                }

                delete pIniSection;
                pIniSection = NULL;
            }
            break;

        case SUCCESS_DEVICE_UNKNOWN:
            dwDeviceType = SUCCESS_DEVICE_UNKNOWN;
            break;

        default:
            dwDeviceType = ERROR_DEVICE_NOT_FOUND;
            m_pParams->bBypassNetProbe = TRUE;

            break;
    }

    if ( hNewCursor )
        SetCursor(hOldCursor);

    // Set values in the outgoing structure
    lstrcpyn(m_pParams->pData->sztPortName, ptcsPortName, MAX_PORTNAME_LEN);
    lstrcpyn(m_pParams->pData->sztHostAddress, ptcsAddress, MAX_NETWORKNAME_LEN);
    m_pParams->dwDeviceType = dwDeviceType;
} // OnNext


//
// FUNCTION: GetDeviceDescription()
//
// PURPOSE: Get the description of the user requested printer.
//
// Return Value Error Codes:
//  NO_ERROR
//  ERROR_DLL_NOT_FOUND
//
// Return Values in dwType:
//  ERROR_DEVICE_NOT_FOUND
//  SUCCESS_DEVICE_SINGLE_PORT
//  SUCCESS_DEVICE_MULTI_PORT
//  SUCCESS_DEVICE_UNKNOWN

DWORD
CGetAddrDlg::
GetDeviceDescription(
    LPCTSTR     pAddress,
    LPTSTR      pszPortDesc,
    DWORD       cBytes
    )
{

//  Here is the essence of the code below without all the load
//  library stuff in addition:
//
//  CTcpMibABC *pTcpMib = NULL;
//  pTcpMib = (CTcpMibABC *) GetTcpMibPtr();
//
//  char HostName[MAX_NETWORKNAME_LEN];
//  UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
//  *dwType = pTcpMib->GetDeviceType(HostName, pdwPortNum);
//
//  return (NO_ERROR);
//
    DWORD            dwRet = ERROR_DEVICE_NOT_FOUND;
    CTcpMibABC     *pTcpMib = NULL;
    FARPROC         pfnGetTcpMibPtr = NULL;

    if ( !g_hTcpMibLib ) {
        goto Done;
    }

    pfnGetTcpMibPtr = ::GetProcAddress(g_hTcpMibLib, "GetTcpMibPtr");

    if ( !pfnGetTcpMibPtr ) {
        goto Done;
    }

    if ( pTcpMib = (CTcpMibABC *) pfnGetTcpMibPtr() ) {

        char HostName[MAX_NETWORKNAME_LEN] = "";

        UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
        dwRet = pTcpMib->GetDeviceDescription(HostName,
                                             DEFAULT_SNMP_COMMUNITYA,
                                             DEFAULT_SNMP_DEVICE_INDEX,
                                             pszPortDesc,
                                             cBytes);
    }

Done:
    return dwRet;
} // GetDeviceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcptrans.h ===
/*****************************************************************************
 *
 * $Workfile: TCPTrans.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPTRANSPORT_H
#define INC_TCPTRANSPORT_H

class CStreamSocket;

class CTCPTransport
{
public:
    CTCPTransport();
    CTCPTransport(  const char *pHost,
					const USHORT port );
    ~CTCPTransport();

    DWORD	Connect();
    DWORD   GetAckBeforeClose(DWORD dwSeconds);
    DWORD   PendingDataStatus(DWORD     dwTimeoutInMilliseconds,
                              LPDWORD   pcbPending);

    DWORD	Write(LPBYTE	pBuffer,		
                  DWORD	cbBuf,
                  LPDWORD pcbWritten);

    DWORD   ReadDataAvailable();
    DWORD	Read(LPBYTE	pBuffer,		
                 DWORD	cbBufSize,
                 INT     iTimeOut,
                 LPDWORD pcbRead);


    BOOL	ResolveAddress();
    BOOL	ResolveAddress(LPSTR	pHostName,
                           LPSTR	pIPAddress );
    BOOL 	ResolveAddress( char   *pHost,
                            DWORD   dwHostNameBufferLength,
                            char   *pHostName,
                            DWORD   dwIpAddressBufferLength,
                            char   *pIPAddress);

private:
    DWORD	MapWinsockToAppError(const DWORD dwErrorCode );

private:
	CStreamSocket *m_pSSocket;		// stream socket class

	USHORT	m_iPort;
	char	m_szHost[MAX_NETWORKNAME_LEN];	
	struct sockaddr_in	m_remoteHost;
};


#endif // INC_TCPTRANSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addgetad.h ===
/*****************************************************************************
 *
 * $Workfile: AddGetAd.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDGETADDRESS_H
#define INC_ADDGETADDRESS_H


const int ADD_PORT_INFO_LEN = 512;


// Global Variables
extern HINSTANCE g_hInstance;

class CGetAddrDlg
{
public:
        CGetAddrDlg();
        ~CGetAddrDlg();

public:
        BOOL    OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        BOOL    OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        BOOL    OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
        BOOL    OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        VOID    OnNext(HWND hDlg);
        DWORD   GetDeviceDescription(LPCTSTR   pHost,
                                 LPTSTR    pszPortDesc,
                                                                 DWORD     cBytes);

private:
        ADD_PARAM_PACKAGE *m_pParams;
        BOOL m_bDontAllowThisPageToBeDeactivated;
        CInputChecker m_InputChkr;

}; // CGetAddrDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
BOOL APIENTRY GetAddressDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDGETADDRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addminfo.h ===
/*****************************************************************************
 *
 * $Workfile: AddMInfo.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDMOREINFO_H
#define INC_ADDMOREINFO_H

#define DEFAULT_COMBO_SELECTION TEXT("<")

// Global Variables
extern HINSTANCE g_hInstance;

// Constants
const int MAX_LISTBOX_STRLEN = 50;
const int MAX_REASON_STRLEN = 512;

class CMoreInfoDlg
{
public:
	CMoreInfoDlg();
	~CMoreInfoDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	BOOL OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void FillComboBox(HWND hDlg);
	void OnSetActive(HWND hDlg);
	BOOL OnSelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void GetPrinterData(HWND hwndControl, LPCTSTR pszAddress);

private:
	ADD_PARAM_PACKAGE *m_pParams;
	CDevicePortList m_DPList;
	PORT_DATA_1 m_PortDataStandard;
	PORT_DATA_1 m_PortDataCustom;
	TCHAR m_szCurrentSelection[MAX_SECTION_NAME];
}; // CMoreInfoDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
BOOL APIENTRY MoreInfoDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDMOREINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addmulti.h ===
/*****************************************************************************
 *
 * $Workfile: AddMulti.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDMULTIPORT_H
#define INC_ADDMULTIPORT_H

// Global Variables
extern HINSTANCE g_hInstance;

// Constants
const int MAX_MULTILISTBOX_STRLEN = 50;
const int MAX_MULTIREASON_STRLEN = 512;

class CMultiPortDlg
{
public:
	CMultiPortDlg();
	~CMultiPortDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void FillComboBox(HWND hDlg);
	void OnSetActive(HWND hDlg);
	BOOL OnSelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void GetPrinterData(HWND hwndControl, LPCTSTR pszAddress);

private:
	ADD_PARAM_PACKAGE *m_pParams;
	CDevicePortList m_DPList;
	PORT_DATA_1 m_PortDataStandard;
	TCHAR m_szCurrentSelection[MAX_SECTION_NAME];

}; // CMultiPortDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
BOOL APIENTRY MultiPortDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDMULTIPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addminfo.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddMInfo.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "UIMgr.h"
#include "DevPort.h"
#include "AddMInfo.h"
#include "Resource.h"
#include "MibABC.h"
#include "TcpMonUI.h"

//
//  FUNCTION: CMoreInfoDlg constructor
//
//  PURPOSE:  initialize a CMoreInfoDlg class
//
CMoreInfoDlg::CMoreInfoDlg() : m_DPList( )
{
    memset(&m_PortDataStandard, 0, sizeof(m_PortDataStandard));
    memset(&m_PortDataCustom, 0, sizeof(m_PortDataCustom));

    lstrcpyn(m_szCurrentSelection, DEFAULT_COMBO_SELECTION, MAX_SECTION_NAME);

} // constructor


//
//  FUNCTION: CMoreInfoDlg destructor
//
//  PURPOSE:  deinitialize a CMoreInfoDlg class
//
CMoreInfoDlg::~CMoreInfoDlg()
{
} // destructor


//
//  FUNCTION: MoreInfoDialog(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY MoreInfoDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CMoreInfoDlg *wndDlg = NULL;

    wndDlg = (CMoreInfoDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CMoreInfoDlg;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CMoreInfoDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_STANDARD);

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), FALSE);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CMoreInfoDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
    case BN_CLICKED:
        return OnButtonClicked(hDlg, wParam, lParam);
        break;

/*
    case LBN_SELCHANGE:
        return OnSelChange(hDlg, wParam, lParam);
        break;
*/
    default:
        return FALSE;
    }

    return TRUE;

} // OnCommand

#if 0
//
//  FUNCTION: OnSelChange()
//
//  PURPOSE:  Process WM_COMMAND's LBN_SELCHANGE message
//
BOOL CMoreInfoDlg::OnSelChange(HWND hDlg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    // The selection in the combo box changed.
    HWND hwndComboBox = NULL;

    hwndComboBox = (HWND) lParam;       // handle of list box
    GetPrinterData(hwndComboBox, m_pParams->pData->sztHostAddress);

    return TRUE;

} // OnSelChange

#endif

//
//  FUNCTION: GetPrinterData(HWND hwndControl, BOOL *Unknown)
//
//  PURPOSE:  Gets the socket number of the selected item.
//
//  Arguments: hwndControl is the handle of the combo box.
//
//  Return Value: Returns the socket number associated with the selected item
//
void CMoreInfoDlg::GetPrinterData(HWND hwndControl,
                                  LPCTSTR pszAddress
                                  )
{
    LRESULT iSelectedIndex = 0;
    CDevicePort *pPortInfo = NULL;

    iSelectedIndex = SendMessage(hwndControl,
                                 CB_GETCURSEL,
                                 (WPARAM)0,
                                 (LPARAM)0);

    pPortInfo = (CDevicePort *) SendMessage(hwndControl,
                                            CB_GETITEMDATA,
                                            (WPARAM)iSelectedIndex,
                                            (LPARAM)0);
    if ( (DWORD_PTR)pPortInfo != CB_ERR) {

        pPortInfo->ReadPortInfo(pszAddress, &m_PortDataStandard, m_pParams->bBypassNetProbe);
        lstrcpyn( m_szCurrentSelection, pPortInfo->GetName(), MAX_SECTION_NAME);
        m_pParams->bMultiPort = ( pPortInfo->GetPortIndex() == 0);
        lstrcpyn(m_pParams->sztSectionName,pPortInfo->GetPortKeyName(), MAX_SECTION_NAME);
    } else {

        //
        // DSN Fill out the default structure
        //
        m_PortDataStandard.dwPortNumber = DEFAULT_PORT_NUMBER;
        lstrcpyn(m_PortDataStandard.sztSNMPCommunity,
                 DEFAULT_SNMP_COMUNITY,
                 MAX_SNMP_COMMUNITY_STR_LEN);
        m_PortDataStandard.dwSNMPDevIndex = 1;
    }
} // GetPrinterData


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CMoreInfoDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:

            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return 1;

        case PSN_RESET:
            //
            // reset to the original values
            //
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            OnSetActive(hDlg);
            break;

        case PSN_WIZBACK:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);

            memcpy(m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1));
            break;

        case PSN_WIZNEXT:
            //
            // the Next button was pressed
            //
            if( IsDlgButtonChecked(hDlg, IDC_RADIO_STANDARD) == BST_CHECKED ) {

                HWND hList = NULL;
                HCURSOR         hNewCursor = NULL;
                HCURSOR         hOldCursor = NULL;

                if ( hNewCursor  = LoadCursor(NULL, IDC_WAIT) )
                    hOldCursor = SetCursor(hNewCursor);

                hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);

                GetPrinterData(hList, m_pParams->pData->sztHostAddress);

                if ( m_pParams->bMultiPort == FALSE ) {
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                }
                memcpy(m_pParams->pData,
                       &m_PortDataStandard,
                       sizeof(PORT_DATA_1));

                lstrcpyn(m_pParams->sztPortDesc,
                         m_szCurrentSelection,
                         SIZEOF_IN_CHAR(m_pParams->sztPortDesc));

                if ( hNewCursor )
                    SetCursor(hOldCursor);

            } else {

                //
                // if(IsDlgButtonChecked(hDlg, IDC_RADIO_CUSTOM) == BST_CHECKED)
                //
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                memcpy(m_pParams->pData, &m_PortDataCustom, sizeof(PORT_DATA_1));
                m_pParams->bMultiPort = FALSE;
                *m_pParams->sztPortDesc = '\0';
            }
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;
} // OnCommand


//
//  FUNCTION: OnSetActive()
//
//  PURPOSE:  Process PSN_SETACTIVE part of the WM_NOTIFY message
//
void CMoreInfoDlg::OnSetActive(HWND hDlg)
{
    TCHAR sztMoreInfoReason[MAX_REASON_STRLEN] = NULLSTR;

    memcpy( &m_PortDataStandard, m_pParams->pData, sizeof(PORT_DATA_1) );
    memcpy( &m_PortDataCustom, m_pParams->pData, sizeof(PORT_DATA_1) );

    FillComboBox(hDlg);

    switch(m_pParams->dwDeviceType) {
        case ERROR_DEVICE_NOT_FOUND:
            LoadString(g_hInstance, IDS_STRING_DEV_NOT_FOUND, sztMoreInfoReason, MAX_REASON_STRLEN);
            break;

        case SUCCESS_DEVICE_UNKNOWN:
            LoadString(g_hInstance, IDS_STRING_UNKNOWN_DEV, sztMoreInfoReason, MAX_REASON_STRLEN);
            break;

        default:
            _tcscpy(sztMoreInfoReason, TEXT(""));
            break;
    }

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_MOREINFO_REASON), sztMoreInfoReason);
} // OnSetActive


//
//  FUNCTION: OnButtonClicked()
//
//  PURPOSE:  Process BN_CLICKED message
//
BOOL CMoreInfoDlg::OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM)
{
    int  idButton = (int) LOWORD(wParam);    // identifier of button
    // HWND hwndButton = (HWND) lParam;

    switch(idButton)
    {
        case IDC_BUTTON_SETTINGS:
            m_pParams->UIManager->ConfigPortUI(hDlg,
                                               &m_PortDataCustom,
                                               m_pParams->hXcvPrinter,
                                               m_pParams->pszServer,
                                               TRUE);
            break;

        case IDC_RADIO_STANDARD:
            CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_STANDARD);

            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), FALSE);
            SetFocus(GetDlgItem(hDlg, IDC_COMBO_DEVICES));
            break;

        case IDC_RADIO_CUSTOM:
            CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_CUSTOM);

            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), TRUE);
            SetFocus(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS));
            break;

        default:
            return FALSE;
            break;
    }
    return TRUE;

} // OnButtonClicked


//
//  FUNCTION: FillComboBox(HWND hDlg)
//
//  PURPOSE:  Fills the combo box with values gotten from the ini file.
//              The associated item data is used to pair the port number with the
//              device types.
//
//  Arguments: hDlg is the handle of the dialog box.
//
void CMoreInfoDlg::FillComboBox(HWND hDlg)
{
    LRESULT index = 0;
    HWND hList = NULL;
    CDevicePort *pDP = NULL;
    TCHAR sztGenericNetworkCard[MAX_TITLE_LENGTH];

    hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);
    // Possible Values in m_pParams->dwDeviceType:
    //  ERROR_DEVICE_NOT_FOUND
    //  SUCCESS_DEVICE_MULTI_PORT
    //  SUCCESS_DEVICE_UNKNOWN

    index = SendMessage(hList,
                        CB_GETCURSEL,
                        (WPARAM)0,
                        (LPARAM)0);

    if (index == CB_ERR) {
        // This is the first time, initiliaze the list

        index = SendMessage(hList, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

        //
        // Initialize the list of variables
        //
        if(m_pParams->dwDeviceType == ERROR_DEVICE_NOT_FOUND ||
            m_pParams->dwDeviceType == SUCCESS_DEVICE_UNKNOWN) {
            m_DPList.GetDevicePortsList(NULL);
        } else { // SUCCESS_DEVICE_MULTI_PORT
            m_DPList.GetDevicePortsList(m_pParams->sztSectionName);
        }

        for(pDP = m_DPList.GetFirst(); pDP != NULL; pDP = m_DPList.GetNext()) {

            index = SendMessage(hList,
                                CB_ADDSTRING,
                                (WPARAM)0,
                                (LPARAM)pDP->GetName());
            SendMessage(hList,
                        CB_SETITEMDATA,
                        (WPARAM)index,
                        (LPARAM)pDP);
        }

        index = SendMessage(hList,
                            CB_SETCURSEL,
                            (WPARAM)0,
                            (LPARAM)0);

        if((m_pParams->dwDeviceType == ERROR_DEVICE_NOT_FOUND ||
            m_pParams->dwDeviceType == SUCCESS_DEVICE_UNKNOWN) &&
            (*m_szCurrentSelection != '\0') ) {

            index = SendMessage(hList,
                                CB_SELECTSTRING,
                                (WPARAM)-1,
                                (LPARAM)m_szCurrentSelection);
        }

        SendMessage(hList, CB_SETCURSEL, (WPARAM)index, (LPARAM)0);

        if (LoadString(g_hInstance, IDS_GENERIC_NETWORK_CARD, sztGenericNetworkCard, MAX_TITLE_LENGTH))
            SendMessage(hList, CB_SELECTSTRING, 0, (LPARAM)sztGenericNetworkCard);
    }


} // FillComboBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\adddone.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddDone.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "UIMgr.h"
#include "AddDone.h"
#include "Resource.h"
#include "TCPMonUI.h"

//
//  FUNCTION: CSummaryDlg constructor
//
//  PURPOSE:  initialize a CSummaryDlg class
//
CSummaryDlg::CSummaryDlg()
{
} // constructor


//
//  FUNCTION: CSummaryDlg destructor
//
//  PURPOSE:  deinitialize a CSummaryDlg class
//
CSummaryDlg::~CSummaryDlg()
{
} // destructor


//
//  FUNCTION: SummaryDialog(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY SummaryDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CSummaryDlg *wndDlg = NULL;

    wndDlg = (CSummaryDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CSummaryDlg;
            if( wndDlg == NULL )
                return FALSE;

            //
            // If the function succeeds, the return value is the previous value of the specified offset.
            //
            // If the function fails, the return value is zero. To get extended error
            // information, call GetLastError.
            //
            // If the previous value is zero and the function succeeds, the return value is zero,
            // but the function does not clear the last error information. To determine success or failure,
            // clear the last error information by calling SetLastError(0), then call SetWindowLongPtr.
            // Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            //

            SetLastError (0);
            if (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) && GetLastError()) {
                delete wndDlg;
                return FALSE;
            }
            else
                return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            if (wndDlg)
                delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CSummaryDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    FillTextFields(hDlg);

    m_pParams->UIManager->SetControlFont(hDlg, IDC_TITLE);

    return TRUE;

} // OnInitDialog


//
// Function: FillTextFields()
//
// Purpose: To load strings and set the text for all the output fields
//          on the Summary page.
//
void CSummaryDlg::FillTextFields(HWND hDlg)
{
    TCHAR ptcsYesNo[MAX_YESNO_SIZE] = NULLSTR;
    TCHAR ptcsProtocolAndPortNum[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;

    // Fill in the protocol field
    TCHAR ptcsProtocol[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;
    TCHAR ptcsPort[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;

    if(m_pParams->pData->dwProtocol == PROTOCOL_RAWTCP_TYPE) {
        LoadString(g_hInstance,
                   IDS_STRING_RAW,
                   ptcsProtocol,
                   MAX_PROTOCOL_AND_PORTNUM_SIZE);
        LoadString(g_hInstance,
                   IDS_STRING_PORT,
                   ptcsPort,
                   MAX_PROTOCOL_AND_PORTNUM_SIZE);

        _stprintf(ptcsProtocolAndPortNum,
                  TEXT("%s, %s %d"),
                  ptcsProtocol,
                  ptcsPort,
                  m_pParams->pData->dwPortNumber);
    } else {
        if(m_pParams->pData->dwProtocol == PROTOCOL_LPR_TYPE) {
            LoadString(g_hInstance,
                       IDS_STRING_LPR,
                       ptcsProtocol,
                       MAX_PROTOCOL_AND_PORTNUM_SIZE);

            _stprintf(ptcsProtocolAndPortNum,
                      TEXT("%s, %s"),
                      ptcsProtocol,
                      m_pParams->pData->sztQueue);
        }
    }
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PROTOCOL_AND_PORTNUM),
                  ptcsProtocolAndPortNum);

    // Fill in the SNMP Field
    if(m_pParams->pData->dwSNMPEnabled != FALSE) {
        LoadString(g_hInstance, IDS_STRING_YES, ptcsYesNo, MAX_YESNO_SIZE);
    } else {
        LoadString(g_hInstance, IDS_STRING_NO, ptcsYesNo, MAX_YESNO_SIZE);
    }
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_SNMP_YESNO), ptcsYesNo);

    // Fill in the Address field:
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_ADDRESS), m_pParams->pData->sztHostAddress);

    // Fill in the PortName field
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORTNAME), m_pParams->pData->sztPortName);

    // Fill in the Detected type
    SetWindowText(GetDlgItem( hDlg, IDC_EDIT_SYSTEMID), m_pParams->sztPortDesc);

} // FillTextFields

//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CSummaryDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_RESET:
            // reset to the original values
#ifdef _WIN64
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
#else
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
#endif
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            FillTextFields(hDlg);
            PostMessage(GetDlgItem(hDlg, IDC_EDIT_SNMP_YESNO), EM_SETSEL,0,0);
            return FALSE;
            break;

        case PSN_WIZBACK:
            // To jump to a page other than the previous or next one,
            // an application should set DWL_MSGRESULT to the identifier
            // of the dialog box to be displayed.
            if(m_pParams->dwDeviceType == SUCCESS_DEVICE_SINGLE_PORT) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);
            } else if (m_pParams->bMultiPort ==  FALSE  ) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MORE_INFO);
            }

            break;

        case PSN_WIZFINISH:
            OnFinish();
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnNotify


//
//  FUNCTION: OnFinish()
//
//  PURPOSE:  Create the Port
//
BOOL CSummaryDlg::OnFinish()
{
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor ) {

        hOldCursor = SetCursor(hNewCursor);
    }

    if ( m_pParams->hXcvPrinter != NULL ) {

        RemoteTellPortMonToCreateThePort();
    } else {
        LocalTellPortMonToCreateThePort();
    }

    //
    // Make sure the port name is returned to the calling module.
    //
    lstrcpyn(m_pParams->sztPortName,
             m_pParams->pData->sztPortName,
             MAX_PORTNAME_LEN);

    //
    // Change the cursor back from an hour glass.
    //
    if ( hNewCursor ) {

        SetCursor(hOldCursor);
    }

    return TRUE;

} // OnFinish


//
//  FUNCTION: RemoteTellPortMonToCreateThePort
//
//  PURPOSE:  Loads winspool.dll and calls XcvData
//
DWORD CSummaryDlg::RemoteTellPortMonToCreateThePort()
{
    DWORD dwReturn = NO_ERROR;
    HINSTANCE hLib = NULL;
    XCVDATAPARAM pfnXcvData = NULL;
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor ) {

        hOldCursor = SetCursor(hNewCursor);
    }

    //
    // load & assign the function pointer
    //
    hLib = ::LoadLibrary(TEXT("WinSpool.drv"));
    if( hLib != NULL ) {

        //
        // initialize the library
        //
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(hLib, "XcvDataW");
        if ( pfnXcvData != NULL ) {

            DWORD dwOutputNeeded = 0;
            DWORD dwStatus = NO_ERROR;
            //
            // here's the call we've all been waiting for:
            //
            DWORD dwRet = (*pfnXcvData)(m_pParams->hXcvPrinter,
                                        (PCWSTR)TEXT("AddPort"),
                                        (PBYTE)(m_pParams->pData),
                                        m_pParams->pData->cbSize,
                                        NULL,
                                        0,
                                        &dwOutputNeeded,
                                        &dwStatus);

            if ( !dwRet ) {

                dwReturn = GetLastError();
                DisplayErrorMessage(NULL, dwReturn);
            } else {

                if ( dwStatus != NO_ERROR )
                    DisplayErrorMessage(NULL, dwStatus);
            }
        } else {

            dwReturn = ERROR_DLL_NOT_FOUND;
        }

    } else {

        dwReturn = ERROR_DLL_NOT_FOUND;
    }

    //
    // --- Cleanup ---
    //
    if ( hLib )
        FreeLibrary(hLib);

    if ( hNewCursor )
        SetCursor(hOldCursor);

    return(dwReturn);

} // RemoteTellPortMonToCreateThePort


//
//  FUNCTION: TellPortMonToCreateThePort
//
//  Purpose: To load the port monitor dll and call AddPortUIEx
//
//  Return Value:
//
DWORD CSummaryDlg::LocalTellPortMonToCreateThePort()
{
    DWORD dwReturn = NO_ERROR;
    UIEXPARAM pfnAddPortUIEx = NULL;
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor )
        hOldCursor = SetCursor(hNewCursor);

    //
    // load & assign the function pointer
    //
    if ( g_hPortMonLib != NULL) {

        //
        // initialize the library
        //
        pfnAddPortUIEx = (UIEXPARAM)::GetProcAddress(g_hPortMonLib,
                                                     "AddPortUIEx");
        if ( pfnAddPortUIEx != NULL ) {

            //
            // here's the call we've all been waiting for:
            //
            BOOL bReturn = (*pfnAddPortUIEx)(m_pParams->pData);
            if(bReturn == FALSE) {

                dwReturn = GetLastError();
                DisplayErrorMessage(NULL, dwReturn);
            }
        } else {

            dwReturn = ERROR_DLL_NOT_FOUND;
        }
    } else {

        dwReturn = ERROR_DLL_NOT_FOUND;
    }

    //
    // Cleanup
    //
    if ( hNewCursor )
        SetCursor(hOldCursor);

    return dwReturn;

} // LocalTellPortMonToCreateThePort
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addmulti.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddMulti.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "UIMgr.h"
#include "DevPort.h"
#include "AddMulti.h"
#include "Resource.h"
#include "MibABC.h"
#include "TcpMonUI.h"

//
//  FUNCTION: CMultiPortDlg constructor
//
//  PURPOSE:  initialize a CMultiPortDlg class
//
CMultiPortDlg::CMultiPortDlg() : m_DPList( )
{
    memset(&m_PortDataStandard, 0, sizeof(m_PortDataStandard));

    memset(m_szCurrentSelection, '\0', sizeof( m_szCurrentSelection ));
} // constructor


//
//  FUNCTION: CMultiPortDlg destructor
//
//  PURPOSE:  deinitialize a CMultiPortDlg class
//
CMultiPortDlg::~CMultiPortDlg()
{
} // destructor


//
//  FUNCTION: MoreInfoDialog(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY MultiPortDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CMultiPortDlg *wndDlg = NULL;
    wndDlg = (CMultiPortDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);


    switch (message)
    {
        case WM_INITDIALOG:
            wndDlg = new CMultiPortDlg;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CMultiPortDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CMultiPortDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case LBN_SELCHANGE:
            return OnSelChange(hDlg, wParam, lParam);
            break;

        default:
            return FALSE;
            break;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnSelChange()
//
//  PURPOSE:  Process WM_COMMAND's LBN_SELCHANGE message
//
BOOL CMultiPortDlg::OnSelChange(HWND hDlg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    // The selection in the combo box changed.
    HWND hwndComboBox = NULL;       // handle of list box

    hwndComboBox = (HWND) lParam;
    GetPrinterData(hwndComboBox, m_pParams->pData->sztHostAddress);

    return TRUE;

} // OnSelChange


//
//  FUNCTION: GetPrinterData(HWND hwndControl, BOOL *Unknown)
//
//  PURPOSE:  Gets the socket number of the selected item.
//
//  Arguments: hwndControl is the handle of the combo box.
//
//  Return Value: Returns the socket number associated with the selected item
//
void CMultiPortDlg::GetPrinterData(HWND hwndControl,
                                   LPCTSTR pszAddress
                                   )
{
    LRESULT iSelectedIndex = 0;
    CDevicePort *pPortInfo = NULL;

    iSelectedIndex = SendMessage(hwndControl,
                                CB_GETCURSEL,
                                (WPARAM)0,
                                (LPARAM)0);

    pPortInfo = (CDevicePort *) SendMessage(hwndControl,
                                            CB_GETITEMDATA,
                                            (WPARAM)iSelectedIndex,
                                            (LPARAM)0);
    if( (DWORD_PTR)pPortInfo != CB_ERR) {
        pPortInfo->ReadPortInfo( pszAddress, &m_PortDataStandard, m_pParams->bBypassNetProbe);
        lstrcpyn( m_szCurrentSelection, pPortInfo->GetName(), MAX_SECTION_NAME);
    } else {
        m_PortDataStandard.dwPortNumber = DEFAULT_PORT_NUMBER;
        lstrcpyn(m_PortDataStandard.sztSNMPCommunity, DEFAULT_SNMP_COMUNITY, MAX_SNMP_COMMUNITY_STR_LEN);
        m_PortDataStandard.dwSNMPDevIndex = 1;
    }

} // GetPrinterData


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CMultiPortDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return TRUE;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            OnSetActive(hDlg);
            break;

        case PSN_WIZBACK:
            if ( m_pParams->dwDeviceType == SUCCESS_DEVICE_MULTI_PORT ) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);
            } else {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MORE_INFO);
            }

            memcpy( m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1) );

            break;
        case PSN_WIZNEXT:
                // the Next button was pressed
            memcpy( m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1) );

            return FALSE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnSetActive()
//
//  PURPOSE:  Process PSN_SETACTIVE part of the WM_NOTIFY message
//
void CMultiPortDlg::OnSetActive(HWND hDlg)
{
    TCHAR sztMoreInfoReason[MAX_MULTIREASON_STRLEN] = NULLSTR;

    memcpy( &m_PortDataStandard, m_pParams->pData, sizeof(PORT_DATA_1) );

    FillComboBox(hDlg);

    LoadString(g_hInstance, IDS_STRING_MULTI_PORT_DEV, sztMoreInfoReason, MAX_MULTIREASON_STRLEN);

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_MOREINFO_REASON), sztMoreInfoReason);
} // OnSetActive



//
//  FUNCTION: FillComboBox(HWND hDlg)
//
//  PURPOSE:  Fills the combo box with values gotten from the ini file.
//              The associated item data is used to pair the port number with the
//              device types.
//
//  Arguments: hDlg is the handle of the dialog box.
//
void CMultiPortDlg::FillComboBox(HWND hDlg)
{
    LRESULT index = 0;
    HWND hList = NULL;
    CDevicePort *pDP = NULL;

    hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);
    // Possible Values in m_pParams->dwDeviceType:
    //  ERROR_DEVICE_NOT_FOUND
    //  SUCCESS_DEVICE_MULTI_PORT
    //  SUCCESS_DEVICE_UNKNOWN


    index = SendMessage(hList, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    //
    // Initialize the list of variables
    //
    m_DPList.GetDevicePortsList(m_pParams->sztSectionName);

    for(pDP = m_DPList.GetFirst(); pDP != NULL; pDP = m_DPList.GetNext())
    {
        index = SendMessage(hList,
                            CB_ADDSTRING,
                            (WPARAM)0,
                            (LPARAM)pDP->GetName());
        SendMessage(hList,
                    CB_SETITEMDATA,
                    (WPARAM)index,
                    (LPARAM)pDP);
    }

    if( *m_szCurrentSelection != '\0' ) {
        index = SendMessage(hList,
                            CB_SELECTSTRING,
                            (WPARAM)-1,
                            (LPARAM)m_szCurrentSelection);
        if (index == CB_ERR) {
            // Error the selected string is not in the list, which implies that the user has
            // selected a different network card, so we set the choice to the first one

            index = 0;
        }

    }
    else
        index = 0;

    SendMessage(hList, CB_SETCURSEL, (WPARAM)index, (LPARAM)0);

    GetPrinterData( hList, m_pParams->pData->sztHostAddress );

} // FillComboBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addwelcm.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddWelcm.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 * 
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "UIMgr.h"
#include "AddWelcm.h"
#include "resource.h"

//
//  FUNCTION: CWelcomeDlg constructor
//
//  PURPOSE:  initialize a CWelcomeDlg class
//
CWelcomeDlg::CWelcomeDlg()
{
} // constructor


//
//  FUNCTION: CWelcomeDlg destructor
//
//  PURPOSE:  deinitialize a CWelcomeDlg class
//
CWelcomeDlg::~CWelcomeDlg()
{
} // destructor


//
//  FUNCTION: WelcomeDialog(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the welcome dialog for adding a port.
//
//  MESSAGES:
//	
//	WM_INITDIALOG - intializes the page
//	WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY WelcomeDialog(
	HWND    hDlg,
	UINT    message,
	WPARAM  wParam,
	LPARAM  lParam)
{
	CWelcomeDlg *wndDlg = NULL;
	wndDlg = (CWelcomeDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	switch (message)
	{
		case WM_INITDIALOG:
			wndDlg = new CWelcomeDlg;
            if( wndDlg == NULL )
                return( FALSE );

			SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
			return wndDlg->OnInitDialog(hDlg, wParam, lParam);
			break;

		case WM_COMMAND:
			return wndDlg->OnCommand(hDlg, wParam, lParam);
			break;

		case WM_NOTIFY:
			return wndDlg->OnNotify(hDlg, wParam, lParam);
			break;

		case WM_DESTROY:
			delete wndDlg;
			break;

		default:
			return FALSE;
	}
	return TRUE;

} // AddPortDialog

//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CWelcomeDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
	m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

	// Initialize the outgoing structure
	m_pParams->dwDeviceType = 0;
	m_pParams->pData->cbSize = sizeof(PORT_DATA_1);
	m_pParams->pData->dwCoreUIVersion = COREUI_VERSION;
	lstrcpyn(m_pParams->pData->sztPortName, TEXT(""), MAX_PORTNAME_LEN);
	lstrcpyn(m_pParams->pData->sztHostAddress, TEXT(""), MAX_NETWORKNAME_LEN);
	m_pParams->pData->dwPortNumber = DEFAULT_PORT_NUMBER;
	m_pParams->pData->dwVersion = DEFAULT_VERSION;
	m_pParams->pData->dwProtocol = DEFAULT_PROTOCOL;
	
	lstrcpyn(m_pParams->pData->sztQueue, TEXT(""), MAX_QUEUENAME_LEN);
	lstrcpyn(m_pParams->pData->sztIPAddress, TEXT(""), MAX_IPADDR_STR_LEN);
	lstrcpyn(m_pParams->pData->sztHardwareAddress, TEXT(""), MAX_ADDRESS_STR_LEN);

	lstrcpyn(m_pParams->pData->sztSNMPCommunity, DEFAULT_SNMP_COMUNITY, MAX_SNMP_COMMUNITY_STR_LEN);
	m_pParams->pData->dwSNMPEnabled = FALSE;
    m_pParams->pData->dwSNMPDevIndex = DEFAULT_SNMP_DEVICE_INDEX;

    m_pParams->UIManager->SetControlFont(hDlg, IDC_TITLE);

	return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CWelcomeDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	switch(HIWORD(wParam)) {
		case BN_CLICKED:
			// return OnButtonClicked(hDlg, wParam);
			break;
		
		case EN_UPDATE:
			// one of the text controls had text changed in it.
			// return OnEnUpdate(hDlg, wParam, lParam);
			break;
		default:
			return FALSE;
			break;
	}

	return TRUE;

} // OnCommand


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CWelcomeDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	switch (((NMHDR FAR *) lParam)->code) {
  		case PSN_KILLACTIVE:
			SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
			return TRUE;
			break;

		case PSN_RESET:
			// reset to the original values
			SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
			break;

 		case PSN_SETACTIVE:
			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT /*| PSWIZB_BACK | PSWIZB_FINISH */);
			break;

		case PSN_WIZNEXT:
			// the Next button was pressed
     		break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

		default:
			return FALSE;

    }

	return TRUE;

} // OnCommand
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addwelcm.h ===
/*****************************************************************************
 *
 * $Workfile: AddWelcm.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/TcpMonUI/AddWelcm.h $
 * 
 * 2     9/12/97 9:43a Becky
 * Added Variable m_pParams
 * 
 * 1     8/19/97 3:45p Becky
 * Redesign of the Port Monitor UI.
 * 
 *****************************************************************************/

#ifndef INC_ADDWELCOME_H
#define INC_ADDWELCOME_H

// Global Variables
extern HINSTANCE g_hInstance;

class CWelcomeDlg
{
public:
	CWelcomeDlg();
	~CWelcomeDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

private:
	ADD_PARAM_PACKAGE *m_pParams;

}; // CWelcomeDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
BOOL APIENTRY WelcomeDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDWELCOME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgall.cpp ===
/*****************************************************************************
 *
 * $Workfile: CfgAll.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  * 
  * This file contains the dialog for configuring an existing port for the port monitor.
  */
#include "precomp.h"
#include "CoreUI.h"
#include "resource.h"    // includes the definitions for the resources
#include "RTcpData.h"
#include "CfgAll.h"     // includes the application-specific information
#include "TcpMonUI.h"

// Global variables:
extern HINSTANCE g_hInstance;


//
//  FUNCTION: AllPortsPage(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the page for configuring all
//              the tcp monitor ports in the system.
//
//  MESSAGES:
//  
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handle button clicks
//  WM_NOTIFY - handle reset
//  WM_HSCROLL - handle scroll events from the 2 trackbars
//
BOOL APIENTRY AllPortsPage(HWND hDlg,
                           UINT message,
                           WPARAM wParam,
                           LPARAM lParam)
{
    CAllPortsPage *wndDlg = NULL;
    wndDlg = (CAllPortsPage *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch(message)
    {
        case WM_INITDIALOG:
            wndDlg = (CAllPortsPage *) new CAllPortsPage;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnWMNotify(hDlg, wParam, lParam);
            break;

        case WM_HSCROLL:
            wndDlg->OnHscroll(hDlg, wParam, lParam);
            break;

        case WM_HELP:
            OnHelp(IDD_DIALOG_CONFIG_ALL, hDlg, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }

    return TRUE;

} // AllPortsPage


//
//  FUNCTION: CAllPortsPage Constructor
//
//  PURPOSE:
//
CAllPortsPage::CAllPortsPage()
{
} // Constructor


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  To initialize the allports dialog.  Calls SetupTrackBar for each dialog
//              and checks or unchecks the Status Update enabled check box as appropriate.
//
BOOL CAllPortsPage::OnInitDialog(HWND hDlg,
                                 WPARAM,
                                 LPARAM lParam)
{
    m_pParams = (CFG_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;
    
    SetupTrackBar(hDlg, IDC_TRACKBAR_FAILURE_TIMEOUT, IDC_TRACKBAR_TOP, FT_MIN, FT_MAX, m_pParams->pData->FailureTimeout, FT_PAGESIZE, IDC_DIGITAL_FAILURE_TIMEOUT);
    SendMessage(GetDlgItem(hDlg, IDC_CHECK_STATUSUPDATE), BM_SETCHECK, (WPARAM)BST_CHECKED, (LPARAM)0);
    
    if(m_pParams->pData->SUEnabled == FALSE) {
        // EnableStatusUpdate(hDlg, FALSE);
        CheckDlgButton(hDlg, IDC_CHECK_STATUSUPDATE, BST_UNCHECKED);
    } else {
        CheckDlgButton(hDlg, IDC_CHECK_STATUSUPDATE, BST_CHECKED);
    }

    return TRUE;

} // OnAllPortsInitDialog


//
//  FUNCTION: OnCommand
//
//  PURPOSE: To process windows WM_COMMAND messages
//
BOOL CAllPortsPage::OnCommand(HWND hDlg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    if(HIWORD(wParam) == BN_CLICKED) {
        // a button is being clicked.
        OnBnClicked(hDlg, wParam, lParam);
    }
    return TRUE;

} // OnCommand



//
// FUNCTION: OnWMNotify
//
// PURPOSE:  This function is called by the page in response to a WM_NOTIFY message.
// 
// lParam - second message parameter of the WM_NOTIFY message
//
BOOL CAllPortsPage::OnWMNotify(HWND hDlg, WPARAM, LPARAM lParam)
{
    switch(((NMHDR FAR *) lParam)->code) {
        case PSN_APPLY:
// 
//      The settings will be written by the apply in cfgport.cpp
//          OnOk(hDlg);
            break;
        case PSN_SETACTIVE:
            {
            }
            break;
        case PSN_RESET:
            {
            }
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            break;// do nothing
    }

    return TRUE;

} // OnWMNotify


//
//  FUNCTION: OnHscroll(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  To set the Digital Readout window text when either of the
//              trackbar thumbs are moved by the user.
//
void CAllPortsPage::OnHscroll(HWND hDlg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    TCHAR strValue[15] = NULLSTR;
    long idTrackbar = 0;
    long idDigitalReadout = 0;

    // I need the child window ID of this trackbar to get the id
    // of the corresponding static display control.
    idTrackbar = GetWindowLong((HWND)lParam, GWL_ID);
    
    if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT) {
        idDigitalReadout = IDC_DIGITAL_FAILURE_TIMEOUT;
    }

    switch(LOWORD(wParam)) // loword of wparam is the notification code.
    {
        case TB_BOTTOM: // VK_END
        case TB_ENDTRACK: // WM_KEYUP (the user released a key that sent a relevant virtual-key code)
        case TB_LINEDOWN: // VK_RIGHT or VK_DOWN
        case TB_LINEUP: // VK_LEFT or VK_UP
        case TB_PAGEDOWN: // VK_NEXT (the user clicked the channel below or to the right of the slider)
        case TB_PAGEUP: // VK_PRIOR (the user clicked the channel above or to the left of the slider)
        case TB_TOP: // VK_HOME
            {
                int iPosition = SendMessage(GetDlgItem(hDlg, idTrackbar), TBM_GETPOS, 0, 0);
                if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT)
                {
                    m_pParams->pData->FailureTimeout = iPosition;
                }
                _stprintf(strValue, TEXT("%d"), iPosition);
            }
            break;
        case TB_THUMBPOSITION: // WM_LBUTTONUP following a TB_THUMBTRACK notification message
            {
                // this is the only case where we don't have to do anything.
                // int iPosition = HIWORD(wParam);
            }
            break;
        case TB_THUMBTRACK: // Slider movement (the user dragged the slider)
            {
                int iPosition = HIWORD(wParam);
                if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT)
                {
                    m_pParams->pData->FailureTimeout = iPosition;
                }

                _stprintf(strValue, TEXT("%d"), iPosition);
            }
            break;
        default:
            break;
    }

    SetWindowText(GetDlgItem(hDlg, idDigitalReadout), strValue);


} // OnHscroll


//
//  FUNCTION: OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  When the enable Status Update checkbox is checked or unchecked
//              the status update controls are enabled or disabled respectively.
//
void CAllPortsPage::OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    if(LOWORD(wParam) == IDC_CHECK_STATUSUPDATE) {
        // the Enable Status Update button was clicked.
        UINT state = IsDlgButtonChecked(hDlg, LOWORD(wParam));
        if(state == BST_UNCHECKED) {
            m_pParams->pData->SUEnabled = FALSE;
        } else {
            m_pParams->pData->SUEnabled = TRUE;
        }
    }

} // OnBnClicked


//
//  FUNCTION: SetupTrackBar(...)
//
//  PURPOSE:  To get the window position, create the track bar and setup it's range
//              and current thumb position.
//
//  Arguments: hDlg is the dialog box that will be the parent of the track bar.
//              iChildWindowID is the id given to the Track Bar
//              iPositionCtrl is the id of a picture frame on the dialog that will
//                  be used to position the track bar.
//              iRangeMin is the minimum value the track bar can be set to.
//              iRangeMax is the maximum value the track bar can be set to.
//              lPosition is the current thumb position.
//              lPageSize is the amount the thumb will jump by when the user clicks
//                  on the track bar instead of dragging the thumb around.
//              iAssociatedDigitalReadout is the static text control that displays
//                  the current value the thumb is indicating.
//              hToolTip is the tool tip control to register a tool tip with.
//
void CAllPortsPage::SetupTrackBar(HWND hDlg,
                   int iChildWindowID,
                   int iPositionCtrl,
                   int iRangeMin, 
                   int iRangeMax, 
                   long lPosition, 
                   long lPageSize, 
                   int iAssociatedDigitalReadout)
{
    HWND    hTrackBar = NULL;
    RECT    r;
    POINT   pt1;
    POINT   pt2;

    GetWindowRect(GetDlgItem(hDlg, iPositionCtrl), &r);
    pt1.x = r.left;
    pt1.y = r.top;
    pt2.x = r.right;
    pt2.y = r.bottom;
    ScreenToClient(hDlg, &pt1);
    ScreenToClient(hDlg, &pt2);     

    hTrackBar = CreateWindowEx(0, TRACKBAR_CLASS, TEXT(""), WS_VISIBLE | WS_CHILD | WS_GROUP | WS_TABSTOP |
            TBS_HORZ, pt1.x, pt1.y, pt2.x - pt1.x,
            pt2.y - pt1.y, hDlg, (HMENU)iChildWindowID, g_hInstance, NULL);
    
    SendMessage(hTrackBar, TBM_SETRANGE, TRUE, MAKELONG(iRangeMin, iRangeMax));
    SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, lPageSize);
    SendMessage(hTrackBar, TBM_SETPOS, TRUE, lPosition);

    TCHAR strValue[5];
    _stprintf(strValue, TEXT("%d"), lPosition);
    SetWindowText(GetDlgItem(hDlg, iAssociatedDigitalReadout), strValue);

} // SetupTrackBar
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgall.h ===
/*****************************************************************************
 *
 * $Workfile: CfgAll.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon2/TcpMonUI/CfgAll.h $
 *
 * 7     3/05/98 11:23a Dsnelson
 * Removed redundant code.
 *
 * 5     10/03/97 10:56a Becky
 * Removed OnHelp()
 *
 * 4     10/02/97 3:45p Becky
 * Changed FT_MIN (Failure Timeout Minimum) from 5 minutes to 1 minute.
 *
 * 3     9/16/97 2:44p Becky
 * Added OnOk() to actually set the data in the port monitor when the ok
 * button is clicked.
 *
 * 2     9/09/97 4:35p Becky
 * Updated to use the new Monitor UI data structure.
 *
 * 1     8/19/97 3:46p Becky
 * Redesign of the Port Monitor UI.
 *
 *****************************************************************************/

#ifndef INC_ALLPORTS_PAGE_H
#define INC_ALLPORTS_PAGE_H

// Values for Failure Timeout
#define FT_MIN		  1
#define FT_MAX		 60
#define FT_PAGESIZE	 10

// Includes:
//#include "UIMgr.h"


class CAllPortsPage
{
public:
	CAllPortsPage();
	BOOL OnInitDialog(HWND hDlg, WPARAM, LPARAM);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void OnHscroll(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnWMNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void SetupTrackBar(HWND hDlg,
						int iChildWindowID,
						int iPositionCtrl,
						int iRangeMin,
						int iRangeMax,
						long lPosition,
						long lPageSize,
						int iAssociatedDigitalReadout);

private:
	CFG_PARAM_PACKAGE *m_pParams;

}; // class CAllPortsPage

#ifdef __cplusplus
extern "C"
{
#endif

// Property sheet page function
BOOL APIENTRY AllPortsPage(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ALLPORTS_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgport.h ===
/*****************************************************************************
 *
 * $Workfile: CfgPort.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_CONFIG_PORT_H
#define INC_CONFIG_PORT_H

// Global Variables
extern HINSTANCE g_hInstance;

class CConfigPortDlg
{
public:
	CConfigPortDlg();
	~CConfigPortDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void CheckProtocolAndEnable(HWND hDlg, int idButton);
	void CheckSNMPAndEnable(HWND hDlg, BOOL Check);
	void OnOk(HWND hDlg);
	void SaveSettings(HWND hDlg);
	BOOL OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM);
	void OnSetActive(HWND hDlg);
	BOOL OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);

	void HostAddressOk(HWND hDlg);
	void PortNumberOk(HWND hDlg);
	void QueueNameOk(HWND hDlg);
	void CommunityNameOk(HWND hDlg);
	void DeviceIndexOk(HWND hDlg);

	DWORD RemoteTellPortMonToModifyThePort();
	DWORD LocalTellPortMonToModifyThePort();

private:
	CFG_PARAM_PACKAGE *m_pParams;
	CInputChecker m_InputChkr;
	BOOL m_bDontAllowThisPageToBeDeactivated;

}; // CConfigPortDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs

BOOL APIENTRY ConfigurePortPage(
	HWND hDlg,
	UINT message,
	WPARAM wParam,
	LPARAM lParam);


#ifdef __cplusplus
}
#endif

#endif // INC_CONFIG_PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgport.cpp ===
/*****************************************************************************
 *
 * $Workfile: CfgPort.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "CfgPort.h"
#include "Resource.h"

#include "LPRData.h"
#include "RTcpData.h"
#include "..\TcpMon\LPRIfc.h"

//
//  FUNCTION: CConfigPortDlg constructor
//
//  PURPOSE:  initialize a CConfigPortDlg class
//
CConfigPortDlg::CConfigPortDlg()
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // constructor


//
//  FUNCTION: CConfigPortDlg destructor
//
//  PURPOSE:  deinitialize a CConfigPortDlg class
//
CConfigPortDlg::~CConfigPortDlg()
{
} // destructor


//
//  FUNCTION: ConfigurePortPage(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
BOOL APIENTRY ConfigurePortPage(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    CConfigPortDlg *wndDlg = NULL;
    wndDlg = (CConfigPortDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CConfigPortDlg;
            if( wndDlg == NULL )
                return( FALSE );

            //
            // If the function succeeds, the return value is the previous value of the specified offset.
            //
            // If the function fails, the return value is zero. To get extended error
            // information, call GetLastError.
            //
            // If the previous value is zero and the function succeeds, the return value is zero,
            // but the function does not clear the last error information. To determine success or failure,
            // clear the last error information by calling SetLastError(0), then call SetWindowLongPtr.
            // Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            //

            SetLastError (0);
            if (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) && GetLastError()) {
                delete wndDlg;
                return FALSE;
            }
            else
                return wndDlg->OnInitDialog(hDlg, wParam, lParam);

            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            OnHelp(IDD_PORT_SETTINGS, hDlg, message, wParam, lParam);
            break;

        case WM_DESTROY:
            if (wndDlg)
                delete wndDlg;

            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CConfigPortDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (CFG_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    if(m_pParams->bNewPort == FALSE) {
        SendMessage(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), EM_SETREADONLY, TRUE, 0);
    }

    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), MAX_ADDRESS_LENGTH);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), MAX_PORTNAME_LEN - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), MAX_PORTNUM_STRING_LENGTH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), MAX_QUEUENAME_LEN - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), MAX_SNMP_COMMUNITY_STR_LEN);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), MAX_SNMP_DEVICENUM_STRING_LENGTH - 1);

    OnSetActive(hDlg);

    return TRUE;

} // OnInitDialog


//
// Function: OnSetActive()
//
// Purpose: To Set all the text fields and make sure the proper buttons are checked.
//
void CConfigPortDlg::OnSetActive(HWND hDlg)
{
    TCHAR psztPortNumber[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    TCHAR psztSNMPDevIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    TCHAR szTemp[MAX_PATH];

    lstrcpyn(szTemp, m_pParams->pData->sztHostAddress, SIZEOF_IN_CHAR(szTemp));
    m_InputChkr.MakePortName( szTemp );
    if ( m_pParams->bNewPort    &&
         ((_tcscmp(m_pParams->pData->sztHostAddress,
                   m_pParams->pData->sztPortName) == 0) ||
          (_tcscmp(m_pParams->pData->sztPortName, szTemp) == 0 ))) {

        m_InputChkr.LinkPortNameAndAddressInput();
    } else {

        m_InputChkr.UnlinkPortNameAndAddressInput();
    }

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS),
                  m_pParams->pData->sztHostAddress);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME),
                  m_pParams->pData->sztPortName);

    switch (m_pParams->pData->dwProtocol) {

        case PROTOCOL_LPR_TYPE :
            CheckProtocolAndEnable(hDlg, IDC_RADIO_LPR);
            break;
        case PROTOCOL_RAWTCP_TYPE:
            CheckProtocolAndEnable(hDlg, IDC_RADIO_RAW);
            break;
        default:
            break;
    }

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME),
                  m_pParams->pData->sztQueue);

    if( m_pParams->pData->dwDoubleSpool )
    {
        CheckDlgButton(hDlg, IDC_CHECK_LPR_DOUBLESPOOL, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_CHECK_LPR_DOUBLESPOOL, BST_UNCHECKED);
    }


    _stprintf(psztPortNumber, TEXT("%d"), m_pParams->pData->dwPortNumber);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM),
                  psztPortNumber);

    CheckSNMPAndEnable(hDlg, m_pParams->pData->dwSNMPEnabled);

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME),
                  m_pParams->pData->sztSNMPCommunity);

    _stprintf(psztSNMPDevIndex, TEXT("%d"), m_pParams->pData->dwSNMPDevIndex);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), psztSNMPDevIndex);

    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // OnSetActive


//
//  FUNCTION: CheckProtocolAndEnable()
//
//  PURPOSE:  Check the radio button whose id is passed in
//      in idButton.  Enable the corresponding set of controls
//      and disable the controls corresponding to the other
//      radio button.
//
void CConfigPortDlg::CheckProtocolAndEnable(HWND hDlg, int idButton)
{
    CheckRadioButton(hDlg, IDC_RADIO_RAW, IDC_RADIO_LPR, idButton);

    switch ( idButton ) {

        case IDC_RADIO_LPR:
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RAW_PORT_NUM), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_LPR_QNAME), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_LPR_DOUBLESPOOL), TRUE);
            break;

    case IDC_RADIO_RAW: {
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RAW_PORT_NUM), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), TRUE);

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_LPR_QNAME), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_LPR_DOUBLESPOOL), FALSE);

            const int iSize = 6;
            TCHAR pString[iSize] = NULLSTR;
            TCHAR pCompareString[iSize] = NULLSTR;

            _stprintf(pCompareString, TEXT("%d"), LPR_PORT_1);
            GetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), pString, iSize);
            if( _tcscmp(pString, pCompareString) == 0 ) {

                _stprintf(pString, TEXT("%d"), SUPPORTED_PORT_1);
                SetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), pString);
            }
        }
        break;

    default:
        break;
    }

} // CheckProtocolAndEnable


//
//  FUNCTION: CheckSNMPAndEnable()
//
//  PURPOSE:  Check the SNMP CheckBox and Enable the corresponding controls
//          or uncheck and disable.
//
void CConfigPortDlg::CheckSNMPAndEnable(HWND hDlg, BOOL Check)
{
    if(Check != FALSE) {
        CheckDlgButton(hDlg, IDC_CHECK_SNMP, BST_CHECKED);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_COMMUNITY_NAME), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE_INDEX), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), TRUE);
    } else {
        CheckDlgButton(hDlg, IDC_CHECK_SNMP, BST_UNCHECKED);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_COMMUNITY_NAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE_INDEX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), FALSE);
    }

} // CheckSNMPAndEnable

//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CConfigPortDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case BN_CLICKED:
            return OnButtonClicked(hDlg, wParam, lParam);
            break;

        case EN_UPDATE:
            // one of the text controls had text changed in it.
            return OnEnUpdate(hDlg, wParam, lParam);
            break;

        default:
            break;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnEnUpdate()
//
//  PURPOSE:  Process EN_UPDATE message
//
BOOL CConfigPortDlg::OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int idEditCtrl = (int) LOWORD(wParam);
    HWND hwndEditCtrl = NULL;

    hwndEditCtrl = (HWND) lParam;

    if(idEditCtrl == IDC_EDIT_DEVICE_ADDRESS) {
        m_InputChkr.OnUpdateAddress(hDlg, idEditCtrl, hwndEditCtrl, m_pParams->pszServer);
    }

    //
    // Port name is a read-only field
    //
    //  if(idEditCtrl == IDC_EDIT_PORT_NAME)
    //      m_InputChkr.OnUpdatePortName(idEditCtrl, hwndEditCtrl);
    //

    if(idEditCtrl == IDC_EDIT_RAW_PORT_NUM) {
        m_InputChkr.OnUpdatePortNumber(idEditCtrl, hwndEditCtrl);
    }

    if(idEditCtrl == IDC_EDIT_LPR_QNAME) {
        m_InputChkr.OnUpdateQueueName(idEditCtrl, hwndEditCtrl);
    }

    if(idEditCtrl == IDC_EDIT_COMMUNITY_NAME) {
        // No function needed since any character is ok.
    }

    if(idEditCtrl == IDC_EDIT_DEVICE_INDEX) {
        m_InputChkr.OnUpdateDeviceIndex(idEditCtrl, hwndEditCtrl);
    }

    return TRUE;

} // OnEnUpdate


//
//  FUNCTION: OnButtonClicked()
//
//  PURPOSE:  Process BN_CLICKED message
//
BOOL CConfigPortDlg::OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int  idButton = (int) LOWORD(wParam);    // identifier of button
    HWND hwndButton = NULL;

    hwndButton = (HWND) lParam;

    switch(idButton) {
        case IDC_CHECK_SNMP:
        {
            LRESULT iCheck = SendMessage(hwndButton, BM_GETCHECK, 0, 0);
            switch( iCheck ) {
                case BST_UNCHECKED:
                    CheckSNMPAndEnable(hDlg, FALSE);
                    break;

                case BST_CHECKED:
                    CheckSNMPAndEnable(hDlg, TRUE);
                    break;

                default:
                    //
                    // False by Default
                    CheckSNMPAndEnable(hDlg, FALSE);
                    break;
            }
        }
        break;

        case IDC_RADIO_RAW:
        case IDC_RADIO_LPR:
            CheckProtocolAndEnable(hDlg, idButton);
            break;

        default:
            break;

    }
    return TRUE;

} // OnButtonClicked


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CConfigPortDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code)
    {
        case PSN_APPLY:
            OnOk(hDlg);
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return TRUE;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            OnSetActive(hDlg);
            break;

        case PSN_KILLACTIVE:
            SaveSettings(hDlg);
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return TRUE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
// FUNCTION: RemoteTellPortMonToModifyThePort
//
// PURPOSE:  Loads the spooler drv and calls XcvData.
//
DWORD CConfigPortDlg::RemoteTellPortMonToModifyThePort()
{
    DWORD dwRet = NO_ERROR;
    XCVDATAPARAM pfnXcvData = NULL;

    // load & assign the function pointer
    if(g_hWinSpoolLib != NULL) {

        // initialize the library
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
        if(pfnXcvData != NULL) {

            DWORD dwOutputNeeded = 0;
            DWORD dwStatus = 0;

            // here's the call we've all been waiting for:
            DWORD dwReturn = (*pfnXcvData)(m_pParams->hXcvPrinter,
                                (PCWSTR)TEXT("ConfigPort"),
                                (PBYTE)m_pParams->pData,
                                m_pParams->pData->cbSize,
                                NULL,
                                0,
                                &dwOutputNeeded,
                                &dwStatus
                                );
            if(!dwReturn) {
                dwRet = GetLastError();
            } else {
                if(dwStatus != NO_ERROR) {
                    dwRet = dwStatus;
                }
            }
        } else {
            dwRet = ERROR_DLL_NOT_FOUND; // TODO: change to an appropriate error code.
        }
    } else {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    m_pParams->dwLastError = dwRet;
    return dwRet;

} // RemoteTellPortMonToModifyThePort


//
//  FUNCTION: LocalTellPortMonToModifyThePort
//
//  Purpose: To load the port monitor dll and call ConfigPortUIEx
//
DWORD CConfigPortDlg::LocalTellPortMonToModifyThePort()
{
    DWORD dwRet = NO_ERROR;
    UIEXPARAM pfnConfigPortUIEx = NULL ;

    if(g_hPortMonLib != NULL) {
        // initialize the library
        pfnConfigPortUIEx = (UIEXPARAM)::GetProcAddress(g_hPortMonLib, "ConfigPortUIEx");
        if(pfnConfigPortUIEx != NULL) {
            // here's the call we've all been waiting for:
            BOOL bReturn = (*pfnConfigPortUIEx)(m_pParams->pData);
            if(bReturn == FALSE) {
                dwRet = GetLastError();
            }
        } else {
            dwRet = ERROR_DLL_NOT_FOUND;
        }
    } else {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    m_pParams->dwLastError = dwRet;
    return dwRet;

} // LocalTellPortMonToModifyThePort


//
//  FUNCTION OnOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::OnOk(HWND hDlg)
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

    HostAddressOk(hDlg);

    if(IsDlgButtonChecked(hDlg, IDC_RADIO_LPR) == BST_CHECKED) {
        m_pParams->pData->dwProtocol = PROTOCOL_LPR_TYPE;
        m_pParams->pData->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;
        QueueNameOk(hDlg);
    } else { // IDC_RADIO_RAW
        m_pParams->pData->dwProtocol = PROTOCOL_RAWTCP_TYPE;
        PortNumberOk(hDlg);
    }

    if(IsDlgButtonChecked(hDlg, IDC_CHECK_SNMP) == BST_CHECKED) {
        m_pParams->pData->dwSNMPEnabled = TRUE;
        CommunityNameOk(hDlg);
        DeviceIndexOk(hDlg);
    } else {
        m_pParams->pData->dwSNMPEnabled = FALSE;
    }


    if(m_pParams->bNewPort == FALSE &&
        m_bDontAllowThisPageToBeDeactivated == FALSE) {

        HCURSOR hOldCursor = NULL;
        HCURSOR hNewCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if( hNewCursor )
        {
            hOldCursor = SetCursor(hNewCursor);
        }
        // The port is not just being created so we can tell the PortMon to
        // modify the port... it is an existing port.

        // There were no errors, so we can go ahead and modify this port.
        if(m_pParams->hXcvPrinter != NULL) {
            RemoteTellPortMonToModifyThePort();
        } else {
            LocalTellPortMonToModifyThePort();
        }

        if( hNewCursor )
        {
            SetCursor(hOldCursor);
        }
    }

} // OnOk

//
//  FUNCTION OnOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::SaveSettings(HWND hDlg)
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

    HostAddressOk(hDlg);

    if(IsDlgButtonChecked(hDlg, IDC_RADIO_LPR) == BST_CHECKED) {
        m_pParams->pData->dwProtocol = PROTOCOL_LPR_TYPE;
        m_pParams->pData->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;
        if( IsDlgButtonChecked(hDlg, IDC_CHECK_LPR_DOUBLESPOOL) == BST_CHECKED )
        {
            m_pParams->pData->dwDoubleSpool = TRUE;
        }
        else
        {
            m_pParams->pData->dwDoubleSpool = FALSE;
        }
        QueueNameOk(hDlg);
    } else {// IDC_RADIO_RAW
        m_pParams->pData->dwProtocol = PROTOCOL_RAWTCP_TYPE;
        PortNumberOk(hDlg);
    }

    if(IsDlgButtonChecked(hDlg, IDC_CHECK_SNMP) == BST_CHECKED) {
        m_pParams->pData->dwSNMPEnabled = TRUE;
        CommunityNameOk(hDlg);
        DeviceIndexOk(hDlg);
    } else {
        m_pParams->pData->dwSNMPEnabled = FALSE;
    }

} // SaveSettings

//
//  FUNCTION HostAddressOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::HostAddressOk(HWND hDlg)
{
    TCHAR ptcsAddress[MAX_ADDRESS_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), ptcsAddress, MAX_ADDRESS_LENGTH);

    if(! m_InputChkr.AddressIsLegal(ptcsAddress)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ADDRESS_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztHostAddress, ptcsAddress, MAX_NETWORKNAME_LEN);

} // HostAddressOk


//
//  FUNCTION PortNumberOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::PortNumberOk(HWND hDlg)
{
    TCHAR psztPortNumber[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM),
                  psztPortNumber,
                  MAX_PORTNUM_STRING_LENGTH);

    if(! m_InputChkr.PortNumberIsLegal(psztPortNumber)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_PORT_NUMBER_NOT_VALID);
        return;
    }

    m_pParams->pData->dwPortNumber = _ttol(psztPortNumber);

} // PortNumberOk


//
//  FUNCTION QueueNameOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::QueueNameOk(HWND hDlg)
{
    TCHAR ptcsQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME),
                  ptcsQueueName,
                  MAX_QUEUENAME_LEN);

    if(! m_InputChkr.QueueNameIsLegal(ptcsQueueName))
    {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_QNAME_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztQueue, ptcsQueueName, MAX_QUEUENAME_LEN);

} // QueueNameOk


//
//  FUNCTION CommunityNameOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::CommunityNameOk(HWND hDlg)
{
    TCHAR ptcsCommunityName[MAX_SNMP_COMMUNITY_STR_LEN] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME),
                  ptcsCommunityName,
                  MAX_SNMP_COMMUNITY_STR_LEN);

    if(! m_InputChkr.CommunityNameIsLegal(ptcsCommunityName)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_COMMUNITY_NAME_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztSNMPCommunity, ptcsCommunityName, MAX_SNMP_COMMUNITY_STR_LEN);

} // CommunityNameOk


//
//  FUNCTION DeviceIndexOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::DeviceIndexOk(HWND hDlg)
{
    TCHAR psztSNMPDevIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg,
                             IDC_EDIT_DEVICE_INDEX),
                             psztSNMPDevIndex,
                             MAX_SNMP_DEVICENUM_STRING_LENGTH);

    if(! m_InputChkr.SNMPDevIndexIsLegal(psztSNMPDevIndex)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_SNMP_DEVINDEX_NOT_VALID);
        return;
    }

    m_pParams->pData->dwSNMPDevIndex = _ttol(psztSNMPDevIndex);

} // DeviceIndexOk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\devport.cpp ===
/*****************************************************************************
 *
 * $Workfile: DevPort.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "DevPort.h"
#include "winreg.h"
#include "TcpMonUI.h"
#include "rtcpdata.h"
#include "lprdata.h"
#include "inisection.h"

//
//  FUNCTION: CDevicePortList Constructor
//
//  PURPOSE: to construct a list of devices and their associated ports
//          from the registry, an ini file or from a static table in the code.
//
CDevicePortList::CDevicePortList() : m_pList( NULL ), m_pCurrent( NULL )
{
} // Constructor


//
//  FUNCTION: CDevicePortList Destructor
//
//  PURPOSE: clean up
//
CDevicePortList::~CDevicePortList()
{
    DeletePortList();
} // Destructor

void
CDevicePortList::DeletePortList()
{
    while(m_pList != NULL)
    {
        m_pCurrent = m_pList->GetNextPtr();
        delete m_pList;
        m_pList = m_pCurrent;
    }
}

//
//  FUNCTION: GetDevicePortsList
//
//  PURPOSE: To create a Device types list getting values from the ini file.
//
BOOL CDevicePortList::GetDevicePortsList(LPTSTR pszDeviceName)
{
    BOOL    bRet = FALSE;
    TCHAR   szSystemPath[MAX_PATH] = NULLSTR;
    TCHAR   szFileName[MAX_PATH] = NULLSTR;

    DeletePortList();

    GetSystemDirectory(szSystemPath, sizeof(szSystemPath) / sizeof (TCHAR));
    _tcscat(szFileName, (LPCTSTR)&szSystemPath);
    _tcscat(szFileName, PORTMONITOR_INI_FILE );

    //
    // Get the section names from the ini file:
    //
    if( pszDeviceName == NULL ) { // Get all the devices

        DWORD nSize = 0;
        TCHAR *lpszReturnBuffer = NULL;

        if ( !GetSectionNames(szFileName, &lpszReturnBuffer, nSize) )
            goto Done;

        //
        // For each section name Load up the number of ports
        //
        TCHAR *lpszSectionName = lpszReturnBuffer;
        LPCTSTR lpKeyName = PORTS_KEY;
        while( lpszSectionName && *lpszSectionName ) {

            TCHAR KeyName[26] = NULLSTR;
            LPCTSTR lpPortsKeyName = PORTS_KEY;
            UINT NumberOfPorts = GetPrivateProfileInt(lpszSectionName,
                                                      lpPortsKeyName,
                                                      0,
                                                      szFileName);
            //
            // Name
            //
            _stprintf(KeyName, PORT_NAME_KEY);
            TCHAR tcsPortName[MAX_PORTNAME_LEN] = NULLSTR;
            if ( GetPrivateProfileString(lpszSectionName,
                                         KeyName,
                                         TEXT(""),
                                         tcsPortName,
                                         MAX_PORTNAME_LEN,
                                         szFileName)    ) {

                //
                // Setup a new DevicePort struct
                //
                if ( m_pCurrent  = new CDevicePort() ) {

                    m_pCurrent->Set(tcsPortName,
                                    _tcslen(tcsPortName),
                                    lpszSectionName,
                                    _tcslen(lpszSectionName),
                                    (NumberOfPorts == 1));

                   m_pCurrent->SetNextPtr(m_pList);
                   m_pList = m_pCurrent;
                }
                else
                    // Out of memory, abort
                    //
                    goto Done;
            }
            /* else
                If the call fails, we continue to the next adapter name */

            lpszSectionName = _tcschr(lpszSectionName, '\0'); // find the end of the current string.
            lpszSectionName = _tcsinc(lpszSectionName); // increment to the beginning of the next string.
        }

        //
        // free memory
        //
        free(lpszReturnBuffer);

    } else  {// Just the names in multiport section

        TCHAR     KeyName[26];

        //
        // Name
        //
        LPCTSTR lpKeyName = PORTS_KEY;
        UINT NumberOfPorts = GetPrivateProfileInt(pszDeviceName,
                                                  lpKeyName,
                                                  0,
                                                  szFileName);

        for ( UINT i=0; i<NumberOfPorts; i++ ) {

            _stprintf(KeyName, PORT_NAMEI_KEY, i+1);
            TCHAR tcsPortName[50] = NULLSTR;
            GetPrivateProfileString(pszDeviceName, KeyName,
                                    TEXT(""), tcsPortName, 50, szFileName);

            //
            // Setup a new DevicePort struct
            //
            if ( m_pCurrent = new CDevicePort() ) {

                m_pCurrent->Set(tcsPortName,
                                _tcslen(tcsPortName),
                                pszDeviceName,
                               _tcslen(pszDeviceName), i+1);
                m_pCurrent->SetNextPtr(m_pList);

                m_pList = m_pCurrent;
            }
            else
                goto Done;
        }
    }

    bRet = TRUE;
Done:
    //
    // Do not leave with a partial list
    //
    if ( !bRet )
        DeletePortList();

    return bRet;
} // GetDevicePortsList


//
//  FUNCTION: ReadPortInfo
//
//  PURPOSE: To read information about a device from the ini file.
//
void CDevicePort::ReadPortInfo( LPCTSTR pszAddress, PPORT_DATA_1 pPortInfo, BOOL bBypassNetProbe)
{
    IniSection *pIniSection;

    if ( m_psztPortKeyName ) {

        if ( pIniSection = new IniSection() ) {

            pIniSection->SetIniSection( m_psztPortKeyName );

            pIniSection->GetPortInfo( pszAddress, pPortInfo, m_dwPortIndex, bBypassNetProbe);
            delete( pIniSection );
        }
    }
} // ReadPortInfo


//
//  FUNCTION: GetSectionNames
//
//  PURPOSE:
//
BOOL
CDevicePortList::
GetSectionNames(
    LPCTSTR lpFileName,
    TCHAR **lpszReturnBuffer,
    DWORD &nSize
)
{
    DWORD   nReturnSize = 0;
    LPTSTR  pNewBuf;

    do
    {
        nSize += 512;
        pNewBuf = (TCHAR *)realloc(*lpszReturnBuffer, nSize * sizeof(TCHAR));

        if ( pNewBuf == NULL )
        {
            if ( *lpszReturnBuffer )
            {
                free(*lpszReturnBuffer);
                *lpszReturnBuffer = NULL;
            }
            return FALSE;
        }

        *lpszReturnBuffer = pNewBuf;

        nReturnSize = GetPrivateProfileSectionNames(*lpszReturnBuffer, nSize, lpFileName);

    } while(nReturnSize >= nSize-2);

    return TRUE;

} // GetSectionNames


//
//  FUNCTION: CDevicePort Constructor
//
//  PURPOSE:
//
CDevicePort::CDevicePort()
{
    m_psztName = NULL;
    m_psztPortKeyName = NULL;
    m_pNext = NULL;

} // Constructor


//
//  FUNCTION: CDevicePort Destructor
//
//  PURPOSE:
//
CDevicePort::~CDevicePort()
{
    if(m_psztName != NULL)
    {
        delete m_psztName;
    }
    if(m_psztPortKeyName != NULL)
    {
        delete m_psztPortKeyName;
    }

} // destructor


//
//  FUNCTION: Set
//
//  PURPOSE:
//
void CDevicePort::Set(TCHAR *psztNewName,
        DWORD dwNameSize,
        TCHAR *psztNewKeyName,
        DWORD dwNewKeyNameSize,
        DWORD dwPortIndex)
{
    if ( psztNewName != NULL ) {

        if ( m_psztName != NULL ) {

            delete m_psztName;
            m_psztName = NULL;
        }

        if ( dwNameSize == 0 )
            dwNameSize = _tcslen(psztNewName);

        m_psztName = new TCHAR[(dwNameSize + 1) * sizeof(TCHAR)];
        if ( m_psztName )
            lstrcpyn(m_psztName, psztNewName, dwNameSize+1);
    }

    if ( psztNewKeyName != NULL ) {

        if ( m_psztPortKeyName != NULL ) {

            delete m_psztPortKeyName;
            m_psztPortKeyName = NULL;
        }

        if ( dwNewKeyNameSize == 0 ) {

            dwNewKeyNameSize = _tcslen(psztNewKeyName);
        }

        m_psztPortKeyName = new TCHAR[(dwNewKeyNameSize + 1) * sizeof(TCHAR)];
        if ( m_psztPortKeyName ) {

            lstrcpyn(m_psztPortKeyName, psztNewKeyName, dwNewKeyNameSize+1);
        }
    }

    m_dwPortIndex = dwPortIndex;

} // Set
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\devport.h ===
/*****************************************************************************
 *
 * $Workfile: DevPort.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_DEV_PORT_INFO_H
#define INC_DEV_PORT_INFO_H

// This class' purpose is to store Name and PortNum pairs.
class CDevicePort
{
public:
    CDevicePort();
    ~CDevicePort();

    VOID Set(TCHAR *psztNewName,
             DWORD dwNameSize,
             TCHAR *psztKeyName = NULL,
             DWORD dwKeyNameSize = 0,
             DWORD dwPortIndex = 1);

    LPCTSTR GetName() {return (LPCTSTR)m_psztName;}
    const DWORD	GetPortIndex() { return (const DWORD )m_dwPortIndex; }
    LPCTSTR GetPortKeyName() {return (LPCTSTR)m_psztPortKeyName;}
    VOID ReadPortInfo(LPCTSTR pszAddress, PPORT_DATA_1 pPortInfo, BOOL bBypassNetProbe);
    VOID SetNextPtr(CDevicePort *ptr) { m_pNext = ptr; }
    CDevicePort *GetNextPtr() { return m_pNext; }

private:
    TCHAR *m_psztPortKeyName;
    TCHAR *m_psztName;
    DWORD m_dwPortIndex;
    CDevicePort *m_pNext;
    TCHAR m_psztFileName[MAX_PATH];
};

// This class manages the list of DevicePorts.
class CDevicePortList
{
public:
    CDevicePortList();
    ~CDevicePortList();

    VOID DeletePortList();

    BOOL GetDevicePortsList(LPTSTR pszDeviceName);
    CDevicePort *GetFirst() {m_pCurrent = m_pList; return(m_pCurrent);}
    CDevicePort *GetNext() {m_pCurrent = m_pCurrent->GetNextPtr(); return(m_pCurrent);}
    CDevicePort *GetCurrent() { return m_pCurrent; }

protected:
    BOOL GetSectionNames(LPCTSTR lpFileName, TCHAR **lpszReturnBuffer, DWORD &nSize);

private:
    CDevicePort *m_pList;
    CDevicePort *m_pCurrent;
};

#endif // INC_DEV_PORT_INFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\helpids.h ===
// This file was not created with DBHE.  I cut and pasted material from a "dummy" file
// so I could organize the info in a way that helps me find information.

//The file contains Help IDs for the Configure TCP/IP Port Monitor dialog, tcpmn_cs.rtf

#define IDH_NOHELP	((DWORD) -1) // Disables Help for a control (for help compiles)

// "Port Settings" Dialog Box

#define IDH_PORT_NAME	11001	// Port Settings: "&Port Name:" (Static) (Edit) (ctrl id 1001, 1026)
#define IDH_PRINTER_NAME_IP_ADDRESS	11002	// Port Settings: "Printer Name or IP &Address:" (Static) (Edit) (ctrl id 1000, 1027)
#define IDH_PROTOCOL_RAW	11003	// Port Settings: "&Raw" (Button) (ctrl id 1006)
#define IDH_PROTOCOL_LPR	11004	// Port Settings: "&LPR" (Button) (ctrl id 1007)
#define IDH_RAW_SETTINGS_PORT_NUMBER	11005	// Port Settings: "Port &Number:" (Static) (Edit) (ctrl id 1008, 1017)
#define IDH_LPR_SETTINGS_QNAME	11006	// Port Settings: "&Queue Name:" (Static) (Edit) (ctrl id 1009, 1020)
#define IDH_LPR_BYTE_COUNTING_ENABLED	11007	// Port Settings: "LPR &Byte Counting Enabled" (Button) (ctrl id 1035)
#define IDH_SNMP_STATUS_ENABLED	11008	// Port Settings: "&SNMP Status Enabled" (Button) (ctrl id 1010)
#define IDH_SNMP_COMMUNITY_NAME	11009	// Port Settings: "&Community Name:" (Static) (Edit) (ctrl id 1011, 1021)
#define IDH_SNMP_DEVICE_INDEX	11010	// Port Settings: "SNMP &Device Index:" (Static) (Edit) (ctrl id 1012, 1022)

const DWORD g_a110HelpIDs[]=
{
	1000,	IDH_PRINTER_NAME_IP_ADDRESS,	// Port Settings: "" (Edit)
	1001,	IDH_PORT_NAME,	// Port Settings: "" (Edit)
	1006,	IDH_PROTOCOL_RAW,	// Port Settings: "&Raw" (Button)
	1007,	IDH_PROTOCOL_LPR,	// Port Settings: "&LPR" (Button)
	1008,	IDH_RAW_SETTINGS_PORT_NUMBER,	// Port Settings: "" (Edit)
	1009,	IDH_LPR_SETTINGS_QNAME,	// Port Settings: "" (Edit)
	1010,	IDH_SNMP_STATUS_ENABLED,	// Port Settings: "&SNMP Status Enabled" (Button)
	1011,	IDH_SNMP_COMMUNITY_NAME,	// Port Settings: "" (Edit)
	1012,	IDH_SNMP_DEVICE_INDEX,	// Port Settings: "" (Edit)
	1017,	IDH_RAW_SETTINGS_PORT_NUMBER,	// Port Settings: "Port &Number:" (Static)
	1020,	IDH_LPR_SETTINGS_QNAME,	// Port Settings: "&Queue Name:" (Static)
	1021,	IDH_SNMP_COMMUNITY_NAME,	// Port Settings: "&Community Name:" (Static)
	1022,	IDH_SNMP_DEVICE_INDEX,	// Port Settings: "SNMP &Device Index:" (Static)
	1026,	IDH_PORT_NAME,	// Port Settings: "&Port Name:" (Static)
	1027,	IDH_PRINTER_NAME_IP_ADDRESS,	// Port Settings: "Printer Name or IP &Address:" (Static)
	1035,	IDH_LPR_BYTE_COUNTING_ENABLED,	// Port Settings: "LPR &Byte Counting Enabled" (Button)
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\hostname.h ===
/*****************************************************************************
 *
 * $Workfile: HostName.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_HOSTNAME_H
#define INC_HOSTNAME_H

#define MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH 128
#define MAX_HOSTNAME_LEN MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH

class CHostName
{
public:
	CHostName();
	CHostName(LPTSTR psztHostName);
	~CHostName();

		// if the string passed in to IsValid in AddressString param is not a valid
		// host name then the returnVal is filled with the last valid HostName from
		// the previous time this method was called.  This facilitates validation for
		// each keystroke the user makes.
	BOOL IsValid(TCHAR * psztAddressString, TCHAR * psztReturnVal = NULL, DWORD cRtnVal = 0);
	BOOL IsValid();

	void SetAddress(TCHAR *psztAddressString);
	void ToString(TCHAR *psztBuffer, int iSize);

private:
	TCHAR m_psztAddress[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH];
	TCHAR m_psztStorageString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH];

};


#endif // INC_HOSTNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inisection.h ===
/*++

Copyright (c) 97 Microsoft Corporation
All rights reserved.

Module Name:

    IniSection.h

Abstract:

    Standard TCP/IP Port Monitor class to handle INI file settings

Author:
    Muhunthan Sivapragasam (MuhuntS) 19-Nov-1997

Revision History:

--*/

// INI file Key names and values
#define RAW_PROTOCOL_TEXT TEXT("RAW")
#define LPR_PROTOCOL_TEXT TEXT("LPR")

#define YES_TEXT TEXT("YES")
#define NO_TEXT TEXT("NO")

#define PORT_SECTION TEXT("Ports")

#define PORTS_KEY TEXT("PORTS")
#define PORT_NAME_KEY TEXT("NAME")
#define PORT_NAMEI_KEY TEXT("NAME%d")
#define PROTOCOL_KEY TEXT("PROTOCOL%d")
#define PORT_NUMBER_KEY TEXT("PORTNUMBER%d")
#define COMMUNITY_KEY TEXT("COMMUNITYNAME%d")
#define DEVICE_KEY TEXT("DEVICE%d")
#define QUEUE_KEY TEXT("QUEUE%d")
#define DOUBLESPOOL_KEY TEXT("LPRDSPOOL%d")
#define PORT_STATUS_ENABLED_KEY TEXT("SNMP%d")


class IniSection {

public:
    IniSection();

    ~IniSection();

    BOOL    GetString(LPTSTR pszKey, TCHAR szBuf[], DWORD  cchBuf);
    BOOL    GetDWord(LPTSTR pszKey, LPDWORD    pdwValue);

    BOOL    GetPortInfo(LPCTSTR pAddress, PPORT_DATA_1 pPortInfo, DWORD dwPortIndex, BOOL bBypassMibProbe);

    BOOL    GetIniSection(LPTSTR    pszPortDesc);

    BOOL    SetIniSection(LPTSTR    pszPortSection);

    LPTSTR  GetSectionName() { return( (LPTSTR)m_szSectionName ); }

private:
    TCHAR   m_szSectionName[MAX_SECTION_NAME];
    TCHAR   m_szIniFileName[MAX_PATH];

    BOOL    SupportsPrinterMIB( LPCTSTR     pAddress, PBOOL bSupported);

    BOOL    FindINISectionFromPortDescription(LPCTSTR   pszAnsiPortDesc);
    BOOL    Valid() { return m_szSectionName[0] != 0 && m_szIniFileName[0] != 0; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\hostname.cpp ===
/*****************************************************************************
 *
 * $Workfile: HostName.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "HostName.h"


//
//  FUNCTION: CHostName constructor
//
//  PURPOSE:
//
CHostName::CHostName()
{
}


//
//  FUNCTION: CHostName constructor
//
//  PURPOSE:
//
CHostName::CHostName(LPTSTR psztHostName)
{
    SetAddress(psztHostName);
}


//
//  FUNCTION: CHostName destructor
//
//  PURPOSE:
//
CHostName::~CHostName()
{
}


//
//  FUNCTION: IsValid
//
//  PURPOSE: Used for validation while the user is typing.
//          It is less strict then IsValid()  (The no argument version)
//
BOOL CHostName::IsValid(TCHAR *psztStringOriginal,
                        TCHAR *psztReturnVal,
                        DWORD   cRtnVal)
{
    TCHAR *pctPtr = NULL;
    TCHAR psztString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH] = NULLSTR;
    BOOL bIsValid = FALSE;

    lstrcpyn(psztString, psztStringOriginal, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

    // Check the total length of the string.
    bIsValid = (_tcslen(psztString) <= MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

    if(bIsValid)
    {
        // Find the first dot and check the length of the part before the first dot.
        TCHAR psztSubString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH] = NULLSTR;
        lstrcpyn(psztSubString, psztString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);
        TCHAR *pDotIndex = NULL;

        pDotIndex = _tcschr(psztSubString, '.');
        if(pDotIndex != NULL) {
            *pDotIndex = TCHAR('\0');
        }
        bIsValid = (_tcslen(psztSubString) <= MAX_HOSTNAME_LEN);
    }

    // Check for invalid characters.
    for (pctPtr = psztString; bIsValid && *pctPtr; pctPtr++)
    {
        switch (*pctPtr)
        {
            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
                bIsValid = FALSE;
                break;

            default:
                if ( ( *pctPtr < ((TCHAR)'!') ) || ( *pctPtr > (TCHAR)'~' ) ) {
                    bIsValid = FALSE;
                }
                break;
        }
    }
    if (!bIsValid) {
        if(psztReturnVal != NULL) {
            _tcscpy(psztReturnVal, m_psztStorageString );
        }
    } else {
        lstrcpyn(m_psztStorageString, psztString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);
        // _ASSERTE( _tcsicmp(psztString, psztStringOriginal) == 0 );
    }
    return(bIsValid);
}

//
//  FUNCTION: IsValid
//
//  PURPOSE: Strict validation of a host name.
//
BOOL CHostName::IsValid()
{
    if(!IsValid(m_psztAddress)) {
        return(FALSE);
    }

    // We know that it is mostly valid now do the final more exact test.

    // check to be sure the first character is an alphanumeric character:
    if(! ((m_psztAddress[0] >= TCHAR('0') && m_psztAddress[0] <= TCHAR('9')) ||
           (m_psztAddress[0] >= TCHAR('A') && m_psztAddress[0] <= TCHAR('Z')) ||
           (m_psztAddress[0] >= TCHAR('a') && m_psztAddress[0] <= TCHAR('z'))) )   {
        return(FALSE);
    }

    // check to be sure the name is longer then 1 character.
    int length = _tcslen(m_psztAddress);
    if(length <= 1) {
        return(FALSE);
    }

    // check to be sure the last character is not a minus sign or period.
    if( m_psztAddress[length - 1] == TCHAR('-') ||
        m_psztAddress[length - 1] == TCHAR('.')) {
        return(FALSE);
    }

    return(TRUE);

} // IsValid


//
//  FUNCTION: SetAddress
//
//  PURPOSE: Sets the host name.
//
void CHostName::SetAddress(TCHAR *AddressString)
{
    IsValid(AddressString);
    lstrcpyn(m_psztAddress, AddressString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

} // SetAddress


//
//  FUNCTION: ToString
//
//  PURPOSE: Returns the address in the given buffer.
//
void CHostName::ToString(TCHAR *Buffer, int size)
{
    lstrcpyn(Buffer, m_psztAddress, size);

} // ToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inptchkr.h ===
/*****************************************************************************
 *
 * $Workfile: InptChkr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *
 *****************************************************************************/

#ifndef INC_INPUTCHECKER_H
#define INC_INPUTCHECKER_H

typedef enum _tagAddressType
{
	Undefined,
	IPAddress,
	HostName
} AddressType;

class CInputChecker
{
public:
	CInputChecker();
	~CInputChecker();

public:
	void LinkPortNameAndAddressInput() { m_bLinked = TRUE; }
	void UnlinkPortNameAndAddressInput() { m_bLinked = FALSE; }

	BOOL AddressIsLegal(TCHAR *ptcsAddress);
	BOOL PortNameIsLegal(TCHAR *ptcsPortName);
	BOOL PortNameIsUnique(TCHAR *ptcsPortName, LPTSTR psztServerName);
	BOOL PortNumberIsLegal(TCHAR *ptcsPortNumber);
	BOOL QueueNameIsLegal(TCHAR *ptcsQueueName);
	BOOL CommunityNameIsLegal(TCHAR *ptcsCommunityName);
	BOOL SNMPDevIndexIsLegal(TCHAR *psztSNMPDevIndex);

	void OnUpdatePortName(int idEditCtrl, HWND hwndEditCtrl);
	void OnUpdateAddress(HWND hDlg, int idEditCtrl, HWND hwndEditCtrl, LPTSTR psztServerName);
	void OnUpdatePortNumber(int idEditCtrl, HWND hwndEditCtrl);
	void OnUpdateDeviceIndex(int idEditCtrl, HWND hwndEditCtrl);
	void OnUpdateQueueName(int idEditCtrl, HWND hwndEditCtrl);
	void MakePortName(TCHAR *strAddr);

protected:
	BOOL IsValidAddressInput(TCHAR *ptcsAddressInput,
		                     TCHAR *ptcsReturnLastValid,
							 DWORD CRtnValSize);
	BOOL IsValidPortNameInput(TCHAR *ptcsPortNameInput,
							  TCHAR *ptcsReturnLastValid,
							  DWORD CRtnValSize);
	BOOL IsValidPortNumberInput(TCHAR *ptcsPortNumInput,
		                        TCHAR *ptcsReturnLastValid = NULL ,
								DWORD cRtnVal = 0);
	BOOL IsValidDeviceIndexInput(TCHAR *ptcsDeviceIndexInput,
		                         TCHAR *ptcsReturnLastValid = NULL,
								 DWORD CRtnValSize = 0);
	BOOL IsValidQueueNameInput(TCHAR *ptcsQueueNameInput,
		                       TCHAR *ptcsReturnLastValid = NULL,
							   DWORD CRtnValSize = 0);
	BOOL IsValidCommunityNameInput(TCHAR *ptcsCommunityNameInput,
		                           TCHAR *ptcsReturnLastValid = NULL,
								   DWORD CRtnValSize = 0);

	BOOL PortExists(LPTSTR psztPortName, LPTSTR psztServerName);

	AddressType GetAddressType(TCHAR *ptcsAddress);

private:
	BOOL m_bLinked; // Is the port name linked to the Address input?
	TCHAR m_InputStorageStringAddress[MAX_ADDRESS_LENGTH];
	TCHAR m_InputStorageStringPortNumber[MAX_PORTNUM_STRING_LENGTH];
	TCHAR m_InputStorageStringDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH];
	TCHAR m_InputStorageStringQueueName[MAX_QUEUENAME_LEN];

}; // CGetAddrDlg

#endif // INC_INPUTCHECKER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inisection.cpp ===
/*++

Copyright (c) 97 Microsoft Corporation
All rights reserved.

Module Name:

    IniSection.cpp

Abstract:

    Standard TCP/IP Port Monitor class to handle INI file settings

Author:
    Muhunthan Sivapragasam (MuhuntS) 19-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "tcpmonui.h"
#include "rtcpdata.h"
#include "lprdata.h"
#include "IniSection.h"

BOOL
StringMatch(
    LPCTSTR     psz1,
    LPCTSTR     psz2    // * is a wild char in this
    )
{
    LPCTSTR  p1 = NULL, p2 = NULL;

    for ( p1 = psz1, p2 = psz2 ; *p1 && *p2 ; ) {

        //
        // A * matches any sub-string
        //
        if ( *p2 == TEXT('*') ) {

            ++p2;
            if ( !*p2 ) {
                return TRUE;
            }

            for ( ; *p1 ; ++p1 )
                if ( StringMatch(p1, p2) ) {
                    return TRUE;
                }

            break;
        } else if ( *p1 == *p2 ) {

            ++p1;
            ++p2;
        } else
            break;
    }

    if( !*p1 && *p2 == TEXT( '*' ))
    {
        ++p2;
        if (!*p2 ) {
            return TRUE;
        }
    }

    return !*p1 && !*p2;
}


BOOL
IniSection::
FindINISectionFromPortDescription(
    LPCTSTR   pszPortDesc
    )
/*++

--*/
{
    LPTSTR      pszBuf = NULL, pszKey = NULL;
    DWORD       rc = 0,  dwLen = 0, dwBufLen = 1024;
    BOOL        bRet = FALSE;

    pszBuf  = (LPTSTR) malloc(dwBufLen*sizeof(TCHAR));

    //
    // Read all the key names in the ini file
    //
    while ( pszBuf ) {

        rc = GetPrivateProfileString(PORT_SECTION,
                                     NULL,
                                     NULL,
                                     pszBuf,
                                     dwBufLen,
                                     m_szIniFileName);

        if ( rc == 0 ) {
            goto Done;
        }

        if ( rc < dwBufLen - 2 ) {
            break; // Succesful exit; Read all port descriptions
        }

        free(pszBuf);
        dwBufLen *= 2;

        pszBuf = (LPTSTR) malloc(dwBufLen*sizeof(TCHAR));
    }

    if ( !pszBuf )
        goto Done;

    //
    // Go through the list of key names in the .INI till we find a match
    //
    for ( pszKey = pszBuf ; *pszKey ; pszKey += dwLen + 1 ) {

        //
        // Keys start and end with " we need to do match w/o them
        //
        dwLen = _tcslen(pszKey);
        pszKey[dwLen-1] = TCHAR('\0');

        if ( StringMatch(pszPortDesc, pszKey+1) ) {

            pszKey[dwLen-1] = TCHAR('\"');
            GetPrivateProfileString(PORT_SECTION,
                                    pszKey,
                                    NULL,
                                    m_szSectionName,
                                    MAX_SECTION_NAME,
                                    m_szIniFileName);
            bRet = TRUE;
            goto Done;
        }
    }

Done:
    if ( pszBuf ) {
        free(pszBuf);
    }

    return( bRet );
}


IniSection::
IniSection(
    void
    )
{
    DWORD   dwLen = 0, dwSize = 0;

    m_szSectionName[0] = TEXT('\0');
    m_szIniFileName[0] = TEXT('\0');

    dwSize = sizeof(m_szIniFileName)/sizeof(m_szIniFileName[0]);
    dwLen = GetSystemDirectory(m_szIniFileName, dwSize);

    if ( dwLen + _tcslen(PORTMONITOR_INI_FILE) > dwSize ) {
        return;
    }

    _tcscat(m_szIniFileName, PORTMONITOR_INI_FILE);

}


IniSection::
~IniSection(
    )
{
    // Nothing to do
}

BOOL
IniSection::
GetString(
    IN  LPTSTR  pszKey,
    OUT TCHAR   szBuf[],
    IN  DWORD   cchBuf
    )
{
    DWORD   rc = 0;

    rc = GetPrivateProfileString(m_szSectionName,
                                 pszKey,
                                 NULL,
                                 szBuf,
                                 cchBuf,
                                 m_szIniFileName);

    return rc > 0 && rc < cchBuf - 1;
}


BOOL
IniSection::
GetDWord(
    IN  LPTSTR  pszKey,
    OUT LPDWORD pdwValue
    )
{
    UINT    uVal;

    uVal = GetPrivateProfileInt(m_szSectionName,
                                pszKey,
                                -1,
                                m_szIniFileName);

    if ( uVal != -1 ) {

        *pdwValue = (DWORD) uVal;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IniSection::
SetIniSection(
    LPTSTR   pszPortSection
    )
{
    lstrcpyn( m_szSectionName, pszPortSection, MAX_SECTION_NAME );

    return( TRUE );
}

BOOL
IniSection::
GetIniSection(
    LPTSTR   pszPortDescription
    )
{
    BOOL bRet = FALSE;

    if ( m_szIniFileName[0] != 0 ) {
        bRet = FindINISectionFromPortDescription(pszPortDescription);
    }

    return( bRet );
}

//
//  FUNCTION: GetPortInfo
//
//  PURPOSE: To read information about a device from the ini file.
//

BOOL
IniSection::
GetPortInfo(LPCTSTR pAddress,
            PPORT_DATA_1 pPortInfo,
            DWORD   dwPortIndex,
            BOOL    bBypassMibProbe)
{
    BOOL bRet = TRUE;
    TCHAR KeyName[26];

    if( !Valid() ) {
        bRet = FALSE;
        goto Done;
    }

    //
    // Protocol
    //
    _stprintf(KeyName, PROTOCOL_KEY, dwPortIndex);
    TCHAR tcsProtocol[50];
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            TEXT(""),
                            tcsProtocol,
                            50,
                            m_szIniFileName);

    if( !_tcsicmp( RAW_PROTOCOL_TEXT, tcsProtocol)) {
        pPortInfo->dwProtocol = PROTOCOL_RAWTCP_TYPE;

        //
        // Port Number
        //
        _stprintf(KeyName, PORT_NUMBER_KEY, dwPortIndex);
        pPortInfo->dwPortNumber = GetPrivateProfileInt(m_szSectionName,
                                                       KeyName,
                                                       DEFAULT_PORT_NUMBER,
                                                       m_szIniFileName);


    } else if( !_tcsicmp( LPR_PROTOCOL_TEXT, tcsProtocol)) {
        pPortInfo->dwProtocol = PROTOCOL_LPR_TYPE;
        pPortInfo->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;

        //
        // LPR QUEUE
        //
        _stprintf(KeyName, QUEUE_KEY, dwPortIndex);
        GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            DEFAULT_QUEUE,
                            pPortInfo->sztQueue,
                            MAX_QUEUENAME_LEN,
                            m_szIniFileName);

        //
        // LPR Double Spool - default 0
        //
        _stprintf(KeyName, DOUBLESPOOL_KEY, dwPortIndex);
        pPortInfo->dwDoubleSpool = GetPrivateProfileInt(m_szSectionName,
                                                    KeyName,
                                                    0,
                                                    m_szIniFileName);



    }

    //
    // CommunityName
    //
    _stprintf(KeyName, COMMUNITY_KEY, dwPortIndex);
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            DEFAULT_SNMP_COMUNITY,
                            pPortInfo->sztSNMPCommunity,
                            MAX_SNMP_COMMUNITY_STR_LEN,
                            m_szIniFileName);

    //
    // DeviceIndex - default 1
    //
    _stprintf(KeyName, DEVICE_KEY, dwPortIndex);
    pPortInfo->dwSNMPDevIndex = GetPrivateProfileInt(m_szSectionName,
                                                    KeyName,
                                                    1,
                                                    m_szIniFileName);

    //
    // SNMP Status Enabled - default ON
    //
    TCHAR szTemp[50];
    _stprintf(KeyName, PORT_STATUS_ENABLED_KEY, dwPortIndex);
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            YES_TEXT,
                            szTemp,
                            SIZEOF_IN_CHAR(szTemp),
                            m_szIniFileName);

    if ( !(_tcsicmp( szTemp, YES_TEXT ))){
        pPortInfo->dwSNMPEnabled = TRUE;
    } else if (!(_tcsicmp( szTemp, NO_TEXT ))) {
        pPortInfo->dwSNMPEnabled = FALSE;
    } else {

        if (bBypassMibProbe)
            pPortInfo->dwSNMPEnabled = FALSE;
        else {

            BOOL bSupported;

            if (SupportsPrinterMIB( pAddress, &bSupported)) {
                pPortInfo->dwSNMPEnabled = bSupported;
            }
            else {

                // Error case, we have to disable SNMP

                pPortInfo->dwSNMPEnabled = FALSE;

                // The caller can check the returned error code to determine
                // whether the last error is "Device Not Found". If so,
                // the client should by pass Mib Probe in the next call
                //

                bRet = FALSE;
            }

        }

    }


Done:
    return( bRet );

} // GetPortInfo


//
BOOL
IniSection::
SupportsPrinterMIB(
    LPCTSTR     pAddress,
    PBOOL       pbSupported
    )
{
    BOOL            bRet = FALSE;
    CTcpMibABC     *pTcpMib = NULL;
    FARPROC         pfnGetTcpMibPtr = NULL;

    if ( !g_hTcpMibLib ) {
        goto Done;
    }

    pfnGetTcpMibPtr = ::GetProcAddress(g_hTcpMibLib, "GetTcpMibPtr");

    if ( !pfnGetTcpMibPtr ) {
        goto Done;
    }

    if ( pTcpMib = (CTcpMibABC *) pfnGetTcpMibPtr() ) {

        char HostName[MAX_NETWORKNAME_LEN] = "";

        UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
        bRet = pTcpMib->SupportsPrinterMib(HostName,
                                           DEFAULT_SNMP_COMMUNITYA,
                                           DEFAULT_SNMP_DEVICE_INDEX,
                                           pbSupported);
    }

Done:
    return bRet;
} // GetDeviceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inptchkr.cpp ===
/*****************************************************************************
 *
 * $Workfile: InptChkr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "Resource.h"
#include "IPAddr.h"
#include "HostName.h"

//
//  FUNCTION: CInputChecker constructor
//
//  PURPOSE:  initialize a CInputChecker class
//
CInputChecker::CInputChecker()
{
    m_bLinked = FALSE;
    m_InputStorageStringAddress[0] = '\0';
    m_InputStorageStringPortNumber[0] = '\0';
    m_InputStorageStringDeviceIndex[0] = '\0';
    m_InputStorageStringQueueName[0] = '\0';

} // constructor


//
//  FUNCTION: CInputChecker destructor
//
//  PURPOSE:  deinitialize a CInputChecker class
//
CInputChecker::~CInputChecker()
{
} // destructor


//
//  FUNCTION: OnUpdatePortName(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Port Name input.
//
void CInputChecker::OnUpdatePortName(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Name had text changed in it.
    BOOL bModified = static_cast<BOOL> (SendMessage(hwndEditCtrl, EM_GETMODIFY, 0,0));
    if(bModified)
    {
        TCHAR tcsAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
        TCHAR tcsLastValidAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
        GetWindowText(hwndEditCtrl, tcsAddr, MAX_ADDRESS_LENGTH);

        if(! IsValidPortNameInput(tcsAddr,
                                  tcsLastValidAddr,
                                  SIZEOF_IN_CHAR(tcsLastValidAddr)))
        {
            // the port name that was entered is not valid so beep and set the text
            // back to the last valid entry.  This test for validity does not
            // include testing for the right length just proper character set.
            MessageBeep((UINT)-1);
            DWORD dwSel = Edit_GetSel(hwndEditCtrl);
            SetWindowText(hwndEditCtrl, tcsLastValidAddr);
            Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
        }

        m_bLinked = FALSE;
    }

} // OnUpdatePortName


//
//  FUNCTION: OnUpdatePortNumber(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Port Number input.
//
void CInputChecker::OnUpdatePortNumber(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Number had text changed in it.
    TCHAR tcsPortNum[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    TCHAR tcsLastValidPortNum[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsPortNum, MAX_PORTNUM_STRING_LENGTH);

    if(! IsValidPortNumberInput(tcsPortNum,
                                tcsLastValidPortNum,
                                SIZEOF_IN_CHAR(tcsLastValidPortNum)))
    {
        // the port number that was entered is not valid so beep and set the text
        // back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidPortNum);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdatePortNumber


//
//  FUNCTION: OnUpdateDeviceIndex(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Device Index input.
//
void CInputChecker::OnUpdateDeviceIndex(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Number had text changed in it.
    TCHAR tcsDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    TCHAR tcsLastValidDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsDeviceIndex, MAX_SNMP_DEVICENUM_STRING_LENGTH);

    if(! IsValidDeviceIndexInput(tcsDeviceIndex,
                                 tcsLastValidDeviceIndex,
                                 SIZEOF_IN_CHAR(tcsLastValidDeviceIndex)))
    {
        // the device index that was entered is not valid so beep and set the
        // text back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidDeviceIndex);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdateDeviceIndex



//
//  FUNCTION: OnUpdateAddress(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Address input.
//
void CInputChecker::OnUpdateAddress(HWND hDlg, int idEditCtrl, HWND hwndEditCtrl, LPTSTR psztServerName)
{
    // the edit control for IP Address or Device Name had text changed in it.
    TCHAR tcsAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
    TCHAR tcsLastValidAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsAddr, MAX_ADDRESS_LENGTH);

    BOOL bValid = IsValidAddressInput(tcsAddr,
                                      tcsLastValidAddr,
                                      SIZEOF_IN_CHAR(tcsLastValidAddr));
    if(! bValid)
    {
        // the address that was entered is not valid so beep and set the text
        // back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidAddr);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }
    else // The address is valid.
    {
        if(m_bLinked)
        {
            MakePortName(tcsAddr);
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), tcsAddr);
        }
    }

} // OnUpdateAddress


//
//  FUNCTION: OnUpdateQueueName(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the QueueName input.
//
void CInputChecker::OnUpdateQueueName(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for QueueName had text changed in it.
    TCHAR tcsQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    TCHAR tcsLastValidQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsQueueName, MAX_QUEUENAME_LEN);

    if(! IsValidQueueNameInput(tcsQueueName,
                               tcsLastValidQueueName,
                               SIZEOF_IN_CHAR(tcsLastValidQueueName)))
    {
        // the device index that was entered is not valid so beep and set the
        // text back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidQueueName);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdateQueueName


//
//  FUNCTION: IsValidPortNameInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidPortNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  Any input is valid until I hear otherwise.
//
BOOL CInputChecker::IsValidPortNameInput(TCHAR *ptcsAddressInput,
                                         TCHAR *ptcsReturnLastValid,
                                         DWORD CRtnValSize)
{
    DWORD   dwLen = 0;
    BOOL    bValid = TRUE;

    //
    // Valid port name is non-blank and does not include ,
    //
    if ( ptcsAddressInput ) {

        while ( ptcsAddressInput[dwLen] != TEXT('\0')   &&
                ptcsAddressInput[dwLen] != TEXT(',') )
            ++dwLen;
    }

    if ( CRtnValSize ) {

        if ( dwLen + 1 > CRtnValSize )
            dwLen = CRtnValSize - 1;

        lstrcpyn(ptcsReturnLastValid, ptcsAddressInput, dwLen+1);
    }

    return dwLen && ptcsAddressInput[dwLen] != TEXT(',');

} // IsValidPortNameInput


//
//  FUNCTION: IsValidCommunityNameInput(TCHAR ptcsCommunityNameInput[MAX_SNMP_COMMUNITY_STR_LEN], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidCommunityNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsCommunityNameInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  Any input is valid until I hear otherwise.
//
BOOL CInputChecker::IsValidCommunityNameInput(TCHAR *ptcsCommunityNameInput,
                                              TCHAR *ptcsReturnLastValid,
                                              DWORD CRtnValSize)
{
    return TRUE;

} // IsValidCommunityNameInput


//
//  FUNCTION: IsValidPortNumberInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidPortNumberInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  The input is valid if it contains only digit characters.
//
BOOL CInputChecker::IsValidPortNumberInput(TCHAR *ptcsPortNumInput,
                                           TCHAR *ptcsReturnLastValid,
                                           DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;

    lstrcpyn(ptcsString, ptcsPortNumInput, MAX_PORTNUM_STRING_LENGTH );
    bIsValid = (_tcslen(ptcsString) <= MAX_PORTNUM_STRING_LENGTH);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)'0':
            case (TCHAR)'1':
            case (TCHAR)'2':
            case (TCHAR)'3':
            case (TCHAR)'4':
            case (TCHAR)'5':
            case (TCHAR)'6':
            case (TCHAR)'7':
            case (TCHAR)'8':
            case (TCHAR)'9':
                bIsValid = TRUE;
                break;

            default:
                bIsValid = FALSE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringPortNumber,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringPortNumber,
                 ptcsString,
                 MAX_ADDRESS_LENGTH);
    }
    return(bIsValid);

} // IsValidPortNumberInput


//
//  FUNCTION: IsValidDeviceIndexInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidDeviceIndexInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  The input is valid if it contains only digit characters.
//
BOOL CInputChecker::IsValidDeviceIndexInput(TCHAR *ptcsDeviceIndexInput,
                                            TCHAR *ptcsReturnLastValid,
                                            DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;

    lstrcpyn(ptcsString,
             ptcsDeviceIndexInput,
             MAX_SNMP_DEVICENUM_STRING_LENGTH);
    bIsValid = (_tcslen(ptcsString) <= MAX_SNMP_DEVICENUM_STRING_LENGTH);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)'0':
            case (TCHAR)'1':
            case (TCHAR)'2':
            case (TCHAR)'3':
            case (TCHAR)'4':
            case (TCHAR)'5':
            case (TCHAR)'6':
            case (TCHAR)'7':
            case (TCHAR)'8':
            case (TCHAR)'9':
                bIsValid = TRUE;
                break;

            default:
                bIsValid = FALSE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringDeviceIndex,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringDeviceIndex,
                 ptcsString,
                 MAX_SNMP_DEVICENUM_STRING_LENGTH);
    }
    return(bIsValid);

} // IsValidDeviceIndexInput


//
//  FUNCTION: IsValidAddressInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidAddressInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//              from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise.
//
//  Comments:  The input is valid if it contains characters that are either valid for
//              an IP Address or a Host Name or both.
//
BOOL CInputChecker::IsValidAddressInput(TCHAR *ptcsAddressInput,
                                        TCHAR *ptcsReturnLastValid,
                                        DWORD CRtnValSize)
{
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_ADDRESS_LENGTH] = NULLSTR;
    BOOL bIsValid = FALSE;

    lstrcpyn(ptcsString, ptcsAddressInput, MAX_ADDRESS_LENGTH);

    bIsValid = (_tcslen(ptcsString) <= MAX_ADDRESS_LENGTH);
    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
            // other invalid character cases here
                    bIsValid = FALSE;
                    break;

            default:
                    break;
        }
    }
    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringAddress,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringAddress,
                 ptcsString,
                 MAX_ADDRESS_LENGTH);
    }
    return(bIsValid);

} // IsValidAddressInput



//
//  FUNCTION: IsValidQueueNameInput(TCHAR ptcsAddressInput[MAX_QUEUENAME_LEN], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidQueueNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsQueueNameInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//              from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise.
//
//  Comments:  The name is limited to 14 characters and must consist entirely of the
//              characters A-Z, a-z, 0-9, and _ (underscore).
//
BOOL CInputChecker::IsValidQueueNameInput(TCHAR *ptcsQueueNameInput,
                                          TCHAR *ptcsReturnLastValid,
                                          DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_QUEUENAME_LEN] = NULLSTR;

    lstrcpyn(ptcsString, ptcsQueueNameInput, MAX_QUEUENAME_LEN );
    bIsValid = (_tcslen(ptcsString) <= MAX_QUEUENAME_LEN);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {

            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
                bIsValid = FALSE;
                break;

            default:
                bIsValid = TRUE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringQueueName,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringQueueName,
                 ptcsString,
                 MAX_QUEUENAME_LEN);
    }
    return(bIsValid);

} // IsValidQueueNameInput


//
//  FUNCTION: MakePortName(TCHAR *strAddr)
//
//  PURPOSE:  To return a string that will be a unique port
//              name when the port is added.
//
void CInputChecker::MakePortName(TCHAR *strAddr)
{
    _ASSERTE(m_bLinked == TRUE);

    if(GetAddressType(strAddr) == IPAddress)
    {
        // The address is an IP address
        TCHAR NameString[10] = NULLSTR;
        TCHAR szTemp[MAX_ADDRESS_LENGTH+1] = NULLSTR;

        LoadString(g_hInstance, IDS_STRING_NAME_IP, NameString, 10);
        _stprintf(szTemp,
                  TEXT( "%s%.*s" ),
                  NameString,
                  MAX_ADDRESS_LENGTH - _tcslen(NameString),
                  strAddr);
        lstrcpyn( strAddr, szTemp, MAX_ADDRESS_LENGTH);
    }


} // MakePortName


//
//  FUNCTION: PortNumberIsLegal(TCHAR *ptcsPortNumber)
//
//  PURPOSE:  To determine if the PortNum passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::PortNumberIsLegal(TCHAR *ptcsPortNumber)
{
    if(IsValidPortNumberInput(ptcsPortNumber, NULL, 0) &&
        _tcslen(ptcsPortNumber) >= 1 &&
        _tcslen(ptcsPortNumber) <= MAX_PORTNUM_STRING_LENGTH)
    {
        return TRUE;
    }
    return FALSE;

} // PortNumberIsLegal


//
//  FUNCTION: CommunityNameIsLegal(TCHAR *ptcsCommunityName)
//
//  PURPOSE:  To determine if the Community Name passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::CommunityNameIsLegal(TCHAR *ptcsCommunityName)
{
    if(IsValidCommunityNameInput(ptcsCommunityName) &&
        _tcslen(ptcsCommunityName) >= 1 &&
        _tcslen(ptcsCommunityName) <= MAX_SNMP_COMMUNITY_STR_LEN)
    {
        return TRUE;
    }
    return FALSE;

} // CommunityNameIsLegal


//
//  FUNCTION: QueueNameIsLegal(TCHAR *ptcsQueueName)
//
//  PURPOSE:  To determine if the PortNum passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::QueueNameIsLegal(TCHAR *ptcsQueueName)
{
    if(IsValidQueueNameInput(ptcsQueueName) &&
        _tcslen(ptcsQueueName) >= 1 &&
        _tcslen(ptcsQueueName) <= MAX_QUEUENAME_LEN)
    {
        return TRUE;
    }
    return FALSE;

} // QueueNameIsLegal

//
//  FUNCTION: GetAddressType(TCHAR *ptcsAddress)
//
//  PURPOSE:  To determine if the address passed in in the parameter ptcsAddress
//              is an ip address or a host name.
//
AddressType CInputChecker::GetAddressType(TCHAR *ptcsAddress)
{
    // determine if we are dealing with a name or an ip address
    // if it's an IP Address it will start with a number, otherwise
    // it will start with a letter or other character.

    if( ptcsAddress[0] == '0' ||
        ptcsAddress[0] == '1' ||
        ptcsAddress[0] == '2' ||
        ptcsAddress[0] == '3' ||
        ptcsAddress[0] == '4' ||
        ptcsAddress[0] == '5' ||
        ptcsAddress[0] == '6' ||
        ptcsAddress[0] == '7' ||
        ptcsAddress[0] == '8' ||
        ptcsAddress[0] == '9')
    {
        CIPAddress IPAddr;
        if (IPAddr.IsValid(ptcsAddress))
            return(IPAddress);
        else
            return (HostName);
    }
    else
    {
        return(HostName);
    }

} // GetAddressType

//
//  FUNCTION: AddressIsLegal(TCHAR *ptcsAddress)
//
//  PURPOSE:  To determine if the address passed in in the parameter ptcsAddress
//              is legal -- That is not too short and either a legal ip address or
//              a legal host name.
//
BOOL CInputChecker::AddressIsLegal(TCHAR *ptcsAddress)
{
    BOOL bLegalAddress = TRUE;

    // determine if the input is at least 2 characters long.
    if((_tcslen(ptcsAddress) > 1))
    {
        if( GetAddressType(ptcsAddress) == IPAddress )
        {
            CIPAddress IPAddr;
            bLegalAddress = IPAddr.IsValid(ptcsAddress);
        }
        else
        {
            CHostName HostName(ptcsAddress);
            bLegalAddress = HostName.IsValid();
        }
    }
    else
    {
        bLegalAddress = FALSE;
    }

    return bLegalAddress;

} // AddressIsLegal


//
//  FUNCTION: PortNameIsLegal(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the PortName passed in in the parameter ptcsPortName
//              is legal
//
//  Return Value:  True if the port name is legal. False if it is not.
//
//  Parameters:  ptcsPortName - the name of the port to check for legality.
//
BOOL CInputChecker::PortNameIsLegal(TCHAR *ptcsPortName)
{
    DWORD   dwLen;

    dwLen = ptcsPortName && *ptcsPortName ? _tcslen(ptcsPortName) : 0;

    //
    // Remove trailing spaces
    //
    while ( dwLen && ptcsPortName[dwLen-1] == ' ' )
        --dwLen;

    if ( dwLen == 0 )
        return FALSE;

    ptcsPortName[dwLen] = TEXT('\0');

    for ( ; *ptcsPortName ; ++ptcsPortName )
        if ( *ptcsPortName == TEXT(',') ||
             *ptcsPortName == TEXT('\\') ||
             *ptcsPortName == TEXT('/') )
            return FALSE;

    return TRUE;
} // PortNameIsLegal


//
//  FUNCTION: SNMPDevIndexIsLegal(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the SNMPDevIndex passed in in the parameter psztSNMPDevIndex
//              is legal
//
//  Return Value:  True if the index is legal. False if it is not.
//
//  Parameters:  psztSNMPDevIndex - the device index to check for legality.
//
BOOL CInputChecker::SNMPDevIndexIsLegal(TCHAR *psztSNMPDevIndex)
{
    if((! IsValidDeviceIndexInput(psztSNMPDevIndex)) ||
        (_tcslen(psztSNMPDevIndex) < 1))
    {
        return FALSE;
    }

    return TRUE;

} // SNMPDevIndexIsLegal


//
//  FUNCTION: PortNameIsUnique(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the PortName passed in in the parameter ptcsPortName
//              is Unique.
//
//  Return Value:  True if the port does not exist. False if it does.
//
//  Parameters:  psztPortName - the name of the port to check for prior existance.
//
//  Note:  The spooler must be running on the system in order for this function
//          to work properly.
//
BOOL CInputChecker::PortNameIsUnique(TCHAR *ptcsPortName, LPTSTR psztServerName)
{
    return(! PortExists(ptcsPortName, psztServerName));

} // PortNameIsUnique


//
//  FUNCTION: PortExists()
//
//  PURPOSE:  Enumerate ports and search for the given port name
//
//  Return Value:  True if the port exists. False if it does not.
//
//  Parameters:  psztPortName - the name of the port to check for existance.
//              psztServerName - The Name of the server to check on.
//
//  Note:  The spooler must be running on the system in order for this function
//          to work properly.
//
BOOL CInputChecker::PortExists(LPTSTR psztPortName, LPTSTR psztServerName)
{
    BOOL Exists = FALSE;

    PORT_INFO_1 *pi1 = NULL;
    DWORD pcbNeeded = 0;
    DWORD pcReturned = 0;
    BOOL res = EnumPorts((psztServerName[0] == '\0') ? NULL : psztServerName,
        1, // specifies type of port info structure
        (LPBYTE)pi1, // pointer to buffer to receive array of port info. structures
        0, // specifies size, in bytes, of buffer
        &pcbNeeded, // pointer to number of bytes stored into buffer (or required buffer size)
        &pcReturned // pointer to number of PORT_INFO_*. structures stored into buffer
        );

    DWORD err = GetLastError();
    if(res == 0 && ERROR_INSUFFICIENT_BUFFER == err)
    {
        pi1 = (PORT_INFO_1 *) malloc(pcbNeeded);
        if(pi1 == NULL)
        {
            pcbNeeded = 0;
        }

        res = EnumPorts((psztServerName[0] == '\0') ? NULL : psztServerName,
            1,
            (LPBYTE)pi1,
            pcbNeeded,
            &pcbNeeded,
            &pcReturned);

        for(DWORD i=0;i<pcReturned; i++)
        {
            if(0 == _tcsicmp(pi1[i].pName, psztPortName))
            {
                Exists = TRUE;
                break;
            }
        }
    }
    if(pi1 != NULL)
    {
        free(pi1);
        pi1 = NULL;
    }

    return(Exists);

} // PortExists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\ipaddr.cpp ===
/*****************************************************************************
 *
 * $Workfile: IPAddr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header


///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::CIPAddress()
//      Initializes the IP address

CIPAddress::CIPAddress() 
{
    m_psztStorageStringComponent[0] = '\0';
    m_psztStorageString[0] = '\0';

}   // ::CIPAddress()


///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::CIPAddress(someString)
//      Initializes the IP address given a string

CIPAddress::CIPAddress(LPTSTR in psztIPAddr) 
{
    int num0 = 0;
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    _stscanf(psztIPAddr, _TEXT("%d.%d.%d.%d"), &num0, &num1, &num2, &num3);
    m_bAddress[0] = (BYTE)num0;
    m_bAddress[1] = (BYTE)num1;
    m_bAddress[2] = (BYTE)num2;
    m_bAddress[3] = (BYTE)num3;

}   // ::CIPAddress()



///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::~CIPAddress()
//      

CIPAddress::~CIPAddress()
{
}   // ::~CIPAddress()

///////////////////////////////////////////////////////////////////////////////
//  IsValid -- validate an ip address
//
BOOL CIPAddress::IsValid(TCHAR *psztStringAddress,
                         TCHAR *psztReturnVal,
                         DWORD  CRtnValSize)
{
    BOOL bIsValid = TRUE;
    CHAR szHostName[MAX_NETWORKNAME_LEN];

    UNICODE_TO_MBCS(szHostName, MAX_NETWORKNAME_LEN, psztStringAddress, -1);
    if ( inet_addr(szHostName) ==  INADDR_NONE ) {

        bIsValid = FALSE;
    }
    else
    {
        int num0 = 0;
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;

        //
        // Scan for correct dotted notation
        //
        if( _stscanf(psztStringAddress, _TEXT("%d.%d.%d.%d"), 
                &num0, 
                &num1, 
                &num2, 
                &num3) != 4 )
        {
            bIsValid = FALSE;
        }
        if( num0 == 0 )
        {
            bIsValid = FALSE;
        }
    }

    // Finish
    if (!bIsValid)
    {
        if(psztReturnVal != NULL)
        {
            lstrcpyn(psztReturnVal, 
                     m_psztStorageString, 
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_psztStorageString, 
                 psztStringAddress, 
                 STORAGE_STRING_LEN);
    }
    return(bIsValid);

} // IsValid


///////////////////////////////////////////////////////////////////////////////
//  IsValid -- validate an ip number entered in an edit control.
//

BOOL CIPAddress::IsValid(BYTE Address[4])
{
    for(int i=0; i<4; i++)
    {
        if ((Address[i] > 255) || (Address[i] < 0))
        {
            return FALSE;
        }
    }

    // if we got through all that stuff:
    return TRUE;

} // IsValid


///////////////////////////////////////////////////////////////////////////////
//  SetAddress -- set the value of this IPAddress object given 4 strings
//

void CIPAddress::SetAddress(TCHAR *psztAddr1,
                            TCHAR *psztAddr2,
                            TCHAR *psztAddr3,
                            TCHAR *psztAddr4)
{
    m_bAddress[0] = (BYTE) _ttoi( psztAddr1 );
    m_bAddress[1] = (BYTE) _ttoi( psztAddr2 );
    m_bAddress[2] = (BYTE) _ttoi( psztAddr3 );
    m_bAddress[3] = (BYTE) _ttoi( psztAddr4 );

} // SetAddress


///////////////////////////////////////////////////////////////////////////////
//  SetAddress -- Set the address given a string
//

void CIPAddress::SetAddress(TCHAR *psztAddress)
{
    int num0 = 0;
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    if(IsValid(psztAddress))
    {
        _stscanf(psztAddress, _TEXT("%d.%d.%d.%d"), &num0, &num1, &num2, &num3);
    }
    m_bAddress[0] = (BYTE)num0;
    m_bAddress[1] = (BYTE)num1;
    m_bAddress[2] = (BYTE)num2;
    m_bAddress[3] = (BYTE)num3;

} // SetAddress


///////////////////////////////////////////////////////////////////////////////
//  ToString -- fill the given buffer with a string representing the IP address.
//

void CIPAddress::ToString(TCHAR *psztBuffer,
                          int iSize)
{
    TCHAR strAddr[MAX_IPADDR_STR_LEN] = NULLSTR;
    _stprintf(strAddr, _TEXT("%d.%d.%d.%d"), m_bAddress[0], m_bAddress[1], m_bAddress[2], m_bAddress[3]);
    lstrcpyn(psztBuffer, strAddr, iSize);

} // ToString


///////////////////////////////////////////////////////////////////////////////
//  ToComponentStrings -- fill the given buffers with 4 strings representing the IP address.
//

void CIPAddress::ToComponentStrings(TCHAR *str1,
                                    TCHAR *str2,
                                    TCHAR *str3,
                                    TCHAR *str4)
{
    _stprintf(str1, TEXT("%d"), m_bAddress[0]);
    _stprintf(str2, TEXT("%d"), m_bAddress[1]);
    _stprintf(str3, TEXT("%d"), m_bAddress[2]);
    _stprintf(str4, TEXT("%d"), m_bAddress[3]);

} // ToComponentStrings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\nt5uimgr.h ===
/*****************************************************************************
 *
 * $Workfile: NT5UIMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_NT5_UI_MANAGER_H
#define INC_NT5_UI_MANAGER_H

class CNT5UIManager : public CUIManager
{
public:
	CNT5UIManager();
	~CNT5UIManager() {}

	DWORD AddPortUI(HWND hWndParent, HANDLE hXcvPrinter, TCHAR pszServer[], TCHAR sztPortName[]);
	DWORD ConfigPortUI(HWND hWndParent, PPORT_DATA_1 pData, HANDLE hXcvPrinter, TCHAR szServerName[], BOOL bNewPort = FALSE);

protected:

private:

}; // CNT5UIManager

#endif // INC_NT5_UI_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\precomp.h ===
/*****************************************************************************
 *
 * Copyright (C) 2000 Hewlett-Packard Company.
 * Copyright (C) 2000 Microsoft Corporation.
 * All rights reserved.
 *
 *
 *****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <winspool.h>
#include <tchar.h>

#include <stdlib.h>
#include <winsock.h>
#include <wininet.h>
#include <ipaddr.h>
#include <stdio.h>
#include <commctrl.h>    // includes track bar
#include <winsplp.h>

//
//  Header files in ..\Common
//
#include "debug.h"		// debug functions
#include "tcpmon.h"
#include "mibabc.h"
#include "RTcpData.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\ipaddr.h ===
/*****************************************************************************
 *
 * $Workfile: IPAddr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_IPADDR_H
#define INC_IPADDR_H

class CMemoryDebug;

#define MAX_IPCOMPONENT_STRLEN 3 + 1
#define STORAGE_STRING_LEN 64

class CIPAddress
{
public:
	CIPAddress();
	CIPAddress(LPTSTR psztIPAddr);
	~CIPAddress();

		// the string passed in to IsValid in AddressString param is _one_ of the 4
		// bytes.  The caller is responsible for breaking apart the IP Address into
		// its 4 (or 6) components.
		// if the string passed in to IsValid in AddressString param is not a valid
		// IP Address then the returnVal is filled with the last valid IP Address from
		// the previous time this method was called.  This facilitates validation for
		// each keystroke the user makes.

	BOOL IsValid(BYTE Address[4]);
	BOOL IsValid() { return IsValid(m_bAddress); }
	BOOL IsValid(TCHAR *psztStringAddress,
                 TCHAR *psztReturnVal = NULL,
                 DWORD CRtnValSize = 0);

	void SetAddress(TCHAR *AddressString);
	void SetAddress(TCHAR *psztAddr1, TCHAR *psztAddr2, TCHAR *psztAddr3, TCHAR *psztAddr4);

	void ToString(TCHAR *psztBuffer, int iSize);
	void ToComponentStrings(TCHAR *str1, TCHAR *str2, TCHAR *str3, TCHAR *str4);

private:
	BYTE	m_bAddress[4];
	TCHAR   m_psztStorageString[STORAGE_STRING_LEN];
	TCHAR	m_psztStorageStringComponent[STORAGE_STRING_LEN]; // last valid string entered in the text entry box.
};


#endif // INC_IPADDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcpmonui.rc
//
#define IDS_STRING_CONFIG_TITLE         1
#define IDS_STRING_ALLPORTS_TITLE       2
#define IDS_STRING_PORTPAGE_TITLE       3
#define IDS_STRING_ADDPORT_TITLE        4
#define IDS_STRING_ERROR_ADDRESS_NOT_VALID 5
#define IDS_STRING_ERROR_TITLE          6
#define IDS_STRING_ERROR_PORTNAME_NOT_VALID 7
#define IDS_STRING_ERROR_PORTNAME_NOT_UNIQUE 8
#define IDS_STRING_ERROR_LOADING_TCPMIB_LIB 9
#define IDS_STRING_YES                  10
#define IDS_STRING_NO                   11
#define IDS_STRING_RAW                  12
#define IDS_STRING_LPR                  13
#define IDS_STRING_PORT                 14
#define IDS_STRING_UNKNOWN_DEVICE       15
#define IDS_STRING_ERROR_PORT_NUMBER_NOT_VALID 16
#define IDS_STRING_ERROR_QNAME_NOT_VALID 17
#define IDS_STRING_ERROR_COMMUNITY_NAME_NOT_VALID 18
#define IDS_STRING_ERROR_SNMP_DEVINDEX_NOT_VALID 19
#define IDS_STRING_ADDPORT_HEADER       20
#define IDS_STRING_ADDPORT_SUBTITLE     21
#define IDS_STRING_MOREINFO_HEADER      22
#define IDS_STRING_MOREINFO_SUBTITLE    23
#define IDS_STRING_DEV_NOT_FOUND        24
#define IDS_STRING_MULTI_PORT_DEV       25
#define IDS_STRING_UNKNOWN_DEV          26
#define IDS_STRING_ERROR_LOADING_TCPMON_LIB 27
#define IDS_STRING_ERROR_LOADING_WINSPOOL_LIB 28
#define IDS_STRING_NAME_IP              29
#define IDS_ERROR_ACCESS                30
#define IDS_STRING_ERROR_ERRMSG         30
#define IDS_ERROR_DATA                  31
#define IDS_STRING_ADD_PORT             31
#define IDS_ERROR_MEMORY                32
#define IDS_LARGEFONTNAME               32
#define IDS_LARGEFONTSIZE               33
#define IDS_MULTIPORT_HEADER            34
#define IDS_MULTIPORT_SUBTITLE          35
#define IDD_DIALOG_ADDPORT              101
#define IDC_TRACKBAR_FAILURE_TIMEOUT    101
#define IDD_WELCOME_PAGE                102
#define IDD_DIALOG_SUMMARY              103
#define IDD_DIALOG_PORT_SETTINGS        104
#define IDD_DIALOG_MORE_INFO            105
#define IDD_DIALOG_CONFIG_ALL           106
#define IDB_WATERMARK                   108
#define IDB_BANNER                      109
#define IDD_PORT_SETTINGS               110
#define IDD_DIALOG_MULTIPORT            111
#define IDC_EDIT_DEVICE_ADDRESS         1000
#define IDC_EDIT_PORT_NAME              1001
#define IDC_CHECK_STATUSUPDATE          1001
#define IDC_EDIT_SNMP_YESNO             1002
#define IDC_TRACKBAR_TOP                1002
#define IDC_EDIT_PROTOCOL_AND_PORTNUM   1003
#define IDC_EDIT_IPADDRESS              1004
#define IDC_DIGITAL_FAILURE_TIMEOUT     1004
#define IDC_EDIT_ADDRESS                1004
#define IDC_EDIT_PORTNAME               1005
#define IDC_RADIO1                      1006
#define IDC_RADIO_RAW                   1006
#define IDC_EDIT_SYSTEMID               1006
#define IDC_RADIO_LPR                   1007
#define IDC_EDIT_RAW_PORT_NUM           1008
#define IDC_EDIT2                       1009
#define IDC_EDIT_LPR_QNAME              1009
#define IDC_CHECK_SNMP                  1010
#define IDC_EDIT3                       1011
#define IDC_EDIT_COMMUNITY_NAME         1011
#define IDC_EDIT4                       1012
#define IDC_EDIT_DEVICE_INDEX           1012
#define IDC_RADIO_STANDARD              1013
#define IDC_RADIO_CUSTOM                1014
#define IDC_BUTTON1                     1015
#define IDC_BUTTON_SETTINGS             1015
#define IDC_COMBO_DEVICES               1016
#define IDC_STATIC_RAW_PORT_NUM         1017
#define IDC_STATIC_LPR_QNAME            1020
#define IDC_STATIC_COMMUNITY_NAME       1021
#define IDC_STATIC_DEVICE_INDEX         1022
#define IDC_STATIC_MOREINFO_REASON      1024
#define IDC_STATIC_PORT_NAME            1026
#define IDC_STATIC_DEVICE_ADDRESS       1027
#define IDC_STATIC_ALL_PORTS_TITLE      1028
#define IDC_STATIC_FT_LABEL             1029
#define IDC_STATIC_MINUTES              1030
#define IDC_STATIC_MORE_OFTEN           1031
#define IDC_STATIC_LESS_OFTEN           1032
#define IDC_STATIC_ADD_PORT             1033
#define IDC_TITLE                       1034
#define IDC_CHECK_LPR_DOUBLESPOOL       1035
#define IDS_GENERIC_NETWORK_CARD        2000
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\tcpmonui.h ===
/*****************************************************************************
 *
 * $Workfile: TCPMonUI.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

//
// defines
//

// MAX_ADDRESS_LENGTH should be set to max(MAX_FULLY_QUALIFIED_HOSTNAME_LEN-1, MAX_IPADDR_STR_LEN-1);
#define		MAX_ADDRESS_LENGTH			MAX_FULLY_QUALIFIED_HOSTNAME_LEN-1

#define MAX_PORTNUM_STRING_LENGTH 6+1
#define MAX_SNMP_DEVICENUM_STRING_LENGTH   128+1

//
// function prototypes
//
void DisplayErrorMessage(HWND hDlg, UINT uErrorTitleResource, UINT uErrorStringResource);
void DisplayErrorMessage(HWND hDlg, DWORD dwLastError);
BOOL OnHelp(UINT iDlgID, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//
// typedef's
//
typedef BOOL (* XCVDATAPARAM)(HANDLE, PCWSTR, PBYTE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
typedef DWORD (* UIEXPARAM)(PPORT_DATA_1);

//
// exported functions
//
BOOL APIENTRY DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved);
PMONITORUI WINAPI InitializePrintMonitorUI(VOID);
extern "C" BOOL WINAPI LocalAddPortUI(HWND hWnd);
extern "C" BOOL WINAPI LocalConfigurePortUI(HWND hWnd, PORT_DATA_1 *pConfigPortData);


//
// Global Variables
//
extern HINSTANCE g_hWinSpoolLib;
extern HINSTANCE g_hPortMonLib;
extern HINSTANCE g_hTcpMibLib;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\tcpmonui.cpp ===
/*****************************************************************************
 *
 * $Workfile: TCPMonUI.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/
#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "resource.h"
#include "splcom.h"
#include "helpids.h"

HINSTANCE g_hInstance = NULL;
MONITORUI g_monitorUI;

// library handles:
HINSTANCE g_hWinSpoolLib = NULL;
HINSTANCE g_hPortMonLib = NULL;
HINSTANCE g_hTcpMibLib = NULL;

///////////////////////////////////////////////////////////////////////////////
//  LoadGlobalLibraries
//
BOOL LoadGlobalLibraries()
{
    BOOL bReturn = TRUE;

    g_hWinSpoolLib = ::LoadLibrary(TEXT("WinSpool.drv"));
    if(g_hWinSpoolLib == NULL)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_LOADING_WINSPOOL_LIB);
        bReturn = FALSE;
    }

    // In either case load the tcpmib dll.
    g_hTcpMibLib = ::LoadLibrary(TCPMIB_DLL_NAME);
    if(g_hTcpMibLib == NULL)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_LOADING_TCPMIB_LIB);
        bReturn = FALSE;
    }

    return(bReturn);

} // LoadGlobalLibraries


///////////////////////////////////////////////////////////////////////////////
//  DllMain
//
BOOL APIENTRY
DllMain (       HANDLE in hInst,
            DWORD  in dwReason,
            LPVOID in lpReserved )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            //
            // Initialize common controls.
            //
            INITCOMMONCONTROLSEX icc;
            InitCommonControls();
            icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
            icc.dwICC = ICC_STANDARD_CLASSES|ICC_BAR_CLASSES;
            InitCommonControlsEx(&icc);

            DisableThreadLibraryCalls( hInst );

            InitDebug(MONUI_DEBUG_FILE);            // initialize debug file

            g_hInstance = (HINSTANCE) hInst;
            memset(&g_monitorUI, 0, sizeof(g_monitorUI));

            return TRUE;

        case DLL_PROCESS_DETACH:
            {
                // The UI sets the last error for the spooler to use later
                // we are keeping a copy to make sure that it is not over
                // written by the dlls as they unload
                //

                DWORD dwLastError = GetLastError();

                if( g_hWinSpoolLib != NULL )
                {
                   ::FreeLibrary(g_hWinSpoolLib);
                }
                if( g_hPortMonLib != NULL )
                {
                   ::FreeLibrary(g_hPortMonLib);
                }
                if( g_hTcpMibLib != NULL )
                {
                    ::FreeLibrary(g_hTcpMibLib);
                }

                if (WSACleanup() == SOCKET_ERROR)
                {
                      _RPT0(_CRT_WARN,"\t> Unable to clean up windows sockets\n");
                }

                // This resets the application last error if one
                // exists.  We cannot allow the UI last error to
                // be overwritten by the dlls being unloaded
                //
                if( dwLastError != NO_ERROR ) {
                    SetLastError( dwLastError );
                }
           }

            // perform any necessary clean up process
            return TRUE;

        case DLL_THREAD_ATTACH:

            return TRUE;

        case DLL_THREAD_DETACH:

            return TRUE;
    }

    return FALSE;

} // DllMain


///////////////////////////////////////////////////////////////////////////////
//  InitializePrintMonitorUI
//              Returns a MONITOREX structure or NULL if failure
//
PMONITORUI WINAPI
InitializePrintMonitorUI(VOID)
{
    DWORD           dwRetCode = NO_ERROR;
    PMONITORUI      pMonitorUI = NULL;
    WSADATA wsaData;

    if(! LoadGlobalLibraries())
        return NULL;

    // Start up Winsock.
    if ( WSAStartup(WS_VERSION_REQUIRED, (LPWSADATA)&wsaData) != NO_ERROR)
    {
        _RPT1(_CRT_WARN, "CSSOCKET -- CStreamSocket() WSAStartup failed! Error( %d )\n", WSAGetLastError());
        return NULL;
    }

    g_monitorUI.dwMonitorUISize = sizeof(MONITORUI);
    g_monitorUI.pfnAddPortUI                = ::AddPortUI;
    g_monitorUI.pfnConfigurePortUI  = ::ConfigurePortUI;
    g_monitorUI.pfnDeletePortUI             = ::DeletePortUI;

    pMonitorUI = &g_monitorUI;


    return (pMonitorUI);

} // InitializePrintMonitorUI


///////////////////////////////////////////////////////////////////////////////
//  RemoteAddPortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
AddPortUI(PCWSTR pszServer, HWND hWnd, PCWSTR pszMonitorNameIn, PWSTR *ppszPortNameOut)
{
    CUIManager manager;
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    DWORD dwRetCode = NO_ERROR;
    BOOL bReturn = TRUE;
    TCHAR szServerName[MAX_NETWORKNAME_LEN] = {0};

    if ( ppszPortNameOut )
        *ppszPortNameOut = NULL;

    if (hWnd == NULL)
    {
        return TRUE;
    }

    TCHAR *psztPortName = (TCHAR *)malloc(sizeof(TCHAR) * MAX_PORTNAME_LEN);
    if( psztPortName == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );
    }

    if(pszServer != NULL)
    {
        lstrcpyn(szServerName, pszServer, MAX_NETWORKNAME_LEN);
    }

    // Construct the OpenPrinter String
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];
    if(pszServer == NULL)
    {
        _stprintf(OpenPrinterString, TEXT(",XcvMonitor %s"), pszMonitorNameIn);
    }
    else
    {
        _stprintf(OpenPrinterString, TEXT("%s\\,XcvMonitor %s"), pszServer, pszMonitorNameIn);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);

    if(bReturn)
    {
        if(hXcvPrinter != NULL)
        {
            dwRetCode = manager.AddPortUI(hWnd,
                                          hXcvPrinter,
                                          szServerName,
                                          psztPortName);
        }

        if ( ppszPortNameOut )
        {
            _ASSERTE(psztPortName != NULL);
            *ppszPortNameOut = psztPortName;
            psztPortName = NULL;
        }
    }
    else
    {
        dwRetCode = GetLastError();
    }

    if( psztPortName != NULL)
    {

        free( psztPortName );
        psztPortName = NULL;
    }

    if( hXcvPrinter != NULL )
    {
        ClosePrinter(hXcvPrinter);
    }

    if( dwRetCode != NO_ERROR )
    {
        // something went wrong
        bReturn = FALSE;
    }

    SetLastError( dwRetCode );
    return bReturn;

} // ExtAddPortUI


///////////////////////////////////////////////////////////////////////////////
//  Load and Call XcvData in order to get Configuration Information.
//              Returns TRUE if success, FALSE otherwise
//
DWORD GetConfigInfo(PORT_DATA_1 *pData, HANDLE hXcvPrinter, PCWSTR pszPortName)
{
    XCVDATAPARAM pfnXcvData = NULL;
    DWORD dwRet = NO_ERROR;
    DWORD dwDataSize = 0;
    DWORD dwOutputNeeded = 0;
    DWORD dwStatus = 0;
    BOOL bReturn = TRUE;
    CONFIG_INFO_DATA_1 cfgData;

    memset( &cfgData, 0, sizeof( cfgData ));
    cfgData.dwVersion = 1;

    // load & assign the function pointer
    if(g_hWinSpoolLib != NULL)
    {
        // initialize the library
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
        if(pfnXcvData != NULL)
        {
            dwDataSize = sizeof(PORT_DATA_1);

            //
            // Set the UI version
            //
            pData->dwVersion = 1;

            // here's the call we've all been waiting for:
            bReturn = (*pfnXcvData)(hXcvPrinter,
                                (PCWSTR)TEXT("GetConfigInfo"),
                                (LPBYTE)&cfgData, // Input Data
                                sizeof( cfgData ),      // Input Data Size
                                (LPBYTE)pData, // Output Data
                                dwDataSize, // Output Data Size
                                &dwOutputNeeded, // size of output buffer server wants to return
                                &dwStatus // return status value from remote component
                                );
            if(!bReturn)
            {
                dwRet = GetLastError();
                DisplayErrorMessage(NULL, dwRet);
            }
            else
            {
                if(dwStatus != NO_ERROR)
                {
                    DisplayErrorMessage(NULL, dwStatus);
                }
            }

        }
        else
        {
            dwRet = ERROR_DLL_NOT_FOUND; // TODO: change to an appropriate error code.
        }

    }
    else
    {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    return(dwRet);

} // GetConfigInfo


///////////////////////////////////////////////////////////////////////////////
//  RemoteConfigurePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
ConfigurePortUI(PCWSTR pszServer, HWND hWnd, PCWSTR pszPortName)
{
    PORT_DATA_1 Data;
    memset(&Data, 0, sizeof(PORT_DATA_1));
    CUIManager manager;
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };

    DWORD dwResult = NO_ERROR;
    BOOL bReturn = TRUE;
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];
    TCHAR szServerName[MAX_NETWORKNAME_LEN] = {0};
    if(pszServer && *pszServer)
    {
        lstrcpyn(szServerName, pszServer, MAX_NETWORKNAME_LEN);
    }

    if(hWnd == NULL)
    {
        return bReturn;
    }

    // Construct the OpenPrinter String
    if(pszServer && *pszServer)
    {
        _stprintf(OpenPrinterString, TEXT("%s\\,XcvPort %s"), pszServer, pszPortName);
    }
    else
    {
        _stprintf(OpenPrinterString, TEXT(",XcvPort %s"), pszPortName);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);

    if(bReturn != FALSE && hXcvPrinter != NULL)
    {
        HCURSOR hNewCursor = NULL;
        HCURSOR hOldCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if( hNewCursor )
        {
            hOldCursor = SetCursor(hNewCursor);
        }

        dwResult = GetConfigInfo(&Data, hXcvPrinter, pszPortName);

        if( hNewCursor )
        {
            SetCursor(hOldCursor);
        }

        if(dwResult != NO_ERROR)
        {
            SetLastError(dwResult);
            bReturn = FALSE;
        }

        if(bReturn == TRUE)
        {
            dwResult = manager.ConfigPortUI(hWnd, &Data, hXcvPrinter, szServerName);
            if(dwResult != NO_ERROR)
            {
                SetLastError(dwResult);
                bReturn = FALSE;
            }
        }
    }

    if( hXcvPrinter != NULL )
    {
        ClosePrinter(hXcvPrinter);
    }
    return(bReturn);

} // ConfigurePortUI


///////////////////////////////////////////////////////////////////////////////
//  RemoteDeletePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
DeletePortUI(PCWSTR pszServer,
             HWND hwnd,
             PCWSTR pszPortName)
{
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    BOOL bReturn = TRUE;
    XCVDATAPARAM pfnXcvData = NULL;
    DELETE_PORT_DATA_1 delData;
    memset(&delData, 0, sizeof(DELETE_PORT_DATA_1));
    DWORD dwDataSize = 0;
    DWORD dwOutputNeeded = 0;
    DWORD dwStatus = 0;
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];

    // Construct the OpenPrinter String
    if(pszServer == NULL || pszServer[0] == TEXT('\0'))
    {
        _stprintf(OpenPrinterString, TEXT(",XcvPort %s"), pszPortName);
    }
    else
    {
        _stprintf(OpenPrinterString, TEXT("%s\\,XcvPort %s"), pszServer, pszPortName);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);
    if(bReturn)
    {
        // load & assign the function pointer
        if(g_hWinSpoolLib != NULL)
        {
            // initialize the library
            pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
            if(pfnXcvData != NULL)
            {
                // Set the data members of delData.
                if(pszServer && *pszServer )
                {
                    lstrcpyn(delData.psztName, pszServer, MAX_NETWORKNAME_LEN);
                }
                else
                {
                    delData.psztName[0] = '\0';
                }
                //delData.hWnd = 0;  This field si not used anywhere
                delData.dwVersion = 1;

                if(pszPortName != NULL)
                {
                    lstrcpyn(delData.psztPortName, pszPortName, MAX_PORTNAME_LEN);
                }
                else
                {
                    delData.psztPortName[0] = '\0';
                }
                dwDataSize = sizeof(DELETE_PORT_DATA_1);

                // here's the call we've all been waiting for:
                bReturn = (*pfnXcvData)(hXcvPrinter,
                                        (PCWSTR)TEXT("DeletePort"),
                                        (BYTE *)(& delData),    // Input Data
                                        dwDataSize,             // Input Data Size
                                        NULL,                   // Output Data
                                        0,                      // Output Data Size
                                        &dwOutputNeeded,        // size of output buffer server wants to return
                                        &dwStatus               // return status value from remote component
                                        );

                if(bReturn)
                {
                    if(dwStatus != NO_ERROR)
                    {
                        DisplayErrorMessage(NULL, dwStatus);

                        //
                        // The call actually failed. Since we already displayed the error message
                        // we need to disable the popup from printui.
                        //

                        SetLastError (ERROR_CANCELLED);
                        bReturn = FALSE;
                    }
                }
                else {
                    DisplayErrorMessage(NULL, GetLastError ());

                    //
                    // The call actually failed. Since we already displayed the error message
                    // we need to disable the popup from printui.
                    //

                    SetLastError (ERROR_CANCELLED);
                    bReturn = FALSE;
                }
            }
            else // pfnXcvData == NULL
            {
                bReturn = FALSE;
                SetLastError(ERROR_DLL_NOT_FOUND);
            }
        }
        else // g_hWinSpoolLib == NULL
        {
            SetLastError(ERROR_DLL_NOT_FOUND);
        }

        if( hXcvPrinter != NULL )
        {
            ClosePrinter(hXcvPrinter);
        }
    }

    return(bReturn);

} // DeletePortUI


///////////////////////////////////////////////////////////////////////////////
//  LocalAddPortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
LocalAddPortUI(HWND in hWnd)
{
    DWORD dwRetCode = NO_ERROR;

    CUIManager manager;
    dwRetCode = manager.AddPortUI(hWnd, NULL, NULL, NULL);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // LocalAddPortUI


///////////////////////////////////////////////////////////////////////////////
//  LocalConfigurePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
LocalConfigurePortUI(HWND   in hWnd,
                     PORT_DATA_1 in *pConfigPortData)
{
    DWORD dwRetCode = NO_ERROR;
    CUIManager manager;

    // call ConfigurePortUI()
    dwRetCode = manager.ConfigPortUI(hWnd, pConfigPortData, NULL, NULL);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // LocalConfigurePortUI


///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: DisplayErrorMessage()
//
//  PURPOSE:  To load a string resource, the error message, and put up a message box.
//
void DisplayErrorMessage(HWND hDlg, UINT uErrorTitleResource, UINT uErrorStringResource)
{
    TCHAR   ptcsErrorTitle[MAX_PATH];
    TCHAR   ptcsErrorMessage[MAX_PATH];
    LoadString(g_hInstance, uErrorTitleResource, ptcsErrorTitle, MAX_PATH);
    LoadString(g_hInstance, uErrorStringResource, ptcsErrorMessage, MAX_PATH);
    MessageBox(hDlg, ptcsErrorMessage, ptcsErrorTitle, MB_ICONERROR);

} // DisplayErrorMessage


///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: DisplayErrorMessage()
//
//  PURPOSE:  To load a string resource, the error message, and put up a message box.
//
void DisplayErrorMessage(HWND hDlg, DWORD dwLastError)
{
    const int iMaxErrorMsgSize = 75;
    TCHAR ptcsErrorTitle[iMaxErrorMsgSize];
    LoadString(g_hInstance, IDS_STRING_ERROR_TITLE, ptcsErrorTitle, iMaxErrorMsgSize);

    LPVOID lpMsgBuf = NULL;
    DWORD NumCharsInBuffer;

    NumCharsInBuffer = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
    );

    if(NumCharsInBuffer <= 0)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ERRMSG);
    }
    else
    {
        // Process any inserts in lpMsgBuf.
        // ...
        // Display the string.
        MessageBox( hDlg, (TCHAR *)lpMsgBuf, ptcsErrorTitle, MB_OK | MB_ICONERROR );

    }

    // Free the buffer.
    LocalFree( lpMsgBuf );


} // DisplayErrorMessage

///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: OnHelp()
//
//  PURPOSE:  Process WM_HELP and WM_CONTEXTMENU messages
//
BOOL OnHelp(UINT iDlgID, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
        case WM_HELP:
            {
                bStatus = WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                                   PORTMONITOR_HELP_FILE,
                                   HELP_WM_HELP,
                                   (ULONG_PTR)g_a110HelpIDs );
            }
            break;

        case WM_CONTEXTMENU:
            {
                bStatus = WinHelp( (HWND)wParam,
                                   PORTMONITOR_HELP_FILE,
                                   HELP_CONTEXTMENU,
                                   (ULONG_PTR)g_a110HelpIDs );
            }
            break;

        default:
            bStatus= FALSE;
            break;
    }

    return bStatus;
} // OnHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\nt5uimgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: NT5UIMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

/*
 * Author: Becky Jacobsen
 */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "NT5UIMgr.h"

#include "Prsht.h"
#include "resource.h"

// includes for ConfigPort
#include "DevPort.h"
#include "CfgPort.h"
#include "CfgAll.h"

// includes for AddPort
#include "AddWelcm.h"
#include "AddGetAd.h"
#include "AddMInfo.h"
#include "AddMulti.h"
#include "AddDone.h"

static void FillInPropertyPage( PROPSHEETPAGE* psp, // a pointer to the structure to be filled in.
                                int idDlg,                      // the id of the dialog template
                                LPTSTR pszProc,         // Title of the dialog.
                                LPTSTR pszHeaderTitle,          // Title displayed in the header.
                                LPTSTR pszHeaderSubTitle,       // SubTitle displayed in the header.
                                DWORD dwFlags,          // Flags used by the page.
                                DLGPROC pfnDlgProc,     // dialog procedure that handles window messages.
                                LPARAM lParam);         // data that will appear in the lParam field of the struct passed to the dialog procedure.

//
//  FUNCTION: CNT5UIManager
//
//  PURPOSE: Constructor
//
CNT5UIManager::CNT5UIManager()
{
} // Constructor

//
//  FUNCTION: AddPortUI
//
//  PURPOSE: Main function called when the User Interface for adding a port is called.
//
DWORD CNT5UIManager::AddPortUI(HWND hWndParent,
                               HANDLE hXcvPrinter,
                               TCHAR pszServer[],
                               TCHAR sztPortName[])
{
    INT_PTR iReturnVal;
    PROPSHEETPAGE psp[MaxNumAddPages];
    PROPSHEETHEADER psh;
    PORT_DATA_1 PortData;
    ADD_PARAM_PACKAGE Params;

    TCHAR sztPropSheetTitle[MAX_TITLE_LENGTH];
    TCHAR sztWelcomePageTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztSummaryPageTitle[MAX_TITLE_LENGTH];

    memset(&PortData, 0, sizeof(PortData));

    PortData.dwVersion = 1;
    Params.pData = &PortData;
    Params.hXcvPrinter = hXcvPrinter;
    Params.UIManager = this;
    Params.dwLastError = NO_ERROR;
    if (pszServer != NULL) {
        lstrcpyn(Params.pszServer, pszServer, MAX_NETWORKNAME_LEN);
    } else {
        Params.pszServer[0] = '\0';
    }
    if (sztPortName != NULL) {
        lstrcpyn(Params.sztPortName, sztPortName, MAX_PORTNAME_LEN);
    } else {
        Params.sztPortName[0] = '\0';
    }

    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztWelcomePageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztAddPortPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_HEADER, sztAddPortHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_SUBTITLE, sztAddPortHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztMoreInfoPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_MOREINFO_HEADER, sztMoreInfoHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_MOREINFO_SUBTITLE, sztMoreInfoHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztMultiPortPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_MULTIPORT_HEADER, sztMultiPortHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_MULTIPORT_SUBTITLE, sztMultiPortHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztSummaryPageTitle, MAX_TITLE_LENGTH);

    FillInPropertyPage( &psp[0], IDD_WELCOME_PAGE, sztWelcomePageTitle, sztWelcomePageTitle, NULL, PSP_HIDEHEADER, (DLGPROC)WelcomeDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[1], IDD_DIALOG_ADDPORT, sztAddPortPageTitle, sztAddPortHeaderTitle, sztAddPortHeaderSubTitle, 0, (DLGPROC)GetAddressDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[2], IDD_DIALOG_MORE_INFO, sztMoreInfoPageTitle, sztMoreInfoHeaderTitle, sztMoreInfoHeaderSubTitle, 0, (DLGPROC)MoreInfoDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[3], IDD_DIALOG_MULTIPORT, sztMultiPortHeaderTitle, sztMultiPortHeaderTitle, sztMultiPortHeaderSubTitle, 0, (DLGPROC)MultiPortDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[4], IDD_DIALOG_SUMMARY, sztSummaryPageTitle, NULL, NULL, PSP_HIDEHEADER, (DLGPROC)SummaryDialog, (LPARAM)&Params);

    LoadString(g_hInstance, IDS_STRING_CONFIG_TITLE, sztPropSheetTitle, MAX_TITLE_LENGTH);

    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.hInstance       = g_hInstance;
    psh.dwFlags         = PSH_WIZARD | PSH_PROPSHEETPAGE | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    psh.hwndParent      = hWndParent;
    psh.pszCaption      = sztPropSheetTitle;
    psh.nPages          = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage      = 0;
    psh.ppsp            = (LPCPROPSHEETPAGE) &psp;
    psh.pszbmWatermark  = MAKEINTRESOURCE( IDB_WATERMARK );
    psh.pszbmHeader     = MAKEINTRESOURCE( IDB_BANNER );

    iReturnVal = PropertySheet(&psh);

    if (iReturnVal < 0) {
        return(ERROR_INVALID_FUNCTION);
    }

    return(Params.dwLastError);

} // AddPortUI


//
//  FUNCTION: ConfigPortUI
//
//  PURPOSE: Main function called when the User Interface for configuring a port is called.
//
DWORD CNT5UIManager::ConfigPortUI(HWND hWndParent,
                                  PPORT_DATA_1 pData,
                                  HANDLE hXcvPrinter,
                                  TCHAR *szServerName,
                                  BOOL bNewPort)
{
    INT_PTR iReturnVal = NO_ERROR;
    PROPSHEETPAGE psp[MaxNumCfgPages];
    PROPSHEETHEADER psh;

    TCHAR sztPropSheetTitle[MAX_TITLE_LENGTH];
    TCHAR sztPortPageTitle[MAX_TITLE_LENGTH];


    CFG_PARAM_PACKAGE Params;
    Params.pData = pData;
    pData->dwVersion = 1;
    Params.hXcvPrinter = hXcvPrinter;
    Params.bNewPort = bNewPort;
    Params.dwLastError = NO_ERROR;
    if (szServerName != NULL) {
        lstrcpyn(Params.pszServer, szServerName, MAX_NETWORKNAME_LEN);
    } else {
        Params.pszServer[0] = '\0';
    }

    LoadString(g_hInstance, IDS_STRING_PORTPAGE_TITLE, sztPortPageTitle, MAX_TITLE_LENGTH);

    FillInPropertyPage( &psp[0], IDD_PORT_SETTINGS, sztPortPageTitle, NULL, NULL, 0, (DLGPROC)ConfigurePortPage, (LPARAM)&Params);
#if 0
    if (!bNewPort) {
        // It's not a brand new port so show the AllPorts Page.
        FillInPropertyPage( &psp[1], IDD_DIALOG_CONFIG_ALL, sztAllPortsPageTitle, NULL, NULL, 0, (DLGPROC)AllPortsPage, (LPARAM)&Params);
    }
#endif
    LoadString(g_hInstance, IDS_STRING_CONFIG_TITLE, sztPropSheetTitle, MAX_TITLE_LENGTH);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE;
    psh.hwndParent = hWndParent;
    psh.hInstance = g_hInstance;
    psh.pszCaption = sztPropSheetTitle;
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;
    psh.pfnCallback = NULL;
    psh.nPages = MaxNumCfgPages;

    iReturnVal = PropertySheet(&psh);

    if (iReturnVal < 0) {
        return(ERROR_INVALID_FUNCTION);
    }

    return(Params.dwLastError);

} // ConfigPortUI


//
//
//  FUNCTION: FillInPropertyPage(PROPSHEETPAGE *, int, LPSTR, LPFN)
//
//  PURPOSE: Fills in the given PROPSHEETPAGE structure
//
//  COMMENTS:
//
//      This function fills in a PROPSHEETPAGE structure with the
//      information the system needs to create the page.
//
static void FillInPropertyPage( PROPSHEETPAGE* psp, int idDlg, LPTSTR pszProc, LPTSTR pszHeaderTitle, LPTSTR pszHeaderSubTitle, DWORD dwFlags, DLGPROC pfnDlgProc, LPARAM lParam)
{
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = PSP_USETITLE |
                   ((pszHeaderTitle != NULL) ? PSP_USEHEADERTITLE : 0) |
                   ((pszHeaderSubTitle != NULL) ? PSP_USEHEADERSUBTITLE : 0) |
                   dwFlags;
    psp->hInstance = g_hInstance;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = pszProc;
    psp->lParam = lParam;
    psp->pszHeaderTitle = pszHeaderTitle;
    psp->pszHeaderSubTitle = pszHeaderSubTitle;

} // FillInPropertyPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\usbmon\enumports.c ===
#include <nt.h>																		
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
//#include <wchar.h>
#include <setupapi.h>
//#include <stdlib.h>
#include "enumports.h"
#include "usbmon.h"

void vOldAddItemToPortList(PUSBMON_PORT_INFO *pHead,PUSBMON_PORT_INFO pNew); 
PUSBMON_PRINTER_INFO pOldGetPrinterList();
LONG UpdateAssociations(PUSBMON_PORT_INFO *ppPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG AllocateNewPorts(PUSBMON_PORT_INFO *ppPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG DoBestEffortMatches(PUSBMON_PORT_INFO pPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG ReattachExactMatches(PUSBMON_PORT_INFO pPortList,PUSBMON_PRINTER_INFO pPrinterList);
//void InitPortBits(PUSBMON_PORT_INFO pPortList);
//PUSBMON_PORT_INFO pGetNewPortNode(PUSBMON_PORT_INFO *ppListHead);
LONG WriteNewAssociations(int *iNumberOfPorts,PUSBMON_PORT_INFO pPortList,HKEY hPortRoot);
void FreePrinterList(PUSBMON_PRINTER_INFO pPrinterList);
LONG BuildReturnTable(int iNumberOfPorts,PUSBMON_PORT_INFO pPortList,DWORD Level,LPBYTE Ports,DWORD cBuf,LPDWORD pcbNeeded,LPDWORD pcReturned);
char szDebugBuff[512];
char *WtoA(WCHAR *pInString);
long lAddPrinterToList(PUSBMON_PORT_INFO *ppHead,HDEVINFO hDeviceList,PSP_DEVICE_INTERFACE_DATA prDeviceInfo,PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,PUSBMON_BASENAME *ppBaseNames);
int iCountPresentPrinters(PUSBMON_PORT_INFO pHead);
LONG lGetPrintersAndPorts(PUSBMON_PORT_INFO *ppHead,PUSBMON_BASENAME *);
LONG lGetQueues(PUSBMON_QUEUE_INFO *ppQueueList,PUSBMON_BASENAME pBaseNames);
LONG lAddQueueToList(LPWSTR pPortName,LPWSTR pPrinterName,PUSBMON_QUEUE_INFO *ppQueueHead);
void vDestroyQueueList(PUSBMON_QUEUE_INFO pQueueList);
void vCleanUpQueuesAndPorts(PUSBMON_PORT_INFO  * pPortInfo,int iNumberOfPorts,PUSBMON_BASENAME pBaseNames);
DWORD WINAPI CleanupThread(LPVOID pParam);
void vEliminateOldQueuesAndPorts(PUSBMON_QUEUE_INFO pQueueInfo,PUSBMON_PORT_INFO * fpPortInfo);
void vDeletePort(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList);
void vGreyOutQueue(PUSBMON_QUEUE_INFO pQueue);
void vUnGreyQueue(PUSBMON_QUEUE_INFO pQueue);
HANDLE hGetPortRegKey(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList);
void vAddNameToBaseNameList(PUSBMON_BASENAME *ppBaseNames,WCHAR *wcPortBaseName);
BOOL bCheckPortName(LPTSTR pPortName,PUSBMON_BASENAME pBaseNames);
int iGetNumberOfPorts(PUSBMON_PORT_INFO pHead);


int iCleanupThreads=0;
HKEY hPortsKeyG; //global
PUSBMON_PORT_INFO pPortInfoG=NULL;
int iLastPrintersHere=-1;



typedef struct CLEANUP_THREAD_PARAMS_DEF
{
	PUSBMON_PORT_INFO * ppPortInfo;
	PUSBMON_BASENAME pBaseNames;
	int iPortCount;
	HANDLE hSemaphore;
} CLEANUP_THREAD_PARAMS,*PCLEANUP_THREAD_PARAMS;



BOOL WINAPI USBMON_EnumPorts(LPWSTR pName, DWORD Level, LPBYTE  pPorts, DWORD cbBuf,LPDWORD pcbNeeded, LPDWORD pcReturned)
{
	PUSBMON_PRINTER_INFO pPrinterList;
	LONG lResult;
	DWORD dwStatus;
	int iNumberOfPorts;
	static int iOldNumberOfPorts=0;
	static int iNumCalls=0;
	int iThisCall;
	int iPrintersHere;
	

	OutputDebugStringD2("USBMON ++=Head of EnumPorts, before WaitForSingleObject\n");
	iThisCall=++iNumCalls;
	wsprintfA(szDebugBuff,"USBMON:  +++++++++++++++++++++++++++++++++++++++++++++++++EnumPorts call # %d, handle = %x\n",iThisCall,hMonitorSemaphore);
	OutputDebugStringD2(szDebugBuff);	
	dwStatus=WaitForSingleObject(hMonitorSemaphore,INFINITE);
	if(dwStatus==WAIT_FAILED)
	{
    OutputDebugStringD1("USBMON: WaitForSingleObject failed!\n");
	}
	wsprintfA(szDebugBuff,"USBMON Head of EnumPrts, ++++++++++++++++++++++++++++++++++++ Instance # %d, after WaitForSingleObject, return code=%d\n",iThisCall,dwStatus);
	OutputDebugStringD2(szDebugBuff);

	
	lResult=lGetPrintersAndPorts(&pPortInfoG,&GpBaseNameList);
	iNumberOfPorts=iGetNumberOfPorts(pPortInfoG);
	
	  if(iCleanupThreads==0)
		{
		  iPrintersHere=iCountPresentPrinters(pPortInfoG);
		  if(iPrintersHere!=iLastPrintersHere)
		  {
		  	iLastPrintersHere=iPrintersHere;
			iCleanupThreads++;
			OutputDebugStringD3("USBMON: About to clean up queues and ports\n");

 			vCleanUpQueuesAndPorts(&pPortInfoG,iNumberOfPorts,GpBaseNameList);	

		  } //end printer count changed
		}
  

	lResult=BuildReturnTable(iNumberOfPorts,pPortInfoG,Level,pPorts,cbBuf,pcbNeeded,pcReturned);
	
	if(lResult!=ERROR_SUCCESS)
	{
		OutputDebugStringD2("USBMON: Unable to build return buffer (this is normal for first call)\n");
		goto EnumPortsError;
	}
	
  OutputDebugStringD3("USBMON tail of EnumPorts, before ReleaseSemaphore\n");

  ReleaseSemaphore(hMonitorSemaphore,1,NULL);	
	return TRUE;
EnumPortsError:
	wsprintfA(szDebugBuff,"USBMON tail of EnumPorts, error path, before ReleaseSemaphore, *pcbNeeded=%d\n",*pcbNeeded);
	OutputDebugStringD3(szDebugBuff);


	if(!ReleaseSemaphore(hMonitorSemaphore,1,NULL))
	{
		  wsprintfA(szDebugBuff,"USBMON: EnumPorts Release sempahore failed for instance %d \n",iThisCall);
		  OutputDebugStringD1(szDebugBuff);
	}
	else
	{
		  wsprintfA(szDebugBuff,"USBMON: EnumPortsRelease sempahore succeeded for instance %d \n",iThisCall);
		  OutputDebugStringD2(szDebugBuff);
	}
	SetLastError(ERROR_INSUFFICIENT_BUFFER);
	return FALSE;
} /*End EnumPorts*/


int iGetNumberOfPorts(PUSBMON_PORT_INFO pHead)
{
	PUSBMON_PORT_INFO pWalk;
	int iCount=0;

	pWalk=pHead;
	while(pWalk!=NULL)
	{
		iCount++;
		pWalk=pWalk->pNext;
	}/*end while*/
    return iCount;
} /*end function iGetNumberOfPorts*/

/***********************************
 * lGetQueues
 *
 * This function builds a linked list of print queues
 * who's port names start with a registered basename.
 *
 * This list is used to grey out queues who's printers are 
 * Unavailable, and to delete ports who's printers are gone
 ************************************************************/
LONG lGetQueues(PUSBMON_QUEUE_INFO *ppQueueList,PUSBMON_BASENAME pBaseNames)
{
  DWORD dwBufferSize=1024;
	DWORD dwBufferNeeded=0;
	DWORD dwNumStructs;
	LPBYTE lpBuffer;
	BOOL bStatus;
	DWORD dwLoop;
	PRINTER_INFO_5 *pEnumInfo;
	LONG lStatus;

	OutputDebugStringD2("USBMON: Head of lGetQueues \n");
	lpBuffer=(LPBYTE)GlobalAlloc(0,dwBufferSize);
	if(lpBuffer==NULL)
	{
  	OutputDebugStringD1("USBMON: Unable to allocate memory in lGetQueues\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	OutputDebugStringD3("USBMON: Before EnumPrinters \n");

	bStatus=EnumPrinters(PRINTER_ENUM_LOCAL,NULL,5,lpBuffer,dwBufferSize,&dwBufferNeeded,&dwNumStructs);

	OutputDebugStringD3("USBMON: After EnumPrinters \n");
	if(dwBufferNeeded>dwBufferSize)
	{
		dwBufferSize=dwBufferNeeded;
		lpBuffer=GlobalReAlloc(lpBuffer,dwBufferSize,0);
		if(lpBuffer==NULL)
		{
  	  OutputDebugStringD1("USBMON: Unable to re-allocate memory in lGetQueues\n");
		  return ERROR_NOT_ENOUGH_MEMORY;
		}
		OutputDebugStringD3("USBMON: Before EnumPrinters2 \n");
		bStatus=EnumPrinters(PRINTER_ENUM_LOCAL,NULL,5,lpBuffer,dwBufferSize,&dwBufferNeeded,&dwNumStructs);
		OutputDebugStringD3("USBMON: After EnumPrinters2 \n");
	} 
	if(bStatus==FALSE)
	{
		OutputDebugStringD1("USBMON: lGetQueues: EnumPrinters failed\n");
		return GetLastError();
	}
  OutputDebugStringD3("USBMON: lGetQueues: Before for loop \n");	
	pEnumInfo=(PRINTER_INFO_5 *)lpBuffer;
	for(dwLoop=0;dwLoop<dwNumStructs;dwLoop++)
	{
		OutputDebugStringD3("USBMON: lGetQueues: Head of for loop \n");
		if(pEnumInfo->pPortName!=NULL)
		{
			OutputDebugStringD2("USBMON: lGetQueues: Valid port name \n");
//		  if(wcsncmp(pEnumInfo->pPortName,PORT_NAME_BASE,wcslen(PORT_NAME_BASE))==0)
		  if(bCheckPortName(pEnumInfo->pPortName,pBaseNames))
			{
			  OutputDebugStringD3("USBMON: lGetQueues: Valid port name, that starts with registered base name, add it to list \n");
			  lStatus=lAddQueueToList(pEnumInfo->pPortName,pEnumInfo->pPrinterName,ppQueueList);
			  if(lStatus!=ERROR_SUCCESS)
				{
				  GlobalFree(lpBuffer);
				  return lStatus;
				}
			} /*end if found a USB print queue*/
		} /*end if pPortName not NULL*/
		pEnumInfo++;
	}	/*end for loop*/
	GlobalFree(lpBuffer);
  return ERROR_SUCCESS;
} /*end function lGetQueues*/



BOOL bCheckPortName(LPTSTR pPortName,PUSBMON_BASENAME pBaseNames)
{
	BOOL bFound=FALSE;
	PUSBMON_BASENAME pWalk;

	OutputDebugStringD3("USBMON: Head of bCheckPortName\n");
	pWalk=pBaseNames;
    while((pWalk!=NULL)&&(!bFound))
	{
		
	    wsprintf((WCHAR *)szDebugBuff,L"USBMON:   PortBaseName==%s\n",pWalk->wcBaseName);
	    OutputDebugStringWD3((WCHAR *)szDebugBuff);						 

		if(wcsncmp(pPortName,pWalk->wcBaseName,wcslen(pWalk->wcBaseName))==0)
		{
			bFound=TRUE;
		}
		else
		{
			pWalk=pWalk->pNext;
		}
	} /*end while not found*/
	return bFound;
} /*end function bCheckPortName*/





LONG lAddQueueToList(LPWSTR pPortName,LPWSTR pPrinterName,PUSBMON_QUEUE_INFO *ppQueueHead)
{
	PUSBMON_QUEUE_INFO pNew,pWalk;
	BOOL bFound;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Head of lAddQueueToList, about to add queue with port %s\n",pPortName);
	OutputDebugStringWD3((WCHAR *)szDebugBuff);


	pNew=(PUSBMON_QUEUE_INFO)GlobalAlloc(0,sizeof(USBMON_QUEUE_INFO));
	if(pNew==NULL)
	{
	  OutputDebugStringD1("USBMON: vAddQueueToList, Out of memory\n");	
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	wcscpy(pNew->wcPortName,pPortName);
	if(pPrinterName!=NULL)
	  wcscpy(pNew->wcPrinterName,pPrinterName);
	else
		pNew->wcPrinterName[0]=L'\0';

	if(*ppQueueHead==NULL)
	{
		*ppQueueHead=pNew;
		pNew->pNext=NULL;
	}
	else if(lstrcmp(pNew->wcPortName,(*ppQueueHead)->wcPortName)<0)
	{
		pNew->pNext=*ppQueueHead;
		*ppQueueHead=pNew;
	}
	else
	{
		pWalk=*ppQueueHead;
		bFound=FALSE;
		while((!bFound)&&(pWalk->pNext!=NULL))
		{
			if(lstrcmp(pNew->wcPortName,pWalk->pNext->wcPortName)<0)
				bFound=TRUE;
			else
				pWalk=pWalk->pNext;
		}
		pNew->pNext=pWalk->pNext;
		pWalk->pNext=pNew;
	} /*end else, we need to walk the list*/
  return ERROR_SUCCESS;
} /*end function vAddQueueToList*/

void vDestroyQueueList(PUSBMON_QUEUE_INFO pQueueList)
{
	PUSBMON_QUEUE_INFO pWalk,pLast;
	
	pWalk=pQueueList;
	while(pWalk!=NULL)
	{
		pLast=pWalk;
		pWalk=pWalk->pNext;
		GlobalFree(pLast);
	} /*end while pWalk!=NULL*/
} /*end function vDestroyQueueList*/



LONG BuildReturnTable(int iNumberOfPorts,        // Internal variable, 
					  PUSBMON_PORT_INFO pPortList,// List of ports
					  DWORD Level,               // IN  specifies structure type to return
					  LPBYTE Ports,              // OUT Buffer to write to
					  DWORD cBuf,                // IN  size of buffer provided
					  LPDWORD pcbNeeded,         // OUT specifies bytes written to buffer, or the size the buffer should have been if it's to small
					  LPDWORD pcReturned)        // OUT specifies the number of structures (ports) stored in the buffer
{
	PORT_INFO_1 *pInfo1;
	PORT_INFO_2 *pInfo2;

	VOID *pNextStruct;
	WCHAR *pszNextString;

	
	int iNodeSize;
	LONG lResult;
	unsigned int iStringsSize;
	unsigned int iStaticSize; //size of "overhead" strings that are only created once for all ports
	
	unsigned int iAllStructsSize;
	unsigned int iAllStringsSize;	 
	unsigned int iTotalSize;
	PUSBMON_PORT_INFO pPortWalk;
	
    OutputDebugStringD2("USBMON: Head of BuildReturnTable\n"); 
	wsprintfA(szDebugBuff,"USBMON: iNumberOfPorts==%d, iLevel=%d\n",iNumberOfPorts,Level);
	OutputDebugStringD3(szDebugBuff);
	if(Level==1)
	{
		iNodeSize=sizeof(PORT_INFO_1);
		iStringsSize=MAX_PORT_LEN*2;
		iStaticSize=0;
	}
	else if(Level==2)
	{
		iNodeSize=sizeof(PORT_INFO_2);
		iStaticSize=(wcslen(MONITOR_NAME)+1)*2;
		iStringsSize=(MAX_PORT_LEN*2)+(MAX_PORT_DESC_LEN*2)+iStaticSize;
		
	}
	else
	{
		OutputDebugStringD1("USBMON: Unsupported structure level in BuildReturnTable\n");
		lResult=ERROR_INVALID_LEVEL; 
		goto BuildTableError;
	} /*end else it's a level we don't support*/
	iAllStructsSize=iNodeSize*iNumberOfPorts;
	iAllStringsSize=iStringsSize*iNumberOfPorts;
	iTotalSize=iAllStructsSize+iAllStringsSize;
	wsprintfA(szDebugBuff,"USBMON: spooler gave us a %lu byte buffer at %X, we need a %lu byte buffer\n",cBuf,Ports,iTotalSize);
	OutputDebugStringD3(szDebugBuff);
	*pcbNeeded=iTotalSize;
	if(iTotalSize>cBuf)
	{
		OutputDebugStringD3("USBMON: Buffer provided by spooler is not large enough\n");
		lResult=ERROR_INSUFFICIENT_BUFFER; 
	
		goto BuildTableError;

	}
	pNextStruct=(VOID *)Ports;
	pszNextString=(WCHAR *)(Ports+cBuf-iAllStringsSize); //ports+cbuff == end of the buffer, - iAllStringsSize == start of the strings
//	if(Level==2)
//	{
//		pszMonitorName=(WCHAR *)pszNextString;
//		wcscpy(pszMonitorName,MONITOR_NAME);
//		pszNextString+=(iStaticSize);
//	}
	pPortWalk=pPortList;
	if(iNumberOfPorts>0)
	  while(pPortWalk!=NULL)
	  {
		
		if(Level==1)
		{
			

			pInfo1=(PORT_INFO_1 *)pNextStruct;
			pInfo1->pName=pszNextString;  //crashing line
			
			wcscpy((WCHAR *)(pInfo1->pName),pPortWalk->szPortName);
			pszNextString+=(MAX_PORT_LEN);
			
			
						
		} /*end if level == 1*/
		else				 
		{
			OutputDebugStringD2("USBMON: Head of build PORT_INFO 2\n"); //yy
			pInfo2=(PORT_INFO_2 *)pNextStruct;
			pInfo2->pPortName=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pPortName),pPortWalk->szPortName);
			pszNextString+=(MAX_PORT_LEN);
			pInfo2->pDescription=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pDescription),pPortWalk->szPortDescription);
			pszNextString+=MAX_PORT_DESC_LEN;
			pInfo2->pMonitorName=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pMonitorName),MONITOR_NAME);
			pszNextString+=(iStaticSize/2); //iStaticSize is bytes, pszNextString in WCHARs
			pInfo2->Reserved=0;
			pInfo2->fPortType=PORT_TYPE_WRITE; 
			wsprintfW((WCHAR *)szDebugBuff,L"pInfo2=0x%x\n",pInfo2);
			OutputDebugStringWD3((WCHAR *)szDebugBuff);
			wsprintfW((WCHAR *)szDebugBuff,L"USBMON in BuildBuff, PortName=%s|\n, Description=%s|\n, MonitorName=%s|\n",pInfo2->pPortName,pInfo2->pDescription,pInfo2->pMonitorName);
			OutputDebugStringWD3((WCHAR *)szDebugBuff);
			wsprintfW((WCHAR *)szDebugBuff,L"USBMON in BuildBuff, PortName=0x%x\n, Description=0x%x\n, MonitorName=0x%x\n",pInfo2->pPortName,pInfo2->pDescription,pInfo2->pMonitorName);
			OutputDebugStringWD3((WCHAR *)szDebugBuff); //yy
			
		} /*else level == 2*/
		((PBYTE)pNextStruct)+=iNodeSize;
		pPortWalk=pPortWalk->pNext;
	  } /*end while iLoop*/
	*pcReturned=iNumberOfPorts;
	return ERROR_SUCCESS;
BuildTableError:
	return lResult;
}	/*end function BuildReturnTable*/


void FreePrinterList(PUSBMON_PRINTER_INFO pPrinterList)
{
	PUSBMON_PRINTER_INFO pWalk,pNext;

	pWalk=pPrinterList;
	while(pWalk!=NULL)
	{
		pNext=pWalk->pNext;
		GlobalFree(pWalk);
		pWalk=pNext;
	}
} /*end function vFreePrinterList*/


int iCountPresentPrinters(PUSBMON_PORT_INFO pHead)
{
  int iReturn=0;
  PUSBMON_PORT_INFO pWalk;
  pWalk=pHead;
  OutputDebugStringD3("USBMON:   ************************************* Head of iCountPresentPrinters\n");
  while(pWalk!=NULL)
  {
		if((pWalk->dwDeviceFlags)&SPINT_ACTIVE)
  	  iReturn++;
	  pWalk=pWalk->pNext;
  }
  return iReturn;
} /*end function iCountPrinters*/
		 

/*******************************************************
 * FUNCTION: pGetPrintersAndPorts
 *   Uses SetupDi calls to obtain list of USB printers   
 *   present in the system, and reads the port name
 *   of the printer from the registry.  This function
 *   replaces pGetPrinterList, UpdateAssociations,
 *   AllocateNewPorts, DoBestEffortMatches, and 
 *   ReattachExactMatches
 *
 *   This function is called initially with a null pointer
 *   And is then called again on each EnumPorts
 * PARAMETERS:
 *   PUSBMON_PORT_INFO *ppHead
 *     Pointer to the head pointer of the list to by modified
 *     or Created
 * RETURN:
 *   status code
 ********************************************************/

LONG lGetPrintersAndPorts(PUSBMON_PORT_INFO *ppHead,PUSBMON_BASENAME *ppBaseNames)
{
    int iLoop;
	LONG lStatus;
	HDEVINFO hDeviceList;
	SP_DEVICE_INTERFACE_DATA rDeviceInfo;
	PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail;
		GUID *pPrinterGuid;
	BOOL bMoreDevices;
	DWORD dwRequiredSize;
	PUSBMON_PRINTER_INFO pPrinterList=NULL,pNew;
	HKEY hDeviceKey;
	DWORD dwError = ERROR_SUCCESS;
	

	OutputDebugStringD2("USBMON: Head of pGetPrinterAndPortList\n");
	pPrinterGuid=(GUID *)&USB_PRINTER_GUID;
    OutputDebugStringD3("USBMON: before SetupDiGetClassDevs\n");
	hDeviceList=SetupDiGetClassDevs(pPrinterGuid,NULL,NULL,DIGCF_INTERFACEDEVICE);
	OutputDebugStringD3("USBMON: after SetupDiGetClassDevs\n");
									

	if(hDeviceList==INVALID_HANDLE_VALUE)
	{
        dwError = GetLastError();
		OutputDebugStringD1("USBMON: SetupDiGetClassDevs failed\n");
		goto SetupDiPrinterAndPortError;
	}
	else
	{	
		iLoop=0;
		rDeviceInfo.cbSize=sizeof(rDeviceInfo);
		bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,iLoop,&rDeviceInfo);
		wsprintfA(szDebugBuff,"USBMON: SetupDiEnumDeviceInterfaces, data.flags=%u\n",rDeviceInfo.Flags);
	    OutputDebugStringD3(szDebugBuff);
		while(bMoreDevices)
		{
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,NULL,0,&dwRequiredSize,NULL))
		  {
			  dwError=GetLastError();
			  wsprintfA(szDebugBuff,"USBMON: SetupDiGetDeviceInterfaceDetail first call failed, error=%x\n",dwError);
			  OutputDebugStringD3(szDebugBuff);
//			  goto SetupDiPrinterAndPortError;  //the first call is just to get this size, so of course it should fail.  Don't goto anywhere
		  }
	 	  pDeviceDetail=(PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(0,dwRequiredSize);
		  if(pDeviceDetail==NULL)
		  {
		      OutputDebugStringD1("USBMON: Unable to allocate memory in pGetPrinterList\n");
			  SetupDiDestroyDeviceInfoList(hDeviceList);
              dwError = ERROR_NOT_ENOUGH_MEMORY;
			  goto SetupDiPrinterAndPortError;
		  }
		  pDeviceDetail->cbSize=sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,pDeviceDetail,dwRequiredSize,&dwRequiredSize,NULL))
		  {
              dwError = GetLastError();
			  OutputDebugStringD1("USBMON: SetupDiGetDeviceInterfaceDetail (second call) failed\n");
			  SetupDiDestroyDeviceInfoList(hDeviceList);
			  goto SetupDiPrinterAndPortError;
		  }
		  else
			  OutputDebugStringD3("USBMON: SetupDiGetDeviceInterfaceDetail (second call) OK\n");

		  lStatus=lAddPrinterToList(ppHead,hDeviceList,&rDeviceInfo,pDeviceDetail,ppBaseNames);
		  GlobalFree(pDeviceDetail);
		  OutputDebugStringD3("USBMON: Before end of loop SetupDiEnumDeviceInterfaces\n"); //yy
		  bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,++iLoop,&rDeviceInfo);
  		  wsprintfA(szDebugBuff,"USBMON: SetupDiEnumDeviceInterfaces, data.flags=%u\n",rDeviceInfo.Flags);
	      OutputDebugStringD3(szDebugBuff);

		} /*end while more devices*/
	   SetupDiDestroyDeviceInfoList(hDeviceList);
	   return STATUS_SUCCESS;
	} /*end else*/
SetupDiPrinterAndPortError:;
    if ( dwError == ERROR_SUCCESS )
        dwError = ERROR_INVALID_DATA;
	    OutputDebugStringD1("USBMON: Erroring out of pGetPrinterList\n");
		return dwError;
} /*end function lGetPrintersAndPorts*/


long lAddPrinterToList(PUSBMON_PORT_INFO *ppHead,HDEVINFO hDeviceList,SP_DEVICE_INTERFACE_DATA * prDeviceInfo,PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,PUSBMON_BASENAME *ppBaseNames)
{
  PUSBMON_PORT_INFO pWalk,pTemp,pNew = NULL;
  BOOL bFound=FALSE;
  HANDLE hDeviceKey = INVALID_HANDLE_VALUE;
  DWORD dwPortNumberSize;
  WCHAR wcPortName[MAX_PORT_LEN+1];
  WCHAR wcPortBaseName[MAX_PORT_LEN]; //arbitrary size, bigger than it needs to be
  DWORD dwPortNumber,dwStringSize;
  DWORD dwReturn = ERROR_SUCCESS;
  int iResult;

  pWalk=*ppHead;
  while((pWalk!=NULL)&&(!bFound))
  {
	if(lstrcmp(pWalk->DevicePath,pDeviceDetail->DevicePath)==0)
	  bFound=TRUE;
	else
	  pWalk=pWalk->pNext;
  }
  
  if(pWalk!=NULL) //it's not a new node
	{
	    if((!((pWalk->dwDeviceFlags)&SPINT_ACTIVE))  && ((prDeviceInfo->Flags)&SPINT_ACTIVE)) //If we just became active
		{
	      hDeviceKey=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,prDeviceInfo,0,KEY_ALL_ACCESS);
	      if(hDeviceKey==INVALID_HANDLE_VALUE)
		  {
	        OutputDebugStringD1("USBMON: reactivation: SetupDiOpenDeviceInterfaceRegKey failed\n");
	        return ERROR_ACCESS_DENIED;
		  }
		  RegDeleteValue(hDeviceKey,L"recyclable");
          dwStringSize = sizeof(pWalk->szPortDescription);
    	  if(RegQueryValueEx(hDeviceKey,L"Port Description",0,NULL,(LPBYTE)(pWalk->szPortDescription),&dwStringSize)!=ERROR_SUCCESS)
		  {
		    OutputDebugStringD2("USBMON: RegQueryValueEx, get \"Port Description\" in lAddPrinterToList (refresh) failed, defaulting to \"Virtual printer port for USB\"\n");
            wcscpy(pWalk->szPortDescription,L"Virtual printer port for USB");
		  }
		  
 	      RegCloseKey(hDeviceKey);
          hDeviceKey=INVALID_HANDLE_VALUE;
		}	 /*end if re-activated port*/
		pWalk->dwDeviceFlags=prDeviceInfo->Flags; //even if we don't need to reload the whole device detail, we need to recheck the flags
  	}
	else
	{
	  pNew=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
	  if(pNew==NULL)
	    return ERROR_NOT_ENOUGH_MEMORY;
      wcscpy(pNew->DevicePath,pDeviceDetail->DevicePath);
	  pNew->iRefCount=0;
	  hDeviceKey=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,prDeviceInfo,0,KEY_ALL_ACCESS);
	  if(hDeviceKey==INVALID_HANDLE_VALUE)
	  {
        dwReturn = GetLastError();
	    OutputDebugStringD1("USBMON: SetupDiOpenDeviceInterfaceRegKey failed\n");
        goto Done;
	  }
	  dwPortNumberSize=sizeof(dwPortNumber);
      dwReturn = RegQueryValueEx(hDeviceKey,L"Port Number",0,NULL,(LPBYTE)&dwPortNumber, &dwPortNumberSize);
      if ( dwReturn != ERROR_SUCCESS )
	  {
	    OutputDebugStringD2("USBMON: RegQueryValueEx get \"Port Number\" in lAddPrinterToList failed\n");
        goto Done;
	  }
	  dwStringSize=sizeof(wcPortBaseName);
	  if(RegQueryValueEx(hDeviceKey,L"Base Name",0,NULL,(LPBYTE)wcPortBaseName,&dwStringSize)!=ERROR_SUCCESS)
	  {
		OutputDebugStringD2("USBMON: RegQueryValueEx, get \"Base Name\" in lAddPrinterToList failed, defaulting to USB\n");
        wcscpy(wcPortBaseName,L"USB");
	  }
	  vAddNameToBaseNameList(ppBaseNames,wcPortBaseName);
	  dwStringSize=sizeof(pNew->szPortDescription);
  	  dwReturn=RegQueryValueEx(hDeviceKey,L"Port Description",0,NULL,(LPBYTE)(pNew->szPortDescription),&dwStringSize);
	
	  if(dwReturn!=ERROR_SUCCESS)
	  {
	 	wsprintfA(szDebugBuff,"USBMON:  RegQueryValueEx returned (signed) %d, (unsigned) %u\n",dwReturn,dwReturn);
	    OutputDebugStringD2(szDebugBuff);						 

		OutputDebugStringD2("USBMON: *************************************************RegQueryValueEx, get \"Port Description\" in lAddPrinterToList failed, defaulting to \"Virtual printer port for USB\"\n");
        wcscpy(pNew->szPortDescription,L"Virtual printer port for USB");

	  }
	  else
	  {
		  OutputDebugStringD2("USBMON: *****************************************RegQueryValueEx on baseName OK\n");
	  }
	
	  wsprintf(wcPortName,L"%s%03u",wcPortBaseName,dwPortNumber);
	  OutputDebugStringD3("USBMON: computed port name ==");
	  OutputDebugStringWD3(wcPortName);
	  wcscpy(pNew->szPortName,wcPortName);
	  pNew->dwDeviceFlags=prDeviceInfo->Flags;
	  if((pNew->dwDeviceFlags)&SPINT_ACTIVE)
		  RegDeleteValue(hDeviceKey,L"recyclable");


	  OutputDebugStringD3("USBMON: AddPrinterToList Start of insertion\n");
	  pWalk=*ppHead;
	  if(pWalk==NULL)
		{
	    *ppHead=pNew;
	    pNew->pNext=NULL;
        pNew = NULL;
		}
	  else if(lstrcmp(pNew->szPortName,pWalk->szPortName)<0)
	  {
	    OutputDebugStringD3("USBMON: AddPrinterToList New Head\n");
	    pNew->pNext=*ppHead;
	    (*ppHead)=pNew;
        pNew = NULL;
	  }
	  else if(lstrcmp(pNew->szPortName,pWalk->szPortName)==0)
	  {
		  pNew->pNext=(*ppHead)->pNext;
		  (*ppHead)=pNew;
 		  GlobalFree(pWalk);
          pNew = NULL;
	  }
	  else
	  {
	    if(pWalk->pNext!=NULL)
		{
	      iResult=lstrcmp(pNew->szPortName,pWalk->pNext->szPortName);
		}
	    while((iResult>0)&&(pWalk->pNext!=NULL))
		{	
		    pWalk=pWalk->pNext;
		    if(pWalk->pNext!=NULL)
			{
		      iResult=lstrcmp(pNew->szPortName,pWalk->pNext->szPortName);
			}
		} /*end while*/
		if(pWalk->pNext!=NULL)
			if(iResult==0) //they match
			{
				pTemp=pWalk->pNext;
				pWalk->pNext=pWalk->pNext->pNext;
				GlobalFree(pTemp);

			}
	    pNew->pNext=pWalk->pNext;
	    pWalk->pNext=pNew;
        pNew = NULL;
	} /*end else*/
  } /*end else pWalk==NULL, therefore it's a new node*/

  dwReturn = ERROR_SUCCESS;
Done:
    if ( pNew )
        GlobalFree(pNew);

    if ( hDeviceKey != INVALID_HANDLE_VALUE )
	  RegCloseKey(hDeviceKey);
  return dwReturn;
} /*end function lAddPrinterToList*/


void vAddNameToBaseNameList(PUSBMON_BASENAME *ppBaseNames,WCHAR *wcPortBaseName)
{
	BOOL bFound;
	PUSBMON_BASENAME pWalk,pNew;

	pWalk=*ppBaseNames;
	bFound=FALSE;
	while((pWalk!=NULL)&&(!bFound))
	{
		if(wcscmp(pWalk->wcBaseName,wcPortBaseName)==0)
			bFound=TRUE;
    	pWalk=pWalk->pNext;	
	} /*end while more items*/
	if(!bFound)
	{
		pWalk=*ppBaseNames;
		pNew=GlobalAlloc(0,sizeof(USBMON_BASENAME));
		if(pNew==NULL)
			return;
		wcscpy(pNew->wcBaseName,wcPortBaseName);
		if(*ppBaseNames==NULL)
		{
			*ppBaseNames=pNew;
			pNew->pNext=NULL;
		}
		else if(wcscmp(pNew->wcBaseName,pWalk->wcBaseName)<0)
		{
			pNew->pNext=*ppBaseNames;
			*ppBaseNames=pNew;
		}
		else
		{
		  while((!bFound)&&(pWalk->pNext!=NULL))
		  {
			if(wcscmp(pNew->wcBaseName,pWalk->pNext->wcBaseName)>0)
				bFound=TRUE;
			else
				pWalk=pWalk->pNext;
		  }
		  pNew->pNext=pWalk->pNext;
		  pWalk->pNext=pNew;
		} /*end else we need to insert it (not new head)*/
	} /*end if need to add*/
}	 /*end function vAddNameToBaseNameList*/



char *WtoA(WCHAR *pInString)
{
	static char szDest[256];
	char *pSourceWalk;
	char *pszDestWalk;

	pszDestWalk=szDest;
	pSourceWalk=(char *)pInString;
	while(*pSourceWalk!='\0')
	{
		*(pszDestWalk++)=*pSourceWalk;
		pSourceWalk+=2;
	}
	(*pszDestWalk)='\0';
	wsprintfA(szDebugBuff,"USBMON, WtoA, About to return %s\n",szDest);
	OutputDebugStringD3(szDebugBuff); //yy
	return szDest;
}

 
void vCleanUpQueuesAndPorts(PUSBMON_PORT_INFO * ppPortInfo,int iNumberOfPorts,PUSBMON_BASENAME pBaseNames)
{		
	DWORD dwThreadID;
	PCLEANUP_THREAD_PARAMS pCleanupParams;

	pCleanupParams=(PCLEANUP_THREAD_PARAMS)GlobalAlloc(0,sizeof(CLEANUP_THREAD_PARAMS));
	if(pCleanupParams==NULL)
	{
			OutputDebugStringD1("USBMON: failed to allocate memory in vCleanupQueuesAndPorts\n");
    	return;
	}
	pCleanupParams->ppPortInfo=ppPortInfo;
	pCleanupParams->iPortCount=iNumberOfPorts;
	pCleanupParams->hSemaphore=hMonitorSemaphore;
	pCleanupParams->pBaseNames=pBaseNames;
	CreateThread(NULL,0,CleanupThread,pCleanupParams,0,&dwThreadID);
}

DWORD WINAPI CleanupThread(LPVOID pParam)
{
	PCLEANUP_THREAD_PARAMS pParams;
	PUSBMON_QUEUE_INFO pQueueList;
	DWORD dwStatus;
		
	pParams=(PCLEANUP_THREAD_PARAMS)pParam;
	pQueueList=NULL;
	lGetQueues(&pQueueList,pParams->pBaseNames);
	if(pQueueList==NULL)
	{
	  OutputDebugStringD3("USBMON:  CleanupThread, pQueueList==NULL\n");
	}
	else
	{
	  OutputDebugStringD3("USBMON:  CleanupThread, pQueueList!=NULL\n");
	}
	wsprintfA(szDebugBuff,"USBMON:+++++++++++++++++++++++++++++++++++++++ Head of CleanupThread, before WaitForSingleObject, hMonitorSemaphore=%x\n",hMonitorSemaphore);
	OutputDebugStringD2(szDebugBuff);
	dwStatus=WaitForSingleObject(hMonitorSemaphore,INFINITE);
	if(dwStatus==WAIT_FAILED)
	  OutputDebugStringD1("USBMON: WaitForSingleObject failed!\n");
	wsprintfA(szDebugBuff,"USBMON: CleanupThread: WaitForSingleObject returned %d\n",dwStatus);
	OutputDebugStringD3(szDebugBuff);
	OutputDebugStringD2("USBMON: Head of CleanupThread, after WaitForSingleObject\n");
	vEliminateOldQueuesAndPorts(pQueueList,pParams->ppPortInfo);
	vDestroyQueueList(pQueueList);
	GlobalFree(pParams);
  OutputDebugStringD2("USBMON: tail of CleanupThread, about to release semaphore++++++++++++++++++++++++++++++++++++++++++++\n");
	iCleanupThreads--;
	ReleaseSemaphore(hMonitorSemaphore,1,NULL);
	return 0;
}

void vEliminateOldQueuesAndPorts(PUSBMON_QUEUE_INFO pQueueInfo,PUSBMON_PORT_INFO * ppPortHead)
{
	PUSBMON_QUEUE_INFO pQueueWalk;
	PUSBMON_PORT_INFO pPortWalk;
    HDEVINFO            hDevInfo;
	int iCompare;
	BOOL bNull=FALSE;

	hDevInfo=SetupDiGetClassDevs((GUID *)&USB_PRINTER_GUID,NULL,NULL,DIGCF_INTERFACEDEVICE);
    if ( hDevInfo == INVALID_HANDLE_VALUE )
        return;

	pQueueWalk=pQueueInfo;
	pPortWalk= *ppPortHead;
	pPortWalk=*ppPortHead;
	if((pPortWalk!=NULL)&&(pQueueWalk!=NULL))
	{
	  iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
	  wsprintf((WCHAR *)szDebugBuff,L"USBMON:  About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
	  OutputDebugStringWD2((WCHAR *)szDebugBuff);
	}
	else
	  bNull=TRUE;
	while(!bNull)
	{
		//Walk through matching items loop
		while((iCompare==0)&&(!bNull))
		{
  		wsprintfA(szDebugBuff,"USBMON: in cleanup loop, flags=%d\n",pPortWalk->dwDeviceFlags);	
		  OutputDebugStringD2(szDebugBuff);

			if((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE)
			  vUnGreyQueue(pQueueWalk);
			else
				vGreyOutQueue(pQueueWalk);
			pPortWalk=pPortWalk->pNext;
			pQueueWalk=pQueueWalk->pNext;
			if((pPortWalk!=NULL)&&(pQueueWalk!=NULL))
			{
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			} /*end if no nulls*/
			else
				bNull=TRUE;
		} /*end while matching items*/

		// grey out "detached" printers loop
		while((iCompare>0)&&(!bNull))
		{
			
			OutputDebugStringD3("USBMON: About to grey out queue inside the \"grey queue\" inner loop\n");
			//vGreyOutQueue(pQueueWalk);  //perhaps something else should happen here.  What does it mean if a port is gone but the queue is still around?
		
			pQueueWalk=pQueueWalk->pNext;
			if(pQueueWalk!=NULL)
			{
				wsprintf((WCHAR *)szDebugBuff,L"USBMON: About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
            	OutputDebugStringWD2((WCHAR *)szDebugBuff);
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			}
			else
				bNull=TRUE;
		} /*end grey out loop*/

		// delete orphaned port names loop
		while((iCompare<0)&&(!bNull))
		{
			if(!((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE))
			  vDeletePort(pPortWalk, hDevInfo);
			pPortWalk=pPortWalk->pNext;
			if(pPortWalk!=NULL)
			{
				wsprintf((WCHAR *)szDebugBuff,L"USBMON: About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
            	OutputDebugStringWD2((WCHAR *)szDebugBuff);
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			}
			else
				bNull=TRUE;
		} /*end delete ports loop*/
	} /*end while both lists not null (outer loop)*/

	//grey out "detached" printers at end of list loop
	while(pQueueWalk!=NULL)
	{
		OutputDebugStringD2("USBMON:  About to grey out queue inside the \"grey queue\" cleanup loop\n");
		vGreyOutQueue(pQueueWalk); //perhaps something else should happen here.  What does it mean if a port is gone but the queue is still around?
		pQueueWalk=pQueueWalk->pNext;
	} //end end of list disable queues list

	//delete orphaned ports names at end of list loop
	while(pPortWalk!=NULL)
	{
		if(!((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE))
  		  vDeletePort(pPortWalk, hDevInfo);
		pPortWalk=pPortWalk->pNext;
	} //end end of list delete ports loop

    SetupDiDestroyDeviceInfoList(hDevInfo);
} /*end function vEliminateOldQueuesAndPorts*/

 
void vGreyOutQueue(PUSBMON_QUEUE_INFO pQueue)
{
#define SET_PRINTER_BUFFER_SIZE 1024
	HANDLE hPrinterHandle;
	PRINTER_DEFAULTS rPrinterDefaults;
	BYTE bPrinterInfo[SET_PRINTER_BUFFER_SIZE];
	int iSizeNeeded;
	PRINTER_INFO_5 *pPrinterInfo;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GreyOut Queue %s attached to %s\n",pQueue->wcPrinterName,pQueue->wcPortName);
	OutputDebugStringWD2((WCHAR *)szDebugBuff);

	rPrinterDefaults.pDatatype=NULL;
	rPrinterDefaults.pDevMode=NULL;
	rPrinterDefaults.DesiredAccess=PRINTER_ACCESS_ADMINISTER|STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL;
	if(!OpenPrinter(pQueue->wcPrinterName,&hPrinterHandle,&rPrinterDefaults))
		OutputDebugStringD1("USBMON: Unable to OpenPrinter in vGreyOutQueue\n");
	if(!GetPrinter(hPrinterHandle,5,bPrinterInfo,SET_PRINTER_BUFFER_SIZE,&iSizeNeeded))
	{
		wsprintfA(szDebugBuff,"USBMON:  GetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	if(iSizeNeeded>SET_PRINTER_BUFFER_SIZE)
		OutputDebugStringD1("USBMON:  Buffer size not big enough in vGreyOutQueue\n");	
	pPrinterInfo=(PRINTER_INFO_5 *)bPrinterInfo;
	(pPrinterInfo->Attributes)|=PRINTER_ATTRIBUTE_WORK_OFFLINE;
	OutputDebugStringD2("USBMON:  about to SetPrinter\n");	
	if(!SetPrinter(hPrinterHandle,5,bPrinterInfo,0))
	{
		wsprintfA(szDebugBuff,"USBMON:  SetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	ClosePrinter(hPrinterHandle);

} /*end function vGreyOutQueue*/

void vUnGreyQueue(PUSBMON_QUEUE_INFO pQueue)
{
	HANDLE hPrinterHandle;
	PRINTER_DEFAULTS rPrinterDefaults;
	BYTE bPrinterInfo[SET_PRINTER_BUFFER_SIZE];
	int iSizeNeeded;
	PRINTER_INFO_5 *pPrinterInfo;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UnGrey Queue %s attached to %s\n",pQueue->wcPrinterName,pQueue->wcPortName);
	OutputDebugStringWD3((WCHAR *)szDebugBuff);

	rPrinterDefaults.pDatatype=NULL;
	rPrinterDefaults.pDevMode=NULL;
	rPrinterDefaults.DesiredAccess=PRINTER_ACCESS_ADMINISTER|STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL;
	if(!OpenPrinter(pQueue->wcPrinterName,&hPrinterHandle,&rPrinterDefaults))
		OutputDebugStringD1("USBMON:  Unable to OpenPrinter in vGreyOutQueue\n");
	if(!GetPrinter(hPrinterHandle,5,bPrinterInfo,SET_PRINTER_BUFFER_SIZE,&iSizeNeeded))
	{
		wsprintfA(szDebugBuff,"USBMON:  GetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	if(iSizeNeeded>SET_PRINTER_BUFFER_SIZE)
		OutputDebugStringD1("USBMON:  Buffer size not big enough in vUnGreyQueue\n");	
	pPrinterInfo=(PRINTER_INFO_5 *)bPrinterInfo;
	(pPrinterInfo->Attributes)&=(~PRINTER_ATTRIBUTE_WORK_OFFLINE);
	OutputDebugStringD3("USBMON:  about to SetPrinter\n");	
	if(!SetPrinter(hPrinterHandle,5,bPrinterInfo,0))
	{
		wsprintfA(szDebugBuff,"USBMON:  SetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	ClosePrinter(hPrinterHandle);



} /*end function vUnGreyQueue*/

/*******************************************
 * vDletePort -- marks a port struct as    *
 * Deleted by setting it's device name to  *
 * Null and deleting the port name value   *
 * from the registry                       *
 *******************************************/
void vDeletePort(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList)
{
	HANDLE hDeviceKey;

//	 DebugBreak();

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: /********************Head of vDeletePort for %s.\n",pPort->szPortName);	
	OutputDebugStringWD2((WCHAR *)szDebugBuff);
	

	hDeviceKey=hGetPortRegKey(pPort, hDeviceList);
	if(hDeviceKey!=INVALID_HANDLE_VALUE)
	{
		wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Opened key for port %s.\n",pPort->szPortName);	
		OutputDebugStringWD3((WCHAR *)szDebugBuff);
//		if(RegDeleteValue(hDeviceKey,L"Port Number")==ERROR_SUCCESS)
        if(RegSetValueEx(hDeviceKey,L"recyclable",0,REG_NONE,0,0)==ERROR_SUCCESS)
		{
		  OutputDebugStringD3("USBMON: RegSetValue Success\n");
		}
		else
		{
		  OutputDebugStringD2("USBMON: RegSetValue Failure\n");
		}
	    RegCloseKey(hDeviceKey);
	} /*end if hGetProtRegKey worked*/
	else
	{
		wsprintfW((WCHAR *)szDebugBuff,L"USBMON:  Unable to locate and delete reg key for %s\n",pPort->szPortName);	
		OutputDebugStringWD1((WCHAR *)szDebugBuff);
	}
} /*end function vDeletePort*/


BOOL
MatchingRegKey(
    HKEY                hKey,
    PUSBMON_PORT_INFO   pPort
    )
{
    WCHAR wcBaseName[MAX_PORT_LEN];
	WCHAR wcPortName[MAX_PORT_LEN];
	DWORD dwPortNumber;
	DWORD dwReadSize;

    dwReadSize=sizeof(DWORD);
    if(RegQueryValueEx(hKey,L"Port Number",0,NULL,(LPBYTE)&dwPortNumber,&dwReadSize)==ERROR_SUCCESS)
    {
        dwReadSize=sizeof(wcBaseName);
		if(RegQueryValueEx(hKey,L"Base Name",0,NULL,(LPBYTE)wcBaseName,&dwReadSize)!=ERROR_SUCCESS)
		{
           OutputDebugStringD2("USBMON:  Unable to locate basename.  Defaulting to \"USB\"\n"); //yy
	wcscpy(wcBaseName,L"USB");
    }

    wsprintf(wcPortName,L"%s%03u",wcBaseName,dwPortNumber);
    return wcscmp(wcPortName,pPort->szPortName)==0;
    }

    return 0;
}


HANDLE hGetPortRegKey(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList)
{
	GUID *pPrinterGuid;
	int iLoop=0;
	SP_DEVICE_INTERFACE_DATA rDeviceInfo;
	BOOL bMoreDevices,bFound=FALSE;
	DWORD dwRequiredSize;
	HANDLE hRegHandle;
	PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail;
	WCHAR wcBaseName[MAX_PORT_LEN];
	
    rDeviceInfo.cbSize=sizeof(rDeviceInfo);

    if ( !SetupDiOpenDeviceInterface(hDeviceList, pPort->DevicePath,
                                     DIODI_NO_ADD,  &rDeviceInfo) )
        return INVALID_HANDLE_VALUE;

    hRegHandle = SetupDiOpenDeviceInterfaceRegKey(hDeviceList,
                                                  &rDeviceInfo,
                                                  0,
                                                  KEY_ALL_ACCESS);
   
    if ( hRegHandle != INVALID_HANDLE_VALUE ) {

        if ( MatchingRegKey(hRegHandle, pPort) )
            return hRegHandle;

        CloseHandle(hRegHandle);
    }

	pPrinterGuid=(GUID *)&USB_PRINTER_GUID;
    bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,iLoop,&rDeviceInfo);
    while((bMoreDevices)&&(!bFound))
		{

		  SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,NULL,0,&dwRequiredSize,NULL);
	 	  pDeviceDetail=(PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(0,dwRequiredSize);
		  if(pDeviceDetail==NULL)
		  {
		      OutputDebugStringD1("USBMON: Unable to allocate memory in pGetPrinterList\n");
			  return INVALID_HANDLE_VALUE;
		  }
		  pDeviceDetail->cbSize=sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,pDeviceDetail,dwRequiredSize,&dwRequiredSize,NULL))
		  {
			  OutputDebugStringD1("USBMON: SetupDiGetDeviceInterfaceDetail (second call) failed\n");
			  return INVALID_HANDLE_VALUE;
		  } /*end if SetupDiGetDeviceInterfaceDetail, call2 failed*/

		  hRegHandle=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,&rDeviceInfo,0,KEY_ALL_ACCESS);
		  if(hRegHandle!=INVALID_HANDLE_VALUE)
		  {
                if ( MatchingRegKey(hRegHandle, pPort) )
					bFound=TRUE;
				else
					CloseHandle(hRegHandle);
		  }		 /*end if SetupDiOpenDeviceInterfaceRegKey successful*/
		  GlobalFree(pDeviceDetail);
		  bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,++iLoop,&rDeviceInfo);
		} /*end while more devices & !found*/

	if(!bFound)
		hRegHandle=INVALID_HANDLE_VALUE;
	return hRegHandle;
} /*end function hGetPortRegKey*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\usbmon\usbmon.h ===
extern int iGMessageLevel;
extern int iTest1;
extern HANDLE hMonitorSemaphore;
extern HANDLE hReadWriteSemaphore;
extern int iTest2;


UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult);


#ifdef DBG

#define OutputDebugStringD(_x_) \
{\
  OutputDebugStringA("Old OutputDebugStringD\n");\
  OutputDebugStringA(_x_); \
}

#define OutputDebugStringD0(_x_) \
  OutputDebugStringA(_x_);

#define OutputDebugStringD1(_x_) \
{\
  if(iGMessageLevel>=1) \
    OutputDebugStringA(_x_); \
}

#define OutputDebugStringD2(_x_) \
{\
  if(iGMessageLevel>=2) \
    OutputDebugStringA(_x_);\
}

#define OutputDebugStringD3(_x_) \
{\
  if(iGMessageLevel>=3) \
    OutputDebugStringA(_x_);\
}

#define OutputDebugStringWD0(_x_) \
  OutputDebugStringW(_x_);

#define OutputDebugStringWD1(_x_) \
{\
  if(iGMessageLevel>=1) \
    OutputDebugStringW(_x_);\
}

#define OutputDebugStringWD2(_x_) \
{	 \
  if(iGMessageLevel>=2) \
    OutputDebugStringW(_x_);\
}

#define OutputDebugStringWD3(_x_) \
{		\
  if(iGMessageLevel>=3) \
    OutputDebugStringW(_x_);\
}


#define printfD wsprintf

#define OuptutDebigStringWD(_x_) \
{	 \
  OutputDebugStringW("Old OutputDebugStringWD\n");	\
  OutputDebugStringW(_x_); \
}

#else

#define OutputDebugStringWD0
#define OutputDebugStringWD1
#define OutputDebugStringWD2
#define OutputDebugStringWD3
#define OutputDebugStringD0
#define OutputDebugStringD
#define OutputDebugStringD1
#define OutputDebugStringD2
#define OutputDebugStringD3
#define printfD


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\usbmon\enumports.h ===
BOOL WINAPI USBMON_EnumPorts(LPWSTR pName, DWORD Level, LPBYTE  pPorts, DWORD cbBuf,LPDWORD pcbNeeded, LPDWORD pcReturned);

#define MAX_PORT_LEN 20	 //chars, this is the max port len of a USB printer
#define MAX_PORT_DESC_LEN 60 //chars This will probably need to get bigger or be made dynamic if we want port-unique descriptions
#define MAX_MONITOR_NAME_LEN 40
//#define PORT_NAME_BASE L"USB"
//#define PORT_NAME_BASE_A "USB"
#define MAX_PRINTER_NAME_LEN 222 
#define MONITOR_NAME L"USB Print Monitor"
#define STANDARD_PORT_DESC L"Virtual printer port for USB"
#define MAX_ENUM_PRINTER_BUFFER_SIZE 1024*512


#define MAX_WRITE_CHUNK 10240

typedef struct USBMON_PRINTER_INFO_DEF
{
	WCHAR DevicePath[256];
	BOOL bLinked;
	DWORD dwVidPid;
	struct USBMON_PRINTER_INFO_DEF *pNext;

} USBMON_PRINTER_INFO, *PUSBMON_PRINTER_INFO;

typedef struct USBMON_PORT_INFO_DEF
{
	WCHAR szPortName[MAX_PORT_LEN];
	WCHAR szPortDescription[MAX_PORT_DESC_LEN];
	WCHAR DevicePath[256];
	int iRefCount;
    DWORD ReadTimeoutMultiplier;
    DWORD ReadTimeoutConstant;
    DWORD WriteTimeoutMultiplier;
    DWORD WriteTimeoutConstant;
	HANDLE hDeviceHandle;
	HANDLE hPrinter; //handle to print queue
	DWORD dwCurrentJob;
	DWORD dwDeviceFlags;
	struct USBMON_PORT_INFO_DEF *pNext;
} USBMON_PORT_INFO, *PUSBMON_PORT_INFO;

typedef struct USBMON_BASENAME_DEF
{
	WCHAR wcBaseName[MAX_PORT_LEN];
	struct USBMON_BASENAME_DEF *pNext;
} USBMON_BASENAME, * PUSBMON_BASENAME;

typedef struct USBMON_QUEUE_INFO_DEF
{
	WCHAR wcPortName[MAX_PORT_LEN];
	WCHAR wcPrinterName[MAX_PRINTER_NAME_LEN];
	struct USBMON_QUEUE_INFO_DEF *pNext;
} USBMON_QUEUE_INFO, *PUSBMON_QUEUE_INFO;

extern PUSBMON_PORT_INFO pPortInfoG;
extern PUSBMON_PRINTER_INFO pPrinterInfoG;
extern char szDebugBuff[];
extern HKEY hPortsKeyG; //global, declared in EnumPorts.
extern PUSBMON_BASENAME GpBaseNameList;

// {28D78FAD-5A12-11d1-AE5B-0000F803A8C2}
static const GUID USB_PRINTER_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\addprint.cpp ===
// AddPrint.cpp : Implementation of COlePrivKSApp and DLL registration.

#include "stdafx.h"
#include "OlePrn.h"
#include "AddPrint.h"

STDMETHODIMP CAddPrint::AddPrinterConnection(BSTR lpPrinterName)
{   
    HRESULT hr = CanIAddPrinterConnection();

    if (FAILED(hr)) 
        return hr;

    if (::AddPrinterConnection(lpPrinterName))
        return S_OK;
    else
        return (SetScriptingError(CLSID_AddPrint,
                                  IID_IAddPrint,
                                  GetLastError()));
}

STDMETHODIMP CAddPrint::DeletePrinterConnection(BSTR lpPrinterName)
{
    HRESULT hr = CanIDeletePrinterConnection( lpPrinterName );

    if (FAILED(hr)) 
        return hr;

    if (::DeletePrinterConnection(lpPrinterName))
        return S_OK;
    else
        return (SetScriptingError(CLSID_AddPrint,
                                  IID_IAddPrint,
                                  GetLastError()));
}

HRESULT CAddPrint::CanIAddPrinterConnection(void) {
    DWORD   dwPolicy;
    HRESULT hr = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicy);
                                 
    if (SUCCEEDED(hr)) {
        hr = (dwPolicy == URLPOLICY_JAVA_MEDIUM ||
              dwPolicy == URLPOLICY_JAVA_LOW    ||
              dwPolicy == URLPOLICY_ALLOW) ? S_OK : E_ACCESSDENIED;
    }

    return hr;
}

HRESULT CAddPrint::CanIDeletePrinterConnection(BSTR pbstrPrinter) {
    DWORD   dwPolicy;
    LPTSTR  lpszPrinter = NULL;
    HRESULT hr = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicy);

    USES_CONVERSION;

    if (SUCCEEDED(hr)) {
        switch(dwPolicy) {
        case URLPOLICY_JAVA_LOW:
        case URLPOLICY_ALLOW:
            hr = S_OK;
            break;
        case URLPOLICY_JAVA_MEDIUM:
            lpszPrinter = OLE2T( pbstrPrinter );

            hr = PromptUser(COlePrnSecurity::DeletePrinterConnection, lpszPrinter );

            hr = SUCCEEDED(hr) ?
                    (HRESULT_CODE(hr) == S_OK ? S_OK : E_FAIL) :
                    hr;
            break;
        default:
            hr = E_ACCESSDENIED;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\uimgr.h ===
/*****************************************************************************
 *
 * $Workfile: UIMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_UI_MANAGER_H
#define INC_UI_MANAGER_H

#define COREUI_VERSION 1
#define MAX_TITLE_LENGTH 256
#define MAX_SUBTITLE_LENGTH 256
const int MaxNumCfgPages = 1;
const int MaxNumAddPages = 5;

class CUIManager
{
public:
    CUIManager();
    ~CUIManager();

    DWORD AddPortUI(HWND hWndParent,
                            HANDLE hXcvPrinter,
                            TCHAR pszServer[],
                            TCHAR sztPortName[]);
    DWORD ConfigPortUI(HWND hWndParent,
                               PPORT_DATA_1 pData,
                               HANDLE hXcvPrinter, TCHAR szServerName[],
                               BOOL bNewPort = FALSE);

    VOID SetControlFont(HWND hwnd, INT nId) const;

protected:

private:

    VOID CreateWizardFont();
    VOID DestroyWizardFont();

    HFONT m_hBigBoldFont;

}; // CUIManager


typedef struct _CFG_PARAM_PACKAGE
{
    PPORT_DATA_1 pData;
    HANDLE hXcvPrinter;
    TCHAR pszServer[MAX_NETWORKNAME_LEN];
    BOOL bNewPort;
    DWORD dwLastError;
} CFG_PARAM_PACKAGE, *PCFG_PARAM_PACKAGE;

typedef struct _ADD_PARAM_PACKAGE
{
    PPORT_DATA_1 pData;
    CUIManager *UIManager;
    HANDLE hXcvPrinter;
    DWORD dwLastError;
    DWORD dwDeviceType;
    DWORD bMultiPort;
    BOOL  bBypassNetProbe;
    TCHAR pszServer[MAX_NETWORKNAME_LEN];
    TCHAR sztPortName[MAX_PORTNAME_LEN];
    TCHAR sztSectionName[MAX_SECTION_NAME];
    TCHAR sztPortDesc[MAX_PORT_DESCRIPTION_LEN + 1];
} ADD_PARAM_PACKAGE, *PADD_PARAM_PACKAGE;


#endif // INC_UI_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\usbmon\usbmon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>

#include <winbase.h>
#include "enumports.h"
#include "usbmon.h"


int iGMessageLevel;
PUSBMON_BASENAME GpBaseNameList;
HANDLE hMonitorSemaphore=NULL;
HANDLE hReadWriteSemaphore=NULL;

BOOL WINAPI USBMON_OpenPort(LPWSTR pName, PHANDLE pHandle);
BOOL WINAPI USBMON_StartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE  pDocInfo);
BOOL WINAPI USBMON_WritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten);
BOOL WINAPI USBMON_ReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer,LPDWORD pcbRead);
BOOL WINAPI USBMON_EndDocPort(HANDLE hPort);
BOOL WINAPI USBMON_ClosePort(HANDLE hPort);
BOOL WINAPI USBMON_SetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved);
BOOL WINAPI USBMON_XcvOpenPort(LPCWSTR pszObject, ACCESS_MASK GrantedAccess, PHANDLE phXcv);
DWORD WINAPI USBMON_XcvDataPort(HANDLE  hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded);
BOOL WINAPI USBMON_XcvClosePort(HANDLE  hXcv);
BOOL USBMON_GetPrinterDataFromPort(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned);
void vLoadBaseNames(HKEY hPortsKey,PUSBMON_BASENAME *ppHead);
void vInterlockedClosePort(PUSBMON_PORT_INFO pPortInfo);
void vInterlockedOpenPort(PUSBMON_PORT_INFO pPortInfo);
void vInterlockedReOpenPort(PUSBMON_PORT_INFO pPortInfo);
LPMONITOREX WINAPI JobyInitializePrintMonitor(LPWSTR pRegistryRoot);
VOID CALLBACK ReadWriteCallback(DWORD dwErrorCode,DWORD dwNumberOfBytesTranfsered,LPOVERLAPPED lpOverlapped);

int iGetMessageLevel();

typedef struct OverlappedResults_def
{
    DWORD dwErrorCode;
    DWORD dwBytesTransfered;
} OverlappedResults,*pOverlappedResults;



BOOL APIENTRY DllMain(HANDLE hModule, 
		      DWORD  ul_reason_for_call, 
		      LPVOID lpReserved)
{

	return TRUE;
}; /*end function DllMain*/




int iGetMessageLevel()
{
  HKEY hRegKey;
  int iReturn=1; //default value is 1; "errors only"
  DWORD dwValue,dwSize;

  dwSize=sizeof(dwValue);
  if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"SOFTWARE\\Microsoft\\USBPRINT",0,KEY_QUERY_VALUE,&hRegKey)==ERROR_SUCCESS)
    if(RegQueryValueEx(hRegKey,L"MonitorMessageLevel",0,NULL,(LPBYTE)&dwValue,&dwSize)==ERROR_SUCCESS)  
      iReturn=(int)dwValue;
  return iReturn;
  

} /*end function iGetMessageLevel*/


LPMONITOREX WINAPI InitializePrintMonitor(LPWSTR pRegistryRoot)
{
	LPMONITOREX lpMonitorInfo=NULL;
	LONG lResult;
	HKEY hRootKey,hPortsKey;
	DWORD dwDisp;

  
	iGMessageLevel=iGetMessageLevel();
    OutputDebugStringD2("USBMON: Head of InitializePrintMonitor\n");

	hMonitorSemaphore=CreateSemaphore(NULL,1,1,NULL);
	if(hMonitorSemaphore==NULL)
	{
		OutputDebugStringD1("USBMON: Unable to initialize Monitor semaphore\n");
		return FALSE;
	}

	hReadWriteSemaphore=CreateSemaphore(NULL,1,1,NULL);
	if(hReadWriteSemaphore==NULL)
	{
		OutputDebugStringD1("USBMON: Unable to initialize ReadWrite semaphore\n");
		return FALSE;
	}



	OutputDebugStringD3("USBMON: Registry root: ");
	OutputDebugStringWD3(pRegistryRoot);
    OutputDebugStringD3("\n");

	pPortInfoG=NULL;
//	lResult=RegOpenKeyExW(HKEY_LOCAL_MACHINE,pRegistryRoot,0,KEY_ALL_ACCESS,&hRootKey);
	lResult=RegCreateKeyExW(HKEY_LOCAL_MACHINE,pRegistryRoot,0,NULL,0,KEY_ALL_ACCESS,NULL,&hRootKey,&dwDisp);
	if(lResult==ERROR_SUCCESS)
	{
		lResult=RegCreateKeyExW(hRootKey,L"PORTS",0,NULL,0,KEY_ALL_ACCESS,NULL,&hPortsKey,&dwDisp);
		RegCloseKey(hRootKey);
	}
	if(lResult==ERROR_SUCCESS)      
	{
	  OutputDebugStringD3("USBMON: hPortsKeyG is good\n");
	  hPortsKeyG=hPortsKey;
	  GpBaseNameList=NULL;
	  vLoadBaseNames(hPortsKey,&GpBaseNameList);
	  lpMonitorInfo=(LPMONITOREX)GlobalAlloc(0,sizeof(MONITOREX));
	  if(lpMonitorInfo!=NULL)
	  {
	    lpMonitorInfo->dwMonitorSize=sizeof(MONITOR);
	    lpMonitorInfo->Monitor.pfnEnumPorts=USBMON_EnumPorts;
	    lpMonitorInfo->Monitor.pfnOpenPort=USBMON_OpenPort;
	    lpMonitorInfo->Monitor.pfnOpenPortEx=NULL; //Not required for port monitors
	    lpMonitorInfo->Monitor.pfnStartDocPort=USBMON_StartDocPort;
	    lpMonitorInfo->Monitor.pfnWritePort=USBMON_WritePort;
	    lpMonitorInfo->Monitor.pfnReadPort=USBMON_ReadPort;
	    lpMonitorInfo->Monitor.pfnEndDocPort=USBMON_EndDocPort;
	    lpMonitorInfo->Monitor.pfnClosePort=USBMON_ClosePort;
	    lpMonitorInfo->Monitor.pfnAddPort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnAddPortEx=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnConfigurePort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnDeletePort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnGetPrinterDataFromPort=USBMON_GetPrinterDataFromPort;
	    lpMonitorInfo->Monitor.pfnSetPortTimeOuts=USBMON_SetPortTimeOuts;
    //	lpMonitorInfo->Monitor.pfnXcvOpenPort=USBMON_XcvOpenPort;
	    lpMonitorInfo->Monitor.pfnXcvOpenPort=NULL;
 //	    lpMonitorInfo->Monitor.pfnXcvDataPort=USBMON_XcvDataPort;
		lpMonitorInfo->Monitor.pfnXcvDataPort=NULL;
//	    lpMonitorInfo->Monitor.pfnXcvClosePort=USBMON_XcvClosePort;
		lpMonitorInfo->Monitor.pfnXcvClosePort=NULL;
	  }
	  else
	  {
	    OutputDebugStringD1("USBMON: Error, Out of memory\n");
	  }
	} /*end if reg keys OK*/
	else
	{
      OutputDebugStringD1("USBMON: Error, Unable to get reg keys!\n");
	}
	
	GpBaseNameList=NULL;
	return lpMonitorInfo; 
};



BOOL USBMON_GetPrinterDataFromPort(
    HANDLE hPort,
    DWORD ControlID,
    LPWSTR pValueName,
    LPWSTR lpInBuffer,
    DWORD cbInBuffer,
    LPWSTR lpOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbReturned)
{

	BOOL bStatus;
    PUSBMON_PORT_INFO pPortInfo;
	HANDLE hPrinter;


	if(ControlID==0)
	{
		OutputDebugStringD2("USBMON: GetPrinterDataFromPort Control ID==0, bailing.  requested value==");
		OutputDebugStringWD2(pValueName);
		OutputDebugStringD2("\n");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE; //need to set last error here.
	}


	pPortInfo=(PUSBMON_PORT_INFO)hPort;
	hPrinter=pPortInfo->hPrinter;

	OutputDebugStringD3("USBMON: Before DeviceIoControl\n");
	bStatus=DeviceIoControl(hPrinter,ControlID,lpInBuffer,cbInBuffer,lpOutBuffer,cbOutBuffer,lpcbReturned,NULL);
	if(!bStatus)
	{
		OutputDebugStringD2("USBMON:  USBMON_GetPrinterDataFromPort failing\n");
		SetLastError(ERROR_INVALID_PARAMETER);
		
	}
	else
	{
		OutputDebugStringD2("USBMON: USBMON_GetPrinterDataFromPort Success\n");
		SetLastError(ERROR_SUCCESS);
	}
	return bStatus;		
} /*end function USBMON_GetPrinterDataFromPort*/





BOOL WINAPI USBMON_OpenPort(LPWSTR pName, PHANDLE pHandle)
{
	PUSBMON_PORT_INFO pWalkPorts;
	BOOL bFound=FALSE;
	
	
	OutputDebugStringD2("USBMON: Head of USBMON_OpenPort\n");
	pWalkPorts=pPortInfoG;
	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: OpenPort Looking for \"%s\"\n",pName);
	OutputDebugStringWD2((WCHAR *)szDebugBuff);
	while((bFound==FALSE)&&(pWalkPorts!=NULL))
	{
  	    wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Looking at node \"%s\"\n",pWalkPorts->szPortName);
	    OutputDebugStringWD3((WCHAR *)szDebugBuff);

		if(lstrcmp(pName,pWalkPorts->szPortName)==0)
			bFound=TRUE;
		else
			pWalkPorts=pWalkPorts->pNext;
	}
	if(bFound)
	{

	    wsprintfW((WCHAR *)szDebugBuff,L"USBMON:  About to open path: \"%s\"\n",pWalkPorts->DevicePath);
	    OutputDebugStringD3(szDebugBuff);

//		pWalkPorts->hDeviceHandle=CreateFile(pWalkPorts->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
//		if(pWalkPorts->hDeviceHandle!=INVALID_HANDLE_VALUE)
//		{
		  *pHandle=(HANDLE)pWalkPorts;
          pWalkPorts->ReadTimeoutMultiplier=0;
          pWalkPorts-> ReadTimeoutConstant=60000;
          pWalkPorts->WriteTimeoutMultiplier=0;
          pWalkPorts->WriteTimeoutConstant=60000;

		  OutputDebugStringD3("USBMON: USBMON_OpenPort returning TRUE\n");
		  return TRUE;
//		}
	}
	*pHandle=INVALID_HANDLE_VALUE;
	wsprintfA(szDebugBuff,"USBMON: USBMON_OpenPort returning FALSE, error=%d\n",GetLastError());
	OutputDebugStringD1(szDebugBuff);
	return FALSE;
}

BOOL WINAPI USBMON_StartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE  pDocInfo)
{
	BOOL bResult;
	HANDLE hPrinter;
	PUSBMON_PORT_INFO pPortInfo;

	OutputDebugStringD2("USBMON: Head of StartDocPort\n");
	pPortInfo=(PUSBMON_PORT_INFO)hPort;
	bResult=OpenPrinterW(pPrinterName,&hPrinter,NULL);
	if(bResult==FALSE)
	{
		OutputDebugStringD1("USBMON: OpenPrinter failed\n");
		return FALSE;
	}
	else
	{
  	  pPortInfo->hPrinter=hPrinter;
	  pPortInfo->dwCurrentJob=JobId;
 //	 pWalkPorts->hDeviceHandle=CreateFile(pWalPorts->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
     wsprintfW((WCHAR *)szDebugBuff,L"USBMON:---------------------------------- About to open path: \"%s\"\n",pPortInfo->DevicePath);
	 OutputDebugStringD3(szDebugBuff);

//	  pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
	  vInterlockedOpenPort(pPortInfo);
 	  OutputDebugStringD3("USBMON: CreateFile in StartDocPort\n");
	  if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
	  {
        OutputDebugStringD1("USBMON: CreateFile on printer device object failed\n");
		return FALSE;
	  }
	  return TRUE;
	} /*end else bResult OK*/

}


BOOL WINAPI USBMON_ReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten)
{
    
    DWORD dwBytesToRead;
    PUSBMON_PORT_INFO pPortInfo;
    DWORD dwTimeout;
    OVERLAPPED rOverlappedInfo;
    BOOL bTimeOut=FALSE,bSuccess=TRUE;
    OverlappedResults Results;
    
    OutputDebugStringD3("USBMON: Head of ReadPort\n");
    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    
    dwBytesToRead=cbBuf;
    
    vInterlockedOpenPort(pPortInfo);
    if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
    {
        OutputDebugStringD1("USBMON: CreateFile on printer device object (inside ReadPort) failed\n");
        return FALSE;
    } /*end else CreateFile failed*/
    
    dwTimeout=(pPortInfo->ReadTimeoutMultiplier)*dwBytesToRead;
    dwTimeout+=pPortInfo->ReadTimeoutConstant;
    memset(&rOverlappedInfo,0,sizeof(rOverlappedInfo));
    rOverlappedInfo.hEvent=(HANDLE)&Results;
    
    if(ReadFileEx(pPortInfo->hDeviceHandle,pBuffer,dwBytesToRead,&rOverlappedInfo,ReadWriteCallback)==FALSE)
    {
        bSuccess=FALSE;
    }
    else
    {
      	wsprintfA(szDebugBuff,"USBMON: Sleep time=%d\n",dwTimeout);
	    OutputDebugStringD3(szDebugBuff);

        if(SleepEx(dwTimeout,TRUE)==0)
        {
            OutputDebugStringD1("USBMON:  SleepEx failed or timed out\n");
            CancelIo(pPortInfo->hDeviceHandle);
            bSuccess=FALSE;
            SetLastError(ERROR_TIMEOUT);
        }
        else
        {
            if(Results.dwErrorCode==0)
            {

                 wsprintfA(szDebugBuff,"USBMON:  bytes read=%u\n",*pcbWritten);
                OutputDebugStringD3(szDebugBuff);
                SetLastError(ERROR_SUCCESS);
                OutputDebugStringD3(szDebugBuff);
            }
            else
            {
                OutputDebugStringD1("USBMON:  callback reported error\n");
                SetLastError(Results.dwErrorCode);
                bSuccess=FALSE;
                
            } /*end else callback reported error*/
        }  /*end else did not time out*/
        *pcbWritten=Results.dwBytesTransfered;
    }  /*end able to start read*/
    
    if(!bSuccess)
    {
        OutputDebugStringD2("USBMON: Re-opening port\n");
        vInterlockedReOpenPort(pPortInfo);
    }

        vInterlockedClosePort(pPortInfo);
        return bSuccess;
} /*end function ReadPort*/



BOOL WINAPI USBMON_WritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten)
{
    
    DWORD dwBytesToWrite;
    PUSBMON_PORT_INFO pPortInfo;
    DWORD dwTimeout;
    OVERLAPPED rOverlappedInfo;
    BOOL bTimeOut=FALSE,bSuccess=TRUE;
    OverlappedResults Results;
    
    OutputDebugStringD3("USBMON: Head of WritePort\n");
    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    
    if(cbBuf>MAX_WRITE_CHUNK)
        dwBytesToWrite=MAX_WRITE_CHUNK;
    else
        dwBytesToWrite=cbBuf;
    
    //	pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
    vInterlockedOpenPort(pPortInfo);
    if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
    {
        OutputDebugStringD1("USBMON: CreateFile on printer device object (inside WritePort) failed\n");
        return FALSE;
    } /*end else CreateFile failed*/
    
    dwTimeout=(pPortInfo->WriteTimeoutMultiplier)*dwBytesToWrite;
    dwTimeout+=pPortInfo->WriteTimeoutConstant;
    memset(&rOverlappedInfo,0,sizeof(rOverlappedInfo));
    rOverlappedInfo.hEvent=(HANDLE)&Results;

    //wsprintfA(szDebugBuff,"USBMON:/*dd About to WriteFileEx; pPortInfo->hDeviceHandle=%x, pBuffer=%x, dwBytesToWrite=%x\n",pPortInfo->hDeviceHandle,
      //  pBuffer,dwBytesToWrite);
	//OutputDebugStringD1(szDebugBuff);
    
    if(WriteFileEx(pPortInfo->hDeviceHandle,pBuffer,dwBytesToWrite,&rOverlappedInfo,ReadWriteCallback)==FALSE)
    {
        bSuccess=FALSE;
    }
    else
    {
      	wsprintfA(szDebugBuff,"USBMON:  Sleep time=%d\n",dwTimeout);
	    OutputDebugStringD2(szDebugBuff);

        if(SleepEx(dwTimeout,TRUE)==0)
        {
            OutputDebugStringD2("USBMON: SleepEx failed or timed out\n");
            CancelIo(pPortInfo->hDeviceHandle);
            bSuccess=FALSE;
            SetLastError(ERROR_TIMEOUT);
        }
        else
        {
            if(Results.dwErrorCode==0)
            {

                 wsprintfA(szDebugBuff,"USBMON:  bytes written=%u\n",*pcbWritten);
                OutputDebugStringD3(szDebugBuff);
                SetLastError(ERROR_SUCCESS);
                OutputDebugStringD3(szDebugBuff);
            }
            else
            {
                OutputDebugStringD3("USBMON:  callback reported error\n");
                SetLastError(Results.dwErrorCode);
                bSuccess=FALSE;
                
            } /*end else callback reported error*/
        }  /*end else did not time out*/
        *pcbWritten=Results.dwBytesTransfered;
    }  /*end able to start write*/
    
    if(!bSuccess)
    {
        OutputDebugStringD2("USBMON:  Re-opening port\n");
        vInterlockedReOpenPort(pPortInfo);
    }

        vInterlockedClosePort(pPortInfo);
        return bSuccess;
} /*end function WritePort*/

    




VOID CALLBACK ReadWriteCallback(DWORD dwErrorCode,DWORD dwNumberOfBytesTransfered,LPOVERLAPPED lpOverlapped)
{
    pOverlappedResults pResults;
   	OutputDebugStringD2("  USBMON:  ReadWriteCallback\n");
    pResults=(pOverlappedResults)(lpOverlapped->hEvent);
    pResults->dwErrorCode=dwErrorCode;
    pResults->dwBytesTransfered=dwNumberOfBytesTransfered;
} /*end function ReadWriteCallback*/


BOOL WINAPI USBMON_EndDocPort(HANDLE hPort)
{
	PUSBMON_PORT_INFO pPortInfo;

	OutputDebugStringD3("USBMON: Head of EndDocPort\n");

	pPortInfo=(PUSBMON_PORT_INFO)hPort;

	SetJob(pPortInfo->hPrinter,pPortInfo->dwCurrentJob,0,NULL,JOB_CONTROL_SENT_TO_PRINTER);
	ClosePrinter(pPortInfo->hPrinter);

	vInterlockedClosePort(pPortInfo);
    return TRUE;
}


BOOL WINAPI USBMON_ClosePort(HANDLE hPort)
{
	OutputDebugStringD3("USBMON:  Head of ClosePort\n");
//	CloseHandle( ((PUSBMON_PORT_INFO)hPort)->hDeviceHandle);
    return TRUE;
}

BOOL WINAPI USBMON_SetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved)
{
    PUSBMON_PORT_INFO pPortInfo;

   	OutputDebugStringD3("  USBMON: Head of SetPortTimeOuts\n");

    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    wsprintfA(szDebugBuff,"USBMON:   SetPortTimeOut, ReadMultiplier=%u, ReadConstant=%u\n",
        lpCTO->ReadTotalTimeoutMultiplier,lpCTO->ReadTotalTimeoutConstant);
	OutputDebugStringD2(szDebugBuff);
    pPortInfo->ReadTimeoutMultiplier=lpCTO->ReadTotalTimeoutMultiplier;
    pPortInfo->ReadTimeoutConstant=lpCTO->ReadTotalTimeoutConstant;
    pPortInfo->WriteTimeoutMultiplier=lpCTO->WriteTotalTimeoutMultiplier;
    pPortInfo->WriteTimeoutConstant=lpCTO->WriteTotalTimeoutConstant;
    return TRUE;
}

BOOL WINAPI USBMON_XcvOpenPort(LPCWSTR pszObject, ACCESS_MASK GrantedAccess, PHANDLE phXcv)
{
	OutputDebugStringD2("USBMON: Head of XcvOpenPort\n");

    return FALSE;
}

DWORD WINAPI USBMON_XcvDataPort(HANDLE  hXcv, 
								LPCWSTR pszDataName, 
								PBYTE pInputData,
								DWORD cbInputData, 
								PBYTE pOutputData, 
								DWORD cbOutputData,
								PDWORD pcbOutputNeeded)
{
	OutputDebugStringD2("USBMON: Head of XcvDataPort\n");

    return ERROR_INVALID_FUNCTION;
}

BOOL WINAPI USBMON_XcvClosePort(HANDLE  hXcv)
{
	OutputDebugStringD2("USBMON: Head of XcvClosePort\n");

    return FALSE;
}
 
/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult)
{
    UINT r = 0;
    UINT Sign = 0;
    UCHAR c;
    UINT d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (UINT)(-(INT)r);
    *pResult = r;

    return 1;                       // Success!
}

void vLoadBaseNames(HKEY hRegKey, PUSBMON_BASENAME *ppHead)
{
	PUSBMON_BASENAME pNew,pWalk;
	WCHAR wcName[MAX_PORT_LEN];
	int iIndex=0;
	LONG lStatus;
	LONG lDataSize;
	int iCompare;
	
	*ppHead=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
	if(*ppHead==NULL)
		return;
	(*ppHead)->pNext=NULL;
	wcscpy((*ppHead)->wcBaseName,L"USB");
	
	lDataSize=MAX_PORT_LEN;
	lStatus=RegEnumValue(hRegKey,iIndex++,wcName,&lDataSize,NULL,NULL,NULL,NULL);
    while(lStatus==ERROR_SUCCESS)
	{
		pNew=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
		if(pNew==NULL)
			return;
		wcscpy(pNew->wcBaseName,wcName);
		if(wcscmp(pNew->wcBaseName,(*ppHead)->wcBaseName)<0)
		{
			pNew->pNext=*ppHead;
			*ppHead=pNew;
		} /*end if new first node*/
		else
		{
			pWalk=*ppHead;
			iCompare=-1;
			while((iCompare<0)&&(pWalk->pNext!=NULL))
			{
				iCompare=wcscmp(pNew->wcBaseName,pWalk->pNext->wcBaseName);
				if(iCompare<0)
					pWalk=pWalk->pNext;
			} /*end while walk*/
			if(iCompare>0)
			{
				pNew->pNext=pWalk->pNext;
				pWalk->pNext=pNew;
			}
			else if(iCompare==0)
			{
				GlobalFree(pNew);
			} /*end if collision*/
		} /*else not new first node*/
		lDataSize=MAX_PORT_LEN;
		lStatus=lStatus=RegEnumValue(hRegKey,iIndex++,wcName,&lDataSize,NULL,NULL,NULL,NULL);
	}	//end while more reg items
} //end function vLoadBaseNames



  

void vInterlockedOpenPort(PUSBMON_PORT_INFO pPortInfo)
{ 
	OutputDebugStringD2("USBMON: Head of vInterlockedOpenPort\n");

	WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
	if((pPortInfo->iRefCount==0)||(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE))
	{
        OutputDebugStringD3("USBMON: vInterlockedOpenPort, Really opening:");
        OutputDebugStringWD3(pPortInfo->DevicePath);
        OutputDebugStringD3("\n");
		pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_FLAG_OVERLAPPED,NULL);
	    if(pPortInfo->hDeviceHandle!=INVALID_HANDLE_VALUE)
		  (pPortInfo->iRefCount)++;
	}
	else
	{
        OutputDebugStringD3("USBMON:  vInterlockedOpenPort, Just incrementing ref count\n");
		(pPortInfo->iRefCount)++;
	}
	wsprintfA(szDebugBuff,"USBMON: vInterlockedOpenPort, iRefCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);

} /*end function vInterlockedOpenPort*/




void vInterlockedClosePort(PUSBMON_PORT_INFO pPortInfo)
{
	OutputDebugStringD2("USBMON: Head of vInterlockedClosePort\n");
	
    WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
	(pPortInfo->iRefCount)--;
	if(pPortInfo<0) {
        DebugBreak();
		pPortInfo=0;
    }
	if(pPortInfo->iRefCount==0)
	{
		CloseHandle(pPortInfo->hDeviceHandle);
		pPortInfo->hDeviceHandle=INVALID_HANDLE_VALUE;
	}
	wsprintfA(szDebugBuff,"USBMON:  vInterlockedClosePort, iRefCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);
} /*end function vInterlockedClosePort*/


void vInterlockedReOpenPort(PUSBMON_PORT_INFO pPortInfo)
{
	OutputDebugStringD2("USBMON: Head of vInterlockedReOpenPort\n");
	WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
    //
    // big problem. what if another thread is using the handle
    //
	CloseHandle(pPortInfo->hDeviceHandle);
    OutputDebugStringD3("USBMON: vInterlockedReOpenPort, Really opening----------------------------------------------:\n");
    OutputDebugStringWD3(pPortInfo->DevicePath);
    OutputDebugStringD3("\n");
    pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
	if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
//		--pPortInfo->iRefCount;
	wsprintfA(szDebugBuff,"USBMON: vInterlockedReOpenPort, iRefcCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);
} /*end function vInterlockedReOpenPort*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\usbmon\usbmonexp.h ===
LPMONITOREX WINAPI InitializePrintMonitor(LPWSTR pRegistryRoot);
LPMONITOREX WINAPI JobyInitializePrintMonitor(LPWSTR pRegistryRoot);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\uimgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: UIMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMonUI/UIMgr.cpp $
 *
 * 9     9/23/97 3:56p Becky
 * Corrected small bug for NT 5.0
 *
 * 8     9/23/97 3:35p Becky
 * Split functionality into NT4UIMgr and NT5UIMgr files.  This main class
 * is only responsible, now, for making a decision on which of these
 * classes to create and call.
 *
 * 7     9/19/97 11:26a Becky
 * Added Wizard 97 flags and function parameters.
 *
 * 6     9/12/97 3:25p Becky
 * Added bNewPort to the params structure.
 *
 * 5     9/11/97 9:55a Becky
 * Added parameter to the ConfigPortUI call to let us know if the call is
 * for a new port or an existing one.
 *
 * 4     9/10/97 3:16p Becky
 * Split out Input Checking functionality into the class CInptChkr.
 *
 * 3     9/09/97 4:35p Becky
 * Updated to use the new Monitor UI data structure.
 *
 * 2     9/09/97 11:58a Becky
 * Added a UIManager field to the AddParamsPackage so the Add UI will know
 * how to call the Config UI (it's a member function of the UIManager).
 *
 * 1     8/19/97 3:46p Becky
 * Redesign of the Port Monitor UI.
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#define _PRSHT_H_

#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "resource.h"
#include "NT5UIMgr.h"

// includes for ConfigPort
#include "CfgPort.h"
#include "CfgAll.h"

// includes for AddPort
#include "DevPort.h"
#include "AddWelcm.h"
#include "AddGetAd.h"
#include "AddMInfo.h"
#include "AddDone.h"

#undef _PRSHT_H_

//
//  FUNCTION: CUIManager
//
//  PURPOSE: Constructor
//
CUIManager::CUIManager() : m_hBigBoldFont(NULL)
{
    CreateWizardFont();
} // Constructor

//
//  FUNCTION: CUIManager
//
//  PURPOSE: Destructor
//
CUIManager::~CUIManager()
{
    DestroyWizardFont();
} // Destructor

//
//  FUNCTION: AddPortUI
//
//  PURPOSE: Main function called when the User Interface for adding a port is called.
//
DWORD CUIManager::AddPortUI(HWND hWndParent,
							HANDLE hXcvPrinter,
							TCHAR pszServer[],
							TCHAR sztPortName[])
{
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( GetVersionEx(&osVersionInfo) )			// get the OS version
	{
		if ( osVersionInfo.dwMajorVersion >= 5 )	// check if we are NT 5.0 & later
		{
			CNT5UIManager UI97;
			return UI97.AddPortUI(hWndParent, hXcvPrinter, pszServer, sztPortName);
		}
		else
		{
            return ERROR_NOT_SUPPORTED;
		}
	}

	return NO_ERROR;

} // AddPortUI


//
//  FUNCTION: ConfigPortUI
//
//  PURPOSE: Main function called when the User Interface for configuring a port is called.
//
DWORD CUIManager::ConfigPortUI(HWND hWndParent,
							   PPORT_DATA_1 pData,
							   HANDLE hXcvPrinter,
							   TCHAR *szServerName,
							   BOOL bNewPort)
{
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( GetVersionEx(&osVersionInfo) )			// get the OS version
	{
		if ( osVersionInfo.dwMajorVersion >= 5 )	// check if we are NT 5.0 & later
		{
			CNT5UIManager UI97;
			return UI97.ConfigPortUI(hWndParent, pData, hXcvPrinter, szServerName, bNewPort);
		}
		else
		{
            return ERROR_NOT_SUPPORTED;
		}
	}

	return NO_ERROR;

} // ConfigPortUI

//
//
//  FUNCTION: CreateWizardFont()
//
//  PURPOSE: Create the large bold font for the wizard 97 style.
//
//  COMMENTS:
//
VOID CUIManager::CreateWizardFont()
{
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
    // Create the Big Bold Font
    //
    BigBoldLogFont.lfWeight = FW_BOLD;

    INT FontSize;
    TCHAR szLargeFontName[MAX_PATH];
    TCHAR szLargeFontSize[MAX_PATH];

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if( LoadString( g_hInstance, IDS_LARGEFONTNAME, szLargeFontName, sizeof(szLargeFontName)/sizeof(szLargeFontName[0]) ) &&
        LoadString( g_hInstance, IDS_LARGEFONTSIZE, szLargeFontSize, sizeof(szLargeFontName)/sizeof(szLargeFontName[0]) ) )
    {
        lstrcpyn( BigBoldLogFont.lfFaceName, szLargeFontName, sizeof(BigBoldLogFont.lfFaceName)/sizeof(BigBoldLogFont.lfFaceName[0]) );

        FontSize = _tcstoul( szLargeFontSize, NULL, 10 );

    	HDC hdc = GetDC( NULL );

        if( hdc )
        {
            BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

            m_hBigBoldFont = CreateFontIndirect( &BigBoldLogFont );

            ReleaseDC( NULL, hdc);
        }
    }
} // CreateWizardFont

//
//
//  FUNCTION: DestroyWizardFont()
//
//  PURPOSE: Destroys the wizard font created with CreateWizardFont
//
//  COMMENTS:
//
VOID CUIManager::DestroyWizardFont()
{
    if(m_hBigBoldFont)
    {
        DeleteObject(m_hBigBoldFont);
    }
} // DestroyWizardFont

//
//
//  FUNCTION: SetControlFont(HFONT hFont, HWND hwnd, INT nId)
//
//  PURPOSE: Set font of the specified control
//
//  COMMENTS:
//
VOID CUIManager::SetControlFont(HWND hwnd, INT nId) const
{
	if(m_hBigBoldFont)
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if(hwndControl)
        {
        	SetWindowFont(hwndControl, m_hBigBoldFont, TRUE);
        }
    }
} // SetControlFont
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\addprint.h ===
// AddPrint.h: Definition of the CAddPrint class
//
//////////////////////////////////////////////////////////////////////

#ifndef _ADDPRINT_H_
#define _ADDPRINT_H_

/////////////////////////////////////////////////////////////////////////////
// CAddPrint

class ATL_NO_VTABLE CAddPrint :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAddPrint, &CLSID_AddPrint>,
    public COlePrnSecObject<CAddPrint>,
    public ISupportErrorInfoImpl<&IID_IAddPrint>,
    public IDispatchImpl<IAddPrint, &IID_IAddPrint, &LIBID_OLEPRNLib>
{
public:
    CAddPrint() {
    }
BEGIN_COM_MAP(CAddPrint)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IAddPrint)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)     // From COlePrnSecObject
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)   // From COlePrnSecObject
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CAddPrint)
// Remove the comment from the line above if you don't want your object to
// support aggregation.

DECLARE_REGISTRY_RESOURCEID(IDR_AddPrint)
// IAddPrint
public:
	STDMETHOD(DeletePrinterConnection)(BSTR lpPrinterName);
	STDMETHOD(AddPrinterConnection)(BSTR lpPrinterName);
private:
    HRESULT CanIAddPrinterConnection(void);
    HRESULT CanIDeletePrinterConnection(BSTR);
};

#endif // !defined _ADDPRINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\cpinst.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_InstallEvent
template <class T>
class CProxy_InstallEvents : public IConnectionPointImpl<T, &DIID__InstallEvent, CComDynamicUnkArray>
{
public:
//methods:
//_InstallEvent : IDispatch
public:
	void Fire_OnProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];

        if (pvars != NULL) {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= lProgress;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
	}
	void Fire_InstallError(
		long lErrCode)
	{
		VARIANTARG* pvars = new VARIANTARG[1];

        if (pvars != NULL) {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= lErrCode;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\asphelp.cpp ===
/*****************************************************************************\
* MODULE:       asphelp.cpp
*
* PURPOSE:      Implementation of the printer helper library
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*
\*****************************************************************************/

#include "stdafx.h"
#include "oleprn.h"
#include "printer.h"
#include "asphelp.h"

Casphelp::Casphelp()
{
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    m_bOnStartPageCalled    = FALSE;
    m_bTCPMonSupported      = FALSE;
    m_hPrinter              = NULL;
    m_hXcvPrinter           = NULL;
    m_pInfo2                = NULL;
    m_bCalcJobETA           = FALSE;
    m_pPrinter              = NULL;

    if ( ! GetComputerName (m_szComputerName, &dwSize) )
        // Set the first char to '\0'.
        m_szComputerName[0] = 0;
}



/////////////////////////////////////////////////////////////////////////////
// Casphelp

STDMETHODIMP Casphelp::OnStartPage (IUnknown* pUnk)
{
    if ( !pUnk )
        return E_POINTER;

    CComPtr<IScriptingContext> spContext;
    HRESULT hr;

    // Get the IScriptingContext Interface
    hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
    if ( FAILED(hr) )
        return hr;

    // Get Request Object Pointer
    hr = spContext->get_Request(&m_piRequest);
    if ( FAILED(hr) ) {
        spContext.Release();
        return hr;
    }

    // Get Response Object Pointer
    hr = spContext->get_Response(&m_piResponse);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        return hr;
    }

    // Get Server Object Pointer
    hr = spContext->get_Server(&m_piServer);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        return hr;
    }

    // Get Session Object Pointer
    hr = spContext->get_Session(&m_piSession);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        m_piServer.Release();
        return hr;
    }

    // Get Application Object Pointer
    hr = spContext->get_Application(&m_piApplication);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        m_piServer.Release();
        m_piSession.Release();
        return hr;
    }
    m_bOnStartPageCalled = TRUE;
    return S_OK;
}

STDMETHODIMP Casphelp::OnEndPage ()
{
    m_bOnStartPageCalled = FALSE;
    // Release all interfaces
    m_piRequest.Release();
    m_piResponse.Release();
    m_piServer.Release();
    m_piSession.Release();
    m_piApplication.Release();

    return S_OK;
}


/*****************************************************************************\
* FUNCTION:         Open
*
* PURPOSE:          Open method, try to open a printer and get the printer info2
*
* ARGUMENTS:
*
*   pPrinterName:   Printer Name
*
* RETURN VALUE:
*   S_OK:           If succeed.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode are
*                   ERROR_INVALID_PRINTER_NAME:     Invalid printer name
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::Open(BSTR pPrinterName)
{
    static  const TCHAR cszPrefix[]   = TEXT(",XcvPort ");
    static  const TCHAR cszPattern[]  = TEXT("%s\\,XcvPort %s");

    LPTSTR      pszXcvPortName          = NULL;
    TCHAR       szMonitorName[MAX_PATH] = TEXT("");
    BOOL        bRet                    = FALSE;

    if ( ! (m_pPrinter = new CPrinter) ) {
        SetLastError (ERROR_INVALID_PRINTER_NAME);
        goto CleanOut;
    }

    if ( ! (m_pPrinter->Open (pPrinterName, &m_hPrinter))) {
        goto CleanOut;
    }

    if ( ! (m_pInfo2 = m_pPrinter->GetPrinterInfo2 ()) ) {
        goto CleanOut;
    }

    // Open the XcvPrinter

    // Compose the openprinter string
    if ( m_pInfo2->pServerName && lstrcmp(m_pInfo2->pServerName, TEXT ("")) ) {
        // Alloc the memeory for open printer string with server name

        if ( ! (pszXcvPortName = (LPTSTR) LocalAlloc (LPTR, sizeof (cszPattern) +
                                                      sizeof (TCHAR) * (lstrlen (m_pInfo2->pServerName)
                                                                        + lstrlen (m_pInfo2->pPortName) + 1))) ) {
            goto CleanOut;
        }

        // Construct the OpenPrinter String with the server name
        wsprintf(pszXcvPortName, cszPattern, m_pInfo2->pServerName,
                 m_pInfo2->pPortName);
    } else {
        // Alloc the memeory for open printer string without server name

        if ( ! (pszXcvPortName = (LPTSTR) LocalAlloc (LPTR, sizeof (cszPrefix) +
                                                      sizeof (TCHAR) * (lstrlen (m_pInfo2->pPortName) + 1))) ) {
            goto CleanOut;
        }

        // Construct the OpenPrinter String with the server name
        lstrcpy (pszXcvPortName, cszPrefix);
        lstrcat (pszXcvPortName, m_pInfo2->pPortName);
    }

    // Now the openprinter string is ready, call the openprinter

    // We open the port using the default access previlige, because that is
    // enought for getting all the XcvData we need.
    if ( !OpenPrinter(pszXcvPortName, &m_hXcvPrinter, NULL) ) {
        // Reset the handle
        m_hXcvPrinter = NULL;
    }

    // Check if we're using the standard universal monitor "TCPMON.DLL"
    if ( GetMonitorName(szMonitorName) )
        m_bTCPMonSupported = !(lstrcmpi(szMonitorName, STANDARD_SNMP_MONITOR_NAME));
    else
        m_bTCPMonSupported = FALSE;

    bRet = TRUE;

CleanOut:
    if (pszXcvPortName)
        LocalFree (pszXcvPortName);

    if (bRet) {
        return S_OK;
    }
    else {
        Cleanup ();
        return SetAspHelpScriptingError(GetLastError ());
    }
}

/*****************************************************************************\
* FUNCTION:         Close
*
* PURPOSE:          Close method, cleanup the allocated handle/memory
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           always.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::Close()
{
    Cleanup();
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_IPAddress
*
* PURPOSE:          Get operation for IPAddress property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the IpAddress.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_IPAddress(BSTR * pbstrVal)
{
    return GetXcvDataBstr (L"IPAddress", pbstrVal);
}

/*****************************************************************************\
* FUNCTION:         get_Community
*
* PURPOSE:          Get operation for Community property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the Community.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Community(BSTR * pbstrVal)
{
    return GetXcvDataBstr (L"SNMPCommunity", pbstrVal);
}

/*****************************************************************************\
* FUNCTION:         get_SNMPDevice
*
* PURPOSE:          Get operation for SNMPDevice property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the SNMPDevice.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_SNMPDevice(DWORD * pdwVal)
{
    return GetXcvDataDword (L"SNMPDeviceIndex", pdwVal);
}

/*****************************************************************************\
* FUNCTION:         get_SNMPSupported
*
* PURPOSE:          Get operation for SNMPSupported property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the SNMPSupported. (TRUE or FALSE)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_SNMPSupported(BOOL * pbVal)
{
    DWORD dwVal;
    HRESULT hr;

    *pbVal = FALSE;

    // Find out if it is an SNMP monitor
    hr = GetXcvDataDword (L"SNMPEnabled", &dwVal);
    if ( SUCCEEDED (hr) )
        *pbVal = dwVal;

    return hr;
}

STDMETHODIMP Casphelp::get_IsHTTP(BOOL * pbVal)
{
    static const TCHAR c_szHttp[]   = TEXT("http://");
    static const TCHAR c_szHttps[]  = TEXT("https://");

    *pbVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    //
    // Check if it is a masq printer and connected to an http port
    // then the port name is the url.
    //
    if ( ( m_pInfo2->Attributes & PRINTER_ATTRIBUTE_LOCAL ) &&
         ( m_pInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK ) ) {

        if ( m_pInfo2->pPortName ) {
            //
            // Compare the port name prefex to see if it is an HTTP port.
            //
            if ( !_tcsnicmp( m_pInfo2->pPortName, c_szHttp, _tcslen( c_szHttp ) ) ||
                 !_tcsnicmp( m_pInfo2->pPortName, c_szHttps, _tcslen( c_szHttps ) ) ) {
                //
                // Masq printers connected via a http print provider do have not
                // useful job status information therefor the standard win32
                // queue view is not the preferred view.
                //
                *pbVal = TRUE;
            }
        }
    }

    return S_OK;
}

VOID Casphelp::Cleanup()
{

    if ( m_hXcvPrinter != NULL ) {
        ClosePrinter (m_hXcvPrinter);
        m_hXcvPrinter = NULL;
    }

    if ( m_pPrinter ) {
        delete (m_pPrinter);
        m_pPrinter = NULL;
    }

    m_bTCPMonSupported        = FALSE;
    return;
}

Casphelp::~Casphelp()
{
    Cleanup();
}


HRESULT Casphelp::GetXcvDataBstr(LPCTSTR pszId, BSTR *pbstrVal)
{
    *pbstrVal = NULL;

    if ( !m_bTCPMonSupported ) {
        *pbstrVal = SysAllocString (TEXT (""));
        return S_OK;
    } else {
        if ( m_hXcvPrinter == NULL )
            return Error(IDS_NO_XCVDATA, IID_Iasphelp, E_HANDLE);
        else { // Real case
            DWORD dwNeeded = 0;
            DWORD dwStatus = ERROR_SUCCESS;
            LPTSTR pszBuffer = NULL;

            XcvData(m_hXcvPrinter,
                    pszId,
                    NULL,            // Input Data
                    0,               // Input Data Size
                    (LPBYTE)NULL,    // Output Data
                    0,               // Output Data Size
                    &dwNeeded,       // size of output buffer server wants to return
                    &dwStatus);      // return status value from remote component

            if ( dwStatus !=  ERROR_INSUFFICIENT_BUFFER ) {
                return SetAspHelpScriptingError(dwStatus);
            } else {
                pszBuffer = (LPTSTR) LocalAlloc (LPTR, dwNeeded);

                if ( !XcvData(m_hXcvPrinter,
                              pszId,
                              NULL,                // Input Data
                              0,                   // Input Data Size
                              (LPBYTE)pszBuffer,   // Output Data
                              dwNeeded,            // Output Data Size
                              &dwNeeded,           // size of output buffer server wants to return
                              &dwStatus)
                     || dwStatus != ERROR_SUCCESS ) {         // return status value from remote component
                    if ( pszBuffer )
                        LocalFree (pszBuffer);
                    return SetAspHelpScriptingError(dwStatus);
                }

                *pbstrVal = SysAllocString(pszBuffer);
                LocalFree (pszBuffer);

                if ( ! *pbstrVal )
                    return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
                else
                    return S_OK;
            }
        }
    }
}

HRESULT Casphelp::GetXcvDataDword(LPCTSTR pszId, DWORD * pdwVal)
{
    *pdwVal = 0;

    if ( m_hXcvPrinter == NULL )
        return Error(IDS_NO_XCVDATA, IID_Iasphelp, E_HANDLE);
    else { // Real case
        DWORD dwStatus = ERROR_SUCCESS;
        DWORD dwBuffer;
        DWORD dwNeeded = sizeof (dwBuffer);
        if ( !XcvData(m_hXcvPrinter,
                      pszId,
                      NULL,                // Input Data
                      0,                   // Input Data Size
                      (LPBYTE)&dwBuffer,   // Output Data
                      sizeof (dwBuffer),            // Output Data Size
                      &dwNeeded,           // size of output buffer server wants to return
                      &dwStatus)
             || dwStatus != ERROR_SUCCESS ) {         // return status value from remote component
            return SetAspHelpScriptingError(dwStatus);
        }

        *pdwVal = dwBuffer;
        return S_OK;
    }
}


/*****************************************************************************\
* FUNCTION:         get_IsTCPMonSupported
*
* PURPOSE:          Get operation for IsTCPMonSupported property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the IsTCPMonSupported. (TRUE  if the specified
*                   printer is using TCP Monitor, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_IsTCPMonSupported(BOOL * pbVal)
{
    *pbVal = FALSE;

    if ( m_hPrinter == NULL )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    *pbVal = m_bTCPMonSupported;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_Color
*
* PURPOSE:          Get operation for Color property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the Color. (TRUE  if the specified
*                   printer supports Color, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Color(BOOL * pVal)
{
    *pVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_COLORDEVICE,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (BOOLEAN) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_Duplex
*
* PURPOSE:          Get operation for Duplex property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the Duplex. (TRUE  if the specified
*                   printer supports Duplex, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Duplex(BOOL * pVal)
{
    *pVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_DUPLEX,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (BOOL) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_MaximumResolution
*
* PURPOSE:          Get operation for MaximumResolution property
*
* ARGUMENTS:
*
*   pVal:           Return value of Maximum Resolution (in DPI)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_MaximumResolution(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD cbNeeded;

    DWORD dwRet = GetPrinterDataEx(m_hPrinter,
                                   SPLDS_DRIVER_KEY,
                                   SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                                   NULL,
                                   (LPBYTE) pVal,
                                   sizeof(DWORD),
                                   &cbNeeded);
    if ( dwRet != ERROR_SUCCESS ) {
        *pVal = 0;
        return SetAspHelpScriptingError(dwRet);
    }

    return S_OK;
}

STDMETHODIMP Casphelp::get_MediaReady(VARIANT * pVal)
{
    return GetPaperAndMedia(pVal, DC_MEDIAREADY);
}

/*****************************************************************************\
* FUNCTION:         get_PaperNames
*
* PURPOSE:          Get operation for PaperNames property
*
* ARGUMENTS:
*
*   pVal:           Return a list of supported paper names (in an array of BSTR)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PaperNames(VARIANT * pVal)
{
    return GetPaperAndMedia(pVal, DC_PAPERNAMES);
}

HRESULT Casphelp::GetPaperAndMedia(VARIANT * pVal, WORD wDCFlag)
{
    SAFEARRAY           *psa = NULL;
    SAFEARRAYBOUND      rgsabound[1];
    long                ix[1];
    VARIANT             var;
    DWORD               i;
    HRESULT             hr = E_FAIL;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     wDCFlag,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    LPTSTR lpMedia = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR) * dwRet * LENGTHOFPAPERNAMES);

    if ( !lpMedia )
        return SetAspHelpScriptingError(GetLastError());

    dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                               m_pInfo2->pPortName,
                               wDCFlag,
                               lpMedia,
                               NULL);
    if ( dwRet == DWERROR ) {
        hr = SetAspHelpScriptingError(GetLastError());
        goto BailOut;
    }

    // Paper Names are now in MULTI_SZ lpMedia
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwRet;

    // Create a SafeArray to eventually return
    if ( ! (psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound)) ) {
        hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
        goto BailOut;
    }

    VariantInit(&var);

    // Fill in the SafeArray
    for ( i = 0; i < dwRet; i++ ) {
        var.vt = VT_BSTR;
        if ( ! (var.bstrVal = SysAllocString(lpMedia + (i*LENGTHOFPAPERNAMES))) ) {
            hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            goto BailOut;
        }
        ix[0] = i;
        hr = SafeArrayPutElement(psa, ix, &var);
        if (FAILED ( hr )) {
            hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            goto BailOut;
        }
        VariantClear(&var);
    }

    // Assign good stuff to Out param
    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = psa;
    LocalFree(lpMedia);
    return S_OK;

    BailOut:
    LocalFree(lpMedia);
    if ( psa )
        SafeArrayDestroy(psa);

    return hr;
}

/*****************************************************************************\
* FUNCTION:         get_PageRate
*
* PURPOSE:          Get operation for PageRate property
*
* ARGUMENTS:
*
*   pVal:           Return a PageRate of the specified printer
*                   (Unit: PPM / CPS / LPM / IPM)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PageRate(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet;

    dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                               m_pInfo2->pPortName,
                               DC_PRINTRATE,
                               NULL,
                               NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (long) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_PageRateUnit
*
* PURPOSE:          Get operation for PageRate property
*
* ARGUMENTS:
*
*   pVal:           Return a Unit of the Page Rate of a specified printer
*                   (Unit: PPM / CPS / LPM / IPM)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PageRateUnit (long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_PRINTRATEUNIT,
                                     NULL,
                                     NULL);

    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (long) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_PortName
*
* PURPOSE:          Get operation for PortName property
*
* ARGUMENTS:
*
*   pVal:           Return the port name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PortName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pPortName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}

/*****************************************************************************\
* FUNCTION:         get_DriverName
*
* PURPOSE:          Get operation for DriverName property
*
* ARGUMENTS:
*
*   pVal:           Return the driver name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_DriverName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pDriverName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}


/*****************************************************************************\
* FUNCTION:         get_ComputerName
*
* PURPOSE:          Get operation for ComputerName property
*
* ARGUMENTS:
*
*   pVal:           Return the computer name of the server
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ComputerName(BSTR * pVal)
{
    if ( !(*pVal = SysAllocString (m_szComputerName)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

HRESULT Casphelp::SetAspHelpScriptingError(DWORD dwError)
{
    return (SetScriptingError(CLSID_asphelp, IID_Iasphelp, dwError));
}


/*****************************************************************************\
* FUNCTION:         get_LongPaperName
*
* PURPOSE:          Get operation for LongPaperName property
*                   Translate the short paper name to the long paper name
*
* ARGUMENTS:
*
*   bstrShortName:  The short paper name
*   pVal:           Pointer to the long paper name
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_LongPaperName(BSTR bstrShortName, BSTR * pVal)
{
    struct PaperNameMapping {
        LPCWSTR     pShortName;
        DWORD       dwLongNameID;
    };

    static const WCHAR      cHyphen         = L'-';
    static const WCHAR      cszUnknown[]    = L"Unknown";
    static const LPCWSTR    pMediaArray[]   = {
        L"-envelope", L"-white", L"-transparent", L"-coloured", NULL};

    static const PaperNameMapping nameMapping[] = {
        {L"iso-a0",             IDS_A0_841_X_1189_MM},
        {L"iso-a1",             IDS_A1_594_X_841_MM},
        {L"iso-a2",             IDS_A2_420_X_594_MM},
        {L"iso-a3",             IDS_A3_297_X_420_MM},
        {L"iso-a4",             IDS_A4_210_X_297_MM},
        {L"iso-a5",             IDS_A5_148_X_210_MM},
        {L"iso-a6",             IDS_A6_105_X_148_MM},
        {L"iso-a7",             IDS_A7_74_X_105_MM},
        {L"iso-a8",             IDS_A8_52_X_74_MM},
        {L"iso-a9",             IDS_A9_37_X_52_MM},
        {L"iso-a10",            IDS_A10_26_X_37_MM},
        {L"iso-b0",             IDS_B0_1000_X_1414_MM},
        {L"iso-b1",             IDS_B1_707_X_1000_MM},
        {L"iso-b2",             IDS_B2_500_X_707_MM},
        {L"iso-b3",             IDS_B3_353_X_500_MM},
        {L"iso-b4",             IDS_B4_250_X_353_MM},
        {L"iso-b5",             IDS_B5_176_X_250_MM},
        {L"iso-b6",             IDS_B6_125_X_176_MM},
        {L"iso-b7",             IDS_B7_88_X_125_MM},
        {L"iso-b8",             IDS_B8_62_X_88_MM},
        {L"iso-b9",             IDS_B9_44_X_62_MM},
        {L"iso-b10",            IDS_B10_31_X_44_MM},
        {L"iso-c0",             IDS_C0_917_X_1297_MM},
        {L"iso-c1",             IDS_C1_648_X_917_MM},
        {L"iso-c2",             IDS_C2_458_X_648_MM},
        {L"iso-c3",             IDS_C3_324_X_458_MM},
        {L"iso-c4",             IDS_C4_ENVELOPE_229_X_324_MM},
        {L"iso-c5",             IDS_C5_ENVELOPE_162_X_229_MM},
        {L"iso-c6",             IDS_C6_114_X_162_MM},
        {L"iso-c7",             IDS_C7_81_X_114_MM},
        {L"iso-c8",             IDS_C8_57_X_81_MM},
        {L"iso-designated",     IDS_DL_ENVELOPE_110_X_220_MM},
        {L"jis-b0",             IDS_B0_1030_X_1456_MM},
        {L"jis-b1",             IDS_B1_728_X_1030_MM},
        {L"jis-b2",             IDS_B2_515_X_728_MM},
        {L"jis-b3",             IDS_B3_364_X_515_MM},
        {L"jis-b4",             IDS_B4_257_X_364_MM},
        {L"jis-b5",             IDS_B5_182_X_257_MM},
        {L"jis-b6",             IDS_B6_128_X_182_MM},
        {L"jis-b7",             IDS_B7_91_X_128_MM},
        {L"jis-b8",             IDS_B8_64_X_91_MM},
        {L"jis-b9",             IDS_B9_45_X_64_MM},
        {L"jis-b10",            IDS_B10_32_X_45_MM},
        {L"na-letter",          IDS_LETTER_8_5_X_11_IN},
        {L"letter",             IDS_LETTER_8_5_X_11_IN},
        {L"na-legal",           IDS_LEGAL_8_5_X_14_IN},
        {L"legal",              IDS_LEGAL_8_5_X_14_IN},
        {L"na-10x13",           IDS_ENVELOPE_10X13},
        {L"na-9x12x",           IDS_ENVELOPE_9X12},
        {L"na-number-10",       IDS_ENVELOPE_10},
        {L"na-7x9",             IDS_ENVELOPE_7X9},
        {L"na-9x11x",           IDS_ENVELOPE_9X11},
        {L"na-10x14",           IDS_ENVELOPE_10X14},
        {L"na-number-9",        IDS_ENVELOPE_9},
        {L"na-6x9",             IDS_ENVELOPE_6X9},
        {L"na-10x15",           IDS_ENVELOPE_10X15},
        {L"a",                  IDS_ENGINEERING_A_8_5_X_11_IN},
        {L"b",                  IDS_ENGINEERING_B_11_X_17_IN},
        {L"c",                  IDS_ENGINEERING_C_17_X_22_IN},
        {L"d",                  IDS_ENGINEERING_D_22_X_34_IN},
        {L"e",                  IDS_ENGINEERING_E_34_X_44_IN},
        {NULL, 0}
    };

    const PaperNameMapping  *pMapping           = nameMapping;
    LPWSTR                  pTail               = NULL ;
    DWORD                   dwLongNameID        = 0;
    WCHAR                   szBuffer [cdwBufSize];
    PWSTR                   pBuffer             = szBuffer;
    HRESULT                 hr                  = S_OK;

    if ( !bstrShortName ) {
        hr =  E_POINTER;
    }

    if (SUCCEEDED (hr))
    {
        //
        //  find the last char '-'
        //
        pTail = wcsrchr(bstrShortName, cHyphen );
        if ( pTail ) {

            const LPCWSTR *pMedia = pMediaArray;

            while ( *pMedia ) {
                if ( !lstrcmpi (*pMedia, pTail) ) {
                    //
                    // Mark it to be NULL;
                    //
                    *pTail = 0;
                    break;
                }
                pMedia++;
            }
        }

        while ( pMapping->pShortName ) {
            if ( !lstrcmpi (pMapping->pShortName, bstrShortName) ) {
                //
                // Found a match
                //
                dwLongNameID = pMapping->dwLongNameID;
                break;
            }
            pMapping++;
        }

        if ( pTail )
            *pTail = cHyphen;

        if (dwLongNameID)
        {
            if ( !LoadString( _Module.GetResourceInstance(),
                              dwLongNameID, szBuffer, cdwBufSize) )
            {
                hr = SetAspHelpScriptingError(GetLastError());
            }

            if (SUCCEEDED (hr))
            {
                if ( !(*pVal = SysAllocString (pBuffer)) )
                {
                    hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
                }
            }
        }
        else
        {
            if ( !(*pVal = SysAllocString (cszUnknown)) )
            {
                hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
* FUNCTION:         get_MibErrorDscp
*
* PURPOSE:          Get operation for MibErrorDscp property
*                   Map the mib error code to the error description
*
* ARGUMENTS:
*
*   dwError:        The error code
*   pVal:           Pointer to the error description
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/

STDMETHODIMP Casphelp::get_MibErrorDscp(DWORD dwError, BSTR * pVal)
{
    static ErrorMapping errorMapping[] = {
        {1,     IDS_MIBERR_OTHER},
        {2,     IDS_MIBERR_UNKNOWN},
        {3,     IDS_MIBERR_COVEROPEN},
        {4,     IDS_MIBERR_COVERCLOSED},
        {5,     IDS_MIBERR_INTERLOCKOPEN},
        {6,     IDS_MIBERR_INTERLOCKCLOSED},
        {7,     IDS_MIBERR_CONFIGURATIONCHANGE},
        {8,     IDS_MIBERR_JAM},
        {501,   IDS_MIBERR_DOOROPEN},
        {502,   IDS_MIBERR_DOORCLOSED},
        {503,   IDS_MIBERR_POWERUP},
        {504,   IDS_MIBERR_POWERDOWN},
        {801,   IDS_MIBERR_INPUTMEDIATRAYMISSING},
        {802,   IDS_MIBERR_INPUTMEDIASIZECHANGE},
        {803,   IDS_MIBERR_INPUTMEDIAWEIGHTCHANGE},
        {804,   IDS_MIBERR_INPUTMEDIATYPECHANGE},
        {805,   IDS_MIBERR_INPUTMEDIACOLORCHANGE},
        {806,   IDS_MIBERR_INPUTMEDIAFORMPARTSCHANGE},
        {807,   IDS_MIBERR_INPUTMEDIASUPPLYLOW},
        {808,   IDS_MIBERR_INPUTMEDIASUPPLYEMPTY},
        {901,   IDS_MIBERR_OUTPUTMEDIATRAYMISSING},
        {902,   IDS_MIBERR_OUTPUTMEDIATRAYALMOSTFULL},
        {903,   IDS_MIBERR_OUTPUTMEDIATRAYFULL},
        {1001,  IDS_MIBERR_MARKERFUSERUNDERTEMPERATURE},
        {1002,  IDS_MIBERR_MARKERFUSEROVERTEMPERATURE},
        {1101,  IDS_MIBERR_MARKERTONEREMPTY},
        {1102,  IDS_MIBERR_MARKERINKEMPTY},
        {1103,  IDS_MIBERR_MARKERPRINTRIBBONEMPTY},
        {1104,  IDS_MIBERR_MARKERTONERALMOSTEMPTY},
        {1105,  IDS_MIBERR_MARKERINKALMOSTEMPTY},
        {1106,  IDS_MIBERR_MARKERPRINTRIBBONALMOSTEMPTY},
        {1107,  IDS_MIBERR_MARKERWASTETONERRECEPTACLEALMOSTFULL},
        {1108,  IDS_MIBERR_MARKERWASTEINKRECEPTACLEALMOSTFULL},
        {1109,  IDS_MIBERR_MARKERWASTETONERRECEPTACLEFULL},
        {1110,  IDS_MIBERR_MARKERWASTEINKRECEPTACLEFULL},
        {1111,  IDS_MIBERR_MARKEROPCLIFEALMOSTOVER},
        {1112,  IDS_MIBERR_MARKEROPCLIFEOVER},
        {1113,  IDS_MIBERR_MARKERDEVELOPERALMOSTEMPTY},
        {1114,  IDS_MIBERR_MARKERDEVELOPEREMPTY},
        {1301,  IDS_MIBERR_MEDIAPATHMEDIATRAYMISSING},
        {1302,  IDS_MIBERR_MEDIAPATHMEDIATRAYALMOSTFULL},
        {1303,  IDS_MIBERR_MEDIAPATHMEDIATRAYFULL},
        {1501,  IDS_MIBERR_INTERPRETERMEMORYINCREASE},
        {1502,  IDS_MIBERR_INTERPRETERMEMORYDECREASE},
        {1503,  IDS_MIBERR_INTERPRETERCARTRIDGEADDED},
        {1504,  IDS_MIBERR_INTERPRETERCARTRIDGEDELETED},
        {1505,  IDS_MIBERR_INTERPRETERRESOURCEADDED},
        {1506,  IDS_MIBERR_INTERPRETERRESOURCEDELETED},
        {1507,  IDS_MIBERR_INTERPRETERRESOURCEUNAVAILABLE},
        {0,     0}
    };

    ErrorMapping *pMapping = errorMapping;
    DWORD   dwErrorDscpID = 0;
    TCHAR   szBuffer [cdwBufSize];

    if ( !pVal )
        return E_POINTER;

    szBuffer[0] = 0;

    while ( pMapping->dwError ) {
        if ( pMapping->dwError == dwError ) {
            // Found a match
            dwErrorDscpID = pMapping->dwErrorDscpID;
            break;
        }
        pMapping++;
    }

    if ( dwErrorDscpID ) {
        if ( !LoadString( _Module.GetResourceInstance(),
                          dwErrorDscpID, szBuffer, cdwBufSize) )
            return SetAspHelpScriptingError(GetLastError());
    }

    if ( !(*pVal = SysAllocString (szBuffer)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         CalcJobETA
*
* PURPOSE:          Calculate Job Completion Time
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::CalcJobETA()
{
    if (m_pPrinter &&
        (m_pPrinter->CalJobEta() || GetLastError () == ERROR_INVALID_DATA) &&
        // If the error is ERROR_INVALID_DATA, m_dwJobCompletionMinute = -1
        (m_pPrinter->GetJobEtaData (m_dwJobCompletionMinute,
                                    m_dwPendingJobCount,
                                    m_dwAvgJobSize,
                                    m_dwAvgJobSizeUnit))) {
        m_bCalcJobETA = TRUE;
        return S_OK;
    }
    else
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
}

/*****************************************************************************\
*
* FUNCTION:         get_PendingJobCount
*
* PURPOSE:          Get the number of pending jobs. This value is calculated in
*                   CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The number of pending jobs
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PendingJobCount(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwPendingJobCount;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_JobCompletionMinute
*
* PURPOSE:          Get the minute when the pending jobs are expected to complete.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the minute
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_JobCompletionMinute(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwJobCompletionMinute;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_AvgJobSizeUnit
*
* PURPOSE:          Get the unit (either PagePerJob or BytePerJob) of the
*                   average job size.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the unit
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_AvgJobSizeUnit(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwAvgJobSizeUnit;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_AvgJobSize
*
* PURPOSE:          Get the average job size.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the average job size
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_AvgJobSize(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwAvgJobSize;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;

}

/*****************************************************************************\
*
* FUNCTION:         get_Status
*
* PURPOSE:          Get the printer status.
*                   The difference between Status and the one got
*                   from PRINTER_INFO_2 is that when the printer is offline
*                   This function return a status with PRINTE_STATUS_OFFLINE
*                   set.
*
* ARGUMENTS:
*
*   pVal:           The value of the average job size
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Status(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    *pVal = m_pInfo2->Status;
    return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_ErrorDscp
*
* PURPOSE:          Convert the error code to a descriptive string.
*
* ARGUMENTS:
*
*   lErrCode:       The error code
*   pVal:           Pointer to the descriptive string.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ErrorDscp(long lErrCode, BSTR * pVal)
{

    static ErrorMapping errorMapping[] = {
        {ERROR_NOT_SUPPORTED,       IDS_ERROR_CPUNOTSUPPORTED},
        {ERROR_DRIVER_NOT_FOUND,    IDS_ERROR_DRIVERNOTFOUND},
        {ERROR_WPNPINST_TERMINATED, IDS_ERROR_WPNPINST_TERMINATED},
        {ERROR_INTERNAL_SERVER,     IDS_ERROR_INTERNAL_SERVER},
        {ERROR_SERVER_DISK_FULL,    IDS_ERROR_SERVER_DISK_FULL},
        {ERROR_TRUST_E_NOSIGNATURE, IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_SPAPI_E_NO_CATALOG,  IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_TRUST_E_BAD_DIGEST,  IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_LOCAL_PRINTER_ACCESS,IDS_ERROR_LOCAL_PRINTER_ACCESS},
        {ERROR_IE_SECURITY_DENIED,  IDS_ERROR_IE_SECURITY_DENIED},
        {CRYPT_E_FILE_ERROR,        IDS_CRYPT_E_FILE_ERROR},
        {0, 0}
    };

    ErrorMapping *pMapping = errorMapping;
    DWORD   dwErrorDscpID = 0;
    DWORD   dwError = ((DWORD)lErrCode) & 0xFFFF;
    TCHAR   szBuffer [cdwBufSize];

    if ( !pVal )
        return E_POINTER;

    szBuffer[0] = 0;

    while ( pMapping->dwError ) {
        if ( pMapping->dwError == dwError ) {
            // Found a match
            dwErrorDscpID = pMapping->dwErrorDscpID;
            break;
        }
        pMapping++;
    }

    if ( dwErrorDscpID ) {
        if ( !LoadString( _Module.GetResourceInstance(),
                          dwErrorDscpID, szBuffer, cdwBufSize) )
            return SetAspHelpScriptingError(GetLastError());
    }
    else {

        if ( !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwError,
                            0,
                            szBuffer,
                            cdwBufSize,
                            NULL) ) {
            return SetAspHelpScriptingError(GetLastError());
        }
    }

    if ( !(*pVal = SysAllocString (szBuffer)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_ShareName
*
* PURPOSE:          Get operation for ShareName property
*
* ARGUMENTS:
*
*   pVal:           Return the share name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ShareName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pShareName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}

STDMETHODIMP Casphelp::get_IsCluster(BOOL * pbVal)
{
    DWORD dwClusterState;

    *pbVal = FALSE;

    if (GetNodeClusterState (NULL, &dwClusterState) == ERROR_SUCCESS &&
        (dwClusterState & ClusterStateRunning)) {

        *pbVal = TRUE;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\asptlb.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ASPTypeLibrary */

#ifndef _ASPTypeLibrary_H_
#define _ASPTypeLibrary_H_

DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0L,0xA85C,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IStringList,0xD97A6DA0L,0xA85D,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IStringList */
#undef INTERFACE
#define INTERFACE IStringList

DECLARE_INTERFACE_(IStringList, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IStringList methods */
    STDMETHOD(get_Item)(THIS_ VARIANT i, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* cStrRet) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0L,0xA85F,0x11DF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequestDictionary */
#undef INTERFACE
#define INTERFACE IRequestDictionary

DECLARE_INTERFACE_(IRequestDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequestDictionary methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequest,0xD97A6DA0L,0xA861,0x11CF,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequest */
#undef INTERFACE
#define INTERFACE IRequest

DECLARE_INTERFACE_(IRequest, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequest methods */
    STDMETHOD(get_Item)(THIS_ BSTR bstrVar, IDispatch * FAR* ppObjReturn) PURE;
    STDMETHOD(get_QueryString)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Form)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Body)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ServerVariables)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ClientCertificate)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
};

DEFINE_GUID(CLSID_Request,0x920C25D0L,0x25D9,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Request;
#endif

DEFINE_GUID(IID_IReadCookie,0x71EAF260L,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

/* Definition of interface: IReadCookie */
#undef INTERFACE
#define INTERFACE IReadCookie

DECLARE_INTERFACE_(IReadCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IReadCookie methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0L,0xA862,0x11CF,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IWriteCookie */
#undef INTERFACE
#define INTERFACE IWriteCookie

DECLARE_INTERFACE_(IWriteCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWriteCookie methods */
    STDMETHOD(put_Item)(THIS_ VARIANT key, BSTR bstrValue) PURE;
    STDMETHOD(put_Expires)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(put_Domain)(THIS_ BSTR bstrDomain) PURE;
    STDMETHOD(put_Path)(THIS_ BSTR bstrPath) PURE;
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL fSecure) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IResponse,0xD97A6DA0L,0xA864,0x11CF,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IResponse */
#undef INTERFACE
#define INTERFACE IResponse

DECLARE_INTERFACE_(IResponse, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IResponse methods */
    STDMETHOD(get_Buffer)(THIS_ VARIANT_BOOL FAR* fIsBuffering) PURE;
    STDMETHOD(put_Buffer)(THIS_ VARIANT_BOOL fIsBuffering) PURE;
    STDMETHOD(get_ContentType)(THIS_ BSTR FAR* pbstrContentTypeRet) PURE;
    STDMETHOD(put_ContentType)(THIS_ BSTR bstrContentType) PURE;
    STDMETHOD(get_Expires)(THIS_ VARIANT FAR* pvarExpiresMinutesRet) PURE;
    STDMETHOD(put_Expires)(THIS_ long lExpiresMinutes) PURE;
    STDMETHOD(get_ExpiresAbsolute)(THIS_ VARIANT FAR* pvarExpiresRet) PURE;
    STDMETHOD(put_ExpiresAbsolute)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppCookies) PURE;
    STDMETHOD(get_Status)(THIS_ BSTR FAR* pbstrStatusRet) PURE;
    STDMETHOD(put_Status)(THIS_ BSTR bstrStatus) PURE;
    STDMETHOD(Add)(THIS_ BSTR bstrHeaderValue, BSTR bstrHeaderName) PURE;
    STDMETHOD(AddHeader)(THIS_ BSTR bstrHeaderName, BSTR bstrHeaderValue) PURE;
    STDMETHOD(AppendToLog)(THIS_ BSTR bstrLogEntry) PURE;
    STDMETHOD(BinaryWrite)(THIS_ VARIANT varInput) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
    STDMETHOD(Redirect)(THIS_ BSTR bstrURL) PURE;
    STDMETHOD(Write)(THIS_ VARIANT varText) PURE;
    STDMETHOD(WriteBlock)(THIS_ short iBlockNumber) PURE;
};

DEFINE_GUID(CLSID_Response,0x46E19BA0L,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Response;
#endif

DEFINE_GUID(IID_ISessionObject,0xD97A6DA0L,0xA865,0x11CF,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: ISessionObject */
#undef INTERFACE
#define INTERFACE ISessionObject

DECLARE_INTERFACE_(ISessionObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ISessionObject methods */
    STDMETHOD(get_SessionID)(THIS_ BSTR FAR* pbstrRet) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plvar) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lvar) PURE;
    STDMETHOD(Abandon)(THIS) PURE;
};

DEFINE_GUID(CLSID_Session,0x509F8F20L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Session;
#endif

DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0L,0xA866,0x11CF,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IApplicationObject */
#undef INTERFACE
#define INTERFACE IApplicationObject

DECLARE_INTERFACE_(IApplicationObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationObject methods */
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(Lock)(THIS) PURE;
    STDMETHOD(UnLock)(THIS) PURE;
};

DEFINE_GUID(CLSID_Application,0x7C3BAF00L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Application;
#endif

DEFINE_GUID(IID_IServer,0xD97A6DA0L,0xA867,0x11CF,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IServer */
#undef INTERFACE
#define INTERFACE IServer

DECLARE_INTERFACE_(IServer, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IServer methods */
    STDMETHOD(get_ScriptTimeout)(THIS_ long FAR* plTimeoutSeconds) PURE;
    STDMETHOD(put_ScriptTimeout)(THIS_ long lTimeoutSeconds) PURE;
    STDMETHOD(CreateObject)(THIS_ BSTR bstrProgID, IDispatch * FAR* ppDispObject) PURE;
    STDMETHOD(HTMLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
    STDMETHOD(MapPath)(THIS_ BSTR bstrLogicalPath, BSTR FAR* pbstrPhysicalPath) PURE;
    STDMETHOD(URLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
};

DEFINE_GUID(CLSID_Server,0xA506D160L,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Server;
#endif

DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IScriptingContext */
#undef INTERFACE
#define INTERFACE IScriptingContext

DECLARE_INTERFACE_(IScriptingContext, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptingContext methods */
    STDMETHOD(get_Request)(THIS_ IRequest FAR* FAR* ppRequest) PURE;
    STDMETHOD(get_Response)(THIS_ IResponse FAR* FAR* ppResponse) PURE;
    STDMETHOD(get_Server)(THIS_ IServer FAR* FAR* ppServer) PURE;
    STDMETHOD(get_Session)(THIS_ ISessionObject FAR* FAR* ppSession) PURE;
    STDMETHOD(get_Application)(THIS_ IApplicationObject FAR* FAR* ppApplication) PURE;
};

DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus
class ScriptingContext;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\dsprintq.cpp ===
// DSPrintQueue.cpp : Implementation of CDSPrintQueue
#include "stdafx.h"
#include "oleprn.h"
#include "DSPrintQ.h"
#include "winsprlp.h"

/////////////////////////////////////////////////////////////////////////////
// CDSPrintQueue

STDMETHODIMP CDSPrintQueue::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IDSPrintQueue,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



CDSPrintQueue::CDSPrintQueue()
{
	m_bstrContainer         = NULL;
	m_bstrName		        = NULL;
	m_bstrUNCName	        = NULL;
	m_bstrADsPath	        = NULL;
    m_pfnPublishPrinter     = (BOOL (*)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD)) NULL;
    m_hWinspool             = NULL;
}


CDSPrintQueue::~CDSPrintQueue()
{
	SysFreeString(m_bstrContainer);
	SysFreeString(m_bstrName);
	SysFreeString(m_bstrUNCName);
	SysFreeString(m_bstrADsPath);

    if (!m_hWinspool)
        FreeLibrary(m_hWinspool);
}



STDMETHODIMP CDSPrintQueue::get_UNCName(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrUNCName) {
        if (!(*ppVal = SysAllocString(m_bstrUNCName)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_UNCName(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrUNCName = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}

STDMETHODIMP CDSPrintQueue::get_Name(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrName) {
        if (!(*ppVal = SysAllocString(m_bstrName)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_Name(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrName = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}

STDMETHODIMP CDSPrintQueue::get_Container(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrContainer) {
        if (!(*ppVal = SysAllocString(m_bstrContainer)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_Container(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrContainer = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}


STDMETHODIMP CDSPrintQueue::Publish(DWORD dwAction)
{
    DWORD   dwRet = ERROR_SUCCESS;
    PWSTR   pszADsPath = NULL;

    // Load PublishPrinter
    if (!m_pfnPublishPrinter) {

        if (!m_hWinspool && !(m_hWinspool = LoadLibraryFromSystem32(L"Winspool.drv")))
            return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, GetLastError());

        if (!(m_pfnPublishPrinter = (BOOL (*)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD))
                                    GetProcAddress(m_hWinspool, (LPCSTR) 217)))
            return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, GetLastError());
    }

    // Publish the Printer
    if (!m_pfnPublishPrinter((HWND) NULL, m_bstrUNCName, m_bstrContainer, m_bstrName, &pszADsPath, dwAction)) {

        dwRet = GetLastError();

        if (pszADsPath) {
            if (dwAction == PUBLISHPRINTER_FAIL_ON_DUPLICATE && dwRet == ERROR_FILE_EXISTS)
                m_bstrADsPath = SysAllocString(pszADsPath);

            GlobalFree(pszADsPath);
        }

    } else if (pszADsPath) {

        m_bstrADsPath = SysAllocString(pszADsPath);
        GlobalFree(pszADsPath);
    }

    return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, dwRet);
}


STDMETHODIMP CDSPrintQueue::get_Path(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrADsPath) {
        if (!(*ppVal = SysAllocString(m_bstrADsPath)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\custom.cpp ===
/*****************************************************************************\
* MODULE:       custom.cpp
*
* PURPOSE:      OEM Customization support
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     10/10/97  babakj    Created
*
\*****************************************************************************/

#include "stdafx.h"
#include "oleprn.h"
#include "asphelp.h"


TCHAR cszEverestVirRoot[]    = TEXT("\\web\\printers");
TCHAR cszManufacturerKey[]   = TEXT("PnPData");
TCHAR cszManufacturerValue[] = TEXT("Manufacturer");

#define DEFAULTASPPAGE         TEXT("Page1.asp")


//
// Caller allocs memory for pMonitorname.
//
// pMonitorName untouched if failure.
//
BOOL Casphelp::GetMonitorName( LPTSTR pMonitorName )
{
    PPORT_INFO_2 pPortInfo2 = NULL;
    BOOL fRet = FALSE;
    DWORD dwNeeded, dwReturned;


    // Now get all ports to find a match from.
    LPTSTR  lpszServerName = m_pInfo2 ? m_pInfo2->pServerName : NULL;

    if( EnumPorts(lpszServerName, 2, NULL, 0, &dwNeeded, &dwReturned) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPortInfo2 = (PPORT_INFO_2)LocalAlloc( LPTR, dwNeeded))) ||
        (!EnumPorts( lpszServerName , 2, (LPBYTE)pPortInfo2, dwNeeded, &dwNeeded, &dwReturned ))) {

        LocalFree( pPortInfo2 );
        SetAspHelpScriptingError(GetLastError());
        return FALSE;
    }


    for( DWORD i=0; i < dwReturned; i++ )
        if( !lstrcmpi( pPortInfo2[i].pPortName, m_pInfo2->pPortName )) {
            // Some monitors (like LPRMON) do not fill in pMonitorName, so we ignore them.
            if( pPortInfo2[i].pMonitorName ) {
                lstrcpy( pMonitorName, pPortInfo2[i].pMonitorName );
                fRet = TRUE;
            }
            break;
        }

    LocalFree( pPortInfo2 );

    return fRet;
}

//
// Get the model name (aka driver name) of the printer
//
// Caller allocs memory for pModel.
//
BOOL Casphelp::GetModel( LPTSTR pModel )
{
    if (!m_pInfo2)
    {
        Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
        return FALSE;
    }

    lstrcpy( pModel, m_pInfo2->pDriverName );
    return TRUE;
}



//
// Get the Manufacturer name (aka driver name) of the printer
//
// Caller allocs memory for pManufacturer. Assumed to be the size of MAX_PATH * sizeof(TCHAR)
//
BOOL Casphelp::GetManufacturer( LPTSTR pManufacturer )
{
    if (!m_hPrinter)
    {
        Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
        return FALSE;
    }

    DWORD dwNeeded, dwType, dwRet;


    dwRet = GetPrinterDataEx( m_hPrinter,
                                  cszManufacturerKey,
                                  cszManufacturerValue,
                                  &dwType,
                                  (LPBYTE) pManufacturer,
                                  sizeof(TCHAR) * MAX_PATH,
                                  &dwNeeded);

    if (dwRet != ERROR_SUCCESS)
    {
        SetAspHelpScriptingError(dwRet);
        return FALSE;
    }
    else
        return TRUE;
}



//
// Returns:
//       bDeviceASP == TRUE:  The relative path to the ASP file if the printer has INF-based ASP support.
//       bDeviceASP == FALSE: The relative path to the ASP file if the printer has per-manufacturer ASP support (i.e.
//                            ASP support just based on its manufacturer name, rather than per model.
//
// Caller allocs memory for pAspPage.
//
// - pASPPage untouched if failure.
//
BOOL Casphelp::IsCustomASP( BOOL bDeviceASP, LPTSTR pASPPage )
{
    TCHAR  szRelPath   [MAX_PATH];    // Path relative to Winnt\web\printers, e.g. HP\LJ4si\page1.asp or .\hp (witout the .\)
    TCHAR  szFinalPath [MAX_PATH];    // Absolute path for szRelPath.
    int    nLen;


    // The Printer virtual dir assumed to be winnt\web\printers. Construct it.

    if( !GetWindowsDirectory( szFinalPath, COUNTOF(szFinalPath)))      // Return value is the length in chars w/o null char.
        return FALSE;

    // Append web\printers to the end

    // Fix the use of c-runtime calls later (T version, not W). Yet again, ASPHELP interface is server-side only.
    nLen = wcslen(szFinalPath);   // the null char not counted
    wsprintf( &szFinalPath[nLen], L"%ws", cszEverestVirRoot );


    // Prepare the relative path.

    if( !GetManufacturer( szRelPath ))
        return FALSE;

    if( bDeviceASP ) {

        // Add a '\' before we add the model name
        nLen = wcslen(szRelPath);   // the null char not counted
        wsprintf( &szRelPath[nLen], L"\\" );

        // Append the Model name
        nLen = wcslen(szRelPath);   // the null char not counted
        if( !GetModel( &szRelPath[nLen] ))
            return FALSE;
    }

    // Append "page1.asp" to the end.
    nLen = wcslen(szRelPath);   // the null char not counted
    wsprintf( &szRelPath[nLen], L"\\%ws", DEFAULTASPPAGE );


    // At this point, szRelPath should be something like HP\LJ4si\page1.asp or HP\page1.asp.


    // Make an absolute path by concatanating szRelPath and szFinalPath
    nLen = wcslen(szFinalPath);   // the null char not counted
    wsprintf( &szFinalPath[nLen], L"\\%ws", szRelPath );


    // See if the file exists.
    if( (DWORD)(-1) == GetFileAttributes( szFinalPath ))
        return FALSE;     // The file does not exist
    else {
        lstrcpy( pASPPage, szRelPath );   // The file exists, so the printer has per device or per manufacturer customization.
        return TRUE;
    }
}


//
// Returns:  The relative path to the default ASP file, i.e. page1.asp, if the printer supports RFC 1759.
//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::IsSnmpSupportedASP( LPTSTR pASPPage )
{
    BOOL   fIsSNMPSupported;
    HRESULT hr;


    hr = get_SNMPSupported( &fIsSNMPSupported );

    if( FAILED( hr ))
        return FALSE;

    if( fIsSNMPSupported )
        lstrcpy( pASPPage, DEFAULTASPPAGE );
    else
        *pASPPage = 0;        // Return an empty string. Not an error case.

    return TRUE;
}


//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPageForUniversalMonitor( LPTSTR pASPPage )
{
    if( !IsCustomASP( TRUE, pASPPage ))              // Check for device ASP
        if( !IsCustomASP( FALSE, pASPPage ))         // Check for manufacturer ASP
            if( !IsSnmpSupportedASP( pASPPage ))     // Check for SNMP support
                return FALSE;

    return TRUE;
}

//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPageForOtherMonitors( LPTSTR pMonitorName, LPTSTR pASPPage )
{
    TCHAR  szRelPath   [MAX_PATH];    // Path relative to Winnt\web\printers, e.g. LexmarkMon\page1.asp
    TCHAR  szFinalPath [MAX_PATH];    // Absolute path for szRelPath.
    int    nLen;


    // The Printer virtual dir assumed to be winnt\web\printers. Construct it.

    if( !GetWindowsDirectory( szFinalPath, COUNTOF(szFinalPath)))      // Return value is the length in chars w/o null char.
        return FALSE;

    // Append web\printers to the end

    // Fix the use of c-runtime calls later (T version, not W). Yet again, ASPHELP interface is server-side only.
    nLen = wcslen(szFinalPath);   // the null char not counted
    wsprintf( &szFinalPath[nLen], L"%ws", cszEverestVirRoot );


    // Prepare the relative path.

    lstrcpy( szRelPath, pMonitorName );

    // Append "page1.asp" to the end.
    nLen = wcslen(szRelPath);   // the null char not counted
    wsprintf( &szRelPath[nLen], L"\\%ws", DEFAULTASPPAGE );


    // At this point, szRelPath should be something like LexmarkMon\page1.asp


    // Make an absolute path by concatanating szRelPath and szFinalPath
    nLen = wcslen(szFinalPath);   // the null char not counted
    wsprintf( &szFinalPath[nLen], L"\\%ws", szRelPath );


    // See if the file exists.
    if( (DWORD)(-1) == GetFileAttributes( szFinalPath ))
        return FALSE;     // The file does not exist
    else {
        lstrcpy( pASPPage, szRelPath );   // The file exists, so the printer has per device or per manufacturer customization.
        return TRUE;
    }
}



//
// Returns a buffer containing the relative path of the ASP, or an empty string.
//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPage( LPTSTR pASPPage )
{

    if( m_bTCPMonSupported ) {
        // The printer is using the Universal monitor
        if( !GetASPPageForUniversalMonitor( pASPPage ))
            return FALSE;
    }
    else {
        TCHAR szMonitorName[MAX_PATH];

        if (!GetMonitorName(szMonitorName))
            return FALSE;

        // The printer is NOT using the Universal monitor
        if( !GetASPPageForOtherMonitors( szMonitorName, pASPPage ))
            return FALSE;

    }
    return TRUE;
}


// STDMETHODIMP means "HRESULT _stdcall"

STDMETHODIMP Casphelp::get_AspPage(DWORD dwPage, BSTR * pbstrVal)
{
    TCHAR   szASPPage[MAX_PATH];
    LPTSTR  pUrl;

    if (!pbstrVal)
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);

    if (m_hPrinter == NULL)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if( !GetASPPage( szASPPage ))
        return Error(IDS_DATA_NOT_SUPPORTED, IID_Iasphelp, E_NOTIMPL);

    // Encode the URL by replacing ' ' with %20, etc.
    if (! (pUrl = EncodeString (szASPPage, TRUE)))
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);

    if (!(*pbstrVal = SysAllocString( pUrl ))) {
        LocalFree (pUrl);
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);
    }

    if (pUrl)
        LocalFree (pUrl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\dsprintq.h ===
// DSPrintQueue.h : Declaration of the CDSPrintQueue

#ifndef __DSPRINTQUEUE_H_
#define __DSPRINTQUEUE_H_

/////////////////////////////////////////////////////////////////////////////
// CDSPrintQueue
class ATL_NO_VTABLE CDSPrintQueue :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDSPrintQueue, &CLSID_DSPrintQueue>,
	public ISupportErrorInfo,
	public IDispatchImpl<IDSPrintQueue, &IID_IDSPrintQueue, &LIBID_OLEPRNLib>
{
public:
	CDSPrintQueue();
	~CDSPrintQueue();

DECLARE_REGISTRY_RESOURCEID(IDR_DSPRINTQUEUE)

BEGIN_COM_MAP(CDSPrintQueue)
	COM_INTERFACE_ENTRY(IDSPrintQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDSPrintQueue
public:
	STDMETHOD(get_Path)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Publish)(DWORD dwAction);
	STDMETHOD(get_Container)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Container)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_UNCName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UNCName)(/*[in]*/ BSTR newVal);

private:
	BSTR	    m_bstrContainer;
	BSTR	    m_bstrName;
	BSTR	    m_bstrUNCName;
	BSTR	    m_bstrADsPath;
    HINSTANCE   m_hWinspool;
    BOOL        (*m_pfnPublishPrinter)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD);
};

#endif //__DSPRINTQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\asphelp.h ===
/*****************************************************************************\
* MODULE:       asphelp.h
*
* PURPOSE:      Declaration of the Casphelp
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*
\*****************************************************************************/

#ifndef __ASPHELP_H_
#define __ASPHELP_H_

#include <asptlb.h>         // Active Server Pages Definitions

#define LENGTHOFPAPERNAMES  64  // From DeviceCapabilities DC_PAPERNAMES
#define STANDARD_SNMP_MONITOR_NAME L"TCPMON.DLL"    // The dll name of the Universal SNMP monitor.
#define PAGEPERJOB  1
#define BYTEPERJOB  2

typedef struct ErrorMapping {
    DWORD   dwError;
    DWORD   dwErrorDscpID;
} ErrorMapping;

/////////////////////////////////////////////////////////////////////////////
// Casphelp
class ATL_NO_VTABLE Casphelp :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<Casphelp, &CLSID_asphelp>,
    public ISupportErrorInfoImpl<&IID_Iasphelp>,
    public IDispatchImpl<Iasphelp, &IID_Iasphelp, &LIBID_OLEPRNLib>
{
public:
    Casphelp();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ASPHELP)

BEGIN_COM_MAP(Casphelp)
    COM_INTERFACE_ENTRY(Iasphelp)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Iasphelp
public:
     ~Casphelp();

    // These properties do not require calling Open at first
    STDMETHOD(get_ErrorDscp)        (long lErrCode, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_MediaReady)       (/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_MibErrorDscp)     (DWORD dwError, /*[out, retval]*/ BSTR *pVal);

    STDMETHOD(Open)                 (BSTR bstrPrinterName);
    STDMETHOD(Close)();
	
    // Printer information
    STDMETHOD(get_AspPage)          (DWORD dwPage, /*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_Color)            (/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Community)        (/*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_ComputerName)     (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DriverName)       (/*[out, retval]*/ BSTR * pbstrVal);
    STDMETHOD(get_Duplex)           (/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_IPAddress)        (/*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_IsHTTP)           (/*[out, retval]*/ BOOL *pbVal);
    STDMETHOD(get_IsTCPMonSupported)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_LongPaperName)    (BSTR bstrShortName, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_MaximumResolution)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PageRate)         (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PageRateUnit)     (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PaperNames)       (/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_PortName)         (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SNMPDevice)       (/*[out, retval]*/ DWORD *pdwVal);
    STDMETHOD(get_SNMPSupported)    (/*[out, retval]*/ BOOL *pbVal);
    STDMETHOD(get_Status)           (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_ShareName)        (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_IsCluster)        (/*[out, retval]*/ BOOL *pbVal);

    // Job completion time estimate
    STDMETHOD(CalcJobETA)           ();
    STDMETHOD(get_AvgJobSize)       (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_AvgJobSizeUnit)   (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_JobCompletionMinute)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PendingJobCount)  (/*[out, retval]*/ long *pVal);

    //Active Server Pages Methods
    STDMETHOD(OnStartPage)(IUnknown* IUnk);
    STDMETHOD(OnEndPage)();

private:

    void    Cleanup();
    BOOL    DecodeString (LPTSTR pPrinterName, LPTSTR pDecodedName, TCHAR chMark);
    BOOL    DecodeStringA (LPSTR pPrinterName, LPSTR pDecodedName, char chMark);
    DWORD   GetPPM();
    DWORD   GetWaitingMinutesPPM (DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob);

    HRESULT AllocGetPrinterInfo2(PPRINTER_INFO_2 *ppInfo2);
    HRESULT GetPaperAndMedia(VARIANT * pVal, WORD wDCFlag);
    HRESULT GetXcvDataBstr(LPCTSTR pszId, BSTR *bStr);
    HRESULT GetXcvDataDword (LPCTSTR pszId, DWORD *dwVal);
    HRESULT SetAspHelpScriptingError(DWORD dwError);

    // The following block is for ASP customization.
    BOOL    GetMonitorName( LPTSTR pMonitorName );
    BOOL    GetModel( LPTSTR pModel );
    BOOL    GetManufacturer( LPTSTR pManufacturer );
    BOOL    IsCustomASP( BOOL bDeviceASP, LPTSTR pASPPage );
    BOOL    IsSnmpSupportedASP( LPTSTR pASPPage );
    BOOL    GetASPPageForUniversalMonitor( LPTSTR pASPPage );
    BOOL    GetASPPageForOtherMonitors( LPTSTR pMonitorName, LPTSTR pASPPage );
    BOOL    GetASPPage( LPTSTR pASPPage );

    static  const DWORD         cdwBufSize      = 512;

    CComPtr<IRequest> m_piRequest;                  //Request Object
    CComPtr<IResponse> m_piResponse;                //Response Object
    CComPtr<ISessionObject> m_piSession;            //Session Object
    CComPtr<IServer> m_piServer;                    //Server Object
    CComPtr<IApplicationObject> m_piApplication;    //Application Object
    BOOL m_bOnStartPageCalled;                      //OnStartPage successful?
    TCHAR m_szComputerName[MAX_COMPUTERNAME_LENGTH+1];

    HANDLE  m_hPrinter;                              //Handle to the printer
    HANDLE  m_hXcvPrinter;
    DWORD   m_dwAvgJobSize;
    DWORD   m_dwAvgJobSizeUnit;
    DWORD   m_dwJobCompletionMinute;
    DWORD   m_dwPendingJobCount;
    DWORD   m_dwSizePerJob;
    BOOL    m_bCalcJobETA;
    BOOL    m_bTCPMonSupported;
    class CPrinter  *m_pPrinter;
    PPRINTER_INFO_2 m_pInfo2;
};

#endif //__ASPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\olecvt.cpp ===
// OleCvt.cpp : Implementation of COleCvt
#include "stdafx.h"
#include "oleprn.h"
#include "OleCvt.h"


/////////////////////////////////////////////////////////////////////////////
// COleCvt

STDMETHODIMP COleCvt::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IOleCvt,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP COleCvt::OnStartPage (IUnknown* pUnk)
{
	if(!pUnk)
		return E_POINTER;

    if (m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER) 
        return E_ACCESSDENIED;

	CComPtr<IScriptingContext> spContext;
	HRESULT hr;

	// Get the IScriptingContext Interface
	hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
	if(FAILED(hr))
		return hr;

	// Get Request Object Pointer
	hr = spContext->get_Request(&m_piRequest);
	if(FAILED(hr))
	{
		spContext.Release();
		return hr;
	}

	// Get Response Object Pointer
	hr = spContext->get_Response(&m_piResponse);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		return hr;
	}
	
	// Get Server Object Pointer
	hr = spContext->get_Server(&m_piServer);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		return hr;
	}
	
	// Get Session Object Pointer
	hr = spContext->get_Session(&m_piSession);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		return hr;
	}

	// Get Application Object Pointer
	hr = spContext->get_Application(&m_piApplication);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		m_piSession.Release();
		return hr;
	}
	m_bOnStartPageCalled = TRUE;
	return S_OK;
}

STDMETHODIMP COleCvt::OnEndPage ()
{
    if (m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER) 
        return E_ACCESSDENIED;

	m_bOnStartPageCalled = FALSE;
	// Release all interfaces
	m_piRequest.Release();
	m_piResponse.Release();
	m_piServer.Release();
	m_piSession.Release();
	m_piApplication.Release();

	return S_OK;
}

HRESULT COleCvt::SetOleCvtScriptingError(DWORD dwError)
{
    return (SetScriptingError(CLSID_OleCvt, IID_IOleCvt, dwError));
}

STDMETHODIMP COleCvt::get_ToUtf8(BSTR bstrUnicode, BSTR * pVal)
{
    LPSTR   pszUtf8 = NULL;
    LPWSTR  pwszUnicodeStr = NULL;
    DWORD   rc;
    HRESULT hr = S_OK;

    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    // Convert the input unicode string to utf8
    if (! (rc = WideCharToMultiByte( CP_UTF8, 0, bstrUnicode, -1, NULL, 0, NULL, NULL ))) {
        goto Cleanup;
    }

    // Allocate the string
    if (! (pszUtf8 = (LPSTR) LocalAlloc (LPTR, rc)))
        goto Cleanup;

    if (! (rc = WideCharToMultiByte( CP_UTF8, 0, bstrUnicode, -1, pszUtf8, rc, NULL, NULL )))
        goto Cleanup;

    // Convert the string to unicode as if it is ANSI (preserve the UTF8 conversion)
    if (! (rc = MultiByteToWideChar( 1252, 0, pszUtf8, -1, NULL, 0)))
        goto Cleanup;

    // Allocate the string
    if (! (pwszUnicodeStr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * rc)))
        goto Cleanup;

    if (! (rc = MultiByteToWideChar( 1252, 0, pszUtf8, -1, pwszUnicodeStr, rc)))
        goto Cleanup;

    if (!(*pVal = SysAllocString (pwszUnicodeStr)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszUtf8)
        LocalFree (pszUtf8);
    if (pwszUnicodeStr)
        LocalFree (pwszUnicodeStr);

    return hr;
}

STDMETHODIMP COleCvt::get_EncodeUnicodeName(BSTR bstrSrcName, BSTR * pDstName)
{
    LPTSTR  pszEncodedName  = NULL;
    DWORD   dwSize          = 0;
    HRESULT hr              = S_OK;

    if (!bstrSrcName || !pDstName)
        return E_POINTER;

    EncodePrinterName (bstrSrcName, NULL, &dwSize);

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        goto Cleanup;

    if (!EncodePrinterName (bstrSrcName, pszEncodedName, &dwSize))
        goto Cleanup;

    if (!(*pDstName = SysAllocString (pszEncodedName)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return hr;
}

STDMETHODIMP COleCvt::get_DecodeUnicodeName(BSTR bstrSrcName, BSTR * pDstName)
{
    LPTSTR  pszDecodedName  = NULL;
    DWORD   dwSize          = 0;
    HRESULT hr              = S_OK;

    if (!bstrSrcName || !pDstName)
        return E_POINTER;

    DecodePrinterName (bstrSrcName, NULL, &dwSize);

    if (! (pszDecodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        goto Cleanup;

    if (!DecodePrinterName (bstrSrcName, pszDecodedName, &dwSize))
        goto Cleanup;

    if (!(*pDstName = SysAllocString (pszDecodedName)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszDecodedName) {
        LocalFree (pszDecodedName);
    }
    return hr;
}

// This function is to take the input string bstrString as if it wrer ANSI
// and then convert it back to unicode using whatever codepage specifed.
STDMETHODIMP COleCvt::get_ToUnicode(BSTR bstrString, long lCodePage, BSTR * pVal)
{
    LPSTR   pszStr = NULL;
    LPWSTR  pwszUnicodeStr = NULL;
    DWORD   rc;
    HRESULT hr = S_OK;

    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    // Convert the input unicode string to utf8
    if (! (rc = WideCharToMultiByte(CP_ACP, 0, bstrString, -1, NULL, 0, NULL, NULL ))) {
        goto Cleanup;
    }

    // Allocate the string
    if (! (pszStr = (LPSTR) LocalAlloc (LPTR, rc)))
        goto Cleanup;

    if (! (rc = WideCharToMultiByte( CP_ACP, 0, bstrString, -1, pszStr, rc, NULL, NULL )))
        goto Cleanup;

    // Convert the string to unicode as if it is ANSI (preserve the UTF8 conversion)
    if (! (rc = MultiByteToWideChar( lCodePage, 0, pszStr, -1, NULL, 0)))
        goto Cleanup;

    // Allocate the string
    if (! (pwszUnicodeStr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * rc)))
        goto Cleanup;

    if (! (rc = MultiByteToWideChar( lCodePage, 0, pszStr, -1, pwszUnicodeStr, rc)))
        goto Cleanup;

    if (!(*pVal = SysAllocString (pwszUnicodeStr)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszStr)
        LocalFree (pszStr);
    if (pwszUnicodeStr)
        LocalFree (pwszUnicodeStr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\oleinst.h ===
// oleInst.h : Declaration of the COleInstall

#ifndef __OLEINSTALL_H_
#define __OLEINSTALL_H_

#include "CPinst.h"         // Template for connection point

#define WM_ON_PROGRESS      (WM_USER+100)
#define WM_INSTALL_ERROR    (WM_USER+101)

#define FILEBUFSIZE         1024
#define MAXFILELEN          64
#define MAXTRY              10000
#define MAX_INET_RETRY      3
#define RET_SUCCESS         1
#define RET_SERVER_ERROR    2
#define RET_OTHER_ERROR     3

typedef class  OleInstallData {
public:
    LONG        m_lCount;
    LPTSTR      m_pszTempWebpnpFile;
    LPTSTR      m_pPrinterUncName;
    LPTSTR      m_pPrinterUrl;
    HWND        m_hwnd;
    BOOL        m_bValid;
    BOOL        m_bRPC;         // Should we do an RPC install?

    OleInstallData (LPTSTR      pPrinterUncName,
                    LPTSTR      pPrinterUrl, 
                    HWND        hwnd,
                    BOOL        m_bRPC);
    ~OleInstallData ();
    
} OleInstallData;


/////////////////////////////////////////////////////////////////////////////
// COleInstall
class ATL_NO_VTABLE COleInstall :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<COleInstall, &CLSID_OleInstall>,
    public COlePrnSecComControl<COleInstall>,
    public IDispatchImpl<IOleInstall, &IID_IOleInstall, &LIBID_OLEPRNLib>,
    public IProvideClassInfo2Impl<&CLSID_OleInstall, &DIID__InstallEvent, &LIBID_OLEPRNLib>,
    public IPersistStreamInitImpl<COleInstall>,
    public IPersistStorageImpl<COleInstall>,
    public IQuickActivateImpl<COleInstall>,
    public IOleControlImpl<COleInstall>,
    public IOleObjectImpl<COleInstall>,
    public IOleInPlaceActiveObjectImpl<COleInstall>,
    public IViewObjectExImpl<COleInstall>,
    public IOleInPlaceObjectWindowlessImpl<COleInstall>,
    public IDataObjectImpl<COleInstall>,
    public ISpecifyPropertyPagesImpl<COleInstall>,
    public CProxy_InstallEvents<COleInstall>,
    public IConnectionPointContainerImpl<COleInstall>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_OLEINSTALL)

BEGIN_COM_MAP(COleInstall)
    COM_INTERFACE_ENTRY(IOleInstall)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(COleInstall)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(COleInstall)
   CONNECTION_POINT_ENTRY(DIID__InstallEvent)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(COleInstall)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IOleInstall
public:
    STDMETHOD(OpenPrintersFolder)();
    STDMETHOD(InstallPrinter)(BSTR pbstrUncName, BSTR pbstrUrl);
    
    COleInstall();
    ~COleInstall();
    HRESULT     OnDraw(ATL_DRAWINFO& di);

private:
    HWND m_hwnd;
    LPTSTR      m_pPrinterUncName;          // holds the printers'UNC name
    LPTSTR      m_pPrinterUrl;              // holds the printer URL
    OleInstallData *m_pThreadData;

    HRESULT             InitWin (BOOL bRPC);
    
    static LRESULT CALLBACK WndProc(
                            HWND hWnd, 
                            UINT uMsg, 
                            WPARAM wParam, 
                            LPARAM lParam);
    
    static BOOL         WorkingThread(
                            void * pParam);
    
    static BOOL         StartInstall(
                            OleInstallData *pThreadData);
    
    static BOOL         SyncExecute(
                            LPTSTR pszFileName, 
                            int nShow);

    static DWORD        GetWebpnpFile(
                            OleInstallData *pData, 
                            LPTSTR pszURL,
                            LPTSTR *ppErrMsg);

    static HANDLE       GetTempFile(
                            LPTSTR pExtension, 
                            LPTSTR * ppFileName);

    static BOOL         IsHttpPreferred(void);

    static BOOL         GetHttpPrinterFile(
                            OleInstallData *pData, 
                            LPTSTR pbstrURL);

    static BOOL         InstallHttpPrinter(
                            OleInstallData *pData);

    static BOOL         CheckAndSetDefaultPrinter(void);
    
    static BOOL         UpdateUI (
                            OleInstallData *pData,
                            UINT message, 
                            WPARAM wParam);

    static BOOL         UpdateProgress (
                            OleInstallData *pData, 
                            DWORD dwProgress);

    static BOOL         UpdateError (
                            OleInstallData *pData);

    HRESULT             CanIOpenPrintersFolder(void);  
    
    HRESULT             CanIInstallRPC(IN LPTSTR lpszPrinter, IN LPTSTR lpszWebPrinter);

    static LPTSTR       RemoveURLVars(LPTSTR);      // Get rid of everything after ?

    static LPTSTR       GetNTPrint(void);

    static LPTSTR       CreatePrinterBaseName(
                            LPCTSTR lpszPrinterURL,
                            LPCTSTR lpszPrinterName);
    
};


#endif //__OLEINSTALL_H_

/******************************************************************
** End of File (oleinst.h)
******************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\oleprn.cpp ===
// oleprn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//  To build a separate proxy/stub DLL,
//  run nmake -f oleprnps.mk in the project directory.

#include "stdafx.h"
#include "stdafx.cpp"

#include "initguid.h"
#include "comcat.h"
#include "objsafe.h"

#include "oleprn.h"

#include "oleprn_i.c"

#include "prturl.h"

#ifndef WIN9X

#include "olesnmp.h"
#include "asphelp.h"
#include "AddPrint.h"
#include "DSPrintQ.h"
#include "OleCvt.h"

#endif

#include "oleInst.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_prturl, Cprturl)
#ifndef WIN9X
    OBJECT_ENTRY(CLSID_SNMP, CSNMP)
    OBJECT_ENTRY(CLSID_asphelp, Casphelp)
    OBJECT_ENTRY(CLSID_AddPrint, CAddPrint)
    OBJECT_ENTRY(CLSID_DSPrintQueue, CDSPrintQueue)
    OBJECT_ENTRY(CLSID_OleCvt, COleCvt)
#endif
    OBJECT_ENTRY(CLSID_OleInstall, COleInstall)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL bRet = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        bRet = COlePrnSecurity::InitStrings();
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
        COlePrnSecurity::DeallocStrings();
    }
        
    return bRet;    
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (FAILED(hr))
        return hr;    // Make sure the HKCR\Component Categories\{..catid...}

    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    int len = wcslen(catDescription);

    if (len>127)
        len = 127;

    wcsncpy(catinfo.szDescription, catDescription, len);

    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';
    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();
    return hr;
}

HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    // Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (SUCCEEDED(hr)) {
        // Register this category as being "implemented" by
        // the class.

        CATID rgcatid[1] ;
        rgcatid[0] = catid;
        hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
    return hr;
}

HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (SUCCEEDED(hr)) {
        // Unregister this category as being "implemented" by
        // the class.

        CATID rgcatid[1] ;
        rgcatid[0] = catid;

        hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // Mark as safe for scripting failure OK.
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib
    hr =  _Module.RegisterServer(TRUE);

    if (FAILED(hr)) return hr;

    // After we successfully register it, add the "safe* for scripting" feature
    hr = CreateComponentCategory(CATID_SafeForScripting,
                                 L"Controls that are safely scriptable");

    if (SUCCEEDED(hr)) {
        RegisterCLSIDInCategory(CLSID_prturl, CATID_SafeForScripting);
    }

    hr = CreateComponentCategory(CATID_SafeForInitializing,
                                 L"Controls safely initializable from persistent data");

    if (SUCCEEDED(hr)) {
        RegisterCLSIDInCategory(CLSID_prturl, CATID_SafeForInitializing);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    UnRegisterCLSIDInCategory (CLSID_prturl, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory (CLSID_prturl, CATID_SafeForInitializing);
    
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\oleinst.cpp ===
// oleInst.cpp : Implementation of COleInstall
#include "stdafx.h"
#include "oleprn.h"
#include "oleInst.h"
#include "printer.h"

/////////////////////////////////////////////////////////////////////////////
// COleInstall

const TCHAR * const g_szWindowClassName = TEXT("Ole Install Control");
const DWORD cdwSucessExitCode = 0xFFFFFFFF;

typedef DWORD (*pfnPrintUIEntry)(HWND,HINSTANCE,LPCTSTR,UINT);

#ifdef WIN9X
    const TCHAR g_szSplDir9X []     = TEXT("\\spool\\printers\\");
#endif

OleInstallData::OleInstallData (
    LPTSTR      pPrinterUncName,
    LPTSTR      pPrinterUrl,
    HWND        hwnd,
    BOOL        bRPC)
    :m_lCount (2),
    m_pPrinterUncName (NULL),
    m_pPrinterUrl (NULL),
    m_pszTempWebpnpFile (NULL),
    m_hwnd (hwnd),
    m_bValid (FALSE),
    m_bRPC(bRPC)
{
    if (AssignString (m_pPrinterUncName, pPrinterUncName)
        && AssignString (m_pPrinterUrl, pPrinterUrl))
        m_bValid = TRUE;
}

OleInstallData::~OleInstallData ()
{
    if (m_pszTempWebpnpFile) {
        DeleteFile (m_pszTempWebpnpFile);
        LocalFree (m_pszTempWebpnpFile);
    }

    LocalFree (m_pPrinterUncName);
    LocalFree (m_pPrinterUrl);
}


COleInstall::COleInstall()
            : m_hwnd (NULL),
              m_pPrinterUncName (NULL),
              m_pPrinterUrl (NULL),
              m_pThreadData (NULL)

{
    DisplayUIonDisallow(FALSE);         // We don't want IE displaying UI.
}

COleInstall::~COleInstall()
{
    if(m_hwnd)
    {
        if (m_pThreadData) {
            m_pThreadData->m_hwnd = NULL;
        }

        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }


    LocalFree (m_pPrinterUncName);
    LocalFree (m_pPrinterUrl);

    if (m_pThreadData) {
        if (InterlockedDecrement (& (m_pThreadData->m_lCount)) == 0) {
            delete (m_pThreadData);
        }
    }
}

HRESULT
COleInstall::OnDraw(
    ATL_DRAWINFO& di)
{
    return S_OK;
}


BOOL
COleInstall::UpdateUI (
    OleInstallData *pData,
    UINT message,
    WPARAM wParam)
{
    BOOL bRet = FALSE;

    if (pData->m_hwnd) {
        ::SendMessage (pData->m_hwnd, message, wParam, NULL);
        bRet =  TRUE;
    }

    return bRet;
}

BOOL
COleInstall::UpdateProgress (
    OleInstallData *pData,
    DWORD dwProgress)
{
    return UpdateUI (pData, WM_ON_PROGRESS, dwProgress);
}

BOOL
COleInstall::UpdateError (
    OleInstallData *pData)
{
    return UpdateUI (pData, WM_INSTALL_ERROR, GetLastError ());
}

HRESULT
COleInstall::InitWin (BOOL bRPC)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwThreadId;
    HANDLE      hThread = NULL;
    WNDCLASS    wc;

    // Create Window Class
    if (!::GetClassInfo(_Module.GetModuleInstance(), g_szWindowClassName, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = COleInstall::WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = g_szWindowClassName;

        if (!RegisterClass(&wc)) {
            return hr;
        }
    }

    m_hwnd = CreateWindow(g_szWindowClassName,
                          NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                          _Module.GetModuleInstance(), this);

    if (m_hwnd) {

        m_pThreadData = new OleInstallData (m_pPrinterUncName,
                                            m_pPrinterUrl,
                                            m_hwnd,
                                            bRPC);

        if (m_pThreadData && m_pThreadData->m_bValid) {

            if (hThread = ::CreateThread (NULL,
                                          0,
                                          (LPTHREAD_START_ROUTINE) &COleInstall::WorkingThread,
                                          m_pThreadData,
                                          0,
                                          &dwThreadId)) {
                CloseHandle (hThread);
                hr = S_OK;
            }
        }
    }

    return hr;

}


BOOL
COleInstall::WorkingThread(
    void * param)
{
    OleInstallData * pThreadData = (OleInstallData *) param;
    BOOL bRet = FALSE;

    if (pThreadData) {
        bRet = StartInstall (pThreadData);
    }

    return bRet;
}


BOOL
COleInstall::StartInstall(
    OleInstallData *pThreadData)
{
    HANDLE hServer = NULL;
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    BOOL bRet = FALSE;

#ifndef WIN9X
    CPrinter        Printer;
    HANDLE          hPrinter;
    PPRINTER_INFO_2 pPrinterInfo2  = NULL;
    LPTSTR          lpszPrinterURL = NULL;
#endif

    // Working thread
    if (!UpdateProgress (pThreadData, 0))
        goto Cleanup;

#ifndef WIN9X
    // Step one, check if the magic registry is set (force http connection)

    if (!IsHttpPreferred () && pThreadData->m_bRPC) {
        // Check RPC connections at first
        if (::AddPrinterConnection( (BSTR)pThreadData->m_pPrinterUncName)) {
            UpdateProgress (pThreadData, 50);
            if (CheckAndSetDefaultPrinter ()) {
                UpdateProgress (pThreadData, 100);
                bRet = TRUE;
            }
            goto Cleanup;
        }
    }

    // AddPrinterConnection failed. Since http installation always requires
    // administrator privilidge, We have to do a access check before we
    // try to down load the cab file

    if (!OpenPrinter (NULL, &hServer, &pd)) {
        // If this fails and it is because we do not have access, we should send a better error
        // message to the local user telling them that the do not have the ability to create
        // printers on the local machine

        if (GetLastError() == ERROR_ACCESS_DENIED) {
            SetLastError(ERROR_LOCAL_PRINTER_ACCESS);
        }
        goto Cleanup;
    }
    else
        ClosePrinter (hServer);

    //
    // Try the local CAB installation instead of downloading the cab, etc.
    // Need admin privaleges.
    //
    if( NULL != (lpszPrinterURL = RemoveURLVars( pThreadData->m_pPrinterUrl )) &&
        Printer.Open( lpszPrinterURL, &hPrinter ) ) {

        LPTSTR lpszInfName            = NULL;
        LPTSTR lpszPrinterName        = NULL;
        
        pPrinterInfo2 = Printer.GetPrinterInfo2();
        if ((pPrinterInfo2 == NULL) && (GetLastError () == ERROR_ACCESS_DENIED))
        {
            if (!ConfigurePort( NULL, pThreadData->m_hwnd, lpszPrinterURL )) 
            {
                bRet = FALSE;
                goto Cleanup; 
            }
            pPrinterInfo2 = Printer.GetPrinterInfo2();
        }

        if( (NULL != pPrinterInfo2) &&
            (NULL != (lpszInfName     = GetNTPrint()))   &&
            (NULL != (lpszPrinterName = CreatePrinterBaseName(lpszPrinterURL, pPrinterInfo2->pPrinterName))) ) {

            LPTSTR          lpszCmd       = NULL;
            DWORD           dwLength      = 0;
            TCHAR           szCmdString[] = _TEXT("/if /x /b \"%s\" /r \"%s\" /m \"%s\" /n \"%s\" /f %s /q");
            HMODULE         hPrintUI      = NULL;
            pfnPrintUIEntry PrintUIEntry;

            dwLength = lstrlen( szCmdString )                    +
                       lstrlen( lpszPrinterName )                +
                       lstrlen( pPrinterInfo2->pPortName )       +
                       lstrlen( pPrinterInfo2->pDriverName )     +
                       lstrlen( pThreadData->m_pPrinterUncName ) +
                       lstrlen( lpszInfName )                    + 1;

            if( (lpszCmd  = (LPTSTR)LocalAlloc( LPTR, dwLength*sizeof(TCHAR) )) &&
                (hPrintUI = LoadLibraryFromSystem32( TEXT("printui.dll") )) ) {

                _sntprintf( lpszCmd, dwLength, szCmdString, lpszPrinterName,
                            pPrinterInfo2->pPortName, pPrinterInfo2->pDriverName,
                            pThreadData->m_pPrinterUncName, lpszInfName );

                if( PrintUIEntry = (pfnPrintUIEntry)GetProcAddress(hPrintUI, "PrintUIEntryW") ) {
                    if( ERROR_SUCCESS == (*PrintUIEntry)( NULL,
                                                          0,
                                                          lpszCmd,
                                                          SW_HIDE ) ) {
                        UpdateProgress (pThreadData, 50);
                        if (CheckAndSetDefaultPrinter ()) {
                            UpdateProgress (pThreadData, 100);
                            bRet = TRUE;
                        }
                    }
                }
            }
            if( lpszCmd )
                LocalFree( lpszCmd );

            if( hPrintUI )
                FreeLibrary( hPrintUI );
        }
        if( lpszInfName )
            LocalFree( lpszInfName );

        if( lpszPrinterName )
            LocalFree( lpszPrinterName );
    }

    if( lpszPrinterURL )
        LocalFree(lpszPrinterURL);

    if( bRet )
        goto Cleanup;

#endif

    if (UpdateProgress (pThreadData, 25)) {

        // Step two, somehow, RPC connection failed, try to install http printer
        if (GetHttpPrinterFile (pThreadData, pThreadData->m_pPrinterUrl)) {

            if (UpdateProgress (pThreadData, 60)) {

                if (InstallHttpPrinter (pThreadData)) {

                    if (UpdateProgress (pThreadData, 90)) {

                        if (CheckAndSetDefaultPrinter ()) {
                            UpdateProgress (pThreadData, 100);
                            bRet = TRUE;
                        }
                    }
                }
            }
        }
    }

Cleanup:
    if (!bRet) {
        UpdateError (pThreadData);
    }

    // Cleanup the ThreadData
    if (InterlockedDecrement (& (pThreadData->m_lCount)) == 0) {
        delete (pThreadData);
    }

    return bRet;
}


LRESULT CALLBACK
COleInstall::WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    COleInstall *ptc = (COleInstall *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (COleInstall *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, (UINT_PTR) ptc);
        }
        break;

    case WM_ON_PROGRESS:
        if (ptc)
            ptc->Fire_OnProgress ((long) wParam);
        break;

    case WM_INSTALL_ERROR:
        if (ptc)
            ptc->Fire_InstallError ((long) wParam);
        break;

    case WM_DESTROY:
        // ignore late messages
        if(ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hWnd, WM_ON_PROGRESS, WM_INSTALL_ERROR, PM_REMOVE));
            ::SetWindowLongPtr (hWnd, GWLP_USERDATA, NULL);
        }
        break;

    default:
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

STDMETHODIMP
COleInstall::InstallPrinter(
    BSTR pbstrUncName,
    BSTR pbstrUrl)
{
    HRESULT hr;

    if (!pbstrUncName || !pbstrUrl)
        return E_POINTER;

    // When using an ATL string conversion Macro, spedcify the USES_CONVERSION macro
    // to avoid compiler error
    USES_CONVERSION;

    if (AssignString (m_pPrinterUncName, OLE2T (pbstrUncName)) &&
        AssignString (m_pPrinterUrl, OLE2T (pbstrUrl))) {
        BOOL bRPC;
        LPTSTR  lpszDisplay = NULL;

        hr = CanIInstallRPC( m_pPrinterUncName, m_pPrinterUrl ); // Determine whether to use RPC or HTTP.

        if (FAILED(hr))
            return hr;

        bRPC = HRESULT_CODE(hr) == S_OK;        // If it is S_FALSE, then we must use WebPnP

        lpszDisplay = RemoveURLVars(bRPC ? m_pPrinterUncName : m_pPrinterUrl);
        if (lpszDisplay == NULL)
            return E_OUTOFMEMORY;

        hr = PromptUser(bRPC ? AddPrinterConnection : AddWebPrinterConnection, lpszDisplay);
        LocalFree(lpszDisplay);

        if (hr == S_OK)
            return InitWin(bRPC);
        else if (hr == S_FALSE)
            return HRESULT_FROM_WIN32(ERROR_INSTALL_USEREXIT);
        else
            return FAILED(hr) ? hr : E_FAIL;
    }
    else

        return E_FAIL;
}

STDMETHODIMP
COleInstall::OpenPrintersFolder()
{
    HRESULT hr;

    if (FAILED(hr = CanIOpenPrintersFolder()))
        return hr;          // We allow JAVALOW/JAVAMEDIUM to open the printers folder

    LPITEMIDLIST pidl = NULL;
    HWND         hwnd = GetDesktopWindow ();

    hr   = SHGetSpecialFolderLocation( hwnd, CSIDL_PRINTERS, &pidl );

    if (SUCCEEDED(hr))
    {
        SHELLEXECUTEINFO ei = {0};

        ei.cbSize   = sizeof(SHELLEXECUTEINFO);
        ei.fMask    = SEE_MASK_IDLIST;
        ei.hwnd     = hwnd;
        ei.lpIDList = (LPVOID)pidl;
        ei.nShow    = SW_SHOWNORMAL;

        if (!ShellExecuteEx(&ei))
            hr = E_FAIL;
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//          Private Member Functions
/////////////////////////////////////////////////////////////////////////////

BOOL
COleInstall::SyncExecute(
    LPTSTR pszFileName,
    int nShow)
{
    SHELLEXECUTEINFO shellExeInfo;
    DWORD            dwErrorCode;
    BOOL             bRet = FALSE;
    HWND             hWndForeground, hWndParent, hWndOwner, hWndLastPopup;

    //
    // We need to get the window handle of the current process to pass to the installation code,
    // otherwise any UI (e.g. driver signing pop ups) won't have focus of the IE frame.
    //

    // get the foreground window first
    hWndForeground = ::GetForegroundWindow();

    // climb up to the top parent in case it's a child window...
    hWndParent = hWndForeground;
    while( hWndParent = ::GetParent(hWndParent) ) {
        hWndForeground = hWndParent;
    }

    // get the owner in case the top parent is owned
    hWndOwner = ::GetWindow(::GetParent(hWndForeground), GW_OWNER);
    if( hWndOwner ) {
        hWndForeground = hWndOwner;
    }

    // get the last popup of the owner window
    hWndLastPopup = ::GetLastActivePopup(hWndForeground);

    ZeroMemory (&shellExeInfo, sizeof (SHELLEXECUTEINFO));
    shellExeInfo.cbSize     = sizeof (SHELLEXECUTEINFO);
    shellExeInfo.hwnd       = hWndLastPopup;
    shellExeInfo.lpVerb     = TEXT ("open");
    shellExeInfo.lpFile     = pszFileName;
    shellExeInfo.fMask      = SEE_MASK_NOCLOSEPROCESS;
    shellExeInfo.nShow      = nShow;

    if (ShellExecuteEx (&shellExeInfo) &&
        (UINT_PTR) shellExeInfo.hInstApp > 32) {

        // Wait until it is done
        if (!WaitForSingleObject (shellExeInfo.hProcess , INFINITE) &&
            GetExitCodeProcess (shellExeInfo.hProcess, &dwErrorCode)) {

            if (dwErrorCode == cdwSucessExitCode) {
                bRet = TRUE;
            }
            else {
                if (!dwErrorCode) {
                    // This means that wpnpinst was terminated abnormally
                    // So we have to setup an customized error code here.
                    dwErrorCode = ERROR_WPNPINST_TERMINATED;
                }
                SetLastError (dwErrorCode);
            }
        }
    }
    return bRet;
}

DWORD
COleInstall::GetWebpnpFile(
    OleInstallData *pData,
    LPTSTR pszURL,
    LPTSTR *ppErrMsg)
{
    HINTERNET   hUrlWebpnp   = NULL;
    HINTERNET   hHandle      = NULL;
    HANDLE      hFile        = INVALID_HANDLE_VALUE;
    DWORD       dwSize       = 0;
    DWORD       dwWritten    = 0;
    LPTSTR      pszHeader    = NULL;
    BOOL        bRet;
    BOOL        bRetry       = TRUE;
    DWORD       dwRet        = RET_OTHER_ERROR;
    DWORD       dwError      = ERROR_SUCCESS;
    DWORD       dwLastError;
    DWORD i;
    BYTE buf[FILEBUFSIZE];

    *ppErrMsg = NULL;

    if (! (hHandle = InternetOpen (TEXT ("Internet Add Printer"),
                                   INTERNET_OPEN_TYPE_PRECONFIG,
                                   NULL, NULL, 0)))
        goto Cleanup;


    for (i = 0; bRetry ; i++) {
        DWORD dwCode;
        DWORD dwBufSize = sizeof (DWORD);

        hUrlWebpnp = InternetOpenUrl (hHandle, pszURL, NULL, 0, 0, 0);


        if (!HttpQueryInfo(hUrlWebpnp,
                           HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
                           &dwCode,
                           &dwBufSize,
                           NULL))
            goto Cleanup;

        switch (dwCode) {
        case HTTP_STATUS_OK :
            bRetry = FALSE;
            break;
        case HTTP_STATUS_SERVER_ERROR :
            // Errors are returned by the server
            // Try to get the error string

            dwBufSize = 0;
            bRet =  HttpQueryInfo(hUrlWebpnp,
                                  HTTP_QUERY_STATUS_TEXT,
                                  NULL,
                                  &dwBufSize,
                                  NULL);

            if (!bRet && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {
                if (!(pszHeader = (LPTSTR) LocalAlloc( LPTR, dwBufSize)))
                    goto Cleanup;

                *ppErrMsg = pszHeader;

                if (! HttpQueryInfo(hUrlWebpnp,
                                    HTTP_QUERY_STATUS_TEXT,
                                    pszHeader,
                                    &dwBufSize,
                                    NULL))
                    goto Cleanup;

                dwRet = RET_SERVER_ERROR;
                goto Cleanup;
            }
            else
                goto Cleanup;

            break;
        case HTTP_STATUS_DENIED :
        case HTTP_STATUS_PROXY_AUTH_REQ :
            dwError = InternetErrorDlg(GetDesktopWindow(), hUrlWebpnp,
                                       hUrlWebpnp? ERROR_SUCCESS : GetLastError(),
                                       FLAGS_ERROR_UI_FILTER_FOR_ERRORS |
                                       FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                                       FLAGS_ERROR_UI_FLAGS_GENERATE_DATA,
                                       NULL);

            switch (dwError) {
            case ERROR_INTERNET_FORCE_RETRY:
                if (i >= MAX_INET_RETRY) {
                    goto Cleanup;
                }
                break;
            case ERROR_SUCCESS:
                bRetry = FALSE;
                break;
            case ERROR_CANCELLED:
            default:
                goto Cleanup;
            }
            break;
        default:
            goto Cleanup;
        }

    }

    if (!UpdateProgress (pData, 35))
        goto Cleanup;

    if ( INVALID_HANDLE_VALUE ==
         (hFile = GetTempFile(TEXT (".webpnp"),  &(pData->m_pszTempWebpnpFile))))
        goto Cleanup;

    dwSize = FILEBUFSIZE;
    while (dwSize == FILEBUFSIZE) {
        if (! InternetReadFile (hUrlWebpnp, (LPVOID)buf, FILEBUFSIZE, &dwSize)) {
            goto Cleanup;
        }

        if (! (pData->m_hwnd)) {
            goto Cleanup;
        }

        if (! WriteFile (hFile, buf, dwSize, &dwWritten, NULL)) {
            goto Cleanup;
        }
    }
    CloseHandle (hFile);
    hFile = INVALID_HANDLE_VALUE;

    dwRet = RET_SUCCESS;

Cleanup:

    dwLastError = GetLastError ();

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);
    if (hUrlWebpnp)
        InternetCloseHandle (hUrlWebpnp);
    if (hHandle)
        InternetCloseHandle (hHandle);

    SetLastError (dwLastError);

    if (dwRet == RET_OTHER_ERROR && GetLastError () == ERROR_SUCCESS) {
        SetLastError (ERROR_ACCESS_DENIED);
    }

    return dwRet;
}

HANDLE
COleInstall::GetTempFile(
    LPTSTR pExtension,
    LPTSTR * ppFileName)
{
#ifndef WIN9X
    HANDLE      hServer          = NULL;
    PRINTER_DEFAULTS prDefaults;    // Used to test access rights to the printer
    DWORD       dwType;             // This is the type of the string
#endif

    HANDLE      hFile            = INVALID_HANDLE_VALUE;
    LPTSTR      pszTempDir       = NULL;
    LPTSTR      pszTempFname     = NULL;

    DWORD       dwTempLen;          // This is the new size of the string
    DWORD       i;
    DWORD       dwTempSize;         // This is the Size of the return String

#ifndef WIN9X
    // First we want to open the local print server and ensure that we have access to it
    prDefaults.pDatatype = NULL;
    prDefaults.pDevMode  = NULL;
    prDefaults.DesiredAccess =  SERVER_ACCESS_ADMINISTER;

    *ppFileName = NULL;

    // Open the local spooler to get a handle to it
    if (!OpenPrinter( NULL, &hServer, &prDefaults)) {
        hServer = NULL; // Open Printer returns NULL and not INVALID_HANDLE_VALUE for a failure
        goto Cleanup;   // OpenPrinter will SetLastError to the reason why we couldn't open
    }

    // Get the size of the buffer we will need to copy the printer data
    if (ERROR_MORE_DATA !=
        GetPrinterData( hServer, SPLREG_DEFAULT_SPOOL_DIRECTORY, &dwType, NULL, 0, &dwTempSize)) {
        goto Cleanup;
    }

    // If it's something other than a simple string, set the error to a database error
    if (dwType != REG_SZ) {
        SetLastError(ERROR_BADDB);
        goto Cleanup;
    }

    // Allocate memory for the directory string, this might have to be for an unexpanded string
    // in which case we will allocate memory later and expand the environment strings into that
    if (! (pszTempDir = (LPTSTR) LocalAlloc( LPTR,sizeof (TCHAR) *
                                                (dwTempSize +  MAXFILELEN + lstrlen (pExtension) + 1
                                              ))))
        goto Cleanup;


    if (ERROR_SUCCESS !=
        GetPrinterData( hServer, SPLREG_DEFAULT_SPOOL_DIRECTORY, &dwType, (LPBYTE)pszTempDir,
                        dwTempSize, &dwTempLen))
        goto Cleanup; // For some reason we could not get the data

    ClosePrinter(hServer);

    pszTempFname = &pszTempDir[ lstrlen(pszTempDir) ];

    // GetPrinterData does not put a last \ on the path
    *pszTempFname++ = TEXT('\\');

#else  // We are in Win9X

    dwTempLen = ( dwTempSize = GetWindowsDirectory( NULL, 0 ) )
                + lstrlen( g_szSplDir9X ) + MAXFILELEN + lstrlen (pExtension);

    if (dwTempSize && (pszTempDir = (LPTSTR)LocalAlloc( LPTR, dwTempLen ))) {

        if (GetWindowsDirectory(pszTempDir,dwTempSize)) {
            lstrcat( pszTempDir , g_szSplDir9X );
        } else goto Cleanup;

    } else goto Cleanup;

    pszTempFname = &pszTempDir[ lstrlen(pszTempDir) ];

#endif

    for (i = 0; i < MAXTRY; i++) {
        wsprintf(pszTempFname, TEXT("spl%d%s"), i, pExtension);
        hFile = CreateFile(pszTempDir,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {
            break;

        }
    }

    if (i == MAXTRY) {
        // Return file not found error
        SetLastError (ERROR_PATH_NOT_FOUND);
        goto Cleanup;
    }

    *ppFileName = pszTempDir;
    return hFile;

Cleanup:
    if (pszTempDir)
        LocalFree (pszTempDir);

#ifdef WINNT32
    if (hServer != NULL)
        ClosePrinter(hServer);
#endif

    return INVALID_HANDLE_VALUE;
}


BOOL
COleInstall::IsHttpPreferred(void)
{
    DWORD dwVal;
    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof (DWORD);
    HKEY  hHandle   = NULL;
    BOOL  bRet      = FALSE;


    if (ERROR_SUCCESS != RegOpenKey (HKEY_CURRENT_USER,
                                          TEXT ("Printers\\Settings"),
                                          &hHandle))
        goto Cleanup;

    if (ERROR_SUCCESS == RegQueryValueEx (hHandle,
                                          TEXT ("PreferredConnection"),
                                          NULL,
                                          &dwType,
                                          (LPBYTE) &dwVal,
                                          &dwSize)) {
        bRet =  (dwVal == 0) ? TRUE : FALSE;
    }

Cleanup:

    if (hHandle) {
        RegCloseKey (hHandle);
    }
    return bRet;
}

BOOL
COleInstall::GetHttpPrinterFile(
    OleInstallData *pData,
    LPTSTR pbstrURL)
{
    LPTSTR  pszErrMsg           = NULL;
    BOOL    bRet                = FALSE;
    DWORD   dwError;

    if (!pbstrURL) {
        return  FALSE;
    }

    switch (GetWebpnpFile(pData, pbstrURL, &pszErrMsg)) {
    case RET_SUCCESS:
        bRet = TRUE;
        break;

    case RET_SERVER_ERROR:
        dwError = _ttol (pszErrMsg);
        if (dwError == 0) {
            // This is a server internal error
            dwError = ERROR_INTERNAL_SERVER;
        }

        SetLastError (dwError);

        break;

    case RET_OTHER_ERROR:
    default:
        break;
    }

    if (pszErrMsg) {
        LocalFree (pszErrMsg);
    }
    return bRet;
}

BOOL
COleInstall::InstallHttpPrinter(
    OleInstallData *pData)
{
    BOOL bRet = FALSE;

    if (SyncExecute(pData->m_pszTempWebpnpFile, SW_SHOWNORMAL))
        bRet = TRUE;

    return bRet;
}

BOOL
COleInstall::CheckAndSetDefaultPrinter()
{
    DWORD   dwSize  = 0;
    BOOL    bRet = TRUE;

#ifndef WIN9X
    if (!GetDefaultPrinterW (NULL, &dwSize)) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            // No default printer is set
            // We pass a NULL to SetDefaultPrinter to set the first printer in the device list to
            // be the default one
            bRet = SetDefaultPrinter (NULL);
        }
    }
#endif
    return bRet;
}



HRESULT COleInstall::CanIOpenPrintersFolder(void) {
    DWORD   dwPolicy;
    HRESULT hr = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicy );

    if (SUCCEEDED(hr)) {
        hr = (dwPolicy == URLPOLICY_JAVA_MEDIUM ||
              dwPolicy == URLPOLICY_JAVA_LOW    ||
              dwPolicy == URLPOLICY_ALLOW) ? S_OK : HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED);
    }

    if (FAILED(hr)) {
        hr = GetActionPolicy(URLACTION_SHELL_INSTALL_DTITEMS, dwPolicy);

        if (SUCCEEDED(hr))
            hr = dwPolicy == URLPOLICY_DISALLOW ? HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED) : S_OK;
    }

    return hr;
}

HRESULT COleInstall::CanIInstallRPC( LPTSTR lpszPrinter, LPTSTR lpszWebPrinter)
/*++

Routine Description:
    Examine Secuiry Policies to determine whether we should install the printer or not

Arguments:
    lpszPrinter - The printer that we want to install

Return Value:
    S_OK                                       - Install via RPC
    S_FALSE                                    - Install via Web Pnp
    HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED) - IE security does not allow this action
    Other HRESULT error code.

--*/
{
    DWORD       dwPolicyJava;
    DWORD       dwPolicyDTI;
    HRESULT     hrRet            = S_FALSE;
    HRESULT     hr               = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicyJava);

    _ASSERTE(lpszPrinter);

    if (FAILED(hr)) {
        // There is no JAVA Security Manager, or something went wrong,
        // then we decide whether to use Web PnP instead or just fail.
        hrRet = S_OK;
    }

    switch(dwPolicyJava) {
    case URLPOLICY_JAVA_LOW:
    case URLPOLICY_JAVA_MEDIUM:
        hr = S_OK;
        break;
    default:        // We must do Web PnP
        hr = GetActionPolicy(URLACTION_SHELL_INSTALL_DTITEMS, dwPolicyDTI );

        if (FAILED(hr))  // Couldn't get the policy on installing Desk Top Items
            goto Cleanup;

        switch(dwPolicyDTI) {
        case URLPOLICY_ALLOW:
        case URLPOLICY_QUERY:
            hr = hrRet;
            break;
        case URLPOLICY_DISALLOW:
            hr = HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED);
            break;
        }
    }

Cleanup:

    return hr;
}

LPTSTR COleInstall::RemoveURLVars(IN LPTSTR lpszPrinter) {
    _ASSERTE(lpszPrinter);

    LPTSTR lpszStripped = NULL;

    DWORD dwIndex = _tcscspn( lpszPrinter, TEXT("?") );

    lpszStripped = (LPTSTR)LocalAlloc( LPTR, (dwIndex + 1) * sizeof(TCHAR) );

    if (NULL == lpszStripped)
        goto Cleanup;

    _tcsncpy( lpszStripped, lpszPrinter, dwIndex );

    lpszStripped[dwIndex] = NULL;       // NULL terminate it.

Cleanup:
    return lpszStripped;
}

/*

  Function: GetNTPrint

  Purpose:  Returns a LPTSTR with the path to %windir%\inf\ntprint.inf
            Caller must free the returned string.

*/
LPTSTR
COleInstall::GetNTPrint(void)
{
    UINT    uiSize         = 0;
    UINT    uiAllocSize    = 0;
    PTCHAR  pData          = NULL;
    LPTSTR  lpszNTPrintInf = NULL;
    LPCTSTR gcszNTPrint    = _TEXT("\\inf\\ntprint.inf");

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //
    if( !(uiSize = GetSystemWindowsDirectory( lpszNTPrintInf, 0 )))
        goto Cleanup;

    uiAllocSize += uiSize + _tcslen( gcszNTPrint ) + 1;

    if( NULL == (lpszNTPrintInf = (LPTSTR)LocalAlloc( LPTR, uiAllocSize*sizeof(TCHAR) )))
        goto Cleanup;

    uiAllocSize = GetSystemWindowsDirectory( lpszNTPrintInf, uiSize );
    if( !uiAllocSize || uiAllocSize > uiSize ) {

        LocalFree(lpszNTPrintInf);
        lpszNTPrintInf = NULL;
        goto Cleanup;
    }

    //
    // Determine if we have a \ on the end remove it.
    //
    pData = &lpszNTPrintInf[ _tcslen(lpszNTPrintInf)-1 ];
    if( *pData == _TEXT('\\') )
        *pData = 0;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    _tcscat( lpszNTPrintInf, gcszNTPrint );

Cleanup:
    return lpszNTPrintInf;
}

//
// Creates the printer base name from the printerURL and printer name.
// Form is : "\\http://url\printer name"
//
LPTSTR
COleInstall::CreatePrinterBaseName(
    LPCTSTR lpszPrinterURL,
    LPCTSTR lpszPrinterName
)
{
    LPTSTR lpszFullPrinterName = NULL;
    PTCHAR pWhack              = NULL,
           pFriendlyName       = NULL;

    //
    // lpszPrinterName should be of the form "server\printer name"
    // We need to get only the "printer name" part.
    //
    if( NULL != ( pFriendlyName = _tcsrchr( lpszPrinterName, _TEXT('\\') ))) {
        //
        // Move off the \
        //
        pFriendlyName++;
    } else {
        pFriendlyName = (PTCHAR)lpszPrinterName;
    }

    //
    // Worst case size - the size of the two strings plus the "\\" plus "\" and
    // a NULL terminator
    //
    lpszFullPrinterName = (LPTSTR)LocalAlloc( LPTR,
                                             (lstrlen(lpszPrinterURL) + lstrlen(pFriendlyName) + 4)*sizeof(TCHAR) );

    if( lpszFullPrinterName ){
        lstrcpy( lpszFullPrinterName, _TEXT("\\\\"));
        lstrcat( lpszFullPrinterName, lpszPrinterURL );

        pWhack = _tcschr( lpszFullPrinterName, _TEXT('/') );

        if( pWhack ) {
            if( *(pWhack+1) == _TEXT('/') ) {
                //
                //  We've got a //, find the next /
                //
                pWhack = _tcschr( pWhack+2, _TEXT('/') );
            }
        }

        if( !pWhack ) {
            pWhack = &lpszFullPrinterName[ lstrlen( lpszFullPrinterName ) ];
        }

        *pWhack++ = _TEXT('\\');

        lstrcpy( pWhack, pFriendlyName );
    }

    return lpszFullPrinterName;
}


/****************************************************************************************
** End of File (oleinst.cpp)
****************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\olesnmp.h ===
/*****************************************************************************\
* MODULE:       olesnmp.h
*
* PURPOSE:      Declaration of the CSNMP
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Moved to oleprn.dll
*     02/14/01  weihaic    Added GetAsByte
*
\*****************************************************************************/

#ifndef __OLESNMP_H_
#define __OLESNMP_H_

/////////////////////////////////////////////////////////////////////////////
// CSNMP
class ATL_NO_VTABLE CSNMP :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSNMP, &CLSID_SNMP>,
    public ISupportErrorInfoImpl<&IID_ISNMP>,
    public IDispatchImpl<ISNMP, &IID_ISNMP, &LIBID_OLEPRNLib>
{
public:
    CSNMP(
        VOID
        );

    ~CSNMP(
        VOID
        );

    DECLARE_REGISTRY_RESOURCEID(IDR_SNMP)

    BEGIN_COM_MAP(CSNMP)
        COM_INTERFACE_ENTRY(ISNMP)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

// ISNMP
public:
    STDMETHOD(Open)(
        IN  BSTR bstrHost,
        IN  BSTR bstrCommunity,
        IN  VARIANT varRetry,
        IN  VARIANT varTimeout
        );

    STDMETHOD(OIDFromString)(
        IN  BSTR bstrOID,
        OUT VARIANT *pvarOID
        );

    STDMETHOD(Close)(
        VOID
        );

    STDMETHOD(Get)(
        IN  BSTR bstrOID,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(GetList)(
        IN  VARIANT *pvarList,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(GetTree)(
        IN  BSTR varTree,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(Set)(
        IN  BSTR bstrOID,
        OUT VARIANT varValue
        );

    STDMETHOD(SetList)(
        IN  VARIANT *pvarName,
        IN  VARIANT *pvarValue
        );

    STDMETHOD(GetAsByte)(
        IN  BSTR bstrOID,
        OUT PUINT puValue
        );

private:

    HRESULT
    RfcToVarList (
        long lbound,
        RFC1157VarBindList * prfcVarList,
        SAFEARRAY  *psaOut);

    HRESULT
    VarToRfcVarList (
        long lbound,
        long ubound,
        SAFEARRAY  *psa,
        RFC1157VarBindList * prfcVarList
        );

    HRESULT
    SetSnmpScriptError (
        DWORD dwError
        );

    HRESULT
    SetWinSnmpApiError(
        DWORD dwError
        );

    static HRESULT
    VariantToRFC1157 (
        RFC1157VarBind *varb,
        VARIANT *var
        );

    static HRESULT
    RFC1157ToUInt(
        PUINT puValue,
        RFC1157VarBind * prfcvbValue
        );

    static HRESULT
    VarListAdd(
        BSTR bstrOID,
        RFC1157VarBindList *vl,
        VARIANT *v = NULL
        );

    static HRESULT
    RFC1157ToVariant(
        VARIANT *v,
        RFC1157VarBind *varb
        );

    LPSNMP_MGR_SESSION m_SNMPSession;
};


#endif //__SNMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\olesnmp.cpp ===
/*****************************************************************************\
* MODULE:       olesnmp.cpp
*
* PURPOSE:      Implementation of COM interface for SNMP
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Moved to oleprn.dll
*
\*****************************************************************************/

#include "stdafx.h"
#include "oleprn.h"
#include "olesnmp.h"

/////////////////////////////////////////////////////////////////////////////
// CSNMP


CSNMP::
CSNMP(
    VOID
    )
{
    m_SNMPSession = NULL;
}

CSNMP::
~CSNMP(
    VOID
    )
{
    if (m_SNMPSession != NULL) SnmpMgrClose(m_SNMPSession);
}

/*****************************************************************************\
* Function:         Open
*
* PURPOSE:          COM wrapper for SnmpMgrOpen
*
* ARGUMENTS:
*
*   bstrHost:       Host name or Server Name
*   bstrCommunity:  Community Name
*   varRetry:       Retry times [optional in VB]
*   varTimeOut:     Time out Value (in millisecond) [optional in VB]
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid argument. It occurs when either varRetry or varTimeOut
*                   can not be converted to a short integer.
*   E_FAIL:         If SNMPMgrOpen fails
*
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Open(
    IN  BSTR bstrHost,
    IN  BSTR bstrCommunity,
    IN  VARIANT varRetry,
    IN  VARIANT varTimeOut
    )
{
    const INT   iDefaultRetry = 5;
    const INT   iDefaultTimeOut = 5000;
    INT         iRetry;
    INT         iTimeOut;
    LPSTR       pAnsiHost = NULL;
    LPSTR       pAnsiCommunity = NULL;
    HRESULT     hr = E_FAIL;

    // To prevent a second open
    if (m_SNMPSession != NULL){
        SnmpMgrClose(m_SNMPSession);
        m_SNMPSession = NULL;
    }

    if (varRetry.vt == VT_ERROR) {
        iRetry = iDefaultRetry;
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, &varRetry, 0, VT_I2);
        if (FAILED (hr))
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        iRetry = varTemp.iVal;
    }

    if (varTimeOut.vt == VT_ERROR) {
        iTimeOut = iDefaultTimeOut;
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, &varTimeOut, 0, VT_I2);
        if (FAILED (hr))
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        iTimeOut = varTemp.iVal;
    }

    pAnsiHost = MakeNarrow(bstrHost);
    pAnsiCommunity = MakeNarrow(bstrCommunity);

    if (pAnsiHost && pAnsiCommunity) {
        __try {

            m_SNMPSession = SnmpMgrOpen(pAnsiHost, pAnsiCommunity, iTimeOut, iRetry);

        } __except(1) {

            hr = E_FAIL;
        }
    }

    LocalFree(pAnsiHost);
    LocalFree(pAnsiCommunity);

    if (m_SNMPSession == NULL)
        return Error(IDS_FAILED_OPEN_SNMP, IID_ISNMP, E_FAIL);

    return S_OK;
}

/*****************************************************************************\
* Function:         Get
*
* PURPOSE:          Get a value of a SNMP oid
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   pvarValue:      The return value for the corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Get(
    IN  BSTR bstrOID,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList))){
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_GETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = RFC1157ToVariant(pvarValue, &rfcVarList.list[0]);

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         GetAsByte
*
* PURPOSE:          Get a value of a SNMP oid as an integer
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   puValue:        The return value for the corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetAsByte(
    IN  BSTR bstrOID,
    OUT PUINT puValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList))){
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_GETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = RFC1157ToUInt(puValue, &rfcVarList.list[0]);

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         GetList
*
* PURPOSE:          Get a list of a SNMP oids
*
* ARGUMENTS:
*
*   pvarList:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The return value for the corresponding Oids, it is 1D array
*                   of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid or the type of the variant is not a 1D array
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetList(
    IN  VARIANT *pvarList,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psa,*psaOut = NULL;
    SAFEARRAYBOUND      rgsabound[1];
    long                lbound, ubound, half, step;
    VARIANT             var;
    BOOL                bFound;
    BOOL                bTooBig;

    // Check if Open Method has been called
    if (m_SNMPSession == NULL)
        return (Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL));

    // Validate the input variable
    if (!(pvarList->vt & VT_ARRAY))
        return (Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG));

    if (pvarList->vt & VT_BYREF)
        psa = *(pvarList->pparray);
    else
        psa = pvarList->parray;

    if (SafeArrayGetDim(psa)!=1)
        return (Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG));

    // Get the array boundary
    SafeArrayGetLBound(psa, 1, &lbound);
    SafeArrayGetUBound(psa, 1, &ubound);

    VariantInit(pvarValue);
    VariantInit(&var);

    // Alloc the destination array
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = ubound - lbound + 1;

    if (! (psaOut = SafeArrayCreate(VT_VARIANT, 1, rgsabound))) {
        hr = Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        goto Cleanup;
    }

    // Try to determine the size of data we can put into one call
    half = ubound;

    bFound = FALSE;
    while (!bFound) {

        bTooBig = FALSE;

        // Convert items of the array to rfcVarList
        hr = VarToRfcVarList (lbound, half, psa, &rfcVarList);
        if (FAILED (hr))
            goto Cleanup;

        if (! SnmpMgrRequest(m_SNMPSession,
                             ASN_RFC1157_GETREQUEST,
                             &rfcVarList,
                             &asniErrorStatus,
                             &asniErrorIndex)) {

            if (GetLastError() != ERROR_NOT_ENOUGH_MEMORY)
            {
                // SNMP call fails. Setup error and return
                hr = SetWinSnmpApiError (GetLastError ());
                goto Cleanup;
            }
            else
                bTooBig = TRUE;
        }

        if (asniErrorStatus > 0)  {
            // SNMP call succeeds but the returned status if wrong
            if (asniErrorStatus != SNMP_ERRORSTATUS_TOOBIG) {
                // Other errors occur in the call, setup error and return
                hr = SetSnmpScriptError(asniErrorStatus);
                goto Cleanup;
            }
            else
                bTooBig = TRUE;
        }

        if (bTooBig){
            // The size of input is too big, reduce it again
            if (half - lbound < 2) {
                // Something must be wrong, quit
                hr = SetSnmpScriptError(asniErrorStatus);
                goto Cleanup;
            }
            else {
                // Divdie the size by 2
                half = (lbound + half) / 2;
            }
        }
        else {
            // We've found the proper steps and also got the first portion
            // Save them to the destination safe array psaout
            hr = RfcToVarList (lbound, &rfcVarList, psaOut);
            if (FAILED (hr))
                goto Cleanup;

            bFound = TRUE;
        }
        SnmpUtilVarBindListFree(&rfcVarList);
        rfcVarList.list = NULL;
        rfcVarList.len = 0;
    }

    step = half - lbound;
    for (lbound = half + 1; lbound <= ubound; lbound += step) {
        half = lbound + step;
        if (half > ubound)
            half = ubound;

        hr = VarToRfcVarList (lbound, half, psa, &rfcVarList);
        if (FAILED (hr))
            goto Cleanup;

        if (! SnmpMgrRequest(m_SNMPSession,
                             ASN_RFC1157_GETREQUEST,
                             &rfcVarList,
                             &asniErrorStatus,
                             &asniErrorIndex)) {
            // SNMP call fails. Setup error and return
            hr = SetWinSnmpApiError (GetLastError ());
            goto Cleanup;
        }
        if (asniErrorStatus > 0)  {
            // SNMP call succeeds but the returned status if wrong
            hr = SetSnmpScriptError(asniErrorStatus);
            goto Cleanup;
        }
        // Everything is OK
        hr = RfcToVarList (lbound, &rfcVarList, psaOut);
        if (FAILED (hr))
            goto Cleanup;

        SnmpUtilVarBindListFree(&rfcVarList);
        rfcVarList.list = NULL;
        rfcVarList.len = 0;
    }

    VariantInit(pvarValue);
    pvarValue->vt = VT_ARRAY|VT_VARIANT;
    pvarValue->parray = psaOut;
    hr = S_OK;
    return hr;

Cleanup:
    if (rfcVarList.len > 0)
        SnmpUtilVarBindListFree(&rfcVarList);
    if (psaOut)
        SafeArrayDestroy (psaOut);
    return hr;
}

/*****************************************************************************\
* Function:         GetTree
*
* PURPOSE:          It walks through  SNMP oids
*
* ARGUMENTS:
*
*   bstrTree:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The return value for the corresponding Oids, it is 1D array
*                   of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetTree(
    IN  BSTR bstrTree,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    VARIANT             v;
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    AsnObjectIdentifier asnRootOid;
    AsnObjectIdentifier asnTmpOid;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psa = NULL;
    SAFEARRAYBOUND      rgsabound[2];
    long                ix[2];
    LPSTR               pszStr;

    if (m_SNMPSession == NULL)
        return (Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL));

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = 2;
    rgsabound[1].lLbound = 0;
    rgsabound[1].cElements = 0;
    if (! (psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound)))
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

    hr = VarListAdd(bstrTree, &rfcVarList);
    if (FAILED (hr))
    {
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup2;
    }

    if (!SnmpUtilOidCpy(&asnRootOid, &rfcVarList.list[0].name)){
        hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
        goto Cleanup2;
    }

    while(1){
        if (!SnmpMgrRequest(m_SNMPSession,
                            ASN_RFC1157_GETNEXTREQUEST,
                            &rfcVarList,
                            &asniErrorStatus,
                            &asniErrorIndex)) {
            hr = SetWinSnmpApiError (GetLastError ());
            goto Cleanup;
        }

        if (asniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
            SnmpUtilOidNCmp(&rfcVarList.list[0].name, &asnRootOid, asnRootOid.idLength))
            break;

        if (asniErrorStatus > 0) {
            hr = SetSnmpScriptError(asniErrorStatus);
            goto Cleanup;
        }

        rgsabound[1].cElements++;
        ix[1] = rgsabound[1].cElements - 1;
        hr = SafeArrayRedim(psa, &rgsabound[1]);
        if (FAILED (hr))
        {
            Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            goto Cleanup;
        }

        // put a pszStr version of the OID in the result array

        pszStr = NULL;
        if (!SnmpMgrOidToStr(&rfcVarList.list[0].name, &pszStr)){
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            goto Cleanup;
        }

        ix[0] = 0;
        hr = PutString(psa, ix, pszStr);
        if (FAILED (hr))
            goto Cleanup;

        SnmpUtilMemFree(pszStr);

        // Put the value variant in the result array

        hr = RFC1157ToVariant(&v, &rfcVarList.list[0]);
        if (FAILED (hr)) goto Cleanup;

        ix[0] = 1;
        hr = SafeArrayPutElement(psa, ix, &v);
        if (FAILED (hr))
        {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }
        VariantClear(&v);

        if (! SnmpUtilOidCpy(&asnTmpOid, &rfcVarList.list[0].name)) {
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            goto Cleanup;
        }

        SnmpUtilVarBindFree(&rfcVarList.list[0]);

        if (! SnmpUtilOidCpy(&rfcVarList.list[0].name, &asnTmpOid)) {
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            SnmpUtilOidFree(&asnTmpOid);
            goto Cleanup;
        }

        rfcVarList.list[0].value.asnType = ASN_NULL;
        SnmpUtilOidFree(&asnTmpOid);
    }

    SnmpUtilOidFree(&asnRootOid);
    SnmpUtilVarBindListFree(&rfcVarList);

    VariantInit(pvarValue);
    pvarValue->vt = VT_ARRAY|VT_VARIANT;
    pvarValue->parray = psa;
    return S_OK;

Cleanup:
    SnmpUtilOidFree(&asnRootOid);
Cleanup2:
    SnmpUtilVarBindListFree(&rfcVarList);
    if (psa)
        SafeArrayDestroy(psa);
    return hr;
}

/*****************************************************************************\
* Function:         Close
*
* PURPOSE:          A Com Wrapper for SnmpMgrClose()
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           always.
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Close(
    VOID
    )
{
    if (m_SNMPSession)
        SnmpMgrClose(m_SNMPSession);
    m_SNMPSession = NULL;
    return S_OK;
}


STDMETHODIMP
CSNMP::
OIDFromString(
    BSTR bstrOID,
    VARIANT *pvarOID
    )
{
    SAFEARRAY           *psaOID;
    SAFEARRAYBOUND      rgsaOID[1];
    long                ixOID[1];
    LPSTR               pszOID;
    BOOL                bResult;
    VARIANT             v;
    AsnObjectIdentifier asnReqObject;
    HRESULT             hr;

    VariantInit(&v);
    if (! (pszOID = MakeNarrow(bstrOID)))
        return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());

    bResult = SnmpMgrStrToOid(pszOID, &asnReqObject);
    LocalFree(pszOID);

    if (!bResult )
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    // put a numeric array of the pvarOID in the result array

    rgsaOID[0].lLbound = 0;
    rgsaOID[0].cElements = asnReqObject.idLength;
    psaOID = SafeArrayCreate(VT_VARIANT, 1, rgsaOID);
    if (psaOID == NULL)
        goto out;
    for (ixOID[0] = 0; ixOID[0] < (long)rgsaOID[0].cElements ; ixOID[0]++){
        hr = VariantClear(&v);
        _ASSERTE (SUCCEEDED (hr));
        v.vt = VT_I4;
        v.lVal = asnReqObject.ids[ixOID[0]];
        hr = SafeArrayPutElement(psaOID, ixOID, &v);
        if (FAILED(hr))
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        //SafeArrayPutElement(psaOID, ixOID, &(asnReqObject.ids[ixOID[0]]));
    }

    hr = VariantClear(pvarOID);
    _ASSERTE(hr);
    pvarOID->vt = VT_ARRAY|VT_VARIANT;
    pvarOID->parray = psaOID;
    SnmpUtilOidFree(&asnReqObject);
    return S_OK;

out:
    SnmpUtilOidFree(&asnReqObject);
    return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
}

HRESULT
CSNMP::
VariantToRFC1157(
    RFC1157VarBind * prfcvbValue,
    VARIANT * pvarValue
    )
{
    HRESULT hr = S_OK;

    if (!pvarValue) {
        prfcvbValue->value.asnType = ASN_NULL;
    } else
    if (pvarValue->vt == VT_BSTR){
        prfcvbValue->value.asnType = ASN_OCTETSTRING;
        LPSTR pStr = MakeNarrow (pvarValue->bstrVal);

        if (pStr) {
            DWORD dwLen = strlen (pStr);

            if (! (prfcvbValue->value.asnValue.string.stream = (BYTE *) SnmpUtilMemAlloc (dwLen + 1))) {
                LocalFree (pStr);
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            }
            memcpy (prfcvbValue->value.asnValue.string.stream, pStr, dwLen + 1);
            prfcvbValue->value.asnValue.string.length = dwLen;
            prfcvbValue->value.asnValue.string.dynamic = TRUE;
            LocalFree (pStr);
        }
        else
            hr = Error( IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY );
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, pvarValue, 0, VT_I4);
        if (FAILED (hr))
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        else {
            prfcvbValue->value.asnType = ASN_INTEGER;
            prfcvbValue->value.asnValue.number = pvarValue->lVal;
        }
    }

    return hr;
}

// ----------------------------------------------------
//  Place a returned SNMP value in a variant
//
HRESULT
CSNMP::
RFC1157ToVariant(
    VARIANT * pvarValue,
    RFC1157VarBind * prfcvbValue
    )
{
    VariantInit(pvarValue);
    switch (prfcvbValue->value.asnType){
    case ASN_RFC1155_TIMETICKS:
    case ASN_RFC1155_COUNTER:
    case ASN_RFC1155_GAUGE:
    case ASN_INTEGER:
    case ASN_UNSIGNED32:
        pvarValue->vt= VT_I4;
        pvarValue->lVal = prfcvbValue->value.asnValue.number;
        break;

    case ASN_RFC1155_IPADDRESS:
    case ASN_RFC1155_OPAQUE:
    case ASN_BITS:
    case ASN_SEQUENCE:
    case ASN_OCTETSTRING:
        pvarValue->vt = VT_BSTR;
        LPWSTR pszUnicodeStr;
        if (prfcvbValue->value.asnValue.string.length > 0 ){
            LPSTR pszAnsiStr;
            if (! (pszAnsiStr = (LPSTR )LocalAlloc(LPTR,
                prfcvbValue->value.asnValue.string.length + 1)))
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            memcpy(pszAnsiStr, (LPSTR )prfcvbValue->value.asnValue.string.stream,
                   prfcvbValue->value.asnValue.string.length);
            pszAnsiStr[prfcvbValue->value.asnValue.string.length] = 0;
            pszUnicodeStr = MakeWide(pszAnsiStr);
            LocalFree(pszAnsiStr);
        }
        else{
            pszUnicodeStr = MakeWide("");
        }

        if (pszUnicodeStr == NULL)
            return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

        pvarValue->bstrVal = SysAllocString(pszUnicodeStr);

        LocalFree(pszUnicodeStr);

        if (pvarValue->bstrVal == NULL) {
            return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        }
        break;

    case ASN_OBJECTIDENTIFIER:
        LPSTR pszAnsiOid;

        pszAnsiOid = NULL;
        if (SnmpMgrOidToStr(& (prfcvbValue->value.asnValue.object), &pszAnsiOid)) {
            LPWSTR pszUnicodeOid = MakeWide (pszAnsiOid);

            SnmpUtilMemFree (pszAnsiOid);

            if (pszUnicodeOid) {
                pvarValue->vt = VT_BSTR;
                pvarValue->bstrVal = SysAllocString(pszUnicodeOid);
                LocalFree (pszUnicodeOid);
            }
            else
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        }
        else
            return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
        break;
    default:
        pvarValue->vt = VT_EMPTY;
    }
    return S_OK;
}

// ----------------------------------------------------
//  Place a returned SNMP value in a uint
//
HRESULT
CSNMP::
RFC1157ToUInt(
    PUINT puValue,
    RFC1157VarBind * prfcvbValue
    )
{
    switch (prfcvbValue->value.asnType){
    case ASN_RFC1155_TIMETICKS:
    case ASN_RFC1155_COUNTER:
    case ASN_RFC1155_GAUGE:
    case ASN_INTEGER:
    case ASN_UNSIGNED32:
        *puValue = prfcvbValue->value.asnValue.number;
        break;

    case ASN_RFC1155_OPAQUE:
    case ASN_BITS:
    case ASN_SEQUENCE:
    case ASN_OCTETSTRING:

        if (prfcvbValue->value.asnValue.string.length == 1 ){
            *puValue = prfcvbValue->value.asnValue.string.stream[0];
        }
        else{
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        }
        break;

    default:
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
    }
    return S_OK;
}

// -----------------------------------------------------
//   Add an OID to an SNMP get list
//
//  Convert the UNICODE string to ANSI
//  Convert it to a real OID (numbers)
//  Add to the Array
HRESULT
CSNMP::
VarListAdd(
    BSTR bstrOID,
    RFC1157VarBindList * prfcList,
    VARIANT *pvarValue
    )
{
    LPSTR               pszOID;
    BOOL                bResult;
    AsnObjectIdentifier asnReqObject;

    if (! (pszOID = MakeNarrow(bstrOID)))
        return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());

    bResult = SnmpMgrStrToOid(pszOID, &asnReqObject);
    LocalFree(pszOID);

    if (!bResult)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    prfcList->len++;

    if (! (prfcList->list = (RFC1157VarBind *) SNMP_realloc (prfcList->list,
        sizeof(RFC1157VarBind) * prfcList->len)))
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

    prfcList->list[prfcList->len - 1].name = asnReqObject;

    return VariantToRFC1157(& (prfcList->list[prfcList->len -1]), pvarValue);

}

/*****************************************************************************\
* Function:         Set
*
* PURPOSE:          Set a value of a SNMP oid
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   varValue:       The corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Set(
    IN  BSTR bstrOID,
    IN  VARIANT varValue
    )
{
    RFC1157VarBindList rfcVarList = {NULL, 0};
    AsnInteger asniErrorStatus;
    AsnInteger asniErrorIndex;
    HRESULT hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList)))
    {
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    hr = VariantToRFC1157(&rfcVarList.list[0], &varValue);
    if (FAILED (hr))
        goto Cleanup;

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_SETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         SetList
*
* PURPOSE:          Set a list of a SNMP oids
*
* ARGUMENTS:
*
*   pvarList:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The corresponding Oids, it must also b a 1D array of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid or the type of the variant is not a 1D array
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
SetList(
    IN  VARIANT * varName,
    IN  VARIANT * varValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psaName, *psaValue;
    long                lLowBound, lUpperBound;
    long                ix[1];

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (!(varName->vt & VT_ARRAY) || !(varValue->vt & VT_ARRAY))
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    if (varName->vt & VT_BYREF)
        psaName = *(varName->pparray);
    else
        psaName = varName->parray;

    if (varValue->vt & VT_BYREF)
        psaValue = *(varValue->pparray);
    else
        psaValue = varValue->parray;

    if (SafeArrayGetDim(psaName) != 1 || SafeArrayGetDim(psaValue) != 1)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    SafeArrayGetLBound(psaName, 1, &lLowBound);
    SafeArrayGetUBound(psaName, 1, &lUpperBound);

    long lVal;

    SafeArrayGetLBound(psaValue, 1, &lVal);
    if (lVal != lLowBound)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
    SafeArrayGetUBound(psaValue, 1, &lVal);
    if (lVal != lUpperBound)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    for (ix[0] = lLowBound; ix[0] <= lUpperBound; ix[0]++) {
        VARIANT             varArgName, varArgValue;

        VariantClear(&varArgName);
        VariantClear(&varArgValue);

        hr = SafeArrayGetElement(psaName, ix, &varArgName);
        if (FAILED (hr)) {
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }

        if (varArgName.vt != VT_BSTR) {
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }

        hr = SafeArrayGetElement(psaValue, ix, &varArgValue);
        if (FAILED (hr))
            goto Cleanup;

        if (FAILED (hr = VarListAdd(varArgName.bstrVal, &rfcVarList, &varArgValue)))
            goto Cleanup;
    }

    if (! SnmpMgrRequest(m_SNMPSession,
                         ASN_RFC1157_SETREQUEST,
                         &rfcVarList,
                         &asniErrorStatus,
                         &asniErrorIndex))
    {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}


HRESULT
CSNMP::
SetSnmpScriptError(
    IN  DWORD dwError
    )
{
    static DWORD SnmpErrorMapping [] = {
        IDS_SNMP_ERRORSTATUS_NOERROR,
        IDS_SNMP_ERRORSTATUS_TOOBIG,
        IDS_SNMP_ERRORSTATUS_NOSUCHNAME,
        IDS_SNMP_ERRORSTATUS_BADVALUE,
        IDS_SNMP_ERRORSTATUS_READONLY,
        IDS_SNMP_ERRORSTATUS_GENERR,
        IDS_SNMP_ERRORSTATUS_NOACCESS,
        IDS_SNMP_ERRORSTATUS_WRONGTYPE,
        IDS_SNMP_ERRORSTATUS_WRONGLENGTH,
        IDS_SNMP_ERRORSTATUS_WRONGENCODING,
        IDS_SNMP_ERRORSTATUS_WRONGVALUE,
        IDS_SNMP_ERRORSTATUS_NOCREATION,
        IDS_SNMP_ERRORSTATUS_INCONSISTENTVALUE,
        IDS_SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE,
        IDS_SNMP_ERRORSTATUS_COMMITFAILED,
        IDS_SNMP_ERRORSTATUS_UNDOFAILED,
        IDS_SNMP_ERRORSTATUS_AUTHORIZATIONERROR,
        IDS_SNMP_ERRORSTATUS_NOTWRITABLE,
        IDS_SNMP_ERRORSTATUS_INCONSISTENTNAME};

    if ((int)dwError < 0 || dwError > sizeof (SnmpErrorMapping) / sizeof (DWORD))
        dwError = SNMP_ERRORSTATUS_GENERR;
    return Error(SnmpErrorMapping[dwError], IID_ISNMP, E_FAIL);
}

HRESULT
CSNMP::
SetWinSnmpApiError(
    IN  DWORD dwError
    )
{
    static DWORD WinSnmpApiErrorMapping [] = {
        IDS_SNMPAPI_ALLOC_ERROR,
        IDS_SNMPAPI_CONTEXT_INVALID,
        IDS_SNMPAPI_CONTEXT_UNKNOWN,
        IDS_SNMPAPI_ENTITY_INVALID,
        IDS_SNMPAPI_ENTITY_UNKNOWN,
        IDS_SNMPAPI_INDEX_INVALID,
        IDS_SNMPAPI_NOOP,
        IDS_SNMPAPI_OID_INVALID,
        IDS_SNMPAPI_OPERATION_INVALID,
        IDS_SNMPAPI_OUTPUT_TRUNCATED,
        IDS_SNMPAPI_PDU_INVALID,
        IDS_SNMPAPI_SESSION_INVALID,
        IDS_SNMPAPI_SYNTAX_INVALID,
        IDS_SNMPAPI_VBL_INVALID,
        IDS_SNMPAPI_MODE_INVALID,
        IDS_SNMPAPI_SIZE_INVALID,
        IDS_SNMPAPI_NOT_INITIALIZED,
        IDS_SNMPAPI_MESSAGE_INVALID,
        IDS_SNMPAPI_HWND_INVALID,
        IDS_SNMPAPI_OTHER_ERROR,
        IDS_SNMPAPI_TL_NOT_INITIALIZED,
        IDS_SNMPAPI_TL_NOT_SUPPORTED,
        IDS_SNMPAPI_TL_NOT_AVAILABLE,
        IDS_SNMPAPI_TL_RESOURCE_ERROR,
        IDS_SNMPAPI_TL_UNDELIVERABLE,
        IDS_SNMPAPI_TL_SRC_INVALID,
        IDS_SNMPAPI_TL_INVALID_PARAM,
        IDS_SNMPAPI_TL_IN_USE,
        IDS_SNMPAPI_TL_TIMEOUT,
        IDS_SNMPAPI_TL_PDU_TOO_BIG,
        IDS_SNMPAPI_TL_OTHER
    };

    static DWORD WinSnmpApiError [] = {
        SNMPAPI_ALLOC_ERROR,
        SNMPAPI_CONTEXT_INVALID,
        SNMPAPI_CONTEXT_UNKNOWN,
        SNMPAPI_ENTITY_INVALID,
        SNMPAPI_ENTITY_UNKNOWN,
        SNMPAPI_INDEX_INVALID,
        SNMPAPI_NOOP,
        SNMPAPI_OID_INVALID,
        SNMPAPI_OPERATION_INVALID,
        SNMPAPI_OUTPUT_TRUNCATED,
        SNMPAPI_PDU_INVALID,
        SNMPAPI_SESSION_INVALID,
        SNMPAPI_SYNTAX_INVALID,
        SNMPAPI_VBL_INVALID,
        SNMPAPI_MODE_INVALID,
        SNMPAPI_SIZE_INVALID,
        SNMPAPI_NOT_INITIALIZED,
        SNMPAPI_MESSAGE_INVALID,
        SNMPAPI_HWND_INVALID,
        SNMPAPI_OTHER_ERROR,
        SNMPAPI_TL_NOT_INITIALIZED,
        SNMPAPI_TL_NOT_SUPPORTED,
        SNMPAPI_TL_NOT_AVAILABLE,
        SNMPAPI_TL_RESOURCE_ERROR,
        SNMPAPI_TL_UNDELIVERABLE,
        SNMPAPI_TL_SRC_INVALID,
        SNMPAPI_TL_INVALID_PARAM,
        SNMPAPI_TL_IN_USE,
        SNMPAPI_TL_TIMEOUT,
        SNMPAPI_TL_PDU_TOO_BIG,
        SNMPAPI_TL_OTHER
    };

    for (int i = 0; i < sizeof (WinSnmpApiError); i++) {
        if (dwError == WinSnmpApiError[i]) {
            dwError = WinSnmpApiErrorMapping[i];
            break;
        }
    }
    return Error(dwError, IID_ISNMP, E_FAIL);

 }

// Convert part of the the variant array to
// RFC1157VarBindList used in SnmpMgrRequest call
HRESULT
CSNMP::
VarToRfcVarList(
    long lbound,
    long ubound,
    SAFEARRAY *psa,
    RFC1157VarBindList * prfcVarList
    )
{
    long                ix[1];
    VARIANT             var;
    HRESULT             hr = S_OK;

    for (ix[0] = lbound; ix[0] <= ubound; ix[0]++) {
        VariantClear(&var);
        hr = SafeArrayGetElement(psa, ix, &var);
        if (FAILED (hr) || var.vt != VT_BSTR) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }

        hr = VarListAdd(var.bstrVal, prfcVarList);
        if (FAILED (hr)) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }
    }
    return hr;
}

// Append RFC1157VarBindList used in SnmpMgrRequest call at the
// end of the variant array
HRESULT
CSNMP::
RfcToVarList(
    long lbound,
    RFC1157VarBindList *prfcVarList,
    SAFEARRAY * psaOut
    )
{
    long                ix[1];
    DWORD               i;
    VARIANT             var;
    HRESULT             hr = S_OK;

    for(ix[0] = lbound, i = 0; i < prfcVarList->len; i++, ix[0]++) {
        hr = RFC1157ToVariant(&var, & prfcVarList->list[i]);
        if (FAILED (hr))
            break;

        hr = SafeArrayPutElement(psaOut, ix, &var);
        if (FAILED (hr)) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\olecvt.h ===
// OleCvt.h : Declaration of the COleCvt

#ifndef __OLECVT_H_
#define __OLECVT_H_

#include <asptlb.h>         // Active Server Pages Definitions

/////////////////////////////////////////////////////////////////////////////
// COleCvt
class ATL_NO_VTABLE COleCvt :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<COleCvt, &CLSID_OleCvt>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<COleCvt>,
	public IDispatchImpl<IOleCvt, &IID_IOleCvt, &LIBID_OLEPRNLib>,
    public IObjectSafetyImpl<COleCvt>
{
public:
	COleCvt()
	{
		m_bOnStartPageCalled = FALSE;
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_OLECVT)

BEGIN_COM_MAP(COleCvt)
	COM_INTERFACE_ENTRY(IOleCvt)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(COleCvt)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IOleCvt
public:
	STDMETHOD(get_ToUnicode)(BSTR bstrString, long lCodePage, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_DecodeUnicodeName)(BSTR bstrSrcName, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_EncodeUnicodeName)(BSTR bstrSrcName, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ToUtf8)(BSTR bstrUnicode, /*[out, retval]*/ BSTR *pVal);
	//Active Server Pages Methods
	STDMETHOD(OnStartPage)(IUnknown* IUnk);
	STDMETHOD(OnEndPage)();

private:
    HRESULT SetOleCvtScriptingError(DWORD dwError);
	CComPtr<IRequest> m_piRequest;					//Request Object
	CComPtr<IResponse> m_piResponse;				//Response Object
	CComPtr<ISessionObject> m_piSession;			//Session Object
	CComPtr<IServer> m_piServer;					//Server Object
	CComPtr<IApplicationObject> m_piApplication;	//Application Object
	BOOL m_bOnStartPageCalled;						//OnStartPage successful?
};

#endif //__OLECVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\printer.cpp ===
// Printer.cpp: implementation of the CPrinter class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Printer.h"
#include "wininet.h"

static const DWORD BIT_IGNORED_JOB = (JOB_STATUS_PAUSED   |
                                      JOB_STATUS_PRINTED  |
                                      JOB_STATUS_DELETING |
                                      JOB_STATUS_OFFLINE  |
                                      JOB_STATUS_SPOOLING);
static const DWORD BIT_ERROR_JOB   = (JOB_STATUS_ERROR | JOB_STATUS_PAPEROUT);
static const DWORD CHAR_PER_PAGE   = 4800;
static const DWORD PAGEPERJOB      = 1;
static const DWORD BYTEPERJOB      = 2;


#ifdef WIN9X
    #error This code requires DRIVER_INFO_6 which is not availabe under Win9X
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPrinter::CPrinter():
          m_hPrinter(NULL),
          m_pInfo2(NULL),
          m_pInfo4(NULL),
          m_pDriverInfo6(NULL),
          m_bCalcJobETA(NULL),
          m_pszUrlBuffer(NULL),
          m_pszOemUrl (NULL),
          m_pszManufacturer (NULL)
{
}

CPrinter::~CPrinter()
{
    if (m_pInfo2) {
        LocalFree (m_pInfo2);
    }

    if (m_pInfo4) {
        LocalFree (m_pInfo4);
    }

    if (m_pDriverInfo6) {
        LocalFree (m_pDriverInfo6);
    }

    if (m_hPrinter) {
        ClosePrinter (m_hPrinter);
    }

    if (m_pszUrlBuffer) {
        LocalFree (m_pszUrlBuffer);
    }

    if (m_pszOemUrl) {
        LocalFree (m_pszOemUrl);
    }

    if (m_pszManufacturer) {
        LocalFree (m_pszManufacturer);
    }

}

BOOL CPrinter::Open(LPTSTR pPrinterName, LPHANDLE phPrinter)
{
    PRINTER_DEFAULTS pd = {NULL, NULL, PRINTER_ACCESS_USE};

    if (m_hPrinter != NULL)
        return FALSE;

    if (! (OpenPrinter(pPrinterName, &m_hPrinter, &pd)))
        return FALSE;

    if (phPrinter) {
        *phPrinter = m_hPrinter;
    }

    return TRUE;
}

// This is a compiler safe way of checking that an unsigned integer is
// negative and returning zero if it is or the integer if it is not
// Note: Tval can be any size but must be unsigned
template<class T> inline T ZeroIfNegative(T Tval) {
    if (Tval & (T(1) << (sizeof(Tval) * 8 - 1))) return 0;
        else return Tval;
}

BOOL CPrinter::CalJobEta()
{
    DWORD           dwPrintRate = DWERROR;
    PJOB_INFO_2     pJobInfo = NULL;
    PJOB_INFO_2     pJob;
    DWORD           dwNumJobs;
    DWORD           dwNeeded = 0;
    DWORD           i;
    float           fFactor = 1;
    float           fTotal = 0;
    DWORD           dwNumJobsReqested;
    BOOL            bRet = FALSE;
    const   DWORD   cdwLimit = 256;

    if (! AllocGetPrinterInfo2())
        return NULL;

    if (m_pInfo2->cJobs > 0) {

        if (m_pInfo2->cJobs > cdwLimit) {
            fFactor = (float) m_pInfo2->cJobs / cdwLimit;
            dwNumJobsReqested = cdwLimit;
        }
        else
            dwNumJobsReqested = m_pInfo2->cJobs;

        EnumJobs (m_hPrinter, 0, dwNumJobsReqested, 2,
            NULL, 0, &dwNeeded, &dwNumJobs);

        if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
            (NULL == (pJobInfo = (PJOB_INFO_2)LocalAlloc(LPTR, dwNeeded))) ||
            (!EnumJobs (m_hPrinter, 0, dwNumJobsReqested, 2, (LPBYTE) pJobInfo, dwNeeded,
            &dwNeeded, &dwNumJobs))) {

            goto Cleanup;
        }

        // Get the average Job size

        // Find out if we can use page as the unit
        for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
            if (pJob->Status & BIT_IGNORED_JOB)
                continue;

            if (pJob->Size > 0 && pJob->TotalPages == 0)
                break;
        }

        m_dwPendingJobCount = 0;

        if (i == dwNumJobs) {
            // All the jobs have the page information. Use page as the unit
            m_dwAvgJobSizeUnit = PAGEPERJOB;

            for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
                if (pJob->Status & BIT_IGNORED_JOB)
                    continue;
                m_dwPendingJobCount++;
                fTotal += pJob->TotalPages;
            }
        }
        else {
            // Use byte as the unit
            m_dwAvgJobSizeUnit = BYTEPERJOB;
            for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
                if (pJob->Status & BIT_IGNORED_JOB)
                    continue;
                m_dwPendingJobCount++;
                fTotal += ZeroIfNegative(pJob->Size);
            }
        }

        // Calculate the averate job size
        if (m_dwPendingJobCount) {
            m_dwAvgJobSize = DWORD ((fTotal) / (float) m_dwPendingJobCount);
            dwPrintRate = GetPPM();

            if (dwPrintRate != DWERROR)
                m_dwJobCompletionMinute = (DWORD) (fFactor * GetWaitingMinutes (dwPrintRate, pJobInfo, dwNumJobs));
        }
        else {
            m_dwAvgJobSize = 0;
            m_dwJobCompletionMinute = 0;
        }

        m_dwPendingJobCount = (DWORD) (m_dwPendingJobCount * fFactor);
    }
    else {
        m_dwPendingJobCount = 0;
        m_dwAvgJobSize = 0;
        m_dwJobCompletionMinute = 0;
        m_dwAvgJobSizeUnit = PAGEPERJOB;
    }

    m_bCalcJobETA = TRUE;

    // Set the last error to ERROR_INVALID_DATA if the printer rate is not available for the current printer
    // or if the printer status is not suitable to display the summary information
    //

    if (dwPrintRate == DWERROR ||
        m_pInfo2->Status & ( PRINTER_STATUS_PAUSED           |
                             PRINTER_STATUS_ERROR            |
                             PRINTER_STATUS_PENDING_DELETION |
                             PRINTER_STATUS_PAPER_JAM        |
                             PRINTER_STATUS_PAPER_OUT        |
                             PRINTER_STATUS_OFFLINE )) {
        SetLastError (ERROR_INVALID_DATA);
        m_dwJobCompletionMinute = DWERROR;
        bRet = FALSE;
    }
    else
        bRet = TRUE;

Cleanup:
    if (pJobInfo)
        LocalFree(pJobInfo);
    return bRet;

    }

DWORD CPrinter::GetWaitingMinutes(DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob)
{
    DWORD   dwWaitingTime   = 0;
    DWORD   dwTotalPages    = 0;

    if (dwNumJob == 0)
        return 0;

    if (dwPPM == 0)
        return DWERROR;

    for (DWORD i = 0; i < dwNumJob; i++,  pJobInfo++) {
        if (pJobInfo->Status & BIT_IGNORED_JOB)
            continue;
        if (pJobInfo->Status & BIT_ERROR_JOB)
            return DWERROR;

        if (pJobInfo->TotalPages > 0) {
            dwTotalPages += pJobInfo->TotalPages;
        }
        else {
            if (pJobInfo->Size) {
                dwTotalPages += 1 + ZeroIfNegative(pJobInfo->Size) / CHAR_PER_PAGE;
            }
        }
    }

    if (dwTotalPages)
        dwWaitingTime = 1 + dwTotalPages / dwPPM;

    return dwWaitingTime;
}


DWORD CPrinter::GetPPM()
{
    DWORD dwPrintRate;
    DWORD dwPrintRateUnit;

    // Get PrintRate
    dwPrintRate = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     NULL,
                                     DC_PRINTRATE,
                                     NULL,
                                     NULL);

    if (dwPrintRate == DWERROR ) {
        return dwPrintRate;
    }

    dwPrintRateUnit = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                         NULL,
                                         DC_PRINTRATEUNIT,
                                         NULL,
                                         NULL);

    switch (dwPrintRateUnit) {
    case PRINTRATEUNIT_PPM:         // PagesPerMinute
        break;
    case PRINTRATEUNIT_CPS:         // CharactersPerSecond
        dwPrintRate = CPS2PPM (dwPrintRate);
        break;
    case PRINTRATEUNIT_LPM:         // LinesPerMinute
        dwPrintRate = LPM2PPM (dwPrintRate);
        break;
    case PRINTRATEUNIT_IPM:         // InchesPerMinute
        dwPrintRate  = DWERROR;
        break;
    default:                        // Unknown
        dwPrintRate  = DWERROR;
        break;
    }

    return dwPrintRate ;
}

BOOL CPrinter::AllocGetPrinterInfo2()
{

    DWORD               dwNeeded = 0;
    PPRINTER_INFO_2     pPrinterInfo = NULL;
    LPTSTR              pszTmp;


    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a PRINTER_INFO_2 structure filled up

    if (GetPrinter(m_hPrinter, 2, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_2)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinter(m_hPrinter, 2, (byte *)pPrinterInfo, dwNeeded, &dwNeeded))) {

            if (pPrinterInfo)
                LocalFree(pPrinterInfo);

            if (! GetLastError())
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    // Mark the offline status if the attribute says offline
    if (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) {
        pPrinterInfo->Status |= PRINTER_STATUS_OFFLINE;
    }

    // Extract the first port for the case of pooled printing. i.e. we don't support pooled printing.
    if ( pPrinterInfo->pPortName) {
        if( pszTmp = _tcschr( pPrinterInfo->pPortName, TEXT(',')))
            *pszTmp = TEXT('\0');
    }

    if (m_pInfo2) {
        LocalFree (m_pInfo2);
    }

    m_pInfo2 = pPrinterInfo;

    return TRUE;
}

BOOL CPrinter::AllocGetPrinterInfo4()
{

    DWORD               dwNeeded = 0;
    PPRINTER_INFO_4     pPrinterInfo = NULL;

    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a PRINTER_INFO_4 structure filled up

    if (GetPrinter(m_hPrinter, 4, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_4)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinter(m_hPrinter, 4, (byte *)pPrinterInfo, dwNeeded, &dwNeeded))) {

            if (pPrinterInfo)
                LocalFree(pPrinterInfo);

            if (! (GetLastError()))
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    if (m_pInfo4) {
        LocalFree (m_pInfo4);
    }
    m_pInfo4 = pPrinterInfo;

    return TRUE;
}

BOOL CPrinter::AllocGetDriverInfo6()
{

    DWORD               dwNeeded = 0;
    PDRIVER_INFO_6      pDriverInfo = NULL;

    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a DRIVER_INFO_6 structure filled up

    if (GetPrinterDriver(m_hPrinter, NULL, 6, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pDriverInfo = (PDRIVER_INFO_6)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinterDriver(m_hPrinter, NULL, 6, (LPBYTE)pDriverInfo, dwNeeded, &dwNeeded))) {

            if (pDriverInfo)
                LocalFree(pDriverInfo);

            if (! (GetLastError()))
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    if (m_pDriverInfo6) {
        LocalFree (m_pDriverInfo6);
    }
    m_pDriverInfo6 = pDriverInfo;

    return TRUE;
}


PPRINTER_INFO_2 CPrinter::GetPrinterInfo2()
{
    if (m_pInfo2 == NULL) {
        if (! AllocGetPrinterInfo2())
            return NULL;
    }

    return m_pInfo2;
}

PDRIVER_INFO_6 CPrinter::GetDriverInfo6()
{
    if (m_pDriverInfo6 == NULL) {
        if (! AllocGetDriverInfo6()) {
            return NULL;
        }
    }

    return m_pDriverInfo6;
}


DWORD CPrinter::GetWaitingTime()
{
    if (!m_bCalcJobETA) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }
    return m_dwJobCompletionMinute;
}

BOOL CPrinter::GetJobEtaData (DWORD & dwWaitingTime, DWORD &dwJobCount, DWORD &dwJobSize, DWORD &dwJob)
{
    if (!m_bCalcJobETA) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwJobCount    = m_dwPendingJobCount;
    dwJobSize     = m_dwAvgJobSize;
    dwWaitingTime = m_dwJobCompletionMinute;
    dwJob         = m_dwAvgJobSizeUnit;

    return TRUE;
}


LPTSTR CPrinter::GetPrinterWebUrl(void)
{
    static const TCHAR c_szHttp[]   = TEXT("http://");
    static const TCHAR c_szHttps[]  = TEXT("https://");

    BOOL                bReturn = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwLen       = 0;
    TCHAR               szBuffer[MAX_COMPUTERNAME_LENGTH+1];
    DWORD               dwBufferSize;
    DWORD               dwAttributes;
    LPCTSTR             pszServerName;
    LPTSTR              pszShareName;
    LPTSTR              pszSplServerName;
    LPTSTR              pszSplPrinterName;
    LPTSTR              pszSplShareName;

    //
    // Get printer info 4 to fetch the attribute.
    //
    bReturn = AllocGetPrinterInfo4();

    if (!bReturn) {

        if (GetLastError () == ERROR_INVALID_LEVEL ) {
            //
            // Most likely it is a remote printers folder, no support for level4, so
            // we have to use level 2 instead.
            //
            if (! AllocGetPrinterInfo2())
                goto Cleanup;
        }
        else {
            //
            // The call fails with other reasons
            //
            goto Cleanup;
        }

    }
    else{

        if (m_pInfo4->Attributes & PRINTER_ATTRIBUTE_LOCAL) {
            // Check if the local flag is on. If so, try to get printer info2 for more information
            if (! AllocGetPrinterInfo2())
                goto Cleanup;
        }
    }

    //
    // Assume failure
    //
    bReturn = FALSE;


    if (m_pInfo2) {
        dwAttributes = m_pInfo2->Attributes;
        pszSplServerName = m_pInfo2->pServerName;
        pszSplPrinterName = m_pInfo2->pPrinterName;
        pszSplShareName = m_pInfo2->pShareName;
    }
    else
    {
        dwAttributes = m_pInfo4->Attributes;
        pszSplServerName = m_pInfo4->pServerName;
        pszSplPrinterName = m_pInfo4->pPrinterName;
        pszSplShareName = NULL;
    }

    //
    // Check if it is a printer connected to an http port
    // then the port name is the url.
    //
    if( m_pInfo2 )
    {

        if( m_pInfo2->pPortName )
        {
            //
            // Compare the port name prefex to see if it is an HTTP port.
            //
            if( !_tcsnicmp( m_pInfo2->pPortName, c_szHttp, _tcslen( c_szHttp ) ) ||
                !_tcsnicmp( m_pInfo2->pPortName, c_szHttps, _tcslen( c_szHttps ) ) )
            {
                //
                //  We always use portname as the URL
                //
                dwLen = 1 + lstrlen( m_pInfo2->pPortName );

                if (! (m_pszUrlBuffer = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
                {
                    goto Cleanup;
                }


                lstrcpy( m_pszUrlBuffer, m_pInfo2->pPortName );

                bReturn = TRUE;
                goto Cleanup;


            }
        }
    }


    //
    // If it is an unshared printer, return false
    //
    if ( !(dwAttributes & PRINTER_ATTRIBUTE_SHARED) )
    {
        goto Cleanup;
    }


    //
    // Check if it is a connection or a local printer or a masq printer
    // which is not connected over http, then build the url
    // from the \\server name\share name.
    //
    if( !pszSplServerName )
    {
        dwBufferSize = COUNTOF( szBuffer );

        if( !GetComputerName( szBuffer, &dwBufferSize ) )
        {
            goto Cleanup;
        }

        pszServerName = szBuffer;
    }
    //
    // Server name was provided then set our pointer to just
    // after the two leading wacks.
    //
    else
    {
        if( pszSplServerName[0] == TEXT('\\') &&
            pszSplServerName[1] == TEXT('\\') )
        {
            pszServerName = pszSplServerName + 2;
        }
        else
        {
            goto Cleanup;
        }
    }

    if ( !IsWebServerInstalled(pszSplServerName) ) {

        dwLastError = ERROR_NO_BROWSER_SERVERS_FOUND;
        goto Cleanup;
    }

    //
    // Build the URL -  http://server/printers/ipp_0004.asp?printer=ShareName
    //
    if (pszSplShareName)
    {
        pszShareName = pszSplShareName;
    }
    else {
        //
        //  Parse the sharename/printername  from the printer name
        //
        if(pszSplPrinterName) {
            if (pszSplPrinterName[0] == TEXT ('\\') && pszSplPrinterName[1] == TEXT ('\\') )
            {
                pszShareName = _tcschr (pszSplPrinterName + 2, TEXT ('\\'));
                pszShareName++;
            }
            else
                pszShareName = pszSplPrinterName;
        }
        else
        {
            goto Cleanup;
        }
    }

    GetWebUIUrl  (pszServerName, pszShareName, NULL, &dwLen);

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER )
    {
        goto Cleanup;
    }

    if (! (m_pszUrlBuffer = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
    {
        goto Cleanup;
    }

    if (!GetWebUIUrl  (pszServerName, pszShareName, m_pszUrlBuffer, &dwLen))
    {
        goto Cleanup;
    }

    //
    // Indicate success.
    //
    bReturn = TRUE;

    //
    // Clean any opened or allocated resources.
    //
Cleanup:


    //
    // If this routine failed then set the last error.
    //
    if( !bReturn )
    {
        //
        // If the last error was not set then a called routine may
        // have set the last error.  We don't want to clear the
        // last error.
        //
        if( dwLastError != ERROR_SUCCESS )
        {
            SetLastError( dwLastError );
        }
    }
    return m_pszUrlBuffer;
}

BOOL CPrinter::GetDriverData(
    DriverData dwDriverData,
    LPTSTR &pszData)
{
    static const ULONG_PTR ulpOffset[LastDriverData] = {
        // This has the offsets into the DRIVER_INFO_6 structure.....
        ULOFFSET( PDRIVER_INFO_6, pszOEMUrl )     ,
        ULOFFSET( PDRIVER_INFO_6, pszHardwareID ) ,
        ULOFFSET( PDRIVER_INFO_6, pszMfgName)
    };

    LPTSTR pszDataString = NULL;
    BOOL   bRet          = FALSE;
    DWORD  dwSize;

    ASSERT( (int)dwDriverData >= 0 && (int)dwDriverData < LastDriverData );

    if (! GetDriverInfo6() )
        goto Cleanup;

    pszDataString = *(LPTSTR *)(((ULONG_PTR) m_pDriverInfo6) +  ulpOffset[dwDriverData] );

    if (pszDataString == NULL || *pszDataString == NULL)
        goto Cleanup;

    dwSize = sizeof(TCHAR) * (lstrlen( pszDataString ) + 1);

    if (! (pszData  = (LPTSTR)LocalAlloc(LPTR, dwSize)))
        goto Cleanup;

    lstrcpy( pszData, pszDataString);

    bRet = TRUE;
Cleanup:
    return bRet;
}

BOOL CPrinter::ParseUrlPattern(
    LPTSTR pSrc,
    LPTSTR pDest,
    DWORD &dwDestLen)
{
    const dwMaxMacroLen = 255;
    enum {
        NORMALTEXT, STARTMACRO
    } URL_PATTERN_STATE;


    BOOL bRet = FALSE;
    DWORD dwLen = 0;
    DWORD dwMacroLen = 0;
    DWORD dwAvailbleSize;
    DWORD dwState = NORMALTEXT;
    int i;
    TCHAR ch;
    TCHAR szMacroName [dwMaxMacroLen + 1];
    LPTSTR pMacroValue = NULL;

    LPTSTR pszMacroList[] = {
        TEXT ("MODEL"),
        TEXT ("HARDWAREID"),
    };


    while (ch = *pSrc++) {
        switch (dwState) {
        case NORMALTEXT:
            if (ch == TEXT ('%')) {
                // Start a macro
                dwState = STARTMACRO;
                dwMacroLen = 0;
                szMacroName[0] = 0;
            }
            else {
                if (dwLen >= dwDestLen) {
                    dwLen ++;
                }
                else {
                    pDest[dwLen++] = ch;
                }
            }

            break;
        case STARTMACRO:
            if (ch == TEXT ('%')) {
                szMacroName[dwMacroLen] = 0;
                // Replace Macro
                for (int i = 0; i < sizeof (pszMacroList) / sizeof (pszMacroList[0]); i++) {
                    if (!lstrcmpi (szMacroName, pszMacroList[i])) {

                        pMacroValue = 0;
                        switch (i) {
                        case 0:
                            AssignString (pMacroValue, m_pInfo2->pDriverName);
                            break;
                        case 1:
                            GetDriverData (HardwareID , pMacroValue);
                            break;
                        default:
                            break;
                        }

                        if (pMacroValue) {

                            if (dwDestLen > dwLen)
                                dwAvailbleSize =  dwDestLen - dwLen;
                            else
                                dwAvailbleSize = 0;

                            TCHAR szPlaceHolder[1];
                            DWORD dwBufSize = sizeof (szPlaceHolder) / sizeof (TCHAR);
                            if (!InternetCanonicalizeUrl (pMacroValue, szPlaceHolder, &dwBufSize, 0)) {
                                if (dwBufSize < dwAvailbleSize ) {
                                    if (!InternetCanonicalizeUrl (pMacroValue, pDest + dwLen, &dwBufSize, 0)) {
                                        LocalFree (pMacroValue);
                                        return bRet;
                                    }
                                    else {
                                        dwLen = lstrlen (pDest);
                                    }
                                }
                                else {
                                    dwLen += dwBufSize;
                                }
                            }
                            LocalFree (pMacroValue);
                        }
                        break;
                    }
                }

                dwState = NORMALTEXT;
            }
            else {
                if (dwMacroLen < dwMaxMacroLen) {
                    szMacroName[dwMacroLen ++] = ch;
                }
            }
            break;
        }
    }

    if (dwState == STARTMACRO) {
        SetLastError ( ERROR_INVALID_DATA );
    }
    else {
        if (dwLen >= dwDestLen) {
            SetLastError (ERROR_INSUFFICIENT_BUFFER);
            dwDestLen = dwLen + 1;
        }
        else {
            pDest[dwLen] = 0;
            bRet = TRUE;
        }
    }

    return bRet;

}

LPTSTR CPrinter::GetOemUrl(
    LPTSTR & pszManufacturer)
{
    LPTSTR pszOemUrlPattern = NULL;
    DWORD dwLen = 0;
    LPTSTR pszUrl = NULL;

    if (!GetPrinterInfo2 () )
        goto Cleanup;

    if (GetDriverData (OEMUrlPattern, pszOemUrlPattern)) {

        if (! ParseUrlPattern (pszOemUrlPattern, NULL, dwLen)
            && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            m_pszOemUrl = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwLen);
            if (m_pszOemUrl) {

                if (!ParseUrlPattern (pszOemUrlPattern, m_pszOemUrl, dwLen))
                    goto Cleanup;
            }
            else
                goto Cleanup;
        }

    }

    if (GetDriverData (Manufacturer, m_pszManufacturer)) {
        pszManufacturer = m_pszManufacturer;
        pszUrl =  m_pszOemUrl;
    }

Cleanup:
    if (pszOemUrlPattern) {
        LocalFree ( pszOemUrlPattern);
    }

    return pszUrl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\printer.h ===
// Printer.h: interface for the CPrinter class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _PRINTER_H
#define _PRINTER_H

/***********************************************\
* Define      - ULOFFSET
*
* Description - This gives the offset into a data structure
\***********************************************/
#define ULOFFSET(type, identifier)  ((ULONG_PTR)&(((type)0)->identifier))


class CPrinter
{
public:
    DWORD           GetWaitingTime();
    BOOL            GetJobEtaData (DWORD &, DWORD &, DWORD &, DWORD &);
    LPTSTR          GetPrinterWebUrl();
    LPTSTR          GetOemUrl(LPTSTR & pszManufactureName);

    PPRINTER_INFO_2 GetPrinterInfo2 ();
    BOOL            CalJobEta();
    BOOL            Open (LPTSTR pPrinterName, LPHANDLE phPrinter = NULL);
    CPrinter();
    virtual ~CPrinter();

private:

    enum DriverData {
        OEMUrlPattern = 0,
        HardwareID,
        Manufacturer,
        LastDriverData      // This must always be the last member of the Enum.
        };

    PDRIVER_INFO_6  GetDriverInfo6 ();
    
    BOOL            AllocGetPrinterInfo2();
    BOOL            AllocGetPrinterInfo4();
    BOOL            AllocGetDriverInfo6();

    DWORD           GetPPM();
    DWORD           GetWaitingMinutes(DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob);
    BOOL            GetDriverData(DriverData dwDriverData, LPTSTR &pszData);
    BOOL            ParseUrlPattern(LPTSTR pSrc, LPTSTR pDest, DWORD &dwDestLen);

    HANDLE          m_hPrinter;
    PPRINTER_INFO_2 m_pInfo2;
    PPRINTER_INFO_4 m_pInfo4;
    PDRIVER_INFO_6  m_pDriverInfo6;
    BOOL            m_bCalcJobETA;
    DWORD           m_dwPendingJobCount;
    DWORD           m_dwAvgJobSize;
    DWORD           m_dwJobCompletionMinute;
    DWORD           m_dwAvgJobSizeUnit;

    LPTSTR          m_pszUrlBuffer;

    LPTSTR          m_pszOemUrl;
    LPTSTR          m_pszManufacturer;
};

#else

class CPrinter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\resource.h ===
// This script must be edited manually, originally generated by Visual Studio
//
// Used by oleprn.rc
//
#define IDS_PROJNAME                    100
#define IDR_PRTURL                      101
#define IDR_SNMP                        102
#define IDR_ASPHELP                     103
#define IDS_ADDPRINT_DESC               104
#define IDR_DSPRINTQUEUE                104
#define IDR_AddPrint                    105
#define IDS_ADDPRINT_PROGID             105
#define IDS_OLEPRN_PROGID               106
#define IDS_OLESNMP_PROGID              107
#define IDS_PRTURL_PROGID               108
#define IDR_OLECVT                      109
#define IDR_OLEINSTALL                  110

#define IDS_ENVELOPE_10X13              150
#define IDS_ENVELOPE_10X14              151
#define IDS_ENVELOPE_10X15              152
#define IDS_ENVELOPE_6X9                153
#define IDS_ENVELOPE_7X9                154
#define IDS_ENVELOPE_9X11               155
#define IDS_ENVELOPE_9X12               156
#define IDS_A0_841_X_1189_MM            157
#define IDS_A1_594_X_841_MM             158
#define IDS_A10_26_X_37_MM              159
#define IDS_A2_420_X_594_MM             160
#define IDS_A3_297_X_420_MM             161
#define IDS_A4_210_X_297_MM             163
#define IDS_A5_148_X_210_MM             164
#define IDS_A6_105_X_148_MM             165
#define IDS_A7_74_X_105_MM              166
#define IDS_A8_52_X_74_MM               167
#define IDS_A9_37_X_52_MM               168
#define IDS_B0_1000_X_1414_MM           169
#define IDS_B0_1030_X_1456_MM           170
#define IDS_B1_707_X_1000_MM            171
#define IDS_B1_728_X_1030_MM            172
#define IDS_B10_31_X_44_MM              173
#define IDS_B10_32_X_45_MM              174
#define IDS_B10_64_X_91_MM              175
#define IDS_B2_500_X_707_MM             176
#define IDS_B2_515_X_728_MM             177
#define IDS_B3_353_X_500_MM             178
#define IDS_B3_364_X_515_MM             179
#define IDS_B4_250_X_353_MM             180
#define IDS_B4_257_X_364_MM             181
#define IDS_B4_ENVELOPE_250_X_353_MM    182
#define IDS_B5_176_X_250_MM             183
#define IDS_B5_182_X_257_MM             184
#define IDS_B5_ENVELOPE_176_X_250_MM    185
#define IDS_B6_125_X_176_MM             186
#define IDS_B6_128_X_182_MM             187
#define IDS_B6_257_X_364_MM             188
#define IDS_B7_182_X_257_MM             189
#define IDS_B7_88_X_125_MM              190
#define IDS_B7_91_X_128_MM              191
#define IDS_B8_128_X_182_MM             192
#define IDS_B8_62_X_88_MM               193
#define IDS_B8_64_X_91_MM               194
#define IDS_B9_44_X_62_MM               195
#define IDS_B9_45_X_64_MM               196
#define IDS_B9_91_X_128_MM              197
#define IDS_C0_917_X_1297_MM            198
#define IDS_C1_648_X_917_MM             199
#define IDI_WEBPNPICON                  200
#define IDS_C2_458_X_648_MM             200
#define IDS_C3_324_X_458_MM             201
#define IDS_C4_ENVELOPE_229_X_324_MM    202
#define IDS_C5_ENVELOPE_162_X_229_MM    203
#define IDS_C6_114_X_162_MM             204
#define IDS_C7_81_X_114_MM              205
#define IDS_C8_57_X_81_MM               206
#define IDS_DL_ENVELOPE_110_X_220_MM    207
#define IDS_ENGINEERING_A_8_5_X_11_IN   208
#define IDS_ENGINEERING_B_11_X_17_IN    209
#define IDS_ENGINEERING_C_17_X_22_IN    210
#define IDS_ENGINEERING_D_22_X_34_IN    211
#define IDS_ENGINEERING_E_34_X_44_IN    212
#define IDS_ENVELOPE_10                 213
#define IDS_ENVELOPE_9                  214
#define IDS_LEGAL_8_5_X_14_IN           215
#define IDS_LETTER_8_5_X_11_IN          216
#define IDS_SNMP_ERRORSTATUS_NOERROR    250
#define IDS_SNMP_ERRORSTATUS_TOOBIG     251
#define IDS_SNMP_ERRORSTATUS_NOSUCHNAME 252
#define IDS_SNMP_ERRORSTATUS_BADVALUE   253
#define IDS_SNMP_ERRORSTATUS_READONLY   254
#define IDS_SNMP_ERRORSTATUS_GENERR     255
#define IDS_SNMP_ERRORSTATUS_NOACCESS   256
#define IDS_SNMP_ERRORSTATUS_WRONGTYPE  257
#define IDS_SNMP_ERRORSTATUS_WRONGLENGTH 258
#define IDS_SNMP_ERRORSTATUS_WRONGENCODING 259
#define IDS_SNMP_ERRORSTATUS_WRONGVALUE 260
#define IDS_SNMP_ERRORSTATUS_NOCREATION 261
#define IDS_SNMP_ERRORSTATUS_INCONSISTENTVALUE 262
#define IDS_SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE 263
#define IDS_SNMP_ERRORSTATUS_COMMITFAILED 264
#define IDS_SNMP_ERRORSTATUS_UNDOFAILED 265
#define IDS_SNMP_ERRORSTATUS_AUTHORIZATIONERROR 266
#define IDS_SNMP_ERRORSTATUS_NOTWRITABLE 267
#define IDS_SNMP_ERRORSTATUS_INCONSISTENTNAME 268
#define IDS_SNMPAPI_ALLOC_ERROR         270
#define IDS_SNMPAPI_CONTEXT_INVALID     271
#define IDS_SNMPAPI_CONTEXT_UNKNOWN     272
#define IDS_SNMPAPI_ENTITY_INVALID      274
#define IDS_SNMPAPI_ENTITY_UNKNOWN      275
#define IDS_SNMPAPI_INDEX_INVALID       276
#define IDS_SNMPAPI_NOOP                277
#define IDS_SNMPAPI_OID_INVALID         278
#define IDS_SNMPAPI_OPERATION_INVALID   279
#define IDS_SNMPAPI_OUTPUT_TRUNCATED    280
#define IDS_SNMPAPI_PDU_INVALID         281
#define IDS_SNMPAPI_SESSION_INVALID     282
#define IDS_SNMPAPI_SYNTAX_INVALID      283
#define IDS_SNMPAPI_VBL_INVALID         284
#define IDS_SNMPAPI_MODE_INVALID        285
#define IDS_SNMPAPI_SIZE_INVALID        286
#define IDS_SNMPAPI_NOT_INITIALIZED     287
#define IDS_SNMPAPI_MESSAGE_INVALID     288
#define IDS_SNMPAPI_HWND_INVALID        289
#define IDS_SNMPAPI_OTHER_ERROR         290
#define IDS_SNMPAPI_TL_NOT_INITIALIZED  291
#define IDS_SNMPAPI_TL_NOT_SUPPORTED    292
#define IDS_SNMPAPI_TL_NOT_AVAILABLE    293
#define IDS_SNMPAPI_TL_RESOURCE_ERROR   294
#define IDS_SNMPAPI_TL_UNDELIVERABLE    295
#define IDS_SNMPAPI_TL_SRC_INVALID      296
#define IDS_SNMPAPI_TL_INVALID_PARAM    297
#define IDS_SNMPAPI_TL_IN_USE           298
#define IDS_SNMPAPI_TL_TIMEOUT          299
#define IDS_SNMPAPI_TL_PDU_TOO_BIG      300
#define IDS_SNMPAPI_TL_OTHER            301

#define IDS_NO_PRINTER_OPEN             512
#define IDS_OUT_OF_MEMORY               513
#define IDS_DATA_NOT_SUPPORTED          514
#define IDS_NO_XCVDATA                  515
#define IDS_INVALIDARG                  516
#define IDS_NO_SNMP_SESSION             517
#define IDS_FAILED_OPEN_SNMP            518
#define IDS_MIBERR_OTHER                1000
#define IDS_MIBERR_UNKNOWN              1001
#define IDS_MIBERR_COVEROPEN            1002
#define IDS_MIBERR_COVERCLOSED          1003
#define IDS_MIBERR_INTERLOCKOPEN        1004
#define IDS_MIBERR_INTERLOCKCLOSED      1005
#define IDS_MIBERR_CONFIGURATIONCHANGE  1006
#define IDS_MIBERR_JAM                  1007
#define IDS_MIBERR_DOOROPEN             1008
#define IDS_MIBERR_DOORCLOSED           1009
#define IDS_MIBERR_POWERUP              1010
#define IDS_MIBERR_POWERDOWN            1011
#define IDS_MIBERR_INPUTMEDIATRAYMISSING 1012
#define IDS_MIBERR_INPUTMEDIASIZECHANGE 1013
#define IDS_MIBERR_INPUTMEDIAWEIGHTCHANGE 1014
#define IDS_MIBERR_INPUTMEDIATYPECHANGE 1015
#define IDS_MIBERR_INPUTMEDIACOLORCHANGE 1016
#define IDS_MIBERR_INPUTMEDIAFORMPARTSCHANGE 1017
#define IDS_MIBERR_INPUTMEDIASUPPLYLOW  1018
#define IDS_MIBERR_INPUTMEDIASUPPLYEMPTY 1019
#define IDS_MIBERR_OUTPUTMEDIATRAYMISSING 1020
#define IDS_MIBERR_OUTPUTMEDIATRAYALMOSTFULL 1021
#define IDS_MIBERR_OUTPUTMEDIATRAYFULL  1022
#define IDS_MIBERR_MARKERFUSERUNDERTEMPERATURE 1023
#define IDS_MIBERR_MARKERFUSEROVERTEMPERATURE 1024
#define IDS_MIBERR_MARKERTONEREMPTY     1025
#define IDS_MIBERR_MARKERINKEMPTY       1026
#define IDS_MIBERR_MARKERPRINTRIBBONEMPTY 1027
#define IDS_MIBERR_MARKERTONERALMOSTEMPTY 1028
#define IDS_MIBERR_MARKERINKALMOSTEMPTY 1029
#define IDS_MIBERR_MARKERPRINTRIBBONALMOSTEMPTY 1030
#define IDS_MIBERR_MARKERWASTETONERRECEPTACLEALMOSTFULL 1031
#define IDS_MIBERR_MARKERWASTEINKRECEPTACLEALMOSTFULL 1032
#define IDS_MIBERR_MARKERWASTETONERRECEPTACLEFULL 1033
#define IDS_MIBERR_MARKERWASTEINKRECEPTACLEFULL 1034
#define IDS_MIBERR_MARKEROPCLIFEALMOSTOVER 1035
#define IDS_MIBERR_MARKEROPCLIFEOVER    1036
#define IDS_MIBERR_MARKERDEVELOPERALMOSTEMPTY 1037
#define IDS_MIBERR_MARKERDEVELOPEREMPTY 1038
#define IDS_MIBERR_MEDIAPATHMEDIATRAYMISSING 1039
#define IDS_MIBERR_MEDIAPATHMEDIATRAYALMOSTFULL 1040
#define IDS_MIBERR_MEDIAPATHMEDIATRAYFULL 1041
#define IDS_MIBERR_INTERPRETERMEMORYINCREASE 1042
#define IDS_MIBERR_INTERPRETERMEMORYDECREASE 1043
#define IDS_MIBERR_INTERPRETERCARTRIDGEADDED 1044
#define IDS_MIBERR_INTERPRETERCARTRIDGEDELETED 1045
#define IDS_MIBERR_INTERPRETERRESOURCEADDED 1046
#define IDS_MIBERR_INTERPRETERRESOURCEDELETED 1047
#define IDS_MIBERR_INTERPRETERRESOURCEUNAVAILABLE 1048
#define IDS_ERROR_CPUNOTSUPPORTED       2000
#define IDS_ERROR_DRIVERNOTFOUND        2001
#define IDS_ERROR_WPNPINST_TERMINATED   2002
#define IDS_ERROR_INTERNAL_SERVER       2003
#define IDS_ERROR_SERVER_DISK_FULL      2004
#define IDS_ERROR_TRUST_E_NOSIGNATURE   2005
#define IDS_ERROR_LOCAL_PRINTER_ACCESS  2006
#define IDS_ERROR_IE_SECURITY_DENIED    2007
#define IDS_CRYPT_E_FILE_ERROR          2008

// The following Resources must be defined in order
#define IDS_SECURITY_ADD_WEB_PRN        3000
#define IDS_SECURITY_ADD_WEB_PRN_MSG    3001
#define IDS_SECURITY_ADD_CONNECTION     3002
#define IDS_SECURITY_ADD_CONNECTION_MSG 3003
#define IDS_SECURITY_DELETE_PRINTER     3004
#define IDS_SECURITY_DELETE_PRINTER_MSG 3005
#define START_SECURITY_DIALOGUE_RES     IDS_SECURITY_ADD_WEB_PRN  // Must be set to the first resource

#define ERROR_DRIVER_NOT_FOUND          5500
#define ERROR_WPNPINST_TERMINATED       5510
#define ERROR_INTERNAL_SERVER           5511
#define ERROR_SERVER_DISK_FULL          5512
#define ERROR_TRUST_E_NOSIGNATURE      (TRUST_E_NOSIGNATURE & 0xFFFF)
#define ERROR_SPAPI_E_NO_CATALOG       (SPAPI_E_NO_CATALOG_FOR_OEM_INF & 0xFFFF)
#define ERROR_TRUST_E_BAD_DIGEST       (TRUST_E_BAD_DIGEST & 0xFFFF)
#define ERROR_LOCAL_PRINTER_ACCESS      5520
#define ERROR_IE_SECURITY_DENIED        5521

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif

#define WM_ON_INFO_READY   (WM_USER+300)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\prturl.cpp ===
// prturl.cpp : Implementation of Cprturl
#include "stdafx.h"

#include "oleprn.h"
#include "prturl.h"
#include "printer.h"

/////////////////////////////////////////////////////////////////////////////
// Cprturl
#ifndef WIN9X

// generate proper HRESULT from Win32 last error
inline HRESULT HRESULTFromWIN32()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

HRESULT Cprturl::PrivateGetSupportValue (LPTSTR pValueName, BSTR * pVal)
{
// The max length of the link is 255 as defined in winnt.adm
#define MAX_LINK_LEN 256

    static  TCHAR szPrinterPath[]   = TEXT ("Software\\Policies\\Microsoft\\Windows NT\\Printers");
    HKEY    hPrinterKey             = NULL;
    TCHAR   szBuffer[MAX_LINK_LEN]  = {0};
    BOOL    bRet                    = FALSE;
    DWORD   dwSize                  = sizeof (szBuffer);
    DWORD   dwType;

    if (ERROR_SUCCESS == RegOpenKeyEx  (HKEY_LOCAL_MACHINE,
                                        szPrinterPath,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hPrinterKey)) {

        if ((ERROR_SUCCESS == RegQueryValueEx (hPrinterKey,
                                               pValueName,
                                               0,
                                               &dwType,
                                               (LPBYTE) szBuffer,
                                               &dwSize))
             && dwType == REG_SZ) {

            bRet = TRUE;

        }

        RegCloseKey (hPrinterKey);
    }

    if (!bRet) {
        szBuffer[0] = 0;
    }

    if (*pVal = SysAllocString (szBuffer))
        return S_OK;
    else
        return Error(IDS_OUT_OF_MEMORY, IID_Iprturl, E_OUTOFMEMORY);
}

STDMETHODIMP Cprturl::get_SupportLinkName(BSTR * pVal)
{
   return PrivateGetSupportValue (TEXT ("SupportLinkName"), pVal);
}

STDMETHODIMP Cprturl::get_SupportLink(BSTR * pVal)
{
   return PrivateGetSupportValue (TEXT ("SupportLink"), pVal);
}

STDMETHODIMP Cprturl::put_PrinterName(BSTR newVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!newVal || 0 == newVal[0])
        {
            //
            // The printer name can't ne NULL or empty string.
            //
            hr = E_INVALIDARG;
            break;
        }

        CPrinter printer;
        if (!printer.Open(newVal))
        {
            //
            // Failed to open the printer. This is fatal.
            //
            hr = HRESULTFromWIN32();
            break;
        }

        LPTSTR pszOemName = NULL;
        LPTSTR pszOemUrl = printer.GetOemUrl(pszOemName);
        LPTSTR pszWebUrl = printer.GetPrinterWebUrl();

        CAutoPtrBSTR spbstrPrinterWebURL = SysAllocString(pszWebUrl);
        CAutoPtrBSTR spbstrPrinterOemURL = SysAllocString(pszOemUrl);
        CAutoPtrBSTR spbstrPrinterOemName = SysAllocString(pszOemName);

        if ((pszWebUrl  && !spbstrPrinterWebURL) || 
            (pszOemUrl  && !spbstrPrinterOemURL) || 
            (pszOemName && !spbstrPrinterOemName))
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // If we are here then everything has succeeded.
        // Remember the new strings.
        //
        m_spbstrPrinterWebURL = spbstrPrinterWebURL.Detach();
        m_spbstrPrinterOemURL = spbstrPrinterOemURL.Detach();
        m_spbstrPrinterOemName = spbstrPrinterOemName.Detach();
        hr = S_OK;
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterWebURL(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterWebURL)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterWebURL);
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterOemURL(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterOemURL)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterOemURL);
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterOemName(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterOemName)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterOemName);
    }
    while(false);
    return hr;
}

#endif

STDMETHODIMP Cprturl::get_ClientInfo(long *lpdwInfo)
{
    if (lpdwInfo == NULL)
        return E_POINTER;

    *lpdwInfo = (long)webCreateOSInfo();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\slist.h ===
#ifndef _SLIST_H
#define _SLIST_H

//////////////////////////////////////////////////////////////////////
//
// slist.h: template for the SingleList class.
//
//////////////////////////////////////////////////////////////////////

#include "csem.h"
#include "sitem.h"

template <class T> class CSingleList
    : public CCriticalSection
{
public:
    CSingleList( void );
    ~CSingleList( void );
    BOOL Insert ( T);
    BOOL Delete ( T);
    virtual T Find (T );
private:
    CSingleItem <T> m_Dummy;
};


//////////////////////////////////////////////////////////////////////
// Template for CSIngleList
//////////////////////////////////////////////////////////////////////

template <class T>
CSingleList<T>::CSingleList<T>(void)
               :m_Dummy ()
{
}

template <class T>
CSingleList<T>::~CSingleList<T>(void)
{
    CSingleItem<T> *pItem = m_Dummy.GetNext();
    CSingleItem<T> *pNext;

    while (pItem) {
        pNext = pItem->GetNext();
        delete pItem;
        pItem = pNext;
    }
}

template <class T>
BOOL CSingleList<T>::Insert (T item)
{
    BOOL bRet = FALSE;

    Lock();

    CSingleItem<T> *pNewItem = new CSingleItem<T> (item, m_Dummy.GetNext());

    if (pNewItem) {
        m_Dummy.SetNext (pNewItem);
        bRet = TRUE;
    }

    Unlock();
    return bRet;
}

template <class T>
BOOL CSingleList<T>::Delete (T item)
{
    CSingleItem<T> *pHead = &m_Dummy;
    CSingleItem<T> *pItem;
    BOOL    bRet = FALSE;

    Lock();

    while (pItem = pHead->GetNext()) {
        if (pItem->IsSame (item)) {
            // Delete it
            pHead->SetNext (pItem->GetNext ());
            delete (pItem);
            bRet = TRUE;
            break;
        }
        pHead = pHead->GetNext();
    }
    Unlock();

    return FALSE;
}

template <class T>
T CSingleList<T>::Find (T item)
{

    Lock();

    CSingleItem<T> *pItem = m_Dummy.GetNext();

    while (pItem) {
        if (pItem->IsSame (item)) {
            Unlock ();
            return pItem->GetData();
        }
        pItem = pItem->GetNext();
    }

    Unlock ();

    return NULL;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\prturl.h ===
// prturl.h : Declaration of the Cprturl

#ifndef __PRTURL_H_
#define __PRTURL_H_

/////////////////////////////////////////////////////////////////////////////
// Cprturl
class ATL_NO_VTABLE Cprturl :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<Cprturl, &CLSID_prturl>,
    public ISupportErrorInfoImpl<&IID_Iprturl>,
    public IDispatchImpl<Iprturl, &IID_Iprturl, &LIBID_OLEPRNLib>
{
public:
    Cprturl()
    {
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PRTURL)
//DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(Cprturl)
    COM_INTERFACE_ENTRY(Iprturl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// Iprturl

#ifndef WIN9X
private:
    HRESULT PrivateGetPrinterData(LPTSTR strPrnName, LPTSTR pszKey, LPTSTR pszValueName, BSTR * pVal);
    HRESULT PrivateGetSupportValue (LPTSTR pValueName, BSTR * pVal);

public:
    STDMETHOD(get_SupportLinkName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SupportLink)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_PrinterName)(/* [in] */ BSTR newVal);
    STDMETHOD(get_PrinterWebURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PrinterOemURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PrinterOemName)(/*[out, retval]*/ BSTR *pVal);
#endif
    STDMETHOD(get_ClientInfo)(/*[out, retval]*/ long *lpdwInfo);

#ifndef WIN9X
private:
    CAutoPtrBSTR m_spbstrPrinterWebURL;
    CAutoPtrBSTR m_spbstrPrinterOemURL;
    CAutoPtrBSTR m_spbstrPrinterOemName;
#endif
};

#endif //__PRTURL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\prnsec.cpp ===
/*****************************************************************************\
* MODULE:       prnsec.cpp
*
* PURPOSE:      Implementations 
*
* Copyright (C) 1999 Microsoft Corporation
*
* History:
*
*     09/2/99  mlawrenc    First implemented the security templates
*
\*****************************************************************************/

#include "stdafx.h"
#include <stdio.h>

///////////////////////////////////////////////////////////////////////////////
// Static Data Members
///////////////////////////////////////////////////////////////////////////////
LPTSTR      COlePrnSecurity::m_MsgStrings[EndMessages*2] = { NULL };
const DWORD COlePrnSecurity::dwMaxResBuf                 = 256;

///////////////////////////////////////////////////////////////////////////////
// Methods
///////////////////////////////////////////////////////////////////////////////
COlePrnSecurity::COlePrnSecurity(IN IUnknown *&iSite, 
                                 IN DWORD &dwSafety ) 
/*++

Routine Description:

    This initialises all of the required members

Arguments:
            iSite    - A reference to the Site Interface pointer
            dwSafety - A reference to the ATL Safety Flags member
                   
--*/
    : m_iSite(iSite),
      m_dwSafetyFlags(dwSafety),
      m_bDisplayUIonDisallow(TRUE),
      m_iSecurity(NULL) {
}


COlePrnSecurity::~COlePrnSecurity() 
/*++

Routine Description:

    This clears any memory we have had to allocate

--*/
    {
    if (m_iSecurity) 
        m_iSecurity->Release();
}



HRESULT COlePrnSecurity::GetActionPolicy(IN  DWORD dwAction, 
                                         OUT DWORD &dwPolicy)
/*++

Routine Description:
    Sees whether the requested action is allowed by the site. 
    

Arguments:
    dwAction    : The action which we want to perform
    dwPolicy    : The policy associated with the action
    
Return Value:
    S_OK or S_FAIL the Policy was returned, S_OK generally means don't prompt
    E_XXXXX

--*/
    {
    HRESULT hr = S_OK;

    dwPolicy = URLPOLICY_DISALLOW;
    
    if (!(m_dwSafetyFlags & INTERFACESAFE_FOR_UNTRUSTED_CALLER)) {
        dwPolicy = URLPOLICY_ALLOW;
        goto Cleanup;
    }
       
    if (NULL == m_iSecurity &&
        FAILED( hr = SetSecurityManager()) ) 
        goto Cleanup;
    
    _ASSERTE(m_iSecurity != NULL);

    hr = m_iSecurity->ProcessUrlAction(dwAction,
                                       (LPBYTE)&dwPolicy,
                                       sizeof(dwPolicy),
                                       NULL,
                                       0,
                                       m_bDisplayUIonDisallow ? PUAF_WARN_IF_DENIED : PUAF_NOUI,
                                       0);
    if (FAILED(hr)) {
        dwPolicy = URLPOLICY_DISALLOW;
        goto Cleanup;
    }
    
Cleanup:

    return hr;
}


HRESULT COlePrnSecurity::SetSecurityManager(void) 
/*++

Routine Description:
    Sets up the security manager 
    
Return Value:
    E_FAIL         - Failed to instantiate
    E_NOINTERFACE  - There was no security Manager
    S_OK           - We instantiated the security manager

--*/
    {
    HRESULT          hr                 = E_NOINTERFACE;
    IServiceProvider *iServiceProvider  = NULL;
    
    if (NULL != m_iSecurity) {
        hr = S_OK;
        goto Cleanup;
    }

    if (NULL == m_iSite)
        goto Cleanup;
    
    if ( FAILED(hr = m_iSite->QueryInterface(IID_IServiceProvider, 
                                             (LPVOID *)&iServiceProvider) ) )
        goto Cleanup;
    
    // From the Service Provider, we can get the security Manager if there is one
    hr = iServiceProvider->QueryService(SID_SInternetHostSecurityManager,
                                        IID_IInternetHostSecurityManager,
                                        (LPVOID *)&m_iSecurity);

    // Either of these are equivalent to allowing the policy to go through
    // We have a Security Manager
Cleanup:

    if (iServiceProvider) 
        iServiceProvider->Release();

    return hr;
}


LPTSTR COlePrnSecurity::LoadResString(UINT uResId)
/*++

Routine Description:
    Allocate and return a resource string.
    
Parameters:
    uResId  - Resource Id to load    
    
Return Value:
    The String or NULL

--*/
    {
    TCHAR  szStr[dwMaxResBuf];
    DWORD  dwLength;
    LPTSTR lpszRet = NULL;


    dwLength = LoadString(_Module.GetResourceInstance(), uResId, szStr, dwMaxResBuf);
    
    if (dwLength == 0) 
        goto Cleanup;

    dwLength = (dwLength + 1)*sizeof(TCHAR);
    
    lpszRet = (LPTSTR)LocalAlloc( LPTR, dwLength );

    if (NULL == lpszRet) 
        goto Cleanup;

    lstrcpy( lpszRet, szStr );

Cleanup:
    return lpszRet;
}

BOOL COlePrnSecurity::InitStrings(void) 
/*++

Routine Description:
    Initialise all of the security strings. It either allocates all of them or none
    
Return Value:
    TRUE if successful, False otherwise

--*/
    {
    BOOL bRet = TRUE;

    for(DWORD dwIndex = StartMessages; dwIndex < (EndMessages*2); dwIndex++) {
        m_MsgStrings[dwIndex] = LoadResString(START_SECURITY_DIALOGUE_RES + dwIndex);
        if (NULL == m_MsgStrings[dwIndex]) {
            DeallocStrings();       // Deallocate any we have allocated
            bRet = FALSE;
            break;
        }
    }

    return bRet;
}

void COlePrnSecurity::DeallocStrings(void)  
/*++

Routine Description:
    Deallocate all of the security strings
   
--*/
    {
    for(DWORD dwIndex = StartMessages; dwIndex < (EndMessages*2); dwIndex++) {
        if (NULL != m_MsgStrings[dwIndex]) {
            LocalFree( m_MsgStrings[dwIndex]);
            m_MsgStrings[dwIndex] = NULL;
        }
    }
}

HRESULT COlePrnSecurity::PromptUser(SecurityMessage eMessage,
                                    LPTSTR          lpszOther) 
/*++

Routine Description:
    Prompt the user with a [Yes]/[No] Message Box based on the message passed in and
    the other string passed in (which is substituted in with sprintf()
    
Parameters:
    eMessage  - The Message to display
    lpszOther - Other Data to display
    
Return Value:
    E_POINTER       - lpszOther was NULL
    E_OUTOFMEMORY   - Could not allocate temporary storage
    E_UNEXPECTED    - sprintf wrote more character than we thought
    S_OK            - The Dialogue Box was displayed and the user selected [Yes]
    S_FALSE         - The Dialogue Box was displayed and the user selected [No]

--*/
    {
    HRESULT hr          = E_POINTER;
    DWORD   dwIndex     = ((DWORD)eMessage)*2;
    LPTSTR  lpszMessage = NULL;
    DWORD   dwLength;
    int     iMBRes;     
    

    if (NULL == lpszOther) 
        goto Cleanup;

    _ASSERTE( dwIndex < EndMessages );              // Must be a valid message
    _ASSERTE( m_MsgStrings[dwIndex    ]  != NULL ); // The table must have been initialised
    _ASSERTE( m_MsgStrings[dwIndex + 1]  != NULL );
    
    // Required Length of the message string
    dwLength = lstrlen( m_MsgStrings[dwIndex+1] ) + lstrlen( lpszOther ) + 1; 
    
    lpszMessage = (LPTSTR)LocalAlloc( LPTR , dwLength * sizeof(TCHAR) );

    if (NULL == lpszMessage) 
        goto Cleanup;

    if (_sntprintf(lpszMessage, dwLength, m_MsgStrings[dwIndex+1], lpszOther ) < 0) {
        hr   = E_UNEXPECTED;
        goto Cleanup;
    }

    // Now display the MessageBox

    iMBRes = MessageBox( NULL,
                         lpszMessage,
                         m_MsgStrings[dwIndex],
                         MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 );

    switch(iMBRes) {
    case IDYES: hr = S_OK;          break;
    case IDNO:  hr = S_FALSE;       break;
    default:    hr = E_UNEXPECTED;  break;
    }

Cleanup:
    if (NULL != lpszMessage) 
        LocalFree( lpszMessage );

    return hr;
}

/***********************************************************************************
** End of File (prnsec.cpp)
**********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\prnsec.h ===
/*****************************************************************************\
* MODULE:       prnsec.h
*
* PURPOSE:      Declaration of the security class that determines the required
*               security settings for a com class. Interacts with the security
*               manager to determine the zone that we are running under.
*
* Copyright (C) 1999 Microsoft Corporation
*
* History:
*
*     09/2/99  mlawrenc    Declaration of security templates
*
\*****************************************************************************/

#ifndef __PRNSEC_H_
#define __PRNSEC_H_

#include "stdafx.h"
#include "urlmon.h"

class ATL_NO_VTABLE COlePrnSecurity {
/*++

Class Description
        This is the class that we we use for a mix in in all the printer classes that require
        zone based security. It also automatically loads any string resources it needs.
    
--*/
public:
    // Enumeration, Security Messages, these messages must correspond to the resource order
    // given from START_SECURITY_DIALOGUE_RES

    enum SecurityMessage {
        StartMessages = 0,
        AddWebPrinterConnection = 0,
        AddPrinterConnection,
        DeletePrinterConnection,
        EndMessages
    };

    static BOOL    InitStrings(void);
    static void    DeallocStrings(void);       
    static HRESULT PromptUser( SecurityMessage, LPTSTR ); 

    inline BOOL DisplayUIonDisallow(BOOL);   // Set to FALSE if we don't want IE to pop
                                             // up UI on disallow or Query
    virtual ~COlePrnSecurity();
protected:	
    // Protected Methods
    COlePrnSecurity(IUnknown *&iSite, DWORD &dwSafety); 

    HRESULT GetActionPolicy(DWORD dwAction, DWORD &dwPolicy);  
                                             // Find out if the action is allowed
private:
    // Private Methods
    HRESULT SetSecurityManager(void);
    static  LPTSTR LoadResString(UINT uResId);
    static const DWORD  dwMaxResBuf;     

    // Private Data Members
    IUnknown*                    &m_iSite;               // The site under which we are located
    DWORD                        &m_dwSafetyFlags;       // The safety set for the site 
    BOOL                         m_bDisplayUIonDisallow; // Should we ask for UI when Policy is Disallow? Default TRUE
    IInternetHostSecurityManager *m_iSecurity;           // Use this to get the security information of
                                                         // the site we are running under
    static LPTSTR                m_MsgStrings[EndMessages*2];
};

template<class T>
class ATL_NO_VTABLE COlePrnSecComControl : public CComControl<T>,
                                           public IObjectSafetyImpl<T>,
                                           public COlePrnSecurity {
/*++

Class Description
        A class which wishes to use the security control just needs to derive from this.
        Used to to illiminate having to templatise COlePrnSecurity
    
--*/
public:
    COlePrnSecComControl() : COlePrnSecurity(*(IUnknown **)&m_spClientSite, m_dwSafety) {}
};

template<class T>
class ATL_NO_VTABLE COlePrnSecObject : public IObjectWithSiteImpl<T>,
                                       public IObjectSafetyImpl<T>,
                                       public COlePrnSecurity 
/*++

Class Description
        A class which wishes to use the security control just needs to derive from this.
        This is for classes that are not OleObjects (i.e. do not have IOleObjectImpl<T> in 
        their inheritance. IE can use the lighter weight IObjectWithSite interface for
        these objects
        
--*/
    {
public:
    COlePrnSecObject() : COlePrnSecurity(*(IUnknown **)&m_spUnkSite, m_dwSafety) {}
};


////////////////////////////////////////////////////////////////////////////////
// INLINE METHODS
////////////////////////////////////////////////////////////////////////////////
inline BOOL COlePrnSecurity::DisplayUIonDisallow(BOOL bNewSetting) {
    BOOL bOldSetting = m_bDisplayUIonDisallow;
    m_bDisplayUIonDisallow = bNewSetting;
    return bOldSetting;
}

#endif  // __PRNSEC_H_

/*******************************************************************************
** End of File (prnsec.h)
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\sitem.h ===
#ifndef _SITEM_H
#define _SITEM_H

//////////////////////////////////////////////////////////////////////
//
// sitem.h: template for the SingleList Item class.
//
//////////////////////////////////////////////////////////////////////


template <class T> class CSingleItem
{
public:
    CSingleItem (void);
    CSingleItem (T);
    CSingleItem (T, CSingleItem<T> *);
    ~CSingleItem (void);
    void SetNext (CSingleItem<T> *);
    CSingleItem<T> * GetNext ();
    BOOL IsSame (T&);
    T GetData (void);

private:
    T m_Data;
    CSingleItem<T> *m_Next;
};



//////////////////////////////////////////////////////////////////////
// Template for CSIngleItem
//////////////////////////////////////////////////////////////////////

template <class T>
CSingleItem<T>::CSingleItem(void)
               : m_Data(NULL), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item)
               : m_Data(item), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item, CSingleItem<T>* next)
               : m_Data(item), m_Next(next)
{
}

template <class T>
CSingleItem<T>::~CSingleItem(void)
{
    if (m_Data) {
        delete (m_Data);
    }
}

template <class T>
void CSingleItem<T>::SetNext (CSingleItem<T> *item)
{
    m_Next = item;
}

template <class T>
CSingleItem<T> * CSingleItem<T>::GetNext (void )
{
    return m_Next;
}

template <class T>
T CSingleItem<T>::GetData (void )
{
    return m_Data;
}


template <class T>
BOOL CSingleItem<T>::IsSame (T &item)
{
    return m_Data->Compare (item) == 0;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\perflib\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for router.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/


#ifndef MODULE
#define MODULE "SPLPERF:"
#define MODULE_DEBUG SplPerfDebug
#define LINK_SPLPERF
#endif
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

//#include <excpt.h>
//#include <rpc.h>    // DataTypes and runtime APIs
//#include <string.h>

#include <windows.h>
//#include <winspool.h>
//#include <winsplp.h>
//#include <winspl.h> // generated by the MIDL complier
//#include <wininet.h>
#include <splcom.h>
//#include <change.h>
//#include <dbt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\stdafx.h ===
#if !defined(AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED_)
#define AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#define STRICT

#define DWERROR           ((DWORD) -1)

#ifndef WIN9X

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#endif

#include <windows.h>
#include <winspool.h>
#include <shellapi.h>
#include <shlobj.h>
#include <wininet.h>
#include <spllib.hxx>

#include <oaidl.h>
#include <winsnmp.h>
#include <snmp.h>
#include <mgmtapi.h>

#include "resource.h"
#include "util.h"

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <clusapi.h>

#include "prnsec.h"     // Printer Ole Security Defined Here
#include "gensph.h"     // Smart Pointers and Handles

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\util.h ===
/*****************************************************************************\
* MODULE:       util.h
*
* PURPOSE:      Header file for util.cpp
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*     11/06/97  keithst    Added SetScriptingError, removed Win2ComErr
*
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

LPWSTR  MakeWide(LPSTR psz);
LPSTR   MakeNarrow(LPWSTR str);
HRESULT PutString(SAFEARRAY *psa, long *ix, char *sz);
HRESULT SetScriptingError(const CLSID& rclsid, const IID& riid, DWORD dwError);

DWORD MyDeviceCapabilities(
    LPCTSTR pDevice,    // pointer to a printer-name string
    LPCTSTR pPort,      // pointer to a port-name string
    WORD fwCapability,  // device capability to query
    LPTSTR pOutput,     // pointer to the output
    CONST DEVMODE *pDevMode
                      // pointer to structure with device data
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\perflib\wmi.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All rights reserved

Module Name:

    wmi.h

Abstract:

    Holds defs for wmi instrumentation

Author:

    Stuart de Jong (sdejong) 15-Oct-99

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef __WMI_H
#define __WMI_H

ULONG WmiInitializeTrace();
ULONG WmiTerminateTrace();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\oleprn\util.cpp ===
/*****************************************************************************\
* MODULE:       util.cpp
*
* PURPOSE:      Tools for OlePrn project
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Added more functions
*     10/28/97  keithst    Added SetScriptingError
*     11/06/97  keithst    Removed Win2ComErr
*
\*****************************************************************************/
#include "stdafx.h"

//---------------------------------------------
//    Put an ANSI string into a SAFEARRAY
//
//
//  Convert the string into UNICODE
//  Make a BSTR out of it
//  Add it to the array
//
HRESULT PutString(SAFEARRAY *psa, long *ix, LPSTR sz)
{
    LPWSTR  lpWstr;
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    var.vt = VT_BSTR;

    if (sz == NULL)
        lpWstr = MakeWide("");
    else
        lpWstr = MakeWide(sz);

    if (lpWstr == NULL) return E_OUTOFMEMORY;

    var.bstrVal = SysAllocString(lpWstr);
    LocalFree(lpWstr);

    if (var.bstrVal == NULL)
        return E_OUTOFMEMORY;

    hr = SafeArrayPutElement(psa, ix, &var);
    VariantClear(&var);
    return hr;
}

// ---------------------------------------------
//  Convert an ANSI string to UNICODE
//
// Note - you must LocalFree the returned string
//

LPWSTR  MakeWide(LPSTR psz)
{
    LPWSTR buff;
    int i;
    i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    buff = (LPWSTR)LocalAlloc(LPTR, i * 2);
    if (buff == NULL)
        return NULL;
    i = MultiByteToWideChar(CP_ACP, 0, psz, -1, buff, i);
    return buff;
}

//-------------------------------------------------
//  Convert a UNICODE string to ANSI
//
// Note - you must LocalFree the returned string
//
LPSTR MakeNarrow(LPWSTR str)
{
    LPSTR  buff;
    int i;

    i = WideCharToMultiByte(CP_ACP, 0, str, -1, NULL, 0, NULL, NULL);
    buff = (LPSTR )LocalAlloc(LPTR, i);
    if (buff == NULL)
        return NULL;
    i = WideCharToMultiByte(CP_ACP, 0, str, -1, buff, i, NULL, NULL);
    return buff;
}

//-------------------------------------------------
// SetScriptingError
//   Takes a Win32 error code and sets the associated string as
//   the scripting language error description
//
// Parameters:
//   CLSID *pclsid: pointer to Class ID (CLSID) for the class which
//                  generated the error; passed to AtlReportError
//
//   IID *piid:     pointer to interface ID (IID) for the interface
//                  which generated the error; passed to AtlReportError
//
//   DWORD dwError: the error code retrieved from GetLastError by
//                  the caller of this function
//
// Return Value:
//   This function uses the HRESULT_FROM_WIN32 macro, which translates
//   the Win32 dwError code to a COM error code.  This COM error code
//   should be returned out as the return value of the failed method.
//
HRESULT SetScriptingError(const CLSID& rclsid, const IID& riid, DWORD dwError)
{
    LPTSTR  lpMsgBuf = NULL;
    DWORD   dwRet = 0;

    dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          dwError,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL);

    if (dwRet == 0 || !lpMsgBuf)
    {
        //
        // If FormatMessage fails, it returns 0, but since we can not call
        // GetLastError again, we return OUTOFMEMORY instead.
        //
        return E_OUTOFMEMORY;
    }

    AtlReportError(rclsid, lpMsgBuf, riid, HRESULT_FROM_WIN32(dwError));

    LocalFree(lpMsgBuf);

    return (HRESULT_FROM_WIN32(dwError));
}


HANDLE
RevertToPrinterSelf(
    VOID)
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_IMPERSONATE,
                 TRUE,
                 &OldToken
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    return OldToken;

}

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&hToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    NtClose(hToken);

    return TRUE;
}

DWORD MyDeviceCapabilities(
    LPCTSTR pDevice,    // pointer to a printer-name string
    LPCTSTR pPort,      // pointer to a port-name string
    WORD fwCapability,  // device capability to query
    LPTSTR pOutput,     // pointer to the output
    CONST DEVMODE *pDevMode
                      // pointer to structure with device data
    )
{
    DWORD dwRet = DWERROR;
    HANDLE hToken = NULL;

    dwRet = DeviceCapabilities(pDevice, pPort, fwCapability, pOutput, pDevMode);

    if (dwRet == DWERROR && GetLastError () == ERROR_ACCESS_DENIED) {
        // In a cluster machine, we need to get the local admin previlige to get
        // the device capabilities.

        if (hToken = RevertToPrinterSelf()) {
            dwRet = DeviceCapabilities(pDevice, pPort, fwCapability, pOutput, pDevMode);
            ImpersonatePrinterClient(hToken);
        }
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\emf.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\emf.c
// @@END_DDKSPLIT

Abstract:

    Routines to facilitate printing of EMF jobs.
    
// @@BEGIN_DDKSPLIT
Author:

    Gerrit van Wingerden (gerritv) 5-12-1995

Revision History:

    Ramanathan N. Venkatapathy (ramanv) 5-15-1997
    Alvin Scholten (alvins) 3-31-00
// @@END_DDKSPLIT
--*/

#include "local.h"
#include "stddef.h"
#include <windef.h>

// @@BEGIN_DDKSPLIT
#include "wingdip.h"
/*
// @@END_DDKSPLIT
#include <winppi.h>
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT


#define EMF_DUP_NONE 0
#define EMF_DUP_VERT 1
#define EMF_DUP_HORZ 2

#define EMF_DEGREE_90   0x0001
#define EMF_DEGREE_270  0x0002
#define EMF_DEGREE_SWAP 0x8000

//   PAGE_NUMBER is used to save a list of the page numbers to start new sides while
//   Reverse Printing.

typedef struct _PAGE_NUMBER {
    struct _PAGE_NUMBER *pNext;
    DWORD  dwPageNumber;
} PAGE_NUMBER, *PPAGE_NUMBER;

typedef struct _UpdateRect {
        double  top;
        double  bottom;
        double  left;
        double  right;
}  UpdateRect;

// The update factors for the different nup options. These factors when multiplied
// with the horizontal and vertical resolutions give the coordinates for the rectangle
// where the EMF page is to be played.

UpdateRect URect21[] = {{0, 0.5, 0, 1},
                        {0.5, 1, 0, 1}};

UpdateRect URect21R[] = {{0.5, 1, 0, 1},
                         {0, 0.5, 0, 1}};

UpdateRect URect22[] = {{0, 1, 0, 0.5},
                        {0, 1, 0.5, 1}};

UpdateRect URect4[] = {{0, 0.5, 0, 0.5},
                       {0, 0.5, 0.5, 1},
                       {0.5, 1, 0, 0.5},
                       {0.5, 1, 0.5, 1}};

UpdateRect URect61[] = {{0, 1.0/3.0, 0, 0.5},
                        {0, 1.0/3.0, 0.5, 1},
                        {1.0/3.0, 2.0/3.0, 0, 0.5},
                        {1.0/3.0, 2.0/3.0, 0.5, 1},
                        {2.0/3.0, 1, 0, 0.5},
                        {2.0/3.0, 1, 0.5, 1}};

UpdateRect URect61R[] = {{2.0/3.0, 1, 0, 0.5},
                         {1.0/3.0, 2.0/3.0, 0, 0.5},
                         {0, 1.0/3.0, 0, 0.5},
                         {2.0/3.0, 1, 0.5, 1},
                         {1.0/3.0, 2.0/3.0, 0.5, 1},
                         {0, 1.0/3.0, 0.5, 1}};

UpdateRect URect62[]  = {{0, 0.5, 0, 1.0/3.0},
                         {0, 0.5, 1.0/3.0, 2.0/3.0},
                         {0, 0.5, 2.0/3.0, 1},
                         {0.5, 1, 0, 1.0/3.0},
                         {0.5, 1, 1.0/3.0, 2.0/3.0},
                         {0.5, 1, 2.0/3.0, 1}};

UpdateRect URect62R[] = {{0.5, 1, 0, 1.0/3.0},
                         {0, 0.5, 0, 1.0/3.0},
                         {0.5, 1, 1.0/3.0, 2.0/3.0},
                         {0, 0.5, 1.0/3.0, 2.0/3.0},
                         {0.5, 1, 2.0/3.0, 1},
                         {0, 0.5, 2.0/3.0, 1}};

UpdateRect URect9[] = {{0, 1.0/3.0, 0, 1.0/3.0},
                       {0, 1.0/3.0, 1.0/3.0, 2.0/3.0},
                       {0, 1.0/3.0, 2.0/3.0, 1},
                       {1.0/3.0, 2.0/3.0, 0, 1.0/3.0},
                       {1.0/3.0, 2.0/3.0, 1.0/3.0, 2.0/3.0},
                       {1.0/3.0, 2.0/3.0, 2.0/3.0, 1},
                       {2.0/3.0, 1, 0, 1.0/3.0},
                       {2.0/3.0, 1, 1.0/3.0, 2.0/3.0},
                       {2.0/3.0, 1, 2.0/3.0, 1}};

UpdateRect URect16[] = {{0, 0.25, 0, 0.25},
                        {0, 0.25, 0.25, 0.5},
                        {0, 0.25, 0.5, 0.75},
                        {0, 0.25, 0.75, 1},
                        {0.25, 0.5, 0, 0.25},
                        {0.25, 0.5, 0.25, 0.5},
                        {0.25, 0.5, 0.5, 0.75},
                        {0.25, 0.5, 0.75, 1},
                        {0.5, 0.75, 0, 0.25},
                        {0.5, 0.75, 0.25, 0.5},
                        {0.5, 0.75, 0.5, 0.75},
                        {0.5, 0.75, 0.75, 1},
                        {0.75, 1, 0, 0.25},
                        {0.75, 1, 0.25, 0.5},
                        {0.75, 1, 0.5, 0.75},
                        {0.75, 1, 0.75, 1}};

BOOL
ValidNumberForNUp(
    DWORD  dwPages)

/*++
Function Description: Checks if the number of pages printed on a single side is Valid.

Parameters: dwPages - Number of pages printed on a single side

Return Values: TRUE if (dwPages = 1|2|4|6|9|16)
               FALSE otherwise.
--*/

{

    return ((dwPages == 1) || (dwPages == 2) || (dwPages == 4) ||
            (dwPages == 6) || (dwPages == 9) || (dwPages == 16));
}

VOID
GetPageCoordinatesForNUp(
    HDC    hPrinterDC,
    RECT   *rectDocument,
    RECT   *rectBorder,
    DWORD  dwTotalNumberOfPages,
    UINT   uCurrentPageNumber,
    DWORD  dwNupBorderFlags,
    LPBOOL pbRotate
    )

/*++
Function Description: GetPageCoordinatesForNUp computes the rectangle on the Page where the
                      EMF file is to be played. It also determines if the picture is to
                      rotated.

Parameters:  hPrinterDC           - Printer Device Context
             *rectDocument        - pointer to RECT where the coordinates to play the
                                     page will be returned.
             *rectBorder          - pointer to RECT where the page borders are to drawn.
             dwTotalNumberOfPages - Total number of pages on 1 side.
             uCurrentPageNumber   - 1 based page number on the side.
             dwNupBorderFlags     - flags to draw border along logical pages.
             pbRotate             - pointer to BOOL which indicates if the picture must be
                                    rotated.

Return Values:  NONE.
--*/

{

    UpdateRect  *URect;
    LONG        lXPrintPage,lYPrintPage,lXPhyPage,lYPhyPage,lXFrame,lYFrame,ltemp,ldX,ldY;
    LONG        lXNewPhyPage,lYNewPhyPage,lXOffset,lYOffset,lNumRowCol,lRowIndex,lColIndex;
    double      dXleft,dXright,dYtop,dYbottom;
    LONG        xResolution = GetDeviceCaps(hPrinterDC, LOGPIXELSX);
    LONG        yResolution = GetDeviceCaps(hPrinterDC, LOGPIXELSY);
    
    // Get the 0-based array index for the current page

    uCurrentPageNumber = uCurrentPageNumber - 1;

    if (dwTotalNumberOfPages==1 || xResolution==yResolution) 
    {
        xResolution = yResolution = 1;
    }

    rectDocument->top = rectDocument->bottom = lYPrintPage = (GetDeviceCaps(hPrinterDC, DESKTOPVERTRES)-1) * xResolution;
    rectDocument->left = rectDocument->right = lXPrintPage = (GetDeviceCaps(hPrinterDC, DESKTOPHORZRES)-1) * yResolution;

    lXPhyPage = GetDeviceCaps(hPrinterDC, PHYSICALWIDTH)  * yResolution;
    lYPhyPage = GetDeviceCaps(hPrinterDC, PHYSICALHEIGHT) * xResolution;

    *pbRotate = FALSE;

    // Select the array containing the update factors

    switch (dwTotalNumberOfPages) {

    case 1: rectDocument->top = rectDocument->left = 0;
            rectDocument->right += 1;
            rectDocument->bottom += 1;
            return;

    case 2: if (lXPrintPage > lYPrintPage) {  // cut vertically
                URect = URect22;
                lXFrame = (LONG) (lXPrintPage / 2.0);
                lYFrame = lYPrintPage;
            } else {                          // cut horizontally
                URect = URect21;
                lYFrame = (LONG) (lYPrintPage / 2.0);
                lXFrame = lXPrintPage;
            }
            break;


    case 4: URect = URect4;
            lXFrame = (LONG) (lXPrintPage / 2.0);
            lYFrame = (LONG) (lYPrintPage / 2.0);
            break;

    case 6: if (lXPrintPage > lYPrintPage) {  // cut vertically twice
                URect = URect62;
                lXFrame = (LONG) (lXPrintPage / 3.0);
                lYFrame = (LONG) (lYPrintPage / 2.0);
            } else {                          // cut horizontally twice
                URect = URect61;
                lYFrame = (LONG) (lYPrintPage / 3.0);
                lXFrame = (LONG) (lXPrintPage / 2.0);
            }
            break;

    case 9: URect = URect9;
            lXFrame = (LONG) (lXPrintPage / 3.0);
            lYFrame = (LONG) (lYPrintPage / 3.0);
            break;

    case 16: URect = URect16;
             lXFrame = (LONG) (lXPrintPage / 4.0);
             lYFrame = (LONG) (lYPrintPage / 4.0);
             break;

    default: // Should Not Occur.
             return;
    }

    // Set the flag if the picture has to be rotated
    *pbRotate = !((lXPhyPage >= lYPhyPage) && (lXFrame >= lYFrame)) &&
                !((lXPhyPage < lYPhyPage) && (lXFrame < lYFrame));
    

    // If the picture is to be rotated, modify the rectangle selected.

    if ((dwTotalNumberOfPages == 2) || (dwTotalNumberOfPages == 6)) {

       if (*pbRotate) {
          switch (dwTotalNumberOfPages) {

          case 2: if (lXPrintPage <= lYPrintPage) {
                      URect = URect21R;
                  } // URect22 = URect22R
                  break;

          case 6: if (lXPrintPage <= lYPrintPage) {
                      URect = URect61R;
                  } else {
                      URect = URect62R;
                  }
                  break;
          }
       }

    } else {

       if (*pbRotate) {

          // get the number of rows/columns. switch is faster than sqrt.
          switch (dwTotalNumberOfPages) {

          case 4: lNumRowCol = 2;
                  break;
          case 9: lNumRowCol = 3;
                  break;
          case 16: lNumRowCol = 4;
                  break;
          }

          lRowIndex  = (LONG) (uCurrentPageNumber / lNumRowCol);
          lColIndex  = (LONG) (uCurrentPageNumber % lNumRowCol);

          uCurrentPageNumber = (lNumRowCol - 1 - lColIndex) * lNumRowCol + lRowIndex;
       }

    }

    // Update the Page Coordinates.

    rectDocument->top    = (LONG) (rectDocument->top    * URect[uCurrentPageNumber].top);
    rectDocument->bottom = (LONG) (rectDocument->bottom * URect[uCurrentPageNumber].bottom);
    rectDocument->left   = (LONG) (rectDocument->left   * URect[uCurrentPageNumber].left);
    rectDocument->right  = (LONG) (rectDocument->right  * URect[uCurrentPageNumber].right);

    // If the page border has to drawn, return the corresponding coordinates in rectBorder.

    if (dwNupBorderFlags == BORDER_PRINT) {
        rectBorder->top    = rectDocument->top/xResolution;
        rectBorder->bottom = rectDocument->bottom/xResolution - 1;
        rectBorder->left   = rectDocument->left/yResolution;
        rectBorder->right  = rectDocument->right/yResolution - 1;
    }

    if (*pbRotate) {
        ltemp = lXFrame; lXFrame = lYFrame; lYFrame = ltemp;
    }

    // Get the new size of the rectangle to keep the X/Y ratio constant.
    if ( ((LONG) (lYFrame*((lXPhyPage*1.0)/lYPhyPage))) >= lXFrame) {
         ldX = 0;
         ldY = lYFrame - ((LONG) (lXFrame*((lYPhyPage*1.0)/lXPhyPage)));
    } else {
         ldY = 0;
         ldX = lXFrame - ((LONG) (lYFrame*((lXPhyPage*1.0)/lYPhyPage)));
    }

    // Adjust the position of the rectangle.

    if (*pbRotate) {
        if (ldX) {
            rectDocument->bottom -= (LONG) (ldX / 2.0);
            rectDocument->top    += (LONG) (ldX / 2.0);
        } else {
           rectDocument->right   -= (LONG) (ldY / 2.0);
           rectDocument->left    += (LONG) (ldY / 2.0);
        }
    } else {
        if (ldX) {
           rectDocument->left    += (LONG) (ldX / 2.0);
           rectDocument->right   -= (LONG) (ldX / 2.0);
        } else {
           rectDocument->top     += (LONG) (ldY / 2.0);
           rectDocument->bottom  -= (LONG) (ldY / 2.0);
        }
    }

    // Adjust to get the Printable Area on the rectangle

    lXOffset = GetDeviceCaps(hPrinterDC, PHYSICALOFFSETX) * yResolution;
    lYOffset = GetDeviceCaps(hPrinterDC, PHYSICALOFFSETY) * xResolution;

    dXleft = ( lXOffset * 1.0) / lXPhyPage;
    dYtop  = ( lYOffset * 1.0) / lYPhyPage;
    dXright =  ((lXPhyPage - (lXOffset + lXPrintPage)) * 1.0) / lXPhyPage;
    dYbottom = ((lYPhyPage - (lYOffset + lYPrintPage)) * 1.0) / lYPhyPage;

    lXNewPhyPage = rectDocument->right  - rectDocument->left;
    lYNewPhyPage = rectDocument->bottom - rectDocument->top;

    if (*pbRotate) {

       ltemp = lXNewPhyPage; lXNewPhyPage = lYNewPhyPage; lYNewPhyPage = ltemp;

       rectDocument->left   += (LONG) (dYtop    * lYNewPhyPage);
       rectDocument->right  -= (LONG) (dYbottom * lYNewPhyPage);
       rectDocument->top    += (LONG) (dXright  * lXNewPhyPage);
       rectDocument->bottom -= (LONG) (dXleft   * lXNewPhyPage);

    } else {

       rectDocument->left   += (LONG) (dXleft   * lXNewPhyPage);
       rectDocument->right  -= (LONG) (dXright  * lXNewPhyPage);
       rectDocument->top    += (LONG) (dYtop    * lYNewPhyPage);
       rectDocument->bottom -= (LONG) (dYbottom * lYNewPhyPage);
    }

    if (xResolution!=yResolution) 
    {
        rectDocument->left   = rectDocument->left   / yResolution;
        rectDocument->right  = rectDocument->right  / yResolution; 
        rectDocument->top    = rectDocument->top    / xResolution;
        rectDocument->bottom = rectDocument->bottom / xResolution; 
    }
    return;
}

BOOL
PlayEMFPage(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    HANDLE       hEMF,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwPageNumber,
    DWORD        dwPageIndex,
    DWORD        dwNupBorderFlags,
    DWORD        dwAngle)
    
/*++
Function Description: PlayEMFPage plays the EMF in the appropriate rectangle. It performs
                      the required scaling, rotation and translation.

Parameters:   hSpoolHandle           -- handle the spool file handle
              hPrinterDC             -- handle to the printer device context
              hEMF                   -- handle to the contents of the page in the spool file
              dwNumberOfPagesPerSide -- number of pages to be printed per side
              dwPageNumber           -- page number in the document
              dwPageIndex            -- page number in the side. (1 based)
              dwNupBorderFlags       -- border printing options for nup
              dwAngle                -- angle for rotation (if neccesary)

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
   BOOL         bReturn = FALSE, bRotate;
   RECT         rectDocument, rectPrinter, rectBorder = {-1, -1, -1, -1};
   RECT         *prectClip = NULL;
   XFORM        TransXForm = {1, 0, 0, 1, 0, 0}, RotateXForm = {0, -1, 1, 0, 0, 0};
   HPEN         hPen;
   HANDLE       hFormEMF;
   DWORD        dwPageType,dwFormPage;

   // Compute the rectangle for one page.
   GetPageCoordinatesForNUp(hPrinterDC,
                            &rectDocument,
                            &rectBorder,
                            dwNumberOfPagesPerSide,
                            dwPageIndex,
                            dwNupBorderFlags,
                            &bRotate);

   // If swap flag is set, reverse rotate flag
   //
   if (dwAngle & EMF_DEGREE_SWAP)
       bRotate = !bRotate;

   if (dwAngle & EMF_DEGREE_270) {
       RotateXForm.eM12 = 1;
       RotateXForm.eM21 = -1;
   }   // EMF_DEGREE_90 case is the initialization

   if (bRotate) {

       rectPrinter.top = 0;
       rectPrinter.bottom = rectDocument.right - rectDocument.left;
       rectPrinter.left = 0;
       rectPrinter.right = rectDocument.bottom - rectDocument.top;

       // Set the translation matrix
       if (dwAngle & EMF_DEGREE_270) {
           TransXForm.eDx = (float) rectDocument.right;
           TransXForm.eDy = (float) rectDocument.top;
       } else {
           // EMF_DEGREE_90
           TransXForm.eDx = (float) rectDocument.left;
           TransXForm.eDy = (float) rectDocument.bottom;
       }

       // Set the transformation matrix
       if (!SetWorldTransform(hPrinterDC, &RotateXForm) ||
           !ModifyWorldTransform(hPrinterDC, &TransXForm, MWT_RIGHTMULTIPLY)) {

            ODS(("Setting transformation matrix failed\n"));
            goto CleanUp;
       }
   }

   // Add clipping for Nup
   if (dwNumberOfPagesPerSide != 1) {

       prectClip = &rectDocument;
   }

   // Print the page.
   if (bRotate) {
       GdiPlayPageEMF(hSpoolHandle, hEMF, &rectPrinter, &rectBorder, prectClip);

   } else {
       GdiPlayPageEMF(hSpoolHandle, hEMF, &rectDocument, &rectBorder, prectClip);
   }

   bReturn = TRUE;

CleanUp:
   
   if (!ModifyWorldTransform(hPrinterDC, NULL, MWT_IDENTITY)) {

       ODS(("Setting Identity Transformation failed\n"));
       bReturn = FALSE;
   }

   return bReturn;
}

BOOL
SetDrvCopies(
    HDC          hPrinterDC,
    LPDEVMODEW   pDevmode,
    DWORD        dwNumberOfCopies)

/*++
Function Description: SetDrvCopies sets the dmCopies field in pDevmode and resets
                      hPrinterDC with this devmode

Parameters: hPrinterDC             -- handle to the printer device context
            pDevmode               -- pointer to devmode
            dwNumberOfCopies       -- value for dmCopies

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL     bReturn;
    DWORD    dmFields;

    if ((pDevmode->dmFields & DM_COPIES) &&
        (pDevmode->dmCopies == (short) dwNumberOfCopies)) {

         return TRUE;
    }

    // Save the old fields structure
    dmFields = pDevmode->dmFields;
    pDevmode->dmFields |= DM_COPIES;
    pDevmode->dmCopies = (short) dwNumberOfCopies;

    if (!ResetDC(hPrinterDC, pDevmode))  {
        bReturn = FALSE;
    } else {
        bReturn = TRUE;
    }
    // Restore the fields structure
    pDevmode->dmFields = dmFields;

    if (!SetGraphicsMode(hPrinterDC,GM_ADVANCED)) {
        ODS(("Setting graphics mode failed\n"));
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
DifferentDevmodes(
    LPDEVMODE    pDevmode1,
    LPDEVMODE    pDevmode2
    )

/*++
Function Description: Compares the devmodes for differences other than dmTTOption

Parameters:  pDevmode1    -   devmode 1
             pDevmode2    -   devmode 2
             
Return Values: TRUE if different ; FALSE otherwise           
--*/

{
    DWORD   dwSize1, dwSize2, dwTTOffset, dwSpecOffset, dwLogOffset;

    // Same pointers are the same devmode
    if (pDevmode1 == pDevmode2) {
        return FALSE;
    }

    // Check for Null devmodes
    if (!pDevmode1 || !pDevmode2) {
        return TRUE;
    }

    dwSize1 = pDevmode1->dmSize + pDevmode1->dmDriverExtra;
    dwSize2 = pDevmode2->dmSize + pDevmode2->dmDriverExtra;

    // Compare devmode sizes
    if (dwSize1 != dwSize2) {
        return TRUE;
    }

    dwTTOffset = FIELD_OFFSET(DEVMODE, dmTTOption);
    dwSpecOffset = FIELD_OFFSET(DEVMODE, dmSpecVersion);
    dwLogOffset = FIELD_OFFSET(DEVMODE, dmLogPixels);

    if (wcscmp(pDevmode1->dmDeviceName,
               pDevmode2->dmDeviceName)) {
        // device names are different
        return TRUE;
    }

    if (dwTTOffset < dwSpecOffset ||
        dwSize1 < dwLogOffset) {

        // incorrent devmode offsets
        return TRUE;
    }

    if (memcmp((LPBYTE) pDevmode1 + dwSpecOffset,
               (LPBYTE) pDevmode2 + dwSpecOffset,
               dwTTOffset - dwSpecOffset)) {
        // Front half is different
        return TRUE;
    }

    // Ignore the dmTTOption setting.

    if ((pDevmode1->dmCollate != pDevmode2->dmCollate) ||
        wcscmp(pDevmode1->dmFormName, pDevmode2->dmFormName)) {
        
        // form name or collate option is different
        return TRUE;
    }

    if (memcmp((LPBYTE) pDevmode1 + dwLogOffset,
               (LPBYTE) pDevmode2 + dwLogOffset,
               dwSize1 - dwLogOffset)) {
        // Back half is different
        return TRUE;
    }

    return FALSE;
}


BOOL
ResetDCForNewDevmode(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwPageNumber,
    BOOL         bInsidePage,    
    DWORD        dwOptimization,
    LPBOOL       pbNewDevmode,
    LPDEVMODE    pDevmode,
    LPDEVMODE    *pCurrentDevmode
    )

/*++
Function Description: Determines if the devmode for the page is different from the 
                      current devmode for the printer dc and resets the dc if necessary.
                      The parameters allow dmTTOption to be ignored in devmode comparison.

Parameters: hSpoolHandle         -  spool file handle
            hPrinterDC           -  printer dc
            dwPageNumber         -  page number before which we search for the devmode
            bInsidePage          -  flag to ignore changes in TT options and call EndPage
                                       before ResetDC
            dwOptimization       -  optimization flags
            pbNewDevmode         -  pointer to flag to indicate if ResetDC was called
            pDevmode             -  devmode containing changed resolution settings

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL           bReturn = FALSE;
    LPDEVMODE      pLastDM, pCurrDM;

    // Initialize OUT parameters
    *pbNewDevmode = FALSE;

    // Get the devmode just before the page
    if (!GdiGetDevmodeForPage(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              &pLastDM)) {

        ODS(("GdiGetDevmodeForPage failed\n"));
        return bReturn;
    }
    
    // Save pointer to current devmode
    if (pCurrentDevmode) 
        *pCurrentDevmode = pCurrDM;
        
    // Check if the devmodes are different
    if (pLastDM != pCurrDM) {

        // If the pointers are different the devmodes are always different
        if (!bInsidePage ||
            DifferentDevmodes(pLastDM, pCurrDM)) {

            *pbNewDevmode = TRUE;
        }
    }

    // Call ResetDC on the hPrinterDC if necessary
    if (*pbNewDevmode) {

        if (bInsidePage &&
            !GdiEndPageEMF(hSpoolHandle, dwOptimization)) {

            ODS(("EndPage failed\n"));
            return bReturn;
        }

        if (pCurrDM) {
            pCurrDM->dmPrintQuality = pDevmode->dmPrintQuality;
            pCurrDM->dmYResolution = pDevmode->dmYResolution;
            pCurrDM->dmCopies = pDevmode->dmCopies;
            pCurrDM->dmCollate = pDevmode->dmCollate;
        }

        // Ignore the return values of ResetDC and SetGraphicsMode
        GdiResetDCEMF(hSpoolHandle, pCurrDM);
        SetGraphicsMode(hPrinterDC, GM_ADVANCED);       
    }

    bReturn = TRUE;

    return bReturn;
}

DWORD
PrintOneSideForwardEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwPageNumber,
    DWORD        dwJobNumberOfCopies,
    LPBOOL       pbComplete,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideForwardEMF plays the next physical page in the same order
                      as the spool file.

Parameters: hSpoolHandle              -- handle the spool file handle
            hPrinterDC                -- handle to the printer device context
            dwNumberOfPagesPerSide    -- number of pages to be printed per side by the print processor
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNupBorderFlags          -- border printing options for nup
            bDuplex                   -- flag to indicate duplex printing
            dwOptimization            -- optimization flags
            dwPageNumber              -- pointer to the starting page number
            pbComplete                -- pointer to the flag to indicate completion
            pDevmode                  -- devmode with resolution settings
   
Return Values:  Last Page Number if successful
                0 on job completion (pbReturn set to TRUE) and
                  on failure (pbReturn remains FALSE)
--*/

{
    DWORD              dwPageIndex, dwPageType;
    DWORD              dwReturn = 0;
    LPDEVMODEW         pCurrDM;
    HANDLE             hEMF = NULL;
    DWORD              dwSides;
    BOOL               bNewDevmode;
    DWORD              cPagesToPlay;
    DWORD              dwAngle;
    INT                dmOrientation = pDevmode->dmOrientation;

    // set the number of sides on this page;
    dwSides = bDuplex ? 2 : 1;
    *pbComplete = FALSE;

    for ( ; dwSides && !*pbComplete ; --dwSides) {

       // loop for a single side
       for (dwPageIndex = 1;
            dwPageIndex <= dwNumberOfPagesPerSide;
            ++dwPageIndex, ++dwPageNumber) {

            if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                          dwPageNumber,
                                          &dwPageType))) {

                if (GetLastError() == ERROR_NO_MORE_ITEMS) {
                     // End of the print job
                     *pbComplete = TRUE;
                     break;
                }

                ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }
            dwAngle = EMF_DEGREE_90;
            if (dwPageIndex == 1)
            {
                // Process new devmodes in the spool file that appear before this page
                if (!ResetDCForNewDevmode(hSpoolHandle,
                                      hPrinterDC,
                                      dwPageNumber,
                                      (dwPageIndex != 1),
                                      dwOptimization,
                                      &bNewDevmode,
                                      pDevmode,
                                      &pCurrDM)) {

                    goto CleanUp;
                }
                if (pCurrDM)
                    dmOrientation = pCurrDM->dmOrientation;
            }
            // in case of orientation switch we need to keep track of what
            // we started with and what it is now
            else if (dwNumberOfPagesPerSide > 1)
            {
                if (GdiGetDevmodeForPage(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                    {
                        dwAngle = EMF_DEGREE_SWAP | EMF_DEGREE_90;
                    }
                }
            }
            // Call StartPage for each new page
            if ((dwPageIndex == 1) &&
                !GdiStartPageEMF(hSpoolHandle)) {

                ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }

            if (!PlayEMFPage(hSpoolHandle,
                             hPrinterDC,
                             hEMF,
                             dwNumberOfPagesPerSide,
                             dwPageNumber,
                             dwPageIndex,
                             dwNupBorderFlags,
                             dwAngle)) {

                ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }            
       }

       //
       // Explaination of the scinario set for the conditions on 
       // dwPageIndex1 , pbComplete and bDuplex.
       // N.B. we are naming them cond.1 and cond.2
       //     dwPageIndex!=1    pbComplete   bDuplex    Condition
       //           0               0           0       None    
       //           0               0           1       None
       //           0               1           0       None
       //           0               1           1       Cond2 on Second Side i.e. dwsides==1
       //           1               0           0       Cond1
       //           1               0           1       Cond1
       //           1               1           0       Cond1
       //           1               1           1       Cond1 & Cond2 on First Side i.e. dwsides==2
       //


       // cond.1
       if (dwPageIndex != 1) {

           // Call EndPage if we played any pages
           if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {

               ODS(("EndPage failed\n"));
               *pbComplete = FALSE;
               goto CleanUp;
           }
       }

       // cond.2
       // play empty page on the back of duplex
       if (*pbComplete && bDuplex && dwDrvNumberOfPagesPerSide==1) {

           ODS(("PCL or PS with no N-up\n"));

           //
           // Checking dwsides against 2 or 1. 
           // depends on whether it is n-up or not.
           //
           if (((dwPageIndex!=1)?(dwSides==2):(dwSides==1))) {
          
               if (!GdiStartPageEMF(hSpoolHandle) ||
                   !GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
 
                   ODS(("EndPage failed\n"));
                   *pbComplete = FALSE;
                   goto CleanUp;
               }
           }
        }
    }

    if (*pbComplete && 
        dwNumberOfPagesPerSide==1 && 
        dwDrvNumberOfPagesPerSide!=1 && 
        dwJobNumberOfCopies!=1)
    {
        cPagesToPlay = dwDrvNumberOfPagesPerSide * (bDuplex ? 2 : 1);
        if ((dwPageNumber-1) % cPagesToPlay)
        {
            //
            // Number of pages played on last physical page
            //
            cPagesToPlay = cPagesToPlay - ((dwPageNumber-1) % cPagesToPlay);

            ODS(("\nPS with N-up!\nMust fill in %u pages\n", cPagesToPlay));

            for (;cPagesToPlay;cPagesToPlay--) 
            {
                if (!GdiStartPageEMF(hSpoolHandle) || !GdiEndPageEMF(hSpoolHandle, dwOptimization)) 
                {
                    ODS(("EndPage failed\n"));
                    goto CleanUp;
                }
            }
        }
    }

    if (!(*pbComplete)) dwReturn = dwPageNumber;

CleanUp:

    return dwReturn;
}

BOOL
PrintForwardEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    LPDEVMODEW   pDevmode,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintForwardEMF plays the EMF files in the order in which they
                      were spooled.

Parameters: hSpoolHandle              -- handle the spool file handle
            hPrinterDC                -- handle to the printer device context
            dwNumberOfPagesPerSide    -- number of pages to be printed per side by the print processor
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNupBorderFlags          -- border printing options for nup
            dwJobNumberOfCopies       -- number of copies of the job to be printed
            dwDrvNumberOfCopies       -- number of copies that the driver can print
            bCollate                  -- flag for collating the copies
            bDuplex                   -- flag for duplex printing
            dwOptimization            -- optimization flags
            pDevmode                  -- pointer to devmode for changing the copy count
            pData                     -- needed for status and the handle of the event: pause, resume etc.

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD              dwLastPageNumber = 1,dwPageNumber,dwPageIndex,dwRemainingCopies;
    BOOL               bReturn = FALSE;

    // Keep printing as long as the spool file contains EMF handles.
    while (dwLastPageNumber) {

        //
        // If the print processor is paused, wait for it to be resumed 
        //
        if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
            WaitForSingleObject(pData->semPaused, INFINITE);
        }

        dwPageNumber = dwLastPageNumber;

        if (bCollate) {

           dwLastPageNumber = PrintOneSideForwardEMF(hSpoolHandle,
                                                     hPrinterDC,
                                                     dwNumberOfPagesPerSide,
                                                     dwDrvNumberOfPagesPerSide,
                                                     dwNupBorderFlags,
                                                     bDuplex,
                                                     dwOptimization,
                                                     dwPageNumber,
                                                     dwJobNumberOfCopies,
                                                     &bReturn,
                                                     pDevmode);
        } else {

           dwRemainingCopies = dwJobNumberOfCopies;

           while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }
               
               if (!(dwLastPageNumber =  PrintOneSideForwardEMF(hSpoolHandle,
                                                                hPrinterDC,
                                                                dwNumberOfPagesPerSide,
                                                                dwDrvNumberOfPagesPerSide,
                                                                dwNupBorderFlags,
                                                                bDuplex,
                                                                dwOptimization,
                                                                dwPageNumber,
                                                                dwJobNumberOfCopies,
                                                                &bReturn,
                                                                pDevmode)) &&
                   !bReturn) {

                    goto CleanUp;
               }
           }
        }
    }

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideReverseForDriverEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwPageNumber,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideReverseForDriverEMF plays the EMF pages on the next
                      physical page, in the reverse order for the driver which does the
                      Nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwTotalNumberOfPages   -- total number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            bDuplex                -- flag to indicate duplex printing
            dwOptimization         -- optimization flags
            dwPageNumber           -- page number to start the side
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
    DWORD       dwPageIndex, dwPageType, dwSides;
    BOOL        bReturn = FALSE, bNewDevmode,BeSmart;    
    LPDEVMODEW  pCurrDM;
    HANDLE      hEMF = NULL;
    DWORD       dwLimit;

    dwSides = bDuplex ? 2 : 1;

    //
    // If the document will fit on one phisical page, then this variable will prevent 
    // the printer from playing extra pages just to fill in one phisical page 
    // The exception is when the pages fit on a single phisical page, but they must
    // be collated. Then because of design, the printer will also draw borders for the
    // empty pages which are played so that the page gets ejected.
    //
    BeSmart =  (dwTotalNumberOfPages<=dwDrvNumberOfPagesPerSide) &&
               (pDevmode->dmCollate != DMCOLLATE_TRUE);
         
    for (; dwSides; --dwSides) {

       // This loop may play some empty pages in the last side, since the
       // driver is doing nup and it does not keep count of the page numbers
       //
       dwPageIndex=BeSmart?dwPageNumber:1;
       dwLimit    =BeSmart?dwTotalNumberOfPages:dwDrvNumberOfPagesPerSide;

       for (;dwPageIndex<=dwLimit; ++dwPageIndex,++dwPageNumber) {

             if (BeSmart || dwPageNumber <= dwTotalNumberOfPages) {

                 if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                               dwPageNumber,
                                               &dwPageType))) {
                     ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                 }

                 // Process new devmodes in the spoolfile
                 if (!ResetDCForNewDevmode(hSpoolHandle,
                                           hPrinterDC,
                                           dwPageNumber,
                                           FALSE,
                                           dwOptimization,
                                           &bNewDevmode,
                                           pDevmode,
                                           NULL)) {
                 }
             }

             if (!GdiStartPageEMF(hSpoolHandle)) {
                 ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                 goto CleanUp;
             }

             if (BeSmart || dwPageNumber <= dwTotalNumberOfPages) {
                if (!PlayEMFPage(hSpoolHandle,
                                  hPrinterDC,
                                  hEMF,
                                  1,
                                  dwPageNumber,
                                  1,
                                  dwNupBorderFlags,
                                  EMF_DEGREE_90)) {

                     ODS(("PlayEMFPage failed\n"));
                     goto CleanUp;
                 }
             }

             if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
                 ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                 goto CleanUp;
             }
       }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}



BOOL
PrintReverseForDriverEMF(
    HANDLE     hSpoolHandle,
    HDC        hPrinterDC,
    DWORD      dwDrvNumberOfPagesPerSide,
    DWORD      dwTotalNumberOfPages,
    DWORD      dwNupBorderFlags,
    DWORD      dwJobNumberOfCopies,
    DWORD      dwDrvNumberOfCopies,
    BOOL       bCollate,
    BOOL       bDuplex,
    BOOL       bOdd,
    DWORD      dwOptimization,
    LPDEVMODEW pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintReverseForDriverEMF plays the EMF pages in the reverse order
                      for the driver which does the Nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwTotalNumberOfPages   -- total number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bDuplex                -- flag to indicate duplex printing
            bOdd                   -- flag to indicate odd number of sides to print
            dwOptimization         -- optimization flags
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                                     

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD         dwPageIndex,dwPageNumber,dwRemainingCopies;
    BOOL          bReturn = FALSE;

    // select the correct page for duplex printing
    if (bDuplex && !bOdd) {
       if (pHead) {
          pHead = pHead->pNext;
       } else {
          bReturn = TRUE;
          goto CleanUp;
       }
    }

    // play the sides in reverse order
    while (pHead) {
        //
        // If the print processor is paused, wait for it to be resumed
        //
        if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
            WaitForSingleObject(pData->semPaused, INFINITE);
        }
        
        // set the page number
        dwPageNumber = pHead->dwPageNumber;

        if (bCollate) {
       
           if (!PrintOneSideReverseForDriverEMF(hSpoolHandle,
                                                hPrinterDC,
                                                dwDrvNumberOfPagesPerSide,
                                                dwTotalNumberOfPages,
                                                dwNupBorderFlags,
                                                bDuplex,
                                                dwOptimization,
                                                dwPageNumber,
                                                pDevmode)) {
               goto CleanUp;
           }
           
        } else {

           dwRemainingCopies = dwJobNumberOfCopies;

           while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }

               if (!PrintOneSideReverseForDriverEMF(hSpoolHandle,
                                                    hPrinterDC,
                                                    dwDrvNumberOfPagesPerSide,
                                                    dwTotalNumberOfPages,
                                                    dwNupBorderFlags,
                                                    bDuplex,
                                                    dwOptimization,
                                                    dwPageNumber,
                                                    pDevmode)) {
                   goto CleanUp;
               }
           }
        }

        pHead = pHead->pNext;

        // go to the next page for duplex printing
        if (bDuplex && pHead) {
            pHead = pHead->pNext;
        }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideReverseEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwStartPage1,
    DWORD        dwEndPage1,
    DWORD        dwStartPage2,
    DWORD        dwEndPage2,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideReverseEMF plays the EMF pages for the next physical page.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            bDuplex                -- flag to indicate duplex printing
            dwOptimization         -- optimization flags
            dwStartPage1           -- page number of the first EMF page on 1st side
            dwEndPage1             -- page number of the last EMF page on 1st side
            dwStartPage2           -- page number of the first EMF page on 2nd side
            dwEndPage2             -- page number of the last EMF page on 2nd side
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
    DWORD         dwPageNumber, dwPageIndex, dwPageType;
    BOOL          bReturn = FALSE, bNewDevmode;
    LPDEVMODEW    pCurrDM;
    HANDLE        hEMF = NULL;
    DWORD         dwEndPage, dwStartPage, dwSides, dwAngle;
    INT           dmOrientation = pDevmode->dmOrientation;

    for (dwSides = bDuplex ? 2 : 1; 
         dwSides; 
         --dwSides) {

         if (bDuplex && (dwSides == 1)) {
             dwStartPage = dwStartPage2;
             dwEndPage = dwEndPage2;
         } else {
             dwStartPage = dwStartPage1;
             dwEndPage = dwEndPage1;
         }

         for (dwPageNumber = dwStartPage, dwPageIndex = 1;
              dwPageNumber <= dwEndPage;
              ++dwPageNumber, ++dwPageIndex) {

            if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                             dwPageNumber,
                                             &dwPageType))) {

                ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;                      
            }
            dwAngle = EMF_DEGREE_90;
            if (dwPageIndex == 1) {
                   
                // Process devmodes in the spool file and call StartPage
                if (!ResetDCForNewDevmode(hSpoolHandle,
                                             hPrinterDC,
                                             dwPageNumber,
                                             FALSE,
                                             dwOptimization,
                                             &bNewDevmode,
                                             pDevmode,
                                             &pCurrDM) ||

                       !GdiStartPageEMF(hSpoolHandle)) {
                        
                       goto CleanUp;
                }
                if (pCurrDM)
                    dmOrientation = pCurrDM->dmOrientation;
            }
            // in case of orientation switch we need to keep track of what
            // we started with and what it is now
            else if (dwNumberOfPagesPerSide > 1)
            {
                if (GdiGetDevmodeForPage(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                    {
                        dwAngle = EMF_DEGREE_SWAP | EMF_DEGREE_90;
                    }
                }
            }

            if (!PlayEMFPage(hSpoolHandle,
                                hPrinterDC,
                                hEMF,
                                dwNumberOfPagesPerSide,
                                dwPageNumber,
                                dwPageIndex,
                                dwNupBorderFlags,
                                dwAngle)) {

                ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }
         }

         if ((dwPageIndex == 1) && !GdiStartPageEMF(hSpoolHandle)) {
              ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
              goto CleanUp;
         }

         if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
             ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
             goto CleanUp;
         }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintReverseEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bDuplex,
    BOOL         bOdd,
    DWORD        dwOptimization,
    LPDEVMODEW   pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintReverseEMF plays the EMF pages in the reverse order and also
                      performs nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwTotalNumberOfPages   -- number of pages in the document
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bDuplex                -- flag to indicate duplex printing
            bOdd                   -- flag to indicate odd number of sides to print
            dwOptimization         -- optimization flags
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                                       

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD         dwPageNumber,dwPageIndex,dwRemainingCopies;
    DWORD         dwStartPage1,dwStartPage2,dwEndPage1,dwEndPage2;
    BOOL          bReturn = FALSE;

    if (!pHead) {
        bReturn = TRUE;
        goto CleanUp;
    }

    // set the start and end page numbers for duplex and regular printing
    if (bDuplex) {
       if (bOdd) {
           dwStartPage1 = pHead->dwPageNumber;
           dwEndPage1   = dwTotalNumberOfPages;
           dwStartPage2 = dwTotalNumberOfPages+1;
           dwEndPage2   = 0;
       } else {
           dwStartPage2 = pHead->dwPageNumber;
           dwEndPage2   = dwTotalNumberOfPages;

           if (pHead = pHead->pNext) {
               dwStartPage1 = pHead->dwPageNumber;
               dwEndPage1   = dwStartPage2 - 1;
           }
       }
    } else {
       dwStartPage1 = pHead->dwPageNumber;
       dwEndPage1   = dwTotalNumberOfPages;
       dwStartPage2 = 0;
       dwEndPage2   = 0;
    }

    while (pHead) {
       //
       // If the print processor is paused, wait for it to be resumed 
       //
       if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
              WaitForSingleObject(pData->semPaused, INFINITE);
       }
         
       if (bCollate) {

          if (!PrintOneSideReverseEMF(hSpoolHandle,
                                      hPrinterDC,
                                      dwNumberOfPagesPerSide,
                                      dwNupBorderFlags,
                                      bDuplex,
                                      dwOptimization,
                                      dwStartPage1,
                                      dwEndPage1,
                                      dwStartPage2,
                                      dwEndPage2,
                                      pDevmode)) {

              goto CleanUp;
          }

       } else {

          dwRemainingCopies = dwJobNumberOfCopies;

          while (dwRemainingCopies) {

              if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                 SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                 dwRemainingCopies = 0;
              } else {
                 SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                 dwRemainingCopies -= dwDrvNumberOfCopies;
              }

              if (!PrintOneSideReverseEMF(hSpoolHandle,
                                          hPrinterDC,
                                          dwNumberOfPagesPerSide,
                                          dwNupBorderFlags,
                                          bDuplex,
                                          dwOptimization,
                                          dwStartPage1,
                                          dwEndPage1,
                                          dwStartPage2,
                                          dwEndPage2,
                                          pDevmode)) {

                  goto CleanUp;
              }
          }
       }

       if (bDuplex) {
          if (pHead->pNext && pHead->pNext->pNext) {
              dwEndPage2 = pHead->dwPageNumber - 1;
              pHead = pHead->pNext;
              dwStartPage2 = pHead->dwPageNumber;
              dwEndPage1 = dwStartPage2 - 1;
              pHead = pHead->pNext;
              dwStartPage1 = pHead->dwPageNumber;
          } else {
              break;
          }
       } else {
          pHead = pHead->pNext;
          if (pHead) {
              dwEndPage1 = dwStartPage1 - 1;
              dwStartPage1 = pHead->dwPageNumber;
          }
       }

    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideBookletEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwTotalPrintPages,
    DWORD        dwStartPage,
    BOOL         bReverseOrderPrinting,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideBookletEMF prints one page of the booklet job.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            dwTotalNumberOfPages   -- number of pages in the document
            dwTotalPrintPages      -- number of pages to printed (multiple of 4)
            dwStartPage            -- number of the starting page for the side
            bReverseOrderPrinting  -- flag for reverse order printing
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD       dwPageArray[4];
    DWORD       dwPagesPrinted = 0, dwPageIndex, dwAngle, dwPageType, dwLastPage;
    HANDLE      hEMF = NULL;
    LPDEVMODEW  pCurrDM;
    BOOL        bReturn = FALSE ,bNewDevmode;
    INT         dmOrientation;

    // set the order of the pages
    if (bReverseOrderPrinting) {
        dwPageArray[0] = dwStartPage + 1;
        dwPageArray[1] = dwTotalPrintPages - dwStartPage;
        if (dwDuplexMode == EMF_DUP_VERT) {
           dwPageArray[2] = dwStartPage;
           dwPageArray[3] = dwPageArray[1] + 1;
        } else { // EMF_DUP_HORZ
           dwPageArray[3] = dwStartPage;
           dwPageArray[2] = dwPageArray[1] + 1;
        }
    } else {
        dwPageArray[1] = dwStartPage;
        dwPageArray[0] = dwTotalPrintPages - dwStartPage + 1;
        if (dwDuplexMode == EMF_DUP_VERT) {
           dwPageArray[2] = dwPageArray[0] - 1;
           dwPageArray[3] = dwPageArray[1] + 1;
        } else { // EMF_DUP_HORZ
           dwPageArray[2] = dwPageArray[1] + 1;
           dwPageArray[3] = dwPageArray[0] - 1;
        }
    }

    // Set page number for ResetDC
    dwLastPage = (dwTotalNumberOfPages < dwPageArray[0]) ? dwTotalNumberOfPages
                                                         : dwPageArray[0];

    // Process devmodes in the spool file
    if (!ResetDCForNewDevmode(hSpoolHandle,
                              hPrinterDC,
                              dwLastPage,
                              FALSE,
                              dwOptimization,
                              &bNewDevmode,
                              pDevmode,
                              &pCurrDM)) {
        goto CleanUp;
    }
    if (pCurrDM)
        dmOrientation = pCurrDM->dmOrientation;
    else
        dmOrientation = pDevmode->dmOrientation;

    while (dwPagesPrinted < 4) {
       for (dwPageIndex = 1;
            dwPageIndex <= dwNumberOfPagesPerSide;
            ++dwPageIndex, ++dwPagesPrinted) {

            if (dwPageArray[dwPagesPrinted] <= dwTotalNumberOfPages) {

                if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                              dwPageArray[dwPagesPrinted],
                                              &dwPageType))) {
                     ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }
            if (dwPageIndex == 1) {

                if (!GdiStartPageEMF(hSpoolHandle)) {
                     ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                    goto CleanUp;
                }
            }
    
            if (dwPageArray[dwPagesPrinted] <= dwTotalNumberOfPages) {
                // in case of orientation switch we need to keep track of what
                // we started with and what it is now
                dwAngle = 0;
                if (GdiGetDevmodeForPage(hSpoolHandle, 
                              dwPageArray[dwPagesPrinted],
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                        dwAngle |= EMF_DEGREE_SWAP;
                }

                if ((dwDuplexMode == EMF_DUP_VERT) &&
                     (dwPagesPrinted > 1)) {
                      dwAngle |= EMF_DEGREE_270;
                } else { // EMF_DUP_HORZ or 1st side
                      dwAngle |= EMF_DEGREE_90;
                }
  
                if (!PlayEMFPage(hSpoolHandle,
                                  hPrinterDC,
                                  hEMF,
                                  dwNumberOfPagesPerSide,
                                  dwPageArray[dwPagesPrinted],
                                  dwPageIndex,
                                  dwNupBorderFlags,
                                  dwAngle)) {

                     ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }

            if (dwPageIndex == dwNumberOfPagesPerSide) {

                if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
                     ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }
       }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}


BOOL
PrintBookletEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bReverseOrderPrinting,
    BOOL         bCollate,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODEW   pDevmode,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintBookletEMF prints the job in 2-up in booklet form.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwTotalNumberOfPages   -- number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bReverseOrderPrinting  -- flag for reverse order printing
            bCollate               -- flag for collating the copies
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- pointer to devmode for changing the copy count
            pData                  -- needed for status and the handle of the event: pause, resume etc.

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL              bReturn = FALSE;
    DWORD             dwTotalPrintPages, dwNumberOfPhyPages, dwRemainingCopies, dwIndex;

    // Get closest multiple of 4 greater than dwTotalNumberOfPages
    dwTotalPrintPages = dwTotalNumberOfPages - (dwTotalNumberOfPages % 4);
    if (dwTotalPrintPages != dwTotalNumberOfPages) {
        dwTotalPrintPages += 4;
    }
    dwNumberOfPhyPages = (DWORD) dwTotalPrintPages / 4;

    for (dwIndex = 0; dwIndex < dwNumberOfPhyPages; ++dwIndex) {
         //
         // If the print processor is paused, wait for it to be resumed 
         //
         if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                WaitForSingleObject(pData->semPaused, INFINITE);
         }

         if (bCollate) {

            if (!PrintOneSideBookletEMF(hSpoolHandle,
                                        hPrinterDC,
                                        dwNumberOfPagesPerSide,
                                        dwNupBorderFlags,
                                        dwTotalNumberOfPages,
                                        dwTotalPrintPages,
                                        dwIndex * 2 + 1,
                                        bReverseOrderPrinting,
                                        dwOptimization,
                                        dwDuplexMode,
                                        pDevmode)) {
                 goto CleanUp;
            }

         } else {

            dwRemainingCopies = dwJobNumberOfCopies;

            while (dwRemainingCopies) {

                if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                   SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                   dwRemainingCopies = 0;
                } else {
                   SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                   dwRemainingCopies -= dwDrvNumberOfCopies;
                }

                if (!PrintOneSideBookletEMF(hSpoolHandle,
                                            hPrinterDC,
                                            dwNumberOfPagesPerSide,
                                            dwNupBorderFlags,
                                            dwTotalNumberOfPages,
                                            dwTotalPrintPages,
                                            dwIndex * 2 + 1,
                                            bReverseOrderPrinting,
                                            dwOptimization,
                                            dwDuplexMode,
                                            pDevmode)) {
                     goto CleanUp;
                }
            }
         }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintEMFSingleCopy(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    BOOL         bReverseOrderPrinting,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bOdd,
    BOOL         bBookletPrint,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODEW   pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintEMFSingleCopy plays one copy of the job on hPrinterDC.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            bReverseOrderPrinting  -- flag for reverse order printing
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwTotalNumberOfPages   -- number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bOdd                   -- flag to indicate odd number of sides to print
            bBookletPrint          -- flag for booklet printing
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                             

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL  bDuplex = (dwDuplexMode != EMF_DUP_NONE);

    if (bBookletPrint) {

       // Booklet Printing
       return PrintBookletEMF(hSpoolHandle,
                              hPrinterDC,
                              dwNumberOfPagesPerSide,
                              dwTotalNumberOfPages,
                              dwNupBorderFlags,
                              dwJobNumberOfCopies,
                              dwDrvNumberOfCopies,
                              bReverseOrderPrinting,
                              bCollate,
                              dwOptimization,
                              dwDuplexMode,
                              pDevmode,
                              pData);
    }

    if (bReverseOrderPrinting) {
       if (dwDrvNumberOfPagesPerSide != 1 || dwNumberOfPagesPerSide == 1) {

          // @@BEGIN_DDKSPLIT
          // Reverse printing while driver does nup / no nup required
          // @@END_DDKSPLIT
          return PrintReverseForDriverEMF(hSpoolHandle,
                                          hPrinterDC,
                                          dwDrvNumberOfPagesPerSide,
                                          dwTotalNumberOfPages,
                                          dwNupBorderFlags,
                                          dwJobNumberOfCopies,
                                          dwDrvNumberOfCopies,
                                          bCollate,
                                          bDuplex,
                                          bOdd,
                                          dwOptimization,
                                          pDevmode,
                                          pHead,
                                          pData);
       } else {

          // Reverse printing and nup
          return PrintReverseEMF(hSpoolHandle,
                                 hPrinterDC,
                                 dwTotalNumberOfPages,
                                 dwNumberOfPagesPerSide,
                                 dwNupBorderFlags,
                                 dwJobNumberOfCopies,
                                 dwDrvNumberOfCopies,
                                 bCollate,
                                 bDuplex,
                                 bOdd,
                                 dwOptimization,
                                 pDevmode,
                                 pHead,
                                 pData);
       }

    } else {

       // Normal printing
       return PrintForwardEMF(hSpoolHandle,
                              hPrinterDC,
                              dwNumberOfPagesPerSide,
                              dwDrvNumberOfPagesPerSide,
                              dwNupBorderFlags,
                              dwJobNumberOfCopies,
                              dwDrvNumberOfCopies,
                              bCollate,
                              bDuplex,
                              dwOptimization,
                              pDevmode,
                              pData);
    }
}

BOOL
GetStartPageList(
    HANDLE       hSpoolHandle,
    PPAGE_NUMBER *pHead,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNumberOfPagesPerSide,
    BOOL         bCheckForDevmode,
    LPBOOL       pbOdd)

/*++
Function Description: GetStartPageList generates a list of the page numbers which
                      should appear on the start of each side of the job. This takes
                      into consideration the ResetDC calls that may appear before the
                      end of the page. The list generated by GetStartPageList is used
                      to play the job in reverse order.

Parameters: hSpoolHandle           -- handle the spool file handle
            pHead                  -- pointer to a pointer to a linked list containing the
                                       starting page numbers for each of the sides
            dwTotalNumberOfPages   -- number of pages in the document
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            pbOdd                  -- pointer to flag indicating odd number of pages to
                                       print

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{

    DWORD        dwPageIndex,dwPageNumber=1,dwPageType;
    LPDEVMODEW   pCurrDM, pLastDM;
    PPAGE_NUMBER pTemp=NULL;
    BOOL         bReturn = FALSE;
    BOOL         bCheckDevmode;

    bCheckDevmode = bCheckForDevmode && (dwNumberOfPagesPerSide != 1);

    while (dwPageNumber <= dwTotalNumberOfPages) {

       for (dwPageIndex = 1;
            (dwPageIndex <= dwNumberOfPagesPerSide) && (dwPageNumber <= dwTotalNumberOfPages);
            ++dwPageIndex, ++dwPageNumber) {

          if (bCheckDevmode) {

             // Check if the devmode has changed requiring a new page
             if (!GdiGetDevmodeForPage(hSpoolHandle, dwPageNumber,
                                               &pCurrDM, NULL)) {
                 ODS(("Get devmodes failed\n"));
                 goto CleanUp;
             }

             if (dwPageIndex == 1) {
                 // Save the Devmode for the first page on a side
                 pLastDM = pCurrDM;

             } else {
                 // If the Devmode changes in a side, start a new page
                 if (DifferentDevmodes(pCurrDM, pLastDM)) {

                     dwPageIndex = 1;
                     pLastDM = pCurrDM;
                 }
             }
          }

          // Create a node for the start of a side
          if (dwPageIndex == 1) {

              if (!(pTemp = AllocSplMem(sizeof(PAGE_NUMBER)))) {
                  ODS(("GetStartPageList - Run out of memory"));
                  goto CleanUp;
              }
              pTemp->pNext = *pHead;
              pTemp->dwPageNumber = dwPageNumber;
              *pHead = pTemp;

              // flip the bOdd flag
              *pbOdd = !*pbOdd;
          }
       }
    }

    bReturn = TRUE;

CleanUp:

    // Free up the memory in case of a failure.
    if (!bReturn) {
       while (pTemp = *pHead) {
          *pHead = (*pHead)->pNext;
          FreeSplMem(pTemp);
       }
    }
    return bReturn;
}


BOOL
CopyDevmode(
    PPRINTPROCESSORDATA pData,
    LPDEVMODEW *pDevmode)

/*++
Function Description: Copies the devmode in pData or the default devmode into pDevmode.

Parameters:   pData           - Data structure for the print job
              pDevmode        - pointer to devmode

Return Value:  TRUE  if successful
               FALSE otherwise
--*/

{
    HANDLE           hDrvPrinter = NULL;
    BOOL             bReturn = FALSE;
    fnWinSpoolDrv    fnList;
    LONG             lNeeded;

    if (pData->pDevmode) {

        lNeeded = pData->pDevmode->dmSize +  pData->pDevmode->dmDriverExtra;

        if (*pDevmode = (LPDEVMODEW) AllocSplMem(lNeeded)) {
            memcpy(*pDevmode, pData->pDevmode, lNeeded);
        } else {
            goto CleanUp;
        }

    } else {
        // Get the default devmode

        // Get the pointer to the client side functions from the router
        if (!SplInitializeWinSpoolDrv(&fnList)) {
            goto CleanUp;
        }

        // Get a client side printer handle to pass to the driver
        if (!(* (fnList.pfnOpenPrinter))(pData->pPrinterName, &hDrvPrinter, NULL)) {
            ODS(("Open printer failed\nPrinter %ws\n", pData->pPrinterName));
            goto CleanUp;
        }

        lNeeded = (* (fnList.pfnDocumentProperties))(NULL,
                                                     hDrvPrinter,
                                                     pData->pPrinterName,
                                                     NULL,
                                                     NULL,
                                                     0);

        if (lNeeded <= 0  ||
            !(*pDevmode = (LPDEVMODEW) AllocSplMem(lNeeded)) ||
            (* (fnList.pfnDocumentProperties))(NULL,
                                               hDrvPrinter,
                                               pData->pPrinterName,
                                               *pDevmode,
                                               NULL,
                                               DM_OUT_BUFFER) < 0) {

             if (*pDevmode) {
                FreeSplMem(*pDevmode);
                *pDevmode = NULL;
             }

             ODS(("DocumentProperties failed\nPrinter %ws\n",pData->pPrinterName));
             goto CleanUp;
        }
    }

    bReturn = TRUE;

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }

    return bReturn;
}

BOOL
PrintEMFJob(
    PPRINTPROCESSORDATA pData,
    LPWSTR pDocumentName)

/*++
Function Description: Prints out a job with EMF data type.

Parameters:   pData           - Data structure for this job
              pDocumentName   - Name of this document

Return Value:  TRUE  if successful
               FALSE if failed - GetLastError() will return reason.
--*/

{
    HANDLE             hSpoolHandle = NULL;
    DWORD              LastError; 
    HDC                hPrinterDC = NULL;

    BOOL               bReverseOrderPrinting, bReturn = FALSE, bSetWorldXform = TRUE;
    BOOL               bCollate, bDuplex, bBookletPrint, bStartDoc = FALSE, bOdd = FALSE;
    BOOL               bUpdateAttributes = FALSE;
    SHORT              dmCollate,dmCopies;

    DWORD              dwNumberOfPagesPerSide, dwTotalNumberOfPages = 0, dwNupBorderFlags;
    DWORD              dwJobNumberOfPagesPerSide, dwDrvNumberOfPagesPerSide, dwDuplexMode;
    DWORD              dwJobNumberOfCopies, dwDrvNumberOfCopies,dwRemainingCopies;
    DWORD              dwJobOrder, dwDrvOrder, dwOptimization;

    DOCINFOW           DocInfo;
    XFORM              OldXForm;
    PPAGE_NUMBER       pHead = NULL,pTemp;
    ATTRIBUTE_INFO_3   AttributeInfo;
    LPDEVMODEW         pDevmode = NULL, pFirstDM = NULL, pCopyDM;

    
    // Copy the devmode into pDevMode
    if (!CopyDevmode(pData, &pDevmode)) {
        
        ODS(("CopyDevmode failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    // Update resolution before CreateDC for monochrome optimization
    if (!GetJobAttributes(pData->pPrinterName,
                          pDevmode,
                          &AttributeInfo)) {
        ODS(("GetJobAttributes failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    } else {
        if (AttributeInfo.dwColorOptimization) {
            if (pDevmode->dmPrintQuality != AttributeInfo.dmPrintQuality ||
                pDevmode->dmYResolution != AttributeInfo.dmYResolution)
            {
                pDevmode->dmPrintQuality =  AttributeInfo.dmPrintQuality;
                pDevmode->dmYResolution =  AttributeInfo.dmYResolution;
                bUpdateAttributes = TRUE;
            }
        }
        if (pDevmode->dmFields & DM_COLLATE)
            dmCollate = pDevmode->dmCollate;
        else
            dmCollate = DMCOLLATE_FALSE;
        if (pDevmode->dmFields & DM_COPIES)
            dmCopies = pDevmode->dmCopies;
        else
            dmCopies = 0;
    }

    // Get spool file handle and printer device context from GDI
    try {

        hSpoolHandle = GdiGetSpoolFileHandle(pData->pPrinterName,
                                             pDevmode,
                                             pDocumentName);
        if (hSpoolHandle) {
            hPrinterDC = GdiGetDC(hSpoolHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    if (!hPrinterDC || !hSpoolHandle) {
        goto CleanUp;
    }

    // Use the first devmode in the spool file to update the copy count
    // and the collate setting
    if (GdiGetDevmodeForPage(hSpoolHandle, 1, &pFirstDM, NULL) &&
        pFirstDM) {
        
        if (pFirstDM->dmFields & DM_COPIES) {
            pDevmode->dmFields |= DM_COPIES;
            pDevmode->dmCopies = pFirstDM->dmCopies;
        }
        if (pFirstDM->dmFields & DM_COLLATE) {
            pDevmode->dmFields |= DM_COLLATE;
            pDevmode->dmCollate = pFirstDM->dmCollate;
        }
    }

    // The number of copies of the print job is the product of the number of copies set
    // from the driver UI (present in the devmode) and the number of copies in pData struct
    dwJobNumberOfCopies = (pDevmode->dmFields & DM_COPIES) ? pData->Copies*pDevmode->dmCopies
                                                           : pData->Copies;
    pDevmode->dmCopies = (short) dwJobNumberOfCopies;
    pDevmode->dmFields |=  DM_COPIES;

    // If collate is true this limits the ability of the driver to do multiple copies 
    // and causes the driver (PS) supported n-up to print blank page borders for reverse printing.
    // Therefore we disable collate for 1 page multiple copy jobs or no copies but n-up since 
    // collate has no meaning in those cases.
    //
    if ((pDevmode->dmFields & DM_COLLATE) && pDevmode->dmCollate == DMCOLLATE_TRUE)
    {
        if (dwJobNumberOfCopies > 1)
        {
            // Get the number of pages in the job. This call waits till the
            // last page is spooled.
            try {

                dwTotalNumberOfPages = GdiGetPageCount(hSpoolHandle);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
                goto SkipCollateDisable;
            }
            if (dwTotalNumberOfPages > AttributeInfo.dwDrvNumberOfPagesPerSide)
                goto SkipCollateDisable;
            
        }
        // if copies == 1 and driver n-up we will disable collate 
        //
        else if (AttributeInfo.dwDrvNumberOfPagesPerSide <= 1 && dmCollate == DMCOLLATE_TRUE)
            goto SkipCollateDisable;
            
        pDevmode->dmCollate = DMCOLLATE_FALSE;
        if (pFirstDM)
            pFirstDM->dmCollate = DMCOLLATE_FALSE;
    }
SkipCollateDisable:    
    // Update the job attributes but only if something has changed. This is an expensive 
    // call so we only make a second call to GetJobAttributes if something has changed.
    //
    if (bUpdateAttributes || pDevmode->dmCopies != dmCopies || 
            ((pDevmode->dmFields & DM_COLLATE) && (pDevmode->dmCollate != dmCollate)))
    {
        if (!GetJobAttributes(pData->pPrinterName,
                          pDevmode,
                          &AttributeInfo)) {
            ODS(("GetJobAttributes failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
            goto CleanUp;
        }
    }

    // Initialize bReverseOrderPrinting, dwJobNumberOfPagesPerSide,
    // dwDrvNumberOfPagesPerSide, dwNupBorderFlags, dwJobNumberOfCopies,
    // dwDrvNumberOfCopies and bCollate

    dwJobNumberOfPagesPerSide = AttributeInfo.dwJobNumberOfPagesPerSide;
    dwDrvNumberOfPagesPerSide = AttributeInfo.dwDrvNumberOfPagesPerSide;
    dwNupBorderFlags          = AttributeInfo.dwNupBorderFlags;
    dwJobNumberOfCopies       = AttributeInfo.dwJobNumberOfCopies;
    dwDrvNumberOfCopies       = AttributeInfo.dwDrvNumberOfCopies;

    dwJobOrder                = AttributeInfo.dwJobPageOrderFlags & ( NORMAL_PRINT | REVERSE_PRINT);
    dwDrvOrder                = AttributeInfo.dwDrvPageOrderFlags & ( NORMAL_PRINT | REVERSE_PRINT);
    bReverseOrderPrinting     = (dwJobOrder != dwDrvOrder);

    dwJobOrder                = AttributeInfo.dwJobPageOrderFlags & BOOKLET_PRINT;
    dwDrvOrder                = AttributeInfo.dwDrvPageOrderFlags & BOOKLET_PRINT;
    bBookletPrint             = (dwJobOrder != dwDrvOrder);

    bCollate                  = (pDevmode->dmFields & DM_COLLATE) &&
                                  (pDevmode->dmCollate == DMCOLLATE_TRUE);

    bDuplex                   = (pDevmode->dmFields & DM_DUPLEX) &&
                                  (pDevmode->dmDuplex != DMDUP_SIMPLEX);
    

    if (!dwJobNumberOfCopies) {
        //
        // Some applications can set the copy count to 0.
        // In this case we exit.
        //
        bReturn = TRUE;
        goto CleanUp;
    }

    if (bDuplex) {
        dwDuplexMode = (pDevmode->dmDuplex == DMDUP_HORIZONTAL) ? EMF_DUP_HORZ
                                                                : EMF_DUP_VERT;
    } else {
        dwDuplexMode = EMF_DUP_NONE;
    }

    if (bBookletPrint) {
        if (!bDuplex) {
            // Not supported w/o duplex printing. Use default settings.
            bBookletPrint = FALSE;
            dwDrvNumberOfPagesPerSide = 1;
            dwJobNumberOfPagesPerSide = 1;
        } else {
            // Fixed settings for pages per side.
            dwDrvNumberOfPagesPerSide = 1;
            dwJobNumberOfPagesPerSide = 2;
        }
    }

    // Number of pages per side that the print processor has to play
    dwNumberOfPagesPerSide = (dwDrvNumberOfPagesPerSide == 1)
                                               ? dwJobNumberOfPagesPerSide
                                               : 1;

    if (dwNumberOfPagesPerSide == 1) {
        // if the print processor is not doing nup, don't draw borders
        dwNupBorderFlags = NO_BORDER_PRINT;
    }

    //
    // Color optimization may cause wrong output with duplex
    //
    dwOptimization = (AttributeInfo.dwColorOptimization == COLOR_OPTIMIZATION && 
                                           !bDuplex && dwJobNumberOfPagesPerSide == 1)
                                           ? EMF_PP_COLOR_OPTIMIZATION
                                           : 0;

    // Check for Valid Option for n-up printing
    if (!ValidNumberForNUp(dwNumberOfPagesPerSide)) {
        ODS(("Invalid N-up option\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    if (bReverseOrderPrinting || bBookletPrint) {

       // Get the number of pages in the job. This call waits till the
       // last page is spooled.
       try {

           dwTotalNumberOfPages= GdiGetPageCount(hSpoolHandle);

       } except (EXCEPTION_EXECUTE_HANDLER) {

           ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
           goto CleanUp;
       }

       // Get start page list for reverse printing
       // Check for a change of devmode between pages only if Nup and PCL driver
       if (!GetStartPageList(hSpoolHandle,
                             &pHead,
                             dwTotalNumberOfPages,
                             dwJobNumberOfPagesPerSide,
                             FALSE,
                             &bOdd)) {
            goto CleanUp;
       }
    }

    // Save the old transformation on hPrinterDC
    if (!SetGraphicsMode(hPrinterDC,GM_ADVANCED) ||
        !GetWorldTransform(hPrinterDC,&OldXForm)) {

         bSetWorldXform = FALSE;
         ODS(("Transformation matrix can't be set\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
         goto CleanUp;
    }

    // pCopyDM will be used for changing the copy count
    pCopyDM = pFirstDM ? pFirstDM : pDevmode;
    pCopyDM->dmPrintQuality = pDevmode->dmPrintQuality;
    pCopyDM->dmYResolution = pDevmode->dmYResolution;

    try {

        DocInfo.cbSize = sizeof(DOCINFOW);
        DocInfo.lpszDocName  = pData->pDocument;
        DocInfo.lpszOutput   = pData->pOutputFile;
        DocInfo.lpszDatatype = NULL;

        if (!GdiStartDocEMF(hSpoolHandle, &DocInfo)) goto CleanUp;
        bStartDoc = TRUE;

        if (bCollate) {

            dwRemainingCopies = dwJobNumberOfCopies & 0x0000FFFF ;

            while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pCopyDM, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pCopyDM, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }

               if (!PrintEMFSingleCopy(hSpoolHandle,
                                       hPrinterDC,
                                       bReverseOrderPrinting,
                                       dwDrvNumberOfPagesPerSide,
                                       dwNumberOfPagesPerSide,
                                       dwTotalNumberOfPages,
                                       dwNupBorderFlags,
                                       dwJobNumberOfCopies,
                                       dwDrvNumberOfCopies,
                                       bCollate,
                                       bOdd,
                                       bBookletPrint,
                                       dwOptimization,
                                       dwDuplexMode,
                                       pCopyDM,
                                       pHead,
                                       pData)) {
                   goto CleanUp;
               }
            }

        } else {

           if (!PrintEMFSingleCopy(hSpoolHandle,
                                   hPrinterDC,
                                   bReverseOrderPrinting,
                                   dwDrvNumberOfPagesPerSide,
                                   dwNumberOfPagesPerSide,
                                   dwTotalNumberOfPages,
                                   dwNupBorderFlags,
                                   dwJobNumberOfCopies,
                                   dwDrvNumberOfCopies,
                                   bCollate,
                                   bOdd,
                                   bBookletPrint,
                                   dwOptimization,
                                   dwDuplexMode,
                                   pCopyDM,
                                   pHead,
                                   pData)) {

               goto CleanUp;
           }
        }

        bStartDoc = FALSE;
        if (!GdiEndDocEMF(hSpoolHandle)) goto CleanUp;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("PrintEMFSingleCopy gave an exception\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    bReturn = TRUE;
    
CleanUp:

    //
    // Preserve the last error
    //
    LastError = bReturn ? ERROR_SUCCESS : GetLastError();
    
    if (bStartDoc) {
       GdiEndDocEMF(hSpoolHandle);
    }

    if (bSetWorldXform && hPrinterDC) {
       SetWorldTransform(hPrinterDC, &OldXForm);
    }

    while (pTemp = pHead) {
       pHead = pHead->pNext;
       FreeSplMem(pTemp);
    }

    if (pDevmode) {
       FreeSplMem(pDevmode);
    }

    try {
        if (hSpoolHandle) {
           GdiDeleteSpoolFileHandle(hSpoolHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("GdiDeleteSpoolFileHandle failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
    }

    SetLastError(LastError);
    
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\perflib\wmidata.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    wmidata.h

Abstract:

    Header file for the WMI trace event datatypes.

    Note -- link with spoolss.lib or perflib.lib to find these routines

Author:

    Bryan Kilian (BryanKil) May 2000

Revision History:


--*/

#ifndef __WMIDEF
#define __WMIDEF

//
// WMI Structures
//
// NOTE: Placing the spooler WMI types in a public header accessible to the
// sdktools depot would help a lot.  These structures are duplicated in the pdh
// source, so to change you need to change this header, the mofdata.guid file,
// and pdh\tracectr.

// JOB TRANSACTIONS
// The first four events correspond to the start and end event values found in
// evntrace.h.  Spooljob is the start and deletejob is the end.  Printjob is
// when the job is taken off the queue and printing has started.  Trackthread is
// used to track secondary threads spun off to help process a job, like RPC calls.
#define EVENT_TRACE_TYPE_SPL_SPOOLJOB    EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_SPL_PRINTJOB    EVENT_TRACE_TYPE_DEQUEUE
#define EVENT_TRACE_TYPE_SPL_DELETEJOB   EVENT_TRACE_TYPE_END
#define EVENT_TRACE_TYPE_SPL_TRACKTHREAD EVENT_TRACE_TYPE_CHECKPOINT

// Non-reserved event types start at 0x0A.  These match values in reducer code
// so they cannot be changed.
#define EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD 0x0A
#define EVENT_TRACE_TYPE_SPL_JOBRENDERED 0x0B
#define EVENT_TRACE_TYPE_SPL_PAUSE 0x0C
#define EVENT_TRACE_TYPE_SPL_RESUME 0x0D

typedef enum {
    eDataTypeRAW  = 1,
    eDataTypeEMF  = 2,
    eDataTypeTEXT = 3
} SPLDATATYPE;

// The fields in this struct correspond to the records in \nt\sdktools\trace\tracedmp\mofdata.guid
typedef union _WMI_SPOOL_DATA {
    // A zero indicates that the field was not filled in (i.e. WMI will ignore
    // the field).
    struct _WMI_JOBDATA {
        ULONG                  ulSize;      // Size of spooled job (post-rendered).
        SPLDATATYPE            eDataType;
        ULONG                  ulPages;
        ULONG                  ulPagesPerSide;
        // 0-3 indicates whether the spool writer, spool reader, and/or shadow
        // file were opened.  If not opened then the handles must of come from
        // the file pool cache.
        SHORT                  sFilesOpened;
    } uJobData;
    // See wingdi.h for definitions of the different possible values.
    struct _WMI_EMFDATA {
        ULONG                 ulSize;      // Size of spooled job (pre-rendered).
        ULONG                 ulICMMethod;
        SHORT                 sColor;
        SHORT                 sXRes;
        SHORT                 sYRes;
        SHORT                 sQuality;
        SHORT                 sCopies;
        SHORT                 sTTOption;
    } uEmfData;
} WMI_SPOOL_DATA, * PWMI_SPOOL_DATA;



ULONG
LogWmiTraceEvent(
    DWORD JobId,
    UCHAR EventTraceType,
    WMI_SPOOL_DATA *data        // Could be NULL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\perflib\wmi.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All rights reserved

Module Name:

    wmi.c

Abstract:

    Holds the internal operations for wmi instrumenation

Author:

    Stuart de Jong (sdejong) 15-Oct-99

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
//
// WMI files
//
#include <wmistr.h>
#include <evntrace.h>
#include "wmi.h"
#include "wmidata.h"
// End WMI


//
// How it works:
//
// There are similar guids defined in the sdktools tracecounter programs, and also 
// descriptions there of the information we send them. This is used by them to print out
// and format the data we send.
//
// When we start up we register ourselves with WMI and provide a callback into our control
// code. This allows an external tool to call the start trace code in WMI with our guid, which
// then has WMI call us, and start tracing. 
//
// Stopping a trace is also done through the callback. the data is then analyzed by the WMI tools
// and output in human readable form, or it could be further analyzed from there.
//




MODULE_DEBUG_INIT ( DBG_ERROR, DBG_ERROR );

// These Guid's correspond to the definitions in \nt\sdktools\trace\tracedmp\mofdata.guid

//
// Identifies the PrintJob data logged by the delete job event.
//
GUID WmiPrintJobGuid = { /* 127eb555-3b06-46ea-a08b-5dc2c3c57cfd */
    0x127eb555, 0x3b06, 0x46ea, 0xa0, 0x8b, 0x5d, 0xc2, 0xc3, 0xc5, 0x7c, 0xfd
};

//
// Identifies the RenderedJob data logged by the job rendered event.
//
GUID WmiRenderedJobGuid = { /* 1d32b239-92a6-485a-96d2-dc3659fb803e */
    0x1d32b239, 0x92a6, 0x485a, 0x96, 0xd2, 0xdc, 0x36, 0x59, 0xfb, 0x80, 0x3e
};

//
// Used by the control app. to find the callback that turns spooler tracing on
// and off.
//
GUID WmiSpoolerControlGuid = { /* 94a984ef-f525-4bf1-be3c-ef374056a592 */
    0x94a984ef, 0xf525, 0x4bf1, 0xbe, 0x3c, 0xef, 0x37, 0x40, 0x56, 0xa5, 0x92 };

#define szWmiResourceName TEXT("Spooler")

TRACE_GUID_REGISTRATION WmiTraceGuidReg[] =
{
    { (LPGUID)&WmiPrintJobGuid,
      NULL
    },
    { (LPGUID)&WmiRenderedJobGuid,
      NULL
    }
};

//
//  The mof fields point to the following data.
//    DWORD                JobId;  // Unique ID for the transaction of printing a job
//    WMI_SPOOL_DATA       Data;   // See splcom.h
//
typedef struct _WMI_SPOOL_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             MofData[2];
} WMI_SPOOL_EVENT, *PWMI_SPOOL_EVENT;


static TRACEHANDLE WmiRegistrationHandle;
static TRACEHANDLE WmiLoggerHandle;
static LONG ulWmiEnableLevel = 0;
static HANDLE hWmiRegisterThread = NULL;
static DWORD dwWmiRegisterThreadId = 0;

static ULONG bWmiTraceOnFlag = FALSE;
static ULONG bWmiIsInitialized = FALSE;

ULONG
WmiControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

/*++
  Routine Name:
    WmiRegisterTrace()
 
  Routine Description:
    Thread routine that registers us with the WMI tools
 
  Arguments:
   LPVOID Arg        : Not used.
 
 
--*/

DWORD 
WmiRegisterTrace(
    IN LPVOID arg
    )
{
    ULONG Status = ERROR_SUCCESS;
    WCHAR szImagePath[MAX_PATH];

    Status = GetModuleFileName(NULL, szImagePath, COUNTOF(szImagePath));
    if (Status == 0) {
        Status = ERROR_FILE_NOT_FOUND;
    }
    else {
        Status = RegisterTraceGuids(
            WmiControlCallback,
            NULL,                 
            (LPGUID)&WmiSpoolerControlGuid,
            1,
            WmiTraceGuidReg,
            szImagePath,
            szWmiResourceName,
            &WmiRegistrationHandle);
        
        if (Status == ERROR_SUCCESS) {
            DBGMSG(DBG_TRACE, ("WmiInitializeTrace: SPOOLER WMI INITIALIZED.\n"));
            InterlockedExchange(&bWmiIsInitialized, TRUE);
        }
        else {
            DBGMSG(DBG_TRACE, ("WmiInitializeTrace: SPOOLER WMI INITIALIZE FAILED: %u.\n",
                     Status));
        }
    }
    return Status;
}


/*++
  Routine Name:  
    WmiInitializeTrace()
 
  Routine Description:
    Initialises the Trace structures and registers the callback with WMI.
    This creates a thread and calls WmiRegisterTrace, since the registering may take
    a long time (up to minutes)
 
  Arguments:
 
  Returns ERROR_SUCCESS if it succeeds or ERROR_ALREADY_EXISTS otherwise
 
--*/
ULONG 
WmiInitializeTrace(VOID)
{
    ULONG Status = ERROR_ALREADY_EXISTS;
    
    if (!hWmiRegisterThread) 
    {
        InterlockedExchange(&bWmiIsInitialized, FALSE);

        //
        // Registering can block for a long time (I've seen minutes
        // occationally), so it must be done in its own thread.
        //
        if (hWmiRegisterThread = CreateThread(NULL,
                                              0,
                                              (LPTHREAD_START_ROUTINE)WmiRegisterTrace,
                                              0,
                                              0,
                                              &dwWmiRegisterThreadId))
        {
            CloseHandle(hWmiRegisterThread);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = GetLastError();
        }
    }
    
    return Status;
}

/*++
  Routine Name:
    WmiTerminateTrace()
 
  Routine Description:
    Deregisters us from the WMI tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success. a Winerror otherwise.
 
--*/
ULONG 
WmiTerminateTrace(VOID)
{
    ULONG Status = ERROR_SUCCESS;
    DWORD dwExitCode;

    if (bWmiIsInitialized) {
        InterlockedExchange(&bWmiIsInitialized, FALSE);
        Status = UnregisterTraceGuids(WmiRegistrationHandle);
        if (Status == ERROR_SUCCESS) {
            DBGMSG(DBG_TRACE, ("WmiTerminateTrace: SPOOLER WMI UNREGISTERED.\n"));
        }
        else {
            DBGMSG(DBG_TRACE, ("WmiTerminateTrace: SPOOLER WMI UNREGISTER FAILED.\n"));
        }       
    }
    
    return Status;
}

/*++
  Routine Name:  
    SplWmiTraceEvent()
 
  Routine Description:
    If tracing is turned on, this sends the event to the WMI subsystem.
 
  Arguments:
    DWORD            JobId          : the JobID this is related to.
    UCHAR            EventTraceType : The type of event that happened
    PWMI_SPOOL_DATA  Data           : The Event Data, could be NULL
 
  Returns ERROR_SUCCESS if it doesn't need to do anything, or if it succeeds.
 
--*/
ULONG
LogWmiTraceEvent(
    IN DWORD JobId,
    IN UCHAR EventTraceType,
    IN PWMI_SPOOL_DATA Data   OPTIONAL
    )
{
    WMI_SPOOL_EVENT WmiSpoolEvent;
    ULONG Status;

    if (!bWmiTraceOnFlag)
        return ERROR_SUCCESS;

    //
    // Level 1 tracing just traces response time of individual jobs with job data.
    // Default level is 0.
    //
    if (ulWmiEnableLevel == 1) {
        switch (EventTraceType) {
            //
            // Save overhead by not tracking resource usage.
            //
        case EVENT_TRACE_TYPE_SPL_TRACKTHREAD:
        case EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD:
            return ERROR_SUCCESS;
        default:
            //
            // Job data.
            //
            break;
        }
    }

    //
    // Record data.
    //
    RtlZeroMemory(&WmiSpoolEvent, sizeof(WmiSpoolEvent));
    WmiSpoolEvent.Header.Size  = sizeof(WMI_SPOOL_EVENT);
    WmiSpoolEvent.Header.Flags = (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR);
    WmiSpoolEvent.Header.Class.Type = EventTraceType;
    WmiSpoolEvent.Header.Guid  = WmiPrintJobGuid;

    WmiSpoolEvent.MofData[0].DataPtr = (ULONG64)&JobId;
    WmiSpoolEvent.MofData[0].Length = sizeof(DWORD);

    WmiSpoolEvent.MofData[1].DataPtr = (ULONG64)Data;
    if (Data) {
        switch (EventTraceType) {
        case EVENT_TRACE_TYPE_SPL_DELETEJOB:
            WmiSpoolEvent.MofData[1].Length = sizeof(struct _WMI_JOBDATA);
            break;
        case EVENT_TRACE_TYPE_SPL_JOBRENDERED:
            WmiSpoolEvent.Header.Guid  = WmiRenderedJobGuid;
            WmiSpoolEvent.MofData[1].Length = sizeof(struct _WMI_EMFDATA);
            break;
        default:
            DBGMSG(DBG_TRACE, ("SplWmiTraceEvent:  FAILED to log WMI Trace Event Unexpected Data JobId:%u Type:%u\n",
                     JobId, (ULONG) EventTraceType));
            return ERROR_INVALID_DATA;
        }
    }

    Status = TraceEvent(
        WmiLoggerHandle,
        (PEVENT_TRACE_HEADER) &WmiSpoolEvent);
    //
    // logger buffers out of memory should not prevent provider from
    // generating events. This will only cause events lost.
    //
    if (Status == ERROR_NOT_ENOUGH_MEMORY) {
        DBGMSG(DBG_TRACE, ("SplWmiTraceEvent: FAILED to log WMI Trace Event No Memory JobId:%u Type:%u\n",
                 JobId, (ULONG) EventTraceType));
    }
    else if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("SplWmiTraceEvent: FAILED to log WMI Trace Event JobId:%u Type:%u Status:%u\n",
                 JobId, (ULONG) EventTraceType, Status));
    }
    
    return Status;
}

/*++
  Routine Name:
    SplWmiControlCallback()
 
  Routine Description:
    This is the function we provite to the WMI subsystem as a callback, it is used to 
    start and stop the trace events.
 
  Arguments:
    IN     WMIDPREQUESTCODE  RequestCode      : The function to provide (enable/disable)
    IN     PVOID             Context          : Not used by us.
    IN OUT ULONG            *InOutBufferSize  : The Buffersize
    IN OUT PVOID             Buffer           : The buffer to use for the events
 
  Returns ERROR_SUCCESS on success, or an error code. 
 
--*/
ULONG
WmiControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;

    if (!bWmiIsInitialized) {
        DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI NOT INITIALIZED.\n"));
        return ERROR_GEN_FAILURE;
    }

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            WmiLoggerHandle = GetTraceLoggerHandle( Buffer );
            ulWmiEnableLevel = GetTraceEnableLevel( WmiLoggerHandle );
            InterlockedExchange(&bWmiTraceOnFlag, TRUE);

            DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI ENABLED LEVEL %u.\n",
                     ulWmiEnableLevel));
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI DISABLED.\n"));
            InterlockedExchange(&bWmiTraceOnFlag, FALSE);
            WmiLoggerHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = 0;
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\msnull.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    MsNull.c

Abstract:

    Implements lanman's msnull type parsing for FFs.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/


enum ParserAction

    {
        prdg_ActNull,
        prdg_ActDelimited,
        prdg_ActConstIgnore,
        prdg_ActCountIgnore,
        prdg_ActFF,
        prdg_ActReset
    };

enum FFstateType

    {
        prdg_FFtext,
        prdg_FFx0c,
        prdg_FFx1b6f,
        prdg_FFx1b45
    };

enum ParserStateType

    {
        prdg_Text,
        prdg_ESC_match,
        prdg_ESC_n_ignore,
        prdg_ESC_d_ignore,
        prdg_ESC_read_lo_count,
        prdg_ESC_read_hi_count
    };

typedef struct dci
    {
        enum ParserStateType ParserState;
        UINT            ParserCount;
        struct EscapeSequence *ParserSequence;
        CHAR           *ParserString;
        CHAR            ParserDelimiter;
        enum FFstateType FFstate;
        UINT uType;
    } DCI;

typedef DCI far *lpDCI;

struct EscapeSequence

    {
        CHAR             *ESCString;
        enum ParserAction ESCAction;
        UINT              ESCValue;
    };

#define MaxEscapeStrings (sizeof(EscapeStrings)/sizeof(struct EscapeSequence))


BOOL
CheckFormFeed(
    lpDCI pDCIData);

VOID
CheckFormFeedStream(
    lpDCI pDCIData,
    UCHAR   inch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\local.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved

Module Name:

    local.h

// @@BEGIN_DDKSPLIT                  
Abstract:

    DDK version of local.h


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _LOCAL_H_
#define _LOCAL_H_

// @@BEGIN_DDKSPLIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
/*
// @@END_DDKSPLIT
typedef long NTSTATUS;
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

// @@BEGIN_DDKSPLIT

#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT

#include <winddiui.h>

typedef struct _pfnWinSpoolDrv {
    BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
    BOOL    (*pfnClosePrinter)(HANDLE);
    BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
    BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM);
    LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);
    HANDLE  (*pfnLoadPrinterDriver)(HANDLE);
    BOOL    (*pfnSetDefaultPrinter)(LPCWSTR);
    BOOL    (*pfnGetDefaultPrinter)(LPWSTR, LPDWORD);
    HANDLE  (*pfnRefCntLoadDriver)(LPWSTR, DWORD, DWORD, BOOL);
    BOOL    (*pfnRefCntUnloadDriver)(HANDLE, BOOL);
    BOOL    (*pfnForceUnloadDriver)(LPWSTR);
}   fnWinSpoolDrv, *pfnWinSpoolDrv;


BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv   pfnList
    );

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    );


#define LOG_ERROR   EVENTLOG_ERROR_TYPE

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);
LPVOID ReallocSplMem(   LPVOID pOldMem, 
                        DWORD cbOld, 
                        DWORD cbNew);


#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT
#endif // INTERNAL
// @@END_DDKSPLIT


//
//  DEBUGGING:
//

#if DBG


BOOL
DebugPrint(
    PCH pszFmt,
    ...
    );
  
//
// ODS - OutputDebugString 
//
#define ODS( MsgAndArgs )       \
    do {                        \
        DebugPrint  MsgAndArgs;   \
    } while(0)  

#else
//
// No debugging
//
#define ODS(x)
#endif             // DBG

// @@BEGIN_DDKSPLIT
//#endif             // INTERNAL
// @@END_DDKSPLIT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\msnull.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    MsNull.c

Abstract:

    Implements lanman's msnull type parsing for FFs.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include "winprint.h"
#include "msnull.h"

#define sgn(x) (((x)>0) ? 1:-1)

struct EscapeSequence EscapeStrings[] =

    {
        { "-",prdg_ActConstIgnore, 1},
        { "0",prdg_ActNull,0},
        { "1",prdg_ActNull,0},
        { "2",prdg_ActNull,0},
        { "3",prdg_ActConstIgnore, 1},
        { "4",prdg_ActNull,0},
        { "5",prdg_ActConstIgnore, 1},
        { "6",prdg_ActNull,0},
        { "7",prdg_ActNull,0},
        { ":",prdg_ActNull,0},
        { "=",prdg_ActNull,0},
        { "A",prdg_ActConstIgnore, 1},
        { "B",prdg_ActDelimited, '\0'},
        { "C\0",prdg_ActConstIgnore, 1},
        { "D",prdg_ActDelimited, '\0'},
        { "E",prdg_ActReset,0},
        { "F",prdg_ActNull,0},
        { "G",prdg_ActNull,0},
        { "H",prdg_ActNull,0},
        { "I",prdg_ActConstIgnore, 1},
        { "J",prdg_ActConstIgnore, 1},
        { "K",prdg_ActCountIgnore, 0},
        { "L",prdg_ActCountIgnore, 0},
        { "N",prdg_ActConstIgnore, 1},
        { "O",prdg_ActNull,0},
        { "P",prdg_ActConstIgnore, 1},
        { "Q",prdg_ActConstIgnore, 1},
        { "R",prdg_ActNull,0},
        { "S",prdg_ActConstIgnore, 1},
        { "T",prdg_ActNull,0},
        { "U",prdg_ActConstIgnore, 1},
        { "W",prdg_ActConstIgnore, 1},
        { "X",prdg_ActConstIgnore, 2},
        { "Y",prdg_ActCountIgnore, 0},
        { "Z",prdg_ActCountIgnore, 0},
        { "[@",prdg_ActCountIgnore, 0},
        { "[C",prdg_ActCountIgnore, 0},
        { "[F",prdg_ActCountIgnore, 0},
        { "[I",prdg_ActCountIgnore, 0},
        { "[S",prdg_ActCountIgnore, 0},
        { "[T",prdg_ActCountIgnore, 0},
        { "[\\",prdg_ActCountIgnore, 0},
        { "[g",prdg_ActCountIgnore, 0},
        { "\\",prdg_ActCountIgnore, 0},
        { "]",prdg_ActNull,0},
        { "^",prdg_ActNull,0},
        { "_",prdg_ActConstIgnore, 1},
        { "d",prdg_ActConstIgnore, 2},
        { "e",prdg_ActConstIgnore, 2},
        { "j",prdg_ActNull,0},
        { "n",prdg_ActNull,0},
        { "\x6f", prdg_ActFF, 0}
    };



VOID
CheckFormFeedStream(
    lpDCI           pDCIData,
    unsigned char   inch)

/**********************************************************************/
/*                                                                    */
/*   FUNCTION: prdg_ParseRawData                                      */
/*                                                                    */
/*   PARAMETERS:                                                      */
/*                                                                    */
/*   lpDCI           pDCIData;  Pointer to DC instance data           */
/*   unsigned char   inch;     The next byte in data stream           */
/*                                                                    */
/*   DESCRIPTION:                                                     */
/*                                                                    */
/*   This function parses the stream of raw data which is being       */
/*   passed to the printer so that the driver can handle form feeds   */
/*   correctly.  The function must follow all the escape sequences    */
/*   which occur in the sequence of raw data.                         */
/*                                                                    */
/*   CHANGES:                                                         */
/*                                                                    */
/*   This function is table driven (from the table in in the ddata    */
/*   module) so it should hopefully only require this to be changed   */
/*   to reflect the escape sequences for a different printer.  If     */
/*   however there are escape sequneces which don't fall into the     */
/*   categories this parser can handle then extra code will have      */
/*   to be written to handle them.  The parser can handle escape      */
/*   sequences with any number of unique identifying characters       */
/*   possibly followed by: a count then the number of charcters given */
/*   in the count; a fixed number of characters; a stream of          */
/*   characters followed by a delimeter.                              */
/*                                                                    */
/**********************************************************************/

{
    /******************************************************************/
    /* Local Variables                                                */
    /******************************************************************/
    INT                    Direction;   /* Variables used in the      */
    UINT                   HiIndex;     /* binary chop routine for    */
    UINT                   LoIndex;     /* searching for a matching   */
    UINT                   Index;       /* escape sequence            */
    UINT                   PrevIndex;
    char *                 optr;        /* Pointers to access the     */
    char *                 nptr;        /* escape sequence strings    */
    struct EscapeSequence *NewSequence; /* Pointer to an escape       */
                                        /* sequence                   */

    /******************************************************************/
    /* Process the input character through the parsing function.      */
    /* Switch depending on which state we are currently in.  One of   */
    /* prdg_Text, prdg_ESC_match, prdg_ESC_n_ignore, prdg_ESC_d_ignore*/
    /* prdg_ESC_read_lo_count, prdg_ESC_read_hi_count.                */
    /******************************************************************/
    switch (pDCIData->ParserState)
    {
        case prdg_Text:
            /**********************************************************/
            /* Text state. Usual state, handled in line by a macro.   */
            /* The code is included here for completeness only.       */
            /* The FFaction (Form Feed action) state is maintained -  */
            /* if the character is text (ie >= 0x20) then set it to   */
            /* prdg_FFstate, if the character is a FF then set it to  */
            /* prdg_FFx0c.  If the input character is an escape then  */
            /* start up the sequence matching mode.                   */
            /**********************************************************/
            if (inch >= 0x20)
                pDCIData->FFstate = prdg_FFtext;

            else if (inch == 0x0c)
                pDCIData->FFstate = prdg_FFx0c;

            else if (inch == 0x1b)
            {
                /******************************************************/
                /* The character is an escape so set ParserState and  */
                /* indicate we have not matched a sequence yet by     */
                /* setting ParserSequence to NULL.                    */
                /******************************************************/
                pDCIData->ParserState = prdg_ESC_match;
                pDCIData->ParserSequence = NULL;
            }

            break;

        case prdg_ESC_match:
            /**********************************************************/
            /* Matching an escape sequence so try to match a new      */
            /* character.                                             */
            /**********************************************************/
            if (!pDCIData->ParserSequence)
            {
                /******************************************************/
                /* ParserSequence is NULL indicating that this is the */
                /* first character of an escape sequence so use a     */
                /* binary chop to get to the correct area of the      */
                /* table of escape sequences (based on the first      */
                /* character of the escape sequence which is the      */
                /* cuurent input character).                          */
                /******************************************************/
                HiIndex = MaxEscapeStrings;
                LoIndex = 0;
                Index = (LoIndex + HiIndex)/2;
                PrevIndex = MaxEscapeStrings;

                /******************************************************/
                /* while inch does not match the first character of   */
                /* the sequence indicated by Index move up or down    */
                /* the table depending on whether inch is < or > the  */
                /* first character of the escape sequence at Index.   */
                /******************************************************/
                while (Direction =
                               (inch - *EscapeStrings[Index].ESCString))
                {
                    if (Direction > 0)
                    {
                        LoIndex = Index;
                    }
                    else
                    {
                        HiIndex = Index;
                    };
                    PrevIndex = Index;
                    if (PrevIndex == (Index = (LoIndex + HiIndex)/2))
                    {
                        /**********************************************/
                        /* There is no escape sequence with a first   */
                        /* character matching the current input       */
                        /* character so resume text mode.             */
                        /**********************************************/
                        pDCIData->ParserState = prdg_Text;
                        return;
                    }

                }
                /*.. while (Direction = ...no match yet...............*/

                /******************************************************/
                /* Set up the ParserSequence and ParserString for the */
                /* first match found.                                 */
                /******************************************************/
                pDCIData->ParserSequence = &EscapeStrings[Index];
                pDCIData->ParserString = EscapeStrings[Index].ESCString;
            };
            /*.. if (!pDCIData->ParserSequence) .......................*/

            /**********************************************************/
            /* Loop forever trying to match escape sequences.         */
            /* First, try the new character against the current       */
            /* escape sequence and if it matches then check if it is  */
            /* the end of the sequence and if it is switch to the     */
            /* appropriate matching mode.  If the new character does  */
            /* not match try the next escape sequence (in either      */
            /* ascending or descending order depending on whether the */
            /* current character was < or > the character we were     */
            /* trying to match it to).  If the new sequence we are    */
            /* trying to match against does not exist (ie we are at   */
            /* one end of the table) or it does not match upto (but   */
            /* not including) the position we are currently at then   */
            /* the escape sequence in the raw data we are trying to   */
            /* match is invalid so revert to prdg_Text mode.  If it   */
            /* does match upto (but not including) the position we    */
            /* are currently trying to match then go back to try and  */
            /* match.                                                 */
            /**********************************************************/
            for (Direction = sgn(inch - *pDCIData->ParserString);;)
            {
                /******************************************************/
                /* Partway along a sequence, try the new character and*/
                /* if it matches then check for end of string.        */
                /******************************************************/
                if (!(inch - *pDCIData->ParserString))
                {
                    if (*++pDCIData->ParserString != '\0')
                        /**********************************************/
                        /* Escape sequence not finished yet so return */
                        /* and wait for the next character.  Note that*/
                        /* this is where the pointer to the position  */
                        /* in the escape sequence we are checking is  */
                        /* updated.                                   */
                        /**********************************************/
                        return;
                    else
                        /**********************************************/
                        /* The escape sequence has matched till the   */
                        /* end so break to the next section which will*/
                        /* take the appropriate action.               */
                        /**********************************************/
                        break;
                }
                /*.. if (!(inch - *pDCIData->ParserString)) ...match...*/

                else
                {
                    /**************************************************/
                    /* The current sequence does not match so we must */
                    /* try another sequence.  Direction determines    */
                    /* which way in the table we should go.           */
                    /**************************************************/
                    NewSequence = pDCIData->ParserSequence + Direction;

                    if (NewSequence < EscapeStrings ||
                        NewSequence> &EscapeStrings[MaxEscapeStrings-1])
                    {
                        /**********************************************/
                        /* The new sequence is beyond one end of the  */
                        /* table so revert to prdg_Text mode because  */
                        /* we will not be able to find a match.       */
                        /**********************************************/
                        pDCIData->ParserState = prdg_Text;
                        return;
                    }

                    /**************************************************/
                    /* Check that all the characters in the new       */
                    /* escape sequence upto (but not including) the   */
                    /* current one match the old escape sequence      */
                    /* (because those characters from the old escape  */
                    /* sequence have already been matched to the      */
                    /* raw data).                                     */
                    /**************************************************/
                    for (optr=pDCIData->ParserSequence->ESCString,
                         nptr=NewSequence->ESCString;
                         optr<pDCIData->ParserString; ++optr,++nptr)

                         if (*nptr != *optr)
                         {
                             /*****************************************/
                             /* If the new sequence does not match the*/
                             /* old then a match is not possible so   */
                             /* return.                               */
                             /*****************************************/
                             pDCIData->ParserState = prdg_Text;
                             return;
                         }

                    /**************************************************/
                    /* The new sequence is correct upto the character */
                    /* before the current character so loop back and  */
                    /* check the current character.                   */
                    /**************************************************/
                    pDCIData->ParserSequence = NewSequence;
                    pDCIData->ParserString = nptr;


                }
                /*.. else ! (!(inch - *pDCIData->ParserString.no match.*/

            }
            /*.. for ( ... ;;) ....for ever...........................*/

            /**********************************************************/
            /* The escape sequence has been matched from our table of */
            /* escape sequences so take the appropriate action for    */
            /* the particular sequence.                               */
            /**********************************************************/
            switch (pDCIData->ParserSequence->ESCAction)
            {
                case prdg_ActNull:
                    /**************************************************/
                    /* No further action so revert to prdg_Text mode  */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    break;

                case prdg_ActDelimited:
                    /**************************************************/
                    /* Ignore subsequent characters upto a specified  */
                    /* delimeter.                                     */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_d_ignore;
                    pDCIData->ParserDelimiter =
                               (char)pDCIData->ParserSequence->ESCValue;
                    break;

                case prdg_ActConstIgnore:
                    /**************************************************/
                    /* Ignore a specified number of characters.       */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_n_ignore;
                    pDCIData->ParserCount =
                                      pDCIData->ParserSequence->ESCValue;
                    break;

                case prdg_ActCountIgnore:
                    /**************************************************/
                    /* A two byte count follows so prepare to read it */
                    /* in.                                            */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_read_lo_count;
                    break;

                case prdg_ActFF:
                    /**************************************************/
                    /* A special action for recognising the 0x1b6f    */
                    /* "No Formfeed" sequence                         */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    pDCIData->FFstate = prdg_FFx1b6f;
                    break;

                case prdg_ActReset:
                    /**************************************************/
                    /* On Esc-E (reset) don't eject a page if this is */
                    /* the last sequence in the stream.               */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    pDCIData->FFstate = prdg_FFx1b45;
                    break;
            }
            /*.. switch (pDCIData->ParserSequence->ESCAction) .........*/

            break;

        case prdg_ESC_n_ignore:
            /**********************************************************/
            /* Ignoring n characters. Decrement the count, move back  */
            /* to text state if all ignored.                          */
            /**********************************************************/
            if (!(--pDCIData->ParserCount))
                pDCIData->ParserState = prdg_Text;
            break;

        case prdg_ESC_d_ignore:
            /**********************************************************/
            /* Ignoring up to a delimiter. If this is it, then stop   */
            /* ignoring.                                              */
            /**********************************************************/
            if (inch == pDCIData->ParserDelimiter)
                pDCIData->ParserState = prdg_Text;
            break;

        case prdg_ESC_read_lo_count:
            /**********************************************************/
            /* Reading first byte of count. Save it, advance state.   */
            /**********************************************************/
            pDCIData->ParserCount = (UINT)inch;
            pDCIData->ParserState = prdg_ESC_read_hi_count;
            break;

        case prdg_ESC_read_hi_count:
            /**********************************************************/
            /* Reading second byte of count. Save it, move to ignore  */
            /* a specified number of characters if there are any.     */
            /**********************************************************/
            pDCIData->ParserCount += 256*(UINT)inch;
            if (pDCIData->ParserCount)
                pDCIData->ParserState = prdg_ESC_n_ignore;
            else
                pDCIData->ParserState = prdg_Text;
            break;

    };
    /*.. switch (pDCIData->ParserState) ...............................*/

    return;
}


BOOL
CheckFormFeed(
    lpDCI pDCIData)
{
    if (pDCIData->FFstate != prdg_FFx1b6f &&
        pDCIData->FFstate != prdg_FFx1b45) {

        if (pDCIData->uType == PRINTPROCESSOR_TYPE_RAW_FF ||
            (pDCIData->uType == PRINTPROCESSOR_TYPE_RAW_FF_AUTO &&
                pDCIData->FFstate == prdg_FFtext)) {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\formfeed.c ===
#include <windows.h>
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    formfeed.c

Abstract:

    Table and routine to send formfeed to a printer.

Author:

    Dave Snipp (davesn)

Revision History:

    Tommy Evans (v-tommye) 10-15-1993 - commented code and fixed possible bug.

--*/
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

typedef struct _FormFeedChar {
    LPWSTR  pDeviceName;        /* Name of device */
    CHAR    NoChars;            /* Number of bytes in formfeed command */
    CHAR    Char1;              /* Formfeed command(n) */
    CHAR    Char2;
    CHAR    Char3;
} FORMFEEDCHAR;

/**
    This is our table of print devices and their
    associated formfeed commands.
**/

FORMFEEDCHAR
FormFeedChar[]={L"Canon Bubble-Jet BJ-10e", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-130e", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-300", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-330", 0, 0, 0, 0,
                L"Citizen PN48", 0, 0, 0, 0,
                L"Citizen GSX-130", 0, 0, 0, 0,
                L"Citizen GSX-140", 0, 0, 0, 0,
                L"Citizen GSX-140+", 0, 0, 0, 0,
                L"Citizen GSX-145", 0, 0, 0, 0,
                L"Citizen 120D", 0, 0, 0, 0,
                L"Citizen 180D", 0, 0, 0, 0,
                L"Citizen 200GX", 0, 0, 0, 0,
                L"Citizen 200GX/15", 0, 0, 0, 0,
                L"Citizen HSP-500", 0, 0, 0, 0,
                L"Citizen HSP-550", 0, 0, 0, 0,
                L"C-Itoh 8510", 0, 0, 0, 0,
                L"AT&T 470/475", 0, 0, 0, 0,
                L"Epson LQ-500", 0, 0, 0, 0,
                L"Epson LQ-510", 0, 0, 0, 0,
                L"Epson LQ-800", 0, 0, 0, 0,
                L"Epson LQ-850", 0, 0, 0, 0,
                L"Epson LQ-950", 0, 0, 0, 0,
                L"Epson LQ-1000", 0, 0, 0, 0,
                L"Epson LQ-1050", 0, 0, 0, 0,
                L"Epson LQ-1500", 0, 0, 0, 0,
                L"Epson LQ-2500", 0, 0, 0, 0,
                L"Epson LQ-2550", 0, 0, 0, 0,
                L"Epson SQ-2000", 0, 0, 0, 0,
                L"Epson SQ-2500", 0, 0, 0, 0,
                L"Epson L-750", 0, 0, 0, 0,
                L"Epson L-1000", 0, 0, 0, 0,
                L"Epson MX-80", 0, 0, 0, 0,
                L"Epson MX-80 F/T", 0, 0, 0, 0,
                L"Epson MX-100", 0, 0, 0, 0,
                L"Epson RX-80", 0, 0, 0, 0,
                L"Epson RX-80 F/T", 0, 0, 0, 0,
                L"Epson RX-100", 0, 0, 0, 0,
                L"Epson RX-80 F/T+", 0, 0, 0, 0,
                L"Epson RX-100+", 0, 0, 0, 0,
                L"Epson FX-80", 0, 0, 0, 0,
                L"Epson FX-100", 0, 0, 0, 0,
                L"Epson FX-80+", 0, 0, 0, 0,
                L"Epson FX-100+", 0, 0, 0, 0,
                L"Epson FX-85", 0, 0, 0, 0,
                L"Epson FX-185", 0, 0, 0, 0,
                L"Epson FX-286", 0, 0, 0, 0,
                L"Epson FX-86e", 0, 0, 0, 0,
                L"Epson FX-286e", 0, 0, 0, 0,
                L"Epson DFX-5000", 0, 0, 0, 0,
                L"Epson T-750", 0, 0, 0, 0,
                L"Epson FX-850", 0, 0, 0, 0,
                L"Epson FX-1050", 0, 0, 0, 0,
                L"Epson JX-80", 0, 0, 0, 0,
                L"Epson EX-800", 0, 0, 0, 0,
                L"Epson EX-1000", 0, 0, 0, 0,
                L"Epson LX-80", 0, 0, 0, 0,
                L"Epson LX-86", 0, 0, 0, 0,
                L"Epson LX-800", 0, 0, 0, 0,
                L"Epson LX-810", 0, 0, 0, 0,
                L"Epson T-1000", 0, 0, 0, 0,
                L"Diconix 150 Plus", 0, 0, 0, 0,
                L"IBM ExecJet", 0, 0, 0, 0,
                L"Fujitsu DL 2400", 0, 0, 0, 0,
                L"Fujitsu DL 2600", 0, 0, 0, 0,
                L"Fujitsu DL 3300", 0, 0, 0, 0,
                L"Fujitsu DL 3400", 0, 0, 0, 0,
                L"Fujitsu DL 5600", 0, 0, 0, 0,
                L"Fujitsu DX 2100", 0, 0, 0, 0,
                L"Fujitsu DX 2200", 0, 0, 0, 0,
                L"Fujitsu DX 2300", 0, 0, 0, 0,
                L"Fujitsu DX 2400", 0, 0, 0, 0,
                L"HP DeskJet", 0, 0, 0, 0,
                L"HP DeskJet Plus", 0, 0, 0, 0,
                L"HP DeskJet 500", 0, 0, 0, 0,
                L"HP LaserJet Series II", 2, 0x1b, 'E', 0,
                L"HP LaserJet IID", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIP", 2, 0x1b, 'E', 0,
                L"HP LaserJet 2000", 2, 0x1b, 'E', 0,
                L"HP LaserJet III", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIID", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIIP", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIISi", 2, 0x1b, 'E', 0,
                L"HP LaserJet", 2, 0x1b, 'E', 0,
                L"HP LaserJet Plus", 2, 0x1b, 'E', 0,
                L"HP LaserJet 500+", 2, 0x1b, 'E', 0,
                L"Agfa Compugraphic Genics", 2, 0x1b, 'E', 0,
                L"Apricot Laser", 2, 0x1b, 'E', 0,
                L"Epson EPL-6000", 2, 0x1b, 'E', 0,
                L"Epson EPL-7000", 2, 0x1b, 'E', 0,
                L"Epson GQ-3500", 2, 0x1b, 'E', 0,
                L"Kodak EktaPlus 7016", 2, 0x1b, 'E', 0,
                L"Kyocera F-Series (USA)", 2, 0x1b, 'E', 0,
                L"NEC Silentwriter LC 860", 2, 0x1b, 'E', 0,
                L"NEC Silentwriter LC 860 Plus", 2, 0x1b, 'E', 0,
                L"Okidata LaserLine 6", 2, 0x1b, 'E', 0,
                L"Okidata OL-400", 2, 0x1b, 'E', 0,
                L"Okidata OL-800", 2, 0x1b, 'E', 0,
                L"Olivetti PG 108", 2, 0x1b, 'E', 0,
                L"Olivetti PG 208 M2", 2, 0x1b, 'E', 0,
                L"Olivetti PG 308 HS", 2, 0x1b, 'E', 0,
                L"Olivetti ETV 5000", 2, 0x1b, 'E', 0,
                L"Panasonic KX-P4420", 2, 0x1b, 'E', 0,
                L"QuadLaser I", 2, 0x1b, 'E', 0,
                L"Tandy LP-1000", 2, 0x1b, 'E', 0,
                L"Tegra Genesis", 2, 0x1b, 'E', 0,
                L"Toshiba PageLaser12", 2, 0x1b, 'E', 0,
                L"Unisys AP9210", 2, 0x1b, 'E', 0,
                L"Wang LDP8", 2, 0x1b, 'E', 0,
                L"IBM QuickWriter 5204", 0, 0, 0, 0,
                L"NEC Pinwriter P2200", 0, 0, 0, 0,
                L"NEC Pinwriter CP6", 0, 0, 0, 0,
                L"NEC Pinwriter CP7", 0, 0, 0, 0,
                L"NEC Pinwriter P5200", 0, 0, 0, 0,
                L"NEC Pinwriter P5300", 0, 0, 0, 0,
                L"NEC Pinwriter P5XL", 0, 0, 0, 0,
                L"NEC Pinwriter P9XL", 0, 0, 0, 0,
                L"NEC Pinwriter P6", 0, 0, 0, 0,
                L"NEC Pinwriter P7", 0, 0, 0, 0,
                L"Okidata ML 380", 0, 0, 0, 0,
                L"Okidata ML 390", 0, 0, 0, 0,
                L"Okidata ML 390 Plus", 0, 0, 0, 0,
                L"Okidata ML 393 Plus", 0, 0, 0, 0,
                L"Okidata ML 391 Plus", 0, 0, 0, 0,
                L"Okidata ML 393", 0, 0, 0, 0,
                L"Okidata ML 393C Plus", 0, 0, 0, 0,
                L"Okidata ML 393C", 0, 0, 0, 0,
                L"Okidata ML 391", 0, 0, 0, 0,
                L"Okidata ML 192", 0, 0, 0, 0,
                L"Okidata ML 192 Plus", 0, 0, 0, 0,
                L"Okidata ML 193", 0, 0, 0, 0,
                L"Okidata ML 193 Plus", 0, 0, 0, 0,
                L"Okidata ML 320", 0, 0, 0, 0,
                L"Okidata ML 321", 0, 0, 0, 0,
                L"Okidata ML 321-IBM", 0, 0, 0, 0,
                L"Okidata ML 320-IBM", 0, 0, 0, 0,
                L"Okidata ML 193-IBM", 0, 0, 0, 0,
                L"Okidata ML 93-IBM", 0, 0, 0, 0,
                L"Okidata ML 192-IBM", 0, 0, 0, 0,
                L"Okidata ML 92-IBM", 0, 0, 0, 0,
                L"IBM Graphics", 0, 0, 0, 0,
                L"ATT 473/478", 0, 0, 0, 0,
                L"HP PaintJet", 0, 0, 0, 0,
                L"HP PaintJet XL", 0, 0, 0, 0,
                L"Panasonic KX-P1123", 0, 0, 0, 0,
                L"Panasonic KX-P1124", 0, 0, 0, 0,
                L"Panasonic KX-P1624", 0, 0, 0, 0,
                L"Panasonic KX-P1180", 0, 0, 0, 0,
                L"Panasonic KX-P1695", 0, 0, 0, 0,
                L"IBM Proprinter", 0, 0, 0, 0,
                L"IBM Proprinter II", 0, 0, 0, 0,
                L"IBM Proprinter XL", 0, 0, 0, 0,
                L"IBM Proprinter XL II", 0, 0, 0, 0,
                L"IBM Proprinter III", 0, 0, 0, 0,
                L"IBM Proprinter XL III", 0, 0, 0, 0,
                L"IBM Proprinter X24", 0, 0, 0, 0,
                L"IBM Proprinter XL24", 0, 0, 0, 0,
                L"IBM Proprinter X24e", 0, 0, 0, 0,
                L"IBM Proprinter XL24e", 0, 0, 0, 0,
                L"IBM PS/1", 0, 0, 0, 0,
                L"IBM QuietWriter III", 0, 0, 0, 0,
                L"HP ThinkJet (2225 C-D)", 0, 0, 0, 0,
                L"TI 850/855", 0, 0, 0, 0,
                L"Toshiba P351", 0, 0, 0, 0,
                L"Toshiba P1351", 0, 0, 0, 0,
                L"IBM LaserPrinter 4029 PS17", 1, 0x4, 0, 0,
                L"IBM LaserPrinter 4029 PS39", 1, 0x4, 0, 0,
                L"Apple LaserWriter v23.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter Plus v38.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter Plus v42.2", 1, 0x4, 0, 0,
                L"APS-PS PIP with APS-6/108", 1, 0x4, 0, 0,
                L"APS-PS PIP with LZR 1200", 1, 0x4, 0, 0,
                L"APS-PS PIP with LZR 2600", 1, 0x4, 0, 0,
                L"APS-PS PIP with APS-6/80", 1, 0x4, 0, 0,
                L"AST TurboLaser/PS v47.0", 1, 0x4, 0, 0,
                L"Agfa-Compugraphic 9400P v49.3", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark IIIR", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark IIIT", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark III", 1, 0x4, 0, 0,
                L"Dataproducts LZR-2665 v47.0", 1, 0x4, 0, 0,
                L"Digital DEClaser 1150", 1, 0x4, 0, 0,
                L"Digital DEClaser 2150", 1, 0x4, 0, 0,
                L"Digital DEClaser 2250", 1, 0x4, 0, 0,
                L"Digital DEClaser 3250", 1, 0x4, 0, 0,
                L"Digital Colormate PS", 1, 0x4, 0, 0,
                L"Digital PrintServer 20/turbo", 1, 0x4, 0, 0,
                L"Dataproducts LZR 1260 v47.0", 1, 0x4, 0, 0,
                L"EPSON EPL-7500 v52.3", 1, 0x4, 0, 0,
                L"Fujitsu RX7100PS", 1, 0x4, 0, 0,
                L"Hermes H 606 PS (13 Fonts)", 1, 0x4, 0, 0,
                L"Hermes H 606 PS (35 fonts)", 1, 0x4, 0, 0,
                L"HP LaserJet ELI PostScript v52.3", 1, 0x4, 0, 0,
                L"HP LaserJet IIISi PostScript", 1, 0x4, 0, 0,
                L"HP LaserJet IID PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet III PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIP PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIID PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIIP PostScript v52.2", 1, 0x4, 0, 0,
                L"IBM 4019 v52.1 (17 Fonts)", 1, 0x4, 0, 0,
                L"IBM 4216-020 v47.0", 1, 0x4, 0, 0,
                L"IBM 4216-030 v50.5", 1, 0x4, 0, 0,
                L"IBM 4019 v52.1 (39 Fonts)", 1, 0x4, 0, 0,
                L"Linotronic 100 v42.5", 1, 0x4, 0, 0,
                L"Linotronic 200/230", 1, 0x4, 0, 0,
                L"Linotronic 200 v47.1", 1, 0x4, 0, 0,
                L"Linotronic 200 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 300 v47.1", 1, 0x4, 0, 0,
                L"Linotronic 300 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 330", 1, 0x4, 0, 0,
                L"Linotronic 500 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 530", 1, 0x4, 0, 0,
                L"Linotronic 630", 1, 0x4, 0, 0,
                L"Apple LaserWriter II NTX v47.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter II NT v47.0", 1, 0x4, 0, 0,
                L"Monotype Imagesetter v52.2", 1, 0x4, 0, 0,
                L"Microtek TrueLaser", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 90 v52.2", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 290 v52.0", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 990 v52.3", 1, 0x4, 0, 0,
                L"NEC Silentwriter LC890XL v50.5", 1, 0x4, 0, 0,
                L"NEC Silentwriter LC890 v47.0", 1, 0x4, 0, 0,
                L"NEC Colormate PS/40 v51.9", 1, 0x4, 0, 0,
                L"NEC Colormate PS/80 v51.9", 1, 0x4, 0, 0,
                L"OceColor G5241 PS", 1, 0x4, 0, 0,
                L"OceColor G5242 PS", 1, 0x4, 0, 0,
                L"Oki OL840/PS V51.8", 1, 0x4, 0, 0,
                L"Olivetti PG 306 PS (13 Fonts)", 1, 0x4, 0, 0,
                L"Olivetti PG 306 PS (35 Fonts)", 1, 0x4, 0, 0,
                L"Panasonic KX-P4455 v51.4", 1, 0x4, 0, 0,
                L"Tektronix Phaser III PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PX", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser PX", 1, 0x4, 0, 0,
                L"QMS-PS 2200 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 2210 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 2220 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 810 Turbo v. 51.7", 1, 0x4, 0, 0,
                L"QMS-PS 820 Turbo v51.7", 1, 0x4, 0, 0,
                L"QMS-PS 820 v51.7", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 Model 10", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 Model 20/30", 1, 0x4, 0, 0,
                L"QMS-PS 810 v47.0", 1, 0x4, 0, 0,
                L"QMS-PS 800 Plus v46.1", 1, 0x4, 0, 0,
                L"QMS-PS 800 v46.1", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 v49.3", 1, 0x4, 0, 0,
                L"QMS PS Jet Plus v46.1", 1, 0x4, 0, 0,
                L"QMS PS Jet v46.1", 1, 0x4, 0, 0,
                L"Qume ScripTEN v47.0", 1, 0x4, 0, 0,
                L"Ricoh PC Laser 6000/PS v50.5", 1, 0x4, 0, 0,
                L"Schlumberger 5232 Color PostScript Printer v50.3", 1, 0x4, 0, 0,
                L"Scantext 2030/51", 1, 0x4, 0, 0,
                L"Seiko ColorPoint PS Model 04", 1, 0x4, 0, 0,
                L"Seiko ColorPoint PS Model 14", 1, 0x4, 0, 0,
                L"TI OmniLaser 2108 v45.0", 1, 0x4, 0, 0,
                L"TI Omnilaser 2115 v47.0", 1, 0x4, 0, 0,
                L"TI microLaser PS17 v.52.1", 1, 0x4, 0, 0,
                L"TI microLaser PS35 v.52.1", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser III PXi", 1, 0x4, 0, 0,
                L"Triumph Adler SDR 7706 PS13", 1, 0x4, 0, 0,
                L"Triumph Adler SDR 7706 PS35", 1, 0x4, 0, 0,
                L"Unisys AP9415 v47.0", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5330", 1, 0x4, 0, 0,
                L"Varityper 4200B-P", 1, 0x4, 0, 0,
                L"Varityper 4300P", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5300", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5500 v52.2", 1, 0x4, 0, 0,
                L"Varityper VT-600P v48.0", 1, 0x4, 0, 0,
                L"Varityper VT-600W v48.0", 1, 0x4, 0, 0,
                NULL, 0, 0, 0, 0
                };


/*++
*******************************************************************
    D o F o r m F e e d

    Routine Description:
        Sends a formfeed to the printer matching the given
        printer device name.

    Arguments:
        hPrinter    Handle to the printer to send formfeed to.
        pDeviceName Name of print device.

    Return Value:
        TRUE  if successful
        FALSE if failed
*******************************************************************
--*/
BOOL
DoFormFeed(
    IN HANDLE  hPrinter,
    IN LPWSTR  pDeviceName
)
{
    FORMFEEDCHAR *pFormFeed=FormFeedChar;
    DWORD   cbWritten;

    /** If we got a bad pointer, fail the call **/

    if (!pDeviceName) {
        return FALSE;
    }

    /** For our list of devices... **/

    while (pFormFeed->pDeviceName) {

        /** Did we find it? **/

        if (!wcscmp(pDeviceName, pFormFeed->pDeviceName)) {

            /** Yes - send formfeed to printer **/

            if (pFormFeed->NoChars)
                return WritePrinter(hPrinter, &pFormFeed->Char1,
                                    pFormFeed->NoChars, &cbWritten);
            else
                return TRUE;
        }

        /** Next device **/

        pFormFeed++;
    }

    /** Didn't find a matching device - return failed **/

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\local.c ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved

Module Name:

    local.c

// @@BEGIN_DDKSPLIT                  
Abstract:

    Implementation of debug functions

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/


#if DBG

#include "local.h"
#include <tchar.h>
#include <stdarg.h>
#include <stdio.h>



/*++

Title:

    vsntprintf

Routine Description:

    Formats a string and returns a heap allocated string with the
    formated data.  This routine can be used to for extremely
    long format strings.  Note:  If a valid pointer is returned
    the callng functions must release the data with a call to delete.
    

Arguments:

    psFmt - format string
    pArgs - pointer to a argument list.

Return Value:

    Pointer to formated string.  NULL if error.

--*/
LPSTR
vsntprintf(
    IN LPCSTR      szFmt,
    IN va_list     pArgs
    )
{
    LPSTR  pszBuff;
    UINT   uSize   = 256;

    for( ; ; )
    {
        pszBuff = AllocSplMem(sizeof(char) * uSize);

        if (!pszBuff)
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        if (_vsnprintf(pszBuff, uSize, szFmt, pArgs) >= 0)
        {
            break;
        }
        
        FreeSplMem(pszBuff);

        pszBuff = NULL;

        //
        // Double the buffer size after each failure.
        //
        uSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (uSize > 100*1024)
        {
            break;
        }
    }
    return pszBuff;
}



/*++

Title:

    DbgPrint

Routine Description:

    Format the string similar to sprintf and output it in the debugger.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    0

--*/
BOOL
DebugPrint(
    PCH pszFmt,
    ...
    )
{
    LPSTR pszString = NULL;
    BOOL  bReturn;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    pszString = vsntprintf( pszFmt, pArgs );

    bReturn = !!pszString;

    va_end( pArgs );

    if (pszString) 
    {
        OutputDebugStringA(pszString);
        
        FreeSplMem(pszString);
    }
    return bReturn;
}


// @@BEGIN_DDKSPLIT
#ifdef NEVER

VOID
vTest(
    IN LPTSTR pPrinterName,
    IN LPTSTR pDocName
    )
{
    WCHAR buf[250];
    UINT  i;

    ODS(("Printer %ws\nDocument %ws\n\n", pPrinterName, pDocName));
    ODS(("Some numbers: %u %u %u %u %u %u %u \n\n", 1, 2, 3, 4, 5, 6 ,7));
    
    for (i=0;i<250;i++) 
    {
        buf[i] = i%40 + 40 ;
    }
    ODS(("The string %ws \n\n", buf));
}

#endif //NEVER
// @@END_DDKSPLIT

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\parsparm.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\formfeed.c
// @@END_DDKSPLIT

Abstract:

    Table and routine to send formfeed to a printer.

// @@BEGIN_DDKSPLIT
Author:

    Tommy Evans (vtommye) 10-21-1993

Revision History:
// @@END_DDKSPLIT
--*/
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

/** Constants for our various states **/

#define ST_KEY      0x01        /** Looking for a key **/
#define ST_VALUE    0x02        /** Looking for a value **/
#define ST_EQUAL    0x04        /** Looking for an = sign **/
#define ST_EQNODATA 0x08        /** Looking for equal w/ no data **/
#define ST_DELIM    0x10        /** Looking for a ; **/
#define ST_DMNODATA 0x20        /** Looking for a ; w/ no data **/


/*++
*******************************************************************
    G e t K e y V a l u e

    Routine Description:
        Returns the value for a given key in the given
        parameter string.  The key/values are in the order of
        KEY = VALUE;.  The spaces are optional, the ';' is
        required and MUST be present, directly after the value.
        If the call fails, the return length will be 0 and the
        return code will give the error.  This routine is written
        as a state machine, driven by the current character. 

    Arguments:
        pParmString => Parameter string to parse
        pKeyName    => Key to search for
        ValueType   =  type of value to return, string or ULONG
        pDestLength => length of dest buffer on enter,
                       new length on exit.
        pDestBuffer => area to store the key value

    Return Value:
        0 if okay
        error if failed (from winerror.h)
*******************************************************************
--*/
USHORT
GetKeyValue(
    IN      PWCHAR  pParmString,
    IN      PWCHAR  pKeyName,
    IN      USHORT  ValueType,
    IN OUT  PUSHORT pDestLength,
    OUT     PVOID   pDestBuffer)
{
    PWCHAR  pKey, pVal, pValEnd = NULL;
    WCHAR   HoldChar;
    USHORT  State = ST_KEY;    /** Start looking for a key **/
    ULONG   length;

    /** If any of the pointers are bad, return error **/

    if ((pParmString == NULL) ||
        (pKeyName == NULL)    ||
        (pDestLength == NULL) ||
        (pDestBuffer == NULL)) {

        if (pDestLength) {
            *pDestLength = 0;
        }

        return ERROR_INVALID_PARAMETER;
    }

    /**
        If we are looking for a ULONG, make sure they passed
        in a big enough buffer.
    **/

    if (ValueType == VALUE_ULONG) {
        if (*pDestLength < sizeof(ULONG)) {
            *pDestLength = 0;
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
        
    while (pParmString && *pParmString) {

        /**
            Update our state, if necessary, depending on
            the current character.
        **/

        switch (*pParmString) {

        /**
            We got a white space.  If we were looking for an equal
            sign or delimiter, then note that we got a space.  If
            we run across more data, then we have an error.
        **/

        case (WCHAR)' ':
        case (WCHAR)'\t':

            /**
                If we were looking for an equal sign,
                check to see if this is the key they
                wanted.  If not, jump to the next key.
            **/

            if (State == ST_EQUAL) {
                if (_wcsnicmp(pKey, pKeyName, lstrlen(pKeyName))) {
                    if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                        pParmString++;
                    }
                    State = ST_KEY;
                    pValEnd = NULL;
                    break;
                }

                /** Looking for an equal sign with no more data **/

                State = ST_EQNODATA;
            }
            else if (State == ST_DELIM) {

                /** If this is the end of the value, remember it **/

                if (!pValEnd) {
                    pValEnd = pParmString;
                }

                /** Now looking for a delimiter with no more data **/

                State = ST_DMNODATA;
            }
            pParmString++;
            break;

        /**
            Found an equal sign.  If we were looking for one,
            then great - we will then be looking for a value.
            We will check to see if this is the key they wanted.
            Otherwise, this is an error and we will start over
            with the next key.
        **/

        case (WCHAR)'=':
            if (State == ST_EQUAL) {
                if (_wcsnicmp(pKey, pKeyName, lstrlen(pKeyName))) {

                    /** Error - go to next key **/

                    if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                        pParmString++;
                    }
                    State = ST_KEY;
                    pValEnd = NULL;
                    break;
                }
                pParmString++;
                State = ST_VALUE;
            }
            else {

                /** Error - go to next key **/

                if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                    pParmString++;
                }
                State = ST_KEY;
                pValEnd = NULL;
            }
            break;
        // @@BEGIN_DDKSPLIT
        /**
            Found a delimeter.  If this is what we were looking
            for, great - we have a complete key/value pair.
        **/
        // @@END_DDKSPLIT

        case (WCHAR)';':    
            if (State == ST_DELIM) {
                if (!pValEnd) {
                    pValEnd = pParmString;
                }
                if (ValueType == VALUE_ULONG) {
                    if (!iswdigit(*pVal)) {
                        if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                            pParmString++;
                        }
                        State = ST_KEY;
                        pValEnd = NULL;
                        break;
                    }
                    *(PULONG)pDestBuffer = wcstoul(pVal, NULL, 10);
                    return 0;
                }
                else if (ValueType == VALUE_STRING) {

                    /**
                        ASCIIZ the value to copy it out without
                        any trailing spaces.
                    **/

                    HoldChar = *pValEnd;
                    *pValEnd = (WCHAR)0;

                    /** Make sure the buffer is big enough **/

                    length = lstrlen(pVal);
                    if (*pDestLength < length) {
                        *pDestLength = 0;
                        return ERROR_INSUFFICIENT_BUFFER;
                    }

                    /**
                        Copy the data, restore the character where
                        we ASCIIZ'd the string, set up the length
                        and return.
                    **/

                    lstrcpy(pDestBuffer, pVal);
                    *pValEnd = HoldChar;
                    *(PULONG)pDestLength = length;
                    return 0;
                }
            }
            else {

                /** We weren't looking for a delimiter - next key **/

                State = ST_KEY;
                pValEnd = NULL;
                pParmString++;
            }
            break;

        /**
            Found some data.  If we had hit a space,
            and were expecting a equal sign or delimiter,
            this is an error.
        **/

        default:
            if ((State == ST_EQNODATA) ||
                (State == ST_DMNODATA)) {
                if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                    pParmString++;
                }
                State = ST_KEY;
                pValEnd = NULL;
                break;
            }
            else if (State == ST_KEY) {
                pKey = pParmString;
                State = ST_EQUAL;
            }
            else if (State == ST_VALUE) {
                pVal = pParmString;
                State = ST_DELIM;
            }
            pParmString++;
            break;
        } /* End switch */
    } /* While parms data */

    *pDestLength = 0;
    return ERROR_NO_DATA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\support.c ===
/*++
Copyright (c) 1990-1998  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\support.c
// @@END_DDKSPLIT

Abstract:

    Support routines for WinPrint.

// @@BEGIN_DDKSPLIT
Revision History:
// @@END_DDKSPLIT
--*/

/*++
*******************************************************************
    G e t P r i n t e r I n f o

    Routine Description:
        This routine allocates the required memory for a
        PRINTER_INFO_? structure and retrieves the information
        from NT.  This returns a pointer to the structure, which
        must be freed by the calling routine.

    Arguments:
                hPrinter    HANDLE to the printer the job is in
                StructLevel The structure level to get
                pErrorCode   => field to place error, if one

    Return Value:
                PUCHAR => buffer where devmode info is if okay
                NULL if error - pErrorCode returns error
*******************************************************************
--*/

#include "local.h"

PUCHAR 
GetPrinterInfo(IN  HANDLE   hPrinter,
               IN  ULONG    StructLevel,
               OUT PULONG   pErrorCode)
{
    ULONG   reqbytes, alloc_size;
    PUCHAR  ptr_info;
    USHORT  retry = 2;

    alloc_size = BASE_PRINTER_BUFFER_SIZE;

    /** Allocate a buffer.  **/

    ptr_info = AllocSplMem(alloc_size);

    /** If the buffer isn't big enough, try once more **/

    while (retry--) {

        /** If the alloc / realloc failed, return error **/

        if (!ptr_info) {
            *pErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            return NULL;
        }

        /** Go get the printer information **/

        if (GetPrinter(
              hPrinter,
              StructLevel,
              (PUCHAR)ptr_info,
              alloc_size,
              &reqbytes) == TRUE) {

            /** Got the info - return it **/

            *pErrorCode = 0;
            return (PUCHAR)ptr_info;
        }

        /**
            GetPrinter failed - if not because of insufficient buffer, fail
            the call.  Otherwise, up our hint, re-allocate and try again.
        **/

        *pErrorCode = GetLastError();

        if (*pErrorCode != ERROR_INSUFFICIENT_BUFFER) {
            FreeSplMem(ptr_info);
            return NULL;
        }

        /**
            Reallocate the buffer and re-try (note that, because we
            allocated the buffer as LMEM_FIXED, the LMEM_MOVABLE does
            not return a movable allocation, it just allows realloc
            to return a different pointer.
        **/

        alloc_size = reqbytes + 10;
        ptr_info = ReallocSplMem(ptr_info, alloc_size, 0);

    } /* While re-trying */

    if (ptr_info) {
        FreeSplMem(ptr_info);
    }

    *pErrorCode = ERROR_NOT_ENOUGH_MEMORY;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\raw.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT

Module Name:

    windows\spooler\prtprocs\winprint\raw.c

// @@END_DDKSPLIT
Abstract:

    Routines to facilitate printing of raw jobs.

// @@BEGIN_DDKSPLIT
Author:

    Tommy Evans (vtommye) 10-22-1993

Revision History:
// @@END_DDKSPLIT
--*/
#include "local.h"

// @@BEGIN_DDKSPLIT
#include <winsplp.h>
// @@END_DDKSPLIT
#include <wchar.h>

// @@BEGIN_DDKSPLIT
#include "msnull.h"
// @@END_DDKSPLIT

BYTE abyFF[1] = { 0xc };


/*++
*******************************************************************
    P r i n t R a w J o b

    Routine Description:
        Prints out a job with RAW data type.

    Arguments:
        pData           => Print Processor data structure
        pPrinterName    => name of printer to print on

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError will return reason
*******************************************************************
--*/

BOOL
PrintRawJob(
    IN PPRINTPROCESSORDATA pData,
    IN LPWSTR pPrinterName,
    IN UINT uDataType)

{
    DOC_INFO_1  DocInfo;
    DWORD       Copies;
    DWORD       NoRead, NoWritten;
    DWORD       i;
    BOOL        rc;
    HANDLE      hPrinter;
    BYTE        *ReadBuffer = NULL;
    BOOL        bRet        = FALSE;
    BOOL        bStartDoc   = FALSE;
    // @@BEGIN_DDKSPLIT
    BOOL        bAddFF = FALSE;
    BOOL        bCheckFF;
    PBYTE       pByte;
    DCI         DCIData;
    // @@END_DDKSPLIT

    DocInfo.pDocName    = pData->pDocument;     /* Document name */
    DocInfo.pOutputFile = pData->pOutputFile;   /* Output file */
    DocInfo.pDatatype   = pData->pDatatype;     /* Document data type */

    /** Let the printer know we are starting a new document **/

    if (!StartDocPrinter(pData->hPrinter, 1, (LPBYTE)&DocInfo)) {
        goto Done;
    }

    bStartDoc = TRUE;

    // @@BEGIN_DDKSPLIT
    bCheckFF = (uDataType == PRINTPROCESSOR_TYPE_RAW_FF ||
                uDataType == PRINTPROCESSOR_TYPE_RAW_FF_AUTO);

    /** Setup the formfeed stuff **/

    if (bCheckFF) {

        DCIData.ParserState = prdg_Text;
        DCIData.ParserSequence = NULL;
        DCIData.FFstate = prdg_FFtext;
        DCIData.uType = uDataType;
    }
    // @@END_DDKSPLIT

    /** Allocate the read buffer, dynamically allocated to conserve stack space **/

    ReadBuffer = AllocSplMem(READ_BUFFER_SIZE);

    if (!ReadBuffer) {
        goto Done;
    }

    /** Print the data pData->Copies times **/

    Copies = pData->Copies;

    while (Copies--) {

        /**
            Open the printer.  If it fails, return.  This also sets up the
            pointer for the ReadPrinter calls.
        **/

        if (!OpenPrinter(pPrinterName, &hPrinter, NULL)) {   
            goto Done;
        }

        /**
            Loop, getting data and sending it to the printer.  This also
            takes care of pausing and cancelling print jobs by checking
            the processor's status flags while printing.
        **/

        while ((rc = ReadPrinter(hPrinter, ReadBuffer, READ_BUFFER_SIZE, &NoRead)) &&
               NoRead) {

            // @@BEGIN_DDKSPLIT
            if (bCheckFF) {

                for(i=0, pByte = ReadBuffer;
                    i< NoRead;
                    i++, pByte++) {

                    CheckFormFeedStream(&DCIData, *pByte);
                }
            }
            // @@END_DDKSPLIT

            /** If the print processor is paused, wait for it to be resumed **/

            if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                WaitForSingleObject(pData->semPaused, INFINITE);
            }

            /** If the job has been aborted, don't write anymore **/

            if (pData->fsStatus & PRINTPROCESSOR_ABORTED) {
                break;
            }

            /** Write the data to the printer **/

            WritePrinter(pData->hPrinter, ReadBuffer, NoRead, &NoWritten);
        }

        // @@BEGIN_DDKSPLIT
        /**
            If we are type _FF* then we may need to add a form feed.
        **/

        if (bCheckFF && CheckFormFeed(&DCIData)) {

            WritePrinter(pData->hPrinter, abyFF, sizeof(abyFF), &NoWritten);
        }
        // @@END_DDKSPLIT

        /**
            Close the printer - we open/close the printer for each
            copy so the data pointer will rewind.
        **/

        ClosePrinter(hPrinter);

    } /* While copies to print */

    bRet = TRUE;

Done:    
    
    /** Close the buffer we allocated **/

    if (ReadBuffer) {
        FreeSplMem(ReadBuffer);
    }
    
    /** Let the printer know that we are done printing **/

    if (bStartDoc) {
        EndDocPrinter(pData->hPrinter);
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\util.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

   util.c
// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

    NOTE: THIS IS FOR THE DDK ONLY! 

Revision History:
// @@END_DDKSPLIT

--*/

#include "local.h"

LPVOID
ReallocSplMem(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}


LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}



LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbginit.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbginit.c

Abstract:

    This module initialization

Author:

    Dave Snipp (DaveSn) 15-Mar-1991
    Steve Kiraly (SteveKi) 28-Nov-2000

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

HANDLE hInst;

BOOL
DllMain(
    IN HANDLE  hModule,
    IN DWORD   dwReason,
    IN LPVOID  lpRes
    )
{
    BOOL bRetval = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        hInst = hModule;
        DisableThreadLibraryCalls(hInst);
        QuerySystemInformation();
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\text.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\text.c

// @@END_DDKSPLIT
Abstract:

    Routines to facilitate printing of text jobs.

--*/

#include "local.h"

#define FLAG_CR_STATE         0x1
#define FLAG_TAB_STATE        0x2
#define FLAG_DBCS_SPLIT       0x8
#define FLAG_FF               0x10
#define FLAG_LF               0x20
#define FLAG_CR               0x40
#define FLAG_TRANSLATE_LF     0x80
#define FLAG_TRANSLATE_CR     0x100

const WCHAR gszNoTranslateCRLF[] = L"Winprint_TextNoTranslation";
const WCHAR gszNoTranslateCR[]   = L"Winprint_TextNoCRTranslation";
const WCHAR gszTransparency[]    = L"Transparency";

/** Prototypes for functions in this file **/

PBYTE
GetTabbedLineFromBuffer(
    IN      PBYTE   pSrcBuffer,
    IN      PBYTE   pSrcBufferEnd,
    IN      PBYTE   pDestBuffer,
    IN      ULONG   CharsPerLine,
    IN      ULONG   TabExpansionSize,
    IN      ULONG   Encoding,
    IN OUT  PULONG  pLength,
    IN OUT  PULONG  pTabBase,
    IN OUT  PDWORD  pfdwFlags
    );


/*++
*******************************************************************
    P r i n t T e x t J o b

    Routine Description:
        Prints a text data job.

    Arguments:
        pData           => Data structure for this job
        pDocumentName   => Name of this document

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError() will return reason.
*******************************************************************
--*/
BOOL
PrintTextJob(
    IN PPRINTPROCESSORDATA pData,
    IN LPWSTR pDocumentName)
{
    DOCINFO     DocInfo;
    LOGFONT     LogFont;
    CHARSETINFO CharSetInfo;
    HFONT       hOldFont, hFont;
    DWORD       Copies;
    BOOL        rc;
    DWORD       NoRead;
    DWORD       CurrentLine;
    DWORD       CurrentCol;
    HANDLE      hPrinter = NULL;
    BYTE        *ReadBufferStart = NULL;
    PBYTE       pLineBuffer = NULL;
    PBYTE       pReadBuffer = NULL;
    PBYTE       pReadBufferEnd = NULL;
    ULONG       CharHeight, CharWidth, CharsPerLine, LinesPerPage;
    ULONG       PageWidth, PageHeight;
    ULONG       Length, TabBase;
    BOOL        ReadAll;
    TEXTMETRIC  tm;
    DWORD       fdwFlags;
    DWORD       Encoding;
    DWORD       SplitSize;
    BOOL        ReturnValue = FALSE;
    BOOL        bAbortDoc   = FALSE;

    DWORD       dwNeeded;
    DWORD       dwNoTranslate = 0;
    DWORD       dwNoTranslateCR = 0;
    DWORD       dwTransparent = 0;
    INT         iBkMode;

    DocInfo.lpszDocName = pData->pDocument;  /* Document name */
    DocInfo.lpszOutput  = NULL;              /* Output file */
    DocInfo.lpszDatatype = NULL;             /* Datatype */
    DocInfo.cbSize = sizeof(DOCINFO);        /* Size of the structure */



    //
    // Go figure out the size of the form on the printer.  We do this
    // by calling GetTextMetrics, which gives us the font size of the
    // printer font, then getting the form size and calculating the
    // number of characters that will fit. In other cases we treat it as ANSI text.
    // Currently the codepage context is fixed to the system default codepage.
    //

    Encoding = GetACP();

    //
    // Create FIXED PITCH font and select
    //

    hOldFont = 0;
    ZeroMemory(&CharSetInfo, sizeof(CHARSETINFO));
    if (TranslateCharsetInfo((PDWORD)UIntToPtr(Encoding), &CharSetInfo, TCI_SRCCODEPAGE))
    {
        ZeroMemory(&LogFont, sizeof(LOGFONT));

        LogFont.lfWeight = 400;
        LogFont.lfCharSet = (BYTE)CharSetInfo.ciCharset;
        LogFont.lfPitchAndFamily = FIXED_PITCH;

        hFont = CreateFontIndirect(&LogFont);
        hOldFont = SelectObject(pData->hDC, hFont);
    }

    if (!GetTextMetrics(pData->hDC, &tm)) {
        // Essential text processing computation failed
        goto Done;
    }

    CharHeight = tm.tmHeight + tm.tmExternalLeading;
    CharWidth  = tm.tmAveCharWidth;

    if (!CharWidth || !CharHeight) {
        // Essential text processing computation failed
        goto Done;
    }

    //
    // Calculate most fittable characters' number to one line.
    //

    PageWidth = GetDeviceCaps(pData->hDC, DESKTOPHORZRES);
    PageHeight = GetDeviceCaps(pData->hDC, DESKTOPVERTRES);

    CharsPerLine = PageWidth / CharWidth;
    LinesPerPage = PageHeight / CharHeight;

    if (!CharsPerLine || !LinesPerPage) {
        // Essential text processing computation failed
        goto Done;
    }

    /** Allocate a buffer for one line of text **/

    pLineBuffer = AllocSplMem(CharsPerLine + 5);

    if (!pLineBuffer) {
        goto Done;
    }

    /** Let the printer know we are starting a new document **/

    if (!StartDoc(pData->hDC, (LPDOCINFO)&DocInfo)) {

        goto Done;
    }

    ReadBufferStart = AllocSplMem(READ_BUFFER_SIZE);

    if (!ReadBufferStart) {

        goto Done;
    }

    /** Print the data pData->Copies times **/

    Copies = pData->Copies;

    while (Copies--) {

        /**
            Loop, getting data and sending it to the printer.  This also
            takes care of pausing and cancelling print jobs by checking
            the processor's status flags while printing.  The way we do
            this is to read in some data from the printer.  We will then
            pull data, one tabbed line at a time from there and print
            it.  If the last bit of data in the buffer does not make up
            a whole line, we call GetTabbedLineFromBuffer() with a non-
            zero Length, which indicates that there are chars left
            from the previous read.
        **/

        TabBase = 0;
        Length = 0;
        fdwFlags = FLAG_TRANSLATE_CR | FLAG_TRANSLATE_LF;

        CurrentLine = 0;
        CurrentCol = 0;

        /**
            Open the printer.  If it fails, return.  This also sets up the
            pointer for the ReadPrinter calls.
        **/

        if (!OpenPrinter(pDocumentName, &hPrinter, NULL)) {

            hPrinter = NULL;
            bAbortDoc = TRUE;
            goto Done;
        }

        //
        // Call GetPrinterData to see if the queue wants no LF/CR processing.
        //
        if( GetPrinterData( hPrinter,
                            (LPWSTR)gszNoTranslateCRLF,
                            NULL,
                            (PBYTE)&dwNoTranslate,
                            sizeof( dwNoTranslate ),
                            &dwNeeded ) == ERROR_SUCCESS ){

            if( dwNoTranslate ){
                fdwFlags &= ~( FLAG_TRANSLATE_CR | FLAG_TRANSLATE_LF );
            }
        }

        //
        // Call GetPrinterData to see if the queue wants no CR processing.
        //
        if( GetPrinterData( hPrinter,
                            (LPWSTR)gszNoTranslateCR,
                            NULL,
                            (PBYTE)&dwNoTranslateCR,
                            sizeof( dwNoTranslateCR ),
                            &dwNeeded ) == ERROR_SUCCESS ){

            if( dwNoTranslateCR ){

                fdwFlags &= ~FLAG_TRANSLATE_CR;

                if( GetPrinterData( hPrinter,
                                (LPWSTR)gszTransparency,
                                NULL,
                                (PBYTE)&dwTransparent,
                                sizeof( dwTransparent ),
                                &dwNeeded ) == ERROR_SUCCESS ){

                    if( dwTransparent ){
                        iBkMode = SetBkMode( pData->hDC, TRANSPARENT );
                    }
                }
            }
        }

        if (StartPage(pData->hDC) == SP_ERROR) {

            bAbortDoc = TRUE;
            goto Done;
        }

        /** ReadAll indicates if we are on the last line of the file **/

        ReadAll = FALSE;

        /**
            This next do loop continues until we have read all of the
            data for the print job.
        **/

        do {

            if (fdwFlags & FLAG_DBCS_SPLIT) {
                SplitSize = (DWORD)(pReadBufferEnd - pReadBuffer);
                memcpy(ReadBufferStart, pReadBuffer, SplitSize);
                fdwFlags &= ~FLAG_DBCS_SPLIT;
            }
            else {
                SplitSize = 0;
            }

            rc = ReadPrinter(hPrinter,
                             (ReadBufferStart + SplitSize),
                             (READ_BUFFER_SIZE - SplitSize),
                             &NoRead);

            if (!rc || !NoRead) {

                ReadAll = TRUE;

            } else {

                /** Pick up a pointer to the end of the data **/

                pReadBuffer    = ReadBufferStart;
                pReadBufferEnd = ReadBufferStart + SplitSize + NoRead;
            }

            /**
                This loop will process all the data that we have
                just read from the printer.
            **/

            do {

                if (!ReadAll) {

                    /**
                        Length on entry holds the length of any
                        residual chars from the last line that we couldn't
                        print out because we ran out of characters on
                        the ReadPrinter buffer.
                    **/

                    pReadBuffer = GetTabbedLineFromBuffer(
                                      pReadBuffer,
                                      pReadBufferEnd,
                                      pLineBuffer,
                                      CharsPerLine - CurrentCol,
                                      pData->TabSize,
                                      Encoding,
                                      &Length,
                                      &TabBase,
                                      &fdwFlags );

                    /**

                        If pReadBuffer == NULL, then we have
                        exhausted the read buffer and we need to ReadPrinter
                        again and save the last line chars.  Length holds
                        the number of characters on this partial line,
                        so the next time we call ReadPrinter we will
                        pickup where we left off.

                        The only time we'll get residual chars is if:

                        1. The last line ends w/o ff/lf/cr ("Hello\EOF")
                           In this case we should TextOutA the last line
                           and then quit.

                           (In this case, don't break here; go ahead and
                           print, then we'll break out below in the do..while.)


                        2. The ReadPrinter last byte is in the middle of a line.
                           Here we should read the next chunk and add the
                           new characters at the end of the chars we just read.

                           (In this case, we should break and leave Length
                           as it is so we will read again and append to the
                           buffer, beginning at Length.)
                    **/

                    if (!pReadBuffer || (fdwFlags & FLAG_DBCS_SPLIT))
                        break;
                }


                /** If the print processor is paused, wait for it to be resumed **/

                if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                    WaitForSingleObject(pData->semPaused, INFINITE);
                }

                /** If the job has been aborted, clean up and leave **/

                if (pData->fsStatus & PRINTPROCESSOR_ABORTED) {

                    ReturnValue = TRUE;

                    bAbortDoc = TRUE;
                    goto Done;
                }

                /** Write the data to the printer **/

                /** Make sure Length is not zero  **/
                /** TextOut will fail if Length == 0 **/

                if (Length) {

                    /**
                        We may have a number of newlines pending, that
                        may push us to the next page (or even next-next
                        page).
                    **/

                    while (CurrentLine >= LinesPerPage) {

                        /**
                            We need a new page; always defer this to the
                            last second to prevent extra pages from coming out.
                        **/

                        if (EndPage(pData->hDC) == SP_ERROR ||
                            StartPage(pData->hDC) == SP_ERROR) {

                            bAbortDoc = TRUE;
                            goto Done;
                        }

                        CurrentLine -= LinesPerPage;
                    }

                    if (TextOutA(pData->hDC,
                                 CurrentCol * CharWidth,
                                 CurrentLine * CharHeight,
                                 pLineBuffer,
                                 Length) == FALSE) {

                        ODS(("TextOut() failed\n"));

                        bAbortDoc = TRUE;
                        goto Done;
                    }

                    CurrentCol += Length;
                }

                /**
                    Even if the length is zero, increment the line.
                    Should happen when the character is only 0x0D or 0x0A.
                **/

                if (fdwFlags & FLAG_CR) {
                    CurrentCol=0;
                    fdwFlags &= ~FLAG_CR;
                }

                if (fdwFlags & FLAG_LF) {
                    CurrentLine++;
                    fdwFlags &= ~FLAG_LF;
                }

                /**
                    We need a new page.  Set the current line to the
                    end of the page.  We could do a End/StartPage
                    sequence, but this may cause a blank page to get
                    ejected.

                    Note: this code will avoid printing out pages that
                    consist of formfeeds only (if you have a page with a
                    space in it, that counts as text).
                **/

                if (fdwFlags & FLAG_FF) {

                    CurrentLine = LinesPerPage;
                    CurrentCol = 0;
                    fdwFlags &= ~FLAG_FF;
                }

                /**
                    We have done the text out, so these characters have
                    been successfully printed.  Zero out Length
                    so these characters won't be printed again
                **/

                Length = 0;

                /**
                    We only terminate this loop if we run out of chars
                    or we run out of read buffer.
                **/

            } while (pReadBuffer && pReadBuffer != pReadBufferEnd);

            /** Keep going until we get the last line **/

        } while (!ReadAll);

        if (EndPage(pData->hDC) == SP_ERROR) {

            bAbortDoc = TRUE;
            goto Done;
        }

        /**
            Close the printer - we open/close the printer for each
            copy so the data pointer will rewind.
        **/

        ClosePrinter(hPrinter);
        hPrinter = NULL;

    } /* While copies to print */

    /** Let the printer know that we are done printing **/

    EndDoc(pData->hDC);

    ReturnValue = TRUE;

Done:

    if (dwTransparent)
        SetBkMode( pData->hDC, iBkMode  );

    if (hPrinter)
        ClosePrinter(hPrinter);

    if (bAbortDoc)
        AbortDoc(pData->hDC);

    if (pLineBuffer)
        FreeSplMem(pLineBuffer);

    if (hOldFont)
    {
        SelectObject(pData->hDC, hOldFont);
        DeleteObject(hFont);
    }

    if (ReadBufferStart) 
    {
        FreeSplMem(ReadBufferStart);
    }

    return ReturnValue;
}


/*++
*******************************************************************
    G e t T a b b e d L i n e F r o m B u f f e r

    Routine Description:
        This routine, given a buffer of text, will pull out a
        line of tab-expanded text.  This is used for tab
        expansion of text data jobs.

    Arguments:
        pSrcBuffer      => Start of source buffer.
        pSrcBufferEnd   => End of source buffer
        pDestBuffer     => Start of destination buffer
        CharsPerLine    => Number of characters on a line
        TabExpansionSize=> Number of spaces in a tab
        Encoding        => Code page
        pLength         => Length of chars from prev line, rets current
        pTabBase        => New 0 offset for tabbing
        pfdwFlags       => State

    Return Value:
        PBYTE => Place left off in the source buffer.  This should
                 be passed in on the next call.  If we ran out of
                 data in the source, this will be unchanged.
*******************************************************************
--*/

PBYTE
GetTabbedLineFromBuffer(
    IN      PBYTE   pSrcBuffer,
    IN      PBYTE   pSrcBufferEnd,
    IN      PBYTE   pDestBuffer,
    IN      ULONG   CharsPerLine,
    IN      ULONG   TabExpansionSize,
    IN      ULONG   Encoding,
    IN OUT  PULONG  pLength,
    IN OUT  PULONG  pTabBase,
    IN OUT  PDWORD  pfdwFlags
    )
{
    ULONG   current_pos;
    ULONG   expand, i;
    ULONG   TabBase = *pTabBase;
    ULONG   TabBaseLeft = TabExpansionSize-TabBase;
    PBYTE   pDestBufferEnd = pDestBuffer + CharsPerLine;

    /**
        If the tab pushed us past the end of the last line, then we need to
        add it back to the next one.
    **/

    if (TabBase && ( *pfdwFlags & FLAG_TAB_STATE )) {

        current_pos = 0;

        i=TabBase;

        while (i-- && (pDestBuffer < pDestBufferEnd)) {
            *pDestBuffer++ = ' ';
            current_pos++;
        }

        /**
            If we ran out of room again, return.  This means that
            the tab expansion size is greater than we can fit on
            one line.
        **/

        if (pDestBuffer >= pDestBufferEnd) {

            *pLength = current_pos;
            pTabBase -= CharsPerLine;

            //
            // We need to move to the next line.
            //
            *pfdwFlags |= FLAG_LF | FLAG_CR;

            return pSrcBuffer;
        }
        *pfdwFlags &= ~FLAG_TAB_STATE;

    } else {

        /** We may have some chars from the previous ReadPrinter **/

        current_pos = *pLength;
        pDestBuffer += current_pos;
    }

    while (pSrcBuffer < pSrcBufferEnd) {

        /** Now process other chars **/

        switch (*pSrcBuffer) {

        case 0x0C:

            /** Found a FF.  Quit and indicate we need to start a new page **/

            *pTabBase = 0;
            *pfdwFlags |= FLAG_FF;
            *pfdwFlags &= ~FLAG_CR_STATE;

            pSrcBuffer++;

            break;

        case '\t':

            *pfdwFlags &= ~FLAG_CR_STATE;

            /**
                Handle TAB case.  If we are really out of buffer,
                then defer now so that the tab will be saved for
                the next line.
            **/

            if (pDestBuffer >= pDestBufferEnd) {
                goto ShiftTab;
            }

            pSrcBuffer++;

            /** Figure out how far to expand the tabs **/

            expand = TabExpansionSize -
                     (current_pos + TabBaseLeft) % TabExpansionSize;

            /** Expand the tabs **/

            for (i = 0; (i < expand) && (pDestBuffer < pDestBufferEnd); i++) {
                *pDestBuffer++ = ' ';
            }

            /**
                If we reached the end of our dest buffer,
                return and set the number of spaces we have left.
            **/

            if (pDestBuffer >= pDestBufferEnd) {

                *pfdwFlags |= FLAG_TAB_STATE;
                goto ShiftTab;
            }

            /** Update our position counter **/

            current_pos += expand;

            continue;

        case 0x0A:

            pSrcBuffer++;

            /** If the last char was a CR, ignore this guy **/

            if (*pfdwFlags & FLAG_CR_STATE) {

                *pfdwFlags &= ~FLAG_CR_STATE;

                //
                // We are translating CRLF, so if we saw a CR
                // immediately before this, then don't do anything.
                //
                continue;
            }

            if( *pfdwFlags & FLAG_TRANSLATE_LF ){

                //
                // If we are translating, then treat a LF as a CRLF pair.
                //
                *pfdwFlags |= FLAG_LF | FLAG_CR;

                /** Found a linefeed.  That's it for this line. **/

                *pTabBase = 0;

            } else {

                *pfdwFlags |= FLAG_LF;
            }

            break;

        case 0x0D:

            /** Found a carriage return.  That's it for this line. **/

            *pTabBase = 0;
            pSrcBuffer++;

            if (*pfdwFlags & FLAG_TRANSLATE_CR) {

                //
                // If we are translating CRLF, then make the newline
                // occur now.  This handles the case where we have a
                // CR all by itself.  Also set the CR flag so if there
                // happens to be a LF immediately after this, we don't
                // move down another line.
                //
                *pfdwFlags |= FLAG_CR_STATE | FLAG_LF | FLAG_CR;

            } else {

                *pfdwFlags |= FLAG_CR;
            }

            break;

        default:

            /** Not tab or carriage return, must be simply data **/

            *pfdwFlags &= ~FLAG_CR_STATE;

            //
            // We always check before we are adding a character
            // (instead of after) since we may be at the end of a line,
            // but we can still process chars like 0x0d 0x0a.
            // This happens in MS-DOS printscreen.
            //
            if (pDestBuffer >= pDestBufferEnd ||
                    (pDestBuffer + 1 >= pDestBufferEnd) &&
                    IsDBCSLeadByteEx(Encoding, *pSrcBuffer)) {

ShiftTab:
                //
                // We must shift the tab over since we are on the
                // same line.
                //
                *pTabBase = (*pTabBase + TabExpansionSize -
                            (CharsPerLine % TabExpansionSize))
                                % TabExpansionSize;

                *pfdwFlags |= FLAG_LF | FLAG_CR;

                break;
            }

            if (IsDBCSLeadByteEx(Encoding, *pSrcBuffer)) {

                // Check if we have trail byte also.

                if (pSrcBuffer + 1 >= pSrcBufferEnd) {
                    *pfdwFlags |= FLAG_DBCS_SPLIT;
                    break;
                }

                // Advance source pointer (for lead byte).

                *pDestBuffer++ = *pSrcBuffer++;
                current_pos++;
            }

            *pDestBuffer++ = *pSrcBuffer++;
            current_pos++;
            continue;
        }

        *pLength = current_pos;
        return pSrcBuffer;
    }

    /** We ran out of source buffer before getting to the EOL **/

    *pLength = current_pos;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbglocal.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbglocal.h

Abstract:

    Header file for Spooler Subsystem Debugger Extensions

Author:

    Krishna Ganugapati (KrishnaG) 08-July-1992

Revision History:

--*/


// Macro Land
// Note: if you use any of these macros within your code, you must have the
// following variables present and set to the appropriate value
//
// HANDLE               hCurrentProcess
// PNTSD_GET_EXPRESSION EvalExpression
//
//

#define move(dst, src)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, &dst, sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movestruct(src, dst, type)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sizeof(type), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movemem(src, dst, sz)\
try {\
    if (!ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sz, NULL)) { \
        ((PBYTE)(dst))[0] = 0; \
    } \
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movestr(src, dst, sz)\
try {\
    if (!ReadProcessString(hCurrentProcess, (LPVOID)src, dst, sz, NULL)) { \
        ((PBYTE)(dst))[0] = 0; \
    } \
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define GetAddress(dst, src)\
try {\
    dst = EvalExpression(src);\
} except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src);\
    return(0);\
}

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

#if DBG

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);

#else

#define SplInSem()
#define SplOutSem()

#endif

BOOL
DbgDumpIniPrintProc(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTPROC pIniPrintProc
);


BOOL
DbgDumpIniDriver(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIDRIVER  pIniDriver
);


BOOL
DbgDumpIniEnvironment(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIENVIRONMENT pIniEnvironment
);


BOOL
DbgDumpIniNetPrint(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PININETPRINT pIniNetPrint
);

BOOL
DbgDumpIniMonitor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIMONITOR pIniMonitor
);


BOOL
DbgDumpIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPORT pIniPort
);

BOOL
DbgDumpWIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWINIPORT pIniPort
);


BOOL
DbgDumpIniPrinter(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTER pIniPrinter
);

BOOL
DbgDumpIniForm(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIFORM pForm
);


BOOL
DbgDumpIniJob(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIJOB pIniJob
);

BOOL
DbgDumpProvidor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    LPPROVIDOR pProvidor
);

BOOL
DbgDumpSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSPOOL pSpool
);

BOOL
DbgDumpShadowFile(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE pShadowFile
);

BOOL
DbgDumpShadowFile2(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE_2 pShadowFile
);

VOID
WINAPIV
PrintData(
    PNTSD_OUTPUT_ROUTINE Print,
    LPSTR   TypeString,
    LPSTR   VarString,
    ...
);

BOOL
DbgDumpChange(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGE pChange
    );

BOOL
DumpDevMode(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress
    );

BOOL
DbgDumpSecurityDescriptor(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PISECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
DbgDumpSid(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID  SidAddress
    );

BOOL
DbgDumpAcl(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID  AclAddress
    );

VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String
    );

DWORD
EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print
    );

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
    );

BOOL
DbgDumpPrintHandle(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PPRINTHANDLE pPrintHandle
    );

BOOL
DbgDumpChange(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGE pChange
    );


BOOL
DbgDumpNotify(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PNOTIFY pNotify
    );


BOOL
DbgDumpChangeInfo(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGEINFO pChangeInfo
    );

BOOL
DbgDumpStructure(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pData
    );

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
    );

BOOL
DbgDumpLL(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pAddress,
    BOOL  bCountOn,
    DWORD dwCount,
    PVOID pNextAddress
    );

BOOL
DbgDumpPI2(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD   dwCount
    );

BOOL
DbgDumpPI0(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD dwCount
    );

BOOL
DbgDumpFI1(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD dwCount
    );

BOOL
DbgDumpPDEF(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD   dwCount
    );

BOOL
ReadProcessString(
    IN  HANDLE  hProcess,
    IN  LPCVOID lpBaseAddress,
    OUT LPVOID  lpBuffer,
    IN  SIZE_T  nSize,
    OUT SIZE_T  *lpNumberOfBytesRead
    );

BOOL
QuerySystemInformation(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\winprint.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\winprint.c

// @@END_DDKSPLIT
Abstract:

    Win32 print processor support functions.


--*/

#include "local.h"

#include <excpt.h>
#include <string.h>

// @@BEGIN_DDKSPLIT
/**
    Used for enumerating, checking supported data types

    !! Warning !! Must match PRINTPROCESSOR_TYPE_* defined in winprint.h

    If the EMF version is rev-ed, corresponding changes need to be made in
      spoolss\client\winspool.c (GetPrinterDataW)
      localspl\port.c (PortThread)
      localspl\schedule.c (CheckMemoryAvailable)
      ntgdi\client\output.c (StartDocW)

    !! HACK !!

    NT EMF 1.003 isn't really supported.  Localspl is hardcoded to reject this
    call, but we keep it so that HP LJ 1100 monolithic driver can still install.
    (During install, they set the DRIVER_INFO_3 datatype to 1.003, and this
    fails if it isn't supported by somebody.)

    In localspl's LocalStartDocPrinter call, we actually reject this datatype.
**/
// @@END_DDKSPLIT

LPWSTR  Datatypes[]={
    L"RAW",
// @@BEGIN_DDKSPLIT
    L"RAW [FF appended]",
    L"RAW [FF auto]",
    L"NT EMF 1.003",
// @@END_DDKSPLIT
    L"NT EMF 1.006",
    L"NT EMF 1.007",
    L"NT EMF 1.008",
    L"TEXT",
    0};

/** Misc. constants **/

#define BASE_TAB_SIZE 8

/**
 *  For localization:
**/

PWCHAR pTabsKey     = L"TABS";
PWCHAR pCopiesKey   = L"COPIES";


/**
    Prototypes
**/

/** Functions found in parsparm.c **/

extern USHORT GetKeyValue(
    IN      PWCHAR,
    IN      PWCHAR,
    IN      USHORT,
    IN OUT  PUSHORT,
    OUT     PVOID);

/** Functions found in raw.c **/

extern BOOL PrintRawJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR,
    IN UINT);

/** Functions found in text.c **/

extern BOOL PrintTextJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR);

/** Functions found in emf.c */

extern BOOL PrintEMFJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR);

/** Functions found in support.c **/

extern PUCHAR GetPrinterInfo(
    IN  HANDLE hPrinter,
    IN  ULONG,
    OUT PULONG);

/*++
*******************************************************************
    E n u m P r i n t P r o c e s s o r D a t a t y p e s W

    Routine Description:
        Enumerates the data types supported by the print processor.

    Arguments:
        pName               => server name
        pPrintProcessorName => print processor name
        Level               => level of data to return (must be 1)
        pDatatypes          => structure array to fill in
        cbBuf               => length of structure array in bytes
        pcbNeeded           => buffer length copied/required
        pcReturned          => number of structures returned

    Return Value:
        TRUE  if successful
        FALSE if failed - caller must use GetLastError for reason
*******************************************************************
--*/
BOOL
EnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DATATYPES_INFO_1    *pInfo1 = (DATATYPES_INFO_1 *)pDatatypes;
    LPWSTR              *pMyDatatypes = Datatypes;
    DWORD               cbTotal=0;
    LPBYTE              pEnd;

    /** Start assuming failure, no entries returned **/

    *pcReturned = 0;

    /** Pick up pointer to end of the given buffer **/

    pEnd = (LPBYTE)pInfo1 + cbBuf;

    /** Add up the minimum buffer required **/

    while (*pMyDatatypes) {

        cbTotal += wcslen(*pMyDatatypes) * sizeof(WCHAR) + sizeof(WCHAR) +
                   sizeof(DATATYPES_INFO_1);

        pMyDatatypes++;
    }

    /** Set the buffer length returned/required **/

    *pcbNeeded = cbTotal;

    /** Fill in the array only if there is sufficient space **/

    if (cbTotal <= cbBuf) {

        /** Pick up our list of supported data types **/

        pMyDatatypes = Datatypes;

        /**
            Fill in the given buffer.  We put the data names at the end of
            the buffer, working towards the front.  The structures are put
            at the front, working towards the end.
        **/

        while (*pMyDatatypes) {

            pEnd -= wcslen(*pMyDatatypes)*sizeof(WCHAR) + sizeof(WCHAR);
            wcscpy((LPWSTR)pEnd, *pMyDatatypes);
            pInfo1->pName = (LPWSTR)pEnd;
            pInfo1++;
            (*pcReturned)++;

            pMyDatatypes++;
        }

    } else {

        /** Caller didn't have large enough buffer, set error and return **/

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    /** Return success **/

    return TRUE;
}


/*++
*******************************************************************
    O p e n P r i n t P r o c e s s o r

    Routine Description:

    Arguments:
        pPrinterName            => name of printer we are
                                    opening for
        pPrintProcessorOpenData => information used for opening
                                    the print processor

    Return Value:
        PPRINTPROCESSORDATA => processor data of opened
                                processor if successful
        NULL if failed - caller uses GetLastError for reason

    NOTE: OpenPrinter will be called iff this returns a valid handle
          (and we're not journal)
@@BEGIN_DDKSPLIT
          ClosePrintProcessor MUST be called if we succeed here,
          (or else things don't get cleaned up--like pIniJob->cRef
          for RAW jobs, which causes the queue to stick!)
@@END_DDKSPLIT          

*******************************************************************
--*/
HANDLE
OpenPrintProcessor(
    LPWSTR   pPrinterName,
    PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
)
{
    PPRINTPROCESSORDATA pData;
    LPWSTR              *pMyDatatypes=Datatypes;
    DWORD               uDatatype=0;
    HANDLE              hPrinter=0;
    HDC                 hDC = 0;
    PDEVMODEW           pDevmode = NULL;


    /** If the caller passed a NULL for the open data, fail the call **/

    if (!pPrintProcessorOpenData ||
        !pPrintProcessorOpenData->pDatatype ||
        !*pPrintProcessorOpenData->pDatatype) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    /** Search for the data type index we are opening for **/

    while (*pMyDatatypes) {

        if (!_wcsicmp(*pMyDatatypes,pPrintProcessorOpenData->pDatatype)) {
            break;
        }
        pMyDatatypes++;
        uDatatype++;
    }

    /** Allocate a buffer for the print processor data to return **/

    pData = (PPRINTPROCESSORDATA)AllocSplMem(sizeof(PRINTPROCESSORDATA));

    if (!pData) {
        ODS(("Alloc failed in OpenPrintProcessor, while printing on %ws\n", pPrinterName));
        return NULL;
    }

    /** Open the processor accordingly **/

    switch (uDatatype) {

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
        if (!OpenPrinter(pPrinterName, &hPrinter, NULL))
            goto Fail;
        break;

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:

        if(pPrintProcessorOpenData->pDevMode)
        {
            if(!(pDevmode=AllocSplMem(pPrintProcessorOpenData->pDevMode->dmSize+
                                      pPrintProcessorOpenData->pDevMode->dmDriverExtra)))
            {
                goto Fail;
            }
            memcpy(pDevmode,
                   pPrintProcessorOpenData->pDevMode,
                   pPrintProcessorOpenData->pDevMode->dmSize+
                   pPrintProcessorOpenData->pDevMode->dmDriverExtra);
        }
        break;

    case PRINTPROCESSOR_TYPE_TEXT:
        if (!(hDC = CreateDC(L"", pPrinterName, L"",
                             pPrintProcessorOpenData->pDevMode)))
            goto Fail;
        break;

    default:
        SetLastError(ERROR_INVALID_DATATYPE);
        goto Fail;
    }

    /** Fill in the print processors information **/

    pData->cb          = sizeof(PRINTPROCESSORDATA);
    pData->signature   = PRINTPROCESSORDATA_SIGNATURE;
    pData->JobId       = pPrintProcessorOpenData->JobId;
    pData->hPrinter    = hPrinter;
    pData->semPaused   = CreateEvent(NULL, TRUE, TRUE,NULL);
    pData->uDatatype   = uDatatype;
    pData->hDC         = hDC;
    pData->Copies      = 1;
    pData->TabSize     = BASE_TAB_SIZE;

    /** Allocate and fill in the processors strings **/

    pData->pPrinterName = AllocSplStr(pPrinterName);
    pData->pDatatype    = AllocSplStr(pPrintProcessorOpenData->pDatatype);
    pData->pDocument    = AllocSplStr(pPrintProcessorOpenData->pDocumentName);
    pData->pOutputFile  = AllocSplStr(pPrintProcessorOpenData->pOutputFile);
    pData->pParameters  = AllocSplStr(pPrintProcessorOpenData->pParameters);
    pData->pDevmode     = pDevmode;
    pData->pPrinterNameFromOpenData = AllocSplStr(pPrintProcessorOpenData->pPrinterName);

    // @@BEGIN_DDKSPLIT
    /**
        WORKWORK : Currently, the pParameters field has
        the name of the printer driver.  This will be fixed, and
        should come up here the same as the user submitted in the
        job's Printer Info structure.
    **/
    // @@END_DDKSPLIT

    /** Parse the parameters string **/
    if (pData->pParameters) {
        ULONG   value;
        USHORT  length = sizeof(ULONG);

        /**
            Look to see if there is a COPIES=n key/value in the
            Parameters field of this job.  This tells us the number
            of times to play the data.
        **/

        if (pData->pParameters) {

            GetKeyValue(pData->pParameters,
                        pCopiesKey,
                        VALUE_ULONG,
                        &length,
                        &value);

            if (length == sizeof(ULONG)) {
                pData->Copies = value;
            }
        }

        /** If this is a text job, see if the tab size is in there **/

        if (uDatatype == PRINTPROCESSOR_TYPE_TEXT) {
            USHORT  length = sizeof(ULONG);

            GetKeyValue(pData->pParameters,
                        pTabsKey,
                        VALUE_ULONG,
                        &length,
                        &value);

            if ((length == sizeof(ULONG)) && value) {
                pData->TabSize = value;
            }
        }
    } /* If we have a parameter string */

    /**
        If we are doing copies, we need to check to see if
        this is a direct or spooled job.  If it is direct, then
        we can't do copies because we can't rewind the data stream.
    **/

    if (pData->Copies > 1) {
        ULONG           Error;
        PPRINTER_INFO_2 pPrinterInfo2;

        /** If we don't already have the printer open, open it **/

        if (uDatatype != PRINTPROCESSOR_TYPE_RAW 
            // @@BEGIN_DDKSPLIT 
            &&
            uDatatype != PRINTPROCESSOR_TYPE_RAW_FF &&
            uDatatype != PRINTPROCESSOR_TYPE_RAW_FF_AUTO 
            // @@END_DDKSPLIT
            ) {

            OpenPrinter(pPrinterName, &hPrinter, NULL);
        }
        if (hPrinter && hPrinter != INVALID_HANDLE_VALUE) {

            /** Get the printer info - this returns an allocated buffer **/

            pPrinterInfo2 = (PPRINTER_INFO_2)GetPrinterInfo(hPrinter, 2, &Error);

            /** If we couldn't get the info, be safe and don't do copies **/

            if (!pPrinterInfo2) {
                ODS(("GetPrinter failed - falling back to 1 copy\n"));
                pData->Copies = 1;
            }
            else {
                if (pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
                    pData->Copies = 1;
                }
                FreeSplMem((PUCHAR)pPrinterInfo2);
            }

            /** If we just opened the printer, close it **/

            if (uDatatype != PRINTPROCESSOR_TYPE_RAW 
                // @@BEGIN_DDKSPLIT 
                &&
                uDatatype != PRINTPROCESSOR_TYPE_RAW_FF &&
                uDatatype != PRINTPROCESSOR_TYPE_RAW_FF_AUTO 
                // @@END_DDKSPLIT
                ) {

                ClosePrinter(hPrinter);
            }
        }
        else {
            pData->Copies = 1;
        }
    }

    return (HANDLE)pData;

Fail:
    if (pData) {
        FreeSplMem(pData);
    }

    return FALSE;
}


/*++
*******************************************************************
    P r i n t D o c u m e n t O n P r i n t P r o c e s s o r

    Routine Description:

    Arguments:
        hPrintProcessor
        pDocumentName

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError() will return reason
*******************************************************************
--*/
BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPWSTR  pDocumentName
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (!(pData = ValidateHandle(hPrintProcessor))) {

        return FALSE;
    }

    /**
        Print the job based on its data type.
    **/

    switch (pData->uDatatype) {

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:

        return PrintEMFJob( pData, pDocumentName );
        break;

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
        return PrintRawJob(pData, pDocumentName, pData->uDatatype);
        break;

    case PRINTPROCESSOR_TYPE_TEXT:
        return PrintTextJob(pData, pDocumentName);
        break;    
    } /* Case on data type */

    /** Return success **/

    return TRUE;
}


/*++
*******************************************************************
    C l o s e P r i n t P r o c e s s o r

    Routine Description:
        Frees the resources used by an open print processor.

    Arguments:
        hPrintProcessor (HANDLE) => print processor to close

    Return Value:
        TRUE  if successful
        FALSE if failed - caller uses GetLastError for reason.
*******************************************************************
--*/

BOOL
ClosePrintProcessor(
    HANDLE  hPrintProcessor
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (!(pData= ValidateHandle(hPrintProcessor))) {
        return FALSE;
    }

    pData->signature = 0;

    /* Release any allocated resources */

    if (pData->hPrinter)
        ClosePrinter(pData->hPrinter);

    if (pData->hDC)
        DeleteDC(pData->hDC);

    if (pData->pDevmode)
        FreeSplMem(pData->pDevmode);

    if (pData->pPrinterNameFromOpenData)
        FreeSplStr(pData->pPrinterNameFromOpenData);

    CloseHandle(pData->semPaused);

    if (pData->pPrinterName)
        FreeSplStr(pData->pPrinterName);

    if (pData->pDatatype)
        FreeSplStr(pData->pDatatype);

    if (pData->pDocument)
        FreeSplStr(pData->pDocument);

    if (pData->pOutputFile)
        FreeSplStr(pData->pOutputFile);

    if (pData->pParameters)
        FreeSplStr(pData->pParameters);

    FreeSplMem(pData);

    return TRUE;
}


/*++
*******************************************************************
    C o n t r o l P r i n t P r o c e s s o r

    Routine Description:
        Handles commands to pause, resume, and cancel print jobs.

    Arguments:
        hPrintProcessor = HANDLE to the PrintProcessor the
        command is issued for.

    Return Value:
        TRUE  if command succeeded
        FALSE if command failed (invalid command)
*******************************************************************
--*/
BOOL
ControlPrintProcessor(
    HANDLE  hPrintProcessor,
    DWORD   Command
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (pData = ValidateHandle(hPrintProcessor)) {

        switch (Command) {

        case JOB_CONTROL_PAUSE:

            ResetEvent(pData->semPaused);
            pData->fsStatus |= PRINTPROCESSOR_PAUSED;
            return TRUE;
            break;

        case JOB_CONTROL_CANCEL:

            pData->fsStatus |= PRINTPROCESSOR_ABORTED;

            if ((pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_1) ||
                (pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_2) ||
                (pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_3))

                CancelDC(pData->hDC);

            /* Fall through to release job if paused */

        case JOB_CONTROL_RESUME:

            if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {

                SetEvent(pData->semPaused);
                pData->fsStatus &= ~PRINTPROCESSOR_PAUSED;
            }

            return TRUE;
            break;

        default:

            return FALSE;
            break;
        }
    }

    return FALSE;
}


/*++
*******************************************************************
    V a l i d a t e H a n d l e

    Routine Description:
        Validates the given Print Processor HANDLE (which is
        really a pointer to the Print Processor's data) by
        checking for our signature.

    Arguments:
        hQProc (HANDLE) => Print Processor data structure.  This
        is verified as really being a pointer to the Print
        Processor's data.

    Return Value:
        PPRINTPROCESSORDATA if successful (valid pointer passed)
        NULL if failed - pointer was not valid
*******************************************************************
--*/
PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hQProc
)
{
    /** Pick up the pointer **/

    PPRINTPROCESSORDATA pData = (PPRINTPROCESSORDATA)hQProc;

    //
    // Note that spooler has to leave the critical section to call into print
    // proc. So the handle passed by spooler could be invalid since one
    // thread could call SetJob to pause/resume a job while port thread
    // is printing it
    //
    try {

        /** See if our signature exists in the suspected data region **/

        if (pData && pData->signature != PRINTPROCESSORDATA_SIGNATURE) {

            /** Bad pointer - return failed **/

            pData = NULL;
        }


    }except (1) {

        /** Bad pointer - return failed **/

        pData = NULL;

    }

    if ( pData == NULL )
        SetLastError( ERROR_INVALID_HANDLE );

    return pData;

}

DWORD
GetPrintProcessorCapabilities(
    LPTSTR   pValueName,
    DWORD    dwAttributes,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
)
/*++
Function Description: GetPrintProcessorCapabilities returns information about the
                      options supported by the print processor for the given datatype
                      in a PRINTPROCESSOR_CAPS_1 struct.

Parameters:   pValueName   -- datatype like RAW|NT EMF 1.006|TEXT|...
              dwAttributes -- printer attributes
              pData        -- pointer to the buffer
              nSize        -- size of the buffer
              pcbNeeded    -- pointer to the variable to store the required buffer size

Return Values: Error Codes.
--*/
{
    LPWSTR                  *pDatatypes = Datatypes;
    DWORD                   dwDatatype  = 0;
    DWORD                   dwReturn;
    PPRINTPROCESSOR_CAPS_1  ppcInfo;

    *pcbNeeded = sizeof(PRINTPROCESSOR_CAPS_1);

    // Check for valid parameters.
    if (!pData || !pValueName) {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Check for sufficient buffer.
    if (nSize < *pcbNeeded) {
        dwReturn = ERROR_MORE_DATA;
        goto CleanUp;
    }

    // Loop to find the index of the datatype.
    while (*pDatatypes) {
       if (!_wcsicmp(*pDatatypes,pValueName)) {
           break;
       }
       pDatatypes++;
       dwDatatype++;
    }

    ppcInfo = (PPRINTPROCESSOR_CAPS_1) pData;

    // Level is 1 for PRINTPROCESSOR_CAPS_1.
    ppcInfo->dwLevel = 1;

    switch (dwDatatype) {

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
    case PRINTPROCESSOR_TYPE_TEXT:
          ppcInfo->dwNupOptions = 1;
          ppcInfo->dwNumberOfCopies = 0xffffffff; // maximum number of copies.
          ppcInfo->dwPageOrderFlags = NORMAL_PRINT;
          break;

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:
          // For direct printing, masq. printers and print RAW only,
          // EMF is not spooled. Dont expose EMF features in the UI.
          if ((dwAttributes & PRINTER_ATTRIBUTE_DIRECT)   ||
              (dwAttributes & PRINTER_ATTRIBUTE_RAW_ONLY) ||
              ((dwAttributes & PRINTER_ATTRIBUTE_LOCAL)  &&
               (dwAttributes & PRINTER_ATTRIBUTE_NETWORK))) {
              ppcInfo->dwNupOptions = 1;
              ppcInfo->dwNumberOfCopies = 1;
              ppcInfo->dwPageOrderFlags = NORMAL_PRINT;
          } else {
              ppcInfo->dwNupOptions = 0x0000812b;  // for 1,2,4,6,9,16 up options.
              ppcInfo->dwNumberOfCopies = 0xffffffff; // maximum number of copies.
              ppcInfo->dwPageOrderFlags = REVERSE_PRINT | BOOKLET_PRINT;
          }
          break;

    default:
          // Should not happen since the spooler must check if the datatype is
          // supported before calling this print processor.
          dwReturn = ERROR_INVALID_DATATYPE;
          goto CleanUp;
    }

    dwReturn = ERROR_SUCCESS;

CleanUp:

    return dwReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\prtprocs\winprint\winprint.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

   winprint.h

// @@BEGIN_DDKSPLIT

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

// @@END_DDKSPLIT
--*/

// for driver related defines and typedefs
#include <winddiui.h>

typedef struct _PRINTPROCESSORDATA {
    DWORD   signature;
    DWORD   cb;
    struct _PRINTPROCESSORDATA *pNext;
    DWORD   fsStatus;
    HANDLE  semPaused;
    DWORD   uDatatype;
    HANDLE  hPrinter;
    LPWSTR  pPrinterName;
    LPWSTR  pDocument;
    LPWSTR  pOutputFile;
    LPWSTR  pDatatype;
    LPWSTR  pParameters;
    DWORD   JobId;
    DWORD   Copies;         /** Number of copies to print **/
    DWORD   TabSize;
    HDC     hDC;
    DEVMODEW *pDevmode;
    LPWSTR  pPrinterNameFromOpenData;
} PRINTPROCESSORDATA, *PPRINTPROCESSORDATA;

#define PRINTPROCESSORDATA_SIGNATURE    0x5051  /* 'QP' is the signature value */

/* Define flags for fsStatus field */

#define PRINTPROCESSOR_ABORTED      0x0001
#define PRINTPROCESSOR_CLOSED       0x0004
#define PRINTPROCESSOR_PAUSED       0x0008

#define PRINTPROCESSOR_RESERVED     0xFFF8

/** Flags used for the GetKey routing **/

#define VALUE_STRING    0x01
#define VALUE_ULONG     0x02

/** Buffer sizes we'll use **/

#define READ_BUFFER_SIZE            0x10000
#define BASE_PRINTER_BUFFER_SIZE    2048

PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hPrintProcessor
);

/** Data types we support **/
// @@BEGIN_DDKSPLIT
#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_RAW_FF      1
#define PRINTPROCESSOR_TYPE_RAW_FF_AUTO 2
#define PRINTPROCESSOR_TYPE_EMF_40      3
#define PRINTPROCESSOR_TYPE_EMF_50_1    4
#define PRINTPROCESSOR_TYPE_EMF_50_2    5
#define PRINTPROCESSOR_TYPE_EMF_50_3    6
#define PRINTPROCESSOR_TYPE_TEXT        7

/** Data types we support for the DDK **/
#if 0
// @@END_DDKSPLIT
#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_EMF_50_1    1
#define PRINTPROCESSOR_TYPE_EMF_50_2    2
#define PRINTPROCESSOR_TYPE_EMF_50_3    3
#define PRINTPROCESSOR_TYPE_TEXT        4
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbgmain.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgmain.c

Abstract:

    This module provides all the Spooler Subsystem Debugger extensions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    Matthew Felton (MattFe) July 1994 Added flag decode and cleanup

--*/

#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"

#define     VERBOSE_ON      1
#define     VERBOSE_OFF     0


DWORD   dwGlobalAddress = 32;
DWORD   dwGlobalCount =  48;

BOOL help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    Print("Windows NT Spooler Subsystem - debugging extensions\n");
    Print("help - prints this list of debugging commands\n");
    Print("d  [addr]        - dumps a spooler structure at [addr]\n");
    Print("dc [addr]        - dumps a change structure at [addr]\n");
    Print("dci [addr]       - dumps a change info structure at [addr]\n");
    Print("ds               - dumps all INISPOOLER structures\n");
    Print("dp               - dumps all INIPRINTER structures pointed to by IniSpooler\n");
    Print("dmo              - dumps all INIMONITOR structures pointed to by IniSpooler\n");
    Print("de               - dumps all INIENVIRONMENT structures pointed to by IniSpooler\n");
    Print("dpo              - dumps all INIPORT structures pointed to by IniSpooler\n");
    Print("df               - dumps all INIFORM structures pointed to by IniSpooler\n");
    Print("dnp              - dumps all ININETPRINT structures pointed to by IniSpooler\n");
    Print("dd               - dumps all INIDRIVER structures pointed to by IniSpooler\n");
    Print("dpv              - dumps all PROVIDOR structures in the router\n");
    Print("w32              - dumps all Win32Spl handles WSPOOL\n");
    Print("dll [c#] [addr]  - dumps all or [c#] structures (based on sig) at [addr]\n");
    Print("dsd [addr]       - dumps a security descriptor starting from [addr]\n");
    Print("ddev [addr]      - dumps a devmode structure starting from [addr]\n");
    Print("dam [addr]       - dumps a security access mask starting at [addr]\n");
    Print("ct [addr] [arg0] - creates a thread at addr with 1 parm: [argv0]\n");
    Print("dpi2 [c#] addr   - dumps 1 or [c#] PRINTER_INFO_2 structures\n");
    Print("dpi0 [c#] addr   - dumps 1 or [c#] PRINTER_INFO_STRESS structures\n");
    Print("dfi1 [c#] addr   - dumps 1 or [c#] FORMS_INFO_1 structures\n");
    Print("dpdef addr       - dumps PRINTER_DEFAULTS structure\n");
    Print("handle           - dumps ClientHandleCount\n");

    return(TRUE);

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL d(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        Print("Usage: d [address] - Dumps internal Spooler structure based on signature\n");

    } else {
        UINT_PTR address;
        address = EvalExpression(lpArgumentString);
        Print("%x ", address);
        if (!DbgDumpStructure(hCurrentProcess, Print, (UINT_PTR)address))
            return(0);
    }

    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dc(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    DbgDumpChange(hCurrentProcess, Print, (PCHANGE)Address);

    //
    // Add Command to the Command Queue
    //
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dci(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    CHANGEINFO  ChangeInfo;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        return(0);
    }

    movestruct(Address, &ChangeInfo, CHANGEINFO);
    DbgDumpChangeInfo(hCurrentProcess, Print, &ChangeInfo);

    // Add Command to the Command Queue
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



PWSPOOL
GetpFirstWSpool(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_SYMBOL GetSymbol;
    PNTSD_GET_EXPRESSION EvalExpression;
    ULONG_PTR dwAddrGlobal;
    PWSPOOL pWSpool;

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwAddrGlobal, "win32spl!pFirstWSpool");
    movestruct((PVOID)dwAddrGlobal,&pWSpool, PWSPOOL);
    return pWSpool;
}


BOOL w32(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 0;
    UINT_PTR  Address = 0;
    PWSPOOL pWSpool = NULL;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }


    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        pWSpool = GetpFirstWSpool( hCurrentProcess, lpExtensionApis, lpArgumentString );
        Address = (UINT_PTR)pWSpool;
    }

    dwGlobalCount = dwCount;

    if ( Address != 0 ) {

        if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
            return(0);

    } else {

        Print("There are NO Win32spl Handles\n");

    }

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

}





PINISPOOLER
GetLocalIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PINISPOOLER pIniSpooler;
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_SYMBOL GetSymbol;
    PNTSD_GET_EXPRESSION EvalExpression;
    ULONG_PTR dwAddrGlobal;

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwAddrGlobal, "localspl!pLocalIniSpooler");
    movestruct((PVOID)dwAddrGlobal,&pIniSpooler, PINISPOOLER);
    return pIniSpooler;
}




BOOL ds(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 0;
    UINT_PTR Address = 0;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }


    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        Address = (UINT_PTR)pIniSpooler;
    }

    dwGlobalCount = dwCount;

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

}


BOOL dll(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        return(0);
    }

    // if we do have a count which is valid and > 0, call the incremental dump
    // otherwise call the dump all function.

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE: FALSE, dwCount, &dwGlobalAddress)) {
        return(0);
    }


    // Add Command to the Command Queue
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR  Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniPrinter;
    }

    dwGlobalCount = dwCount;

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    Print("dwGlobalAddress %.8x dwGlobalCount %d\n", dwGlobalAddress, dwGlobalCount);
    // Add Command to the Command Queue
    return TRUE;

}

BOOL de(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniEnvironment;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dd(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    INIENVIRONMENT IniEnvironment;
    PINIENVIRONMENT pIniEnvironment;
    INIVERSION IniVersion;
    PINIVERSION pIniVersion;
    UINT_PTR  Address = 0;
    WCHAR Buffer[MAX_PATH+1];


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
    movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

    for (pIniEnvironment = IniSpooler.pIniEnvironment;
         pIniEnvironment;
         pIniEnvironment = IniEnvironment.pNext) {

       movestruct((PVOID)pIniEnvironment,&IniEnvironment, INIENVIRONMENT);
       movemem(IniEnvironment.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
       (*Print)("\nEnvironment %ws\n", Buffer);

       for (pIniVersion = IniEnvironment.pIniVersion;
            pIniVersion;
            pIniVersion = IniVersion.pNext) {

          movestruct((PVOID)pIniVersion,&IniVersion, INIVERSION);
          movemem(IniVersion.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
          (*Print)("\nVersion %ws\n", Buffer);

          Address = (UINT_PTR)IniVersion.pIniDriver;

          if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, FALSE, 0, &dwGlobalAddress))
              return(0);
       }
    }

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dpo(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        PSHARED pShared;
        SHARED Shared;

        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniPort;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dmo(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        PSHARED pShared;
        SHARED Shared;

        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniMonitor;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL dnp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

        Address = (UINT_PTR)IniSpooler.pIniNetPrint;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);


    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}




BOOL df(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        PSHARED pShared;
        SHARED Shared;

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        movestruct( (PVOID)IniSpooler.pShared, &Shared, SHARED );
        Address = (UINT_PTR)Shared.pIniForm;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dsp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = (UINT_PTR)NULL;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

        Address = (UINT_PTR)IniSpooler.pSpool;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);


    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL next(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    Address = dwGlobalAddress;    // Let's get the address to dump at
    dwCount = dwGlobalCount;        // and while we're at it, get the count

    Print("Next address: %.8x Count: %d\n", Address, dwCount);
    if (Address == 0) {
        Print("dump address = <null>; no more data to dump\n");
        return(FALSE);
    }

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return (TRUE);

}

BOOL ct(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwArg = 0;
    BOOL    bThereAreOptions = TRUE;
    UINT i = 0;
    HANDLE hThread;
    DWORD dwThreadId;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (i) {
        case 0:

            Address = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        case 1:

            dwArg = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default:

            (*Print)("Usage: ct addr arg0");
            return FALSE;
       }
       i++;
    }

    hThread = CreateRemoteThread(hCurrentProcess,
                                 NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE)Address,
                                 (LPVOID)UIntToPtr(dwArg),
                                 0,
                                 &dwThreadId);

    if (hThread) {

        (*Print)("Thread id 0x%x at %x, arg0 %x created.\n",
                 dwThreadId, Address, dwArg);

        CloseHandle(hThread);
        return TRUE;
    }

    return FALSE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL dpi2(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi2 you need to supply an address\n");
        return TRUE;
    }

    if ( !DbgDumpPI2(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}




BOOL dpi0(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi0 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpPI0(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}









BOOL dfi1(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dfi1 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpFI1(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}






BOOL dpdef(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi0 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpPDEF(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}


BOOL handle(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    ULONG_PTR dwAddrGlobal = 0;
    DWORD   HandleCount;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;


    GetAddress(dwAddrGlobal, "winspool!ClientHandleCount");

    if ( dwAddrGlobal != 0 ) {

        movestruct((PVOID)dwAddrGlobal, &HandleCount, DWORD);
        Print("ClientHandleCount %d\n", HandleCount);

    }


    GetAddress(dwAddrGlobal, "spoolss!ServerHandleCount");

    if ( dwAddrGlobal != 0 ) {

        movestruct((PVOID)dwAddrGlobal, &HandleCount, DWORD);
        Print("ServerHandleCount %d\n", HandleCount);

    }

    return TRUE;
}

BOOL dpv(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    ULONG_PTR dwGlobalAddress = 0;
    WCHAR Buffer[MAX_PATH+1];
    LPPROVIDOR  pLocalProvidor, pProvidor;
    PROVIDOR    Providor;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwGlobalAddress, "spoolss!pLocalProvidor");
    movestruct((PVOID)dwGlobalAddress, &pLocalProvidor, LPPROVIDOR);

    for (pProvidor = pLocalProvidor;
         pProvidor;
         pProvidor = Providor.pNext)
    {
        (*Print) ("Providor %x\n", pProvidor);
        movestruct((PVOID) pProvidor, &Providor, PROVIDOR);
        DbgDumpProvidor(hCurrentProcess, Print, &Providor);
    }

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbgsec.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgspl.c

Abstract:

    This module provides all the Spooler Subsystem Debugger extensions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion routines)
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)

To do:

    Write a generic dump unicode string (reduce the code!!)

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"


#define NULL_TERMINATED 0
#define VERBOSE_ON      1
#define VERBOSE_OFF     0

#define         MAX_SDC_FLAGS           7

typedef struct _DBG_SED_CONTROL{
    unsigned short    Flag;
    LPSTR     String;
}DBG_SED_CONTROL, *PDBG_SED_CONTROL;

DBG_SED_CONTROL SDC_Table[] =

{
    0x0001, "SE_OWNER_DEFAULTED",

    0x0002, "SE_GROUP_DEFAULTED",

    0x0004, "SE_DACL_PRESENT",

    0x0008, "SE_DACL_DEFAULTED",

    0x0010, "SE_SACL_PRESENT",

    0x0020, "SE_SACL_DEFAULTED",

    0x8000, "SE_SELF_RELATIVE"

};

#define     MAX_ACE_FLAGS       6

typedef struct _DBG_ACE_FLAGS{
    UCHAR   Flags;
    LPSTR   String;
}DBG_ACE_FLAGS, *PDBG_ACE_FLAGS;


DBG_ACE_FLAGS AceFlagsTable[] =

{
    0x1, "OBJECT_INHERIT_ACE",

    0x2, "CONTAINER_INHERIT_ACE",

    0x4, "NO_PROPAGATE_INHERIT_ACE",

    0x8, "INHERIT_ONLY_ACE",

    0x40, "SUCCESSFUL_ACCESS_ACE_FLAG",

    0x80, "FAILED_ACCESS_ACE_FLAG"
};



typedef struct _ACCESSMASKTAB{
    DWORD   Flag;
    LPSTR   String;
}ACCESSMASKTAB, *PACCESSMASKTAB;


ACCESSMASKTAB AccessMaskTable[33] =

{
    0x00000001, "SERVER_ACCESS_ADMINSTER",

    0x00000002, "SERVER_ACCESS_ENUMERATE",

    0x00000004, "PRINTER_ACCESS_ADMINSTER",

    0x00000008, "PRINTER_ACCESS_USE",

    0x00000010, "JOB_ACCESS_ADMINISTER",

    0x00010000, "DELETE",

    0x00020000, "READ_CONTROL",

    0x00040000, "WRITE_DAC",

    0x00080000, "WRITE_OWNER",

    0x00100000, "SYNCHRONIZE",

    0x01000000, "ACCESS_SYSTEM_SECURITY",

    0x10000000, "GENERIC_ALL",

    0x20000000, "GENERIC_EXECUTE",

    0x40000000, "GENERIC_WRITE",

    0x80000000, "GENERIC_READ",

    0x0000FFFF, "SPECIFIC_RIGHTS_ALL",

    0x000F0000, "STANDARD_RIGHTS_REQUIRED <D-R/C-W/DAC-W/O>",

    0x001F0000, "STANDARD_RIGHTS_ALL  <D-R/C-W/DAC-W/O-S>",

    READ_CONTROL, "STANDARD_RIGHTS_READ <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_WRITE <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_EXECUTE <R/C>",

    SERVER_ALL_ACCESS, "SERVER_ALL_ACCESS <SRREQ-SAA-SAE>",

    SERVER_READ,    "SERVER_READ <SRR-SAE>",

    SERVER_WRITE, "SERVER_WRITE <SRW-SAA-SAE>",

    SERVER_EXECUTE, "SERVER_EXECUTE <SRE-SAE>",

    PRINTER_ALL_ACCESS, "PRINTER_ALL_ACCESS <SRREQ-PAA-PAU>",

    PRINTER_READ, "PRINTER_READ <SRR-PAU>",

    PRINTER_WRITE, "PRINTER_WRITE <SRW-PAU>",

    PRINTER_EXECUTE, "PRINTER_EXECUTE <SRE-PAU>",

    JOB_ALL_ACCESS, "JOB_ALL_ACCESS <SRREQ-JAA>",

    JOB_READ, "JOB_READ <SRR-JAA>",

    JOB_WRITE, "JOB_WRITE <SRW-JAA>",

    JOB_EXECUTE, "JOB_EXECUTE <SRE-JAA>"

};



BOOL
DbgDumpSecurityDescriptor(
            HANDLE hCurrentProcess,
            PNTSD_OUTPUT_ROUTINE Print,
            PISECURITY_DESCRIPTOR pSecurityDescriptor
            )
{
    BOOL    bSe_Self_Relative = FALSE;
    DWORD   i;
    UINT_PTR   OwnerSidAddress, GroupSidAddress;
    UINT_PTR   SaclAddress, DaclAddress;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    memset(&SecurityDescriptor, 0, sizeof(SECURITY_DESCRIPTOR));
    movestruct(pSecurityDescriptor, &SecurityDescriptor, SECURITY_DESCRIPTOR);

    (*Print)("SecurityDescriptor\n");

    bSe_Self_Relative = SecurityDescriptor.Control & SE_SELF_RELATIVE;
    if (bSe_Self_Relative) {
        (*Print)("This Security Descriptor is a Self-Relative Security Descriptor\n");
    }

    (*Print)("UCHAR         Revision        0x%x\n", SecurityDescriptor.Revision);
    (*Print)("UCHAR         Sbz1            0x%x\n", SecurityDescriptor.Sbz1);
    (*Print)("USHORT         Control        0x%x\n", SecurityDescriptor.Control);
    for (i = 0; i < MAX_SDC_FLAGS; i++ ) {
        if (SecurityDescriptor.Control & SDC_Table[i].Flag) {
            (*Print)("%s - ON  (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        } else {
            (*Print)("%s - OFF (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        }
    }

    //
    // Now dumping out the owner's sid
    //

    if (SecurityDescriptor.Owner == NULL) {
        (*Print)("PSID       Owner     null -- no owner sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID          Owner Offset   0x%.8x\n",SecurityDescriptor.Owner);
            OwnerSidAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Owner;
        }else {
            OwnerSidAddress = (UINT_PTR)SecurityDescriptor.Owner;
        }
        // (*Print)("PSID         Owner            0x%.8x\n", OwnerSidAddress);
    }
    (*Print)("The owner's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)OwnerSidAddress);
    (*Print)("\n\n");

    //
    // Now dumping out the group's sid

    if (SecurityDescriptor.Group == NULL) {
        (*Print)("PSID       Group    null -- no group sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID      Group Offset    0x%.8x\n", SecurityDescriptor.Group);
            GroupSidAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Group;
        }else {
            GroupSidAddress = (UINT_PTR)SecurityDescriptor.Group;
        }
        // (*Print)("PSID         Group            0x%.8x\n", GroupSidAddress);
    }
    (*Print)("The group's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)GroupSidAddress);
    (*Print)("\n");



    if (SecurityDescriptor.Sacl == NULL) {
        (*Print)("PACL       Sacl    null -- no sacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Sacl Offset %.8x\n", SecurityDescriptor.Sacl);
            SaclAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Sacl;
        }else{
            SaclAddress = (UINT_PTR)SecurityDescriptor.Sacl;

        }
        // (*Print)("PACL         Sacl            0x%.8x\n", SaclAddress);
    }

    if (SecurityDescriptor.Dacl == NULL) {
        (*Print)("PACL      Dacl    null -- no dacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Dacl Offset %.8x\n", SecurityDescriptor.Dacl);
            DaclAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Dacl;
        }else {
            DaclAddress = (UINT_PTR)SecurityDescriptor.Dacl;
        }
        // (*Print)("PACL         Dacl            0x%.8x\n", DaclAddress);
        DbgDumpAcl(hCurrentProcess, Print,(PVOID)DaclAddress);
    }

    return TRUE;
}


BOOL
DbgDumpSid(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  SidAddress
           )
{
    BYTE    Sid[256];
    CHAR   SidString[256];
    SID_NAME_USE SidType = 1;

    // (*Print)("Size of a SID is %d\n", sizeof(SID));

    // movestruct(SidAddress, &Sid, SID);
    memset(Sid, 0,  256);
    movemem(SidAddress, Sid, 256);
    ConvertSidToAsciiString(Sid, SidString);
    (*Print)("PSID      %s\n", SidString);

    return TRUE;
}


BOOL
DbgDumpAceHeader(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID   AceHeaderAddress
    )
{
   ACE_HEADER AceHeader;
   DWORD i = 0;

   memset(&AceHeader, 0, sizeof(ACE_HEADER));
   movestruct(AceHeaderAddress, &AceHeader, ACE_HEADER);
   (*Print)("UCHAR      AceType         %.2x\n", AceHeader.AceType);
   switch (AceHeader.AceType) {
   case ACCESS_ALLOWED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_ALLOWED_ACE_TYPE\n");
       break;
   case ACCESS_DENIED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_DENIED_ACE_TYPE\n");
       break;
   case SYSTEM_AUDIT_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_AUDIT_ACE_TYPE\n");
       break;

   case SYSTEM_ALARM_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_ALARM_ACE_TYPE\n");
       break;
   }
   (*Print)("UCHAR      AceFlags        %.2x\n", AceHeader.AceFlags);

   for (i = 0; i < MAX_ACE_FLAGS; i++ ) {
       if (AceFlagsTable[i].Flags & AceHeader.AceFlags) {
           (*Print)("%s - ON (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }else {
           (*Print)("%s - OFF (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }
   }

   (*Print)("USHORT     AceSize         %d\n", AceHeader.AceSize);

    return TRUE;
}


BOOL
DbgDumpAcl(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  AclAddress
           )
{
    ACL         Acl;
    PVOID       AceAddress;
    ACE_HEADER  AceHeader;
    ACCESS_ALLOWED_ACE AccessAllowedAce;
    ACCESS_DENIED_ACE  AccessDeniedAce;
    SYSTEM_AUDIT_ACE   SystemAuditAce;
    SYSTEM_ALARM_ACE   SystemAlarmAce;
    DWORD   i;
    UINT_PTR   SidAddress;

    // Pull the Acl across

    movestruct(AclAddress, &Acl, ACL);

    (*Print)("ACL\n");

    (*Print)("UCHAR     AclRevision     0x%x\n", Acl.AclRevision);
    (*Print)("UCHAR     Sbz1            0x%x\n", Acl.Sbz1);
    (*Print)("USHORT    AclSize         %d\n", Acl.AclSize);
    (*Print)("USHORT    AceCount        %d\n", Acl.AceCount);
    (*Print)("USHORT    Sz2             0x%x\n", Acl.Sbz2);

    AceAddress = (LPBYTE)AclAddress + sizeof(ACL);
    for (i = 0; i < Acl.AceCount; i++ ) {
        (*Print)("\nAce # %d: ",i);
        DbgDumpAceHeader(hCurrentProcess, Print, AceAddress);
        movestruct(AceAddress, &AceHeader, ACE_HEADER);

        switch (AceHeader.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            memset(&AccessAllowedAce, 0, sizeof(ACCESS_ALLOWED_ACE));
            movestruct(AceAddress, &AccessAllowedAce, ACCESS_ALLOWED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessAllowedAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            // (*Print)("The Address of the Sid is %.8x\n", SidAddress);
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            memset(&AccessDeniedAce, 0, sizeof(ACCESS_DENIED_ACE));
            movestruct(AceAddress, &AccessDeniedAce, ACCESS_DENIED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessDeniedAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            memset(&SystemAuditAce, 0, sizeof(SYSTEM_AUDIT_ACE));
            movestruct(AceAddress, &SystemAuditAce, SYSTEM_AUDIT_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAuditAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_ALARM_ACE_TYPE:
            memset(&SystemAlarmAce, 0, sizeof(SYSTEM_ALARM_ACE));
            movestruct(AceAddress, &SystemAlarmAce, SYSTEM_ALARM_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAlarmAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;
        }
        AceAddress = (PVOID)((UINT_PTR)AceAddress +  AceHeader.AceSize);
        (*Print)("\n");
    }

    return TRUE;
}


BOOL
dsd(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSecurityDescriptor(
                hCurrentProcess,
                Print,
                (PISECURITY_DESCRIPTOR)Address
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL
dsid(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSid(
          hCurrentProcess,
          Print,
          (PVOID)Address
          );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}




BOOL
ddev(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DumpDevMode(
                hCurrentProcess,
                Print,
                (UINT_PTR)Address
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}





BOOL
DbgDumpAccessMask(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     DWORD  AccessMask
           )
{
    DWORD i;
    for (i = 0; i < 33; i++) {
        if (AccessMask & AccessMaskTable[i].Flag) {
            (*Print)("%s\t\tON\n", AccessMaskTable[i].String);
        }else {
            (*Print)("%s\t\tOFF\n", AccessMaskTable[i].String);
        }
    }
    return TRUE;
}




BOOL
dam(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   AccessMask = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        AccessMask = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (AccessMask == (UINT_PTR)NULL) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpAccessMask(
                hCurrentProcess,
                Print,
                AccessMask
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\precomp.h ===
#include <windows.h>
#include <winspool.h>
#include <ntsdexts.h>
#include <stdio.h>

#include <winsplp.h>
#include <spltypes.h>
#include <router.h>
#include <winspl.h>
#include <reply.h>
#include <w32types.h>
#include <splcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbgsec.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgsec.h

Abstract:

    Header file for Spooler Subsystem Debugger Extensions

Author:

    Krishna Ganugapati (KrishnaG) 08-July-1992

Revision History:

--*/

//
// Object types
//

#define SPOOLER_OBJECT_SERVER   0
#define SPOOLER_OBJECT_PRINTER  1
#define SPOOLER_OBJECT_DOCUMENT 2
#define SPOOLER_OBJECT_COUNT    3

/* These access bits must be different from those exposed in winspool.h,
 * so that no auditing takes place when we do an access check against them:
 */
#define SERVER_ACCESS_ADMINISTER_PRIVATE    0x00000004
#define PRINTER_ACCESS_ADMINISTER_PRIVATE   0x00000008
#define JOB_ACCESS_ADMINISTER_PRIVATE       0x00000080

PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
);

PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
);

BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
);

BOOL
DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
);

BOOL
DeleteDocumentSecurity(
    PINIJOB pIniJob
);

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
);

BOOL
ValidateObjectAccess(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID      ObjectHandle
);

BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
);

VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
);

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
);

BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
);

ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
);

BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
);

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrintShareSecurityDescriptor(
    VOID
);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbgutil.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgutil.c

Abstract:

    This module provides all the Spooler Subsystem Debugger utility
    functions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

SYSTEM_INFO gSysInfo;

DWORD EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print)
{
    LPSTR lpArgumentString;
    LPSTR lpAddress;
    DWORD dw;
    char ach[80];
    UINT_PTR cch;

    UNREFERENCED_PARAMETER(Print);
    lpArgumentString = *pptstr;

    while (isspace(*lpArgumentString))
        lpArgumentString++;

    lpAddress = lpArgumentString;
    while ((!isspace(*lpArgumentString)) && (*lpArgumentString != 0))
        lpArgumentString++;

    cch = (UINT_PTR)lpArgumentString - (UINT_PTR)lpAddress;
    if (cch > 79)
        cch = 79;

    strncpy(ach, lpAddress, (UINT)cch);
//  Print("\"%s\"\n", lpAddress);
    dw = (DWORD)EvalExpression(lpAddress);

    *pptstr = lpArgumentString;
    return dw;
}


VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    UCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= '\0';
        return;
    }

    sprintf(Buffer, "S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    strcpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        sprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        strcat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        sprintf(Buffer, "%lu", Tmp);
        strcat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        sprintf(Buffer, "-%lu", *(GetSidSubAuthority(pSid, i)));
        strcat(String, Buffer);
    }

}

BOOL
ReadProcessString(
    IN  HANDLE  hProcess,
    IN  LPCVOID lpBaseAddress,
    OUT LPVOID  lpBuffer,
    IN  SIZE_T  nSize,
    OUT SIZE_T  *lpNumberOfBytesRead
    )
{
    BOOL        bRetval     = FALSE;
    SIZE_T      cbRead      = 0;
    UINT_PTR    nAddress    = 0;

    //
    // Attempt to read the memory, up to the provided size.
    //
    bRetval = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, &cbRead);

    //
    // The string in the debugged process may have unmapped memory just after
    // the end of the string, (this is true when page heap is enabled),
    //
    // If the read failed and the address plus the string buffer size crosses
    // a page boundary then retry the operation up to the page end.
    //
    if (!bRetval)
    {
        nAddress = (UINT_PTR)lpBaseAddress;

        //
        // If we have crossed a page boundary.
        //
        if (((nAddress & (gSysInfo.dwPageSize-1)) + nSize) > gSysInfo.dwPageSize-1)
        {
            nSize = (SIZE_T)((gSysInfo.dwPageSize-1) - (nAddress & (gSysInfo.dwPageSize-1)));

            bRetval = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, &cbRead);
        }
    }

    //
    // The read succeeded.
    //
    if (bRetval)
    {
        //
        // If the caller wants to know the number of bytes read.
        //
        if (lpNumberOfBytesRead)
        {
            *lpNumberOfBytesRead = cbRead;
        }
    }

    return bRetval;
}

//
// Query the system for the page size.
//
BOOL
QuerySystemInformation(
    VOID
    )
{
    GetSystemInfo(&gSysInfo);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splexts\dbgspl.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgspl.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion routines)
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)
    MattFe                   7 NOV   94   win32spl debug extentions

To do:

    Write a generic dump unicode string (reduce the code!!)

--*/

#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

#define NULL_TERMINATED 0
#define VERBOSE_ON      1
#define VERBOSE_OFF     0


typedef void (*PNTSD_OUTPUT_ROUTINE)(char *, ...);

BOOL
DbgDumpIniPrintProc(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTPROC pIniPrintProc
);


BOOL
DbgDumpIniDriver(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIDRIVER  pIniDriver
);


BOOL
DbgDumpIniEnvironment(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIENVIRONMENT pIniEnvironment
);


BOOL
DbgDumpIniNetPrint(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PININETPRINT pIniNetPrint
);

BOOL
DbgDumpIniMonitor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIMONITOR pIniMonitor
);


BOOL
DbgDumpIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPORT pIniPort
);

BOOL
DbgDumpIniPrinter(

    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTER pIniPrinter
);

BOOL
DbgDumpIniForm(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIFORM pForm
);

BOOL
DbgDumpIniJob(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIJOB pIniJob
);

BOOL
DbgDumpProvidor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    LPPROVIDOR pProvidor
);

BOOL
DbgDumpSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSPOOL pSpool
);

BOOL
DbgDumpShadowFile(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE pShadowFile
);

BOOL
DbgDumpShadowFile2(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE_2 pShadowFile
);

VOID
PrintData(
    PNTSD_OUTPUT_ROUTINE Print,
    LPSTR   TypeString,
    LPSTR   VarString,
    ...
);

BOOL
DbgDumpWCacheIniPrinter(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWCACHEINIPRINTEREXTRA pWCacheIniPrinter
);

BOOL
DbgDumpWSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWSPOOL pSpool
);

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
);


BOOL
DbgDumpIniVersion(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIVERSION pIniVersion
);

BOOL
DbgDumpPrintHandle(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PPRINTHANDLE pPrintHandle
);


typedef struct _DBG_PRINTER_ACCESS
{
    DWORD   Attribute;
    LPSTR   String;
} DBG_PRINTER_ACCESS, *PDBG_PRINTER_ACCESS;


DBG_PRINTER_ACCESS
PrinterAccessTable[] =
{
    SERVER_ACCESS_ADMINISTER    ,"Server_Access_Administer",
    SERVER_ACCESS_ENUMERATE     ,"Server_Access_Enumerate",
    PRINTER_ACCESS_ADMINISTER   ,"Printer_Access_Administer",
    PRINTER_ACCESS_USE          ,"Printer_Access_Use",
    JOB_ACCESS_ADMINISTER       ,"Job_Access_Administer"
};




typedef struct _DBG_SPOOLER_FLAGS
{
    DWORD   SpoolerFlags;
    LPSTR   String;
} DBG_SPOOLER_FLAGS, *PDBG_SPOOLER_FLAGS;


DBG_SPOOLER_FLAGS
SpoolerFlagsTable[] =

{
    SPL_UPDATE_WININI_DEVICES                   ,"Update_WinIni_Devices",
    SPL_PRINTER_CHANGES                         ,"Printer_Changes",
    SPL_LOG_EVENTS                              ,"Log_Events",
    SPL_FORMS_CHANGE                            ,"Forms_Change",
    SPL_BROADCAST_CHANGE                        ,"Broadcast_Change",
    SPL_SECURITY_CHECK                          ,"Security_Check",
    SPL_OPEN_CREATE_PORTS                       ,"Open_Create_Ports",
    SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION     ,"Fail_Open_Printers_Pending_Deletion",
    SPL_REMOTE_HANDLE_CHECK                     ,"Remote_Handle_Check"
};



typedef struct _DBG_PRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PRINTER_STATUS, *PDBG_PRINTER_STATUS;


DBG_PRINTER_STATUS
PrinterStatusTable[] =

{
    PRINTER_ZOMBIE_OBJECT,              "Zombie_Object",
    PRINTER_PENDING_CREATION,           "Pending_Creation",
    PRINTER_OK,                         "OK",
    PRINTER_FROM_REG,                   "From_Reg",
    PRINTER_WAS_SHARED,                 "Was_Shared",

    PRINTER_ERROR,               "Error",
    PRINTER_PAPER_JAM,           "PaperJam",
    PRINTER_PAPEROUT,           "PaperOut",
    PRINTER_MANUAL_FEED,         "ManualFeed",
    PRINTER_PAPER_PROBLEM,       "PaperProblem",
    PRINTER_OFFLINE,             "OffLine",
    PRINTER_IO_ACTIVE,           "IOActive",
    PRINTER_BUSY,                "Busy",
    PRINTER_PRINTING,            "Printing",
    PRINTER_OUTPUT_BIN_FULL,     "OutputBinFull",
    PRINTER_NOT_AVAILABLE,       "NotAvailable",
    PRINTER_WAITING,             "Waiting",
    PRINTER_PROCESSING,          "Processing",
    PRINTER_INITIALIZING,        "Initializing",
    PRINTER_WARMING_UP,          "WarmingUp",
    PRINTER_TONER_LOW,           "TonerLow",
    PRINTER_NO_TONER,            "NoToner",
    PRINTER_PAGE_PUNT,           "PagePunt",
    PRINTER_USER_INTERVENTION,   "UserIntervention",
    PRINTER_OUT_OF_MEMORY,       "OutOfMemory",
    PRINTER_DOOR_OPEN,           "DoorOpen",
    PRINTER_SERVER_UNKNOWN,      "ServerUnknown",

    PRINTER_PAUSED,              "Paused",
    PRINTER_PENDING_DELETION,    "Pending_Deletion",
};

typedef struct _DBG_EXTERNAL_PRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_EXTERNAL_PRINTER_STATUS, *PDBG_EXTERNAL_PRINTER_STATUS;


DBG_EXTERNAL_PRINTER_STATUS
ExternalPrinterStatusTable[] =

{
     PRINTER_STATUS_PAUSED            , "Paused",
     PRINTER_STATUS_ERROR             , "Error",
     PRINTER_STATUS_PENDING_DELETION  , "Pending_Deletion",
     PRINTER_STATUS_PAPER_JAM         , "Paper_Jam",
     PRINTER_STATUS_PAPER_OUT         , "Paper_Out",
     PRINTER_STATUS_MANUAL_FEED       , "Manual_Feed",
     PRINTER_STATUS_PAPER_PROBLEM     , "Paper_Problem",
     PRINTER_STATUS_OFFLINE           , "OffLine",
     PRINTER_STATUS_IO_ACTIVE         , "IO_Active",
     PRINTER_STATUS_BUSY              , "Busy",
     PRINTER_STATUS_PRINTING          , "Printing",
     PRINTER_STATUS_OUTPUT_BIN_FULL   , "Output_Bin_Full",
     PRINTER_STATUS_NOT_AVAILABLE     , "Not_Available",
     PRINTER_STATUS_WAITING           , "Waiting",
     PRINTER_STATUS_PROCESSING        , "Processing",
     PRINTER_STATUS_INITIALIZING      , "Initializing",
     PRINTER_STATUS_WARMING_UP        , "Warming_Up",
     PRINTER_STATUS_TONER_LOW         , "Toner_Low",
     PRINTER_STATUS_NO_TONER          , "No_Toner",
     PRINTER_STATUS_PAGE_PUNT         , "Page_Punt",
     PRINTER_STATUS_USER_INTERVENTION , "User_Intervention",
     PRINTER_STATUS_OUT_OF_MEMORY     , "Out_Of_Memory",
     PRINTER_STATUS_DOOR_OPEN         , "Door_Open",
     PRINTER_STATUS_SERVER_UNKNOWN    , "Server_Unknown"
};

typedef struct _DBG_PORT_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PORT_STATUS, *PDBG_PORT_STATUS;

DBG_PORT_STATUS
PortStatusTable[] =

{
    PORT_STATUS_OFFLINE                 , "Offline",
    PORT_STATUS_PAPER_JAM               , "PaperJam",
    PORT_STATUS_PAPER_OUT               , "PaperOut",
    PORT_STATUS_OUTPUT_BIN_FULL         , "OutputBinFull",
    PORT_STATUS_PAPER_PROBLEM           , "PaperJam",
    PORT_STATUS_NO_TONER                , "NoToner",
    PORT_STATUS_DOOR_OPEN               , "DoorOpen",
    PORT_STATUS_USER_INTERVENTION       , "UserIntervention",
    PORT_STATUS_OUT_OF_MEMORY           , "OutOfMemory",

    PORT_STATUS_TONER_LOW               , "TonerLow",

    PORT_STATUS_WARMING_UP              , "WarmingUp",
    PORT_STATUS_POWER_SAVE              , "PowerSave"
};





typedef struct _DBG_PRINTER_ATTRIBUTE
{
    DWORD   Attribute;
    LPSTR   String;
} DBG_PRINTER_ATTRIBUTE, *PDBG_PRINTER_ATTRIBUTE;


DBG_PRINTER_ATTRIBUTE
ChangeStatusTable[] =

{
    STATUS_CHANGE_FORMING, "Forming",
    STATUS_CHANGE_VALID,   "Valid",
    STATUS_CHANGE_CLOSING, "Closing",
    STATUS_CHANGE_CLIENT,  "Client",
    STATUS_CHANGE_ACTIVE,  "Active",

    STATUS_CHANGE_INFO, "Info",

    STATUS_CHANGE_ACTIVE_REQ,  "ActiveRequest",

    STATUS_CHANGE_DISCARDED, "Discarded",

    STATUS_CHANGE_DISCARDNOTED, "DiscardNoted",
};

DBG_PRINTER_ATTRIBUTE
PrinterAttributeTable[] =

{
    PRINTER_ATTRIBUTE_QUEUED,            "Queued",
    PRINTER_ATTRIBUTE_DIRECT,            "Direct",
    PRINTER_ATTRIBUTE_DEFAULT,           "Default",
    PRINTER_ATTRIBUTE_SHARED,            "Shared",
    PRINTER_ATTRIBUTE_NETWORK,           "Network",
    PRINTER_ATTRIBUTE_LOCAL,             "Local",
    PRINTER_ATTRIBUTE_HIDDEN,            "Hidden",
    PRINTER_ATTRIBUTE_ENABLE_DEVQ,       "Enable_DevQ",
    PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS,   "KeepPrintedJobs",
    PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, "DoCompleteFirst",
    PRINTER_ATTRIBUTE_ENABLE_BIDI,       "EnableBidi",
    PRINTER_ATTRIBUTE_FAX,               "Fax",
    PRINTER_ATTRIBUTE_WORK_OFFLINE,      "Offline"
};


typedef struct _DBG_JOB_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_JOB_STATUS, *PDBG_JOB_STATUS;

DBG_JOB_STATUS
JobStatusTable[] =

{
    JOB_PAUSED,                  "Paused",
    JOB_ERROR,                   "Error",
    JOB_OFFLINE,                 "OffLine",
    JOB_PAPEROUT,                "PaperOut",

    JOB_PENDING_DELETION,        "Deleting",
    JOB_SPOOLING,                "Spooling",
    JOB_PRINTING,                "Printing",
    JOB_PRINTED,                 "Printed",
    JOB_BLOCKED_DEVQ,            "Blocked_DevQ",
    JOB_DELETED,                 "Deleted",

    JOB_DESPOOLING,              "Despooling",
    JOB_DIRECT,                  "Direct",
    JOB_COMPLETE,                "Complete",
    JOB_RESTART,                 "Restart",
    JOB_REMOTE,                  "Remote",
    JOB_NOTIFICATION_SENT,       "Notification_Sent",
    JOB_PRINT_TO_FILE,           "Print_To_File",
    JOB_TYPE_ADDJOB,             "AddJob",
    JOB_SCHEDULE_JOB,            "Schedule_Job",
    JOB_TIMEOUT,                 "Timeout",
    JOB_ABANDON,                 "Abandon",
    JOB_TRUE_EOJ,                "TrueEOJ",
    JOB_COMPOUND,                "Compound",
    JOB_HIDDEN,                  "Hidden",
    JOB_TYPE_OPTIMIZE,           "MemoryMap Optimization",
    JOB_PP_CLOSE,                "Print Proccessor Close",
    JOB_DOWNLEVEL,               "Downlevel Job"
};

typedef struct _DBG_PINIPORT_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PINIPORT_STATUS, *PDBG_PINIPORT_STATUS;


DBG_PINIPORT_STATUS
pIniPortStatusTable[]=
{
     PP_PAUSED         ,"Paused",
     PP_WAITING        ,"Waiting",
     PP_RUNTHREAD      ,"RunThread",
     PP_THREADRUNNING  ,"ThreadRunning",
     PP_RESTART        ,"Restart",
     PP_CHECKMON       ,"CheckMon",
     PP_STOPMON        ,"StopMon",
     PP_QPROCCHECK     ,"QProcCheck",
     PP_QPROCPAUSE     ,"QProcPause",
     PP_QPROCABORT     ,"QProctAbort",
     PP_QPROCCLOSE     ,"QProcClose",
     PP_PAUSEAFTER     ,"PauseAfter",
     PP_MONITORRUNNING ,"MonitorRunning",
     PP_RUNMONITOR     ,"RunMonitor",
     PP_MONITOR        ,"Monitor",
     PP_FILE           ,"File",
     PP_ERROR          ,"Error",
     PP_WARNING        ,"Warning",
     PP_INFORMATIONAL  ,"Informational",
     PP_DELETING       ,"Deleting",
     PP_STARTDOC       ,"StartDoc",
     PP_PLACEHOLDER    ,"Placeholder",
};



typedef struct _DBG_WSPOOL_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_WSPOOL_STATUS, *PDBG_WSPOOL_STATUS;


DBG_WSPOOL_STATUS
WSpoolStatusTable[]=
{
     WSPOOL_STATUS_STARTDOC                   ,"StartDoc",
     WSPOOL_STATUS_BEGINPAGE                  ,"BeginPage",
     WSPOOL_STATUS_TEMP_CONNECTION            ,"Temp_Connection",
     WSPOOL_STATUS_OPEN_ERROR                 ,"Open_Error",
     WSPOOL_STATUS_PRINT_FILE                 ,"Print_File",
     WSPOOL_STATUS_USE_CACHE                  ,"Use_Cache",
     WSPOOL_STATUS_NO_RPC_HANDLE              ,"No_Rpc_Handle",
     WSPOOL_STATUS_PENDING_DELETE             ,"Pending_delete",
     WSPOOL_STATUS_RESETPRINTER_PENDING       ,"ResetPrinter_Pending"
};


typedef struct _DBG_PSPOOL_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PSPOOL_STATUS, *PDBG_PSPOOL_STATUS;


DBG_PSPOOL_STATUS
pSpoolStatusTable[]=
{
     SPOOL_STATUS_STARTDOC          ,"StartDoc",
     SPOOL_STATUS_BEGINPAGE         ,"BeginPage",
     SPOOL_STATUS_CANCELLED         ,"Cancelled",
     SPOOL_STATUS_PRINTING          ,"Printing",
     SPOOL_STATUS_ADDJOB            ,"AddJob",
     SPOOL_STATUS_PRINT_FILE        ,"Print_File",
     SPOOL_STATUS_NOTIFY            ,"Notify",
     SPOOL_STATUS_FLUSH_PRINTER     ,"FlushPrinter"
};


typedef struct _DBG_PSPOOL_TYPE_OF_HANDLE
{
    DWORD   TypeOfHandle;
    LPSTR   String;
} DBG_PSPOOL_TYPE_OF_HANDLE, *PDBG_PSPOOL_TYPE_OF_HANDLE;


DBG_PSPOOL_TYPE_OF_HANDLE
pSpoolTypeOfHandleTable[]=
{

    PRINTER_HANDLE_PRINTER,         "Printer",
    PRINTER_HANDLE_REMOTE_DATA,     "RemoteData",
    PRINTER_HANDLE_REMOTE_CALL,     "RemoteCall",
    PRINTER_HANDLE_JOB,             "Job",
    PRINTER_HANDLE_PORT,            "Port",
    PRINTER_HANDLE_DIRECT,          "Direct",
    PRINTER_HANDLE_SERVER,          "Server",
    PRINTER_HANDLE_3XCLIENT,        "Nt3x_Client",
    PRINTER_HANDLE_REMOTE_ADMIN,    "Remote Admin"
};



typedef struct _DBG_WCACHEPRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_WCACHEPRINTER_STATUS, *PDBG_WCACHEPRINTER_STATUS;


DBG_WCACHEPRINTER_STATUS
WCachePrinterStatusTable[]=
{

    EXTRA_STATUS_PENDING_FFPCN  ,"Pending_FFPCN",
    EXTRA_STATUS_DOING_REFRESH  ,"Doing_Refresh"
};


typedef struct _DBG_DEVMODE_FIELDS {
    DWORD   dmField;
    LPSTR   String;
}DBG_DEVMODE_FIELDS;

#define MAX_DEVMODE_FIELDS          14

DBG_DEVMODE_FIELDS DevModeFieldsTable[] =
{
    0x00000001, "dm_orientation",
    0x00000002, "dm_papersize",
    0x00000004, "dm_paperlength",
    0x00000008, "dm_paperwidth",
    0x00000010, "dm_scale",
    0x00000100, "dm_copies",
    0x00000200, "dm_defautsource",
    0x00000400, "dm_printquality",
    0x00000800, "dm_color",
    0x00001000, "dm_duplex",
    0x00002000, "dm_yresolution",
    0x00004000, "dm_ttoption",
    0x00008000, "dm_collate",
    0x00010000, "dm_formname"
};

typedef struct _DBG_PINIDRIVER_FLAGS {
    DWORD   dwDriverFlag;
    LPSTR   String;
} DBG_PINIDRIVER_FLAGS;

DBG_PINIDRIVER_FLAGS pIniDriverFlagsTable[] =
{
    PRINTER_DRIVER_PENDING_DELETION,     "Pending-Deletion"
};


#define MAX_DEVMODE_PAPERSIZES              41

LPSTR DevModePaperSizes[] =
{
           " Letter 8 1/2 x 11 in               ",
           " Letter Small 8 1/2 x 11 in         ",
           " Tabloid 11 x 17 in                 ",
           " Ledger 17 x 11 in                  ",
           " Legal 8 1/2 x 14 in                ",
           " Statement 5 1/2 x 8 1/2 in         ",
           " Executive 7 1/4 x 10 1/2 in        ",
           " A3 297 x 420 mm                    ",
           " A4 210 x 297 mm                    ",
          " A4 Small 210 x 297 mm              ",
          " A5 148 x 210 mm                    ",
          " B4 250 x 354                       ",
          " B5 182 x 257 mm                    ",
          " Folio 8 1/2 x 13 in                ",
          " Quarto 215 x 275 mm                ",
          " 10x14 in                           ",
          " 11x17 in                           ",
          " Note 8 1/2 x 11 in                 ",
          " Envelope #9 3 7/8 x 8 7/8          ",
          " Envelope #10 4 1/8 x 9 1/2         ",
          " Envelope #11 4 1/2 x 10 3/8        ",
          " Envelope #12 4 \276 x 11           ",
          " Envelope #14 5 x 11 1/2            ",
          " C size sheet                       ",
          " D size sheet                       ",
          " E size sheet                       ",
          " Envelope DL 110 x 220mm            ",
          " Envelope C5 162 x 229 mm           ",
          " Envelope C3  324 x 458 mm          ",
          " Envelope C4  229 x 324 mm          ",
          " Envelope C6  114 x 162 mm          ",
          " Envelope C65 114 x 229 mm          ",
          " Envelope B4  250 x 353 mm          ",
          " Envelope B5  176 x 250 mm          ",
          " Envelope B6  176 x 125 mm          ",
          " Envelope 110 x 230 mm              ",
          " Envelope Monarch 3.875 x 7.5 in    ",
          " 6 3/4 Envelope 3 5/8 x 6 1/2 in    ",
          " US Std Fanfold 14 7/8 x 11 in      ",
          " German Std Fanfold 8 1/2 x 12 in   ",
          " German Legal Fanfold 8 1/2 x 13 in "
};




VOID
ExtractPrinterAccess(PNTSD_OUTPUT_ROUTINE Print, DWORD Attribute)
{
    DWORD i = 0;
    if ( Attribute != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterAccessTable)/sizeof(PrinterAccessTable[0])) {
            if (Attribute & PrinterAccessTable[i].Attribute) {
                (*Print)("%s ", PrinterAccessTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractPrinterAttributes(PNTSD_OUTPUT_ROUTINE Print, DWORD Attribute)
{
    DWORD i = 0;
    if ( Attribute != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterAttributeTable)/sizeof(PrinterAttributeTable[0])) {
            if (Attribute & PrinterAttributeTable[i].Attribute) {
                (*Print)("%s ", PrinterAttributeTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractChangeStatus(PNTSD_OUTPUT_ROUTINE Print, ESTATUS eStatus)
{
    DWORD i = 0;
    if ( eStatus != 0 ) {
        (*Print)(" ");
        while (i < sizeof(ChangeStatusTable)/sizeof(ChangeStatusTable[0])) {
            if (eStatus & ChangeStatusTable[i].Attribute) {
                (*Print)("%s ", ChangeStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractExternalPrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(ExternalPrinterStatusTable)/sizeof(ExternalPrinterStatusTable[0])) {
            if (Status & ExternalPrinterStatusTable[i].Status) {
                (*Print)("%s ", ExternalPrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractSpoolerFlags(PNTSD_OUTPUT_ROUTINE  Print, DWORD SpoolerFlags)
{
    DWORD i = 0;
    if ( SpoolerFlags != 0 ) {
        (*Print)(" ");
        while (i < sizeof(SpoolerFlagsTable)/sizeof(SpoolerFlagsTable[0])) {
            if (SpoolerFlags & SpoolerFlagsTable[i].SpoolerFlags) {
                (*Print)("%s ", SpoolerFlagsTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}


VOID
ExtractPrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterStatusTable)/sizeof(PrinterStatusTable[0])) {
            if (Status & PrinterStatusTable[i].Status) {
                (*Print)("%s ", PrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }

}

VOID
ExtractWCachePrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(WCachePrinterStatusTable)/sizeof(WCachePrinterStatusTable[0])) {
            if (Status & WCachePrinterStatusTable[i].Status) {
                (*Print)("%s ", WCachePrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }

}

VOID
ExtractPortStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;

    (*Print)(" ");
    if ( Status != 0 ) {
        while (i < sizeof(PortStatusTable)/sizeof(PortStatusTable[0])) {
            if (Status == PortStatusTable[i].Status) {
                (*Print)("%s ", PortStatusTable[i].String);
            }
            i++;
        }
    } else {

    }
   (*Print)("\n");

}

VOID
ExtractJobStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(JobStatusTable)/sizeof(JobStatusTable[0])) {
            if (Status & JobStatusTable[i].Status) {
                (*Print)("%s ", JobStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpSpoolTypeOfHandle(PNTSD_OUTPUT_ROUTINE Print, DWORD TypeOfHandle)
{
    DWORD i = 0;
    if ( TypeOfHandle != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pSpoolTypeOfHandleTable)/sizeof(pSpoolTypeOfHandleTable[0])) {
            if (TypeOfHandle & pSpoolTypeOfHandleTable[i].TypeOfHandle) {
                (*Print)("%s ", pSpoolTypeOfHandleTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpSpoolStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status  != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pSpoolStatusTable)/sizeof(pSpoolStatusTable[0])) {
            if (Status & pSpoolStatusTable[i].Status) {
                (*Print)("%s ", pSpoolStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}


VOID
ExtractWSpoolStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(WSpoolStatusTable)/sizeof(WSpoolStatusTable[0])) {
            if (Status & WSpoolStatusTable[i].Status) {
                (*Print)("%s ", WSpoolStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpIniPortStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pIniPortStatusTable)/sizeof(pIniPortStatusTable[0])) {
            if (Status & pIniPortStatusTable[i].Status) {
                (*Print)("%s ", pIniPortStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpIniDriverFlags(PNTSD_OUTPUT_ROUTINE Print, DWORD Flags)
{
    DWORD i = 0;
    if ( Flags != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pIniDriverFlagsTable)/sizeof(pIniDriverFlagsTable[0])) {
            if (Flags & pIniDriverFlagsTable[i].dwDriverFlag) {
                (*Print)("%s ", pIniDriverFlagsTable[i].String);
            }
            i++;
        }        
    }

    (*Print)("\n");
}



// All of the primary spooler structures are identified by an
// "signature" field which is the first DWORD in the structure
// This function examines the signature field in the structure
// and appropriately dumps out the contents of the structure in
// a human-readable format.

BOOL
DbgDumpStructure(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, UINT_PTR pData)
{

    INIDRIVER IniDriver;
    INIENVIRONMENT IniEnvironment;
    INIPRINTER IniPrinter;
    INIPRINTPROC IniPrintProc;
    ININETPRINT IniNetPrint;
    INIMONITOR IniMonitor;
    INIPORT IniPort;
    WINIPORT WIniPort;
    INIFORM IniForm;
    INIJOB  IniJob;
    SPOOL   Spool;
    WSPOOL  WSpool;
    SHADOWFILE  ShadowFile;
    SHADOWFILE_2  ShadowFile2;
    PRINTHANDLE PrintHandle;
    DWORD   Signature;
    INISPOOLER IniSpooler;
    INIVERSION IniVersion;
    WCACHEINIPRINTEREXTRA WCacheIniPrinterExtra;

    movestruct(pData,&Signature, DWORD);
    switch (Signature) {

    case ISP_SIGNATURE: // dump INISPOOLER
        movestruct(pData, &IniSpooler, INISPOOLER);
        DbgDumpIniSpooler(hCurrentProcess, Print, (PINISPOOLER)&IniSpooler);
        break;

    case IPP_SIGNATURE: // dump INIPRINTPROC structure
        movestruct(pData, &IniPrintProc, INIPRINTPROC);
        DbgDumpIniPrintProc(hCurrentProcess, Print, (PINIPRINTPROC)&IniPrintProc);
        break;

    case ID_SIGNATURE: //  dump INIDRIVER structure
        movestruct(pData, &IniDriver, INIDRIVER);
        DbgDumpIniDriver(hCurrentProcess, Print, (PINIDRIVER)&IniDriver);
        break;

    case IE_SIGNATURE: //   dump INIENVIRONMENT structure
        movestruct(pData, &IniEnvironment, INIENVIRONMENT);
        DbgDumpIniEnvironment(hCurrentProcess, Print, (PINIENVIRONMENT)&IniEnvironment);
        break;

    case IV_SIGNATURE: //   dump INIVERSION structure
        movestruct(pData, &IniVersion, INIVERSION);
        DbgDumpIniVersion(hCurrentProcess, Print, (PINIVERSION)&IniVersion);
        break;

    case IP_SIGNATURE:
        movestruct(pData, &IniPrinter, INIPRINTER);
        DbgDumpIniPrinter(hCurrentProcess, Print, (PINIPRINTER)&IniPrinter);
        break;

    case WCIP_SIGNATURE:
        movestruct(pData, &WCacheIniPrinterExtra, WCACHEINIPRINTEREXTRA);
        DbgDumpWCacheIniPrinter(hCurrentProcess, Print, (PWCACHEINIPRINTEREXTRA)&WCacheIniPrinterExtra);
        break;

    case IN_SIGNATURE:
        movestruct(pData, &IniNetPrint, ININETPRINT);
        DbgDumpIniNetPrint(hCurrentProcess, Print, (PININETPRINT)&IniNetPrint);
        break;

    case IMO_SIGNATURE:
        movestruct(pData, &IniMonitor, INIMONITOR);
        DbgDumpIniMonitor(hCurrentProcess, Print, (PINIMONITOR)&IniMonitor);
        break;

    case IPO_SIGNATURE:
        movestruct(pData, &IniPort, INIPORT);
        DbgDumpIniPort(hCurrentProcess, Print, (PINIPORT)&IniPort);
        break;

    case WIPO_SIGNATURE:
        movestruct(pData, &WIniPort, WINIPORT);
        DbgDumpWIniPort(hCurrentProcess, Print, (PWINIPORT)&WIniPort);
        break;

    case IFO_SIGNATURE:
        movestruct(pData, &IniForm, INIFORM);
        DbgDumpIniForm(hCurrentProcess, Print, (PINIFORM)&IniForm);
        break;

    case IJ_SIGNATURE:
        movestruct(pData, &IniJob, INIJOB);
        DbgDumpIniJob(hCurrentProcess, Print, (PINIJOB)&IniJob);
        break;

    case SJ_SIGNATURE:
        movestruct(pData, &Spool, SPOOL);
        DbgDumpSpool(hCurrentProcess, Print, (PSPOOL)&Spool);
        break;

    case WSJ_SIGNATURE:
        movestruct(pData, &WSpool, WSPOOL);
        DbgDumpWSpool(hCurrentProcess, Print, (PWSPOOL)&WSpool);
        break;

    case SF_SIGNATURE:
        movestruct(pData, &ShadowFile, SHADOWFILE);
        DbgDumpShadowFile(hCurrentProcess, Print, (PSHADOWFILE)&ShadowFile);
        break;

    case SF_SIGNATURE_2:
        movestruct(pData, &ShadowFile2, SHADOWFILE_2);
        DbgDumpShadowFile2(hCurrentProcess, Print, (PSHADOWFILE_2)&ShadowFile2);
        break;

    case PRINTHANDLE_SIGNATURE:
        movestruct(pData, &PrintHandle, PRINTHANDLE);
        DbgDumpPrintHandle(hCurrentProcess, Print, (PPRINTHANDLE)&PrintHandle);
        break;


    default:
        // Unknown signature -- no data to dump
        (*Print)("Warning: Unknown Signature\n");
        break;
    }
    (*Print)("\n");

    return TRUE;
}

BOOL
DbgDumpIniEntry(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIENTRY pIniEntry)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniEntry\n");
    (*Print)("DWORD         signature                       %d\n", pIniEntry->signature);
    (*Print)("PINIENTRY     pNext                           %p\n", pIniEntry->pNext);

    movestr(pIniEntry->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

    return TRUE;
}

BOOL
DbgDumpIniPrintProc(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPRINTPROC pIniPrintProc)
{
   WCHAR Buffer[MAX_PATH+1];
   DWORD i = 0;

   (*Print)("IniPrintProc\n");
   (*Print)("DWORD          signature                       %d\n", pIniPrintProc->signature);
   (*Print)("PINIPRINTPROC  pNext                           %x\n", pIniPrintProc->pNext);
   (*Print)("DWORD          cRef                            %d\n", pIniPrintProc->cRef);


    movestr(pIniPrintProc->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
   (*Print)("DWORD          pName                           %ws\n", Buffer);

    movestr(pIniPrintProc->pDLLName, Buffer, sizeof(WCHAR)*MAX_PATH);
   (*Print)("LPWSTR         pDLLName                        %ws\n", Buffer);
   (*Print)("LPWSTR         cbDatatypes                     %d\n", pIniPrintProc->cbDatatypes);
   (*Print)("LPWSTR         cDatatypes                      %d\n", pIniPrintProc->cDatatypes);
   for (i = 0; i < pIniPrintProc->cDatatypes; i++ ) {
       (*Print)("   Each of the Strings here \n");
   }
   (*Print)("HANDLE         hLibrary                        0x%.8x\n", pIniPrintProc->hLibrary);
   (*Print)("FARPROC        Install                         0x%.8x\n", pIniPrintProc->Install);
   (*Print)("FARPROC        EnumDatatypes                   0x%.8x\n", pIniPrintProc->EnumDatatypes);
   (*Print)("FARPROC        Open                            0x%.8x\n", pIniPrintProc->Open);
   (*Print)("FARPROC        Print                           0x%.8x\n", pIniPrintProc->Print);
   (*Print)("FARPROC        Close                           0x%.8x\n", pIniPrintProc->Close);
   (*Print)("FARPROC        Control                         0x%.8x\n", pIniPrintProc->Control);
   (*Print)("CRITICAL_SECTION CriticalSection               0x%.8x\n", pIniPrintProc->CriticalSection);

    return TRUE;
}

BOOL
DbgDumpIniDriver(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIDRIVER pIniDriver)
{
    WCHAR Buffer[MAX_PATH+1];
    WCHAR UnKnown[] = L"Not Initialized";
    WCHAR Kernel[] = L"Kernel Mode";
    WCHAR User[] = L"User Mode";
    SYSTEMTIME SystemTime;

    (*Print)("IniDriver\n");
    (*Print)("DWORD         signature                       %d\n", pIniDriver->signature);
    (*Print)("PINIDRIVER    pNext                           %p\n", pIniDriver->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniDriver->cRef);

     movestr(pIniDriver->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniDriver->pDriverFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDriverFile                     %ws\n", Buffer);

     movestr(pIniDriver->pConfigFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pConfigFile                     %ws\n", Buffer);

     movestr(pIniDriver->pDataFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDataFile                       %ws\n", Buffer);

     movestr(pIniDriver->pHelpFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pHelpFile                       %ws\n", Buffer);

     movestr(pIniDriver->pDependentFiles, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDependentFiles                 %ws\n", Buffer);

     movestr(pIniDriver->pMonitorName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMonitorName                    %ws\n", Buffer);
    (*Print)("PINIMONITOR   pIniLangMonitor                 %p\n", pIniDriver->pIniLangMonitor);

     movestr(pIniDriver->pDefaultDataType, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDefaultDataType                %ws\n", Buffer);

     movestr(pIniDriver->pszzPreviousNames, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszzPreviousNames               %ws\n", Buffer);

    switch (pIniDriver->dwDriverAttributes) {
    case 0:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)UnKnown);
       break;
    case 1:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)Kernel);
       break;
    case 2:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)User);
       break;
    }

    (*Print)("DWORD         cVersion                        %d\n", pIniDriver->cVersion);
    (*Print)("DWORD         dwTempDir                       %d\n", pIniDriver->dwTempDir);

    movestr(pIniDriver->pszMfgName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        Manufacturer                    %ws\n", Buffer);

    movestr(pIniDriver->pszOEMUrl, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        OEM URL                         %ws\n", Buffer);

    movestr(pIniDriver->pszHardwareID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        HardwareID                      %ws\n", Buffer);

    movestr(pIniDriver->pszProvider, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        Provider                        %ws\n", Buffer);

    (*Print)("DWORDLONG     DriverVersion                   %I64x\n",  pIniDriver->dwlDriverVersion);

    if (pIniDriver->ftDriverDate.dwHighDateTime &&
        pIniDriver->ftDriverDate.dwLowDateTime  &&
        FileTimeToSystemTime(&pIniDriver->ftDriverDate, &SystemTime))
    {
        (*Print)("SYSTEMTIME    DriverDate                      %d/%d/%d  %d  %d:%d:%d.%d\n",SystemTime.wYear,
                                                                SystemTime.wMonth,
                                                                SystemTime.wDay,
                                                                SystemTime.wDayOfWeek,
                                                                SystemTime.wHour,
                                                                SystemTime.wMinute,
                                                                SystemTime.wSecond,
                                                                SystemTime.wMilliseconds);
    }
    else
    {
        (*Print)("SYSTEMTIME    DriverDate                      Not initialized\n");
    }

    (*Print)("DWORD         dwDriverFlags                   %08x", pIniDriver->dwDriverFlags);

    ExtractpIniDriverFlags(Print, pIniDriver->dwDriverFlags);
    
    return TRUE;
}

BOOL
DbgDumpIniEnvironment(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIENVIRONMENT pIniEnvironment)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniEnvironment\n");
    (*Print)("DWORD         signature                       %d\n", pIniEnvironment->signature);
    (*Print)("struct _INIENVIRONMENT *pNext                 %p\n", pIniEnvironment->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniEnvironment->cRef);

     movestr(pIniEnvironment->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniEnvironment->pDirectory, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDirectory                      %ws\n", Buffer);

    (*Print)("PINIVERSION   pIniVersion                     %p\n", pIniEnvironment->pIniVersion);
    (*Print)("PINIPRINTPROC pIniPrintProc                   %p\n", pIniEnvironment->pIniPrintProc);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniEnvironment->pIniSpooler);

    return TRUE;
}

BOOL
DbgDumpIniVersion( HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIVERSION pIniVersion )
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniVersion\n");
    (*Print)("DWORD         signature                       %d\n", pIniVersion->signature);
    (*Print)("struct _IniVersion *pNext                     %p\n", pIniVersion->pNext);

     movestr(pIniVersion->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniVersion->szDirectory, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        szDirectory                     %ws\n", Buffer);
    (*Print)("DWORD         cMajorVersion                   %d\n", pIniVersion->cMajorVersion );
    (*Print)("DWORD         cMinorVersion                   %d\n", pIniVersion->cMinorVersion );
    (*Print)("PINIDRIVER    pIniDriver                      %p\n", pIniVersion->pIniDriver );

    return TRUE;
}


BOOL
DbgDumpWCacheIniPrinter(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWCACHEINIPRINTEREXTRA pWCacheIniPrinter)
{
    WCHAR Buffer[MAX_PATH+1];


    (*Print)("WCacheIniPrinterExtra\n");
    (*Print)("DWORD         signature                       %d\n", pWCacheIniPrinter->signature);

    (*Print)("DWORD         cb                              %d\n", pWCacheIniPrinter->cb);

    (*Print)("LPPRINTER_INFO_2 pPI2                         %p\n", pWCacheIniPrinter->pPI2);
    (*Print)("DWORD         cbPI2                           %d\n", pWCacheIniPrinter->cbPI2);

    DbgDumpPI2( hCurrentProcess, Print, (UINT_PTR)pWCacheIniPrinter->pPI2, 1 );

    (*Print)("DWORD         cCacheID                        %d\n", pWCacheIniPrinter->cCacheID );
    (*Print)("DWORD         cRef                            %d\n", pWCacheIniPrinter->cRef );
    (*Print)("DWORD         dwServerVersion                 %x\n", pWCacheIniPrinter->dwServerVersion );
    (*Print)("DWORD         dwTickCount                     %x\n", pWCacheIniPrinter->dwTickCount );
    (*Print)("DWORD         Status                          0x%.8x\n", pWCacheIniPrinter->Status );
    ExtractWCachePrinterStatus( Print, pWCacheIniPrinter->Status );

    return  TRUE;
}



BOOL
DbgDumpIniPrinter(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPRINTER pIniPrinter)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniPrinter\n");
    (*Print)("DWORD         signature                       %d\n", pIniPrinter->signature);

    (*Print)("PINIPRINTER   pNext                           %p\n", pIniPrinter->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniPrinter->cRef);

     movestr(pIniPrinter->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniPrinter->pShareName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pShareName                      %ws\n", Buffer);

    (*Print)("PINIPRINTPROC pIniPrintProc                   %p\n", pIniPrinter->pIniPrintProc);

     movestr(pIniPrinter->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDatatype                       %ws\n", Buffer);

     movestr(pIniPrinter->pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pParameters                     %ws\n", Buffer);

     movestr(pIniPrinter->pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

    (*Print)("PINIDRIVER    pIniDriver                      %p\n", pIniPrinter->pIniDriver);
    (*Print)("DWORD         cbDevMode                       %d\n", pIniPrinter->cbDevMode);
    (*Print)("LPDEVMODE     pDevMode                        %p\n", pIniPrinter->pDevMode);
    (*Print)("DWORD         Priority                        %d\n", pIniPrinter->Priority);
    (*Print)("DWORD         DefaultPriority                 %d\n", pIniPrinter->DefaultPriority);
    (*Print)("DWORD         StartTime                       %d\n", pIniPrinter->StartTime);
    (*Print)("DWORD         UntilTime                       %d\n", pIniPrinter->UntilTime);

     movestr(pIniPrinter->pSepFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pSepFile                        %ws\n", Buffer);

    (*Print)("DWORD         Status                          0x%.8x\n", pIniPrinter->Status);
    ExtractPrinterStatus( Print, pIniPrinter->Status );

     movestr(pIniPrinter->pLocation, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pLocation                       %ws\n", Buffer);


    (*Print)("DWORD         Attributes                      0x%.8x\n",pIniPrinter->Attributes);
    ExtractPrinterAttributes( Print, pIniPrinter->Attributes );

    (*Print)("DWORD         cJobs                           %d\n", pIniPrinter->cJobs);
    (*Print)("DWORD         AveragePPM                      %d\n", pIniPrinter->AveragePPM);
    (*Print)("BOOL          GenerateOnClose                 0x%.8x\n", pIniPrinter->GenerateOnClose);
    (*Print)("PINIPORT      pIniNetPort                     %p\n", pIniPrinter->pIniNetPort);
    (*Print)("PINIJOB       pIniFirstJob                    %p\n", pIniPrinter->pIniFirstJob);
    (*Print)("PINIJOB       pIniLastJob                     %p\n", pIniPrinter->pIniLastJob);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pIniPrinter->pSecurityDescriptor);
    (*Print)("PSPOOL        *pSpool                         %p\n", pIniPrinter->pSpool);

    if ( pIniPrinter->pSpoolDir == NULL ) {

        (*Print)("LPWSTR        pSpoolDir                       %p\n", pIniPrinter->pSpoolDir);

    } else {

        movestr(pIniPrinter->pSpoolDir, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pSpoolDir                       %ws\n", Buffer);
    }

    (*Print)("DWORD         cTotalJobs                      %d\n", pIniPrinter->cTotalJobs);
    (*Print)("DWORD         cTotalBytes.LowPart             %d\n", pIniPrinter->cTotalBytes.LowPart);
    (*Print)("DWORD         cTotalBytes.HighPart            %d\n", pIniPrinter->cTotalBytes.HighPart);
    (*Print)("SYSTEMTIME    stUpTime                        %d/%d/%d  %d  %d:%d:%d.%d\n",pIniPrinter->stUpTime.wYear,
                                                                pIniPrinter->stUpTime.wMonth,
                                                                pIniPrinter->stUpTime.wDay,
                                                                pIniPrinter->stUpTime.wDayOfWeek,
                                                                pIniPrinter->stUpTime.wHour,
                                                                pIniPrinter->stUpTime.wMinute,
                                                                pIniPrinter->stUpTime.wSecond,
                                                                pIniPrinter->stUpTime.wMilliseconds);
    (*Print)("DWORD         MaxcRef                         %d\n", pIniPrinter->MaxcRef);
    (*Print)("DWORD         cTotalPagesPrinted              %d\n", pIniPrinter->cTotalPagesPrinted);
    (*Print)("DWORD         cSpooling                       %d\n", pIniPrinter->cSpooling);
    (*Print)("DWORD         cMaxSpooling                    %d\n", pIniPrinter->cMaxSpooling);
    (*Print)("DWORD         cErrorOutOfPaper                %d\n", pIniPrinter->cErrorOutOfPaper);
    (*Print)("DWORD         cErrorNotReady                  %d\n", pIniPrinter->cErrorNotReady);
    (*Print)("DWORD         cJobError                       %d\n", pIniPrinter->cJobError);
    (*Print)("DWORD         dwLastError                     %d\n", pIniPrinter->dwLastError);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniPrinter->pIniSpooler);
    (*Print)("DWORD         cZombieRef                      %d\n", pIniPrinter->cZombieRef);
    (*Print)("LPBYTE        pExtraData                      %x\n", pIniPrinter->pExtraData);
    (*Print)("DWORD         cChangeID                       %d\n", pIniPrinter->cChangeID);
    (*Print)("DWORD         cPorts                          %d\n", pIniPrinter->cPorts);
    (*Print)("PINIPORT      *ppIniPorts                     %x\n", pIniPrinter->ppIniPorts);
    (*Print)("DWORD         PortStatus                      %d\n", pIniPrinter->PortStatus);
    (*Print)("DWORD         dnsTimeout                      %d\n", pIniPrinter->dnsTimeout);
    (*Print)("DWORD         txTimeout                       %d\n", pIniPrinter->txTimeout);
     movestr(pIniPrinter->pszObjectGUID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszObjectGUID                   %ws\n", Buffer);
    (*Print)("DWORD         DsKeyUpdate                     %x\n", pIniPrinter->DsKeyUpdate);
    (*Print)("DWORD         DsKeyUpdateForeground           %x\n", pIniPrinter->DsKeyUpdateForeground);
     movestr(pIniPrinter->pszDN, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszDN                           %ws\n", Buffer);
     movestr(pIniPrinter->pszCN, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszCN                           %ws\n", Buffer);
    (*Print)("DWORD         cRefIC                          %d\n", pIniPrinter->cRefIC);
    (*Print)("DWORD         dwAction                        %d\n", pIniPrinter->dwAction);
    (*Print)("BOOL          bDsPendingDeletion              %d\n", pIniPrinter->bDsPendingDeletion);

    return TRUE;
}


BOOL
DbgDumpIniNetPrint(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PININETPRINT pIniNetPrint)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniNetPrint\n");
    (*Print)("DWORD         signature                       %d\n", pIniNetPrint->signature);
    (*Print)("PININETPRINT  *pNext                          %p\n", pIniNetPrint->pNext);
    (*Print)("DWORD         TickCount                       %d\n", pIniNetPrint->TickCount);

     movestr(pIniNetPrint->pDescription, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDescription                    %ws\n", Buffer);

     movestr(pIniNetPrint->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniNetPrint->pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

    return TRUE;
}


BOOL
DbgDumpIniMonitor(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIMONITOR pIniMonitor)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniMonitor\n");
    (*Print)("DWORD         signature                       %d\n", pIniMonitor->signature);
    (*Print)("PINIMONITOR   pNext                           %p\n", pIniMonitor->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniMonitor->cRef);

     movestr(pIniMonitor->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniMonitor->pMonitorDll, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMonitorDll                     %ws\n", Buffer);

    (*Print)("HANDLE        hModule                         %p\n", pIniMonitor->hModule);
    (*Print)("PMONITORINIT  pMonitorInit                    %p\n", pIniMonitor->pMonitorInit);
    (*Print)("HANDLE        hMonitor                        %p\n", pIniMonitor->hMonitor);
    (*Print)("BOOL          bUplevel                        %%.8x\n", pIniMonitor->bUplevel);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniMonitor->pIniSpooler);

    return TRUE;
}

BOOL
DbgDumpIniPort(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPORT pIniPort)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniPort\n");
    (*Print)("DWORD         signature                       %d\n", pIniPort->signature);
    (*Print)("struct        _INIPORT *pNext                 %p\n", pIniPort->pNext);
    (*Print)("DWORD         cRef                            0x%.8x\n", pIniPort->cRef);

     movestr(pIniPort->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);
    (*Print)("HANDLE        hProc                           0x%.8x\n", pIniPort->hProc);
    (*Print)("DWORD         Status                          0x%.8x\n", pIniPort->Status);
    ExtractpIniPortStatus( Print, pIniPort->Status);
    ExtractPortStatus( Print, pIniPort->PrinterStatus);

    (*Print)("HANDLE        Semaphore                       0x%.8x\n", pIniPort->Semaphore);
    (*Print)("PINIJOB       pIniJob                         %p\n", pIniPort->pIniJob);
    (*Print)("DWORD         cJobs                           %d\n", pIniPort->cJobs);
    (*Print)("DWORD         cPrinters                       %d\n", pIniPort->cPrinters);
    (*Print)("PINIPRINTER   *ppIniPrinter                   %p\n", pIniPort->ppIniPrinter);

    (*Print)("PINIMONITOR   pIniMonitor                     %p\n", pIniPort->pIniMonitor);
    (*Print)("PINIMONITOR   pIniLangMonitor                 %p\n", pIniPort->pIniLangMonitor);
    (*Print)("HANDLE        hWaitToOpenOrClose              0x%.8x\n", pIniPort->hWaitToOpenOrClose);
    (*Print)("HANDLE        hEvent                          0x%.8x\n", pIniPort->hEvent);
    (*Print)("HANDLE        hPort                           0x%.8x\n", pIniPort->hPort);
    (*Print)("HANDLE        Ready                           0x%.8x\n", pIniPort->Ready);
    (*Print)("HANDLE        hPortThread                     0x%.8x\n", pIniPort->hPortThread);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniPort->pIniSpooler);
    (*Print)("DWORD         InCriticalSection               %d\n", pIniPort->InCriticalSection);

    return TRUE;
}

BOOL
DbgDumpWIniPort(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWINIPORT pWIniPort)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("WIniPort\n");
    (*Print)("DWORD         signature                       %d\n", pWIniPort->signature);
    (*Print)("DWORD         cb                              %d\n", pWIniPort->cb);
    (*Print)("struct        _WIniPort *pNext                 %p\n", pWIniPort->pNext);

     movestr(pWIniPort->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

    return TRUE;
}


BOOL
DbgDumpIniForm(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIFORM pIniForm)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniForm\n");
    (*Print)("DWORD         signature                       %d\n", pIniForm->signature);
    (*Print)("struct        _INIFORM *pNext                 %p\n", pIniForm->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniForm->cRef);

    movestr(pIniForm->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %p %ws\n", pIniForm->pName, Buffer );

    (*Print)("SIZEL         Size                            cx %d cy %d\n", pIniForm->Size.cx, pIniForm->Size.cy);
    (*Print)("RECTL         ImageableArea                   left %d right %d top %d bottom %d\n",
                                                             pIniForm->ImageableArea.left,
                                                             pIniForm->ImageableArea.right,
                                                             pIniForm->ImageableArea.top,
                                                             pIniForm->ImageableArea.bottom);
    (*Print)("DWORD         Type                            0x%.8x", pIniForm->Type);

    if ( pIniForm->Type & FORM_BUILTIN )
        (*Print)(" FORM_BUILTIN\n");
    else
        (*Print)(" FORM_USERDEFINED\n");

    (*Print)("DWORD         cFormOrder                      %d\n", pIniForm->cFormOrder);

    return TRUE;
}

BOOL
DbgDumpIniSpooler(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINISPOOLER pIniSpooler)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniSpooler\n" );
    (*Print)("DWORD         signature                       %d\n", pIniSpooler->signature);
    (*Print)("PINISPOOLER   pIniNextSpooler                 %p\n", pIniSpooler->pIniNextSpooler);
    (*Print)("DWORD         cRef                            %d\n",     pIniSpooler->cRef);
    movestr(pIniSpooler->pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMachineName                    %ws\n", Buffer);
    (*Print)("DWORD         cOtherNames                     %d\n",     pIniSpooler->cOtherNames);
    (*Print)("(LPWSTR *)    ppszOtherNames                  %p\n", pIniSpooler->ppszOtherNames);
    movestr(pIniSpooler->pDir, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDir                            %ws\n", Buffer);
    (*Print)("PINIPRINTER   pIniPrinter                     %p\n", pIniSpooler->pIniPrinter);
    (*Print)("PINIENVIRONMENT pIniEnvironment               %p\n", pIniSpooler->pIniEnvironment);
    (*Print)("PINIMONITOR   pIniMonitor                     %p\n", pIniSpooler->pIniMonitor);
    (*Print)("PINIPORT      pIniPort                        %p\n", pIniSpooler->pIniPort);
    (*Print)("PSHARED       pShared                         %p\n", pIniSpooler->pShared);
    (*Print)("PININETPRINT  pIniNetPrint                    %p\n", pIniSpooler->pIniNetPrint);
    (*Print)("PSPOOL        pSpool                          %p\n", pIniSpooler->pSpool);
    movestr(pIniSpooler->pDefaultSpoolDir, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDefaultSpoolDir                %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryMonitors, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryMonitors             %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryEnvironments, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryEnvironments         %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryEventLog, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryEventLog             %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryProviders, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryProviders            %ws\n", Buffer);
    movestr(pIniSpooler->pszEventLogMsgFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszEventLogMsgFile              %ws\n", Buffer);
    (*Print)("PSHARE_INFO_2 pDriversShareInfo               %p\n", pIniSpooler->pDriversShareInfo);
    movestr(pIniSpooler->pszDriversShare, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszDriversShare                 %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryForms, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryForms                %ws\n", Buffer);
    (*Print)("DWORD         SpoolerFlags                    %d\n", pIniSpooler->SpoolerFlags );
    ExtractSpoolerFlags( Print, pIniSpooler->SpoolerFlags );
    (*Print)("FARPROC       pfnReadRegistryExtra            0x%.8x\n", pIniSpooler->pfnReadRegistryExtra );
    (*Print)("FARPROC       pfnWriteRegistryExtra           0x%.8x\n", pIniSpooler->pfnWriteRegistryExtra );
    (*Print)("FARPROC       pfnFreePrinterExtra             0x%.8x\n", pIniSpooler->pfnFreePrinterExtra );
    (*Print)("DWORD         cEnumerateNetworkPrinters       %d\n", pIniSpooler->cEnumerateNetworkPrinters );
    (*Print)("DWORD         cAddNetPrinters                 %d\n", pIniSpooler->cAddNetPrinters );
    (*Print)("DWORD         cFormOrderMax                   %d\n", pIniSpooler->cFormOrderMax );
    (*Print)("HKEY          hckRoot                         %p\n", pIniSpooler->hckRoot );
    (*Print)("HKEY          hckPrinters                     %p\n", pIniSpooler->hckPrinters );
    (*Print)("DWORD         cFullPrintingJobs               %d\n", pIniSpooler->cFullPrintingJobs );
    (*Print)("DWORD         hEventNoPrintingJobs            %p\n", pIniSpooler->hEventNoPrintingJobs );
    (*Print)("HKEY          hJobIdMap                       %p\n", pIniSpooler->hJobIdMap );
    (*Print)("DWORD         dwEventLogging                  %d\n", pIniSpooler->dwEventLogging );
    (*Print)("BOOL          bEnableNetPopups                %d\n", pIniSpooler->bEnableNetPopups );
    (*Print)("DWORD         dwJobCompletionTimeout          %d\n", pIniSpooler->dwJobCompletionTimeout );
    (*Print)("DWORD         dwBeepEnabled                   %d\n", pIniSpooler->dwBeepEnabled );
    (*Print)("HKEY          bEnableNetPopupToComputer       %d\n", pIniSpooler->bEnableNetPopupToComputer );
    (*Print)("HKEY          bEnableRetryPopups              %d\n", pIniSpooler->bEnableRetryPopups );
    movestr(pIniSpooler->pszClusterGUID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszClusterGUID                  %ws\n", Buffer);
    (*Print)("HKEY          hClusterToken                   %p\n", pIniSpooler->hClusterToken );
    (*Print)("DWORD         dwRestartJobOnPoolTimeout       %p\n", pIniSpooler->dwRestartJobOnPoolTimeout );
    (*Print)("DWORD         bRestartJobOnPoolEnabled        %p\n", pIniSpooler->bRestartJobOnPoolEnabled );
    (*Print)("DWORD         bImmortal                       %p\n", pIniSpooler->bImmortal );
    movestr(pIniSpooler->pszFullMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszFullMachineName              %ws\n", Buffer);
    return TRUE;
}

BOOL
DbgDumpIniJob(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIJOB pIniJob)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniJob\n");
    (*Print)("DWORD           signature                     %d\n", pIniJob->signature);
    (*Print)("PINIJOB         pIniNextJob                   %p\n", pIniJob->pIniNextJob);
    (*Print)("PINIJOB         pIniPrevJob                   %p\n", pIniJob->pIniPrevJob);
    (*Print)("DWORD           cRef                          %d\n", pIniJob->cRef);
    (*Print)("DWORD           Status                        0x%.8x\n", pIniJob->Status);
    ExtractJobStatus( Print, pIniJob->Status );

    (*Print)("DWORD           JobId                         %d\n", pIniJob->JobId);
    (*Print)("DWORD           Priority                      %d\n", pIniJob->Priority);

     movestr(pIniJob->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pIniJob->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pIniJob->pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pMachineName                  %ws\n", Buffer);

     movestr(pIniJob->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pIniJob->pOutputFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pOutputFile                   %ws\n", Buffer);

    (*Print)("PINIPRINTER     pIniPrinter                   %p\n", pIniJob->pIniPrinter);
    (*Print)("PINIDRIVER      pIniDriver                    %p\n", pIniJob->pIniDriver);
    (*Print)("LPDEVMODE       pDevMode                      %p\n", pIniJob->pDevMode);
    (*Print)("PINIPRINTPROC   pIniPrintProc                 %p\n", pIniJob->pIniPrintProc);

     movestr(pIniJob->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pIniJob->pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    (*Print)("SYSTEMTIME      Submitted                     %d/%d/%d  %d  %d:%d:%d.%d\n",pIniJob->Submitted.wYear,
                                                                pIniJob->Submitted.wMonth,
                                                                pIniJob->Submitted.wDay,
                                                                pIniJob->Submitted.wDayOfWeek,
                                                                pIniJob->Submitted.wHour,
                                                                pIniJob->Submitted.wMinute,
                                                                pIniJob->Submitted.wSecond,
                                                                pIniJob->Submitted.wMilliseconds);
//    (*Print)("DWORD           StartPrintingTickCount        %d\n", pIniJob->StartPrintingTickCount );
    (*Print)("DWORD           Time                          %d\n", pIniJob->Time);
    (*Print)("DWORD           StartTime                     %d\n", pIniJob->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pIniJob->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pIniJob->Size);
    (*Print)("HANDLE          hWriteFile                    0x%.8x\n", pIniJob->hWriteFile);

     movestr(pIniJob->pStatus, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pStatus                       %ws\n", Buffer);

    (*Print)("PBOOL           pBuffer                       %p\n", pIniJob->pBuffer);
    (*Print)("DWORD           cbBuffer                      %d\n", pIniJob->cbBuffer);
    (*Print)("HANDLE          WaitForRead                   0x%.8x\n", pIniJob->WaitForRead);
    (*Print)("HANDLE          WaitForWrite                  0x%.8x\n", pIniJob->WaitForWrite);
    (*Print)("HANDLE          StartDocComplete              0x%.8x\n", pIniJob->StartDocComplete);
    (*Print)("DWORD           StartDocError                 0x%.8x\n", pIniJob->StartDocError);
    (*Print)("PINIPORT        pIniPort                      %p\n", pIniJob->pIniPort);
    (*Print)("HANDLE          hToken                        0x%.8x\n", pIniJob->hToken);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pIniJob->pSecurityDescriptor);
    (*Print)("DWORD           cPagesPrinted                 %d\n", pIniJob->cPagesPrinted);
    (*Print)("DWORD           cPages                        %d\n", pIniJob->cPages);
    (*Print)("DWORD           dwJobNumberOfPagesPerSide     %d\n", pIniJob->dwJobNumberOfPagesPerSide);
    (*Print)("DWORD           dwDrvNumberOfPagesPerSide     %d\n", pIniJob->dwDrvNumberOfPagesPerSide);
    (*Print)("DWORD           cLogicalPagesPrinted          %d\n", pIniJob->cLogicalPagesPrinted);
    (*Print)("DWORD           cLogicalPages                 %d\n", pIniJob->cLogicalPages);
    (*Print)("BOOL            GenerateOnClose               0x%.8x\n", pIniJob->GenerateOnClose);
    (*Print)("DWORD           cbPrinted                     %d\n", pIniJob->cbPrinted);
    (*Print)("DWORD           NextJobId                     %d\n", pIniJob->NextJobId);
    (*Print)("PINIJOB         pCurrentIniJob                %p\n", pIniJob->pCurrentIniJob);
    (*Print)("DWORD           dwJobControlsPending          %d\n", pIniJob->dwJobControlsPending);
    (*Print)("DWORD           dwReboots                     %d\n", pIniJob->dwReboots);
    (*Print)("DWORD           dwValidSize                   %d\n", pIniJob->dwValidSize);
    (*Print)("DWORD           bWaitForEnd                   %d\n", pIniJob->bWaitForEnd);
    (*Print)("DWORD           WaitForSeek                   %d\n", pIniJob->WaitForSeek);
    (*Print)("DWORD           bWaitForSeek                  %d\n", pIniJob->bWaitForSeek);
    (*Print)("DWORD           dwAlert                       %d\n", pIniJob->dwAlert);

    movestr(pIniJob->pszSplFileName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pszSplFileName                %ws\n", Buffer);

    (*Print)("HANDLE          hFileItem                     0x%.8x\n", pIniJob->hFileItem);
    (*Print)("DWORD           AddJobLevel                   %d\n", pIniJob->AddJobLevel);

    return TRUE;
}

BOOL
DbgDumpProvidor(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, LPPROVIDOR pProvidor)
{
    WCHAR Buffer[MAX_PATH+1];

    movestr(pProvidor->lpName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR         ProvidorName                   %ws\n", Buffer);
    (*Print)("HANDLE         hModule                        %p\n", pProvidor->hModule);

    return TRUE;
}


BOOL
DbgDumpSpool(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSPOOL pSpool)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("Spool - LocalSpl Handle\n");
    (*Print)("DWORD           signature                     %d\n", pSpool->signature);
    (*Print)("struct _SPOOL  *pNext                         %p\n", pSpool->pNext);
    (*Print)("DWORD           cRef                          %d\n", pSpool->cRef);

     movestr(pSpool->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pName                         %ws\n", Buffer);

     movestr(pSpool->pFullMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pFullMachineName              %ws\n", Buffer);

     movestr(pSpool->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n",    Buffer);
    (*Print)("PINIPRINTPROC   pIniPrintProc                 %p\n", pSpool->pIniPrintProc);
    (*Print)("LPDEVMODE       pDevMode                      %p\n", pSpool->pDevMode);
    (*Print)("PINIPRINTER     pIniPrinter                   %p\n", pSpool->pIniPrinter);
    (*Print)("PINIPORT        pIniPort                      %p\n", pSpool->pIniPort);
    (*Print)("PINIJOB         pIniJob                       %p\n", pSpool->pIniJob);
    (*Print)("DWORD           TypeofHandle                  %d\n", pSpool->TypeofHandle);
    ExtractpSpoolTypeOfHandle( Print, pSpool->TypeofHandle);

    (*Print)("PINIPORT        pIniNetPort                   %p\n", pSpool->pIniNetPort);
    (*Print)("HANDLE          hPort                         %p\n", pSpool->hPort);
    (*Print)("DWORD           Status                        %d\n", pSpool->Status);
    ExtractpSpoolStatus( Print, pSpool->Status);

    (*Print)("ACCESS_MASK     GrantedAccess                 %p\n", (DWORD)pSpool->GrantedAccess);
    (*Print)("DWORD           ChangeFlags                   %p\n", pSpool->ChangeFlags);
    (*Print)("DWORD           WaitFlags                     %x\n", pSpool->WaitFlags);
    (*Print)("PDWORD          pChangeFlags                  %p\n", pSpool->pChangeFlags);
    (*Print)("HANDLE          ChangeEvent                   %d\n", pSpool->ChangeEvent);
    (*Print)("DWORD           OpenPortError                 %x\n", pSpool->OpenPortError);
    (*Print)("HANDLE          hNotify                       %p\n", pSpool->hNotify);
    (*Print)("ESTATUS         eStatus                       %d\n", pSpool->eStatus);
    (*Print)("pIniSpooler     pIniSpooler                   %p\n", pSpool->pIniSpooler);
    (*Print)("PINIXCV         pIniXcv                       %p\n", pSpool->pIniXcv);
     movestr(pSpool->SplClientInfo1.pUserName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUserName                     %ws\n",    Buffer);
     movestr(pSpool->SplClientInfo1.pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pMachineName                  %ws\n",    Buffer);

    return TRUE;
}


BOOL
DbgDumpWSpool(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWSPOOL pWSpool)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("WSpool - Win32Spl Handle\n");
    (*Print)("DWORD           signature                     %d\n", pWSpool->signature);
    (*Print)("struct _WSPOOL  *pNext                        %p\n", pWSpool->pNext);
    (*Print)("struct _WSPOOL  *pPrev                        %p\n", pWSpool->pPrev);
    (*Print)("DWORD           cRef                          %d\n", pWSpool->cRef);

     Buffer[0] = L'\0';
     movestr(pWSpool->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pName                         %ws\n", Buffer);
     Buffer[0] = L'\0';

    (*Print)("DWORD           Type                          %d\n", pWSpool->Type);

    if ( pWSpool->Type == SJ_WIN32HANDLE )
        (*Print)(" SJ_WIN32HANDLE\n");

    if ( pWSpool->Type == LM_HANDLE )
        (*Print)(" LM_HANDLE\n");

    (*Print)("HANDLE          RpcHandle                     %p\n", pWSpool->RpcHandle);

     movestr(pWSpool->pServer, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pServer                       %ws\n", Buffer);
     Buffer[0] = L'\0';

     movestr(pWSpool->pShare, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pShare                        %ws\n", Buffer);
     Buffer[0] = L'\0';

    (*Print)("HANDLE          hFile                         %p\n", pWSpool->hFile);
    (*Print)("DWORD           Status                        %d\n", pWSpool->Status);
    ExtractWSpoolStatus( Print, pWSpool->Status );

    (*Print)("DWORD           RpcError                      %d\n", pWSpool->RpcError);
    (*Print)("LMNOTIFY        LMNotify                      %p %p %p\n", pWSpool->LMNotify.ChangeEvent,
                                                                         pWSpool->LMNotify.hNotify,
                                                                         pWSpool->LMNotify.fdwChangeFlags );

    (*Print)("HANDLE          hIniSpooler                   %p\n", pWSpool->hIniSpooler );
    (*Print)("HANDLE          hSplPrinter                   %p\n", pWSpool->hSplPrinter );
    (*Print)("HANDLE          hToken                        %p\n", pWSpool->hToken );

     movestr(pWSpool->PrinterDefaults.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          PrinterDefaults.pDatatype     %ws\n",    Buffer);
    Buffer[0] = L'\0';
    (*Print)("LPDEVMODE       PrinterDefaults.pDevMode      %p\n", pWSpool->PrinterDefaults.pDevMode);
    (*Print)("ACCESS_MASK     PrinterDefaults.DesiredAccess %x\n", pWSpool->PrinterDefaults.DesiredAccess);
    ExtractPrinterAccess( Print, pWSpool->PrinterDefaults.DesiredAccess);
    (*Print)("HANDLE          hWaitValidHandle              %p\n", pWSpool->hWaitValidHandle );
    (*Print)("BOOL            bNt3xServer                   %d\n", pWSpool->bNt3xServer);

    return TRUE;
}



BOOL
DbgDumpShadowFile(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSHADOWFILE pShadowFile)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("ShadowFile\n");
    (*Print)("DWORD           signature                     %d\n", pShadowFile->signature);
    (*Print)("DWORD           Status                        0x%.8x\n", pShadowFile->Status);
    (*Print)("DWORD           JobId                         %d\n", pShadowFile->JobId);
    (*Print)("DWORD           Priority                      %d\n", pSha